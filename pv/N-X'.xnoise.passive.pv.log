File "pv/N-X'.xnoise.passive.pv", line 214, characters 7-8:
Warning: identifier ck rebound.
File "pv/N-X'.xnoise.passive.pv", line 223, characters 7-8:
Warning: identifier ck rebound.
File "pv/N-X'.xnoise.passive.pv", line 224, characters 7-8:
Warning: identifier cs rebound.
File "pv/N-X'.xnoise.passive.pv", line 224, character 36:
Warning: identifier h rebound.
File "pv/N-X'.xnoise.passive.pv", line 254, characters 6-7:
Warning: identifier ss rebound.
File "pv/N-X'.xnoise.passive.pv", line 255, characters 6-7:
Warning: identifier ss rebound.
File "pv/N-X'.xnoise.passive.pv", line 260, characters 6-7:
Warning: identifier ss rebound.
File "pv/N-X'.xnoise.passive.pv", line 261, characters 6-7:
Warning: identifier ss rebound.
File "pv/N-X'.xnoise.passive.pv", line 267, character 6:
Warning: identifier e rebound.
File "pv/N-X'.xnoise.passive.pv", line 268, characters 6-7:
Warning: identifier ne rebound.
File "pv/N-X'.xnoise.passive.pv", line 269, characters 6-7:
Warning: identifier ss rebound.
File "pv/N-X'.xnoise.passive.pv", line 271, characters 6-7:
Warning: identifier ss rebound.
File "pv/N-X'.xnoise.passive.pv", line 272, characters 6-7:
Warning: identifier ss rebound.
File "pv/N-X'.xnoise.passive.pv", line 277, character 6:
Warning: identifier m rebound.
File "pv/N-X'.xnoise.passive.pv", line 278, characters 7-8:
Warning: identifier ss rebound.
File "pv/N-X'.xnoise.passive.pv", line 278, characters 26-27:
Warning: identifier nm rebound.
File "pv/N-X'.xnoise.passive.pv", line 280, characters 6-7:
Warning: identifier ss rebound.
File "pv/N-X'.xnoise.passive.pv", line 283, characters 7-8:
Warning: identifier ss rebound.
File "pv/N-X'.xnoise.passive.pv", line 283, characters 26-35:
Warning: identifier ciphertext rebound.
File "pv/N-X'.xnoise.passive.pv", line 285, characters 6-7:
Warning: identifier hs rebound.
File "pv/N-X'.xnoise.passive.pv", line 296, characters 6-7:
Warning: identifier re rebound.
File "pv/N-X'.xnoise.passive.pv", line 297, characters 6-7:
Warning: identifier ss rebound.
File "pv/N-X'.xnoise.passive.pv", line 299, characters 6-7:
Warning: identifier ss rebound.
File "pv/N-X'.xnoise.passive.pv", line 300, characters 6-7:
Warning: identifier ss rebound.
File "pv/N-X'.xnoise.passive.pv", line 305, characters 7-8:
Warning: identifier ss rebound.
File "pv/N-X'.xnoise.passive.pv", line 305, characters 26-27:
Warning: identifier me rebound.
File "pv/N-X'.xnoise.passive.pv", line 305, characters 40-45:
Warning: identifier valid1 rebound.
File "pv/N-X'.xnoise.passive.pv", line 306, characters 6-7:
Warning: identifier rm rebound.
File "pv/N-X'.xnoise.passive.pv", line 308, characters 6-7:
Warning: identifier ss rebound.
File "pv/N-X'.xnoise.passive.pv", line 311, characters 7-8:
Warning: identifier ss rebound.
File "pv/N-X'.xnoise.passive.pv", line 313, characters 13-14:
Warning: identifier hs rebound.
File "pv/N-X'.xnoise.passive.pv", line 388, characters 8-9:
Warning: identifier hs rebound.
File "pv/N-X'.xnoise.passive.pv", line 417, characters 8-9:
Warning: identifier hs rebound.
Linear part:
dhexp_real(b,dhexp_real(a,g)) = dhexp_real(a,dhexp_real(b,g))
Completing equations...
Completed equations:
dhexp_real(b,dhexp_real(a,g)) = dhexp_real(a,dhexp_real(b,g))
Convergent part: No equation.
Process 0 (that is, the initial process):
{1}out(pub, (key_s(charlie),key_m(charlie)));
{2}!
{3}new sid: sessionid;
(
    {4}let me: principal = alice in
    {5}let them: principal = bob in
    {6}let sid_1: sessionid = sid in
    {7}let s: keypair = keypairpack(empty,empty) in
    {8}let m: keypair = keypairpack(empty,empty) in
    {9}out(pub, (getpublickey(s),getpublickey(m)));
    (
        {10}let e: keypair = keypairpack(empty,empty) in
        {11}let basis: key = key_s(them) in
        {12}let public_key: key = catch-fail(dhexp(basis,validkey(g))) in
        {13}let v: bool = not-caught-fail(public_key) in
        {14}let rs: key = getpublickey((if v then keypairpack(validkey(public_key),basis) else fail-any)) in
        {15}let basis_1: key = key_m(them) in
        {16}let public_key_1: key = catch-fail(dhexp(basis_1,validkey(g))) in
        {17}let v_1: bool = not-caught-fail(public_key_1) in
        {18}let rm: key = getpublickey((if v_1 then keypairpack(validkey(public_key_1),basis_1) else fail-any)) in
        {19}let re: key = empty in
        {20}let prologue: bitstring = empty in
        {21}let psk: key = empty in
        {22}let protocol_name: bitstring = somename in
        {23}let h: bitstring = hash(protocol_name,empty) in
        {24}let ck: key = h in
        {25}let k: key = empty in
        {26}let cs: cipherstate = cipherstatepack(k,minnonce) in
        {27}let ss: symmetricstate = symmetricstatepack(cs,ck,h) in
        {28}let v_2: bitstring = catch-fail(symmetricstateunpack(ss)) in
        {29}let v_3: bool = (not-caught-fail(v_2) && success?(1-proj-3-tuple(v_2))) in
        {30}let h_1: bitstring = (if v_3 then 3-proj-3-tuple(v_2) else caught-fail) in
        {31}let ck_1: key = (if v_3 then 2-proj-3-tuple(v_2) else caught-fail) in
        {32}let cs_1: cipherstate = (if v_3 then 1-proj-3-tuple(v_2) else caught-fail) in
        {33}let ss_1: symmetricstate = catch-fail((if v_3 then symmetricstatepack(cs_1,ck_1,hash(h_1,prologue)) else fail-any)) in
        {34}let v_4: bool = not-caught-fail(ss_1) in
        {35}let v_5: bitstring = (if v_4 then catch-fail(symmetricstateunpack(ss_1)) else caught-fail) in
        {36}let v_6: bool = (not-caught-fail(v_5) && success?(1-proj-3-tuple(v_5))) in
        {37}let h_2: bitstring = (if v_6 then 3-proj-3-tuple(v_5) else caught-fail) in
        {38}let ck_2: key = (if v_6 then 2-proj-3-tuple(v_5) else caught-fail) in
        {39}let cs_2: cipherstate = (if v_6 then 1-proj-3-tuple(v_5) else caught-fail) in
        {40}let ss_2: symmetricstate = (if v_4 then catch-fail((if v_6 then symmetricstatepack(cs_2,ck_2,hash(h_2,rs)) else fail-any)) else caught-fail) in
        {41}let v_7: bool = not-caught-fail(ss_2) in
        {42}let v_8: bitstring = (if v_7 then catch-fail(symmetricstateunpack(ss_2)) else caught-fail) in
        {43}let v_9: bool = (not-caught-fail(v_8) && success?(1-proj-3-tuple(v_8))) in
        {44}let h_3: bitstring = (if v_9 then 3-proj-3-tuple(v_8) else caught-fail) in
        {45}let ck_3: key = (if v_9 then 2-proj-3-tuple(v_8) else caught-fail) in
        {46}let cs_3: cipherstate = (if v_9 then 1-proj-3-tuple(v_8) else caught-fail) in
        {47}let ss_3: symmetricstate = (if v_7 then catch-fail((if v_9 then symmetricstatepack(cs_3,ck_3,hash(h_3,rm)) else fail-any)) else caught-fail) in
        {48}let v_10: bool = not-caught-fail(ss_3) in
        {49}let hs: handshakestate = (if v_4 then (if v_7 then (if v_10 then handshakestatepack(ss_3,s,m,e,rs,rm,re,psk,true) else fail-any) else fail-any) else fail-any) in
        {50}insert statestore(me,them,sid_1,statepack_a(hs))
    ) | (
        {244}get statestore(=me,=them,=sid_1,statepack_a(hs_1: handshakestate)) in
        {51}let payload: bitstring = msg_a(me,them,sid_1) in
        {52}let v_11: bitstring = catch-fail(handshakestateunpack(hs_1)) in
        {53}let v_12: bool = (not-caught-fail(v_11) && success?(1-proj-9-tuple(v_11))) in
        {54}let initiator_1: bool = (if v_12 then 9-proj-9-tuple(v_11) else caught-fail) in
        {55}let psk_1: key = (if v_12 then 8-proj-9-tuple(v_11) else caught-fail) in
        {56}let re_1: key = (if v_12 then 7-proj-9-tuple(v_11) else caught-fail) in
        {57}let rm_1: key = (if v_12 then 6-proj-9-tuple(v_11) else caught-fail) in
        {58}let rs_1: key = (if v_12 then 5-proj-9-tuple(v_11) else caught-fail) in
        {59}let e_1: keypair = (if v_12 then 4-proj-9-tuple(v_11) else caught-fail) in
        {60}let m_1: keypair = (if v_12 then 3-proj-9-tuple(v_11) else caught-fail) in
        {61}let s_1: keypair = (if v_12 then 2-proj-9-tuple(v_11) else caught-fail) in
        {62}let ss_4: symmetricstate = (if v_12 then 1-proj-9-tuple(v_11) else caught-fail) in
        {63}let v_13: bitstring = (if v_12 then catch-fail((empty,empty,empty)) else caught-fail) in
        {64}let v_14: bool = (not-caught-fail(v_13) && success?(1-proj-3-tuple(v_13))) in
        {65}let ciphertext: bitstring = (if v_14 then 3-proj-3-tuple(v_13) else caught-fail) in
        {66}let nm: bitstring = (if v_14 then 2-proj-3-tuple(v_13) else caught-fail) in
        {67}let ne: bitstring = (if v_14 then 1-proj-3-tuple(v_13) else caught-fail) in
        {68}let basis_2: key = (if v_14 then key_e(me,them,sid_1) else caught-fail) in
        {69}let public_key_2: key = (if v_14 then catch-fail(dhexp(basis_2,validkey(g))) else caught-fail) in
        {70}let v_15: bool = not-caught-fail(public_key_2) in
        {71}let e_2: keypair = (if v_14 then catch-fail((if v_15 then keypairpack(validkey(public_key_2),basis_2) else fail-any)) else caught-fail) in
        {72}let v_16: bool = not-caught-fail(e_2) in
        {73}let ne_1: bitstring = (if v_16 then catch-fail(getpublickey(e_2)) else caught-fail) in
        {74}let v_17: bool = not-caught-fail(ne_1) in
        {75}let v_18: bitstring = (if v_17 then catch-fail(symmetricstateunpack(ss_4)) else caught-fail) in
        {76}let v_19: bool = (not-caught-fail(v_18) && success?(1-proj-3-tuple(v_18))) in
        {77}let h_4: bitstring = (if v_19 then 3-proj-3-tuple(v_18) else caught-fail) in
        {78}let ck_4: key = (if v_19 then 2-proj-3-tuple(v_18) else caught-fail) in
        {79}let cs_4: cipherstate = (if v_19 then 1-proj-3-tuple(v_18) else caught-fail) in
        {80}let ss_5: symmetricstate = (if v_17 then catch-fail((if v_19 then symmetricstatepack(cs_4,ck_4,hash(h_4,ne_1)) else fail-any)) else caught-fail) in
        {81}let v_20: bool = not-caught-fail(ss_5) in
        {82}let v_21: bitstring = (if v_20 then catch-fail(keypairunpack(e_2)) else caught-fail) in
        {83}let v_22: bool = (not-caught-fail(v_21) && success?(1-proj-2-tuple(v_21))) in
        {84}let my_private_key: key = (if v_22 then 2-proj-2-tuple(v_21) else caught-fail) in
        {85}let my_public_key: key = (if v_22 then 1-proj-2-tuple(v_21) else caught-fail) in
        {86}let input_key_material: key = (if v_20 then catch-fail((if v_22 then dhexp(my_private_key,rs_1) else fail-any)) else caught-fail) in
        {87}let v_23: bool = not-caught-fail(input_key_material) in
        {88}let v_24: bitstring = (if v_23 then catch-fail(symmetricstateunpack(ss_5)) else caught-fail) in
        {89}let v_25: bool = (not-caught-fail(v_24) && success?(1-proj-3-tuple(v_24))) in
        {90}let h_5: bitstring = (if v_25 then 3-proj-3-tuple(v_24) else caught-fail) in
        {91}let ck_5: key = (if v_25 then 2-proj-3-tuple(v_24) else caught-fail) in
        {92}let cs_5: cipherstate = (if v_25 then 1-proj-3-tuple(v_24) else caught-fail) in
        {93}let output1: key = (if v_25 then hmac_hash1(ck_5,input_key_material) else caught-fail) in
        {94}let output2: key = (if v_25 then hmac_hash2(ck_5,input_key_material) else caught-fail) in
        {95}let output3: key = (if v_25 then hmac_hash3(ck_5,input_key_material) else caught-fail) in
        {96}let v_26: bitstring = (if v_25 then catch-fail((output1,output2,output3)) else caught-fail) in
        {97}let v_27: bool = (not-caught-fail(v_26) && success?(1-proj-3-tuple(v_26))) in
        {98}let output_3: key = (if v_27 then 3-proj-3-tuple(v_26) else caught-fail) in
        {99}let temp_k: key = (if v_27 then 2-proj-3-tuple(v_26) else caught-fail) in
        {100}let ck_6: key = (if v_27 then 1-proj-3-tuple(v_26) else caught-fail) in
        {101}let ss_6: symmetricstate = (if v_20 then catch-fail((if v_23 then (if v_25 then (if v_27 then symmetricstatepack(cipherstatepack(temp_k,minnonce),ck_6,h_5) else fail-any) else fail-any) else fail-any)) else caught-fail) in
        {102}let v_28: bool = not-caught-fail(ss_6) in
        {103}let v_29: bitstring = (if v_28 then catch-fail(keypairunpack(e_2)) else caught-fail) in
        {104}let v_30: bool = (not-caught-fail(v_29) && success?(1-proj-2-tuple(v_29))) in
        {105}let my_private_key_1: key = (if v_30 then 2-proj-2-tuple(v_29) else caught-fail) in
        {106}let my_public_key_1: key = (if v_30 then 1-proj-2-tuple(v_29) else caught-fail) in
        {107}let input_key_material_1: key = (if v_28 then catch-fail((if v_30 then dhexp(my_private_key_1,rm_1) else fail-any)) else caught-fail) in
        {108}let v_31: bool = not-caught-fail(input_key_material_1) in
        {109}let v_32: bitstring = (if v_31 then catch-fail(symmetricstateunpack(ss_6)) else caught-fail) in
        {110}let v_33: bool = (not-caught-fail(v_32) && success?(1-proj-3-tuple(v_32))) in
        {111}let h_6: bitstring = (if v_33 then 3-proj-3-tuple(v_32) else caught-fail) in
        {112}let ck_7: key = (if v_33 then 2-proj-3-tuple(v_32) else caught-fail) in
        {113}let cs_6: cipherstate = (if v_33 then 1-proj-3-tuple(v_32) else caught-fail) in
        {114}let output1_1: key = (if v_33 then hmac_hash1(ck_7,input_key_material_1) else caught-fail) in
        {115}let output2_1: key = (if v_33 then hmac_hash2(ck_7,input_key_material_1) else caught-fail) in
        {116}let output3_1: key = (if v_33 then hmac_hash3(ck_7,input_key_material_1) else caught-fail) in
        {117}let v_34: bitstring = (if v_33 then catch-fail((output1_1,output2_1,output3_1)) else caught-fail) in
        {118}let v_35: bool = (not-caught-fail(v_34) && success?(1-proj-3-tuple(v_34))) in
        {119}let output: key = (if v_35 then 3-proj-3-tuple(v_34) else caught-fail) in
        {120}let temp_k_1: key = (if v_35 then 2-proj-3-tuple(v_34) else caught-fail) in
        {121}let ck_8: key = (if v_35 then 1-proj-3-tuple(v_34) else caught-fail) in
        {122}let ss_7: symmetricstate = (if v_28 then catch-fail((if v_31 then (if v_33 then (if v_35 then symmetricstatepack(cipherstatepack(temp_k_1,minnonce),ck_8,h_6) else fail-any) else fail-any) else fail-any)) else caught-fail) in
        {123}let v_36: bool = not-caught-fail(ss_7) in
        {124}let basis_3: key = (if v_36 then key_m(me) else caught-fail) in
        {125}let public_key_3: key = (if v_36 then catch-fail(dhexp(basis_3,validkey(g))) else caught-fail) in
        {126}let v_37: bool = not-caught-fail(public_key_3) in
        {127}let m_2: keypair = (if v_36 then catch-fail((if v_37 then keypairpack(validkey(public_key_3),basis_3) else fail-any)) else caught-fail) in
        {128}let v_38: bool = not-caught-fail(m_2) in
        {129}let plaintext: bitstring = (if v_38 then catch-fail(getpublickey(m_2)) else caught-fail) in
        {130}let v_39: bool = not-caught-fail(plaintext) in
        {131}let v_40: bitstring = (if v_39 then catch-fail(symmetricstateunpack(ss_7)) else caught-fail) in
        {132}let v_41: bool = (not-caught-fail(v_40) && success?(1-proj-3-tuple(v_40))) in
        {133}let h_7: bitstring = (if v_41 then 3-proj-3-tuple(v_40) else caught-fail) in
        {134}let ck_9: key = (if v_41 then 2-proj-3-tuple(v_40) else caught-fail) in
        {135}let cs_7: cipherstate = (if v_41 then 1-proj-3-tuple(v_40) else caught-fail) in
        {136}let v_42: bitstring = (if v_41 then catch-fail(cipherstateunpack(cs_7)) else caught-fail) in
        {137}let v_43: bool = (not-caught-fail(v_42) && success?(1-proj-2-tuple(v_42))) in
        {138}let n: nonce = (if v_43 then 2-proj-2-tuple(v_42) else caught-fail) in
        {139}let k_1: key = (if v_43 then 1-proj-2-tuple(v_42) else caught-fail) in
        {140}let e_3: bitstring = (if v_43 then encrypt(k_1,n,h_7,plaintext) else caught-fail) in
        {141}let n_1: nonce = (if v_43 then increment_nonce(n) else caught-fail) in
        {142}let v_44: bitstring = (if v_43 then catch-fail(cipherstateunpack(cs_7)) else caught-fail) in
        {143}let v_45: bool = (not-caught-fail(v_44) && success?(1-proj-2-tuple(v_44))) in
        {144}let o: nonce = (if v_45 then 2-proj-2-tuple(v_44) else caught-fail) in
        {145}let k_2: key = (if v_45 then 1-proj-2-tuple(v_44) else caught-fail) in
        {146}let csi: cipherstate = (if v_43 then catch-fail((if v_45 then cipherstatepack(k_2,n_1) else fail-any)) else caught-fail) in
        {147}let v_46: bool = not-caught-fail(csi) in
        {148}let v_47: bitstring = (if v_41 then catch-fail((if v_43 then (if v_46 then (csi,e_3) else fail-any) else fail-any)) else caught-fail) in
        {149}let v_48: bool = (not-caught-fail(v_47) && success?(1-proj-2-tuple(v_47))) in
        {150}let ciphertext_1: bitstring = (if v_48 then 2-proj-2-tuple(v_47) else caught-fail) in
        {151}let csi_1: cipherstate = (if v_48 then 1-proj-2-tuple(v_47) else caught-fail) in
        {152}let ss_8: symmetricstate = (if v_48 then symmetricstatepack(csi_1,ck_9,h_7) else caught-fail) in
        {153}let v_49: bitstring = (if v_48 then catch-fail(symmetricstateunpack(ss_8)) else caught-fail) in
        {154}let v_50: bool = (not-caught-fail(v_49) && success?(1-proj-3-tuple(v_49))) in
        {155}let h_8: bitstring = (if v_50 then 3-proj-3-tuple(v_49) else caught-fail) in
        {156}let ck_10: key = (if v_50 then 2-proj-3-tuple(v_49) else caught-fail) in
        {157}let cs_8: cipherstate = (if v_50 then 1-proj-3-tuple(v_49) else caught-fail) in
        {158}let ssi: symmetricstate = (if v_48 then catch-fail((if v_50 then symmetricstatepack(cs_8,ck_10,hash(h_8,ciphertext_1)) else fail-any)) else caught-fail) in
        {159}let v_51: bool = not-caught-fail(ssi) in
        {160}let v_52: bitstring = (if v_38 then catch-fail((if v_39 then (if v_41 then (if v_48 then (if v_51 then (ssi,ciphertext_1) else fail-any) else fail-any) else fail-any) else fail-any)) else caught-fail) in
        {161}let v_53: bool = (not-caught-fail(v_52) && success?(1-proj-2-tuple(v_52))) in
        {162}let nm_1: bitstring = (if v_53 then 2-proj-2-tuple(v_52) else caught-fail) in
        {163}let ss_9: symmetricstate = (if v_53 then 1-proj-2-tuple(v_52) else caught-fail) in
        {164}let v_54: bitstring = (if v_53 then catch-fail(keypairunpack(m_2)) else caught-fail) in
        {165}let v_55: bool = (not-caught-fail(v_54) && success?(1-proj-2-tuple(v_54))) in
        {166}let my_private_key_2: key = (if v_55 then 2-proj-2-tuple(v_54) else caught-fail) in
        {167}let my_public_key_2: key = (if v_55 then 1-proj-2-tuple(v_54) else caught-fail) in
        {168}let input_key_material_2: key = (if v_53 then catch-fail((if v_55 then dhexp(my_private_key_2,rs_1) else fail-any)) else caught-fail) in
        {169}let v_56: bool = not-caught-fail(input_key_material_2) in
        {170}let v_57: bitstring = (if v_56 then catch-fail(symmetricstateunpack(ss_9)) else caught-fail) in
        {171}let v_58: bool = (not-caught-fail(v_57) && success?(1-proj-3-tuple(v_57))) in
        {172}let h_9: bitstring = (if v_58 then 3-proj-3-tuple(v_57) else caught-fail) in
        {173}let ck_11: key = (if v_58 then 2-proj-3-tuple(v_57) else caught-fail) in
        {174}let cs_9: cipherstate = (if v_58 then 1-proj-3-tuple(v_57) else caught-fail) in
        {175}let output1_2: key = (if v_58 then hmac_hash1(ck_11,input_key_material_2) else caught-fail) in
        {176}let output2_2: key = (if v_58 then hmac_hash2(ck_11,input_key_material_2) else caught-fail) in
        {177}let output3_2: key = (if v_58 then hmac_hash3(ck_11,input_key_material_2) else caught-fail) in
        {178}let v_59: bitstring = (if v_58 then catch-fail((output1_2,output2_2,output3_2)) else caught-fail) in
        {179}let v_60: bool = (not-caught-fail(v_59) && success?(1-proj-3-tuple(v_59))) in
        {180}let output_1: key = (if v_60 then 3-proj-3-tuple(v_59) else caught-fail) in
        {181}let temp_k_2: key = (if v_60 then 2-proj-3-tuple(v_59) else caught-fail) in
        {182}let ck_12: key = (if v_60 then 1-proj-3-tuple(v_59) else caught-fail) in
        {183}let ss_10: symmetricstate = (if v_53 then catch-fail((if v_56 then (if v_58 then (if v_60 then symmetricstatepack(cipherstatepack(temp_k_2,minnonce),ck_12,h_9) else fail-any) else fail-any) else fail-any)) else caught-fail) in
        {184}let v_61: bool = not-caught-fail(ss_10) in
        {185}let v_62: bitstring = (if v_61 then catch-fail(symmetricstateunpack(ss_10)) else caught-fail) in
        {186}let v_63: bool = (not-caught-fail(v_62) && success?(1-proj-3-tuple(v_62))) in
        {187}let h_10: bitstring = (if v_63 then 3-proj-3-tuple(v_62) else caught-fail) in
        {188}let ck_13: key = (if v_63 then 2-proj-3-tuple(v_62) else caught-fail) in
        {189}let cs_10: cipherstate = (if v_63 then 1-proj-3-tuple(v_62) else caught-fail) in
        {190}let v_64: bitstring = (if v_63 then catch-fail(cipherstateunpack(cs_10)) else caught-fail) in
        {191}let v_65: bool = (not-caught-fail(v_64) && success?(1-proj-2-tuple(v_64))) in
        {192}let n_2: nonce = (if v_65 then 2-proj-2-tuple(v_64) else caught-fail) in
        {193}let k_3: key = (if v_65 then 1-proj-2-tuple(v_64) else caught-fail) in
        {194}let e_4: bitstring = (if v_65 then encrypt(k_3,n_2,h_10,payload) else caught-fail) in
        {195}let n_3: nonce = (if v_65 then increment_nonce(n_2) else caught-fail) in
        {196}let v_66: bitstring = (if v_65 then catch-fail(cipherstateunpack(cs_10)) else caught-fail) in
        {197}let v_67: bool = (not-caught-fail(v_66) && success?(1-proj-2-tuple(v_66))) in
        {198}let o_1: nonce = (if v_67 then 2-proj-2-tuple(v_66) else caught-fail) in
        {199}let k_4: key = (if v_67 then 1-proj-2-tuple(v_66) else caught-fail) in
        {200}let csi_2: cipherstate = (if v_65 then catch-fail((if v_67 then cipherstatepack(k_4,n_3) else fail-any)) else caught-fail) in
        {201}let v_68: bool = not-caught-fail(csi_2) in
        {202}let v_69: bitstring = (if v_63 then catch-fail((if v_65 then (if v_68 then (csi_2,e_4) else fail-any) else fail-any)) else caught-fail) in
        {203}let v_70: bool = (not-caught-fail(v_69) && success?(1-proj-2-tuple(v_69))) in
        {204}let ciphertext_2: bitstring = (if v_70 then 2-proj-2-tuple(v_69) else caught-fail) in
        {205}let csi_3: cipherstate = (if v_70 then 1-proj-2-tuple(v_69) else caught-fail) in
        {206}let ss_11: symmetricstate = (if v_70 then symmetricstatepack(csi_3,ck_13,h_10) else caught-fail) in
        {207}let v_71: bitstring = (if v_70 then catch-fail(symmetricstateunpack(ss_11)) else caught-fail) in
        {208}let v_72: bool = (not-caught-fail(v_71) && success?(1-proj-3-tuple(v_71))) in
        {209}let h_11: bitstring = (if v_72 then 3-proj-3-tuple(v_71) else caught-fail) in
        {210}let ck_14: key = (if v_72 then 2-proj-3-tuple(v_71) else caught-fail) in
        {211}let cs_11: cipherstate = (if v_72 then 1-proj-3-tuple(v_71) else caught-fail) in
        {212}let ssi_1: symmetricstate = (if v_70 then catch-fail((if v_72 then symmetricstatepack(cs_11,ck_14,hash(h_11,ciphertext_2)) else fail-any)) else caught-fail) in
        {213}let v_73: bool = not-caught-fail(ssi_1) in
        {214}let v_74: bitstring = (if v_61 then catch-fail((if v_63 then (if v_70 then (if v_73 then (ssi_1,ciphertext_2) else fail-any) else fail-any) else fail-any)) else caught-fail) in
        {215}let v_75: bool = (not-caught-fail(v_74) && success?(1-proj-2-tuple(v_74))) in
        {216}let ciphertext_3: bitstring = (if v_75 then 2-proj-2-tuple(v_74) else caught-fail) in
        {217}let ss_12: symmetricstate = (if v_75 then 1-proj-2-tuple(v_74) else caught-fail) in
        {218}let hs_2: handshakestate = (if v_75 then handshakestatepack(ss_12,s_1,m_2,e_2,rs_1,rm_1,re_1,psk_1,initiator_1) else caught-fail) in
        {219}let message_buffer: bitstring = (if v_75 then concat3(ne_1,nm_1,ciphertext_3) else caught-fail) in
        {220}let v_76: bitstring = (if v_75 then catch-fail(symmetricstateunpack(ss_12)) else caught-fail) in
        {221}let v_77: bool = (not-caught-fail(v_76) && success?(1-proj-3-tuple(v_76))) in
        {222}let h_12: bitstring = (if v_77 then 3-proj-3-tuple(v_76) else caught-fail) in
        {223}let ck_15: key = (if v_77 then 2-proj-3-tuple(v_76) else caught-fail) in
        {224}let cs_12: cipherstate = (if v_77 then 1-proj-3-tuple(v_76) else caught-fail) in
        {225}let input_key_material_3: key = (if v_77 then zero else caught-fail) in
        {226}let output1_3: key = (if v_77 then hmac_hash1(ck_15,input_key_material_3) else caught-fail) in
        {227}let output2_3: key = (if v_77 then hmac_hash2(ck_15,input_key_material_3) else caught-fail) in
        {228}let output3_3: key = (if v_77 then hmac_hash3(ck_15,input_key_material_3) else caught-fail) in
        {229}let v_78: bitstring = (if v_77 then catch-fail((output1_3,output2_3,output3_3)) else caught-fail) in
        {230}let v_79: bool = (not-caught-fail(v_78) && success?(1-proj-3-tuple(v_78))) in
        {231}let temp_k3: key = (if v_79 then 3-proj-3-tuple(v_78) else caught-fail) in
        {232}let temp_k2: key = (if v_79 then 2-proj-3-tuple(v_78) else caught-fail) in
        {233}let temp_k1: key = (if v_79 then 1-proj-3-tuple(v_78) else caught-fail) in
        {234}let cs1: cipherstate = (if v_79 then cipherstatepack(temp_k1,minnonce) else caught-fail) in
        {235}let cs2: cipherstate = (if v_79 then cipherstatepack(temp_k2,minnonce) else caught-fail) in
        {236}let v_80: bitstring = (if v_75 then catch-fail((if v_77 then (if v_79 then (ss_12,cs1,cs2) else fail-any) else fail-any)) else caught-fail) in
        {237}let v_81: bool = (not-caught-fail(v_80) && success?(1-proj-3-tuple(v_80))) in
        {238}let cs2_1: cipherstate = (if v_81 then 3-proj-3-tuple(v_80) else caught-fail) in
        {239}let cs1_1: cipherstate = (if v_81 then 2-proj-3-tuple(v_80) else caught-fail) in
        {240}let ssi_2: symmetricstate = (if v_81 then 1-proj-3-tuple(v_80) else caught-fail) in
        {241}let (hs_3: handshakestate,message_a: bitstring,cs1_2: cipherstate,cs2_2: cipherstate) = (if v_12 then (if v_14 then (if v_16 then (if v_17 then (if v_20 then (if v_28 then (if v_36 then (if v_38 then (if v_53 then (if v_61 then (if v_75 then (if v_81 then (hs_2,message_buffer,cs1_1,cs2_1) else fail-any) else fail-any) else fail-any) else fail-any) else fail-any) else fail-any) else fail-any) else fail-any) else fail-any) else fail-any) else fail-any) else fail-any) in
        {242}event SendMsg(me,them,stagepack_a(sid_1),msg_a(me,them,sid_1));
        {243}out(pub, message_a)
    ) | (
        {245}event LeakS(phase0,me);
        {246}event LeakM(phase0,me);
        {247}out(pub, (key_s(me),key_m(me)))
    ) | (
        {248}phase 1;
        {249}event LeakS(phase1,me);
        {250}event LeakM(phase1,me);
        {251}out(pub, (key_s(me),key_m(me)))
    )
) | (
    {252}let me_1: principal = alice in
    {253}let them_1: principal = charlie in
    {254}let sid_2: sessionid = sid in
    {255}let s_2: keypair = keypairpack(empty,empty) in
    {256}let m_3: keypair = keypairpack(empty,empty) in
    {257}out(pub, (getpublickey(s_2),getpublickey(m_3)));
    (
        {258}let e_5: keypair = keypairpack(empty,empty) in
        {259}let basis_4: key = key_s(them_1) in
        {260}let public_key_4: key = catch-fail(dhexp(basis_4,validkey(g))) in
        {261}let v_82: bool = not-caught-fail(public_key_4) in
        {262}let rs_2: key = getpublickey((if v_82 then keypairpack(validkey(public_key_4),basis_4) else fail-any)) in
        {263}let basis_5: key = key_m(them_1) in
        {264}let public_key_5: key = catch-fail(dhexp(basis_5,validkey(g))) in
        {265}let v_83: bool = not-caught-fail(public_key_5) in
        {266}let rm_2: key = getpublickey((if v_83 then keypairpack(validkey(public_key_5),basis_5) else fail-any)) in
        {267}let re_2: key = empty in
        {268}let prologue_1: bitstring = empty in
        {269}let psk_2: key = empty in
        {270}let protocol_name_1: bitstring = somename in
        {271}let h_13: bitstring = hash(protocol_name_1,empty) in
        {272}let ck_16: key = h_13 in
        {273}let k_5: key = empty in
        {274}let cs_13: cipherstate = cipherstatepack(k_5,minnonce) in
        {275}let ss_13: symmetricstate = symmetricstatepack(cs_13,ck_16,h_13) in
        {276}let v_84: bitstring = catch-fail(symmetricstateunpack(ss_13)) in
        {277}let v_85: bool = (not-caught-fail(v_84) && success?(1-proj-3-tuple(v_84))) in
        {278}let h_14: bitstring = (if v_85 then 3-proj-3-tuple(v_84) else caught-fail) in
        {279}let ck_17: key = (if v_85 then 2-proj-3-tuple(v_84) else caught-fail) in
        {280}let cs_14: cipherstate = (if v_85 then 1-proj-3-tuple(v_84) else caught-fail) in
        {281}let ss_14: symmetricstate = catch-fail((if v_85 then symmetricstatepack(cs_14,ck_17,hash(h_14,prologue_1)) else fail-any)) in
        {282}let v_86: bool = not-caught-fail(ss_14) in
        {283}let v_87: bitstring = (if v_86 then catch-fail(symmetricstateunpack(ss_14)) else caught-fail) in
        {284}let v_88: bool = (not-caught-fail(v_87) && success?(1-proj-3-tuple(v_87))) in
        {285}let h_15: bitstring = (if v_88 then 3-proj-3-tuple(v_87) else caught-fail) in
        {286}let ck_18: key = (if v_88 then 2-proj-3-tuple(v_87) else caught-fail) in
        {287}let cs_15: cipherstate = (if v_88 then 1-proj-3-tuple(v_87) else caught-fail) in
        {288}let ss_15: symmetricstate = (if v_86 then catch-fail((if v_88 then symmetricstatepack(cs_15,ck_18,hash(h_15,rs_2)) else fail-any)) else caught-fail) in
        {289}let v_89: bool = not-caught-fail(ss_15) in
        {290}let v_90: bitstring = (if v_89 then catch-fail(symmetricstateunpack(ss_15)) else caught-fail) in
        {291}let v_91: bool = (not-caught-fail(v_90) && success?(1-proj-3-tuple(v_90))) in
        {292}let h_16: bitstring = (if v_91 then 3-proj-3-tuple(v_90) else caught-fail) in
        {293}let ck_19: key = (if v_91 then 2-proj-3-tuple(v_90) else caught-fail) in
        {294}let cs_16: cipherstate = (if v_91 then 1-proj-3-tuple(v_90) else caught-fail) in
        {295}let ss_16: symmetricstate = (if v_89 then catch-fail((if v_91 then symmetricstatepack(cs_16,ck_19,hash(h_16,rm_2)) else fail-any)) else caught-fail) in
        {296}let v_92: bool = not-caught-fail(ss_16) in
        {297}let hs_4: handshakestate = (if v_86 then (if v_89 then (if v_92 then handshakestatepack(ss_16,s_2,m_3,e_5,rs_2,rm_2,re_2,psk_2,true) else fail-any) else fail-any) else fail-any) in
        {298}insert statestore(me_1,them_1,sid_2,statepack_a(hs_4))
    ) | (
        {492}get statestore(=me_1,=them_1,=sid_2,statepack_a(hs_5: handshakestate)) in
        {299}let payload_1: bitstring = msg_a(me_1,them_1,sid_2) in
        {300}let v_93: bitstring = catch-fail(handshakestateunpack(hs_5)) in
        {301}let v_94: bool = (not-caught-fail(v_93) && success?(1-proj-9-tuple(v_93))) in
        {302}let initiator_2: bool = (if v_94 then 9-proj-9-tuple(v_93) else caught-fail) in
        {303}let psk_3: key = (if v_94 then 8-proj-9-tuple(v_93) else caught-fail) in
        {304}let re_3: key = (if v_94 then 7-proj-9-tuple(v_93) else caught-fail) in
        {305}let rm_3: key = (if v_94 then 6-proj-9-tuple(v_93) else caught-fail) in
        {306}let rs_3: key = (if v_94 then 5-proj-9-tuple(v_93) else caught-fail) in
        {307}let e_6: keypair = (if v_94 then 4-proj-9-tuple(v_93) else caught-fail) in
        {308}let m_4: keypair = (if v_94 then 3-proj-9-tuple(v_93) else caught-fail) in
        {309}let s_3: keypair = (if v_94 then 2-proj-9-tuple(v_93) else caught-fail) in
        {310}let ss_17: symmetricstate = (if v_94 then 1-proj-9-tuple(v_93) else caught-fail) in
        {311}let v_95: bitstring = (if v_94 then catch-fail((empty,empty,empty)) else caught-fail) in
        {312}let v_96: bool = (not-caught-fail(v_95) && success?(1-proj-3-tuple(v_95))) in
        {313}let ciphertext_4: bitstring = (if v_96 then 3-proj-3-tuple(v_95) else caught-fail) in
        {314}let nm_2: bitstring = (if v_96 then 2-proj-3-tuple(v_95) else caught-fail) in
        {315}let ne_2: bitstring = (if v_96 then 1-proj-3-tuple(v_95) else caught-fail) in
        {316}let basis_6: key = (if v_96 then key_e(me_1,them_1,sid_2) else caught-fail) in
        {317}let public_key_6: key = (if v_96 then catch-fail(dhexp(basis_6,validkey(g))) else caught-fail) in
        {318}let v_97: bool = not-caught-fail(public_key_6) in
        {319}let e_7: keypair = (if v_96 then catch-fail((if v_97 then keypairpack(validkey(public_key_6),basis_6) else fail-any)) else caught-fail) in
        {320}let v_98: bool = not-caught-fail(e_7) in
        {321}let ne_3: bitstring = (if v_98 then catch-fail(getpublickey(e_7)) else caught-fail) in
        {322}let v_99: bool = not-caught-fail(ne_3) in
        {323}let v_100: bitstring = (if v_99 then catch-fail(symmetricstateunpack(ss_17)) else caught-fail) in
        {324}let v_101: bool = (not-caught-fail(v_100) && success?(1-proj-3-tuple(v_100))) in
        {325}let h_17: bitstring = (if v_101 then 3-proj-3-tuple(v_100) else caught-fail) in
        {326}let ck_20: key = (if v_101 then 2-proj-3-tuple(v_100) else caught-fail) in
        {327}let cs_17: cipherstate = (if v_101 then 1-proj-3-tuple(v_100) else caught-fail) in
        {328}let ss_18: symmetricstate = (if v_99 then catch-fail((if v_101 then symmetricstatepack(cs_17,ck_20,hash(h_17,ne_3)) else fail-any)) else caught-fail) in
        {329}let v_102: bool = not-caught-fail(ss_18) in
        {330}let v_103: bitstring = (if v_102 then catch-fail(keypairunpack(e_7)) else caught-fail) in
        {331}let v_104: bool = (not-caught-fail(v_103) && success?(1-proj-2-tuple(v_103))) in
        {332}let my_private_key_3: key = (if v_104 then 2-proj-2-tuple(v_103) else caught-fail) in
        {333}let my_public_key_3: key = (if v_104 then 1-proj-2-tuple(v_103) else caught-fail) in
        {334}let input_key_material_4: key = (if v_102 then catch-fail((if v_104 then dhexp(my_private_key_3,rs_3) else fail-any)) else caught-fail) in
        {335}let v_105: bool = not-caught-fail(input_key_material_4) in
        {336}let v_106: bitstring = (if v_105 then catch-fail(symmetricstateunpack(ss_18)) else caught-fail) in
        {337}let v_107: bool = (not-caught-fail(v_106) && success?(1-proj-3-tuple(v_106))) in
        {338}let h_18: bitstring = (if v_107 then 3-proj-3-tuple(v_106) else caught-fail) in
        {339}let ck_21: key = (if v_107 then 2-proj-3-tuple(v_106) else caught-fail) in
        {340}let cs_18: cipherstate = (if v_107 then 1-proj-3-tuple(v_106) else caught-fail) in
        {341}let output1_4: key = (if v_107 then hmac_hash1(ck_21,input_key_material_4) else caught-fail) in
        {342}let output2_4: key = (if v_107 then hmac_hash2(ck_21,input_key_material_4) else caught-fail) in
        {343}let output3_4: key = (if v_107 then hmac_hash3(ck_21,input_key_material_4) else caught-fail) in
        {344}let v_108: bitstring = (if v_107 then catch-fail((output1_4,output2_4,output3_4)) else caught-fail) in
        {345}let v_109: bool = (not-caught-fail(v_108) && success?(1-proj-3-tuple(v_108))) in
        {346}let output_2: key = (if v_109 then 3-proj-3-tuple(v_108) else caught-fail) in
        {347}let temp_k_3: key = (if v_109 then 2-proj-3-tuple(v_108) else caught-fail) in
        {348}let ck_22: key = (if v_109 then 1-proj-3-tuple(v_108) else caught-fail) in
        {349}let ss_19: symmetricstate = (if v_102 then catch-fail((if v_105 then (if v_107 then (if v_109 then symmetricstatepack(cipherstatepack(temp_k_3,minnonce),ck_22,h_18) else fail-any) else fail-any) else fail-any)) else caught-fail) in
        {350}let v_110: bool = not-caught-fail(ss_19) in
        {351}let v_111: bitstring = (if v_110 then catch-fail(keypairunpack(e_7)) else caught-fail) in
        {352}let v_112: bool = (not-caught-fail(v_111) && success?(1-proj-2-tuple(v_111))) in
        {353}let my_private_key_4: key = (if v_112 then 2-proj-2-tuple(v_111) else caught-fail) in
        {354}let my_public_key_4: key = (if v_112 then 1-proj-2-tuple(v_111) else caught-fail) in
        {355}let input_key_material_5: key = (if v_110 then catch-fail((if v_112 then dhexp(my_private_key_4,rm_3) else fail-any)) else caught-fail) in
        {356}let v_113: bool = not-caught-fail(input_key_material_5) in
        {357}let v_114: bitstring = (if v_113 then catch-fail(symmetricstateunpack(ss_19)) else caught-fail) in
        {358}let v_115: bool = (not-caught-fail(v_114) && success?(1-proj-3-tuple(v_114))) in
        {359}let h_19: bitstring = (if v_115 then 3-proj-3-tuple(v_114) else caught-fail) in
        {360}let ck_23: key = (if v_115 then 2-proj-3-tuple(v_114) else caught-fail) in
        {361}let cs_19: cipherstate = (if v_115 then 1-proj-3-tuple(v_114) else caught-fail) in
        {362}let output1_5: key = (if v_115 then hmac_hash1(ck_23,input_key_material_5) else caught-fail) in
        {363}let output2_5: key = (if v_115 then hmac_hash2(ck_23,input_key_material_5) else caught-fail) in
        {364}let output3_5: key = (if v_115 then hmac_hash3(ck_23,input_key_material_5) else caught-fail) in
        {365}let v_116: bitstring = (if v_115 then catch-fail((output1_5,output2_5,output3_5)) else caught-fail) in
        {366}let v_117: bool = (not-caught-fail(v_116) && success?(1-proj-3-tuple(v_116))) in
        {367}let output_4: key = (if v_117 then 3-proj-3-tuple(v_116) else caught-fail) in
        {368}let temp_k_4: key = (if v_117 then 2-proj-3-tuple(v_116) else caught-fail) in
        {369}let ck_24: key = (if v_117 then 1-proj-3-tuple(v_116) else caught-fail) in
        {370}let ss_20: symmetricstate = (if v_110 then catch-fail((if v_113 then (if v_115 then (if v_117 then symmetricstatepack(cipherstatepack(temp_k_4,minnonce),ck_24,h_19) else fail-any) else fail-any) else fail-any)) else caught-fail) in
        {371}let v_118: bool = not-caught-fail(ss_20) in
        {372}let basis_7: key = (if v_118 then key_m(me_1) else caught-fail) in
        {373}let public_key_7: key = (if v_118 then catch-fail(dhexp(basis_7,validkey(g))) else caught-fail) in
        {374}let v_119: bool = not-caught-fail(public_key_7) in
        {375}let m_5: keypair = (if v_118 then catch-fail((if v_119 then keypairpack(validkey(public_key_7),basis_7) else fail-any)) else caught-fail) in
        {376}let v_120: bool = not-caught-fail(m_5) in
        {377}let plaintext_1: bitstring = (if v_120 then catch-fail(getpublickey(m_5)) else caught-fail) in
        {378}let v_121: bool = not-caught-fail(plaintext_1) in
        {379}let v_122: bitstring = (if v_121 then catch-fail(symmetricstateunpack(ss_20)) else caught-fail) in
        {380}let v_123: bool = (not-caught-fail(v_122) && success?(1-proj-3-tuple(v_122))) in
        {381}let h_20: bitstring = (if v_123 then 3-proj-3-tuple(v_122) else caught-fail) in
        {382}let ck_25: key = (if v_123 then 2-proj-3-tuple(v_122) else caught-fail) in
        {383}let cs_20: cipherstate = (if v_123 then 1-proj-3-tuple(v_122) else caught-fail) in
        {384}let v_124: bitstring = (if v_123 then catch-fail(cipherstateunpack(cs_20)) else caught-fail) in
        {385}let v_125: bool = (not-caught-fail(v_124) && success?(1-proj-2-tuple(v_124))) in
        {386}let n_4: nonce = (if v_125 then 2-proj-2-tuple(v_124) else caught-fail) in
        {387}let k_6: key = (if v_125 then 1-proj-2-tuple(v_124) else caught-fail) in
        {388}let e_8: bitstring = (if v_125 then encrypt(k_6,n_4,h_20,plaintext_1) else caught-fail) in
        {389}let n_5: nonce = (if v_125 then increment_nonce(n_4) else caught-fail) in
        {390}let v_126: bitstring = (if v_125 then catch-fail(cipherstateunpack(cs_20)) else caught-fail) in
        {391}let v_127: bool = (not-caught-fail(v_126) && success?(1-proj-2-tuple(v_126))) in
        {392}let o_2: nonce = (if v_127 then 2-proj-2-tuple(v_126) else caught-fail) in
        {393}let k_7: key = (if v_127 then 1-proj-2-tuple(v_126) else caught-fail) in
        {394}let csi_4: cipherstate = (if v_125 then catch-fail((if v_127 then cipherstatepack(k_7,n_5) else fail-any)) else caught-fail) in
        {395}let v_128: bool = not-caught-fail(csi_4) in
        {396}let v_129: bitstring = (if v_123 then catch-fail((if v_125 then (if v_128 then (csi_4,e_8) else fail-any) else fail-any)) else caught-fail) in
        {397}let v_130: bool = (not-caught-fail(v_129) && success?(1-proj-2-tuple(v_129))) in
        {398}let ciphertext_5: bitstring = (if v_130 then 2-proj-2-tuple(v_129) else caught-fail) in
        {399}let csi_5: cipherstate = (if v_130 then 1-proj-2-tuple(v_129) else caught-fail) in
        {400}let ss_21: symmetricstate = (if v_130 then symmetricstatepack(csi_5,ck_25,h_20) else caught-fail) in
        {401}let v_131: bitstring = (if v_130 then catch-fail(symmetricstateunpack(ss_21)) else caught-fail) in
        {402}let v_132: bool = (not-caught-fail(v_131) && success?(1-proj-3-tuple(v_131))) in
        {403}let h_21: bitstring = (if v_132 then 3-proj-3-tuple(v_131) else caught-fail) in
        {404}let ck_26: key = (if v_132 then 2-proj-3-tuple(v_131) else caught-fail) in
        {405}let cs_21: cipherstate = (if v_132 then 1-proj-3-tuple(v_131) else caught-fail) in
        {406}let ssi_3: symmetricstate = (if v_130 then catch-fail((if v_132 then symmetricstatepack(cs_21,ck_26,hash(h_21,ciphertext_5)) else fail-any)) else caught-fail) in
        {407}let v_133: bool = not-caught-fail(ssi_3) in
        {408}let v_134: bitstring = (if v_120 then catch-fail((if v_121 then (if v_123 then (if v_130 then (if v_133 then (ssi_3,ciphertext_5) else fail-any) else fail-any) else fail-any) else fail-any)) else caught-fail) in
        {409}let v_135: bool = (not-caught-fail(v_134) && success?(1-proj-2-tuple(v_134))) in
        {410}let nm_3: bitstring = (if v_135 then 2-proj-2-tuple(v_134) else caught-fail) in
        {411}let ss_22: symmetricstate = (if v_135 then 1-proj-2-tuple(v_134) else caught-fail) in
        {412}let v_136: bitstring = (if v_135 then catch-fail(keypairunpack(m_5)) else caught-fail) in
        {413}let v_137: bool = (not-caught-fail(v_136) && success?(1-proj-2-tuple(v_136))) in
        {414}let my_private_key_5: key = (if v_137 then 2-proj-2-tuple(v_136) else caught-fail) in
        {415}let my_public_key_5: key = (if v_137 then 1-proj-2-tuple(v_136) else caught-fail) in
        {416}let input_key_material_6: key = (if v_135 then catch-fail((if v_137 then dhexp(my_private_key_5,rs_3) else fail-any)) else caught-fail) in
        {417}let v_138: bool = not-caught-fail(input_key_material_6) in
        {418}let v_139: bitstring = (if v_138 then catch-fail(symmetricstateunpack(ss_22)) else caught-fail) in
        {419}let v_140: bool = (not-caught-fail(v_139) && success?(1-proj-3-tuple(v_139))) in
        {420}let h_22: bitstring = (if v_140 then 3-proj-3-tuple(v_139) else caught-fail) in
        {421}let ck_27: key = (if v_140 then 2-proj-3-tuple(v_139) else caught-fail) in
        {422}let cs_22: cipherstate = (if v_140 then 1-proj-3-tuple(v_139) else caught-fail) in
        {423}let output1_6: key = (if v_140 then hmac_hash1(ck_27,input_key_material_6) else caught-fail) in
        {424}let output2_6: key = (if v_140 then hmac_hash2(ck_27,input_key_material_6) else caught-fail) in
        {425}let output3_6: key = (if v_140 then hmac_hash3(ck_27,input_key_material_6) else caught-fail) in
        {426}let v_141: bitstring = (if v_140 then catch-fail((output1_6,output2_6,output3_6)) else caught-fail) in
        {427}let v_142: bool = (not-caught-fail(v_141) && success?(1-proj-3-tuple(v_141))) in
        {428}let output_5: key = (if v_142 then 3-proj-3-tuple(v_141) else caught-fail) in
        {429}let temp_k_5: key = (if v_142 then 2-proj-3-tuple(v_141) else caught-fail) in
        {430}let ck_28: key = (if v_142 then 1-proj-3-tuple(v_141) else caught-fail) in
        {431}let ss_23: symmetricstate = (if v_135 then catch-fail((if v_138 then (if v_140 then (if v_142 then symmetricstatepack(cipherstatepack(temp_k_5,minnonce),ck_28,h_22) else fail-any) else fail-any) else fail-any)) else caught-fail) in
        {432}let v_143: bool = not-caught-fail(ss_23) in
        {433}let v_144: bitstring = (if v_143 then catch-fail(symmetricstateunpack(ss_23)) else caught-fail) in
        {434}let v_145: bool = (not-caught-fail(v_144) && success?(1-proj-3-tuple(v_144))) in
        {435}let h_23: bitstring = (if v_145 then 3-proj-3-tuple(v_144) else caught-fail) in
        {436}let ck_29: key = (if v_145 then 2-proj-3-tuple(v_144) else caught-fail) in
        {437}let cs_23: cipherstate = (if v_145 then 1-proj-3-tuple(v_144) else caught-fail) in
        {438}let v_146: bitstring = (if v_145 then catch-fail(cipherstateunpack(cs_23)) else caught-fail) in
        {439}let v_147: bool = (not-caught-fail(v_146) && success?(1-proj-2-tuple(v_146))) in
        {440}let n_6: nonce = (if v_147 then 2-proj-2-tuple(v_146) else caught-fail) in
        {441}let k_8: key = (if v_147 then 1-proj-2-tuple(v_146) else caught-fail) in
        {442}let e_9: bitstring = (if v_147 then encrypt(k_8,n_6,h_23,payload_1) else caught-fail) in
        {443}let n_7: nonce = (if v_147 then increment_nonce(n_6) else caught-fail) in
        {444}let v_148: bitstring = (if v_147 then catch-fail(cipherstateunpack(cs_23)) else caught-fail) in
        {445}let v_149: bool = (not-caught-fail(v_148) && success?(1-proj-2-tuple(v_148))) in
        {446}let o_3: nonce = (if v_149 then 2-proj-2-tuple(v_148) else caught-fail) in
        {447}let k_9: key = (if v_149 then 1-proj-2-tuple(v_148) else caught-fail) in
        {448}let csi_6: cipherstate = (if v_147 then catch-fail((if v_149 then cipherstatepack(k_9,n_7) else fail-any)) else caught-fail) in
        {449}let v_150: bool = not-caught-fail(csi_6) in
        {450}let v_151: bitstring = (if v_145 then catch-fail((if v_147 then (if v_150 then (csi_6,e_9) else fail-any) else fail-any)) else caught-fail) in
        {451}let v_152: bool = (not-caught-fail(v_151) && success?(1-proj-2-tuple(v_151))) in
        {452}let ciphertext_6: bitstring = (if v_152 then 2-proj-2-tuple(v_151) else caught-fail) in
        {453}let csi_7: cipherstate = (if v_152 then 1-proj-2-tuple(v_151) else caught-fail) in
        {454}let ss_24: symmetricstate = (if v_152 then symmetricstatepack(csi_7,ck_29,h_23) else caught-fail) in
        {455}let v_153: bitstring = (if v_152 then catch-fail(symmetricstateunpack(ss_24)) else caught-fail) in
        {456}let v_154: bool = (not-caught-fail(v_153) && success?(1-proj-3-tuple(v_153))) in
        {457}let h_24: bitstring = (if v_154 then 3-proj-3-tuple(v_153) else caught-fail) in
        {458}let ck_30: key = (if v_154 then 2-proj-3-tuple(v_153) else caught-fail) in
        {459}let cs_24: cipherstate = (if v_154 then 1-proj-3-tuple(v_153) else caught-fail) in
        {460}let ssi_4: symmetricstate = (if v_152 then catch-fail((if v_154 then symmetricstatepack(cs_24,ck_30,hash(h_24,ciphertext_6)) else fail-any)) else caught-fail) in
        {461}let v_155: bool = not-caught-fail(ssi_4) in
        {462}let v_156: bitstring = (if v_143 then catch-fail((if v_145 then (if v_152 then (if v_155 then (ssi_4,ciphertext_6) else fail-any) else fail-any) else fail-any)) else caught-fail) in
        {463}let v_157: bool = (not-caught-fail(v_156) && success?(1-proj-2-tuple(v_156))) in
        {464}let ciphertext_7: bitstring = (if v_157 then 2-proj-2-tuple(v_156) else caught-fail) in
        {465}let ss_25: symmetricstate = (if v_157 then 1-proj-2-tuple(v_156) else caught-fail) in
        {466}let hs_6: handshakestate = (if v_157 then handshakestatepack(ss_25,s_3,m_5,e_7,rs_3,rm_3,re_3,psk_3,initiator_2) else caught-fail) in
        {467}let message_buffer_1: bitstring = (if v_157 then concat3(ne_3,nm_3,ciphertext_7) else caught-fail) in
        {468}let v_158: bitstring = (if v_157 then catch-fail(symmetricstateunpack(ss_25)) else caught-fail) in
        {469}let v_159: bool = (not-caught-fail(v_158) && success?(1-proj-3-tuple(v_158))) in
        {470}let h_25: bitstring = (if v_159 then 3-proj-3-tuple(v_158) else caught-fail) in
        {471}let ck_31: key = (if v_159 then 2-proj-3-tuple(v_158) else caught-fail) in
        {472}let cs_25: cipherstate = (if v_159 then 1-proj-3-tuple(v_158) else caught-fail) in
        {473}let input_key_material_7: key = (if v_159 then zero else caught-fail) in
        {474}let output1_7: key = (if v_159 then hmac_hash1(ck_31,input_key_material_7) else caught-fail) in
        {475}let output2_7: key = (if v_159 then hmac_hash2(ck_31,input_key_material_7) else caught-fail) in
        {476}let output3_7: key = (if v_159 then hmac_hash3(ck_31,input_key_material_7) else caught-fail) in
        {477}let v_160: bitstring = (if v_159 then catch-fail((output1_7,output2_7,output3_7)) else caught-fail) in
        {478}let v_161: bool = (not-caught-fail(v_160) && success?(1-proj-3-tuple(v_160))) in
        {479}let temp_k3_1: key = (if v_161 then 3-proj-3-tuple(v_160) else caught-fail) in
        {480}let temp_k2_1: key = (if v_161 then 2-proj-3-tuple(v_160) else caught-fail) in
        {481}let temp_k1_1: key = (if v_161 then 1-proj-3-tuple(v_160) else caught-fail) in
        {482}let cs1_3: cipherstate = (if v_161 then cipherstatepack(temp_k1_1,minnonce) else caught-fail) in
        {483}let cs2_3: cipherstate = (if v_161 then cipherstatepack(temp_k2_1,minnonce) else caught-fail) in
        {484}let v_162: bitstring = (if v_157 then catch-fail((if v_159 then (if v_161 then (ss_25,cs1_3,cs2_3) else fail-any) else fail-any)) else caught-fail) in
        {485}let v_163: bool = (not-caught-fail(v_162) && success?(1-proj-3-tuple(v_162))) in
        {486}let cs2_4: cipherstate = (if v_163 then 3-proj-3-tuple(v_162) else caught-fail) in
        {487}let cs1_4: cipherstate = (if v_163 then 2-proj-3-tuple(v_162) else caught-fail) in
        {488}let ssi_5: symmetricstate = (if v_163 then 1-proj-3-tuple(v_162) else caught-fail) in
        {489}let (hs_7: handshakestate,message_a_1: bitstring,cs1_5: cipherstate,cs2_5: cipherstate) = (if v_94 then (if v_96 then (if v_98 then (if v_99 then (if v_102 then (if v_110 then (if v_118 then (if v_120 then (if v_135 then (if v_143 then (if v_157 then (if v_163 then (hs_6,message_buffer_1,cs1_4,cs2_4) else fail-any) else fail-any) else fail-any) else fail-any) else fail-any) else fail-any) else fail-any) else fail-any) else fail-any) else fail-any) else fail-any) else fail-any) in
        {490}event SendMsg(me_1,them_1,stagepack_a(sid_2),msg_a(me_1,them_1,sid_2));
        {491}out(pub, message_a_1)
    ) | (
        {493}event LeakS(phase0,me_1);
        {494}event LeakM(phase0,me_1);
        {495}out(pub, (key_s(me_1),key_m(me_1)))
    ) | (
        {496}phase 1;
        {497}event LeakS(phase1,me_1);
        {498}event LeakM(phase1,me_1);
        {499}out(pub, (key_s(me_1),key_m(me_1)))
    )
) | (
    {500}let me_2: principal = bob in
    {501}let them_2: principal = alice in
    {502}let sid_3: sessionid = sid in
    {503}let basis_8: key = key_s(me_2) in
    {504}let public_key_8: key = catch-fail(dhexp(basis_8,validkey(g))) in
    {505}let v_164: bool = not-caught-fail(public_key_8) in
    {506}let s_4: keypair = (if v_164 then keypairpack(validkey(public_key_8),basis_8) else fail-any) in
    {507}let basis_9: key = key_m(me_2) in
    {508}let public_key_9: key = catch-fail(dhexp(basis_9,validkey(g))) in
    {509}let v_165: bool = not-caught-fail(public_key_9) in
    {510}let m_6: keypair = (if v_165 then keypairpack(validkey(public_key_9),basis_9) else fail-any) in
    {511}out(pub, (getpublickey(s_4),getpublickey(m_6)));
    (
        {512}let e_10: keypair = keypairpack(empty,empty) in
        {513}let rs_4: key = empty in
        {514}let rm_4: key = empty in
        {515}let re_4: key = empty in
        {516}let prologue_2: bitstring = empty in
        {517}let psk_4: key = empty in
        {518}let protocol_name_2: bitstring = somename in
        {519}let h_26: bitstring = hash(protocol_name_2,empty) in
        {520}let ck_32: key = h_26 in
        {521}let k_10: key = empty in
        {522}let cs_26: cipherstate = cipherstatepack(k_10,minnonce) in
        {523}let ss_26: symmetricstate = symmetricstatepack(cs_26,ck_32,h_26) in
        {524}let v_166: bitstring = catch-fail(symmetricstateunpack(ss_26)) in
        {525}let v_167: bool = (not-caught-fail(v_166) && success?(1-proj-3-tuple(v_166))) in
        {526}let h_27: bitstring = (if v_167 then 3-proj-3-tuple(v_166) else caught-fail) in
        {527}let ck_33: key = (if v_167 then 2-proj-3-tuple(v_166) else caught-fail) in
        {528}let cs_27: cipherstate = (if v_167 then 1-proj-3-tuple(v_166) else caught-fail) in
        {529}let ss_27: symmetricstate = catch-fail((if v_167 then symmetricstatepack(cs_27,ck_33,hash(h_27,prologue_2)) else fail-any)) in
        {530}let v_168: bool = not-caught-fail(ss_27) in
        {531}let data: bitstring = (if v_168 then catch-fail(getpublickey(s_4)) else caught-fail) in
        {532}let v_169: bool = not-caught-fail(data) in
        {533}let v_170: bitstring = (if v_169 then catch-fail(symmetricstateunpack(ss_27)) else caught-fail) in
        {534}let v_171: bool = (not-caught-fail(v_170) && success?(1-proj-3-tuple(v_170))) in
        {535}let h_28: bitstring = (if v_171 then 3-proj-3-tuple(v_170) else caught-fail) in
        {536}let ck_34: key = (if v_171 then 2-proj-3-tuple(v_170) else caught-fail) in
        {537}let cs_28: cipherstate = (if v_171 then 1-proj-3-tuple(v_170) else caught-fail) in
        {538}let ss_28: symmetricstate = (if v_168 then catch-fail((if v_169 then (if v_171 then symmetricstatepack(cs_28,ck_34,hash(h_28,data)) else fail-any) else fail-any)) else caught-fail) in
        {539}let v_172: bool = not-caught-fail(ss_28) in
        {540}let data_1: bitstring = (if v_172 then catch-fail(getpublickey(m_6)) else caught-fail) in
        {541}let v_173: bool = not-caught-fail(data_1) in
        {542}let v_174: bitstring = (if v_173 then catch-fail(symmetricstateunpack(ss_28)) else caught-fail) in
        {543}let v_175: bool = (not-caught-fail(v_174) && success?(1-proj-3-tuple(v_174))) in
        {544}let h_29: bitstring = (if v_175 then 3-proj-3-tuple(v_174) else caught-fail) in
        {545}let ck_35: key = (if v_175 then 2-proj-3-tuple(v_174) else caught-fail) in
        {546}let cs_29: cipherstate = (if v_175 then 1-proj-3-tuple(v_174) else caught-fail) in
        {547}let ss_29: symmetricstate = (if v_172 then catch-fail((if v_173 then (if v_175 then symmetricstatepack(cs_29,ck_35,hash(h_29,data_1)) else fail-any) else fail-any)) else caught-fail) in
        {548}let v_176: bool = not-caught-fail(ss_29) in
        {549}let hs_8: handshakestate = (if v_168 then (if v_172 then (if v_176 then handshakestatepack(ss_29,s_4,m_6,e_10,rs_4,rm_4,re_4,psk_4,false) else fail-any) else fail-any) else fail-any) in
        {550}insert statestore(me_2,them_2,sid_3,statepack_a(hs_8))
    ) | (
        {752}get statestore(=me_2,=them_2,=sid_3,statepack_a(hs_9: handshakestate)) in
        {551}in(pub, message_a_2: bitstring);
        {552}let v_177: bitstring = catch-fail(handshakestateunpack(hs_9)) in
        {553}let v_178: bool = (not-caught-fail(v_177) && success?(1-proj-9-tuple(v_177))) in
        {554}let initiator_3: bool = (if v_178 then 9-proj-9-tuple(v_177) else caught-fail) in
        {555}let psk_5: key = (if v_178 then 8-proj-9-tuple(v_177) else caught-fail) in
        {556}let re_5: key = (if v_178 then 7-proj-9-tuple(v_177) else caught-fail) in
        {557}let rm_5: key = (if v_178 then 6-proj-9-tuple(v_177) else caught-fail) in
        {558}let rs_5: key = (if v_178 then 5-proj-9-tuple(v_177) else caught-fail) in
        {559}let e_11: keypair = (if v_178 then 4-proj-9-tuple(v_177) else caught-fail) in
        {560}let m_7: keypair = (if v_178 then 3-proj-9-tuple(v_177) else caught-fail) in
        {561}let s_5: keypair = (if v_178 then 2-proj-9-tuple(v_177) else caught-fail) in
        {562}let ss_30: symmetricstate = (if v_178 then 1-proj-9-tuple(v_177) else caught-fail) in
        {563}let v_179: bitstring = (if v_178 then catch-fail(deconcat3(message_a_2)) else caught-fail) in
        {564}let v_180: bool = (not-caught-fail(v_179) && success?(1-proj-3-tuple(v_179))) in
        {565}let ciphertext_8: bitstring = (if v_180 then 3-proj-3-tuple(v_179) else caught-fail) in
        {566}let nm_4: bitstring = (if v_180 then 2-proj-3-tuple(v_179) else caught-fail) in
        {567}let ne_4: bitstring = (if v_180 then 1-proj-3-tuple(v_179) else caught-fail) in
        {568}let valid1: bool = (if v_180 then true else caught-fail) in
        {569}let re_6: key = (if v_180 then ne_4 else caught-fail) in
        {570}let v_181: bitstring = (if v_180 then catch-fail(symmetricstateunpack(ss_30)) else caught-fail) in
        {571}let v_182: bool = (not-caught-fail(v_181) && success?(1-proj-3-tuple(v_181))) in
        {572}let h_30: bitstring = (if v_182 then 3-proj-3-tuple(v_181) else caught-fail) in
        {573}let ck_36: key = (if v_182 then 2-proj-3-tuple(v_181) else caught-fail) in
        {574}let cs_30: cipherstate = (if v_182 then 1-proj-3-tuple(v_181) else caught-fail) in
        {575}let ss_31: symmetricstate = (if v_180 then catch-fail((if v_182 then symmetricstatepack(cs_30,ck_36,hash(h_30,re_6)) else fail-any)) else caught-fail) in
        {576}let v_183: bool = not-caught-fail(ss_31) in
        {577}let v_184: bitstring = (if v_183 then catch-fail(keypairunpack(s_5)) else caught-fail) in
        {578}let v_185: bool = (not-caught-fail(v_184) && success?(1-proj-2-tuple(v_184))) in
        {579}let my_private_key_6: key = (if v_185 then 2-proj-2-tuple(v_184) else caught-fail) in
        {580}let my_public_key_6: key = (if v_185 then 1-proj-2-tuple(v_184) else caught-fail) in
        {581}let input_key_material_8: key = (if v_183 then catch-fail((if v_185 then dhexp(my_private_key_6,re_6) else fail-any)) else caught-fail) in
        {582}let v_186: bool = not-caught-fail(input_key_material_8) in
        {583}let v_187: bitstring = (if v_186 then catch-fail(symmetricstateunpack(ss_31)) else caught-fail) in
        {584}let v_188: bool = (not-caught-fail(v_187) && success?(1-proj-3-tuple(v_187))) in
        {585}let h_31: bitstring = (if v_188 then 3-proj-3-tuple(v_187) else caught-fail) in
        {586}let ck_37: key = (if v_188 then 2-proj-3-tuple(v_187) else caught-fail) in
        {587}let cs_31: cipherstate = (if v_188 then 1-proj-3-tuple(v_187) else caught-fail) in
        {588}let output1_8: key = (if v_188 then hmac_hash1(ck_37,input_key_material_8) else caught-fail) in
        {589}let output2_8: key = (if v_188 then hmac_hash2(ck_37,input_key_material_8) else caught-fail) in
        {590}let output3_8: key = (if v_188 then hmac_hash3(ck_37,input_key_material_8) else caught-fail) in
        {591}let v_189: bitstring = (if v_188 then catch-fail((output1_8,output2_8,output3_8)) else caught-fail) in
        {592}let v_190: bool = (not-caught-fail(v_189) && success?(1-proj-3-tuple(v_189))) in
        {593}let output_6: key = (if v_190 then 3-proj-3-tuple(v_189) else caught-fail) in
        {594}let temp_k_6: key = (if v_190 then 2-proj-3-tuple(v_189) else caught-fail) in
        {595}let ck_38: key = (if v_190 then 1-proj-3-tuple(v_189) else caught-fail) in
        {596}let ss_32: symmetricstate = (if v_183 then catch-fail((if v_186 then (if v_188 then (if v_190 then symmetricstatepack(cipherstatepack(temp_k_6,minnonce),ck_38,h_31) else fail-any) else fail-any) else fail-any)) else caught-fail) in
        {597}let v_191: bool = not-caught-fail(ss_32) in
        {598}let v_192: bitstring = (if v_191 then catch-fail(keypairunpack(m_7)) else caught-fail) in
        {599}let v_193: bool = (not-caught-fail(v_192) && success?(1-proj-2-tuple(v_192))) in
        {600}let my_private_key_7: key = (if v_193 then 2-proj-2-tuple(v_192) else caught-fail) in
        {601}let my_public_key_7: key = (if v_193 then 1-proj-2-tuple(v_192) else caught-fail) in
        {602}let input_key_material_9: key = (if v_191 then catch-fail((if v_193 then dhexp(my_private_key_7,re_6) else fail-any)) else caught-fail) in
        {603}let v_194: bool = not-caught-fail(input_key_material_9) in
        {604}let v_195: bitstring = (if v_194 then catch-fail(symmetricstateunpack(ss_32)) else caught-fail) in
        {605}let v_196: bool = (not-caught-fail(v_195) && success?(1-proj-3-tuple(v_195))) in
        {606}let h_32: bitstring = (if v_196 then 3-proj-3-tuple(v_195) else caught-fail) in
        {607}let ck_39: key = (if v_196 then 2-proj-3-tuple(v_195) else caught-fail) in
        {608}let cs_32: cipherstate = (if v_196 then 1-proj-3-tuple(v_195) else caught-fail) in
        {609}let output1_9: key = (if v_196 then hmac_hash1(ck_39,input_key_material_9) else caught-fail) in
        {610}let output2_9: key = (if v_196 then hmac_hash2(ck_39,input_key_material_9) else caught-fail) in
        {611}let output3_9: key = (if v_196 then hmac_hash3(ck_39,input_key_material_9) else caught-fail) in
        {612}let v_197: bitstring = (if v_196 then catch-fail((output1_9,output2_9,output3_9)) else caught-fail) in
        {613}let v_198: bool = (not-caught-fail(v_197) && success?(1-proj-3-tuple(v_197))) in
        {614}let output_7: key = (if v_198 then 3-proj-3-tuple(v_197) else caught-fail) in
        {615}let temp_k_7: key = (if v_198 then 2-proj-3-tuple(v_197) else caught-fail) in
        {616}let ck_40: key = (if v_198 then 1-proj-3-tuple(v_197) else caught-fail) in
        {617}let ss_33: symmetricstate = (if v_191 then catch-fail((if v_194 then (if v_196 then (if v_198 then symmetricstatepack(cipherstatepack(temp_k_7,minnonce),ck_40,h_32) else fail-any) else fail-any) else fail-any)) else caught-fail) in
        {618}let v_199: bool = not-caught-fail(ss_33) in
        {619}let v_200: bitstring = (if v_199 then catch-fail(symmetricstateunpack(ss_33)) else caught-fail) in
        {620}let v_201: bool = (not-caught-fail(v_200) && success?(1-proj-3-tuple(v_200))) in
        {621}let h_33: bitstring = (if v_201 then 3-proj-3-tuple(v_200) else caught-fail) in
        {622}let ck_41: key = (if v_201 then 2-proj-3-tuple(v_200) else caught-fail) in
        {623}let cs_33: cipherstate = (if v_201 then 1-proj-3-tuple(v_200) else caught-fail) in
        {624}let v_202: bitstring = (if v_201 then catch-fail(cipherstateunpack(cs_33)) else caught-fail) in
        {625}let v_203: bool = (not-caught-fail(v_202) && success?(1-proj-2-tuple(v_202))) in
        {626}let n_8: nonce = (if v_203 then 2-proj-2-tuple(v_202) else caught-fail) in
        {627}let k_11: key = (if v_203 then 1-proj-2-tuple(v_202) else caught-fail) in
        {628}let d: aead = (if v_203 then catch-fail(decrypt(k_11,n_8,h_33,nm_4)) else caught-fail) in
        {629}let v_204: bool = not-caught-fail(d) in
        {630}let v_205: bitstring = (if v_204 then catch-fail(aeadunpack(d)) else caught-fail) in
        {631}let v_206: bool = (not-caught-fail(v_205) && success?(1-proj-3-tuple(v_205))) in
        {632}let plaintext_2: bitstring = (if v_206 then 3-proj-3-tuple(v_205) else caught-fail) in
        {633}let adi: bitstring = (if v_206 then 2-proj-3-tuple(v_205) else caught-fail) in
        {634}let valid: bool = (if v_206 then 1-proj-3-tuple(v_205) else caught-fail) in
        {635}let n_9: nonce = (if v_206 then increment_nonce(n_8) else caught-fail) in
        {636}let v_207: bitstring = (if v_206 then catch-fail(cipherstateunpack(cs_33)) else caught-fail) in
        {637}let v_208: bool = (not-caught-fail(v_207) && success?(1-proj-2-tuple(v_207))) in
        {638}let o_4: nonce = (if v_208 then 2-proj-2-tuple(v_207) else caught-fail) in
        {639}let k_12: key = (if v_208 then 1-proj-2-tuple(v_207) else caught-fail) in
        {640}let csi_8: cipherstate = (if v_206 then catch-fail((if v_208 then cipherstatepack(k_12,n_9) else fail-any)) else caught-fail) in
        {641}let v_209: bool = not-caught-fail(csi_8) in
        {642}let v_210: bitstring = (if v_201 then catch-fail((if v_203 then (if v_204 then (if v_206 then (if v_209 then (csi_8,plaintext_2,valid) else fail-any) else fail-any) else fail-any) else fail-any)) else caught-fail) in
        {643}let v_211: bool = (not-caught-fail(v_210) && success?(1-proj-3-tuple(v_210))) in
        {644}let valid_1: bool = (if v_211 then 3-proj-3-tuple(v_210) else caught-fail) in
        {645}let plaintext_3: bitstring = (if v_211 then 2-proj-3-tuple(v_210) else caught-fail) in
        {646}let csi_9: cipherstate = (if v_211 then 1-proj-3-tuple(v_210) else caught-fail) in
        {647}let ss_34: symmetricstate = (if v_211 then symmetricstatepack(csi_9,ck_41,h_33) else caught-fail) in
        {648}let v_212: bitstring = (if v_211 then catch-fail(symmetricstateunpack(ss_34)) else caught-fail) in
        {649}let v_213: bool = (not-caught-fail(v_212) && success?(1-proj-3-tuple(v_212))) in
        {650}let h_34: bitstring = (if v_213 then 3-proj-3-tuple(v_212) else caught-fail) in
        {651}let ck_42: key = (if v_213 then 2-proj-3-tuple(v_212) else caught-fail) in
        {652}let cs_34: cipherstate = (if v_213 then 1-proj-3-tuple(v_212) else caught-fail) in
        {653}let ssi_6: symmetricstate = (if v_211 then catch-fail((if v_213 then symmetricstatepack(cs_34,ck_42,hash(h_34,nm_4)) else fail-any)) else caught-fail) in
        {654}let v_214: bool = not-caught-fail(ssi_6) in
        {655}let v_215: bitstring = (if v_199 then catch-fail((if v_201 then (if v_211 then (if v_214 then (ssi_6,plaintext_3,valid_1) else fail-any) else fail-any) else fail-any)) else caught-fail) in
        {656}let v_216: bool = (not-caught-fail(v_215) && success?(1-proj-3-tuple(v_215))) in
        {657}let valid1_1: bool = (if v_216 then 3-proj-3-tuple(v_215) else caught-fail) in
        {658}let me_3: bitstring = (if v_216 then 2-proj-3-tuple(v_215) else caught-fail) in
        {659}let ss_35: symmetricstate = (if v_216 then 1-proj-3-tuple(v_215) else caught-fail) in
        {660}let rm_6: key = (if v_216 then me_3 else caught-fail) in
        {661}let v_217: bitstring = (if v_216 then catch-fail(keypairunpack(s_5)) else caught-fail) in
        {662}let v_218: bool = (not-caught-fail(v_217) && success?(1-proj-2-tuple(v_217))) in
        {663}let my_private_key_8: key = (if v_218 then 2-proj-2-tuple(v_217) else caught-fail) in
        {664}let my_public_key_8: key = (if v_218 then 1-proj-2-tuple(v_217) else caught-fail) in
        {665}let input_key_material_10: key = (if v_216 then catch-fail((if v_218 then dhexp(my_private_key_8,rm_6) else fail-any)) else caught-fail) in
        {666}let v_219: bool = not-caught-fail(input_key_material_10) in
        {667}let v_220: bitstring = (if v_219 then catch-fail(symmetricstateunpack(ss_35)) else caught-fail) in
        {668}let v_221: bool = (not-caught-fail(v_220) && success?(1-proj-3-tuple(v_220))) in
        {669}let h_35: bitstring = (if v_221 then 3-proj-3-tuple(v_220) else caught-fail) in
        {670}let ck_43: key = (if v_221 then 2-proj-3-tuple(v_220) else caught-fail) in
        {671}let cs_35: cipherstate = (if v_221 then 1-proj-3-tuple(v_220) else caught-fail) in
        {672}let output1_10: key = (if v_221 then hmac_hash1(ck_43,input_key_material_10) else caught-fail) in
        {673}let output2_10: key = (if v_221 then hmac_hash2(ck_43,input_key_material_10) else caught-fail) in
        {674}let output3_10: key = (if v_221 then hmac_hash3(ck_43,input_key_material_10) else caught-fail) in
        {675}let v_222: bitstring = (if v_221 then catch-fail((output1_10,output2_10,output3_10)) else caught-fail) in
        {676}let v_223: bool = (not-caught-fail(v_222) && success?(1-proj-3-tuple(v_222))) in
        {677}let output_8: key = (if v_223 then 3-proj-3-tuple(v_222) else caught-fail) in
        {678}let temp_k_8: key = (if v_223 then 2-proj-3-tuple(v_222) else caught-fail) in
        {679}let ck_44: key = (if v_223 then 1-proj-3-tuple(v_222) else caught-fail) in
        {680}let ss_36: symmetricstate = (if v_216 then catch-fail((if v_219 then (if v_221 then (if v_223 then symmetricstatepack(cipherstatepack(temp_k_8,minnonce),ck_44,h_35) else fail-any) else fail-any) else fail-any)) else caught-fail) in
        {681}let v_224: bool = not-caught-fail(ss_36) in
        {682}let v_225: bitstring = (if v_224 then catch-fail(symmetricstateunpack(ss_36)) else caught-fail) in
        {683}let v_226: bool = (not-caught-fail(v_225) && success?(1-proj-3-tuple(v_225))) in
        {684}let h_36: bitstring = (if v_226 then 3-proj-3-tuple(v_225) else caught-fail) in
        {685}let ck_45: key = (if v_226 then 2-proj-3-tuple(v_225) else caught-fail) in
        {686}let cs_36: cipherstate = (if v_226 then 1-proj-3-tuple(v_225) else caught-fail) in
        {687}let v_227: bitstring = (if v_226 then catch-fail(cipherstateunpack(cs_36)) else caught-fail) in
        {688}let v_228: bool = (not-caught-fail(v_227) && success?(1-proj-2-tuple(v_227))) in
        {689}let n_10: nonce = (if v_228 then 2-proj-2-tuple(v_227) else caught-fail) in
        {690}let k_13: key = (if v_228 then 1-proj-2-tuple(v_227) else caught-fail) in
        {691}let d_1: aead = (if v_228 then catch-fail(decrypt(k_13,n_10,h_36,ciphertext_8)) else caught-fail) in
        {692}let v_229: bool = not-caught-fail(d_1) in
        {693}let v_230: bitstring = (if v_229 then catch-fail(aeadunpack(d_1)) else caught-fail) in
        {694}let v_231: bool = (not-caught-fail(v_230) && success?(1-proj-3-tuple(v_230))) in
        {695}let plaintext_4: bitstring = (if v_231 then 3-proj-3-tuple(v_230) else caught-fail) in
        {696}let adi_1: bitstring = (if v_231 then 2-proj-3-tuple(v_230) else caught-fail) in
        {697}let valid_2: bool = (if v_231 then 1-proj-3-tuple(v_230) else caught-fail) in
        {698}let n_11: nonce = (if v_231 then increment_nonce(n_10) else caught-fail) in
        {699}let v_232: bitstring = (if v_231 then catch-fail(cipherstateunpack(cs_36)) else caught-fail) in
        {700}let v_233: bool = (not-caught-fail(v_232) && success?(1-proj-2-tuple(v_232))) in
        {701}let o_5: nonce = (if v_233 then 2-proj-2-tuple(v_232) else caught-fail) in
        {702}let k_14: key = (if v_233 then 1-proj-2-tuple(v_232) else caught-fail) in
        {703}let csi_10: cipherstate = (if v_231 then catch-fail((if v_233 then cipherstatepack(k_14,n_11) else fail-any)) else caught-fail) in
        {704}let v_234: bool = not-caught-fail(csi_10) in
        {705}let v_235: bitstring = (if v_226 then catch-fail((if v_228 then (if v_229 then (if v_231 then (if v_234 then (csi_10,plaintext_4,valid_2) else fail-any) else fail-any) else fail-any) else fail-any)) else caught-fail) in
        {706}let v_236: bool = (not-caught-fail(v_235) && success?(1-proj-3-tuple(v_235))) in
        {707}let valid_3: bool = (if v_236 then 3-proj-3-tuple(v_235) else caught-fail) in
        {708}let plaintext_5: bitstring = (if v_236 then 2-proj-3-tuple(v_235) else caught-fail) in
        {709}let csi_11: cipherstate = (if v_236 then 1-proj-3-tuple(v_235) else caught-fail) in
        {710}let ss_37: symmetricstate = (if v_236 then symmetricstatepack(csi_11,ck_45,h_36) else caught-fail) in
        {711}let v_237: bitstring = (if v_236 then catch-fail(symmetricstateunpack(ss_37)) else caught-fail) in
        {712}let v_238: bool = (not-caught-fail(v_237) && success?(1-proj-3-tuple(v_237))) in
        {713}let h_37: bitstring = (if v_238 then 3-proj-3-tuple(v_237) else caught-fail) in
        {714}let ck_46: key = (if v_238 then 2-proj-3-tuple(v_237) else caught-fail) in
        {715}let cs_37: cipherstate = (if v_238 then 1-proj-3-tuple(v_237) else caught-fail) in
        {716}let ssi_7: symmetricstate = (if v_236 then catch-fail((if v_238 then symmetricstatepack(cs_37,ck_46,hash(h_37,ciphertext_8)) else fail-any)) else caught-fail) in
        {717}let v_239: bool = not-caught-fail(ssi_7) in
        {718}let v_240: bitstring = (if v_224 then catch-fail((if v_226 then (if v_236 then (if v_239 then (ssi_7,plaintext_5,valid_3) else fail-any) else fail-any) else fail-any)) else caught-fail) in
        {719}let v_241: bool = (not-caught-fail(v_240) && success?(1-proj-3-tuple(v_240))) in
        {720}let valid2: bool = (if v_241 then 3-proj-3-tuple(v_240) else caught-fail) in
        {721}let plaintext_6: bitstring = (if v_241 then 2-proj-3-tuple(v_240) else caught-fail) in
        {722}let ss_38: symmetricstate = (if v_241 then 1-proj-3-tuple(v_240) else caught-fail) in
        {723}let basis_10: key = (if v_241 then key_s(them_2) else caught-fail) in
        {724}let public_key_10: key = (if v_241 then catch-fail(dhexp(basis_10,validkey(g))) else caught-fail) in
        {725}let v_242: bool = not-caught-fail(public_key_10) in
        {726}let v_243: bool = (if v_241 then catch-fail(((valid1_1 && valid2) && (rs_5 = getpublickey((if v_242 then keypairpack(validkey(public_key_10),basis_10) else fail-any))))) else caught-fail) in
        {727}let hs_10: handshakestate = (if v_243 then handshakestatepack(ss_38,s_5,m_7,e_11,rs_5,rm_6,re_6,psk_5,initiator_3) else caught-fail) in
        {728}let v_244: bitstring = (if v_243 then catch-fail(symmetricstateunpack(ss_38)) else caught-fail) in
        {729}let v_245: bool = (not-caught-fail(v_244) && success?(1-proj-3-tuple(v_244))) in
        {730}let h_38: bitstring = (if v_245 then 3-proj-3-tuple(v_244) else caught-fail) in
        {731}let ck_47: key = (if v_245 then 2-proj-3-tuple(v_244) else caught-fail) in
        {732}let cs_38: cipherstate = (if v_245 then 1-proj-3-tuple(v_244) else caught-fail) in
        {733}let input_key_material_11: key = (if v_245 then zero else caught-fail) in
        {734}let output1_11: key = (if v_245 then hmac_hash1(ck_47,input_key_material_11) else caught-fail) in
        {735}let output2_11: key = (if v_245 then hmac_hash2(ck_47,input_key_material_11) else caught-fail) in
        {736}let output3_11: key = (if v_245 then hmac_hash3(ck_47,input_key_material_11) else caught-fail) in
        {737}let v_246: bitstring = (if v_245 then catch-fail((output1_11,output2_11,output3_11)) else caught-fail) in
        {738}let v_247: bool = (not-caught-fail(v_246) && success?(1-proj-3-tuple(v_246))) in
        {739}let temp_k3_2: key = (if v_247 then 3-proj-3-tuple(v_246) else caught-fail) in
        {740}let temp_k2_2: key = (if v_247 then 2-proj-3-tuple(v_246) else caught-fail) in
        {741}let temp_k1_2: key = (if v_247 then 1-proj-3-tuple(v_246) else caught-fail) in
        {742}let cs1_6: cipherstate = (if v_247 then cipherstatepack(temp_k1_2,minnonce) else caught-fail) in
        {743}let cs2_6: cipherstate = (if v_247 then cipherstatepack(temp_k2_2,minnonce) else caught-fail) in
        {744}let v_248: bitstring = (if v_243 then catch-fail((if v_245 then (if v_247 then (ss_38,cs1_6,cs2_6) else fail-any) else fail-any)) else caught-fail) in
        {745}let v_249: bool = (not-caught-fail(v_248) && success?(1-proj-3-tuple(v_248))) in
        {746}let cs2_7: cipherstate = (if v_249 then 3-proj-3-tuple(v_248) else caught-fail) in
        {747}let cs1_7: cipherstate = (if v_249 then 2-proj-3-tuple(v_248) else caught-fail) in
        {748}let ssi_8: symmetricstate = (if v_249 then 1-proj-3-tuple(v_248) else caught-fail) in
        {749}let (hs_11: handshakestate,plaintext_a: bitstring,valid_4: bool,cs1_8: cipherstate,cs2_8: cipherstate) = (if v_178 then (if v_180 then (if v_183 then (if v_191 then (if v_199 then (if v_216 then (if v_224 then (if v_241 then (if undo-catch-fail(v_243) then (if v_249 then (hs_10,plaintext_6,true,cs1_7,cs2_7) else fail-any) else fail-any) else fail-any) else fail-any) else fail-any) else fail-any) else fail-any) else fail-any) else fail-any) else fail-any) in
        {750}event RecvMsg(me_2,them_2,stagepack_a(sid_3),plaintext_a);
        {751}event RecvEnd(valid_4)
    ) | (
        {753}event LeakS(phase0,me_2);
        {754}event LeakM(phase0,me_2);
        {755}out(pub, (key_s(me_2),key_m(me_2)))
    ) | (
        {756}phase 1;
        {757}event LeakS(phase1,me_2);
        {758}event LeakM(phase1,me_2);
        {759}out(pub, (key_s(me_2),key_m(me_2)))
    )
) | (
    {760}let me_4: principal = bob in
    {761}let them_3: principal = charlie in
    {762}let sid_4: sessionid = sid in
    {763}let basis_11: key = key_s(me_4) in
    {764}let public_key_11: key = catch-fail(dhexp(basis_11,validkey(g))) in
    {765}let v_250: bool = not-caught-fail(public_key_11) in
    {766}let s_6: keypair = (if v_250 then keypairpack(validkey(public_key_11),basis_11) else fail-any) in
    {767}let basis_12: key = key_m(me_4) in
    {768}let public_key_12: key = catch-fail(dhexp(basis_12,validkey(g))) in
    {769}let v_251: bool = not-caught-fail(public_key_12) in
    {770}let m_8: keypair = (if v_251 then keypairpack(validkey(public_key_12),basis_12) else fail-any) in
    {771}out(pub, (getpublickey(s_6),getpublickey(m_8)));
    (
        {772}let e_12: keypair = keypairpack(empty,empty) in
        {773}let rs_6: key = empty in
        {774}let rm_7: key = empty in
        {775}let re_7: key = empty in
        {776}let prologue_3: bitstring = empty in
        {777}let psk_6: key = empty in
        {778}let protocol_name_3: bitstring = somename in
        {779}let h_39: bitstring = hash(protocol_name_3,empty) in
        {780}let ck_48: key = h_39 in
        {781}let k_15: key = empty in
        {782}let cs_39: cipherstate = cipherstatepack(k_15,minnonce) in
        {783}let ss_39: symmetricstate = symmetricstatepack(cs_39,ck_48,h_39) in
        {784}let v_252: bitstring = catch-fail(symmetricstateunpack(ss_39)) in
        {785}let v_253: bool = (not-caught-fail(v_252) && success?(1-proj-3-tuple(v_252))) in
        {786}let h_40: bitstring = (if v_253 then 3-proj-3-tuple(v_252) else caught-fail) in
        {787}let ck_49: key = (if v_253 then 2-proj-3-tuple(v_252) else caught-fail) in
        {788}let cs_40: cipherstate = (if v_253 then 1-proj-3-tuple(v_252) else caught-fail) in
        {789}let ss_40: symmetricstate = catch-fail((if v_253 then symmetricstatepack(cs_40,ck_49,hash(h_40,prologue_3)) else fail-any)) in
        {790}let v_254: bool = not-caught-fail(ss_40) in
        {791}let data_2: bitstring = (if v_254 then catch-fail(getpublickey(s_6)) else caught-fail) in
        {792}let v_255: bool = not-caught-fail(data_2) in
        {793}let v_256: bitstring = (if v_255 then catch-fail(symmetricstateunpack(ss_40)) else caught-fail) in
        {794}let v_257: bool = (not-caught-fail(v_256) && success?(1-proj-3-tuple(v_256))) in
        {795}let h_41: bitstring = (if v_257 then 3-proj-3-tuple(v_256) else caught-fail) in
        {796}let ck_50: key = (if v_257 then 2-proj-3-tuple(v_256) else caught-fail) in
        {797}let cs_41: cipherstate = (if v_257 then 1-proj-3-tuple(v_256) else caught-fail) in
        {798}let ss_41: symmetricstate = (if v_254 then catch-fail((if v_255 then (if v_257 then symmetricstatepack(cs_41,ck_50,hash(h_41,data_2)) else fail-any) else fail-any)) else caught-fail) in
        {799}let v_258: bool = not-caught-fail(ss_41) in
        {800}let data_3: bitstring = (if v_258 then catch-fail(getpublickey(m_8)) else caught-fail) in
        {801}let v_259: bool = not-caught-fail(data_3) in
        {802}let v_260: bitstring = (if v_259 then catch-fail(symmetricstateunpack(ss_41)) else caught-fail) in
        {803}let v_261: bool = (not-caught-fail(v_260) && success?(1-proj-3-tuple(v_260))) in
        {804}let h_42: bitstring = (if v_261 then 3-proj-3-tuple(v_260) else caught-fail) in
        {805}let ck_51: key = (if v_261 then 2-proj-3-tuple(v_260) else caught-fail) in
        {806}let cs_42: cipherstate = (if v_261 then 1-proj-3-tuple(v_260) else caught-fail) in
        {807}let ss_42: symmetricstate = (if v_258 then catch-fail((if v_259 then (if v_261 then symmetricstatepack(cs_42,ck_51,hash(h_42,data_3)) else fail-any) else fail-any)) else caught-fail) in
        {808}let v_262: bool = not-caught-fail(ss_42) in
        {809}let hs_12: handshakestate = (if v_254 then (if v_258 then (if v_262 then handshakestatepack(ss_42,s_6,m_8,e_12,rs_6,rm_7,re_7,psk_6,false) else fail-any) else fail-any) else fail-any) in
        {810}insert statestore(me_4,them_3,sid_4,statepack_a(hs_12))
    ) | (
        {1012}get statestore(=me_4,=them_3,=sid_4,statepack_a(hs_13: handshakestate)) in
        {811}in(pub, message_a_3: bitstring);
        {812}let v_263: bitstring = catch-fail(handshakestateunpack(hs_13)) in
        {813}let v_264: bool = (not-caught-fail(v_263) && success?(1-proj-9-tuple(v_263))) in
        {814}let initiator_4: bool = (if v_264 then 9-proj-9-tuple(v_263) else caught-fail) in
        {815}let psk_7: key = (if v_264 then 8-proj-9-tuple(v_263) else caught-fail) in
        {816}let re_8: key = (if v_264 then 7-proj-9-tuple(v_263) else caught-fail) in
        {817}let rm_8: key = (if v_264 then 6-proj-9-tuple(v_263) else caught-fail) in
        {818}let rs_7: key = (if v_264 then 5-proj-9-tuple(v_263) else caught-fail) in
        {819}let e_13: keypair = (if v_264 then 4-proj-9-tuple(v_263) else caught-fail) in
        {820}let m_9: keypair = (if v_264 then 3-proj-9-tuple(v_263) else caught-fail) in
        {821}let s_7: keypair = (if v_264 then 2-proj-9-tuple(v_263) else caught-fail) in
        {822}let ss_43: symmetricstate = (if v_264 then 1-proj-9-tuple(v_263) else caught-fail) in
        {823}let v_265: bitstring = (if v_264 then catch-fail(deconcat3(message_a_3)) else caught-fail) in
        {824}let v_266: bool = (not-caught-fail(v_265) && success?(1-proj-3-tuple(v_265))) in
        {825}let ciphertext_9: bitstring = (if v_266 then 3-proj-3-tuple(v_265) else caught-fail) in
        {826}let nm_5: bitstring = (if v_266 then 2-proj-3-tuple(v_265) else caught-fail) in
        {827}let ne_5: bitstring = (if v_266 then 1-proj-3-tuple(v_265) else caught-fail) in
        {828}let valid1_2: bool = (if v_266 then true else caught-fail) in
        {829}let re_9: key = (if v_266 then ne_5 else caught-fail) in
        {830}let v_267: bitstring = (if v_266 then catch-fail(symmetricstateunpack(ss_43)) else caught-fail) in
        {831}let v_268: bool = (not-caught-fail(v_267) && success?(1-proj-3-tuple(v_267))) in
        {832}let h_43: bitstring = (if v_268 then 3-proj-3-tuple(v_267) else caught-fail) in
        {833}let ck_52: key = (if v_268 then 2-proj-3-tuple(v_267) else caught-fail) in
        {834}let cs_43: cipherstate = (if v_268 then 1-proj-3-tuple(v_267) else caught-fail) in
        {835}let ss_44: symmetricstate = (if v_266 then catch-fail((if v_268 then symmetricstatepack(cs_43,ck_52,hash(h_43,re_9)) else fail-any)) else caught-fail) in
        {836}let v_269: bool = not-caught-fail(ss_44) in
        {837}let v_270: bitstring = (if v_269 then catch-fail(keypairunpack(s_7)) else caught-fail) in
        {838}let v_271: bool = (not-caught-fail(v_270) && success?(1-proj-2-tuple(v_270))) in
        {839}let my_private_key_9: key = (if v_271 then 2-proj-2-tuple(v_270) else caught-fail) in
        {840}let my_public_key_9: key = (if v_271 then 1-proj-2-tuple(v_270) else caught-fail) in
        {841}let input_key_material_12: key = (if v_269 then catch-fail((if v_271 then dhexp(my_private_key_9,re_9) else fail-any)) else caught-fail) in
        {842}let v_272: bool = not-caught-fail(input_key_material_12) in
        {843}let v_273: bitstring = (if v_272 then catch-fail(symmetricstateunpack(ss_44)) else caught-fail) in
        {844}let v_274: bool = (not-caught-fail(v_273) && success?(1-proj-3-tuple(v_273))) in
        {845}let h_44: bitstring = (if v_274 then 3-proj-3-tuple(v_273) else caught-fail) in
        {846}let ck_53: key = (if v_274 then 2-proj-3-tuple(v_273) else caught-fail) in
        {847}let cs_44: cipherstate = (if v_274 then 1-proj-3-tuple(v_273) else caught-fail) in
        {848}let output1_12: key = (if v_274 then hmac_hash1(ck_53,input_key_material_12) else caught-fail) in
        {849}let output2_12: key = (if v_274 then hmac_hash2(ck_53,input_key_material_12) else caught-fail) in
        {850}let output3_12: key = (if v_274 then hmac_hash3(ck_53,input_key_material_12) else caught-fail) in
        {851}let v_275: bitstring = (if v_274 then catch-fail((output1_12,output2_12,output3_12)) else caught-fail) in
        {852}let v_276: bool = (not-caught-fail(v_275) && success?(1-proj-3-tuple(v_275))) in
        {853}let output_9: key = (if v_276 then 3-proj-3-tuple(v_275) else caught-fail) in
        {854}let temp_k_9: key = (if v_276 then 2-proj-3-tuple(v_275) else caught-fail) in
        {855}let ck_54: key = (if v_276 then 1-proj-3-tuple(v_275) else caught-fail) in
        {856}let ss_45: symmetricstate = (if v_269 then catch-fail((if v_272 then (if v_274 then (if v_276 then symmetricstatepack(cipherstatepack(temp_k_9,minnonce),ck_54,h_44) else fail-any) else fail-any) else fail-any)) else caught-fail) in
        {857}let v_277: bool = not-caught-fail(ss_45) in
        {858}let v_278: bitstring = (if v_277 then catch-fail(keypairunpack(m_9)) else caught-fail) in
        {859}let v_279: bool = (not-caught-fail(v_278) && success?(1-proj-2-tuple(v_278))) in
        {860}let my_private_key_10: key = (if v_279 then 2-proj-2-tuple(v_278) else caught-fail) in
        {861}let my_public_key_10: key = (if v_279 then 1-proj-2-tuple(v_278) else caught-fail) in
        {862}let input_key_material_13: key = (if v_277 then catch-fail((if v_279 then dhexp(my_private_key_10,re_9) else fail-any)) else caught-fail) in
        {863}let v_280: bool = not-caught-fail(input_key_material_13) in
        {864}let v_281: bitstring = (if v_280 then catch-fail(symmetricstateunpack(ss_45)) else caught-fail) in
        {865}let v_282: bool = (not-caught-fail(v_281) && success?(1-proj-3-tuple(v_281))) in
        {866}let h_45: bitstring = (if v_282 then 3-proj-3-tuple(v_281) else caught-fail) in
        {867}let ck_55: key = (if v_282 then 2-proj-3-tuple(v_281) else caught-fail) in
        {868}let cs_45: cipherstate = (if v_282 then 1-proj-3-tuple(v_281) else caught-fail) in
        {869}let output1_13: key = (if v_282 then hmac_hash1(ck_55,input_key_material_13) else caught-fail) in
        {870}let output2_13: key = (if v_282 then hmac_hash2(ck_55,input_key_material_13) else caught-fail) in
        {871}let output3_13: key = (if v_282 then hmac_hash3(ck_55,input_key_material_13) else caught-fail) in
        {872}let v_283: bitstring = (if v_282 then catch-fail((output1_13,output2_13,output3_13)) else caught-fail) in
        {873}let v_284: bool = (not-caught-fail(v_283) && success?(1-proj-3-tuple(v_283))) in
        {874}let output_10: key = (if v_284 then 3-proj-3-tuple(v_283) else caught-fail) in
        {875}let temp_k_10: key = (if v_284 then 2-proj-3-tuple(v_283) else caught-fail) in
        {876}let ck_56: key = (if v_284 then 1-proj-3-tuple(v_283) else caught-fail) in
        {877}let ss_46: symmetricstate = (if v_277 then catch-fail((if v_280 then (if v_282 then (if v_284 then symmetricstatepack(cipherstatepack(temp_k_10,minnonce),ck_56,h_45) else fail-any) else fail-any) else fail-any)) else caught-fail) in
        {878}let v_285: bool = not-caught-fail(ss_46) in
        {879}let v_286: bitstring = (if v_285 then catch-fail(symmetricstateunpack(ss_46)) else caught-fail) in
        {880}let v_287: bool = (not-caught-fail(v_286) && success?(1-proj-3-tuple(v_286))) in
        {881}let h_46: bitstring = (if v_287 then 3-proj-3-tuple(v_286) else caught-fail) in
        {882}let ck_57: key = (if v_287 then 2-proj-3-tuple(v_286) else caught-fail) in
        {883}let cs_46: cipherstate = (if v_287 then 1-proj-3-tuple(v_286) else caught-fail) in
        {884}let v_288: bitstring = (if v_287 then catch-fail(cipherstateunpack(cs_46)) else caught-fail) in
        {885}let v_289: bool = (not-caught-fail(v_288) && success?(1-proj-2-tuple(v_288))) in
        {886}let n_12: nonce = (if v_289 then 2-proj-2-tuple(v_288) else caught-fail) in
        {887}let k_16: key = (if v_289 then 1-proj-2-tuple(v_288) else caught-fail) in
        {888}let d_2: aead = (if v_289 then catch-fail(decrypt(k_16,n_12,h_46,nm_5)) else caught-fail) in
        {889}let v_290: bool = not-caught-fail(d_2) in
        {890}let v_291: bitstring = (if v_290 then catch-fail(aeadunpack(d_2)) else caught-fail) in
        {891}let v_292: bool = (not-caught-fail(v_291) && success?(1-proj-3-tuple(v_291))) in
        {892}let plaintext_7: bitstring = (if v_292 then 3-proj-3-tuple(v_291) else caught-fail) in
        {893}let adi_2: bitstring = (if v_292 then 2-proj-3-tuple(v_291) else caught-fail) in
        {894}let valid_5: bool = (if v_292 then 1-proj-3-tuple(v_291) else caught-fail) in
        {895}let n_13: nonce = (if v_292 then increment_nonce(n_12) else caught-fail) in
        {896}let v_293: bitstring = (if v_292 then catch-fail(cipherstateunpack(cs_46)) else caught-fail) in
        {897}let v_294: bool = (not-caught-fail(v_293) && success?(1-proj-2-tuple(v_293))) in
        {898}let o_6: nonce = (if v_294 then 2-proj-2-tuple(v_293) else caught-fail) in
        {899}let k_17: key = (if v_294 then 1-proj-2-tuple(v_293) else caught-fail) in
        {900}let csi_12: cipherstate = (if v_292 then catch-fail((if v_294 then cipherstatepack(k_17,n_13) else fail-any)) else caught-fail) in
        {901}let v_295: bool = not-caught-fail(csi_12) in
        {902}let v_296: bitstring = (if v_287 then catch-fail((if v_289 then (if v_290 then (if v_292 then (if v_295 then (csi_12,plaintext_7,valid_5) else fail-any) else fail-any) else fail-any) else fail-any)) else caught-fail) in
        {903}let v_297: bool = (not-caught-fail(v_296) && success?(1-proj-3-tuple(v_296))) in
        {904}let valid_6: bool = (if v_297 then 3-proj-3-tuple(v_296) else caught-fail) in
        {905}let plaintext_8: bitstring = (if v_297 then 2-proj-3-tuple(v_296) else caught-fail) in
        {906}let csi_13: cipherstate = (if v_297 then 1-proj-3-tuple(v_296) else caught-fail) in
        {907}let ss_47: symmetricstate = (if v_297 then symmetricstatepack(csi_13,ck_57,h_46) else caught-fail) in
        {908}let v_298: bitstring = (if v_297 then catch-fail(symmetricstateunpack(ss_47)) else caught-fail) in
        {909}let v_299: bool = (not-caught-fail(v_298) && success?(1-proj-3-tuple(v_298))) in
        {910}let h_47: bitstring = (if v_299 then 3-proj-3-tuple(v_298) else caught-fail) in
        {911}let ck_58: key = (if v_299 then 2-proj-3-tuple(v_298) else caught-fail) in
        {912}let cs_47: cipherstate = (if v_299 then 1-proj-3-tuple(v_298) else caught-fail) in
        {913}let ssi_9: symmetricstate = (if v_297 then catch-fail((if v_299 then symmetricstatepack(cs_47,ck_58,hash(h_47,nm_5)) else fail-any)) else caught-fail) in
        {914}let v_300: bool = not-caught-fail(ssi_9) in
        {915}let v_301: bitstring = (if v_285 then catch-fail((if v_287 then (if v_297 then (if v_300 then (ssi_9,plaintext_8,valid_6) else fail-any) else fail-any) else fail-any)) else caught-fail) in
        {916}let v_302: bool = (not-caught-fail(v_301) && success?(1-proj-3-tuple(v_301))) in
        {917}let valid1_3: bool = (if v_302 then 3-proj-3-tuple(v_301) else caught-fail) in
        {918}let me_5: bitstring = (if v_302 then 2-proj-3-tuple(v_301) else caught-fail) in
        {919}let ss_48: symmetricstate = (if v_302 then 1-proj-3-tuple(v_301) else caught-fail) in
        {920}let rm_9: key = (if v_302 then me_5 else caught-fail) in
        {921}let v_303: bitstring = (if v_302 then catch-fail(keypairunpack(s_7)) else caught-fail) in
        {922}let v_304: bool = (not-caught-fail(v_303) && success?(1-proj-2-tuple(v_303))) in
        {923}let my_private_key_11: key = (if v_304 then 2-proj-2-tuple(v_303) else caught-fail) in
        {924}let my_public_key_11: key = (if v_304 then 1-proj-2-tuple(v_303) else caught-fail) in
        {925}let input_key_material_14: key = (if v_302 then catch-fail((if v_304 then dhexp(my_private_key_11,rm_9) else fail-any)) else caught-fail) in
        {926}let v_305: bool = not-caught-fail(input_key_material_14) in
        {927}let v_306: bitstring = (if v_305 then catch-fail(symmetricstateunpack(ss_48)) else caught-fail) in
        {928}let v_307: bool = (not-caught-fail(v_306) && success?(1-proj-3-tuple(v_306))) in
        {929}let h_48: bitstring = (if v_307 then 3-proj-3-tuple(v_306) else caught-fail) in
        {930}let ck_59: key = (if v_307 then 2-proj-3-tuple(v_306) else caught-fail) in
        {931}let cs_48: cipherstate = (if v_307 then 1-proj-3-tuple(v_306) else caught-fail) in
        {932}let output1_14: key = (if v_307 then hmac_hash1(ck_59,input_key_material_14) else caught-fail) in
        {933}let output2_14: key = (if v_307 then hmac_hash2(ck_59,input_key_material_14) else caught-fail) in
        {934}let output3_14: key = (if v_307 then hmac_hash3(ck_59,input_key_material_14) else caught-fail) in
        {935}let v_308: bitstring = (if v_307 then catch-fail((output1_14,output2_14,output3_14)) else caught-fail) in
        {936}let v_309: bool = (not-caught-fail(v_308) && success?(1-proj-3-tuple(v_308))) in
        {937}let output_11: key = (if v_309 then 3-proj-3-tuple(v_308) else caught-fail) in
        {938}let temp_k_11: key = (if v_309 then 2-proj-3-tuple(v_308) else caught-fail) in
        {939}let ck_60: key = (if v_309 then 1-proj-3-tuple(v_308) else caught-fail) in
        {940}let ss_49: symmetricstate = (if v_302 then catch-fail((if v_305 then (if v_307 then (if v_309 then symmetricstatepack(cipherstatepack(temp_k_11,minnonce),ck_60,h_48) else fail-any) else fail-any) else fail-any)) else caught-fail) in
        {941}let v_310: bool = not-caught-fail(ss_49) in
        {942}let v_311: bitstring = (if v_310 then catch-fail(symmetricstateunpack(ss_49)) else caught-fail) in
        {943}let v_312: bool = (not-caught-fail(v_311) && success?(1-proj-3-tuple(v_311))) in
        {944}let h_49: bitstring = (if v_312 then 3-proj-3-tuple(v_311) else caught-fail) in
        {945}let ck_61: key = (if v_312 then 2-proj-3-tuple(v_311) else caught-fail) in
        {946}let cs_49: cipherstate = (if v_312 then 1-proj-3-tuple(v_311) else caught-fail) in
        {947}let v_313: bitstring = (if v_312 then catch-fail(cipherstateunpack(cs_49)) else caught-fail) in
        {948}let v_314: bool = (not-caught-fail(v_313) && success?(1-proj-2-tuple(v_313))) in
        {949}let n_14: nonce = (if v_314 then 2-proj-2-tuple(v_313) else caught-fail) in
        {950}let k_18: key = (if v_314 then 1-proj-2-tuple(v_313) else caught-fail) in
        {951}let d_3: aead = (if v_314 then catch-fail(decrypt(k_18,n_14,h_49,ciphertext_9)) else caught-fail) in
        {952}let v_315: bool = not-caught-fail(d_3) in
        {953}let v_316: bitstring = (if v_315 then catch-fail(aeadunpack(d_3)) else caught-fail) in
        {954}let v_317: bool = (not-caught-fail(v_316) && success?(1-proj-3-tuple(v_316))) in
        {955}let plaintext_9: bitstring = (if v_317 then 3-proj-3-tuple(v_316) else caught-fail) in
        {956}let adi_3: bitstring = (if v_317 then 2-proj-3-tuple(v_316) else caught-fail) in
        {957}let valid_7: bool = (if v_317 then 1-proj-3-tuple(v_316) else caught-fail) in
        {958}let n_15: nonce = (if v_317 then increment_nonce(n_14) else caught-fail) in
        {959}let v_318: bitstring = (if v_317 then catch-fail(cipherstateunpack(cs_49)) else caught-fail) in
        {960}let v_319: bool = (not-caught-fail(v_318) && success?(1-proj-2-tuple(v_318))) in
        {961}let o_7: nonce = (if v_319 then 2-proj-2-tuple(v_318) else caught-fail) in
        {962}let k_19: key = (if v_319 then 1-proj-2-tuple(v_318) else caught-fail) in
        {963}let csi_14: cipherstate = (if v_317 then catch-fail((if v_319 then cipherstatepack(k_19,n_15) else fail-any)) else caught-fail) in
        {964}let v_320: bool = not-caught-fail(csi_14) in
        {965}let v_321: bitstring = (if v_312 then catch-fail((if v_314 then (if v_315 then (if v_317 then (if v_320 then (csi_14,plaintext_9,valid_7) else fail-any) else fail-any) else fail-any) else fail-any)) else caught-fail) in
        {966}let v_322: bool = (not-caught-fail(v_321) && success?(1-proj-3-tuple(v_321))) in
        {967}let valid_8: bool = (if v_322 then 3-proj-3-tuple(v_321) else caught-fail) in
        {968}let plaintext_10: bitstring = (if v_322 then 2-proj-3-tuple(v_321) else caught-fail) in
        {969}let csi_15: cipherstate = (if v_322 then 1-proj-3-tuple(v_321) else caught-fail) in
        {970}let ss_50: symmetricstate = (if v_322 then symmetricstatepack(csi_15,ck_61,h_49) else caught-fail) in
        {971}let v_323: bitstring = (if v_322 then catch-fail(symmetricstateunpack(ss_50)) else caught-fail) in
        {972}let v_324: bool = (not-caught-fail(v_323) && success?(1-proj-3-tuple(v_323))) in
        {973}let h_50: bitstring = (if v_324 then 3-proj-3-tuple(v_323) else caught-fail) in
        {974}let ck_62: key = (if v_324 then 2-proj-3-tuple(v_323) else caught-fail) in
        {975}let cs_50: cipherstate = (if v_324 then 1-proj-3-tuple(v_323) else caught-fail) in
        {976}let ssi_10: symmetricstate = (if v_322 then catch-fail((if v_324 then symmetricstatepack(cs_50,ck_62,hash(h_50,ciphertext_9)) else fail-any)) else caught-fail) in
        {977}let v_325: bool = not-caught-fail(ssi_10) in
        {978}let v_326: bitstring = (if v_310 then catch-fail((if v_312 then (if v_322 then (if v_325 then (ssi_10,plaintext_10,valid_8) else fail-any) else fail-any) else fail-any)) else caught-fail) in
        {979}let v_327: bool = (not-caught-fail(v_326) && success?(1-proj-3-tuple(v_326))) in
        {980}let valid2_1: bool = (if v_327 then 3-proj-3-tuple(v_326) else caught-fail) in
        {981}let plaintext_11: bitstring = (if v_327 then 2-proj-3-tuple(v_326) else caught-fail) in
        {982}let ss_51: symmetricstate = (if v_327 then 1-proj-3-tuple(v_326) else caught-fail) in
        {983}let basis_13: key = (if v_327 then key_s(them_3) else caught-fail) in
        {984}let public_key_13: key = (if v_327 then catch-fail(dhexp(basis_13,validkey(g))) else caught-fail) in
        {985}let v_328: bool = not-caught-fail(public_key_13) in
        {986}let v_329: bool = (if v_327 then catch-fail(((valid1_3 && valid2_1) && (rs_7 = getpublickey((if v_328 then keypairpack(validkey(public_key_13),basis_13) else fail-any))))) else caught-fail) in
        {987}let hs_14: handshakestate = (if v_329 then handshakestatepack(ss_51,s_7,m_9,e_13,rs_7,rm_9,re_9,psk_7,initiator_4) else caught-fail) in
        {988}let v_330: bitstring = (if v_329 then catch-fail(symmetricstateunpack(ss_51)) else caught-fail) in
        {989}let v_331: bool = (not-caught-fail(v_330) && success?(1-proj-3-tuple(v_330))) in
        {990}let h_51: bitstring = (if v_331 then 3-proj-3-tuple(v_330) else caught-fail) in
        {991}let ck_63: key = (if v_331 then 2-proj-3-tuple(v_330) else caught-fail) in
        {992}let cs_51: cipherstate = (if v_331 then 1-proj-3-tuple(v_330) else caught-fail) in
        {993}let input_key_material_15: key = (if v_331 then zero else caught-fail) in
        {994}let output1_15: key = (if v_331 then hmac_hash1(ck_63,input_key_material_15) else caught-fail) in
        {995}let output2_15: key = (if v_331 then hmac_hash2(ck_63,input_key_material_15) else caught-fail) in
        {996}let output3_15: key = (if v_331 then hmac_hash3(ck_63,input_key_material_15) else caught-fail) in
        {997}let v_332: bitstring = (if v_331 then catch-fail((output1_15,output2_15,output3_15)) else caught-fail) in
        {998}let v_333: bool = (not-caught-fail(v_332) && success?(1-proj-3-tuple(v_332))) in
        {999}let temp_k3_3: key = (if v_333 then 3-proj-3-tuple(v_332) else caught-fail) in
        {1000}let temp_k2_3: key = (if v_333 then 2-proj-3-tuple(v_332) else caught-fail) in
        {1001}let temp_k1_3: key = (if v_333 then 1-proj-3-tuple(v_332) else caught-fail) in
        {1002}let cs1_9: cipherstate = (if v_333 then cipherstatepack(temp_k1_3,minnonce) else caught-fail) in
        {1003}let cs2_9: cipherstate = (if v_333 then cipherstatepack(temp_k2_3,minnonce) else caught-fail) in
        {1004}let v_334: bitstring = (if v_329 then catch-fail((if v_331 then (if v_333 then (ss_51,cs1_9,cs2_9) else fail-any) else fail-any)) else caught-fail) in
        {1005}let v_335: bool = (not-caught-fail(v_334) && success?(1-proj-3-tuple(v_334))) in
        {1006}let cs2_10: cipherstate = (if v_335 then 3-proj-3-tuple(v_334) else caught-fail) in
        {1007}let cs1_10: cipherstate = (if v_335 then 2-proj-3-tuple(v_334) else caught-fail) in
        {1008}let ssi_11: symmetricstate = (if v_335 then 1-proj-3-tuple(v_334) else caught-fail) in
        {1009}let (hs_15: handshakestate,plaintext_a_1: bitstring,valid_9: bool,cs1_11: cipherstate,cs2_11: cipherstate) = (if v_264 then (if v_266 then (if v_269 then (if v_277 then (if v_285 then (if v_302 then (if v_310 then (if v_327 then (if undo-catch-fail(v_329) then (if v_335 then (hs_14,plaintext_11,true,cs1_10,cs2_10) else fail-any) else fail-any) else fail-any) else fail-any) else fail-any) else fail-any) else fail-any) else fail-any) else fail-any) else fail-any) in
        {1010}event RecvMsg(me_4,them_3,stagepack_a(sid_4),plaintext_a_1);
        {1011}event RecvEnd(valid_9)
    ) | (
        {1013}event LeakS(phase0,me_4);
        {1014}event LeakM(phase0,me_4);
        {1015}out(pub, (key_s(me_4),key_m(me_4)))
    ) | (
        {1016}phase 1;
        {1017}event LeakS(phase1,me_4);
        {1018}event LeakM(phase1,me_4);
        {1019}out(pub, (key_s(me_4),key_m(me_4)))
    )
)

--  Process 1 (that is, process 0, with let moved downwards):
{1}out(pub, (key_s(charlie),key_m(charlie)));
{2}!
{3}new sid: sessionid;
(
    {8}let m: keypair = keypairpack(empty,empty) in
    {7}let s: keypair = keypairpack(empty,empty) in
    {9}out(pub, (getpublickey(s),getpublickey(m)));
    {6}let sid_1: sessionid = sid in
    {5}let them: principal = bob in
    {4}let me: principal = alice in
    (
        {11}let basis: key = key_s(them) in
        {12}let public_key: key = catch-fail(dhexp(basis,validkey(g))) in
        {13}let v: bool = not-caught-fail(public_key) in
        {14}let rs: key = getpublickey((if v then keypairpack(validkey(public_key),basis) else fail-any)) in
        {15}let basis_1: key = key_m(them) in
        {16}let public_key_1: key = catch-fail(dhexp(basis_1,validkey(g))) in
        {17}let v_1: bool = not-caught-fail(public_key_1) in
        {18}let rm: key = getpublickey((if v_1 then keypairpack(validkey(public_key_1),basis_1) else fail-any)) in
        {25}let k: key = empty in
        {26}let cs: cipherstate = cipherstatepack(k,minnonce) in
        {22}let protocol_name: bitstring = somename in
        {23}let h: bitstring = hash(protocol_name,empty) in
        {24}let ck: key = h in
        {27}let ss: symmetricstate = symmetricstatepack(cs,ck,h) in
        {28}let v_2: bitstring = catch-fail(symmetricstateunpack(ss)) in
        {29}let v_3: bool = (not-caught-fail(v_2) && success?(1-proj-3-tuple(v_2))) in
        {30}let h_1: bitstring = (if v_3 then 3-proj-3-tuple(v_2) else caught-fail) in
        {31}let ck_1: key = (if v_3 then 2-proj-3-tuple(v_2) else caught-fail) in
        {32}let cs_1: cipherstate = (if v_3 then 1-proj-3-tuple(v_2) else caught-fail) in
        {20}let prologue: bitstring = empty in
        {33}let ss_1: symmetricstate = catch-fail((if v_3 then symmetricstatepack(cs_1,ck_1,hash(h_1,prologue)) else fail-any)) in
        {34}let v_4: bool = not-caught-fail(ss_1) in
        {35}let v_5: bitstring = (if v_4 then catch-fail(symmetricstateunpack(ss_1)) else caught-fail) in
        {36}let v_6: bool = (not-caught-fail(v_5) && success?(1-proj-3-tuple(v_5))) in
        {37}let h_2: bitstring = (if v_6 then 3-proj-3-tuple(v_5) else caught-fail) in
        {38}let ck_2: key = (if v_6 then 2-proj-3-tuple(v_5) else caught-fail) in
        {39}let cs_2: cipherstate = (if v_6 then 1-proj-3-tuple(v_5) else caught-fail) in
        {40}let ss_2: symmetricstate = (if v_4 then catch-fail((if v_6 then symmetricstatepack(cs_2,ck_2,hash(h_2,rs)) else fail-any)) else caught-fail) in
        {41}let v_7: bool = not-caught-fail(ss_2) in
        {42}let v_8: bitstring = (if v_7 then catch-fail(symmetricstateunpack(ss_2)) else caught-fail) in
        {43}let v_9: bool = (not-caught-fail(v_8) && success?(1-proj-3-tuple(v_8))) in
        {44}let h_3: bitstring = (if v_9 then 3-proj-3-tuple(v_8) else caught-fail) in
        {45}let ck_3: key = (if v_9 then 2-proj-3-tuple(v_8) else caught-fail) in
        {46}let cs_3: cipherstate = (if v_9 then 1-proj-3-tuple(v_8) else caught-fail) in
        {47}let ss_3: symmetricstate = (if v_7 then catch-fail((if v_9 then symmetricstatepack(cs_3,ck_3,hash(h_3,rm)) else fail-any)) else caught-fail) in
        {48}let v_10: bool = not-caught-fail(ss_3) in
        {21}let psk: key = empty in
        {19}let re: key = empty in
        {10}let e: keypair = keypairpack(empty,empty) in
        {49}let hs: handshakestate = (if v_4 then (if v_7 then (if v_10 then handshakestatepack(ss_3,s,m,e,rs,rm,re,psk,true) else fail-any) else fail-any) else fail-any) in
        {50}insert statestore(me,them,sid_1,statepack_a(hs))
    ) | (
        {244}get statestore(=me,=them,=sid_1,statepack_a(hs_1: handshakestate)) in
        {52}let v_11: bitstring = catch-fail(handshakestateunpack(hs_1)) in
        {53}let v_12: bool = (not-caught-fail(v_11) && success?(1-proj-9-tuple(v_11))) in
        {54}let initiator_1: bool = (if v_12 then 9-proj-9-tuple(v_11) else caught-fail) in
        {55}let psk_1: key = (if v_12 then 8-proj-9-tuple(v_11) else caught-fail) in
        {56}let re_1: key = (if v_12 then 7-proj-9-tuple(v_11) else caught-fail) in
        {57}let rm_1: key = (if v_12 then 6-proj-9-tuple(v_11) else caught-fail) in
        {58}let rs_1: key = (if v_12 then 5-proj-9-tuple(v_11) else caught-fail) in
        {59}let e_1: keypair = (if v_12 then 4-proj-9-tuple(v_11) else caught-fail) in
        {60}let m_1: keypair = (if v_12 then 3-proj-9-tuple(v_11) else caught-fail) in
        {61}let s_1: keypair = (if v_12 then 2-proj-9-tuple(v_11) else caught-fail) in
        {62}let ss_4: symmetricstate = (if v_12 then 1-proj-9-tuple(v_11) else caught-fail) in
        {63}let v_13: bitstring = (if v_12 then catch-fail((empty,empty,empty)) else caught-fail) in
        {64}let v_14: bool = (not-caught-fail(v_13) && success?(1-proj-3-tuple(v_13))) in
        {65}let ciphertext: bitstring = (if v_14 then 3-proj-3-tuple(v_13) else caught-fail) in
        {66}let nm: bitstring = (if v_14 then 2-proj-3-tuple(v_13) else caught-fail) in
        {67}let ne: bitstring = (if v_14 then 1-proj-3-tuple(v_13) else caught-fail) in
        {68}let basis_2: key = (if v_14 then key_e(me,them,sid_1) else caught-fail) in
        {69}let public_key_2: key = (if v_14 then catch-fail(dhexp(basis_2,validkey(g))) else caught-fail) in
        {70}let v_15: bool = not-caught-fail(public_key_2) in
        {71}let e_2: keypair = (if v_14 then catch-fail((if v_15 then keypairpack(validkey(public_key_2),basis_2) else fail-any)) else caught-fail) in
        {72}let v_16: bool = not-caught-fail(e_2) in
        {73}let ne_1: bitstring = (if v_16 then catch-fail(getpublickey(e_2)) else caught-fail) in
        {74}let v_17: bool = not-caught-fail(ne_1) in
        {75}let v_18: bitstring = (if v_17 then catch-fail(symmetricstateunpack(ss_4)) else caught-fail) in
        {76}let v_19: bool = (not-caught-fail(v_18) && success?(1-proj-3-tuple(v_18))) in
        {77}let h_4: bitstring = (if v_19 then 3-proj-3-tuple(v_18) else caught-fail) in
        {78}let ck_4: key = (if v_19 then 2-proj-3-tuple(v_18) else caught-fail) in
        {79}let cs_4: cipherstate = (if v_19 then 1-proj-3-tuple(v_18) else caught-fail) in
        {80}let ss_5: symmetricstate = (if v_17 then catch-fail((if v_19 then symmetricstatepack(cs_4,ck_4,hash(h_4,ne_1)) else fail-any)) else caught-fail) in
        {81}let v_20: bool = not-caught-fail(ss_5) in
        {82}let v_21: bitstring = (if v_20 then catch-fail(keypairunpack(e_2)) else caught-fail) in
        {83}let v_22: bool = (not-caught-fail(v_21) && success?(1-proj-2-tuple(v_21))) in
        {84}let my_private_key: key = (if v_22 then 2-proj-2-tuple(v_21) else caught-fail) in
        {85}let my_public_key: key = (if v_22 then 1-proj-2-tuple(v_21) else caught-fail) in
        {86}let input_key_material: key = (if v_20 then catch-fail((if v_22 then dhexp(my_private_key,rs_1) else fail-any)) else caught-fail) in
        {87}let v_23: bool = not-caught-fail(input_key_material) in
        {88}let v_24: bitstring = (if v_23 then catch-fail(symmetricstateunpack(ss_5)) else caught-fail) in
        {89}let v_25: bool = (not-caught-fail(v_24) && success?(1-proj-3-tuple(v_24))) in
        {90}let h_5: bitstring = (if v_25 then 3-proj-3-tuple(v_24) else caught-fail) in
        {91}let ck_5: key = (if v_25 then 2-proj-3-tuple(v_24) else caught-fail) in
        {92}let cs_5: cipherstate = (if v_25 then 1-proj-3-tuple(v_24) else caught-fail) in
        {95}let output3: key = (if v_25 then hmac_hash3(ck_5,input_key_material) else caught-fail) in
        {94}let output2: key = (if v_25 then hmac_hash2(ck_5,input_key_material) else caught-fail) in
        {93}let output1: key = (if v_25 then hmac_hash1(ck_5,input_key_material) else caught-fail) in
        {96}let v_26: bitstring = (if v_25 then catch-fail((output1,output2,output3)) else caught-fail) in
        {97}let v_27: bool = (not-caught-fail(v_26) && success?(1-proj-3-tuple(v_26))) in
        {98}let output_3: key = (if v_27 then 3-proj-3-tuple(v_26) else caught-fail) in
        {99}let temp_k: key = (if v_27 then 2-proj-3-tuple(v_26) else caught-fail) in
        {100}let ck_6: key = (if v_27 then 1-proj-3-tuple(v_26) else caught-fail) in
        {101}let ss_6: symmetricstate = (if v_20 then catch-fail((if v_23 then (if v_25 then (if v_27 then symmetricstatepack(cipherstatepack(temp_k,minnonce),ck_6,h_5) else fail-any) else fail-any) else fail-any)) else caught-fail) in
        {102}let v_28: bool = not-caught-fail(ss_6) in
        {103}let v_29: bitstring = (if v_28 then catch-fail(keypairunpack(e_2)) else caught-fail) in
        {104}let v_30: bool = (not-caught-fail(v_29) && success?(1-proj-2-tuple(v_29))) in
        {105}let my_private_key_1: key = (if v_30 then 2-proj-2-tuple(v_29) else caught-fail) in
        {106}let my_public_key_1: key = (if v_30 then 1-proj-2-tuple(v_29) else caught-fail) in
        {107}let input_key_material_1: key = (if v_28 then catch-fail((if v_30 then dhexp(my_private_key_1,rm_1) else fail-any)) else caught-fail) in
        {108}let v_31: bool = not-caught-fail(input_key_material_1) in
        {109}let v_32: bitstring = (if v_31 then catch-fail(symmetricstateunpack(ss_6)) else caught-fail) in
        {110}let v_33: bool = (not-caught-fail(v_32) && success?(1-proj-3-tuple(v_32))) in
        {111}let h_6: bitstring = (if v_33 then 3-proj-3-tuple(v_32) else caught-fail) in
        {112}let ck_7: key = (if v_33 then 2-proj-3-tuple(v_32) else caught-fail) in
        {113}let cs_6: cipherstate = (if v_33 then 1-proj-3-tuple(v_32) else caught-fail) in
        {116}let output3_1: key = (if v_33 then hmac_hash3(ck_7,input_key_material_1) else caught-fail) in
        {115}let output2_1: key = (if v_33 then hmac_hash2(ck_7,input_key_material_1) else caught-fail) in
        {114}let output1_1: key = (if v_33 then hmac_hash1(ck_7,input_key_material_1) else caught-fail) in
        {117}let v_34: bitstring = (if v_33 then catch-fail((output1_1,output2_1,output3_1)) else caught-fail) in
        {118}let v_35: bool = (not-caught-fail(v_34) && success?(1-proj-3-tuple(v_34))) in
        {119}let output: key = (if v_35 then 3-proj-3-tuple(v_34) else caught-fail) in
        {120}let temp_k_1: key = (if v_35 then 2-proj-3-tuple(v_34) else caught-fail) in
        {121}let ck_8: key = (if v_35 then 1-proj-3-tuple(v_34) else caught-fail) in
        {122}let ss_7: symmetricstate = (if v_28 then catch-fail((if v_31 then (if v_33 then (if v_35 then symmetricstatepack(cipherstatepack(temp_k_1,minnonce),ck_8,h_6) else fail-any) else fail-any) else fail-any)) else caught-fail) in
        {123}let v_36: bool = not-caught-fail(ss_7) in
        {124}let basis_3: key = (if v_36 then key_m(me) else caught-fail) in
        {125}let public_key_3: key = (if v_36 then catch-fail(dhexp(basis_3,validkey(g))) else caught-fail) in
        {126}let v_37: bool = not-caught-fail(public_key_3) in
        {127}let m_2: keypair = (if v_36 then catch-fail((if v_37 then keypairpack(validkey(public_key_3),basis_3) else fail-any)) else caught-fail) in
        {128}let v_38: bool = not-caught-fail(m_2) in
        {129}let plaintext: bitstring = (if v_38 then catch-fail(getpublickey(m_2)) else caught-fail) in
        {130}let v_39: bool = not-caught-fail(plaintext) in
        {131}let v_40: bitstring = (if v_39 then catch-fail(symmetricstateunpack(ss_7)) else caught-fail) in
        {132}let v_41: bool = (not-caught-fail(v_40) && success?(1-proj-3-tuple(v_40))) in
        {133}let h_7: bitstring = (if v_41 then 3-proj-3-tuple(v_40) else caught-fail) in
        {134}let ck_9: key = (if v_41 then 2-proj-3-tuple(v_40) else caught-fail) in
        {135}let cs_7: cipherstate = (if v_41 then 1-proj-3-tuple(v_40) else caught-fail) in
        {136}let v_42: bitstring = (if v_41 then catch-fail(cipherstateunpack(cs_7)) else caught-fail) in
        {137}let v_43: bool = (not-caught-fail(v_42) && success?(1-proj-2-tuple(v_42))) in
        {138}let n: nonce = (if v_43 then 2-proj-2-tuple(v_42) else caught-fail) in
        {139}let k_1: key = (if v_43 then 1-proj-2-tuple(v_42) else caught-fail) in
        {142}let v_44: bitstring = (if v_43 then catch-fail(cipherstateunpack(cs_7)) else caught-fail) in
        {143}let v_45: bool = (not-caught-fail(v_44) && success?(1-proj-2-tuple(v_44))) in
        {144}let o: nonce = (if v_45 then 2-proj-2-tuple(v_44) else caught-fail) in
        {145}let k_2: key = (if v_45 then 1-proj-2-tuple(v_44) else caught-fail) in
        {141}let n_1: nonce = (if v_43 then increment_nonce(n) else caught-fail) in
        {146}let csi: cipherstate = (if v_43 then catch-fail((if v_45 then cipherstatepack(k_2,n_1) else fail-any)) else caught-fail) in
        {147}let v_46: bool = not-caught-fail(csi) in
        {140}let e_3: bitstring = (if v_43 then encrypt(k_1,n,h_7,plaintext) else caught-fail) in
        {148}let v_47: bitstring = (if v_41 then catch-fail((if v_43 then (if v_46 then (csi,e_3) else fail-any) else fail-any)) else caught-fail) in
        {149}let v_48: bool = (not-caught-fail(v_47) && success?(1-proj-2-tuple(v_47))) in
        {150}let ciphertext_1: bitstring = (if v_48 then 2-proj-2-tuple(v_47) else caught-fail) in
        {151}let csi_1: cipherstate = (if v_48 then 1-proj-2-tuple(v_47) else caught-fail) in
        {152}let ss_8: symmetricstate = (if v_48 then symmetricstatepack(csi_1,ck_9,h_7) else caught-fail) in
        {153}let v_49: bitstring = (if v_48 then catch-fail(symmetricstateunpack(ss_8)) else caught-fail) in
        {154}let v_50: bool = (not-caught-fail(v_49) && success?(1-proj-3-tuple(v_49))) in
        {155}let h_8: bitstring = (if v_50 then 3-proj-3-tuple(v_49) else caught-fail) in
        {156}let ck_10: key = (if v_50 then 2-proj-3-tuple(v_49) else caught-fail) in
        {157}let cs_8: cipherstate = (if v_50 then 1-proj-3-tuple(v_49) else caught-fail) in
        {158}let ssi: symmetricstate = (if v_48 then catch-fail((if v_50 then symmetricstatepack(cs_8,ck_10,hash(h_8,ciphertext_1)) else fail-any)) else caught-fail) in
        {159}let v_51: bool = not-caught-fail(ssi) in
        {160}let v_52: bitstring = (if v_38 then catch-fail((if v_39 then (if v_41 then (if v_48 then (if v_51 then (ssi,ciphertext_1) else fail-any) else fail-any) else fail-any) else fail-any)) else caught-fail) in
        {161}let v_53: bool = (not-caught-fail(v_52) && success?(1-proj-2-tuple(v_52))) in
        {162}let nm_1: bitstring = (if v_53 then 2-proj-2-tuple(v_52) else caught-fail) in
        {163}let ss_9: symmetricstate = (if v_53 then 1-proj-2-tuple(v_52) else caught-fail) in
        {164}let v_54: bitstring = (if v_53 then catch-fail(keypairunpack(m_2)) else caught-fail) in
        {165}let v_55: bool = (not-caught-fail(v_54) && success?(1-proj-2-tuple(v_54))) in
        {166}let my_private_key_2: key = (if v_55 then 2-proj-2-tuple(v_54) else caught-fail) in
        {167}let my_public_key_2: key = (if v_55 then 1-proj-2-tuple(v_54) else caught-fail) in
        {168}let input_key_material_2: key = (if v_53 then catch-fail((if v_55 then dhexp(my_private_key_2,rs_1) else fail-any)) else caught-fail) in
        {169}let v_56: bool = not-caught-fail(input_key_material_2) in
        {170}let v_57: bitstring = (if v_56 then catch-fail(symmetricstateunpack(ss_9)) else caught-fail) in
        {171}let v_58: bool = (not-caught-fail(v_57) && success?(1-proj-3-tuple(v_57))) in
        {172}let h_9: bitstring = (if v_58 then 3-proj-3-tuple(v_57) else caught-fail) in
        {173}let ck_11: key = (if v_58 then 2-proj-3-tuple(v_57) else caught-fail) in
        {174}let cs_9: cipherstate = (if v_58 then 1-proj-3-tuple(v_57) else caught-fail) in
        {177}let output3_2: key = (if v_58 then hmac_hash3(ck_11,input_key_material_2) else caught-fail) in
        {176}let output2_2: key = (if v_58 then hmac_hash2(ck_11,input_key_material_2) else caught-fail) in
        {175}let output1_2: key = (if v_58 then hmac_hash1(ck_11,input_key_material_2) else caught-fail) in
        {178}let v_59: bitstring = (if v_58 then catch-fail((output1_2,output2_2,output3_2)) else caught-fail) in
        {179}let v_60: bool = (not-caught-fail(v_59) && success?(1-proj-3-tuple(v_59))) in
        {180}let output_1: key = (if v_60 then 3-proj-3-tuple(v_59) else caught-fail) in
        {181}let temp_k_2: key = (if v_60 then 2-proj-3-tuple(v_59) else caught-fail) in
        {182}let ck_12: key = (if v_60 then 1-proj-3-tuple(v_59) else caught-fail) in
        {183}let ss_10: symmetricstate = (if v_53 then catch-fail((if v_56 then (if v_58 then (if v_60 then symmetricstatepack(cipherstatepack(temp_k_2,minnonce),ck_12,h_9) else fail-any) else fail-any) else fail-any)) else caught-fail) in
        {184}let v_61: bool = not-caught-fail(ss_10) in
        {185}let v_62: bitstring = (if v_61 then catch-fail(symmetricstateunpack(ss_10)) else caught-fail) in
        {186}let v_63: bool = (not-caught-fail(v_62) && success?(1-proj-3-tuple(v_62))) in
        {187}let h_10: bitstring = (if v_63 then 3-proj-3-tuple(v_62) else caught-fail) in
        {188}let ck_13: key = (if v_63 then 2-proj-3-tuple(v_62) else caught-fail) in
        {189}let cs_10: cipherstate = (if v_63 then 1-proj-3-tuple(v_62) else caught-fail) in
        {190}let v_64: bitstring = (if v_63 then catch-fail(cipherstateunpack(cs_10)) else caught-fail) in
        {191}let v_65: bool = (not-caught-fail(v_64) && success?(1-proj-2-tuple(v_64))) in
        {192}let n_2: nonce = (if v_65 then 2-proj-2-tuple(v_64) else caught-fail) in
        {193}let k_3: key = (if v_65 then 1-proj-2-tuple(v_64) else caught-fail) in
        {196}let v_66: bitstring = (if v_65 then catch-fail(cipherstateunpack(cs_10)) else caught-fail) in
        {197}let v_67: bool = (not-caught-fail(v_66) && success?(1-proj-2-tuple(v_66))) in
        {198}let o_1: nonce = (if v_67 then 2-proj-2-tuple(v_66) else caught-fail) in
        {199}let k_4: key = (if v_67 then 1-proj-2-tuple(v_66) else caught-fail) in
        {195}let n_3: nonce = (if v_65 then increment_nonce(n_2) else caught-fail) in
        {200}let csi_2: cipherstate = (if v_65 then catch-fail((if v_67 then cipherstatepack(k_4,n_3) else fail-any)) else caught-fail) in
        {201}let v_68: bool = not-caught-fail(csi_2) in
        {51}let payload: bitstring = msg_a(me,them,sid_1) in
        {194}let e_4: bitstring = (if v_65 then encrypt(k_3,n_2,h_10,payload) else caught-fail) in
        {202}let v_69: bitstring = (if v_63 then catch-fail((if v_65 then (if v_68 then (csi_2,e_4) else fail-any) else fail-any)) else caught-fail) in
        {203}let v_70: bool = (not-caught-fail(v_69) && success?(1-proj-2-tuple(v_69))) in
        {204}let ciphertext_2: bitstring = (if v_70 then 2-proj-2-tuple(v_69) else caught-fail) in
        {205}let csi_3: cipherstate = (if v_70 then 1-proj-2-tuple(v_69) else caught-fail) in
        {206}let ss_11: symmetricstate = (if v_70 then symmetricstatepack(csi_3,ck_13,h_10) else caught-fail) in
        {207}let v_71: bitstring = (if v_70 then catch-fail(symmetricstateunpack(ss_11)) else caught-fail) in
        {208}let v_72: bool = (not-caught-fail(v_71) && success?(1-proj-3-tuple(v_71))) in
        {209}let h_11: bitstring = (if v_72 then 3-proj-3-tuple(v_71) else caught-fail) in
        {210}let ck_14: key = (if v_72 then 2-proj-3-tuple(v_71) else caught-fail) in
        {211}let cs_11: cipherstate = (if v_72 then 1-proj-3-tuple(v_71) else caught-fail) in
        {212}let ssi_1: symmetricstate = (if v_70 then catch-fail((if v_72 then symmetricstatepack(cs_11,ck_14,hash(h_11,ciphertext_2)) else fail-any)) else caught-fail) in
        {213}let v_73: bool = not-caught-fail(ssi_1) in
        {214}let v_74: bitstring = (if v_61 then catch-fail((if v_63 then (if v_70 then (if v_73 then (ssi_1,ciphertext_2) else fail-any) else fail-any) else fail-any)) else caught-fail) in
        {215}let v_75: bool = (not-caught-fail(v_74) && success?(1-proj-2-tuple(v_74))) in
        {216}let ciphertext_3: bitstring = (if v_75 then 2-proj-2-tuple(v_74) else caught-fail) in
        {217}let ss_12: symmetricstate = (if v_75 then 1-proj-2-tuple(v_74) else caught-fail) in
        {220}let v_76: bitstring = (if v_75 then catch-fail(symmetricstateunpack(ss_12)) else caught-fail) in
        {221}let v_77: bool = (not-caught-fail(v_76) && success?(1-proj-3-tuple(v_76))) in
        {222}let h_12: bitstring = (if v_77 then 3-proj-3-tuple(v_76) else caught-fail) in
        {223}let ck_15: key = (if v_77 then 2-proj-3-tuple(v_76) else caught-fail) in
        {224}let cs_12: cipherstate = (if v_77 then 1-proj-3-tuple(v_76) else caught-fail) in
        {225}let input_key_material_3: key = (if v_77 then zero else caught-fail) in
        {228}let output3_3: key = (if v_77 then hmac_hash3(ck_15,input_key_material_3) else caught-fail) in
        {227}let output2_3: key = (if v_77 then hmac_hash2(ck_15,input_key_material_3) else caught-fail) in
        {226}let output1_3: key = (if v_77 then hmac_hash1(ck_15,input_key_material_3) else caught-fail) in
        {229}let v_78: bitstring = (if v_77 then catch-fail((output1_3,output2_3,output3_3)) else caught-fail) in
        {230}let v_79: bool = (not-caught-fail(v_78) && success?(1-proj-3-tuple(v_78))) in
        {231}let temp_k3: key = (if v_79 then 3-proj-3-tuple(v_78) else caught-fail) in
        {232}let temp_k2: key = (if v_79 then 2-proj-3-tuple(v_78) else caught-fail) in
        {233}let temp_k1: key = (if v_79 then 1-proj-3-tuple(v_78) else caught-fail) in
        {235}let cs2: cipherstate = (if v_79 then cipherstatepack(temp_k2,minnonce) else caught-fail) in
        {234}let cs1: cipherstate = (if v_79 then cipherstatepack(temp_k1,minnonce) else caught-fail) in
        {236}let v_80: bitstring = (if v_75 then catch-fail((if v_77 then (if v_79 then (ss_12,cs1,cs2) else fail-any) else fail-any)) else caught-fail) in
        {237}let v_81: bool = (not-caught-fail(v_80) && success?(1-proj-3-tuple(v_80))) in
        {238}let cs2_1: cipherstate = (if v_81 then 3-proj-3-tuple(v_80) else caught-fail) in
        {239}let cs1_1: cipherstate = (if v_81 then 2-proj-3-tuple(v_80) else caught-fail) in
        {240}let ssi_2: symmetricstate = (if v_81 then 1-proj-3-tuple(v_80) else caught-fail) in
        {219}let message_buffer: bitstring = (if v_75 then concat3(ne_1,nm_1,ciphertext_3) else caught-fail) in
        {218}let hs_2: handshakestate = (if v_75 then handshakestatepack(ss_12,s_1,m_2,e_2,rs_1,rm_1,re_1,psk_1,initiator_1) else caught-fail) in
        {241}let (hs_3: handshakestate,message_a: bitstring,cs1_2: cipherstate,cs2_2: cipherstate) = (if v_12 then (if v_14 then (if v_16 then (if v_17 then (if v_20 then (if v_28 then (if v_36 then (if v_38 then (if v_53 then (if v_61 then (if v_75 then (if v_81 then (hs_2,message_buffer,cs1_1,cs2_1) else fail-any) else fail-any) else fail-any) else fail-any) else fail-any) else fail-any) else fail-any) else fail-any) else fail-any) else fail-any) else fail-any) else fail-any) in
        {242}event SendMsg(me,them,stagepack_a(sid_1),msg_a(me,them,sid_1));
        {243}out(pub, message_a)
    ) | (
        {245}event LeakS(phase0,me);
        {246}event LeakM(phase0,me);
        {247}out(pub, (key_s(me),key_m(me)))
    ) | (
        {248}phase 1;
        {249}event LeakS(phase1,me);
        {250}event LeakM(phase1,me);
        {251}out(pub, (key_s(me),key_m(me)))
    )
) | (
    {256}let m_3: keypair = keypairpack(empty,empty) in
    {255}let s_2: keypair = keypairpack(empty,empty) in
    {257}out(pub, (getpublickey(s_2),getpublickey(m_3)));
    {254}let sid_2: sessionid = sid in
    {253}let them_1: principal = charlie in
    {252}let me_1: principal = alice in
    (
        {259}let basis_4: key = key_s(them_1) in
        {260}let public_key_4: key = catch-fail(dhexp(basis_4,validkey(g))) in
        {261}let v_82: bool = not-caught-fail(public_key_4) in
        {262}let rs_2: key = getpublickey((if v_82 then keypairpack(validkey(public_key_4),basis_4) else fail-any)) in
        {263}let basis_5: key = key_m(them_1) in
        {264}let public_key_5: key = catch-fail(dhexp(basis_5,validkey(g))) in
        {265}let v_83: bool = not-caught-fail(public_key_5) in
        {266}let rm_2: key = getpublickey((if v_83 then keypairpack(validkey(public_key_5),basis_5) else fail-any)) in
        {273}let k_5: key = empty in
        {274}let cs_13: cipherstate = cipherstatepack(k_5,minnonce) in
        {270}let protocol_name_1: bitstring = somename in
        {271}let h_13: bitstring = hash(protocol_name_1,empty) in
        {272}let ck_16: key = h_13 in
        {275}let ss_13: symmetricstate = symmetricstatepack(cs_13,ck_16,h_13) in
        {276}let v_84: bitstring = catch-fail(symmetricstateunpack(ss_13)) in
        {277}let v_85: bool = (not-caught-fail(v_84) && success?(1-proj-3-tuple(v_84))) in
        {278}let h_14: bitstring = (if v_85 then 3-proj-3-tuple(v_84) else caught-fail) in
        {279}let ck_17: key = (if v_85 then 2-proj-3-tuple(v_84) else caught-fail) in
        {280}let cs_14: cipherstate = (if v_85 then 1-proj-3-tuple(v_84) else caught-fail) in
        {268}let prologue_1: bitstring = empty in
        {281}let ss_14: symmetricstate = catch-fail((if v_85 then symmetricstatepack(cs_14,ck_17,hash(h_14,prologue_1)) else fail-any)) in
        {282}let v_86: bool = not-caught-fail(ss_14) in
        {283}let v_87: bitstring = (if v_86 then catch-fail(symmetricstateunpack(ss_14)) else caught-fail) in
        {284}let v_88: bool = (not-caught-fail(v_87) && success?(1-proj-3-tuple(v_87))) in
        {285}let h_15: bitstring = (if v_88 then 3-proj-3-tuple(v_87) else caught-fail) in
        {286}let ck_18: key = (if v_88 then 2-proj-3-tuple(v_87) else caught-fail) in
        {287}let cs_15: cipherstate = (if v_88 then 1-proj-3-tuple(v_87) else caught-fail) in
        {288}let ss_15: symmetricstate = (if v_86 then catch-fail((if v_88 then symmetricstatepack(cs_15,ck_18,hash(h_15,rs_2)) else fail-any)) else caught-fail) in
        {289}let v_89: bool = not-caught-fail(ss_15) in
        {290}let v_90: bitstring = (if v_89 then catch-fail(symmetricstateunpack(ss_15)) else caught-fail) in
        {291}let v_91: bool = (not-caught-fail(v_90) && success?(1-proj-3-tuple(v_90))) in
        {292}let h_16: bitstring = (if v_91 then 3-proj-3-tuple(v_90) else caught-fail) in
        {293}let ck_19: key = (if v_91 then 2-proj-3-tuple(v_90) else caught-fail) in
        {294}let cs_16: cipherstate = (if v_91 then 1-proj-3-tuple(v_90) else caught-fail) in
        {295}let ss_16: symmetricstate = (if v_89 then catch-fail((if v_91 then symmetricstatepack(cs_16,ck_19,hash(h_16,rm_2)) else fail-any)) else caught-fail) in
        {296}let v_92: bool = not-caught-fail(ss_16) in
        {269}let psk_2: key = empty in
        {267}let re_2: key = empty in
        {258}let e_5: keypair = keypairpack(empty,empty) in
        {297}let hs_4: handshakestate = (if v_86 then (if v_89 then (if v_92 then handshakestatepack(ss_16,s_2,m_3,e_5,rs_2,rm_2,re_2,psk_2,true) else fail-any) else fail-any) else fail-any) in
        {298}insert statestore(me_1,them_1,sid_2,statepack_a(hs_4))
    ) | (
        {492}get statestore(=me_1,=them_1,=sid_2,statepack_a(hs_5: handshakestate)) in
        {300}let v_93: bitstring = catch-fail(handshakestateunpack(hs_5)) in
        {301}let v_94: bool = (not-caught-fail(v_93) && success?(1-proj-9-tuple(v_93))) in
        {302}let initiator_2: bool = (if v_94 then 9-proj-9-tuple(v_93) else caught-fail) in
        {303}let psk_3: key = (if v_94 then 8-proj-9-tuple(v_93) else caught-fail) in
        {304}let re_3: key = (if v_94 then 7-proj-9-tuple(v_93) else caught-fail) in
        {305}let rm_3: key = (if v_94 then 6-proj-9-tuple(v_93) else caught-fail) in
        {306}let rs_3: key = (if v_94 then 5-proj-9-tuple(v_93) else caught-fail) in
        {307}let e_6: keypair = (if v_94 then 4-proj-9-tuple(v_93) else caught-fail) in
        {308}let m_4: keypair = (if v_94 then 3-proj-9-tuple(v_93) else caught-fail) in
        {309}let s_3: keypair = (if v_94 then 2-proj-9-tuple(v_93) else caught-fail) in
        {310}let ss_17: symmetricstate = (if v_94 then 1-proj-9-tuple(v_93) else caught-fail) in
        {311}let v_95: bitstring = (if v_94 then catch-fail((empty,empty,empty)) else caught-fail) in
        {312}let v_96: bool = (not-caught-fail(v_95) && success?(1-proj-3-tuple(v_95))) in
        {313}let ciphertext_4: bitstring = (if v_96 then 3-proj-3-tuple(v_95) else caught-fail) in
        {314}let nm_2: bitstring = (if v_96 then 2-proj-3-tuple(v_95) else caught-fail) in
        {315}let ne_2: bitstring = (if v_96 then 1-proj-3-tuple(v_95) else caught-fail) in
        {316}let basis_6: key = (if v_96 then key_e(me_1,them_1,sid_2) else caught-fail) in
        {317}let public_key_6: key = (if v_96 then catch-fail(dhexp(basis_6,validkey(g))) else caught-fail) in
        {318}let v_97: bool = not-caught-fail(public_key_6) in
        {319}let e_7: keypair = (if v_96 then catch-fail((if v_97 then keypairpack(validkey(public_key_6),basis_6) else fail-any)) else caught-fail) in
        {320}let v_98: bool = not-caught-fail(e_7) in
        {321}let ne_3: bitstring = (if v_98 then catch-fail(getpublickey(e_7)) else caught-fail) in
        {322}let v_99: bool = not-caught-fail(ne_3) in
        {323}let v_100: bitstring = (if v_99 then catch-fail(symmetricstateunpack(ss_17)) else caught-fail) in
        {324}let v_101: bool = (not-caught-fail(v_100) && success?(1-proj-3-tuple(v_100))) in
        {325}let h_17: bitstring = (if v_101 then 3-proj-3-tuple(v_100) else caught-fail) in
        {326}let ck_20: key = (if v_101 then 2-proj-3-tuple(v_100) else caught-fail) in
        {327}let cs_17: cipherstate = (if v_101 then 1-proj-3-tuple(v_100) else caught-fail) in
        {328}let ss_18: symmetricstate = (if v_99 then catch-fail((if v_101 then symmetricstatepack(cs_17,ck_20,hash(h_17,ne_3)) else fail-any)) else caught-fail) in
        {329}let v_102: bool = not-caught-fail(ss_18) in
        {330}let v_103: bitstring = (if v_102 then catch-fail(keypairunpack(e_7)) else caught-fail) in
        {331}let v_104: bool = (not-caught-fail(v_103) && success?(1-proj-2-tuple(v_103))) in
        {332}let my_private_key_3: key = (if v_104 then 2-proj-2-tuple(v_103) else caught-fail) in
        {333}let my_public_key_3: key = (if v_104 then 1-proj-2-tuple(v_103) else caught-fail) in
        {334}let input_key_material_4: key = (if v_102 then catch-fail((if v_104 then dhexp(my_private_key_3,rs_3) else fail-any)) else caught-fail) in
        {335}let v_105: bool = not-caught-fail(input_key_material_4) in
        {336}let v_106: bitstring = (if v_105 then catch-fail(symmetricstateunpack(ss_18)) else caught-fail) in
        {337}let v_107: bool = (not-caught-fail(v_106) && success?(1-proj-3-tuple(v_106))) in
        {338}let h_18: bitstring = (if v_107 then 3-proj-3-tuple(v_106) else caught-fail) in
        {339}let ck_21: key = (if v_107 then 2-proj-3-tuple(v_106) else caught-fail) in
        {340}let cs_18: cipherstate = (if v_107 then 1-proj-3-tuple(v_106) else caught-fail) in
        {343}let output3_4: key = (if v_107 then hmac_hash3(ck_21,input_key_material_4) else caught-fail) in
        {342}let output2_4: key = (if v_107 then hmac_hash2(ck_21,input_key_material_4) else caught-fail) in
        {341}let output1_4: key = (if v_107 then hmac_hash1(ck_21,input_key_material_4) else caught-fail) in
        {344}let v_108: bitstring = (if v_107 then catch-fail((output1_4,output2_4,output3_4)) else caught-fail) in
        {345}let v_109: bool = (not-caught-fail(v_108) && success?(1-proj-3-tuple(v_108))) in
        {346}let output_2: key = (if v_109 then 3-proj-3-tuple(v_108) else caught-fail) in
        {347}let temp_k_3: key = (if v_109 then 2-proj-3-tuple(v_108) else caught-fail) in
        {348}let ck_22: key = (if v_109 then 1-proj-3-tuple(v_108) else caught-fail) in
        {349}let ss_19: symmetricstate = (if v_102 then catch-fail((if v_105 then (if v_107 then (if v_109 then symmetricstatepack(cipherstatepack(temp_k_3,minnonce),ck_22,h_18) else fail-any) else fail-any) else fail-any)) else caught-fail) in
        {350}let v_110: bool = not-caught-fail(ss_19) in
        {351}let v_111: bitstring = (if v_110 then catch-fail(keypairunpack(e_7)) else caught-fail) in
        {352}let v_112: bool = (not-caught-fail(v_111) && success?(1-proj-2-tuple(v_111))) in
        {353}let my_private_key_4: key = (if v_112 then 2-proj-2-tuple(v_111) else caught-fail) in
        {354}let my_public_key_4: key = (if v_112 then 1-proj-2-tuple(v_111) else caught-fail) in
        {355}let input_key_material_5: key = (if v_110 then catch-fail((if v_112 then dhexp(my_private_key_4,rm_3) else fail-any)) else caught-fail) in
        {356}let v_113: bool = not-caught-fail(input_key_material_5) in
        {357}let v_114: bitstring = (if v_113 then catch-fail(symmetricstateunpack(ss_19)) else caught-fail) in
        {358}let v_115: bool = (not-caught-fail(v_114) && success?(1-proj-3-tuple(v_114))) in
        {359}let h_19: bitstring = (if v_115 then 3-proj-3-tuple(v_114) else caught-fail) in
        {360}let ck_23: key = (if v_115 then 2-proj-3-tuple(v_114) else caught-fail) in
        {361}let cs_19: cipherstate = (if v_115 then 1-proj-3-tuple(v_114) else caught-fail) in
        {364}let output3_5: key = (if v_115 then hmac_hash3(ck_23,input_key_material_5) else caught-fail) in
        {363}let output2_5: key = (if v_115 then hmac_hash2(ck_23,input_key_material_5) else caught-fail) in
        {362}let output1_5: key = (if v_115 then hmac_hash1(ck_23,input_key_material_5) else caught-fail) in
        {365}let v_116: bitstring = (if v_115 then catch-fail((output1_5,output2_5,output3_5)) else caught-fail) in
        {366}let v_117: bool = (not-caught-fail(v_116) && success?(1-proj-3-tuple(v_116))) in
        {367}let output_4: key = (if v_117 then 3-proj-3-tuple(v_116) else caught-fail) in
        {368}let temp_k_4: key = (if v_117 then 2-proj-3-tuple(v_116) else caught-fail) in
        {369}let ck_24: key = (if v_117 then 1-proj-3-tuple(v_116) else caught-fail) in
        {370}let ss_20: symmetricstate = (if v_110 then catch-fail((if v_113 then (if v_115 then (if v_117 then symmetricstatepack(cipherstatepack(temp_k_4,minnonce),ck_24,h_19) else fail-any) else fail-any) else fail-any)) else caught-fail) in
        {371}let v_118: bool = not-caught-fail(ss_20) in
        {372}let basis_7: key = (if v_118 then key_m(me_1) else caught-fail) in
        {373}let public_key_7: key = (if v_118 then catch-fail(dhexp(basis_7,validkey(g))) else caught-fail) in
        {374}let v_119: bool = not-caught-fail(public_key_7) in
        {375}let m_5: keypair = (if v_118 then catch-fail((if v_119 then keypairpack(validkey(public_key_7),basis_7) else fail-any)) else caught-fail) in
        {376}let v_120: bool = not-caught-fail(m_5) in
        {377}let plaintext_1: bitstring = (if v_120 then catch-fail(getpublickey(m_5)) else caught-fail) in
        {378}let v_121: bool = not-caught-fail(plaintext_1) in
        {379}let v_122: bitstring = (if v_121 then catch-fail(symmetricstateunpack(ss_20)) else caught-fail) in
        {380}let v_123: bool = (not-caught-fail(v_122) && success?(1-proj-3-tuple(v_122))) in
        {381}let h_20: bitstring = (if v_123 then 3-proj-3-tuple(v_122) else caught-fail) in
        {382}let ck_25: key = (if v_123 then 2-proj-3-tuple(v_122) else caught-fail) in
        {383}let cs_20: cipherstate = (if v_123 then 1-proj-3-tuple(v_122) else caught-fail) in
        {384}let v_124: bitstring = (if v_123 then catch-fail(cipherstateunpack(cs_20)) else caught-fail) in
        {385}let v_125: bool = (not-caught-fail(v_124) && success?(1-proj-2-tuple(v_124))) in
        {386}let n_4: nonce = (if v_125 then 2-proj-2-tuple(v_124) else caught-fail) in
        {387}let k_6: key = (if v_125 then 1-proj-2-tuple(v_124) else caught-fail) in
        {390}let v_126: bitstring = (if v_125 then catch-fail(cipherstateunpack(cs_20)) else caught-fail) in
        {391}let v_127: bool = (not-caught-fail(v_126) && success?(1-proj-2-tuple(v_126))) in
        {392}let o_2: nonce = (if v_127 then 2-proj-2-tuple(v_126) else caught-fail) in
        {393}let k_7: key = (if v_127 then 1-proj-2-tuple(v_126) else caught-fail) in
        {389}let n_5: nonce = (if v_125 then increment_nonce(n_4) else caught-fail) in
        {394}let csi_4: cipherstate = (if v_125 then catch-fail((if v_127 then cipherstatepack(k_7,n_5) else fail-any)) else caught-fail) in
        {395}let v_128: bool = not-caught-fail(csi_4) in
        {388}let e_8: bitstring = (if v_125 then encrypt(k_6,n_4,h_20,plaintext_1) else caught-fail) in
        {396}let v_129: bitstring = (if v_123 then catch-fail((if v_125 then (if v_128 then (csi_4,e_8) else fail-any) else fail-any)) else caught-fail) in
        {397}let v_130: bool = (not-caught-fail(v_129) && success?(1-proj-2-tuple(v_129))) in
        {398}let ciphertext_5: bitstring = (if v_130 then 2-proj-2-tuple(v_129) else caught-fail) in
        {399}let csi_5: cipherstate = (if v_130 then 1-proj-2-tuple(v_129) else caught-fail) in
        {400}let ss_21: symmetricstate = (if v_130 then symmetricstatepack(csi_5,ck_25,h_20) else caught-fail) in
        {401}let v_131: bitstring = (if v_130 then catch-fail(symmetricstateunpack(ss_21)) else caught-fail) in
        {402}let v_132: bool = (not-caught-fail(v_131) && success?(1-proj-3-tuple(v_131))) in
        {403}let h_21: bitstring = (if v_132 then 3-proj-3-tuple(v_131) else caught-fail) in
        {404}let ck_26: key = (if v_132 then 2-proj-3-tuple(v_131) else caught-fail) in
        {405}let cs_21: cipherstate = (if v_132 then 1-proj-3-tuple(v_131) else caught-fail) in
        {406}let ssi_3: symmetricstate = (if v_130 then catch-fail((if v_132 then symmetricstatepack(cs_21,ck_26,hash(h_21,ciphertext_5)) else fail-any)) else caught-fail) in
        {407}let v_133: bool = not-caught-fail(ssi_3) in
        {408}let v_134: bitstring = (if v_120 then catch-fail((if v_121 then (if v_123 then (if v_130 then (if v_133 then (ssi_3,ciphertext_5) else fail-any) else fail-any) else fail-any) else fail-any)) else caught-fail) in
        {409}let v_135: bool = (not-caught-fail(v_134) && success?(1-proj-2-tuple(v_134))) in
        {410}let nm_3: bitstring = (if v_135 then 2-proj-2-tuple(v_134) else caught-fail) in
        {411}let ss_22: symmetricstate = (if v_135 then 1-proj-2-tuple(v_134) else caught-fail) in
        {412}let v_136: bitstring = (if v_135 then catch-fail(keypairunpack(m_5)) else caught-fail) in
        {413}let v_137: bool = (not-caught-fail(v_136) && success?(1-proj-2-tuple(v_136))) in
        {414}let my_private_key_5: key = (if v_137 then 2-proj-2-tuple(v_136) else caught-fail) in
        {415}let my_public_key_5: key = (if v_137 then 1-proj-2-tuple(v_136) else caught-fail) in
        {416}let input_key_material_6: key = (if v_135 then catch-fail((if v_137 then dhexp(my_private_key_5,rs_3) else fail-any)) else caught-fail) in
        {417}let v_138: bool = not-caught-fail(input_key_material_6) in
        {418}let v_139: bitstring = (if v_138 then catch-fail(symmetricstateunpack(ss_22)) else caught-fail) in
        {419}let v_140: bool = (not-caught-fail(v_139) && success?(1-proj-3-tuple(v_139))) in
        {420}let h_22: bitstring = (if v_140 then 3-proj-3-tuple(v_139) else caught-fail) in
        {421}let ck_27: key = (if v_140 then 2-proj-3-tuple(v_139) else caught-fail) in
        {422}let cs_22: cipherstate = (if v_140 then 1-proj-3-tuple(v_139) else caught-fail) in
        {425}let output3_6: key = (if v_140 then hmac_hash3(ck_27,input_key_material_6) else caught-fail) in
        {424}let output2_6: key = (if v_140 then hmac_hash2(ck_27,input_key_material_6) else caught-fail) in
        {423}let output1_6: key = (if v_140 then hmac_hash1(ck_27,input_key_material_6) else caught-fail) in
        {426}let v_141: bitstring = (if v_140 then catch-fail((output1_6,output2_6,output3_6)) else caught-fail) in
        {427}let v_142: bool = (not-caught-fail(v_141) && success?(1-proj-3-tuple(v_141))) in
        {428}let output_5: key = (if v_142 then 3-proj-3-tuple(v_141) else caught-fail) in
        {429}let temp_k_5: key = (if v_142 then 2-proj-3-tuple(v_141) else caught-fail) in
        {430}let ck_28: key = (if v_142 then 1-proj-3-tuple(v_141) else caught-fail) in
        {431}let ss_23: symmetricstate = (if v_135 then catch-fail((if v_138 then (if v_140 then (if v_142 then symmetricstatepack(cipherstatepack(temp_k_5,minnonce),ck_28,h_22) else fail-any) else fail-any) else fail-any)) else caught-fail) in
        {432}let v_143: bool = not-caught-fail(ss_23) in
        {433}let v_144: bitstring = (if v_143 then catch-fail(symmetricstateunpack(ss_23)) else caught-fail) in
        {434}let v_145: bool = (not-caught-fail(v_144) && success?(1-proj-3-tuple(v_144))) in
        {435}let h_23: bitstring = (if v_145 then 3-proj-3-tuple(v_144) else caught-fail) in
        {436}let ck_29: key = (if v_145 then 2-proj-3-tuple(v_144) else caught-fail) in
        {437}let cs_23: cipherstate = (if v_145 then 1-proj-3-tuple(v_144) else caught-fail) in
        {438}let v_146: bitstring = (if v_145 then catch-fail(cipherstateunpack(cs_23)) else caught-fail) in
        {439}let v_147: bool = (not-caught-fail(v_146) && success?(1-proj-2-tuple(v_146))) in
        {440}let n_6: nonce = (if v_147 then 2-proj-2-tuple(v_146) else caught-fail) in
        {441}let k_8: key = (if v_147 then 1-proj-2-tuple(v_146) else caught-fail) in
        {444}let v_148: bitstring = (if v_147 then catch-fail(cipherstateunpack(cs_23)) else caught-fail) in
        {445}let v_149: bool = (not-caught-fail(v_148) && success?(1-proj-2-tuple(v_148))) in
        {446}let o_3: nonce = (if v_149 then 2-proj-2-tuple(v_148) else caught-fail) in
        {447}let k_9: key = (if v_149 then 1-proj-2-tuple(v_148) else caught-fail) in
        {443}let n_7: nonce = (if v_147 then increment_nonce(n_6) else caught-fail) in
        {448}let csi_6: cipherstate = (if v_147 then catch-fail((if v_149 then cipherstatepack(k_9,n_7) else fail-any)) else caught-fail) in
        {449}let v_150: bool = not-caught-fail(csi_6) in
        {299}let payload_1: bitstring = msg_a(me_1,them_1,sid_2) in
        {442}let e_9: bitstring = (if v_147 then encrypt(k_8,n_6,h_23,payload_1) else caught-fail) in
        {450}let v_151: bitstring = (if v_145 then catch-fail((if v_147 then (if v_150 then (csi_6,e_9) else fail-any) else fail-any)) else caught-fail) in
        {451}let v_152: bool = (not-caught-fail(v_151) && success?(1-proj-2-tuple(v_151))) in
        {452}let ciphertext_6: bitstring = (if v_152 then 2-proj-2-tuple(v_151) else caught-fail) in
        {453}let csi_7: cipherstate = (if v_152 then 1-proj-2-tuple(v_151) else caught-fail) in
        {454}let ss_24: symmetricstate = (if v_152 then symmetricstatepack(csi_7,ck_29,h_23) else caught-fail) in
        {455}let v_153: bitstring = (if v_152 then catch-fail(symmetricstateunpack(ss_24)) else caught-fail) in
        {456}let v_154: bool = (not-caught-fail(v_153) && success?(1-proj-3-tuple(v_153))) in
        {457}let h_24: bitstring = (if v_154 then 3-proj-3-tuple(v_153) else caught-fail) in
        {458}let ck_30: key = (if v_154 then 2-proj-3-tuple(v_153) else caught-fail) in
        {459}let cs_24: cipherstate = (if v_154 then 1-proj-3-tuple(v_153) else caught-fail) in
        {460}let ssi_4: symmetricstate = (if v_152 then catch-fail((if v_154 then symmetricstatepack(cs_24,ck_30,hash(h_24,ciphertext_6)) else fail-any)) else caught-fail) in
        {461}let v_155: bool = not-caught-fail(ssi_4) in
        {462}let v_156: bitstring = (if v_143 then catch-fail((if v_145 then (if v_152 then (if v_155 then (ssi_4,ciphertext_6) else fail-any) else fail-any) else fail-any)) else caught-fail) in
        {463}let v_157: bool = (not-caught-fail(v_156) && success?(1-proj-2-tuple(v_156))) in
        {464}let ciphertext_7: bitstring = (if v_157 then 2-proj-2-tuple(v_156) else caught-fail) in
        {465}let ss_25: symmetricstate = (if v_157 then 1-proj-2-tuple(v_156) else caught-fail) in
        {468}let v_158: bitstring = (if v_157 then catch-fail(symmetricstateunpack(ss_25)) else caught-fail) in
        {469}let v_159: bool = (not-caught-fail(v_158) && success?(1-proj-3-tuple(v_158))) in
        {470}let h_25: bitstring = (if v_159 then 3-proj-3-tuple(v_158) else caught-fail) in
        {471}let ck_31: key = (if v_159 then 2-proj-3-tuple(v_158) else caught-fail) in
        {472}let cs_25: cipherstate = (if v_159 then 1-proj-3-tuple(v_158) else caught-fail) in
        {473}let input_key_material_7: key = (if v_159 then zero else caught-fail) in
        {476}let output3_7: key = (if v_159 then hmac_hash3(ck_31,input_key_material_7) else caught-fail) in
        {475}let output2_7: key = (if v_159 then hmac_hash2(ck_31,input_key_material_7) else caught-fail) in
        {474}let output1_7: key = (if v_159 then hmac_hash1(ck_31,input_key_material_7) else caught-fail) in
        {477}let v_160: bitstring = (if v_159 then catch-fail((output1_7,output2_7,output3_7)) else caught-fail) in
        {478}let v_161: bool = (not-caught-fail(v_160) && success?(1-proj-3-tuple(v_160))) in
        {479}let temp_k3_1: key = (if v_161 then 3-proj-3-tuple(v_160) else caught-fail) in
        {480}let temp_k2_1: key = (if v_161 then 2-proj-3-tuple(v_160) else caught-fail) in
        {481}let temp_k1_1: key = (if v_161 then 1-proj-3-tuple(v_160) else caught-fail) in
        {483}let cs2_3: cipherstate = (if v_161 then cipherstatepack(temp_k2_1,minnonce) else caught-fail) in
        {482}let cs1_3: cipherstate = (if v_161 then cipherstatepack(temp_k1_1,minnonce) else caught-fail) in
        {484}let v_162: bitstring = (if v_157 then catch-fail((if v_159 then (if v_161 then (ss_25,cs1_3,cs2_3) else fail-any) else fail-any)) else caught-fail) in
        {485}let v_163: bool = (not-caught-fail(v_162) && success?(1-proj-3-tuple(v_162))) in
        {486}let cs2_4: cipherstate = (if v_163 then 3-proj-3-tuple(v_162) else caught-fail) in
        {487}let cs1_4: cipherstate = (if v_163 then 2-proj-3-tuple(v_162) else caught-fail) in
        {488}let ssi_5: symmetricstate = (if v_163 then 1-proj-3-tuple(v_162) else caught-fail) in
        {467}let message_buffer_1: bitstring = (if v_157 then concat3(ne_3,nm_3,ciphertext_7) else caught-fail) in
        {466}let hs_6: handshakestate = (if v_157 then handshakestatepack(ss_25,s_3,m_5,e_7,rs_3,rm_3,re_3,psk_3,initiator_2) else caught-fail) in
        {489}let (hs_7: handshakestate,message_a_1: bitstring,cs1_5: cipherstate,cs2_5: cipherstate) = (if v_94 then (if v_96 then (if v_98 then (if v_99 then (if v_102 then (if v_110 then (if v_118 then (if v_120 then (if v_135 then (if v_143 then (if v_157 then (if v_163 then (hs_6,message_buffer_1,cs1_4,cs2_4) else fail-any) else fail-any) else fail-any) else fail-any) else fail-any) else fail-any) else fail-any) else fail-any) else fail-any) else fail-any) else fail-any) else fail-any) in
        {490}event SendMsg(me_1,them_1,stagepack_a(sid_2),msg_a(me_1,them_1,sid_2));
        {491}out(pub, message_a_1)
    ) | (
        {493}event LeakS(phase0,me_1);
        {494}event LeakM(phase0,me_1);
        {495}out(pub, (key_s(me_1),key_m(me_1)))
    ) | (
        {496}phase 1;
        {497}event LeakS(phase1,me_1);
        {498}event LeakM(phase1,me_1);
        {499}out(pub, (key_s(me_1),key_m(me_1)))
    )
) | (
    {500}let me_2: principal = bob in
    {503}let basis_8: key = key_s(me_2) in
    {504}let public_key_8: key = catch-fail(dhexp(basis_8,validkey(g))) in
    {505}let v_164: bool = not-caught-fail(public_key_8) in
    {506}let s_4: keypair = (if v_164 then keypairpack(validkey(public_key_8),basis_8) else fail-any) in
    {507}let basis_9: key = key_m(me_2) in
    {508}let public_key_9: key = catch-fail(dhexp(basis_9,validkey(g))) in
    {509}let v_165: bool = not-caught-fail(public_key_9) in
    {510}let m_6: keypair = (if v_165 then keypairpack(validkey(public_key_9),basis_9) else fail-any) in
    {511}out(pub, (getpublickey(s_4),getpublickey(m_6)));
    {502}let sid_3: sessionid = sid in
    {501}let them_2: principal = alice in
    (
        {521}let k_10: key = empty in
        {522}let cs_26: cipherstate = cipherstatepack(k_10,minnonce) in
        {518}let protocol_name_2: bitstring = somename in
        {519}let h_26: bitstring = hash(protocol_name_2,empty) in
        {520}let ck_32: key = h_26 in
        {523}let ss_26: symmetricstate = symmetricstatepack(cs_26,ck_32,h_26) in
        {524}let v_166: bitstring = catch-fail(symmetricstateunpack(ss_26)) in
        {525}let v_167: bool = (not-caught-fail(v_166) && success?(1-proj-3-tuple(v_166))) in
        {526}let h_27: bitstring = (if v_167 then 3-proj-3-tuple(v_166) else caught-fail) in
        {527}let ck_33: key = (if v_167 then 2-proj-3-tuple(v_166) else caught-fail) in
        {528}let cs_27: cipherstate = (if v_167 then 1-proj-3-tuple(v_166) else caught-fail) in
        {516}let prologue_2: bitstring = empty in
        {529}let ss_27: symmetricstate = catch-fail((if v_167 then symmetricstatepack(cs_27,ck_33,hash(h_27,prologue_2)) else fail-any)) in
        {530}let v_168: bool = not-caught-fail(ss_27) in
        {531}let data: bitstring = (if v_168 then catch-fail(getpublickey(s_4)) else caught-fail) in
        {532}let v_169: bool = not-caught-fail(data) in
        {533}let v_170: bitstring = (if v_169 then catch-fail(symmetricstateunpack(ss_27)) else caught-fail) in
        {534}let v_171: bool = (not-caught-fail(v_170) && success?(1-proj-3-tuple(v_170))) in
        {535}let h_28: bitstring = (if v_171 then 3-proj-3-tuple(v_170) else caught-fail) in
        {536}let ck_34: key = (if v_171 then 2-proj-3-tuple(v_170) else caught-fail) in
        {537}let cs_28: cipherstate = (if v_171 then 1-proj-3-tuple(v_170) else caught-fail) in
        {538}let ss_28: symmetricstate = (if v_168 then catch-fail((if v_169 then (if v_171 then symmetricstatepack(cs_28,ck_34,hash(h_28,data)) else fail-any) else fail-any)) else caught-fail) in
        {539}let v_172: bool = not-caught-fail(ss_28) in
        {540}let data_1: bitstring = (if v_172 then catch-fail(getpublickey(m_6)) else caught-fail) in
        {541}let v_173: bool = not-caught-fail(data_1) in
        {542}let v_174: bitstring = (if v_173 then catch-fail(symmetricstateunpack(ss_28)) else caught-fail) in
        {543}let v_175: bool = (not-caught-fail(v_174) && success?(1-proj-3-tuple(v_174))) in
        {544}let h_29: bitstring = (if v_175 then 3-proj-3-tuple(v_174) else caught-fail) in
        {545}let ck_35: key = (if v_175 then 2-proj-3-tuple(v_174) else caught-fail) in
        {546}let cs_29: cipherstate = (if v_175 then 1-proj-3-tuple(v_174) else caught-fail) in
        {547}let ss_29: symmetricstate = (if v_172 then catch-fail((if v_173 then (if v_175 then symmetricstatepack(cs_29,ck_35,hash(h_29,data_1)) else fail-any) else fail-any)) else caught-fail) in
        {548}let v_176: bool = not-caught-fail(ss_29) in
        {517}let psk_4: key = empty in
        {515}let re_4: key = empty in
        {514}let rm_4: key = empty in
        {513}let rs_4: key = empty in
        {512}let e_10: keypair = keypairpack(empty,empty) in
        {549}let hs_8: handshakestate = (if v_168 then (if v_172 then (if v_176 then handshakestatepack(ss_29,s_4,m_6,e_10,rs_4,rm_4,re_4,psk_4,false) else fail-any) else fail-any) else fail-any) in
        {550}insert statestore(me_2,them_2,sid_3,statepack_a(hs_8))
    ) | (
        {752}get statestore(=me_2,=them_2,=sid_3,statepack_a(hs_9: handshakestate)) in
        {551}in(pub, message_a_2: bitstring);
        {552}let v_177: bitstring = catch-fail(handshakestateunpack(hs_9)) in
        {553}let v_178: bool = (not-caught-fail(v_177) && success?(1-proj-9-tuple(v_177))) in
        {554}let initiator_3: bool = (if v_178 then 9-proj-9-tuple(v_177) else caught-fail) in
        {555}let psk_5: key = (if v_178 then 8-proj-9-tuple(v_177) else caught-fail) in
        {556}let re_5: key = (if v_178 then 7-proj-9-tuple(v_177) else caught-fail) in
        {557}let rm_5: key = (if v_178 then 6-proj-9-tuple(v_177) else caught-fail) in
        {558}let rs_5: key = (if v_178 then 5-proj-9-tuple(v_177) else caught-fail) in
        {559}let e_11: keypair = (if v_178 then 4-proj-9-tuple(v_177) else caught-fail) in
        {560}let m_7: keypair = (if v_178 then 3-proj-9-tuple(v_177) else caught-fail) in
        {561}let s_5: keypair = (if v_178 then 2-proj-9-tuple(v_177) else caught-fail) in
        {562}let ss_30: symmetricstate = (if v_178 then 1-proj-9-tuple(v_177) else caught-fail) in
        {563}let v_179: bitstring = (if v_178 then catch-fail(deconcat3(message_a_2)) else caught-fail) in
        {564}let v_180: bool = (not-caught-fail(v_179) && success?(1-proj-3-tuple(v_179))) in
        {565}let ciphertext_8: bitstring = (if v_180 then 3-proj-3-tuple(v_179) else caught-fail) in
        {566}let nm_4: bitstring = (if v_180 then 2-proj-3-tuple(v_179) else caught-fail) in
        {567}let ne_4: bitstring = (if v_180 then 1-proj-3-tuple(v_179) else caught-fail) in
        {570}let v_181: bitstring = (if v_180 then catch-fail(symmetricstateunpack(ss_30)) else caught-fail) in
        {571}let v_182: bool = (not-caught-fail(v_181) && success?(1-proj-3-tuple(v_181))) in
        {572}let h_30: bitstring = (if v_182 then 3-proj-3-tuple(v_181) else caught-fail) in
        {573}let ck_36: key = (if v_182 then 2-proj-3-tuple(v_181) else caught-fail) in
        {574}let cs_30: cipherstate = (if v_182 then 1-proj-3-tuple(v_181) else caught-fail) in
        {569}let re_6: key = (if v_180 then ne_4 else caught-fail) in
        {575}let ss_31: symmetricstate = (if v_180 then catch-fail((if v_182 then symmetricstatepack(cs_30,ck_36,hash(h_30,re_6)) else fail-any)) else caught-fail) in
        {576}let v_183: bool = not-caught-fail(ss_31) in
        {577}let v_184: bitstring = (if v_183 then catch-fail(keypairunpack(s_5)) else caught-fail) in
        {578}let v_185: bool = (not-caught-fail(v_184) && success?(1-proj-2-tuple(v_184))) in
        {579}let my_private_key_6: key = (if v_185 then 2-proj-2-tuple(v_184) else caught-fail) in
        {580}let my_public_key_6: key = (if v_185 then 1-proj-2-tuple(v_184) else caught-fail) in
        {581}let input_key_material_8: key = (if v_183 then catch-fail((if v_185 then dhexp(my_private_key_6,re_6) else fail-any)) else caught-fail) in
        {582}let v_186: bool = not-caught-fail(input_key_material_8) in
        {583}let v_187: bitstring = (if v_186 then catch-fail(symmetricstateunpack(ss_31)) else caught-fail) in
        {584}let v_188: bool = (not-caught-fail(v_187) && success?(1-proj-3-tuple(v_187))) in
        {585}let h_31: bitstring = (if v_188 then 3-proj-3-tuple(v_187) else caught-fail) in
        {586}let ck_37: key = (if v_188 then 2-proj-3-tuple(v_187) else caught-fail) in
        {587}let cs_31: cipherstate = (if v_188 then 1-proj-3-tuple(v_187) else caught-fail) in
        {590}let output3_8: key = (if v_188 then hmac_hash3(ck_37,input_key_material_8) else caught-fail) in
        {589}let output2_8: key = (if v_188 then hmac_hash2(ck_37,input_key_material_8) else caught-fail) in
        {588}let output1_8: key = (if v_188 then hmac_hash1(ck_37,input_key_material_8) else caught-fail) in
        {591}let v_189: bitstring = (if v_188 then catch-fail((output1_8,output2_8,output3_8)) else caught-fail) in
        {592}let v_190: bool = (not-caught-fail(v_189) && success?(1-proj-3-tuple(v_189))) in
        {593}let output_6: key = (if v_190 then 3-proj-3-tuple(v_189) else caught-fail) in
        {594}let temp_k_6: key = (if v_190 then 2-proj-3-tuple(v_189) else caught-fail) in
        {595}let ck_38: key = (if v_190 then 1-proj-3-tuple(v_189) else caught-fail) in
        {596}let ss_32: symmetricstate = (if v_183 then catch-fail((if v_186 then (if v_188 then (if v_190 then symmetricstatepack(cipherstatepack(temp_k_6,minnonce),ck_38,h_31) else fail-any) else fail-any) else fail-any)) else caught-fail) in
        {597}let v_191: bool = not-caught-fail(ss_32) in
        {598}let v_192: bitstring = (if v_191 then catch-fail(keypairunpack(m_7)) else caught-fail) in
        {599}let v_193: bool = (not-caught-fail(v_192) && success?(1-proj-2-tuple(v_192))) in
        {600}let my_private_key_7: key = (if v_193 then 2-proj-2-tuple(v_192) else caught-fail) in
        {601}let my_public_key_7: key = (if v_193 then 1-proj-2-tuple(v_192) else caught-fail) in
        {602}let input_key_material_9: key = (if v_191 then catch-fail((if v_193 then dhexp(my_private_key_7,re_6) else fail-any)) else caught-fail) in
        {603}let v_194: bool = not-caught-fail(input_key_material_9) in
        {604}let v_195: bitstring = (if v_194 then catch-fail(symmetricstateunpack(ss_32)) else caught-fail) in
        {605}let v_196: bool = (not-caught-fail(v_195) && success?(1-proj-3-tuple(v_195))) in
        {606}let h_32: bitstring = (if v_196 then 3-proj-3-tuple(v_195) else caught-fail) in
        {607}let ck_39: key = (if v_196 then 2-proj-3-tuple(v_195) else caught-fail) in
        {608}let cs_32: cipherstate = (if v_196 then 1-proj-3-tuple(v_195) else caught-fail) in
        {611}let output3_9: key = (if v_196 then hmac_hash3(ck_39,input_key_material_9) else caught-fail) in
        {610}let output2_9: key = (if v_196 then hmac_hash2(ck_39,input_key_material_9) else caught-fail) in
        {609}let output1_9: key = (if v_196 then hmac_hash1(ck_39,input_key_material_9) else caught-fail) in
        {612}let v_197: bitstring = (if v_196 then catch-fail((output1_9,output2_9,output3_9)) else caught-fail) in
        {613}let v_198: bool = (not-caught-fail(v_197) && success?(1-proj-3-tuple(v_197))) in
        {614}let output_7: key = (if v_198 then 3-proj-3-tuple(v_197) else caught-fail) in
        {615}let temp_k_7: key = (if v_198 then 2-proj-3-tuple(v_197) else caught-fail) in
        {616}let ck_40: key = (if v_198 then 1-proj-3-tuple(v_197) else caught-fail) in
        {617}let ss_33: symmetricstate = (if v_191 then catch-fail((if v_194 then (if v_196 then (if v_198 then symmetricstatepack(cipherstatepack(temp_k_7,minnonce),ck_40,h_32) else fail-any) else fail-any) else fail-any)) else caught-fail) in
        {618}let v_199: bool = not-caught-fail(ss_33) in
        {619}let v_200: bitstring = (if v_199 then catch-fail(symmetricstateunpack(ss_33)) else caught-fail) in
        {620}let v_201: bool = (not-caught-fail(v_200) && success?(1-proj-3-tuple(v_200))) in
        {621}let h_33: bitstring = (if v_201 then 3-proj-3-tuple(v_200) else caught-fail) in
        {622}let ck_41: key = (if v_201 then 2-proj-3-tuple(v_200) else caught-fail) in
        {623}let cs_33: cipherstate = (if v_201 then 1-proj-3-tuple(v_200) else caught-fail) in
        {624}let v_202: bitstring = (if v_201 then catch-fail(cipherstateunpack(cs_33)) else caught-fail) in
        {625}let v_203: bool = (not-caught-fail(v_202) && success?(1-proj-2-tuple(v_202))) in
        {626}let n_8: nonce = (if v_203 then 2-proj-2-tuple(v_202) else caught-fail) in
        {627}let k_11: key = (if v_203 then 1-proj-2-tuple(v_202) else caught-fail) in
        {628}let d: aead = (if v_203 then catch-fail(decrypt(k_11,n_8,h_33,nm_4)) else caught-fail) in
        {629}let v_204: bool = not-caught-fail(d) in
        {630}let v_205: bitstring = (if v_204 then catch-fail(aeadunpack(d)) else caught-fail) in
        {631}let v_206: bool = (not-caught-fail(v_205) && success?(1-proj-3-tuple(v_205))) in
        {632}let plaintext_2: bitstring = (if v_206 then 3-proj-3-tuple(v_205) else caught-fail) in
        {633}let adi: bitstring = (if v_206 then 2-proj-3-tuple(v_205) else caught-fail) in
        {634}let valid: bool = (if v_206 then 1-proj-3-tuple(v_205) else caught-fail) in
        {636}let v_207: bitstring = (if v_206 then catch-fail(cipherstateunpack(cs_33)) else caught-fail) in
        {637}let v_208: bool = (not-caught-fail(v_207) && success?(1-proj-2-tuple(v_207))) in
        {638}let o_4: nonce = (if v_208 then 2-proj-2-tuple(v_207) else caught-fail) in
        {639}let k_12: key = (if v_208 then 1-proj-2-tuple(v_207) else caught-fail) in
        {635}let n_9: nonce = (if v_206 then increment_nonce(n_8) else caught-fail) in
        {640}let csi_8: cipherstate = (if v_206 then catch-fail((if v_208 then cipherstatepack(k_12,n_9) else fail-any)) else caught-fail) in
        {641}let v_209: bool = not-caught-fail(csi_8) in
        {642}let v_210: bitstring = (if v_201 then catch-fail((if v_203 then (if v_204 then (if v_206 then (if v_209 then (csi_8,plaintext_2,valid) else fail-any) else fail-any) else fail-any) else fail-any)) else caught-fail) in
        {643}let v_211: bool = (not-caught-fail(v_210) && success?(1-proj-3-tuple(v_210))) in
        {644}let valid_1: bool = (if v_211 then 3-proj-3-tuple(v_210) else caught-fail) in
        {645}let plaintext_3: bitstring = (if v_211 then 2-proj-3-tuple(v_210) else caught-fail) in
        {646}let csi_9: cipherstate = (if v_211 then 1-proj-3-tuple(v_210) else caught-fail) in
        {647}let ss_34: symmetricstate = (if v_211 then symmetricstatepack(csi_9,ck_41,h_33) else caught-fail) in
        {648}let v_212: bitstring = (if v_211 then catch-fail(symmetricstateunpack(ss_34)) else caught-fail) in
        {649}let v_213: bool = (not-caught-fail(v_212) && success?(1-proj-3-tuple(v_212))) in
        {650}let h_34: bitstring = (if v_213 then 3-proj-3-tuple(v_212) else caught-fail) in
        {651}let ck_42: key = (if v_213 then 2-proj-3-tuple(v_212) else caught-fail) in
        {652}let cs_34: cipherstate = (if v_213 then 1-proj-3-tuple(v_212) else caught-fail) in
        {653}let ssi_6: symmetricstate = (if v_211 then catch-fail((if v_213 then symmetricstatepack(cs_34,ck_42,hash(h_34,nm_4)) else fail-any)) else caught-fail) in
        {654}let v_214: bool = not-caught-fail(ssi_6) in
        {655}let v_215: bitstring = (if v_199 then catch-fail((if v_201 then (if v_211 then (if v_214 then (ssi_6,plaintext_3,valid_1) else fail-any) else fail-any) else fail-any)) else caught-fail) in
        {656}let v_216: bool = (not-caught-fail(v_215) && success?(1-proj-3-tuple(v_215))) in
        {657}let valid1_1: bool = (if v_216 then 3-proj-3-tuple(v_215) else caught-fail) in
        {658}let me_3: bitstring = (if v_216 then 2-proj-3-tuple(v_215) else caught-fail) in
        {659}let ss_35: symmetricstate = (if v_216 then 1-proj-3-tuple(v_215) else caught-fail) in
        {661}let v_217: bitstring = (if v_216 then catch-fail(keypairunpack(s_5)) else caught-fail) in
        {662}let v_218: bool = (not-caught-fail(v_217) && success?(1-proj-2-tuple(v_217))) in
        {663}let my_private_key_8: key = (if v_218 then 2-proj-2-tuple(v_217) else caught-fail) in
        {664}let my_public_key_8: key = (if v_218 then 1-proj-2-tuple(v_217) else caught-fail) in
        {660}let rm_6: key = (if v_216 then me_3 else caught-fail) in
        {665}let input_key_material_10: key = (if v_216 then catch-fail((if v_218 then dhexp(my_private_key_8,rm_6) else fail-any)) else caught-fail) in
        {666}let v_219: bool = not-caught-fail(input_key_material_10) in
        {667}let v_220: bitstring = (if v_219 then catch-fail(symmetricstateunpack(ss_35)) else caught-fail) in
        {668}let v_221: bool = (not-caught-fail(v_220) && success?(1-proj-3-tuple(v_220))) in
        {669}let h_35: bitstring = (if v_221 then 3-proj-3-tuple(v_220) else caught-fail) in
        {670}let ck_43: key = (if v_221 then 2-proj-3-tuple(v_220) else caught-fail) in
        {671}let cs_35: cipherstate = (if v_221 then 1-proj-3-tuple(v_220) else caught-fail) in
        {674}let output3_10: key = (if v_221 then hmac_hash3(ck_43,input_key_material_10) else caught-fail) in
        {673}let output2_10: key = (if v_221 then hmac_hash2(ck_43,input_key_material_10) else caught-fail) in
        {672}let output1_10: key = (if v_221 then hmac_hash1(ck_43,input_key_material_10) else caught-fail) in
        {675}let v_222: bitstring = (if v_221 then catch-fail((output1_10,output2_10,output3_10)) else caught-fail) in
        {676}let v_223: bool = (not-caught-fail(v_222) && success?(1-proj-3-tuple(v_222))) in
        {677}let output_8: key = (if v_223 then 3-proj-3-tuple(v_222) else caught-fail) in
        {678}let temp_k_8: key = (if v_223 then 2-proj-3-tuple(v_222) else caught-fail) in
        {679}let ck_44: key = (if v_223 then 1-proj-3-tuple(v_222) else caught-fail) in
        {680}let ss_36: symmetricstate = (if v_216 then catch-fail((if v_219 then (if v_221 then (if v_223 then symmetricstatepack(cipherstatepack(temp_k_8,minnonce),ck_44,h_35) else fail-any) else fail-any) else fail-any)) else caught-fail) in
        {681}let v_224: bool = not-caught-fail(ss_36) in
        {682}let v_225: bitstring = (if v_224 then catch-fail(symmetricstateunpack(ss_36)) else caught-fail) in
        {683}let v_226: bool = (not-caught-fail(v_225) && success?(1-proj-3-tuple(v_225))) in
        {684}let h_36: bitstring = (if v_226 then 3-proj-3-tuple(v_225) else caught-fail) in
        {685}let ck_45: key = (if v_226 then 2-proj-3-tuple(v_225) else caught-fail) in
        {686}let cs_36: cipherstate = (if v_226 then 1-proj-3-tuple(v_225) else caught-fail) in
        {687}let v_227: bitstring = (if v_226 then catch-fail(cipherstateunpack(cs_36)) else caught-fail) in
        {688}let v_228: bool = (not-caught-fail(v_227) && success?(1-proj-2-tuple(v_227))) in
        {689}let n_10: nonce = (if v_228 then 2-proj-2-tuple(v_227) else caught-fail) in
        {690}let k_13: key = (if v_228 then 1-proj-2-tuple(v_227) else caught-fail) in
        {691}let d_1: aead = (if v_228 then catch-fail(decrypt(k_13,n_10,h_36,ciphertext_8)) else caught-fail) in
        {692}let v_229: bool = not-caught-fail(d_1) in
        {693}let v_230: bitstring = (if v_229 then catch-fail(aeadunpack(d_1)) else caught-fail) in
        {694}let v_231: bool = (not-caught-fail(v_230) && success?(1-proj-3-tuple(v_230))) in
        {695}let plaintext_4: bitstring = (if v_231 then 3-proj-3-tuple(v_230) else caught-fail) in
        {696}let adi_1: bitstring = (if v_231 then 2-proj-3-tuple(v_230) else caught-fail) in
        {697}let valid_2: bool = (if v_231 then 1-proj-3-tuple(v_230) else caught-fail) in
        {699}let v_232: bitstring = (if v_231 then catch-fail(cipherstateunpack(cs_36)) else caught-fail) in
        {700}let v_233: bool = (not-caught-fail(v_232) && success?(1-proj-2-tuple(v_232))) in
        {701}let o_5: nonce = (if v_233 then 2-proj-2-tuple(v_232) else caught-fail) in
        {702}let k_14: key = (if v_233 then 1-proj-2-tuple(v_232) else caught-fail) in
        {698}let n_11: nonce = (if v_231 then increment_nonce(n_10) else caught-fail) in
        {703}let csi_10: cipherstate = (if v_231 then catch-fail((if v_233 then cipherstatepack(k_14,n_11) else fail-any)) else caught-fail) in
        {704}let v_234: bool = not-caught-fail(csi_10) in
        {705}let v_235: bitstring = (if v_226 then catch-fail((if v_228 then (if v_229 then (if v_231 then (if v_234 then (csi_10,plaintext_4,valid_2) else fail-any) else fail-any) else fail-any) else fail-any)) else caught-fail) in
        {706}let v_236: bool = (not-caught-fail(v_235) && success?(1-proj-3-tuple(v_235))) in
        {707}let valid_3: bool = (if v_236 then 3-proj-3-tuple(v_235) else caught-fail) in
        {708}let plaintext_5: bitstring = (if v_236 then 2-proj-3-tuple(v_235) else caught-fail) in
        {709}let csi_11: cipherstate = (if v_236 then 1-proj-3-tuple(v_235) else caught-fail) in
        {710}let ss_37: symmetricstate = (if v_236 then symmetricstatepack(csi_11,ck_45,h_36) else caught-fail) in
        {711}let v_237: bitstring = (if v_236 then catch-fail(symmetricstateunpack(ss_37)) else caught-fail) in
        {712}let v_238: bool = (not-caught-fail(v_237) && success?(1-proj-3-tuple(v_237))) in
        {713}let h_37: bitstring = (if v_238 then 3-proj-3-tuple(v_237) else caught-fail) in
        {714}let ck_46: key = (if v_238 then 2-proj-3-tuple(v_237) else caught-fail) in
        {715}let cs_37: cipherstate = (if v_238 then 1-proj-3-tuple(v_237) else caught-fail) in
        {716}let ssi_7: symmetricstate = (if v_236 then catch-fail((if v_238 then symmetricstatepack(cs_37,ck_46,hash(h_37,ciphertext_8)) else fail-any)) else caught-fail) in
        {717}let v_239: bool = not-caught-fail(ssi_7) in
        {718}let v_240: bitstring = (if v_224 then catch-fail((if v_226 then (if v_236 then (if v_239 then (ssi_7,plaintext_5,valid_3) else fail-any) else fail-any) else fail-any)) else caught-fail) in
        {719}let v_241: bool = (not-caught-fail(v_240) && success?(1-proj-3-tuple(v_240))) in
        {720}let valid2: bool = (if v_241 then 3-proj-3-tuple(v_240) else caught-fail) in
        {721}let plaintext_6: bitstring = (if v_241 then 2-proj-3-tuple(v_240) else caught-fail) in
        {722}let ss_38: symmetricstate = (if v_241 then 1-proj-3-tuple(v_240) else caught-fail) in
        {723}let basis_10: key = (if v_241 then key_s(them_2) else caught-fail) in
        {724}let public_key_10: key = (if v_241 then catch-fail(dhexp(basis_10,validkey(g))) else caught-fail) in
        {725}let v_242: bool = not-caught-fail(public_key_10) in
        {726}let v_243: bool = (if v_241 then catch-fail(((valid1_1 && valid2) && (rs_5 = getpublickey((if v_242 then keypairpack(validkey(public_key_10),basis_10) else fail-any))))) else caught-fail) in
        {728}let v_244: bitstring = (if v_243 then catch-fail(symmetricstateunpack(ss_38)) else caught-fail) in
        {729}let v_245: bool = (not-caught-fail(v_244) && success?(1-proj-3-tuple(v_244))) in
        {730}let h_38: bitstring = (if v_245 then 3-proj-3-tuple(v_244) else caught-fail) in
        {731}let ck_47: key = (if v_245 then 2-proj-3-tuple(v_244) else caught-fail) in
        {732}let cs_38: cipherstate = (if v_245 then 1-proj-3-tuple(v_244) else caught-fail) in
        {733}let input_key_material_11: key = (if v_245 then zero else caught-fail) in
        {736}let output3_11: key = (if v_245 then hmac_hash3(ck_47,input_key_material_11) else caught-fail) in
        {735}let output2_11: key = (if v_245 then hmac_hash2(ck_47,input_key_material_11) else caught-fail) in
        {734}let output1_11: key = (if v_245 then hmac_hash1(ck_47,input_key_material_11) else caught-fail) in
        {737}let v_246: bitstring = (if v_245 then catch-fail((output1_11,output2_11,output3_11)) else caught-fail) in
        {738}let v_247: bool = (not-caught-fail(v_246) && success?(1-proj-3-tuple(v_246))) in
        {739}let temp_k3_2: key = (if v_247 then 3-proj-3-tuple(v_246) else caught-fail) in
        {740}let temp_k2_2: key = (if v_247 then 2-proj-3-tuple(v_246) else caught-fail) in
        {741}let temp_k1_2: key = (if v_247 then 1-proj-3-tuple(v_246) else caught-fail) in
        {743}let cs2_6: cipherstate = (if v_247 then cipherstatepack(temp_k2_2,minnonce) else caught-fail) in
        {742}let cs1_6: cipherstate = (if v_247 then cipherstatepack(temp_k1_2,minnonce) else caught-fail) in
        {744}let v_248: bitstring = (if v_243 then catch-fail((if v_245 then (if v_247 then (ss_38,cs1_6,cs2_6) else fail-any) else fail-any)) else caught-fail) in
        {745}let v_249: bool = (not-caught-fail(v_248) && success?(1-proj-3-tuple(v_248))) in
        {746}let cs2_7: cipherstate = (if v_249 then 3-proj-3-tuple(v_248) else caught-fail) in
        {747}let cs1_7: cipherstate = (if v_249 then 2-proj-3-tuple(v_248) else caught-fail) in
        {748}let ssi_8: symmetricstate = (if v_249 then 1-proj-3-tuple(v_248) else caught-fail) in
        {727}let hs_10: handshakestate = (if v_243 then handshakestatepack(ss_38,s_5,m_7,e_11,rs_5,rm_6,re_6,psk_5,initiator_3) else caught-fail) in
        {749}let (hs_11: handshakestate,plaintext_a: bitstring,valid_4: bool,cs1_8: cipherstate,cs2_8: cipherstate) = (if v_178 then (if v_180 then (if v_183 then (if v_191 then (if v_199 then (if v_216 then (if v_224 then (if v_241 then (if undo-catch-fail(v_243) then (if v_249 then (hs_10,plaintext_6,true,cs1_7,cs2_7) else fail-any) else fail-any) else fail-any) else fail-any) else fail-any) else fail-any) else fail-any) else fail-any) else fail-any) else fail-any) in
        {750}event RecvMsg(me_2,them_2,stagepack_a(sid_3),plaintext_a);
        {751}event RecvEnd(valid_4)
    ) | (
        {753}event LeakS(phase0,me_2);
        {754}event LeakM(phase0,me_2);
        {755}out(pub, (key_s(me_2),key_m(me_2)))
    ) | (
        {756}phase 1;
        {757}event LeakS(phase1,me_2);
        {758}event LeakM(phase1,me_2);
        {759}out(pub, (key_s(me_2),key_m(me_2)))
    )
) | (
    {760}let me_4: principal = bob in
    {763}let basis_11: key = key_s(me_4) in
    {764}let public_key_11: key = catch-fail(dhexp(basis_11,validkey(g))) in
    {765}let v_250: bool = not-caught-fail(public_key_11) in
    {766}let s_6: keypair = (if v_250 then keypairpack(validkey(public_key_11),basis_11) else fail-any) in
    {767}let basis_12: key = key_m(me_4) in
    {768}let public_key_12: key = catch-fail(dhexp(basis_12,validkey(g))) in
    {769}let v_251: bool = not-caught-fail(public_key_12) in
    {770}let m_8: keypair = (if v_251 then keypairpack(validkey(public_key_12),basis_12) else fail-any) in
    {771}out(pub, (getpublickey(s_6),getpublickey(m_8)));
    {762}let sid_4: sessionid = sid in
    {761}let them_3: principal = charlie in
    (
        {781}let k_15: key = empty in
        {782}let cs_39: cipherstate = cipherstatepack(k_15,minnonce) in
        {778}let protocol_name_3: bitstring = somename in
        {779}let h_39: bitstring = hash(protocol_name_3,empty) in
        {780}let ck_48: key = h_39 in
        {783}let ss_39: symmetricstate = symmetricstatepack(cs_39,ck_48,h_39) in
        {784}let v_252: bitstring = catch-fail(symmetricstateunpack(ss_39)) in
        {785}let v_253: bool = (not-caught-fail(v_252) && success?(1-proj-3-tuple(v_252))) in
        {786}let h_40: bitstring = (if v_253 then 3-proj-3-tuple(v_252) else caught-fail) in
        {787}let ck_49: key = (if v_253 then 2-proj-3-tuple(v_252) else caught-fail) in
        {788}let cs_40: cipherstate = (if v_253 then 1-proj-3-tuple(v_252) else caught-fail) in
        {776}let prologue_3: bitstring = empty in
        {789}let ss_40: symmetricstate = catch-fail((if v_253 then symmetricstatepack(cs_40,ck_49,hash(h_40,prologue_3)) else fail-any)) in
        {790}let v_254: bool = not-caught-fail(ss_40) in
        {791}let data_2: bitstring = (if v_254 then catch-fail(getpublickey(s_6)) else caught-fail) in
        {792}let v_255: bool = not-caught-fail(data_2) in
        {793}let v_256: bitstring = (if v_255 then catch-fail(symmetricstateunpack(ss_40)) else caught-fail) in
        {794}let v_257: bool = (not-caught-fail(v_256) && success?(1-proj-3-tuple(v_256))) in
        {795}let h_41: bitstring = (if v_257 then 3-proj-3-tuple(v_256) else caught-fail) in
        {796}let ck_50: key = (if v_257 then 2-proj-3-tuple(v_256) else caught-fail) in
        {797}let cs_41: cipherstate = (if v_257 then 1-proj-3-tuple(v_256) else caught-fail) in
        {798}let ss_41: symmetricstate = (if v_254 then catch-fail((if v_255 then (if v_257 then symmetricstatepack(cs_41,ck_50,hash(h_41,data_2)) else fail-any) else fail-any)) else caught-fail) in
        {799}let v_258: bool = not-caught-fail(ss_41) in
        {800}let data_3: bitstring = (if v_258 then catch-fail(getpublickey(m_8)) else caught-fail) in
        {801}let v_259: bool = not-caught-fail(data_3) in
        {802}let v_260: bitstring = (if v_259 then catch-fail(symmetricstateunpack(ss_41)) else caught-fail) in
        {803}let v_261: bool = (not-caught-fail(v_260) && success?(1-proj-3-tuple(v_260))) in
        {804}let h_42: bitstring = (if v_261 then 3-proj-3-tuple(v_260) else caught-fail) in
        {805}let ck_51: key = (if v_261 then 2-proj-3-tuple(v_260) else caught-fail) in
        {806}let cs_42: cipherstate = (if v_261 then 1-proj-3-tuple(v_260) else caught-fail) in
        {807}let ss_42: symmetricstate = (if v_258 then catch-fail((if v_259 then (if v_261 then symmetricstatepack(cs_42,ck_51,hash(h_42,data_3)) else fail-any) else fail-any)) else caught-fail) in
        {808}let v_262: bool = not-caught-fail(ss_42) in
        {777}let psk_6: key = empty in
        {775}let re_7: key = empty in
        {774}let rm_7: key = empty in
        {773}let rs_6: key = empty in
        {772}let e_12: keypair = keypairpack(empty,empty) in
        {809}let hs_12: handshakestate = (if v_254 then (if v_258 then (if v_262 then handshakestatepack(ss_42,s_6,m_8,e_12,rs_6,rm_7,re_7,psk_6,false) else fail-any) else fail-any) else fail-any) in
        {810}insert statestore(me_4,them_3,sid_4,statepack_a(hs_12))
    ) | (
        {1012}get statestore(=me_4,=them_3,=sid_4,statepack_a(hs_13: handshakestate)) in
        {811}in(pub, message_a_3: bitstring);
        {812}let v_263: bitstring = catch-fail(handshakestateunpack(hs_13)) in
        {813}let v_264: bool = (not-caught-fail(v_263) && success?(1-proj-9-tuple(v_263))) in
        {814}let initiator_4: bool = (if v_264 then 9-proj-9-tuple(v_263) else caught-fail) in
        {815}let psk_7: key = (if v_264 then 8-proj-9-tuple(v_263) else caught-fail) in
        {816}let re_8: key = (if v_264 then 7-proj-9-tuple(v_263) else caught-fail) in
        {817}let rm_8: key = (if v_264 then 6-proj-9-tuple(v_263) else caught-fail) in
        {818}let rs_7: key = (if v_264 then 5-proj-9-tuple(v_263) else caught-fail) in
        {819}let e_13: keypair = (if v_264 then 4-proj-9-tuple(v_263) else caught-fail) in
        {820}let m_9: keypair = (if v_264 then 3-proj-9-tuple(v_263) else caught-fail) in
        {821}let s_7: keypair = (if v_264 then 2-proj-9-tuple(v_263) else caught-fail) in
        {822}let ss_43: symmetricstate = (if v_264 then 1-proj-9-tuple(v_263) else caught-fail) in
        {823}let v_265: bitstring = (if v_264 then catch-fail(deconcat3(message_a_3)) else caught-fail) in
        {824}let v_266: bool = (not-caught-fail(v_265) && success?(1-proj-3-tuple(v_265))) in
        {825}let ciphertext_9: bitstring = (if v_266 then 3-proj-3-tuple(v_265) else caught-fail) in
        {826}let nm_5: bitstring = (if v_266 then 2-proj-3-tuple(v_265) else caught-fail) in
        {827}let ne_5: bitstring = (if v_266 then 1-proj-3-tuple(v_265) else caught-fail) in
        {830}let v_267: bitstring = (if v_266 then catch-fail(symmetricstateunpack(ss_43)) else caught-fail) in
        {831}let v_268: bool = (not-caught-fail(v_267) && success?(1-proj-3-tuple(v_267))) in
        {832}let h_43: bitstring = (if v_268 then 3-proj-3-tuple(v_267) else caught-fail) in
        {833}let ck_52: key = (if v_268 then 2-proj-3-tuple(v_267) else caught-fail) in
        {834}let cs_43: cipherstate = (if v_268 then 1-proj-3-tuple(v_267) else caught-fail) in
        {829}let re_9: key = (if v_266 then ne_5 else caught-fail) in
        {835}let ss_44: symmetricstate = (if v_266 then catch-fail((if v_268 then symmetricstatepack(cs_43,ck_52,hash(h_43,re_9)) else fail-any)) else caught-fail) in
        {836}let v_269: bool = not-caught-fail(ss_44) in
        {837}let v_270: bitstring = (if v_269 then catch-fail(keypairunpack(s_7)) else caught-fail) in
        {838}let v_271: bool = (not-caught-fail(v_270) && success?(1-proj-2-tuple(v_270))) in
        {839}let my_private_key_9: key = (if v_271 then 2-proj-2-tuple(v_270) else caught-fail) in
        {840}let my_public_key_9: key = (if v_271 then 1-proj-2-tuple(v_270) else caught-fail) in
        {841}let input_key_material_12: key = (if v_269 then catch-fail((if v_271 then dhexp(my_private_key_9,re_9) else fail-any)) else caught-fail) in
        {842}let v_272: bool = not-caught-fail(input_key_material_12) in
        {843}let v_273: bitstring = (if v_272 then catch-fail(symmetricstateunpack(ss_44)) else caught-fail) in
        {844}let v_274: bool = (not-caught-fail(v_273) && success?(1-proj-3-tuple(v_273))) in
        {845}let h_44: bitstring = (if v_274 then 3-proj-3-tuple(v_273) else caught-fail) in
        {846}let ck_53: key = (if v_274 then 2-proj-3-tuple(v_273) else caught-fail) in
        {847}let cs_44: cipherstate = (if v_274 then 1-proj-3-tuple(v_273) else caught-fail) in
        {850}let output3_12: key = (if v_274 then hmac_hash3(ck_53,input_key_material_12) else caught-fail) in
        {849}let output2_12: key = (if v_274 then hmac_hash2(ck_53,input_key_material_12) else caught-fail) in
        {848}let output1_12: key = (if v_274 then hmac_hash1(ck_53,input_key_material_12) else caught-fail) in
        {851}let v_275: bitstring = (if v_274 then catch-fail((output1_12,output2_12,output3_12)) else caught-fail) in
        {852}let v_276: bool = (not-caught-fail(v_275) && success?(1-proj-3-tuple(v_275))) in
        {853}let output_9: key = (if v_276 then 3-proj-3-tuple(v_275) else caught-fail) in
        {854}let temp_k_9: key = (if v_276 then 2-proj-3-tuple(v_275) else caught-fail) in
        {855}let ck_54: key = (if v_276 then 1-proj-3-tuple(v_275) else caught-fail) in
        {856}let ss_45: symmetricstate = (if v_269 then catch-fail((if v_272 then (if v_274 then (if v_276 then symmetricstatepack(cipherstatepack(temp_k_9,minnonce),ck_54,h_44) else fail-any) else fail-any) else fail-any)) else caught-fail) in
        {857}let v_277: bool = not-caught-fail(ss_45) in
        {858}let v_278: bitstring = (if v_277 then catch-fail(keypairunpack(m_9)) else caught-fail) in
        {859}let v_279: bool = (not-caught-fail(v_278) && success?(1-proj-2-tuple(v_278))) in
        {860}let my_private_key_10: key = (if v_279 then 2-proj-2-tuple(v_278) else caught-fail) in
        {861}let my_public_key_10: key = (if v_279 then 1-proj-2-tuple(v_278) else caught-fail) in
        {862}let input_key_material_13: key = (if v_277 then catch-fail((if v_279 then dhexp(my_private_key_10,re_9) else fail-any)) else caught-fail) in
        {863}let v_280: bool = not-caught-fail(input_key_material_13) in
        {864}let v_281: bitstring = (if v_280 then catch-fail(symmetricstateunpack(ss_45)) else caught-fail) in
        {865}let v_282: bool = (not-caught-fail(v_281) && success?(1-proj-3-tuple(v_281))) in
        {866}let h_45: bitstring = (if v_282 then 3-proj-3-tuple(v_281) else caught-fail) in
        {867}let ck_55: key = (if v_282 then 2-proj-3-tuple(v_281) else caught-fail) in
        {868}let cs_45: cipherstate = (if v_282 then 1-proj-3-tuple(v_281) else caught-fail) in
        {871}let output3_13: key = (if v_282 then hmac_hash3(ck_55,input_key_material_13) else caught-fail) in
        {870}let output2_13: key = (if v_282 then hmac_hash2(ck_55,input_key_material_13) else caught-fail) in
        {869}let output1_13: key = (if v_282 then hmac_hash1(ck_55,input_key_material_13) else caught-fail) in
        {872}let v_283: bitstring = (if v_282 then catch-fail((output1_13,output2_13,output3_13)) else caught-fail) in
        {873}let v_284: bool = (not-caught-fail(v_283) && success?(1-proj-3-tuple(v_283))) in
        {874}let output_10: key = (if v_284 then 3-proj-3-tuple(v_283) else caught-fail) in
        {875}let temp_k_10: key = (if v_284 then 2-proj-3-tuple(v_283) else caught-fail) in
        {876}let ck_56: key = (if v_284 then 1-proj-3-tuple(v_283) else caught-fail) in
        {877}let ss_46: symmetricstate = (if v_277 then catch-fail((if v_280 then (if v_282 then (if v_284 then symmetricstatepack(cipherstatepack(temp_k_10,minnonce),ck_56,h_45) else fail-any) else fail-any) else fail-any)) else caught-fail) in
        {878}let v_285: bool = not-caught-fail(ss_46) in
        {879}let v_286: bitstring = (if v_285 then catch-fail(symmetricstateunpack(ss_46)) else caught-fail) in
        {880}let v_287: bool = (not-caught-fail(v_286) && success?(1-proj-3-tuple(v_286))) in
        {881}let h_46: bitstring = (if v_287 then 3-proj-3-tuple(v_286) else caught-fail) in
        {882}let ck_57: key = (if v_287 then 2-proj-3-tuple(v_286) else caught-fail) in
        {883}let cs_46: cipherstate = (if v_287 then 1-proj-3-tuple(v_286) else caught-fail) in
        {884}let v_288: bitstring = (if v_287 then catch-fail(cipherstateunpack(cs_46)) else caught-fail) in
        {885}let v_289: bool = (not-caught-fail(v_288) && success?(1-proj-2-tuple(v_288))) in
        {886}let n_12: nonce = (if v_289 then 2-proj-2-tuple(v_288) else caught-fail) in
        {887}let k_16: key = (if v_289 then 1-proj-2-tuple(v_288) else caught-fail) in
        {888}let d_2: aead = (if v_289 then catch-fail(decrypt(k_16,n_12,h_46,nm_5)) else caught-fail) in
        {889}let v_290: bool = not-caught-fail(d_2) in
        {890}let v_291: bitstring = (if v_290 then catch-fail(aeadunpack(d_2)) else caught-fail) in
        {891}let v_292: bool = (not-caught-fail(v_291) && success?(1-proj-3-tuple(v_291))) in
        {892}let plaintext_7: bitstring = (if v_292 then 3-proj-3-tuple(v_291) else caught-fail) in
        {893}let adi_2: bitstring = (if v_292 then 2-proj-3-tuple(v_291) else caught-fail) in
        {894}let valid_5: bool = (if v_292 then 1-proj-3-tuple(v_291) else caught-fail) in
        {896}let v_293: bitstring = (if v_292 then catch-fail(cipherstateunpack(cs_46)) else caught-fail) in
        {897}let v_294: bool = (not-caught-fail(v_293) && success?(1-proj-2-tuple(v_293))) in
        {898}let o_6: nonce = (if v_294 then 2-proj-2-tuple(v_293) else caught-fail) in
        {899}let k_17: key = (if v_294 then 1-proj-2-tuple(v_293) else caught-fail) in
        {895}let n_13: nonce = (if v_292 then increment_nonce(n_12) else caught-fail) in
        {900}let csi_12: cipherstate = (if v_292 then catch-fail((if v_294 then cipherstatepack(k_17,n_13) else fail-any)) else caught-fail) in
        {901}let v_295: bool = not-caught-fail(csi_12) in
        {902}let v_296: bitstring = (if v_287 then catch-fail((if v_289 then (if v_290 then (if v_292 then (if v_295 then (csi_12,plaintext_7,valid_5) else fail-any) else fail-any) else fail-any) else fail-any)) else caught-fail) in
        {903}let v_297: bool = (not-caught-fail(v_296) && success?(1-proj-3-tuple(v_296))) in
        {904}let valid_6: bool = (if v_297 then 3-proj-3-tuple(v_296) else caught-fail) in
        {905}let plaintext_8: bitstring = (if v_297 then 2-proj-3-tuple(v_296) else caught-fail) in
        {906}let csi_13: cipherstate = (if v_297 then 1-proj-3-tuple(v_296) else caught-fail) in
        {907}let ss_47: symmetricstate = (if v_297 then symmetricstatepack(csi_13,ck_57,h_46) else caught-fail) in
        {908}let v_298: bitstring = (if v_297 then catch-fail(symmetricstateunpack(ss_47)) else caught-fail) in
        {909}let v_299: bool = (not-caught-fail(v_298) && success?(1-proj-3-tuple(v_298))) in
        {910}let h_47: bitstring = (if v_299 then 3-proj-3-tuple(v_298) else caught-fail) in
        {911}let ck_58: key = (if v_299 then 2-proj-3-tuple(v_298) else caught-fail) in
        {912}let cs_47: cipherstate = (if v_299 then 1-proj-3-tuple(v_298) else caught-fail) in
        {913}let ssi_9: symmetricstate = (if v_297 then catch-fail((if v_299 then symmetricstatepack(cs_47,ck_58,hash(h_47,nm_5)) else fail-any)) else caught-fail) in
        {914}let v_300: bool = not-caught-fail(ssi_9) in
        {915}let v_301: bitstring = (if v_285 then catch-fail((if v_287 then (if v_297 then (if v_300 then (ssi_9,plaintext_8,valid_6) else fail-any) else fail-any) else fail-any)) else caught-fail) in
        {916}let v_302: bool = (not-caught-fail(v_301) && success?(1-proj-3-tuple(v_301))) in
        {917}let valid1_3: bool = (if v_302 then 3-proj-3-tuple(v_301) else caught-fail) in
        {918}let me_5: bitstring = (if v_302 then 2-proj-3-tuple(v_301) else caught-fail) in
        {919}let ss_48: symmetricstate = (if v_302 then 1-proj-3-tuple(v_301) else caught-fail) in
        {921}let v_303: bitstring = (if v_302 then catch-fail(keypairunpack(s_7)) else caught-fail) in
        {922}let v_304: bool = (not-caught-fail(v_303) && success?(1-proj-2-tuple(v_303))) in
        {923}let my_private_key_11: key = (if v_304 then 2-proj-2-tuple(v_303) else caught-fail) in
        {924}let my_public_key_11: key = (if v_304 then 1-proj-2-tuple(v_303) else caught-fail) in
        {920}let rm_9: key = (if v_302 then me_5 else caught-fail) in
        {925}let input_key_material_14: key = (if v_302 then catch-fail((if v_304 then dhexp(my_private_key_11,rm_9) else fail-any)) else caught-fail) in
        {926}let v_305: bool = not-caught-fail(input_key_material_14) in
        {927}let v_306: bitstring = (if v_305 then catch-fail(symmetricstateunpack(ss_48)) else caught-fail) in
        {928}let v_307: bool = (not-caught-fail(v_306) && success?(1-proj-3-tuple(v_306))) in
        {929}let h_48: bitstring = (if v_307 then 3-proj-3-tuple(v_306) else caught-fail) in
        {930}let ck_59: key = (if v_307 then 2-proj-3-tuple(v_306) else caught-fail) in
        {931}let cs_48: cipherstate = (if v_307 then 1-proj-3-tuple(v_306) else caught-fail) in
        {934}let output3_14: key = (if v_307 then hmac_hash3(ck_59,input_key_material_14) else caught-fail) in
        {933}let output2_14: key = (if v_307 then hmac_hash2(ck_59,input_key_material_14) else caught-fail) in
        {932}let output1_14: key = (if v_307 then hmac_hash1(ck_59,input_key_material_14) else caught-fail) in
        {935}let v_308: bitstring = (if v_307 then catch-fail((output1_14,output2_14,output3_14)) else caught-fail) in
        {936}let v_309: bool = (not-caught-fail(v_308) && success?(1-proj-3-tuple(v_308))) in
        {937}let output_11: key = (if v_309 then 3-proj-3-tuple(v_308) else caught-fail) in
        {938}let temp_k_11: key = (if v_309 then 2-proj-3-tuple(v_308) else caught-fail) in
        {939}let ck_60: key = (if v_309 then 1-proj-3-tuple(v_308) else caught-fail) in
        {940}let ss_49: symmetricstate = (if v_302 then catch-fail((if v_305 then (if v_307 then (if v_309 then symmetricstatepack(cipherstatepack(temp_k_11,minnonce),ck_60,h_48) else fail-any) else fail-any) else fail-any)) else caught-fail) in
        {941}let v_310: bool = not-caught-fail(ss_49) in
        {942}let v_311: bitstring = (if v_310 then catch-fail(symmetricstateunpack(ss_49)) else caught-fail) in
        {943}let v_312: bool = (not-caught-fail(v_311) && success?(1-proj-3-tuple(v_311))) in
        {944}let h_49: bitstring = (if v_312 then 3-proj-3-tuple(v_311) else caught-fail) in
        {945}let ck_61: key = (if v_312 then 2-proj-3-tuple(v_311) else caught-fail) in
        {946}let cs_49: cipherstate = (if v_312 then 1-proj-3-tuple(v_311) else caught-fail) in
        {947}let v_313: bitstring = (if v_312 then catch-fail(cipherstateunpack(cs_49)) else caught-fail) in
        {948}let v_314: bool = (not-caught-fail(v_313) && success?(1-proj-2-tuple(v_313))) in
        {949}let n_14: nonce = (if v_314 then 2-proj-2-tuple(v_313) else caught-fail) in
        {950}let k_18: key = (if v_314 then 1-proj-2-tuple(v_313) else caught-fail) in
        {951}let d_3: aead = (if v_314 then catch-fail(decrypt(k_18,n_14,h_49,ciphertext_9)) else caught-fail) in
        {952}let v_315: bool = not-caught-fail(d_3) in
        {953}let v_316: bitstring = (if v_315 then catch-fail(aeadunpack(d_3)) else caught-fail) in
        {954}let v_317: bool = (not-caught-fail(v_316) && success?(1-proj-3-tuple(v_316))) in
        {955}let plaintext_9: bitstring = (if v_317 then 3-proj-3-tuple(v_316) else caught-fail) in
        {956}let adi_3: bitstring = (if v_317 then 2-proj-3-tuple(v_316) else caught-fail) in
        {957}let valid_7: bool = (if v_317 then 1-proj-3-tuple(v_316) else caught-fail) in
        {959}let v_318: bitstring = (if v_317 then catch-fail(cipherstateunpack(cs_49)) else caught-fail) in
        {960}let v_319: bool = (not-caught-fail(v_318) && success?(1-proj-2-tuple(v_318))) in
        {961}let o_7: nonce = (if v_319 then 2-proj-2-tuple(v_318) else caught-fail) in
        {962}let k_19: key = (if v_319 then 1-proj-2-tuple(v_318) else caught-fail) in
        {958}let n_15: nonce = (if v_317 then increment_nonce(n_14) else caught-fail) in
        {963}let csi_14: cipherstate = (if v_317 then catch-fail((if v_319 then cipherstatepack(k_19,n_15) else fail-any)) else caught-fail) in
        {964}let v_320: bool = not-caught-fail(csi_14) in
        {965}let v_321: bitstring = (if v_312 then catch-fail((if v_314 then (if v_315 then (if v_317 then (if v_320 then (csi_14,plaintext_9,valid_7) else fail-any) else fail-any) else fail-any) else fail-any)) else caught-fail) in
        {966}let v_322: bool = (not-caught-fail(v_321) && success?(1-proj-3-tuple(v_321))) in
        {967}let valid_8: bool = (if v_322 then 3-proj-3-tuple(v_321) else caught-fail) in
        {968}let plaintext_10: bitstring = (if v_322 then 2-proj-3-tuple(v_321) else caught-fail) in
        {969}let csi_15: cipherstate = (if v_322 then 1-proj-3-tuple(v_321) else caught-fail) in
        {970}let ss_50: symmetricstate = (if v_322 then symmetricstatepack(csi_15,ck_61,h_49) else caught-fail) in
        {971}let v_323: bitstring = (if v_322 then catch-fail(symmetricstateunpack(ss_50)) else caught-fail) in
        {972}let v_324: bool = (not-caught-fail(v_323) && success?(1-proj-3-tuple(v_323))) in
        {973}let h_50: bitstring = (if v_324 then 3-proj-3-tuple(v_323) else caught-fail) in
        {974}let ck_62: key = (if v_324 then 2-proj-3-tuple(v_323) else caught-fail) in
        {975}let cs_50: cipherstate = (if v_324 then 1-proj-3-tuple(v_323) else caught-fail) in
        {976}let ssi_10: symmetricstate = (if v_322 then catch-fail((if v_324 then symmetricstatepack(cs_50,ck_62,hash(h_50,ciphertext_9)) else fail-any)) else caught-fail) in
        {977}let v_325: bool = not-caught-fail(ssi_10) in
        {978}let v_326: bitstring = (if v_310 then catch-fail((if v_312 then (if v_322 then (if v_325 then (ssi_10,plaintext_10,valid_8) else fail-any) else fail-any) else fail-any)) else caught-fail) in
        {979}let v_327: bool = (not-caught-fail(v_326) && success?(1-proj-3-tuple(v_326))) in
        {980}let valid2_1: bool = (if v_327 then 3-proj-3-tuple(v_326) else caught-fail) in
        {981}let plaintext_11: bitstring = (if v_327 then 2-proj-3-tuple(v_326) else caught-fail) in
        {982}let ss_51: symmetricstate = (if v_327 then 1-proj-3-tuple(v_326) else caught-fail) in
        {983}let basis_13: key = (if v_327 then key_s(them_3) else caught-fail) in
        {984}let public_key_13: key = (if v_327 then catch-fail(dhexp(basis_13,validkey(g))) else caught-fail) in
        {985}let v_328: bool = not-caught-fail(public_key_13) in
        {986}let v_329: bool = (if v_327 then catch-fail(((valid1_3 && valid2_1) && (rs_7 = getpublickey((if v_328 then keypairpack(validkey(public_key_13),basis_13) else fail-any))))) else caught-fail) in
        {988}let v_330: bitstring = (if v_329 then catch-fail(symmetricstateunpack(ss_51)) else caught-fail) in
        {989}let v_331: bool = (not-caught-fail(v_330) && success?(1-proj-3-tuple(v_330))) in
        {990}let h_51: bitstring = (if v_331 then 3-proj-3-tuple(v_330) else caught-fail) in
        {991}let ck_63: key = (if v_331 then 2-proj-3-tuple(v_330) else caught-fail) in
        {992}let cs_51: cipherstate = (if v_331 then 1-proj-3-tuple(v_330) else caught-fail) in
        {993}let input_key_material_15: key = (if v_331 then zero else caught-fail) in
        {996}let output3_15: key = (if v_331 then hmac_hash3(ck_63,input_key_material_15) else caught-fail) in
        {995}let output2_15: key = (if v_331 then hmac_hash2(ck_63,input_key_material_15) else caught-fail) in
        {994}let output1_15: key = (if v_331 then hmac_hash1(ck_63,input_key_material_15) else caught-fail) in
        {997}let v_332: bitstring = (if v_331 then catch-fail((output1_15,output2_15,output3_15)) else caught-fail) in
        {998}let v_333: bool = (not-caught-fail(v_332) && success?(1-proj-3-tuple(v_332))) in
        {999}let temp_k3_3: key = (if v_333 then 3-proj-3-tuple(v_332) else caught-fail) in
        {1000}let temp_k2_3: key = (if v_333 then 2-proj-3-tuple(v_332) else caught-fail) in
        {1001}let temp_k1_3: key = (if v_333 then 1-proj-3-tuple(v_332) else caught-fail) in
        {1003}let cs2_9: cipherstate = (if v_333 then cipherstatepack(temp_k2_3,minnonce) else caught-fail) in
        {1002}let cs1_9: cipherstate = (if v_333 then cipherstatepack(temp_k1_3,minnonce) else caught-fail) in
        {1004}let v_334: bitstring = (if v_329 then catch-fail((if v_331 then (if v_333 then (ss_51,cs1_9,cs2_9) else fail-any) else fail-any)) else caught-fail) in
        {1005}let v_335: bool = (not-caught-fail(v_334) && success?(1-proj-3-tuple(v_334))) in
        {1006}let cs2_10: cipherstate = (if v_335 then 3-proj-3-tuple(v_334) else caught-fail) in
        {1007}let cs1_10: cipherstate = (if v_335 then 2-proj-3-tuple(v_334) else caught-fail) in
        {1008}let ssi_11: symmetricstate = (if v_335 then 1-proj-3-tuple(v_334) else caught-fail) in
        {987}let hs_14: handshakestate = (if v_329 then handshakestatepack(ss_51,s_7,m_9,e_13,rs_7,rm_9,re_9,psk_7,initiator_4) else caught-fail) in
        {1009}let (hs_15: handshakestate,plaintext_a_1: bitstring,valid_9: bool,cs1_11: cipherstate,cs2_11: cipherstate) = (if v_264 then (if v_266 then (if v_269 then (if v_277 then (if v_285 then (if v_302 then (if v_310 then (if v_327 then (if undo-catch-fail(v_329) then (if v_335 then (hs_14,plaintext_11,true,cs1_10,cs2_10) else fail-any) else fail-any) else fail-any) else fail-any) else fail-any) else fail-any) else fail-any) else fail-any) else fail-any) else fail-any) in
        {1010}event RecvMsg(me_4,them_3,stagepack_a(sid_4),plaintext_a_1);
        {1011}event RecvEnd(valid_9)
    ) | (
        {1013}event LeakS(phase0,me_4);
        {1014}event LeakM(phase0,me_4);
        {1015}out(pub, (key_s(me_4),key_m(me_4)))
    ) | (
        {1016}phase 1;
        {1017}event LeakS(phase1,me_4);
        {1018}event LeakM(phase1,me_4);
        {1019}out(pub, (key_s(me_4),key_m(me_4)))
    )
)

-- Query event(RecvMsg(bob,alice,stagepack_a(sid_b),m_10)) ==> event(SendMsg(alice,bob,stagepack_a(sid_a),m_10)); event(RecvMsg(bob,alice,stagepack_a(sid_b),m_10)) ==> event(SendMsg(alice,c,stagepack_a(sid_a),m_10)) || (event(LeakS(phase0,alice)) && event(LeakM(phase0,alice))) || (event(LeakS(phase0,bob)) && event(LeakM(phase0,bob))); event(RecvMsg(bob,alice,stagepack_a(sid_b),m_10)) ==> event(SendMsg(alice,c,stagepack_a(sid_a),m_10)) || (event(LeakS(phase0,alice)) && event(LeakM(phase0,alice))); event(RecvMsg(bob,alice,stagepack_a(sid_b),m_10)) ==> event(SendMsg(alice,bob,stagepack_a(sid_a),m_10)) || (event(LeakS(phase0,alice)) && event(LeakM(phase0,alice))) || (event(LeakS(phase0,bob)) && event(LeakM(phase0,bob))); event(RecvMsg(bob,alice,stagepack_a(sid_b),m_10)) ==> event(SendMsg(alice,bob,stagepack_a(sid_a),m_10)) || (event(LeakS(phase0,alice)) && event(LeakM(phase0,alice))); not attacker_p1(msg_a(alice,bob,sid_a)); attacker_p1(msg_a(alice,bob,sid_a)) ==> event(LeakS(px,bob)) && event(LeakM(px,bob)); attacker_p1(msg_a(alice,bob,sid_a)) ==> (event(LeakS(phase0,bob)) && event(LeakM(phase0,bob))) || (event(LeakS(px,bob)) && event(LeakM(px,bob)) && event(LeakS(pz,alice)) && event(LeakM(pz,alice))); attacker_p1(msg_a(alice,bob,sid_a)) ==> event(LeakS(phase0,bob)) && event(LeakM(phase0,bob)); not event(RecvEnd(true)) in process 1.
Translating the process into Horn clauses...
Completing...
200 rules inserted. Base: 200 rules (85 with conclusion selected). Queue: 108 rules.
400 rules inserted. Base: 397 rules (166 with conclusion selected). Queue: 59 rules.
600 rules inserted. Base: 525 rules (170 with conclusion selected). Queue: 127 rules.
800 rules inserted. Base: 673 rules (170 with conclusion selected). Queue: 191 rules.
1000 rules inserted. Base: 835 rules (170 with conclusion selected). Queue: 231 rules.
1200 rules inserted. Base: 995 rules (170 with conclusion selected). Queue: 252 rules.
1400 rules inserted. Base: 1164 rules (170 with conclusion selected). Queue: 264 rules.
1600 rules inserted. Base: 1360 rules (170 with conclusion selected). Queue: 347 rules.
1800 rules inserted. Base: 1524 rules (170 with conclusion selected). Queue: 360 rules.
2000 rules inserted. Base: 1669 rules (170 with conclusion selected). Queue: 353 rules.
2200 rules inserted. Base: 1800 rules (170 with conclusion selected). Queue: 353 rules.
2400 rules inserted. Base: 1980 rules (170 with conclusion selected). Queue: 368 rules.
2600 rules inserted. Base: 2152 rules (170 with conclusion selected). Queue: 389 rules.
2800 rules inserted. Base: 2297 rules (170 with conclusion selected). Queue: 403 rules.
3000 rules inserted. Base: 2480 rules (171 with conclusion selected). Queue: 435 rules.
3200 rules inserted. Base: 2624 rules (171 with conclusion selected). Queue: 438 rules.
3400 rules inserted. Base: 2798 rules (176 with conclusion selected). Queue: 496 rules.
3600 rules inserted. Base: 2865 rules (176 with conclusion selected). Queue: 478 rules.
3800 rules inserted. Base: 2971 rules (178 with conclusion selected). Queue: 474 rules.
4000 rules inserted. Base: 2990 rules (179 with conclusion selected). Queue: 433 rules.
4200 rules inserted. Base: 3029 rules (179 with conclusion selected). Queue: 383 rules.
4400 rules inserted. Base: 2586 rules (183 with conclusion selected). Queue: 300 rules.
4600 rules inserted. Base: 2629 rules (183 with conclusion selected). Queue: 260 rules.
4800 rules inserted. Base: 2569 rules (184 with conclusion selected). Queue: 176 rules.
5000 rules inserted. Base: 2604 rules (183 with conclusion selected). Queue: 81 rules.
Starting query event(RecvMsg(bob,alice,stagepack_a(sid_b),m_10)) ==> event(SendMsg(alice,bob,stagepack_a(sid_a),m_10))
RESULT event(RecvMsg(bob,alice,stagepack_a(sid_b),m_10)) ==> event(SendMsg(alice,bob,stagepack_a(sid_a),m_10)) is true.
Starting query event(RecvMsg(bob,alice,stagepack_a(sid_b),m_10)) ==> event(SendMsg(alice,c,stagepack_a(sid_a),m_10)) || (event(LeakS(phase0,alice)) && event(LeakM(phase0,alice))) || (event(LeakS(phase0,bob)) && event(LeakM(phase0,bob)))
RESULT event(RecvMsg(bob,alice,stagepack_a(sid_b),m_10)) ==> event(SendMsg(alice,c,stagepack_a(sid_a),m_10)) || (event(LeakS(phase0,alice)) && event(LeakM(phase0,alice))) || (event(LeakS(phase0,bob)) && event(LeakM(phase0,bob))) is true.
Starting query event(RecvMsg(bob,alice,stagepack_a(sid_b),m_10)) ==> event(SendMsg(alice,c,stagepack_a(sid_a),m_10)) || (event(LeakS(phase0,alice)) && event(LeakM(phase0,alice)))
RESULT event(RecvMsg(bob,alice,stagepack_a(sid_b),m_10)) ==> event(SendMsg(alice,c,stagepack_a(sid_a),m_10)) || (event(LeakS(phase0,alice)) && event(LeakM(phase0,alice))) is true.
Starting query event(RecvMsg(bob,alice,stagepack_a(sid_b),m_10)) ==> event(SendMsg(alice,bob,stagepack_a(sid_a),m_10)) || (event(LeakS(phase0,alice)) && event(LeakM(phase0,alice))) || (event(LeakS(phase0,bob)) && event(LeakM(phase0,bob)))
RESULT event(RecvMsg(bob,alice,stagepack_a(sid_b),m_10)) ==> event(SendMsg(alice,bob,stagepack_a(sid_a),m_10)) || (event(LeakS(phase0,alice)) && event(LeakM(phase0,alice))) || (event(LeakS(phase0,bob)) && event(LeakM(phase0,bob))) is true.
Starting query event(RecvMsg(bob,alice,stagepack_a(sid_b),m_10)) ==> event(SendMsg(alice,bob,stagepack_a(sid_a),m_10)) || (event(LeakS(phase0,alice)) && event(LeakM(phase0,alice)))
RESULT event(RecvMsg(bob,alice,stagepack_a(sid_b),m_10)) ==> event(SendMsg(alice,bob,stagepack_a(sid_a),m_10)) || (event(LeakS(phase0,alice)) && event(LeakM(phase0,alice))) is true.
Starting query not attacker_p1(msg_a(alice,bob,sid_a))
goal reachable: begin(LeakM(phase0,bob)) && begin(LeakS(phase0,bob)) && begin(SendMsg(alice,bob,stagepack_a(sid_5),msg_a(alice,bob,sid_5))) -> attacker_p1(msg_a(alice,bob,sid_5))
Abbreviations:
sid_5 = sid[!1 = @sid]

Derivation:
Abbreviations:
sid_5 = sid[!1 = @sid]

1. Using the function pub the attacker may obtain pub.
attacker(pub).

2. The entry statestore(alice,bob,sid_5,statepack_a(handshakestatepack(symmetricstatepack(cipherstatepack(empty,minnonce),hash(somename,empty),hash(hash(hash(hash(somename,empty),empty),validkey(dhexp_real(key_s(bob),g))),validkey(dhexp_real(key_m(bob),g)))),keypairpack(empty,empty),keypairpack(empty,empty),keypairpack(empty,empty),validkey(dhexp_real(key_s(bob),g)),validkey(dhexp_real(key_m(bob),g)),empty,empty,true))) may be inserted in a table at insert {50}.
table(statestore(alice,bob,sid_5,statepack_a(handshakestatepack(symmetricstatepack(cipherstatepack(empty,minnonce),hash(somename,empty),hash(hash(hash(hash(somename,empty),empty),validkey(dhexp_real(key_s(bob),g))),validkey(dhexp_real(key_m(bob),g)))),keypairpack(empty,empty),keypairpack(empty,empty),keypairpack(empty,empty),validkey(dhexp_real(key_s(bob),g)),validkey(dhexp_real(key_m(bob),g)),empty,empty,true)))).

3. The entry statestore(alice,bob,sid_5,statepack_a(handshakestatepack(symmetricstatepack(cipherstatepack(empty,minnonce),hash(somename,empty),hash(hash(hash(hash(somename,empty),empty),validkey(dhexp_real(key_s(bob),g))),validkey(dhexp_real(key_m(bob),g)))),keypairpack(empty,empty),keypairpack(empty,empty),keypairpack(empty,empty),validkey(dhexp_real(key_s(bob),g)),validkey(dhexp_real(key_m(bob),g)),empty,empty,true))) that may be in a table by 2 may be read at get {244}.
The event SendMsg(alice,bob,stagepack_a(sid_5),msg_a(alice,bob,sid_5)) may be executed at {242}.
So the message concat3(validkey(dhexp_real(key_e(alice,bob,sid_5),g)),encrypt(hmac_hash2(hmac_hash1(hash(somename,empty),dhexp_real(key_e(alice,bob,sid_5),dhexp_real(key_s(bob),g))),dhexp_real(key_e(alice,bob,sid_5),dhexp_real(key_m(bob),g))),minnonce,hash(hash(hash(hash(hash(somename,empty),empty),validkey(dhexp_real(key_s(bob),g))),validkey(dhexp_real(key_m(bob),g))),validkey(dhexp_real(key_e(alice,bob,sid_5),g))),validkey(dhexp_real(key_m(alice),g))),encrypt(hmac_hash2(hmac_hash1(hmac_hash1(hash(somename,empty),dhexp_real(key_e(alice,bob,sid_5),dhexp_real(key_s(bob),g))),dhexp_real(key_e(alice,bob,sid_5),dhexp_real(key_m(bob),g))),dhexp_real(key_m(alice),dhexp_real(key_s(bob),g))),minnonce,hash(hash(hash(hash(hash(hash(somename,empty),empty),validkey(dhexp_real(key_s(bob),g))),validkey(dhexp_real(key_m(bob),g))),validkey(dhexp_real(key_e(alice,bob,sid_5),g))),encrypt(hmac_hash2(hmac_hash1(hash(somename,empty),dhexp_real(key_e(alice,bob,sid_5),dhexp_real(key_s(bob),g))),dhexp_real(key_e(alice,bob,sid_5),dhexp_real(key_m(bob),g))),minnonce,hash(hash(hash(hash(hash(somename,empty),empty),validkey(dhexp_real(key_s(bob),g))),validkey(dhexp_real(key_m(bob),g))),validkey(dhexp_real(key_e(alice,bob,sid_5),g))),validkey(dhexp_real(key_m(alice),g)))),msg_a(alice,bob,sid_5))) may be sent on channel pub at output {243}.
mess(pub,concat3(validkey(dhexp_real(key_e(alice,bob,sid_5),g)),encrypt(hmac_hash2(hmac_hash1(hash(somename,empty),dhexp_real(key_e(alice,bob,sid_5),dhexp_real(key_s(bob),g))),dhexp_real(key_e(alice,bob,sid_5),dhexp_real(key_m(bob),g))),minnonce,hash(hash(hash(hash(hash(somename,empty),empty),validkey(dhexp_real(key_s(bob),g))),validkey(dhexp_real(key_m(bob),g))),validkey(dhexp_real(key_e(alice,bob,sid_5),g))),validkey(dhexp_real(key_m(alice),g))),encrypt(hmac_hash2(hmac_hash1(hmac_hash1(hash(somename,empty),dhexp_real(key_e(alice,bob,sid_5),dhexp_real(key_s(bob),g))),dhexp_real(key_e(alice,bob,sid_5),dhexp_real(key_m(bob),g))),dhexp_real(key_m(alice),dhexp_real(key_s(bob),g))),minnonce,hash(hash(hash(hash(hash(hash(somename,empty),empty),validkey(dhexp_real(key_s(bob),g))),validkey(dhexp_real(key_m(bob),g))),validkey(dhexp_real(key_e(alice,bob,sid_5),g))),encrypt(hmac_hash2(hmac_hash1(hash(somename,empty),dhexp_real(key_e(alice,bob,sid_5),dhexp_real(key_s(bob),g))),dhexp_real(key_e(alice,bob,sid_5),dhexp_real(key_m(bob),g))),minnonce,hash(hash(hash(hash(hash(somename,empty),empty),validkey(dhexp_real(key_s(bob),g))),validkey(dhexp_real(key_m(bob),g))),validkey(dhexp_real(key_e(alice,bob,sid_5),g))),validkey(dhexp_real(key_m(alice),g)))),msg_a(alice,bob,sid_5)))).

4. By 1, the attacker may have the channel pub.
By 3, the message concat3(validkey(dhexp_real(key_e(alice,bob,sid_5),g)),encrypt(hmac_hash2(hmac_hash1(hash(somename,empty),dhexp_real(key_e(alice,bob,sid_5),dhexp_real(key_s(bob),g))),dhexp_real(key_e(alice,bob,sid_5),dhexp_real(key_m(bob),g))),minnonce,hash(hash(hash(hash(hash(somename,empty),empty),validkey(dhexp_real(key_s(bob),g))),validkey(dhexp_real(key_m(bob),g))),validkey(dhexp_real(key_e(alice,bob,sid_5),g))),validkey(dhexp_real(key_m(alice),g))),encrypt(hmac_hash2(hmac_hash1(hmac_hash1(hash(somename,empty),dhexp_real(key_e(alice,bob,sid_5),dhexp_real(key_s(bob),g))),dhexp_real(key_e(alice,bob,sid_5),dhexp_real(key_m(bob),g))),dhexp_real(key_m(alice),dhexp_real(key_s(bob),g))),minnonce,hash(hash(hash(hash(hash(hash(somename,empty),empty),validkey(dhexp_real(key_s(bob),g))),validkey(dhexp_real(key_m(bob),g))),validkey(dhexp_real(key_e(alice,bob,sid_5),g))),encrypt(hmac_hash2(hmac_hash1(hash(somename,empty),dhexp_real(key_e(alice,bob,sid_5),dhexp_real(key_s(bob),g))),dhexp_real(key_e(alice,bob,sid_5),dhexp_real(key_m(bob),g))),minnonce,hash(hash(hash(hash(hash(somename,empty),empty),validkey(dhexp_real(key_s(bob),g))),validkey(dhexp_real(key_m(bob),g))),validkey(dhexp_real(key_e(alice,bob,sid_5),g))),validkey(dhexp_real(key_m(alice),g)))),msg_a(alice,bob,sid_5))) may be sent on this channel.
So the attacker may obtain the message concat3(validkey(dhexp_real(key_e(alice,bob,sid_5),g)),encrypt(hmac_hash2(hmac_hash1(hash(somename,empty),dhexp_real(key_e(alice,bob,sid_5),dhexp_real(key_s(bob),g))),dhexp_real(key_e(alice,bob,sid_5),dhexp_real(key_m(bob),g))),minnonce,hash(hash(hash(hash(hash(somename,empty),empty),validkey(dhexp_real(key_s(bob),g))),validkey(dhexp_real(key_m(bob),g))),validkey(dhexp_real(key_e(alice,bob,sid_5),g))),validkey(dhexp_real(key_m(alice),g))),encrypt(hmac_hash2(hmac_hash1(hmac_hash1(hash(somename,empty),dhexp_real(key_e(alice,bob,sid_5),dhexp_real(key_s(bob),g))),dhexp_real(key_e(alice,bob,sid_5),dhexp_real(key_m(bob),g))),dhexp_real(key_m(alice),dhexp_real(key_s(bob),g))),minnonce,hash(hash(hash(hash(hash(hash(somename,empty),empty),validkey(dhexp_real(key_s(bob),g))),validkey(dhexp_real(key_m(bob),g))),validkey(dhexp_real(key_e(alice,bob,sid_5),g))),encrypt(hmac_hash2(hmac_hash1(hash(somename,empty),dhexp_real(key_e(alice,bob,sid_5),dhexp_real(key_s(bob),g))),dhexp_real(key_e(alice,bob,sid_5),dhexp_real(key_m(bob),g))),minnonce,hash(hash(hash(hash(hash(somename,empty),empty),validkey(dhexp_real(key_s(bob),g))),validkey(dhexp_real(key_m(bob),g))),validkey(dhexp_real(key_e(alice,bob,sid_5),g))),validkey(dhexp_real(key_m(alice),g)))),msg_a(alice,bob,sid_5))) by listening on this channel.
attacker(concat3(validkey(dhexp_real(key_e(alice,bob,sid_5),g)),encrypt(hmac_hash2(hmac_hash1(hash(somename,empty),dhexp_real(key_e(alice,bob,sid_5),dhexp_real(key_s(bob),g))),dhexp_real(key_e(alice,bob,sid_5),dhexp_real(key_m(bob),g))),minnonce,hash(hash(hash(hash(hash(somename,empty),empty),validkey(dhexp_real(key_s(bob),g))),validkey(dhexp_real(key_m(bob),g))),validkey(dhexp_real(key_e(alice,bob,sid_5),g))),validkey(dhexp_real(key_m(alice),g))),encrypt(hmac_hash2(hmac_hash1(hmac_hash1(hash(somename,empty),dhexp_real(key_e(alice,bob,sid_5),dhexp_real(key_s(bob),g))),dhexp_real(key_e(alice,bob,sid_5),dhexp_real(key_m(bob),g))),dhexp_real(key_m(alice),dhexp_real(key_s(bob),g))),minnonce,hash(hash(hash(hash(hash(hash(somename,empty),empty),validkey(dhexp_real(key_s(bob),g))),validkey(dhexp_real(key_m(bob),g))),validkey(dhexp_real(key_e(alice,bob,sid_5),g))),encrypt(hmac_hash2(hmac_hash1(hash(somename,empty),dhexp_real(key_e(alice,bob,sid_5),dhexp_real(key_s(bob),g))),dhexp_real(key_e(alice,bob,sid_5),dhexp_real(key_m(bob),g))),minnonce,hash(hash(hash(hash(hash(somename,empty),empty),validkey(dhexp_real(key_s(bob),g))),validkey(dhexp_real(key_m(bob),g))),validkey(dhexp_real(key_e(alice,bob,sid_5),g))),validkey(dhexp_real(key_m(alice),g)))),msg_a(alice,bob,sid_5)))).

5. By 4, the attacker may know concat3(validkey(dhexp_real(key_e(alice,bob,sid_5),g)),encrypt(hmac_hash2(hmac_hash1(hash(somename,empty),dhexp_real(key_e(alice,bob,sid_5),dhexp_real(key_s(bob),g))),dhexp_real(key_e(alice,bob,sid_5),dhexp_real(key_m(bob),g))),minnonce,hash(hash(hash(hash(hash(somename,empty),empty),validkey(dhexp_real(key_s(bob),g))),validkey(dhexp_real(key_m(bob),g))),validkey(dhexp_real(key_e(alice,bob,sid_5),g))),validkey(dhexp_real(key_m(alice),g))),encrypt(hmac_hash2(hmac_hash1(hmac_hash1(hash(somename,empty),dhexp_real(key_e(alice,bob,sid_5),dhexp_real(key_s(bob),g))),dhexp_real(key_e(alice,bob,sid_5),dhexp_real(key_m(bob),g))),dhexp_real(key_m(alice),dhexp_real(key_s(bob),g))),minnonce,hash(hash(hash(hash(hash(hash(somename,empty),empty),validkey(dhexp_real(key_s(bob),g))),validkey(dhexp_real(key_m(bob),g))),validkey(dhexp_real(key_e(alice,bob,sid_5),g))),encrypt(hmac_hash2(hmac_hash1(hash(somename,empty),dhexp_real(key_e(alice,bob,sid_5),dhexp_real(key_s(bob),g))),dhexp_real(key_e(alice,bob,sid_5),dhexp_real(key_m(bob),g))),minnonce,hash(hash(hash(hash(hash(somename,empty),empty),validkey(dhexp_real(key_s(bob),g))),validkey(dhexp_real(key_m(bob),g))),validkey(dhexp_real(key_e(alice,bob,sid_5),g))),validkey(dhexp_real(key_m(alice),g)))),msg_a(alice,bob,sid_5))).
Using the function 3-proj-concat3 the attacker may obtain encrypt(hmac_hash2(hmac_hash1(hmac_hash1(hash(somename,empty),dhexp_real(key_e(alice,bob,sid_5),dhexp_real(key_s(bob),g))),dhexp_real(key_e(alice,bob,sid_5),dhexp_real(key_m(bob),g))),dhexp_real(key_m(alice),dhexp_real(key_s(bob),g))),minnonce,hash(hash(hash(hash(hash(hash(somename,empty),empty),validkey(dhexp_real(key_s(bob),g))),validkey(dhexp_real(key_m(bob),g))),validkey(dhexp_real(key_e(alice,bob,sid_5),g))),encrypt(hmac_hash2(hmac_hash1(hash(somename,empty),dhexp_real(key_e(alice,bob,sid_5),dhexp_real(key_s(bob),g))),dhexp_real(key_e(alice,bob,sid_5),dhexp_real(key_m(bob),g))),minnonce,hash(hash(hash(hash(hash(somename,empty),empty),validkey(dhexp_real(key_s(bob),g))),validkey(dhexp_real(key_m(bob),g))),validkey(dhexp_real(key_e(alice,bob,sid_5),g))),validkey(dhexp_real(key_m(alice),g)))),msg_a(alice,bob,sid_5)).
attacker(encrypt(hmac_hash2(hmac_hash1(hmac_hash1(hash(somename,empty),dhexp_real(key_e(alice,bob,sid_5),dhexp_real(key_s(bob),g))),dhexp_real(key_e(alice,bob,sid_5),dhexp_real(key_m(bob),g))),dhexp_real(key_m(alice),dhexp_real(key_s(bob),g))),minnonce,hash(hash(hash(hash(hash(hash(somename,empty),empty),validkey(dhexp_real(key_s(bob),g))),validkey(dhexp_real(key_m(bob),g))),validkey(dhexp_real(key_e(alice,bob,sid_5),g))),encrypt(hmac_hash2(hmac_hash1(hash(somename,empty),dhexp_real(key_e(alice,bob,sid_5),dhexp_real(key_s(bob),g))),dhexp_real(key_e(alice,bob,sid_5),dhexp_real(key_m(bob),g))),minnonce,hash(hash(hash(hash(hash(somename,empty),empty),validkey(dhexp_real(key_s(bob),g))),validkey(dhexp_real(key_m(bob),g))),validkey(dhexp_real(key_e(alice,bob,sid_5),g))),validkey(dhexp_real(key_m(alice),g)))),msg_a(alice,bob,sid_5))).

6. By 5, the attacker may know encrypt(hmac_hash2(hmac_hash1(hmac_hash1(hash(somename,empty),dhexp_real(key_e(alice,bob,sid_5),dhexp_real(key_s(bob),g))),dhexp_real(key_e(alice,bob,sid_5),dhexp_real(key_m(bob),g))),dhexp_real(key_m(alice),dhexp_real(key_s(bob),g))),minnonce,hash(hash(hash(hash(hash(hash(somename,empty),empty),validkey(dhexp_real(key_s(bob),g))),validkey(dhexp_real(key_m(bob),g))),validkey(dhexp_real(key_e(alice,bob,sid_5),g))),encrypt(hmac_hash2(hmac_hash1(hash(somename,empty),dhexp_real(key_e(alice,bob,sid_5),dhexp_real(key_s(bob),g))),dhexp_real(key_e(alice,bob,sid_5),dhexp_real(key_m(bob),g))),minnonce,hash(hash(hash(hash(hash(somename,empty),empty),validkey(dhexp_real(key_s(bob),g))),validkey(dhexp_real(key_m(bob),g))),validkey(dhexp_real(key_e(alice,bob,sid_5),g))),validkey(dhexp_real(key_m(alice),g)))),msg_a(alice,bob,sid_5)).
So the attacker may know encrypt(hmac_hash2(hmac_hash1(hmac_hash1(hash(somename,empty),dhexp_real(key_e(alice,bob,sid_5),dhexp_real(key_s(bob),g))),dhexp_real(key_e(alice,bob,sid_5),dhexp_real(key_m(bob),g))),dhexp_real(key_m(alice),dhexp_real(key_s(bob),g))),minnonce,hash(hash(hash(hash(hash(hash(somename,empty),empty),validkey(dhexp_real(key_s(bob),g))),validkey(dhexp_real(key_m(bob),g))),validkey(dhexp_real(key_e(alice,bob,sid_5),g))),encrypt(hmac_hash2(hmac_hash1(hash(somename,empty),dhexp_real(key_e(alice,bob,sid_5),dhexp_real(key_s(bob),g))),dhexp_real(key_e(alice,bob,sid_5),dhexp_real(key_m(bob),g))),minnonce,hash(hash(hash(hash(hash(somename,empty),empty),validkey(dhexp_real(key_s(bob),g))),validkey(dhexp_real(key_m(bob),g))),validkey(dhexp_real(key_e(alice,bob,sid_5),g))),validkey(dhexp_real(key_m(alice),g)))),msg_a(alice,bob,sid_5)) in phase 1.
attacker_p1(encrypt(hmac_hash2(hmac_hash1(hmac_hash1(hash(somename,empty),dhexp_real(key_e(alice,bob,sid_5),dhexp_real(key_s(bob),g))),dhexp_real(key_e(alice,bob,sid_5),dhexp_real(key_m(bob),g))),dhexp_real(key_m(alice),dhexp_real(key_s(bob),g))),minnonce,hash(hash(hash(hash(hash(hash(somename,empty),empty),validkey(dhexp_real(key_s(bob),g))),validkey(dhexp_real(key_m(bob),g))),validkey(dhexp_real(key_e(alice,bob,sid_5),g))),encrypt(hmac_hash2(hmac_hash1(hash(somename,empty),dhexp_real(key_e(alice,bob,sid_5),dhexp_real(key_s(bob),g))),dhexp_real(key_e(alice,bob,sid_5),dhexp_real(key_m(bob),g))),minnonce,hash(hash(hash(hash(hash(somename,empty),empty),validkey(dhexp_real(key_s(bob),g))),validkey(dhexp_real(key_m(bob),g))),validkey(dhexp_real(key_e(alice,bob,sid_5),g))),validkey(dhexp_real(key_m(alice),g)))),msg_a(alice,bob,sid_5))).

7. By 4, the attacker may know concat3(validkey(dhexp_real(key_e(alice,bob,sid_5),g)),encrypt(hmac_hash2(hmac_hash1(hash(somename,empty),dhexp_real(key_e(alice,bob,sid_5),dhexp_real(key_s(bob),g))),dhexp_real(key_e(alice,bob,sid_5),dhexp_real(key_m(bob),g))),minnonce,hash(hash(hash(hash(hash(somename,empty),empty),validkey(dhexp_real(key_s(bob),g))),validkey(dhexp_real(key_m(bob),g))),validkey(dhexp_real(key_e(alice,bob,sid_5),g))),validkey(dhexp_real(key_m(alice),g))),encrypt(hmac_hash2(hmac_hash1(hmac_hash1(hash(somename,empty),dhexp_real(key_e(alice,bob,sid_5),dhexp_real(key_s(bob),g))),dhexp_real(key_e(alice,bob,sid_5),dhexp_real(key_m(bob),g))),dhexp_real(key_m(alice),dhexp_real(key_s(bob),g))),minnonce,hash(hash(hash(hash(hash(hash(somename,empty),empty),validkey(dhexp_real(key_s(bob),g))),validkey(dhexp_real(key_m(bob),g))),validkey(dhexp_real(key_e(alice,bob,sid_5),g))),encrypt(hmac_hash2(hmac_hash1(hash(somename,empty),dhexp_real(key_e(alice,bob,sid_5),dhexp_real(key_s(bob),g))),dhexp_real(key_e(alice,bob,sid_5),dhexp_real(key_m(bob),g))),minnonce,hash(hash(hash(hash(hash(somename,empty),empty),validkey(dhexp_real(key_s(bob),g))),validkey(dhexp_real(key_m(bob),g))),validkey(dhexp_real(key_e(alice,bob,sid_5),g))),validkey(dhexp_real(key_m(alice),g)))),msg_a(alice,bob,sid_5))).
Using the function 2-proj-concat3 the attacker may obtain encrypt(hmac_hash2(hmac_hash1(hash(somename,empty),dhexp_real(key_e(alice,bob,sid_5),dhexp_real(key_s(bob),g))),dhexp_real(key_e(alice,bob,sid_5),dhexp_real(key_m(bob),g))),minnonce,hash(hash(hash(hash(hash(somename,empty),empty),validkey(dhexp_real(key_s(bob),g))),validkey(dhexp_real(key_m(bob),g))),validkey(dhexp_real(key_e(alice,bob,sid_5),g))),validkey(dhexp_real(key_m(alice),g))).
attacker(encrypt(hmac_hash2(hmac_hash1(hash(somename,empty),dhexp_real(key_e(alice,bob,sid_5),dhexp_real(key_s(bob),g))),dhexp_real(key_e(alice,bob,sid_5),dhexp_real(key_m(bob),g))),minnonce,hash(hash(hash(hash(hash(somename,empty),empty),validkey(dhexp_real(key_s(bob),g))),validkey(dhexp_real(key_m(bob),g))),validkey(dhexp_real(key_e(alice,bob,sid_5),g))),validkey(dhexp_real(key_m(alice),g)))).

8. By 4, the attacker may know concat3(validkey(dhexp_real(key_e(alice,bob,sid_5),g)),encrypt(hmac_hash2(hmac_hash1(hash(somename,empty),dhexp_real(key_e(alice,bob,sid_5),dhexp_real(key_s(bob),g))),dhexp_real(key_e(alice,bob,sid_5),dhexp_real(key_m(bob),g))),minnonce,hash(hash(hash(hash(hash(somename,empty),empty),validkey(dhexp_real(key_s(bob),g))),validkey(dhexp_real(key_m(bob),g))),validkey(dhexp_real(key_e(alice,bob,sid_5),g))),validkey(dhexp_real(key_m(alice),g))),encrypt(hmac_hash2(hmac_hash1(hmac_hash1(hash(somename,empty),dhexp_real(key_e(alice,bob,sid_5),dhexp_real(key_s(bob),g))),dhexp_real(key_e(alice,bob,sid_5),dhexp_real(key_m(bob),g))),dhexp_real(key_m(alice),dhexp_real(key_s(bob),g))),minnonce,hash(hash(hash(hash(hash(hash(somename,empty),empty),validkey(dhexp_real(key_s(bob),g))),validkey(dhexp_real(key_m(bob),g))),validkey(dhexp_real(key_e(alice,bob,sid_5),g))),encrypt(hmac_hash2(hmac_hash1(hash(somename,empty),dhexp_real(key_e(alice,bob,sid_5),dhexp_real(key_s(bob),g))),dhexp_real(key_e(alice,bob,sid_5),dhexp_real(key_m(bob),g))),minnonce,hash(hash(hash(hash(hash(somename,empty),empty),validkey(dhexp_real(key_s(bob),g))),validkey(dhexp_real(key_m(bob),g))),validkey(dhexp_real(key_e(alice,bob,sid_5),g))),validkey(dhexp_real(key_m(alice),g)))),msg_a(alice,bob,sid_5))).
Using the function 1-proj-concat3 the attacker may obtain validkey(dhexp_real(key_e(alice,bob,sid_5),g)).
attacker(validkey(dhexp_real(key_e(alice,bob,sid_5),g))).

9. The message (validkey(dhexp_real(key_s(bob),g)),validkey(dhexp_real(key_m(bob),g))) may be sent on channel pub at output {511}.
mess(pub,(validkey(dhexp_real(key_s(bob),g)),validkey(dhexp_real(key_m(bob),g)))).

10. By 1, the attacker may have the channel pub.
By 9, the message (validkey(dhexp_real(key_s(bob),g)),validkey(dhexp_real(key_m(bob),g))) may be sent on this channel.
So the attacker may obtain the message (validkey(dhexp_real(key_s(bob),g)),validkey(dhexp_real(key_m(bob),g))) by listening on this channel.
attacker((validkey(dhexp_real(key_s(bob),g)),validkey(dhexp_real(key_m(bob),g)))).

11. By 10, the attacker may know (validkey(dhexp_real(key_s(bob),g)),validkey(dhexp_real(key_m(bob),g))).
Using the function 2-proj-2-tuple the attacker may obtain validkey(dhexp_real(key_m(bob),g)).
attacker(validkey(dhexp_real(key_m(bob),g))).

12. By 10, the attacker may know (validkey(dhexp_real(key_s(bob),g)),validkey(dhexp_real(key_m(bob),g))).
Using the function 1-proj-2-tuple the attacker may obtain validkey(dhexp_real(key_s(bob),g)).
attacker(validkey(dhexp_real(key_s(bob),g))).

13. Using the function empty the attacker may obtain empty.
attacker(empty).

14. Using the function somename the attacker may obtain somename.
attacker(somename).

15. By 14, the attacker may know somename.
By 13, the attacker may know empty.
Using the function hash the attacker may obtain hash(somename,empty).
attacker(hash(somename,empty)).

16. By 15, the attacker may know hash(somename,empty).
By 13, the attacker may know empty.
Using the function hash the attacker may obtain hash(hash(somename,empty),empty).
attacker(hash(hash(somename,empty),empty)).

17. By 16, the attacker may know hash(hash(somename,empty),empty).
By 12, the attacker may know validkey(dhexp_real(key_s(bob),g)).
Using the function hash the attacker may obtain hash(hash(hash(somename,empty),empty),validkey(dhexp_real(key_s(bob),g))).
attacker(hash(hash(hash(somename,empty),empty),validkey(dhexp_real(key_s(bob),g)))).

18. By 17, the attacker may know hash(hash(hash(somename,empty),empty),validkey(dhexp_real(key_s(bob),g))).
By 11, the attacker may know validkey(dhexp_real(key_m(bob),g)).
Using the function hash the attacker may obtain hash(hash(hash(hash(somename,empty),empty),validkey(dhexp_real(key_s(bob),g))),validkey(dhexp_real(key_m(bob),g))).
attacker(hash(hash(hash(hash(somename,empty),empty),validkey(dhexp_real(key_s(bob),g))),validkey(dhexp_real(key_m(bob),g)))).

19. By 18, the attacker may know hash(hash(hash(hash(somename,empty),empty),validkey(dhexp_real(key_s(bob),g))),validkey(dhexp_real(key_m(bob),g))).
By 8, the attacker may know validkey(dhexp_real(key_e(alice,bob,sid_5),g)).
Using the function hash the attacker may obtain hash(hash(hash(hash(hash(somename,empty),empty),validkey(dhexp_real(key_s(bob),g))),validkey(dhexp_real(key_m(bob),g))),validkey(dhexp_real(key_e(alice,bob,sid_5),g))).
attacker(hash(hash(hash(hash(hash(somename,empty),empty),validkey(dhexp_real(key_s(bob),g))),validkey(dhexp_real(key_m(bob),g))),validkey(dhexp_real(key_e(alice,bob,sid_5),g)))).

20. By 19, the attacker may know hash(hash(hash(hash(hash(somename,empty),empty),validkey(dhexp_real(key_s(bob),g))),validkey(dhexp_real(key_m(bob),g))),validkey(dhexp_real(key_e(alice,bob,sid_5),g))).
By 7, the attacker may know encrypt(hmac_hash2(hmac_hash1(hash(somename,empty),dhexp_real(key_e(alice,bob,sid_5),dhexp_real(key_s(bob),g))),dhexp_real(key_e(alice,bob,sid_5),dhexp_real(key_m(bob),g))),minnonce,hash(hash(hash(hash(hash(somename,empty),empty),validkey(dhexp_real(key_s(bob),g))),validkey(dhexp_real(key_m(bob),g))),validkey(dhexp_real(key_e(alice,bob,sid_5),g))),validkey(dhexp_real(key_m(alice),g))).
Using the function hash the attacker may obtain hash(hash(hash(hash(hash(hash(somename,empty),empty),validkey(dhexp_real(key_s(bob),g))),validkey(dhexp_real(key_m(bob),g))),validkey(dhexp_real(key_e(alice,bob,sid_5),g))),encrypt(hmac_hash2(hmac_hash1(hash(somename,empty),dhexp_real(key_e(alice,bob,sid_5),dhexp_real(key_s(bob),g))),dhexp_real(key_e(alice,bob,sid_5),dhexp_real(key_m(bob),g))),minnonce,hash(hash(hash(hash(hash(somename,empty),empty),validkey(dhexp_real(key_s(bob),g))),validkey(dhexp_real(key_m(bob),g))),validkey(dhexp_real(key_e(alice,bob,sid_5),g))),validkey(dhexp_real(key_m(alice),g)))).
attacker(hash(hash(hash(hash(hash(hash(somename,empty),empty),validkey(dhexp_real(key_s(bob),g))),validkey(dhexp_real(key_m(bob),g))),validkey(dhexp_real(key_e(alice,bob,sid_5),g))),encrypt(hmac_hash2(hmac_hash1(hash(somename,empty),dhexp_real(key_e(alice,bob,sid_5),dhexp_real(key_s(bob),g))),dhexp_real(key_e(alice,bob,sid_5),dhexp_real(key_m(bob),g))),minnonce,hash(hash(hash(hash(hash(somename,empty),empty),validkey(dhexp_real(key_s(bob),g))),validkey(dhexp_real(key_m(bob),g))),validkey(dhexp_real(key_e(alice,bob,sid_5),g))),validkey(dhexp_real(key_m(alice),g))))).

21. By 20, the attacker may know hash(hash(hash(hash(hash(hash(somename,empty),empty),validkey(dhexp_real(key_s(bob),g))),validkey(dhexp_real(key_m(bob),g))),validkey(dhexp_real(key_e(alice,bob,sid_5),g))),encrypt(hmac_hash2(hmac_hash1(hash(somename,empty),dhexp_real(key_e(alice,bob,sid_5),dhexp_real(key_s(bob),g))),dhexp_real(key_e(alice,bob,sid_5),dhexp_real(key_m(bob),g))),minnonce,hash(hash(hash(hash(hash(somename,empty),empty),validkey(dhexp_real(key_s(bob),g))),validkey(dhexp_real(key_m(bob),g))),validkey(dhexp_real(key_e(alice,bob,sid_5),g))),validkey(dhexp_real(key_m(alice),g)))).
So the attacker may know hash(hash(hash(hash(hash(hash(somename,empty),empty),validkey(dhexp_real(key_s(bob),g))),validkey(dhexp_real(key_m(bob),g))),validkey(dhexp_real(key_e(alice,bob,sid_5),g))),encrypt(hmac_hash2(hmac_hash1(hash(somename,empty),dhexp_real(key_e(alice,bob,sid_5),dhexp_real(key_s(bob),g))),dhexp_real(key_e(alice,bob,sid_5),dhexp_real(key_m(bob),g))),minnonce,hash(hash(hash(hash(hash(somename,empty),empty),validkey(dhexp_real(key_s(bob),g))),validkey(dhexp_real(key_m(bob),g))),validkey(dhexp_real(key_e(alice,bob,sid_5),g))),validkey(dhexp_real(key_m(alice),g)))) in phase 1.
attacker_p1(hash(hash(hash(hash(hash(hash(somename,empty),empty),validkey(dhexp_real(key_s(bob),g))),validkey(dhexp_real(key_m(bob),g))),validkey(dhexp_real(key_e(alice,bob,sid_5),g))),encrypt(hmac_hash2(hmac_hash1(hash(somename,empty),dhexp_real(key_e(alice,bob,sid_5),dhexp_real(key_s(bob),g))),dhexp_real(key_e(alice,bob,sid_5),dhexp_real(key_m(bob),g))),minnonce,hash(hash(hash(hash(hash(somename,empty),empty),validkey(dhexp_real(key_s(bob),g))),validkey(dhexp_real(key_m(bob),g))),validkey(dhexp_real(key_e(alice,bob,sid_5),g))),validkey(dhexp_real(key_m(alice),g))))).

22. Using the function minnonce the attacker may obtain minnonce in phase 1.
attacker_p1(minnonce).

23. Using the function minnonce the attacker may obtain minnonce.
attacker(minnonce).

24. The event LeakS(phase0,bob) may be executed at {753}.
The event LeakM(phase0,bob) may be executed at {754}.
So the message (key_s(bob),key_m(bob)) may be sent on channel pub at output {755}.
mess(pub,(key_s(bob),key_m(bob))).

25. By 1, the attacker may have the channel pub.
By 24, the message (key_s(bob),key_m(bob)) may be sent on this channel.
So the attacker may obtain the message (key_s(bob),key_m(bob)) by listening on this channel.
attacker((key_s(bob),key_m(bob))).

26. By 25, the attacker may know (key_s(bob),key_m(bob)).
Using the function 2-proj-2-tuple the attacker may obtain key_m(bob).
attacker(key_m(bob)).

27. By 26, the attacker may know key_m(bob).
By 8, the attacker may know validkey(dhexp_real(key_e(alice,bob,sid_5),g)).
Using the function dhexp the attacker may obtain dhexp_real(key_e(alice,bob,sid_5),dhexp_real(key_m(bob),g)).
attacker(dhexp_real(key_e(alice,bob,sid_5),dhexp_real(key_m(bob),g))).

28. By 25, the attacker may know (key_s(bob),key_m(bob)).
Using the function 1-proj-2-tuple the attacker may obtain key_s(bob).
attacker(key_s(bob)).

29. By 28, the attacker may know key_s(bob).
By 8, the attacker may know validkey(dhexp_real(key_e(alice,bob,sid_5),g)).
Using the function dhexp the attacker may obtain dhexp_real(key_e(alice,bob,sid_5),dhexp_real(key_s(bob),g)).
attacker(dhexp_real(key_e(alice,bob,sid_5),dhexp_real(key_s(bob),g))).

30. By 15, the attacker may know hash(somename,empty).
By 29, the attacker may know dhexp_real(key_e(alice,bob,sid_5),dhexp_real(key_s(bob),g)).
Using the function hmac_hash1 the attacker may obtain hmac_hash1(hash(somename,empty),dhexp_real(key_e(alice,bob,sid_5),dhexp_real(key_s(bob),g))).
attacker(hmac_hash1(hash(somename,empty),dhexp_real(key_e(alice,bob,sid_5),dhexp_real(key_s(bob),g)))).

31. By 30, the attacker may know hmac_hash1(hash(somename,empty),dhexp_real(key_e(alice,bob,sid_5),dhexp_real(key_s(bob),g))).
By 27, the attacker may know dhexp_real(key_e(alice,bob,sid_5),dhexp_real(key_m(bob),g)).
Using the function hmac_hash2 the attacker may obtain hmac_hash2(hmac_hash1(hash(somename,empty),dhexp_real(key_e(alice,bob,sid_5),dhexp_real(key_s(bob),g))),dhexp_real(key_e(alice,bob,sid_5),dhexp_real(key_m(bob),g))).
attacker(hmac_hash2(hmac_hash1(hash(somename,empty),dhexp_real(key_e(alice,bob,sid_5),dhexp_real(key_s(bob),g))),dhexp_real(key_e(alice,bob,sid_5),dhexp_real(key_m(bob),g)))).

32. By 31, the attacker may know hmac_hash2(hmac_hash1(hash(somename,empty),dhexp_real(key_e(alice,bob,sid_5),dhexp_real(key_s(bob),g))),dhexp_real(key_e(alice,bob,sid_5),dhexp_real(key_m(bob),g))).
By 23, the attacker may know minnonce.
By 19, the attacker may know hash(hash(hash(hash(hash(somename,empty),empty),validkey(dhexp_real(key_s(bob),g))),validkey(dhexp_real(key_m(bob),g))),validkey(dhexp_real(key_e(alice,bob,sid_5),g))).
By 7, the attacker may know encrypt(hmac_hash2(hmac_hash1(hash(somename,empty),dhexp_real(key_e(alice,bob,sid_5),dhexp_real(key_s(bob),g))),dhexp_real(key_e(alice,bob,sid_5),dhexp_real(key_m(bob),g))),minnonce,hash(hash(hash(hash(hash(somename,empty),empty),validkey(dhexp_real(key_s(bob),g))),validkey(dhexp_real(key_m(bob),g))),validkey(dhexp_real(key_e(alice,bob,sid_5),g))),validkey(dhexp_real(key_m(alice),g))).
Using the function decrypt the attacker may obtain aeadpack(true,hash(hash(hash(hash(hash(somename,empty),empty),validkey(dhexp_real(key_s(bob),g))),validkey(dhexp_real(key_m(bob),g))),validkey(dhexp_real(key_e(alice,bob,sid_5),g))),validkey(dhexp_real(key_m(alice),g))).
attacker(aeadpack(true,hash(hash(hash(hash(hash(somename,empty),empty),validkey(dhexp_real(key_s(bob),g))),validkey(dhexp_real(key_m(bob),g))),validkey(dhexp_real(key_e(alice,bob,sid_5),g))),validkey(dhexp_real(key_m(alice),g)))).

33. By 32, the attacker may know aeadpack(true,hash(hash(hash(hash(hash(somename,empty),empty),validkey(dhexp_real(key_s(bob),g))),validkey(dhexp_real(key_m(bob),g))),validkey(dhexp_real(key_e(alice,bob,sid_5),g))),validkey(dhexp_real(key_m(alice),g))).
Using the function 3-proj-aeadpack the attacker may obtain validkey(dhexp_real(key_m(alice),g)).
attacker(validkey(dhexp_real(key_m(alice),g))).

34. By 28, the attacker may know key_s(bob).
By 33, the attacker may know validkey(dhexp_real(key_m(alice),g)).
Using the function dhexp the attacker may obtain dhexp_real(key_m(alice),dhexp_real(key_s(bob),g)).
attacker(dhexp_real(key_m(alice),dhexp_real(key_s(bob),g))).

35. By 30, the attacker may know hmac_hash1(hash(somename,empty),dhexp_real(key_e(alice,bob,sid_5),dhexp_real(key_s(bob),g))).
By 27, the attacker may know dhexp_real(key_e(alice,bob,sid_5),dhexp_real(key_m(bob),g)).
Using the function hmac_hash1 the attacker may obtain hmac_hash1(hmac_hash1(hash(somename,empty),dhexp_real(key_e(alice,bob,sid_5),dhexp_real(key_s(bob),g))),dhexp_real(key_e(alice,bob,sid_5),dhexp_real(key_m(bob),g))).
attacker(hmac_hash1(hmac_hash1(hash(somename,empty),dhexp_real(key_e(alice,bob,sid_5),dhexp_real(key_s(bob),g))),dhexp_real(key_e(alice,bob,sid_5),dhexp_real(key_m(bob),g)))).

36. By 35, the attacker may know hmac_hash1(hmac_hash1(hash(somename,empty),dhexp_real(key_e(alice,bob,sid_5),dhexp_real(key_s(bob),g))),dhexp_real(key_e(alice,bob,sid_5),dhexp_real(key_m(bob),g))).
By 34, the attacker may know dhexp_real(key_m(alice),dhexp_real(key_s(bob),g)).
Using the function hmac_hash2 the attacker may obtain hmac_hash2(hmac_hash1(hmac_hash1(hash(somename,empty),dhexp_real(key_e(alice,bob,sid_5),dhexp_real(key_s(bob),g))),dhexp_real(key_e(alice,bob,sid_5),dhexp_real(key_m(bob),g))),dhexp_real(key_m(alice),dhexp_real(key_s(bob),g))).
attacker(hmac_hash2(hmac_hash1(hmac_hash1(hash(somename,empty),dhexp_real(key_e(alice,bob,sid_5),dhexp_real(key_s(bob),g))),dhexp_real(key_e(alice,bob,sid_5),dhexp_real(key_m(bob),g))),dhexp_real(key_m(alice),dhexp_real(key_s(bob),g)))).

37. By 36, the attacker may know hmac_hash2(hmac_hash1(hmac_hash1(hash(somename,empty),dhexp_real(key_e(alice,bob,sid_5),dhexp_real(key_s(bob),g))),dhexp_real(key_e(alice,bob,sid_5),dhexp_real(key_m(bob),g))),dhexp_real(key_m(alice),dhexp_real(key_s(bob),g))).
So the attacker may know hmac_hash2(hmac_hash1(hmac_hash1(hash(somename,empty),dhexp_real(key_e(alice,bob,sid_5),dhexp_real(key_s(bob),g))),dhexp_real(key_e(alice,bob,sid_5),dhexp_real(key_m(bob),g))),dhexp_real(key_m(alice),dhexp_real(key_s(bob),g))) in phase 1.
attacker_p1(hmac_hash2(hmac_hash1(hmac_hash1(hash(somename,empty),dhexp_real(key_e(alice,bob,sid_5),dhexp_real(key_s(bob),g))),dhexp_real(key_e(alice,bob,sid_5),dhexp_real(key_m(bob),g))),dhexp_real(key_m(alice),dhexp_real(key_s(bob),g)))).

38. By 37, the attacker may know hmac_hash2(hmac_hash1(hmac_hash1(hash(somename,empty),dhexp_real(key_e(alice,bob,sid_5),dhexp_real(key_s(bob),g))),dhexp_real(key_e(alice,bob,sid_5),dhexp_real(key_m(bob),g))),dhexp_real(key_m(alice),dhexp_real(key_s(bob),g))) in phase 1.
By 22, the attacker may know minnonce in phase 1.
By 21, the attacker may know hash(hash(hash(hash(hash(hash(somename,empty),empty),validkey(dhexp_real(key_s(bob),g))),validkey(dhexp_real(key_m(bob),g))),validkey(dhexp_real(key_e(alice,bob,sid_5),g))),encrypt(hmac_hash2(hmac_hash1(hash(somename,empty),dhexp_real(key_e(alice,bob,sid_5),dhexp_real(key_s(bob),g))),dhexp_real(key_e(alice,bob,sid_5),dhexp_real(key_m(bob),g))),minnonce,hash(hash(hash(hash(hash(somename,empty),empty),validkey(dhexp_real(key_s(bob),g))),validkey(dhexp_real(key_m(bob),g))),validkey(dhexp_real(key_e(alice,bob,sid_5),g))),validkey(dhexp_real(key_m(alice),g)))) in phase 1.
By 6, the attacker may know encrypt(hmac_hash2(hmac_hash1(hmac_hash1(hash(somename,empty),dhexp_real(key_e(alice,bob,sid_5),dhexp_real(key_s(bob),g))),dhexp_real(key_e(alice,bob,sid_5),dhexp_real(key_m(bob),g))),dhexp_real(key_m(alice),dhexp_real(key_s(bob),g))),minnonce,hash(hash(hash(hash(hash(hash(somename,empty),empty),validkey(dhexp_real(key_s(bob),g))),validkey(dhexp_real(key_m(bob),g))),validkey(dhexp_real(key_e(alice,bob,sid_5),g))),encrypt(hmac_hash2(hmac_hash1(hash(somename,empty),dhexp_real(key_e(alice,bob,sid_5),dhexp_real(key_s(bob),g))),dhexp_real(key_e(alice,bob,sid_5),dhexp_real(key_m(bob),g))),minnonce,hash(hash(hash(hash(hash(somename,empty),empty),validkey(dhexp_real(key_s(bob),g))),validkey(dhexp_real(key_m(bob),g))),validkey(dhexp_real(key_e(alice,bob,sid_5),g))),validkey(dhexp_real(key_m(alice),g)))),msg_a(alice,bob,sid_5)) in phase 1.
Using the function decrypt the attacker may obtain aeadpack(true,hash(hash(hash(hash(hash(hash(somename,empty),empty),validkey(dhexp_real(key_s(bob),g))),validkey(dhexp_real(key_m(bob),g))),validkey(dhexp_real(key_e(alice,bob,sid_5),g))),encrypt(hmac_hash2(hmac_hash1(hash(somename,empty),dhexp_real(key_e(alice,bob,sid_5),dhexp_real(key_s(bob),g))),dhexp_real(key_e(alice,bob,sid_5),dhexp_real(key_m(bob),g))),minnonce,hash(hash(hash(hash(hash(somename,empty),empty),validkey(dhexp_real(key_s(bob),g))),validkey(dhexp_real(key_m(bob),g))),validkey(dhexp_real(key_e(alice,bob,sid_5),g))),validkey(dhexp_real(key_m(alice),g)))),msg_a(alice,bob,sid_5)) in phase 1.
attacker_p1(aeadpack(true,hash(hash(hash(hash(hash(hash(somename,empty),empty),validkey(dhexp_real(key_s(bob),g))),validkey(dhexp_real(key_m(bob),g))),validkey(dhexp_real(key_e(alice,bob,sid_5),g))),encrypt(hmac_hash2(hmac_hash1(hash(somename,empty),dhexp_real(key_e(alice,bob,sid_5),dhexp_real(key_s(bob),g))),dhexp_real(key_e(alice,bob,sid_5),dhexp_real(key_m(bob),g))),minnonce,hash(hash(hash(hash(hash(somename,empty),empty),validkey(dhexp_real(key_s(bob),g))),validkey(dhexp_real(key_m(bob),g))),validkey(dhexp_real(key_e(alice,bob,sid_5),g))),validkey(dhexp_real(key_m(alice),g)))),msg_a(alice,bob,sid_5))).

39. By 38, the attacker may know aeadpack(true,hash(hash(hash(hash(hash(hash(somename,empty),empty),validkey(dhexp_real(key_s(bob),g))),validkey(dhexp_real(key_m(bob),g))),validkey(dhexp_real(key_e(alice,bob,sid_5),g))),encrypt(hmac_hash2(hmac_hash1(hash(somename,empty),dhexp_real(key_e(alice,bob,sid_5),dhexp_real(key_s(bob),g))),dhexp_real(key_e(alice,bob,sid_5),dhexp_real(key_m(bob),g))),minnonce,hash(hash(hash(hash(hash(somename,empty),empty),validkey(dhexp_real(key_s(bob),g))),validkey(dhexp_real(key_m(bob),g))),validkey(dhexp_real(key_e(alice,bob,sid_5),g))),validkey(dhexp_real(key_m(alice),g)))),msg_a(alice,bob,sid_5)) in phase 1.
Using the function 3-proj-aeadpack the attacker may obtain msg_a(alice,bob,sid_5) in phase 1.
attacker_p1(msg_a(alice,bob,sid_5)).

40. By 39, attacker_p1(msg_a(alice,bob,sid_5)).
The goal is reached, represented in the following fact:
attacker_p1(msg_a(alice,bob,sid_5)).


RESULT not attacker_p1(msg_a(alice,bob,sid_a)) cannot be proved.
Starting query attacker_p1(msg_a(alice,bob,sid_a)) ==> event(LeakS(px,bob)) && event(LeakM(px,bob))
goal reachable: begin(LeakM(phase0,bob)) && begin(LeakS(phase0,bob)) && begin(SendMsg(alice,bob,stagepack_a(sid_5),msg_a(alice,bob,sid_5))) -> attacker_p1(msg_a(alice,bob,sid_5))
Abbreviations:
sid_5 = sid[!1 = @sid]
goal reachable: begin(LeakM(phase1,bob)) && begin(LeakS(phase1,bob)) && begin(SendMsg(alice,bob,stagepack_a(sid_5),msg_a(alice,bob,sid_5))) -> attacker_p1(msg_a(alice,bob,sid_5))
Abbreviations:
sid_5 = sid[!1 = @sid]
RESULT attacker_p1(msg_a(alice,bob,sid_a)) ==> event(LeakS(px,bob)) && event(LeakM(px,bob)) is true.
Starting query attacker_p1(msg_a(alice,bob,sid_a)) ==> (event(LeakS(phase0,bob)) && event(LeakM(phase0,bob))) || (event(LeakS(px,bob)) && event(LeakM(px,bob)) && event(LeakS(pz,alice)) && event(LeakM(pz,alice)))
goal reachable: begin(LeakM(phase1,bob)) && begin(LeakS(phase1,bob)) && begin(SendMsg(alice,bob,stagepack_a(sid_5),msg_a(alice,bob,sid_5))) -> attacker_p1(msg_a(alice,bob,sid_5))
Abbreviations:
sid_5 = sid[!1 = @sid]

Derivation:
Abbreviations:
sid_5 = sid[!1 = @sid]

1. Using the function pub the attacker may obtain pub.
attacker(pub).

2. The entry statestore(alice,bob,sid_5,statepack_a(handshakestatepack(symmetricstatepack(cipherstatepack(empty,minnonce),hash(somename,empty),hash(hash(hash(hash(somename,empty),empty),validkey(dhexp_real(key_s(bob),g))),validkey(dhexp_real(key_m(bob),g)))),keypairpack(empty,empty),keypairpack(empty,empty),keypairpack(empty,empty),validkey(dhexp_real(key_s(bob),g)),validkey(dhexp_real(key_m(bob),g)),empty,empty,true))) may be inserted in a table at insert {50}.
table(statestore(alice,bob,sid_5,statepack_a(handshakestatepack(symmetricstatepack(cipherstatepack(empty,minnonce),hash(somename,empty),hash(hash(hash(hash(somename,empty),empty),validkey(dhexp_real(key_s(bob),g))),validkey(dhexp_real(key_m(bob),g)))),keypairpack(empty,empty),keypairpack(empty,empty),keypairpack(empty,empty),validkey(dhexp_real(key_s(bob),g)),validkey(dhexp_real(key_m(bob),g)),empty,empty,true)))).

3. The entry statestore(alice,bob,sid_5,statepack_a(handshakestatepack(symmetricstatepack(cipherstatepack(empty,minnonce),hash(somename,empty),hash(hash(hash(hash(somename,empty),empty),validkey(dhexp_real(key_s(bob),g))),validkey(dhexp_real(key_m(bob),g)))),keypairpack(empty,empty),keypairpack(empty,empty),keypairpack(empty,empty),validkey(dhexp_real(key_s(bob),g)),validkey(dhexp_real(key_m(bob),g)),empty,empty,true))) that may be in a table by 2 may be read at get {244}.
The event SendMsg(alice,bob,stagepack_a(sid_5),msg_a(alice,bob,sid_5)) may be executed at {242}.
So the message concat3(validkey(dhexp_real(key_e(alice,bob,sid_5),g)),encrypt(hmac_hash2(hmac_hash1(hash(somename,empty),dhexp_real(key_e(alice,bob,sid_5),dhexp_real(key_s(bob),g))),dhexp_real(key_e(alice,bob,sid_5),dhexp_real(key_m(bob),g))),minnonce,hash(hash(hash(hash(hash(somename,empty),empty),validkey(dhexp_real(key_s(bob),g))),validkey(dhexp_real(key_m(bob),g))),validkey(dhexp_real(key_e(alice,bob,sid_5),g))),validkey(dhexp_real(key_m(alice),g))),encrypt(hmac_hash2(hmac_hash1(hmac_hash1(hash(somename,empty),dhexp_real(key_e(alice,bob,sid_5),dhexp_real(key_s(bob),g))),dhexp_real(key_e(alice,bob,sid_5),dhexp_real(key_m(bob),g))),dhexp_real(key_m(alice),dhexp_real(key_s(bob),g))),minnonce,hash(hash(hash(hash(hash(hash(somename,empty),empty),validkey(dhexp_real(key_s(bob),g))),validkey(dhexp_real(key_m(bob),g))),validkey(dhexp_real(key_e(alice,bob,sid_5),g))),encrypt(hmac_hash2(hmac_hash1(hash(somename,empty),dhexp_real(key_e(alice,bob,sid_5),dhexp_real(key_s(bob),g))),dhexp_real(key_e(alice,bob,sid_5),dhexp_real(key_m(bob),g))),minnonce,hash(hash(hash(hash(hash(somename,empty),empty),validkey(dhexp_real(key_s(bob),g))),validkey(dhexp_real(key_m(bob),g))),validkey(dhexp_real(key_e(alice,bob,sid_5),g))),validkey(dhexp_real(key_m(alice),g)))),msg_a(alice,bob,sid_5))) may be sent on channel pub at output {243}.
mess(pub,concat3(validkey(dhexp_real(key_e(alice,bob,sid_5),g)),encrypt(hmac_hash2(hmac_hash1(hash(somename,empty),dhexp_real(key_e(alice,bob,sid_5),dhexp_real(key_s(bob),g))),dhexp_real(key_e(alice,bob,sid_5),dhexp_real(key_m(bob),g))),minnonce,hash(hash(hash(hash(hash(somename,empty),empty),validkey(dhexp_real(key_s(bob),g))),validkey(dhexp_real(key_m(bob),g))),validkey(dhexp_real(key_e(alice,bob,sid_5),g))),validkey(dhexp_real(key_m(alice),g))),encrypt(hmac_hash2(hmac_hash1(hmac_hash1(hash(somename,empty),dhexp_real(key_e(alice,bob,sid_5),dhexp_real(key_s(bob),g))),dhexp_real(key_e(alice,bob,sid_5),dhexp_real(key_m(bob),g))),dhexp_real(key_m(alice),dhexp_real(key_s(bob),g))),minnonce,hash(hash(hash(hash(hash(hash(somename,empty),empty),validkey(dhexp_real(key_s(bob),g))),validkey(dhexp_real(key_m(bob),g))),validkey(dhexp_real(key_e(alice,bob,sid_5),g))),encrypt(hmac_hash2(hmac_hash1(hash(somename,empty),dhexp_real(key_e(alice,bob,sid_5),dhexp_real(key_s(bob),g))),dhexp_real(key_e(alice,bob,sid_5),dhexp_real(key_m(bob),g))),minnonce,hash(hash(hash(hash(hash(somename,empty),empty),validkey(dhexp_real(key_s(bob),g))),validkey(dhexp_real(key_m(bob),g))),validkey(dhexp_real(key_e(alice,bob,sid_5),g))),validkey(dhexp_real(key_m(alice),g)))),msg_a(alice,bob,sid_5)))).

4. By 1, the attacker may have the channel pub.
By 3, the message concat3(validkey(dhexp_real(key_e(alice,bob,sid_5),g)),encrypt(hmac_hash2(hmac_hash1(hash(somename,empty),dhexp_real(key_e(alice,bob,sid_5),dhexp_real(key_s(bob),g))),dhexp_real(key_e(alice,bob,sid_5),dhexp_real(key_m(bob),g))),minnonce,hash(hash(hash(hash(hash(somename,empty),empty),validkey(dhexp_real(key_s(bob),g))),validkey(dhexp_real(key_m(bob),g))),validkey(dhexp_real(key_e(alice,bob,sid_5),g))),validkey(dhexp_real(key_m(alice),g))),encrypt(hmac_hash2(hmac_hash1(hmac_hash1(hash(somename,empty),dhexp_real(key_e(alice,bob,sid_5),dhexp_real(key_s(bob),g))),dhexp_real(key_e(alice,bob,sid_5),dhexp_real(key_m(bob),g))),dhexp_real(key_m(alice),dhexp_real(key_s(bob),g))),minnonce,hash(hash(hash(hash(hash(hash(somename,empty),empty),validkey(dhexp_real(key_s(bob),g))),validkey(dhexp_real(key_m(bob),g))),validkey(dhexp_real(key_e(alice,bob,sid_5),g))),encrypt(hmac_hash2(hmac_hash1(hash(somename,empty),dhexp_real(key_e(alice,bob,sid_5),dhexp_real(key_s(bob),g))),dhexp_real(key_e(alice,bob,sid_5),dhexp_real(key_m(bob),g))),minnonce,hash(hash(hash(hash(hash(somename,empty),empty),validkey(dhexp_real(key_s(bob),g))),validkey(dhexp_real(key_m(bob),g))),validkey(dhexp_real(key_e(alice,bob,sid_5),g))),validkey(dhexp_real(key_m(alice),g)))),msg_a(alice,bob,sid_5))) may be sent on this channel.
So the attacker may obtain the message concat3(validkey(dhexp_real(key_e(alice,bob,sid_5),g)),encrypt(hmac_hash2(hmac_hash1(hash(somename,empty),dhexp_real(key_e(alice,bob,sid_5),dhexp_real(key_s(bob),g))),dhexp_real(key_e(alice,bob,sid_5),dhexp_real(key_m(bob),g))),minnonce,hash(hash(hash(hash(hash(somename,empty),empty),validkey(dhexp_real(key_s(bob),g))),validkey(dhexp_real(key_m(bob),g))),validkey(dhexp_real(key_e(alice,bob,sid_5),g))),validkey(dhexp_real(key_m(alice),g))),encrypt(hmac_hash2(hmac_hash1(hmac_hash1(hash(somename,empty),dhexp_real(key_e(alice,bob,sid_5),dhexp_real(key_s(bob),g))),dhexp_real(key_e(alice,bob,sid_5),dhexp_real(key_m(bob),g))),dhexp_real(key_m(alice),dhexp_real(key_s(bob),g))),minnonce,hash(hash(hash(hash(hash(hash(somename,empty),empty),validkey(dhexp_real(key_s(bob),g))),validkey(dhexp_real(key_m(bob),g))),validkey(dhexp_real(key_e(alice,bob,sid_5),g))),encrypt(hmac_hash2(hmac_hash1(hash(somename,empty),dhexp_real(key_e(alice,bob,sid_5),dhexp_real(key_s(bob),g))),dhexp_real(key_e(alice,bob,sid_5),dhexp_real(key_m(bob),g))),minnonce,hash(hash(hash(hash(hash(somename,empty),empty),validkey(dhexp_real(key_s(bob),g))),validkey(dhexp_real(key_m(bob),g))),validkey(dhexp_real(key_e(alice,bob,sid_5),g))),validkey(dhexp_real(key_m(alice),g)))),msg_a(alice,bob,sid_5))) by listening on this channel.
attacker(concat3(validkey(dhexp_real(key_e(alice,bob,sid_5),g)),encrypt(hmac_hash2(hmac_hash1(hash(somename,empty),dhexp_real(key_e(alice,bob,sid_5),dhexp_real(key_s(bob),g))),dhexp_real(key_e(alice,bob,sid_5),dhexp_real(key_m(bob),g))),minnonce,hash(hash(hash(hash(hash(somename,empty),empty),validkey(dhexp_real(key_s(bob),g))),validkey(dhexp_real(key_m(bob),g))),validkey(dhexp_real(key_e(alice,bob,sid_5),g))),validkey(dhexp_real(key_m(alice),g))),encrypt(hmac_hash2(hmac_hash1(hmac_hash1(hash(somename,empty),dhexp_real(key_e(alice,bob,sid_5),dhexp_real(key_s(bob),g))),dhexp_real(key_e(alice,bob,sid_5),dhexp_real(key_m(bob),g))),dhexp_real(key_m(alice),dhexp_real(key_s(bob),g))),minnonce,hash(hash(hash(hash(hash(hash(somename,empty),empty),validkey(dhexp_real(key_s(bob),g))),validkey(dhexp_real(key_m(bob),g))),validkey(dhexp_real(key_e(alice,bob,sid_5),g))),encrypt(hmac_hash2(hmac_hash1(hash(somename,empty),dhexp_real(key_e(alice,bob,sid_5),dhexp_real(key_s(bob),g))),dhexp_real(key_e(alice,bob,sid_5),dhexp_real(key_m(bob),g))),minnonce,hash(hash(hash(hash(hash(somename,empty),empty),validkey(dhexp_real(key_s(bob),g))),validkey(dhexp_real(key_m(bob),g))),validkey(dhexp_real(key_e(alice,bob,sid_5),g))),validkey(dhexp_real(key_m(alice),g)))),msg_a(alice,bob,sid_5)))).

5. By 4, the attacker may know concat3(validkey(dhexp_real(key_e(alice,bob,sid_5),g)),encrypt(hmac_hash2(hmac_hash1(hash(somename,empty),dhexp_real(key_e(alice,bob,sid_5),dhexp_real(key_s(bob),g))),dhexp_real(key_e(alice,bob,sid_5),dhexp_real(key_m(bob),g))),minnonce,hash(hash(hash(hash(hash(somename,empty),empty),validkey(dhexp_real(key_s(bob),g))),validkey(dhexp_real(key_m(bob),g))),validkey(dhexp_real(key_e(alice,bob,sid_5),g))),validkey(dhexp_real(key_m(alice),g))),encrypt(hmac_hash2(hmac_hash1(hmac_hash1(hash(somename,empty),dhexp_real(key_e(alice,bob,sid_5),dhexp_real(key_s(bob),g))),dhexp_real(key_e(alice,bob,sid_5),dhexp_real(key_m(bob),g))),dhexp_real(key_m(alice),dhexp_real(key_s(bob),g))),minnonce,hash(hash(hash(hash(hash(hash(somename,empty),empty),validkey(dhexp_real(key_s(bob),g))),validkey(dhexp_real(key_m(bob),g))),validkey(dhexp_real(key_e(alice,bob,sid_5),g))),encrypt(hmac_hash2(hmac_hash1(hash(somename,empty),dhexp_real(key_e(alice,bob,sid_5),dhexp_real(key_s(bob),g))),dhexp_real(key_e(alice,bob,sid_5),dhexp_real(key_m(bob),g))),minnonce,hash(hash(hash(hash(hash(somename,empty),empty),validkey(dhexp_real(key_s(bob),g))),validkey(dhexp_real(key_m(bob),g))),validkey(dhexp_real(key_e(alice,bob,sid_5),g))),validkey(dhexp_real(key_m(alice),g)))),msg_a(alice,bob,sid_5))).
Using the function 3-proj-concat3 the attacker may obtain encrypt(hmac_hash2(hmac_hash1(hmac_hash1(hash(somename,empty),dhexp_real(key_e(alice,bob,sid_5),dhexp_real(key_s(bob),g))),dhexp_real(key_e(alice,bob,sid_5),dhexp_real(key_m(bob),g))),dhexp_real(key_m(alice),dhexp_real(key_s(bob),g))),minnonce,hash(hash(hash(hash(hash(hash(somename,empty),empty),validkey(dhexp_real(key_s(bob),g))),validkey(dhexp_real(key_m(bob),g))),validkey(dhexp_real(key_e(alice,bob,sid_5),g))),encrypt(hmac_hash2(hmac_hash1(hash(somename,empty),dhexp_real(key_e(alice,bob,sid_5),dhexp_real(key_s(bob),g))),dhexp_real(key_e(alice,bob,sid_5),dhexp_real(key_m(bob),g))),minnonce,hash(hash(hash(hash(hash(somename,empty),empty),validkey(dhexp_real(key_s(bob),g))),validkey(dhexp_real(key_m(bob),g))),validkey(dhexp_real(key_e(alice,bob,sid_5),g))),validkey(dhexp_real(key_m(alice),g)))),msg_a(alice,bob,sid_5)).
attacker(encrypt(hmac_hash2(hmac_hash1(hmac_hash1(hash(somename,empty),dhexp_real(key_e(alice,bob,sid_5),dhexp_real(key_s(bob),g))),dhexp_real(key_e(alice,bob,sid_5),dhexp_real(key_m(bob),g))),dhexp_real(key_m(alice),dhexp_real(key_s(bob),g))),minnonce,hash(hash(hash(hash(hash(hash(somename,empty),empty),validkey(dhexp_real(key_s(bob),g))),validkey(dhexp_real(key_m(bob),g))),validkey(dhexp_real(key_e(alice,bob,sid_5),g))),encrypt(hmac_hash2(hmac_hash1(hash(somename,empty),dhexp_real(key_e(alice,bob,sid_5),dhexp_real(key_s(bob),g))),dhexp_real(key_e(alice,bob,sid_5),dhexp_real(key_m(bob),g))),minnonce,hash(hash(hash(hash(hash(somename,empty),empty),validkey(dhexp_real(key_s(bob),g))),validkey(dhexp_real(key_m(bob),g))),validkey(dhexp_real(key_e(alice,bob,sid_5),g))),validkey(dhexp_real(key_m(alice),g)))),msg_a(alice,bob,sid_5))).

6. By 5, the attacker may know encrypt(hmac_hash2(hmac_hash1(hmac_hash1(hash(somename,empty),dhexp_real(key_e(alice,bob,sid_5),dhexp_real(key_s(bob),g))),dhexp_real(key_e(alice,bob,sid_5),dhexp_real(key_m(bob),g))),dhexp_real(key_m(alice),dhexp_real(key_s(bob),g))),minnonce,hash(hash(hash(hash(hash(hash(somename,empty),empty),validkey(dhexp_real(key_s(bob),g))),validkey(dhexp_real(key_m(bob),g))),validkey(dhexp_real(key_e(alice,bob,sid_5),g))),encrypt(hmac_hash2(hmac_hash1(hash(somename,empty),dhexp_real(key_e(alice,bob,sid_5),dhexp_real(key_s(bob),g))),dhexp_real(key_e(alice,bob,sid_5),dhexp_real(key_m(bob),g))),minnonce,hash(hash(hash(hash(hash(somename,empty),empty),validkey(dhexp_real(key_s(bob),g))),validkey(dhexp_real(key_m(bob),g))),validkey(dhexp_real(key_e(alice,bob,sid_5),g))),validkey(dhexp_real(key_m(alice),g)))),msg_a(alice,bob,sid_5)).
So the attacker may know encrypt(hmac_hash2(hmac_hash1(hmac_hash1(hash(somename,empty),dhexp_real(key_e(alice,bob,sid_5),dhexp_real(key_s(bob),g))),dhexp_real(key_e(alice,bob,sid_5),dhexp_real(key_m(bob),g))),dhexp_real(key_m(alice),dhexp_real(key_s(bob),g))),minnonce,hash(hash(hash(hash(hash(hash(somename,empty),empty),validkey(dhexp_real(key_s(bob),g))),validkey(dhexp_real(key_m(bob),g))),validkey(dhexp_real(key_e(alice,bob,sid_5),g))),encrypt(hmac_hash2(hmac_hash1(hash(somename,empty),dhexp_real(key_e(alice,bob,sid_5),dhexp_real(key_s(bob),g))),dhexp_real(key_e(alice,bob,sid_5),dhexp_real(key_m(bob),g))),minnonce,hash(hash(hash(hash(hash(somename,empty),empty),validkey(dhexp_real(key_s(bob),g))),validkey(dhexp_real(key_m(bob),g))),validkey(dhexp_real(key_e(alice,bob,sid_5),g))),validkey(dhexp_real(key_m(alice),g)))),msg_a(alice,bob,sid_5)) in phase 1.
attacker_p1(encrypt(hmac_hash2(hmac_hash1(hmac_hash1(hash(somename,empty),dhexp_real(key_e(alice,bob,sid_5),dhexp_real(key_s(bob),g))),dhexp_real(key_e(alice,bob,sid_5),dhexp_real(key_m(bob),g))),dhexp_real(key_m(alice),dhexp_real(key_s(bob),g))),minnonce,hash(hash(hash(hash(hash(hash(somename,empty),empty),validkey(dhexp_real(key_s(bob),g))),validkey(dhexp_real(key_m(bob),g))),validkey(dhexp_real(key_e(alice,bob,sid_5),g))),encrypt(hmac_hash2(hmac_hash1(hash(somename,empty),dhexp_real(key_e(alice,bob,sid_5),dhexp_real(key_s(bob),g))),dhexp_real(key_e(alice,bob,sid_5),dhexp_real(key_m(bob),g))),minnonce,hash(hash(hash(hash(hash(somename,empty),empty),validkey(dhexp_real(key_s(bob),g))),validkey(dhexp_real(key_m(bob),g))),validkey(dhexp_real(key_e(alice,bob,sid_5),g))),validkey(dhexp_real(key_m(alice),g)))),msg_a(alice,bob,sid_5))).

7. By 4, the attacker may know concat3(validkey(dhexp_real(key_e(alice,bob,sid_5),g)),encrypt(hmac_hash2(hmac_hash1(hash(somename,empty),dhexp_real(key_e(alice,bob,sid_5),dhexp_real(key_s(bob),g))),dhexp_real(key_e(alice,bob,sid_5),dhexp_real(key_m(bob),g))),minnonce,hash(hash(hash(hash(hash(somename,empty),empty),validkey(dhexp_real(key_s(bob),g))),validkey(dhexp_real(key_m(bob),g))),validkey(dhexp_real(key_e(alice,bob,sid_5),g))),validkey(dhexp_real(key_m(alice),g))),encrypt(hmac_hash2(hmac_hash1(hmac_hash1(hash(somename,empty),dhexp_real(key_e(alice,bob,sid_5),dhexp_real(key_s(bob),g))),dhexp_real(key_e(alice,bob,sid_5),dhexp_real(key_m(bob),g))),dhexp_real(key_m(alice),dhexp_real(key_s(bob),g))),minnonce,hash(hash(hash(hash(hash(hash(somename,empty),empty),validkey(dhexp_real(key_s(bob),g))),validkey(dhexp_real(key_m(bob),g))),validkey(dhexp_real(key_e(alice,bob,sid_5),g))),encrypt(hmac_hash2(hmac_hash1(hash(somename,empty),dhexp_real(key_e(alice,bob,sid_5),dhexp_real(key_s(bob),g))),dhexp_real(key_e(alice,bob,sid_5),dhexp_real(key_m(bob),g))),minnonce,hash(hash(hash(hash(hash(somename,empty),empty),validkey(dhexp_real(key_s(bob),g))),validkey(dhexp_real(key_m(bob),g))),validkey(dhexp_real(key_e(alice,bob,sid_5),g))),validkey(dhexp_real(key_m(alice),g)))),msg_a(alice,bob,sid_5))).
Using the function 2-proj-concat3 the attacker may obtain encrypt(hmac_hash2(hmac_hash1(hash(somename,empty),dhexp_real(key_e(alice,bob,sid_5),dhexp_real(key_s(bob),g))),dhexp_real(key_e(alice,bob,sid_5),dhexp_real(key_m(bob),g))),minnonce,hash(hash(hash(hash(hash(somename,empty),empty),validkey(dhexp_real(key_s(bob),g))),validkey(dhexp_real(key_m(bob),g))),validkey(dhexp_real(key_e(alice,bob,sid_5),g))),validkey(dhexp_real(key_m(alice),g))).
attacker(encrypt(hmac_hash2(hmac_hash1(hash(somename,empty),dhexp_real(key_e(alice,bob,sid_5),dhexp_real(key_s(bob),g))),dhexp_real(key_e(alice,bob,sid_5),dhexp_real(key_m(bob),g))),minnonce,hash(hash(hash(hash(hash(somename,empty),empty),validkey(dhexp_real(key_s(bob),g))),validkey(dhexp_real(key_m(bob),g))),validkey(dhexp_real(key_e(alice,bob,sid_5),g))),validkey(dhexp_real(key_m(alice),g)))).

8. By 4, the attacker may know concat3(validkey(dhexp_real(key_e(alice,bob,sid_5),g)),encrypt(hmac_hash2(hmac_hash1(hash(somename,empty),dhexp_real(key_e(alice,bob,sid_5),dhexp_real(key_s(bob),g))),dhexp_real(key_e(alice,bob,sid_5),dhexp_real(key_m(bob),g))),minnonce,hash(hash(hash(hash(hash(somename,empty),empty),validkey(dhexp_real(key_s(bob),g))),validkey(dhexp_real(key_m(bob),g))),validkey(dhexp_real(key_e(alice,bob,sid_5),g))),validkey(dhexp_real(key_m(alice),g))),encrypt(hmac_hash2(hmac_hash1(hmac_hash1(hash(somename,empty),dhexp_real(key_e(alice,bob,sid_5),dhexp_real(key_s(bob),g))),dhexp_real(key_e(alice,bob,sid_5),dhexp_real(key_m(bob),g))),dhexp_real(key_m(alice),dhexp_real(key_s(bob),g))),minnonce,hash(hash(hash(hash(hash(hash(somename,empty),empty),validkey(dhexp_real(key_s(bob),g))),validkey(dhexp_real(key_m(bob),g))),validkey(dhexp_real(key_e(alice,bob,sid_5),g))),encrypt(hmac_hash2(hmac_hash1(hash(somename,empty),dhexp_real(key_e(alice,bob,sid_5),dhexp_real(key_s(bob),g))),dhexp_real(key_e(alice,bob,sid_5),dhexp_real(key_m(bob),g))),minnonce,hash(hash(hash(hash(hash(somename,empty),empty),validkey(dhexp_real(key_s(bob),g))),validkey(dhexp_real(key_m(bob),g))),validkey(dhexp_real(key_e(alice,bob,sid_5),g))),validkey(dhexp_real(key_m(alice),g)))),msg_a(alice,bob,sid_5))).
Using the function 1-proj-concat3 the attacker may obtain validkey(dhexp_real(key_e(alice,bob,sid_5),g)).
attacker(validkey(dhexp_real(key_e(alice,bob,sid_5),g))).

9. The message (validkey(dhexp_real(key_s(bob),g)),validkey(dhexp_real(key_m(bob),g))) may be sent on channel pub at output {511}.
mess(pub,(validkey(dhexp_real(key_s(bob),g)),validkey(dhexp_real(key_m(bob),g)))).

10. By 1, the attacker may have the channel pub.
By 9, the message (validkey(dhexp_real(key_s(bob),g)),validkey(dhexp_real(key_m(bob),g))) may be sent on this channel.
So the attacker may obtain the message (validkey(dhexp_real(key_s(bob),g)),validkey(dhexp_real(key_m(bob),g))) by listening on this channel.
attacker((validkey(dhexp_real(key_s(bob),g)),validkey(dhexp_real(key_m(bob),g)))).

11. By 10, the attacker may know (validkey(dhexp_real(key_s(bob),g)),validkey(dhexp_real(key_m(bob),g))).
Using the function 2-proj-2-tuple the attacker may obtain validkey(dhexp_real(key_m(bob),g)).
attacker(validkey(dhexp_real(key_m(bob),g))).

12. By 10, the attacker may know (validkey(dhexp_real(key_s(bob),g)),validkey(dhexp_real(key_m(bob),g))).
Using the function 1-proj-2-tuple the attacker may obtain validkey(dhexp_real(key_s(bob),g)).
attacker(validkey(dhexp_real(key_s(bob),g))).

13. Using the function empty the attacker may obtain empty.
attacker(empty).

14. Using the function somename the attacker may obtain somename.
attacker(somename).

15. By 14, the attacker may know somename.
By 13, the attacker may know empty.
Using the function hash the attacker may obtain hash(somename,empty).
attacker(hash(somename,empty)).

16. By 15, the attacker may know hash(somename,empty).
By 13, the attacker may know empty.
Using the function hash the attacker may obtain hash(hash(somename,empty),empty).
attacker(hash(hash(somename,empty),empty)).

17. By 16, the attacker may know hash(hash(somename,empty),empty).
By 12, the attacker may know validkey(dhexp_real(key_s(bob),g)).
Using the function hash the attacker may obtain hash(hash(hash(somename,empty),empty),validkey(dhexp_real(key_s(bob),g))).
attacker(hash(hash(hash(somename,empty),empty),validkey(dhexp_real(key_s(bob),g)))).

18. By 17, the attacker may know hash(hash(hash(somename,empty),empty),validkey(dhexp_real(key_s(bob),g))).
By 11, the attacker may know validkey(dhexp_real(key_m(bob),g)).
Using the function hash the attacker may obtain hash(hash(hash(hash(somename,empty),empty),validkey(dhexp_real(key_s(bob),g))),validkey(dhexp_real(key_m(bob),g))).
attacker(hash(hash(hash(hash(somename,empty),empty),validkey(dhexp_real(key_s(bob),g))),validkey(dhexp_real(key_m(bob),g)))).

19. By 18, the attacker may know hash(hash(hash(hash(somename,empty),empty),validkey(dhexp_real(key_s(bob),g))),validkey(dhexp_real(key_m(bob),g))).
By 8, the attacker may know validkey(dhexp_real(key_e(alice,bob,sid_5),g)).
Using the function hash the attacker may obtain hash(hash(hash(hash(hash(somename,empty),empty),validkey(dhexp_real(key_s(bob),g))),validkey(dhexp_real(key_m(bob),g))),validkey(dhexp_real(key_e(alice,bob,sid_5),g))).
attacker(hash(hash(hash(hash(hash(somename,empty),empty),validkey(dhexp_real(key_s(bob),g))),validkey(dhexp_real(key_m(bob),g))),validkey(dhexp_real(key_e(alice,bob,sid_5),g)))).

20. By 19, the attacker may know hash(hash(hash(hash(hash(somename,empty),empty),validkey(dhexp_real(key_s(bob),g))),validkey(dhexp_real(key_m(bob),g))),validkey(dhexp_real(key_e(alice,bob,sid_5),g))).
By 7, the attacker may know encrypt(hmac_hash2(hmac_hash1(hash(somename,empty),dhexp_real(key_e(alice,bob,sid_5),dhexp_real(key_s(bob),g))),dhexp_real(key_e(alice,bob,sid_5),dhexp_real(key_m(bob),g))),minnonce,hash(hash(hash(hash(hash(somename,empty),empty),validkey(dhexp_real(key_s(bob),g))),validkey(dhexp_real(key_m(bob),g))),validkey(dhexp_real(key_e(alice,bob,sid_5),g))),validkey(dhexp_real(key_m(alice),g))).
Using the function hash the attacker may obtain hash(hash(hash(hash(hash(hash(somename,empty),empty),validkey(dhexp_real(key_s(bob),g))),validkey(dhexp_real(key_m(bob),g))),validkey(dhexp_real(key_e(alice,bob,sid_5),g))),encrypt(hmac_hash2(hmac_hash1(hash(somename,empty),dhexp_real(key_e(alice,bob,sid_5),dhexp_real(key_s(bob),g))),dhexp_real(key_e(alice,bob,sid_5),dhexp_real(key_m(bob),g))),minnonce,hash(hash(hash(hash(hash(somename,empty),empty),validkey(dhexp_real(key_s(bob),g))),validkey(dhexp_real(key_m(bob),g))),validkey(dhexp_real(key_e(alice,bob,sid_5),g))),validkey(dhexp_real(key_m(alice),g)))).
attacker(hash(hash(hash(hash(hash(hash(somename,empty),empty),validkey(dhexp_real(key_s(bob),g))),validkey(dhexp_real(key_m(bob),g))),validkey(dhexp_real(key_e(alice,bob,sid_5),g))),encrypt(hmac_hash2(hmac_hash1(hash(somename,empty),dhexp_real(key_e(alice,bob,sid_5),dhexp_real(key_s(bob),g))),dhexp_real(key_e(alice,bob,sid_5),dhexp_real(key_m(bob),g))),minnonce,hash(hash(hash(hash(hash(somename,empty),empty),validkey(dhexp_real(key_s(bob),g))),validkey(dhexp_real(key_m(bob),g))),validkey(dhexp_real(key_e(alice,bob,sid_5),g))),validkey(dhexp_real(key_m(alice),g))))).

21. By 20, the attacker may know hash(hash(hash(hash(hash(hash(somename,empty),empty),validkey(dhexp_real(key_s(bob),g))),validkey(dhexp_real(key_m(bob),g))),validkey(dhexp_real(key_e(alice,bob,sid_5),g))),encrypt(hmac_hash2(hmac_hash1(hash(somename,empty),dhexp_real(key_e(alice,bob,sid_5),dhexp_real(key_s(bob),g))),dhexp_real(key_e(alice,bob,sid_5),dhexp_real(key_m(bob),g))),minnonce,hash(hash(hash(hash(hash(somename,empty),empty),validkey(dhexp_real(key_s(bob),g))),validkey(dhexp_real(key_m(bob),g))),validkey(dhexp_real(key_e(alice,bob,sid_5),g))),validkey(dhexp_real(key_m(alice),g)))).
So the attacker may know hash(hash(hash(hash(hash(hash(somename,empty),empty),validkey(dhexp_real(key_s(bob),g))),validkey(dhexp_real(key_m(bob),g))),validkey(dhexp_real(key_e(alice,bob,sid_5),g))),encrypt(hmac_hash2(hmac_hash1(hash(somename,empty),dhexp_real(key_e(alice,bob,sid_5),dhexp_real(key_s(bob),g))),dhexp_real(key_e(alice,bob,sid_5),dhexp_real(key_m(bob),g))),minnonce,hash(hash(hash(hash(hash(somename,empty),empty),validkey(dhexp_real(key_s(bob),g))),validkey(dhexp_real(key_m(bob),g))),validkey(dhexp_real(key_e(alice,bob,sid_5),g))),validkey(dhexp_real(key_m(alice),g)))) in phase 1.
attacker_p1(hash(hash(hash(hash(hash(hash(somename,empty),empty),validkey(dhexp_real(key_s(bob),g))),validkey(dhexp_real(key_m(bob),g))),validkey(dhexp_real(key_e(alice,bob,sid_5),g))),encrypt(hmac_hash2(hmac_hash1(hash(somename,empty),dhexp_real(key_e(alice,bob,sid_5),dhexp_real(key_s(bob),g))),dhexp_real(key_e(alice,bob,sid_5),dhexp_real(key_m(bob),g))),minnonce,hash(hash(hash(hash(hash(somename,empty),empty),validkey(dhexp_real(key_s(bob),g))),validkey(dhexp_real(key_m(bob),g))),validkey(dhexp_real(key_e(alice,bob,sid_5),g))),validkey(dhexp_real(key_m(alice),g))))).

22. Using the function minnonce the attacker may obtain minnonce in phase 1.
attacker_p1(minnonce).

23. By 7, the attacker may know encrypt(hmac_hash2(hmac_hash1(hash(somename,empty),dhexp_real(key_e(alice,bob,sid_5),dhexp_real(key_s(bob),g))),dhexp_real(key_e(alice,bob,sid_5),dhexp_real(key_m(bob),g))),minnonce,hash(hash(hash(hash(hash(somename,empty),empty),validkey(dhexp_real(key_s(bob),g))),validkey(dhexp_real(key_m(bob),g))),validkey(dhexp_real(key_e(alice,bob,sid_5),g))),validkey(dhexp_real(key_m(alice),g))).
So the attacker may know encrypt(hmac_hash2(hmac_hash1(hash(somename,empty),dhexp_real(key_e(alice,bob,sid_5),dhexp_real(key_s(bob),g))),dhexp_real(key_e(alice,bob,sid_5),dhexp_real(key_m(bob),g))),minnonce,hash(hash(hash(hash(hash(somename,empty),empty),validkey(dhexp_real(key_s(bob),g))),validkey(dhexp_real(key_m(bob),g))),validkey(dhexp_real(key_e(alice,bob,sid_5),g))),validkey(dhexp_real(key_m(alice),g))) in phase 1.
attacker_p1(encrypt(hmac_hash2(hmac_hash1(hash(somename,empty),dhexp_real(key_e(alice,bob,sid_5),dhexp_real(key_s(bob),g))),dhexp_real(key_e(alice,bob,sid_5),dhexp_real(key_m(bob),g))),minnonce,hash(hash(hash(hash(hash(somename,empty),empty),validkey(dhexp_real(key_s(bob),g))),validkey(dhexp_real(key_m(bob),g))),validkey(dhexp_real(key_e(alice,bob,sid_5),g))),validkey(dhexp_real(key_m(alice),g)))).

24. By 19, the attacker may know hash(hash(hash(hash(hash(somename,empty),empty),validkey(dhexp_real(key_s(bob),g))),validkey(dhexp_real(key_m(bob),g))),validkey(dhexp_real(key_e(alice,bob,sid_5),g))).
So the attacker may know hash(hash(hash(hash(hash(somename,empty),empty),validkey(dhexp_real(key_s(bob),g))),validkey(dhexp_real(key_m(bob),g))),validkey(dhexp_real(key_e(alice,bob,sid_5),g))) in phase 1.
attacker_p1(hash(hash(hash(hash(hash(somename,empty),empty),validkey(dhexp_real(key_s(bob),g))),validkey(dhexp_real(key_m(bob),g))),validkey(dhexp_real(key_e(alice,bob,sid_5),g)))).

25. By 8, the attacker may know validkey(dhexp_real(key_e(alice,bob,sid_5),g)).
So the attacker may know validkey(dhexp_real(key_e(alice,bob,sid_5),g)) in phase 1.
attacker_p1(validkey(dhexp_real(key_e(alice,bob,sid_5),g))).

26. Using the function pub the attacker may obtain pub in phase 1.
attacker_p1(pub).

27. The event LeakS(phase1,bob) may be executed at {757}.
The event LeakM(phase1,bob) may be executed at {758}.
So the message (key_s(bob),key_m(bob)) may be sent on channel pub in phase 1 at output {759}.
mess_p1(pub,(key_s(bob),key_m(bob))).

28. By 26, the attacker may have the channel pub in phase 1.
By 27, the message (key_s(bob),key_m(bob)) in phase 1 may be sent on this channel.
So the attacker may obtain the message (key_s(bob),key_m(bob)) in phase 1 by listening on this channel.
attacker_p1((key_s(bob),key_m(bob))).

29. By 28, the attacker may know (key_s(bob),key_m(bob)) in phase 1.
Using the function 2-proj-2-tuple the attacker may obtain key_m(bob) in phase 1.
attacker_p1(key_m(bob)).

30. By 29, the attacker may know key_m(bob) in phase 1.
By 25, the attacker may know validkey(dhexp_real(key_e(alice,bob,sid_5),g)) in phase 1.
Using the function dhexp the attacker may obtain dhexp_real(key_e(alice,bob,sid_5),dhexp_real(key_m(bob),g)) in phase 1.
attacker_p1(dhexp_real(key_e(alice,bob,sid_5),dhexp_real(key_m(bob),g))).

31. By 28, the attacker may know (key_s(bob),key_m(bob)) in phase 1.
Using the function 1-proj-2-tuple the attacker may obtain key_s(bob) in phase 1.
attacker_p1(key_s(bob)).

32. By 31, the attacker may know key_s(bob) in phase 1.
By 25, the attacker may know validkey(dhexp_real(key_e(alice,bob,sid_5),g)) in phase 1.
Using the function dhexp the attacker may obtain dhexp_real(key_e(alice,bob,sid_5),dhexp_real(key_s(bob),g)) in phase 1.
attacker_p1(dhexp_real(key_e(alice,bob,sid_5),dhexp_real(key_s(bob),g))).

33. Using the function empty the attacker may obtain empty in phase 1.
attacker_p1(empty).

34. Using the function somename the attacker may obtain somename in phase 1.
attacker_p1(somename).

35. By 34, the attacker may know somename in phase 1.
By 33, the attacker may know empty in phase 1.
Using the function hash the attacker may obtain hash(somename,empty) in phase 1.
attacker_p1(hash(somename,empty)).

36. By 35, the attacker may know hash(somename,empty) in phase 1.
By 32, the attacker may know dhexp_real(key_e(alice,bob,sid_5),dhexp_real(key_s(bob),g)) in phase 1.
Using the function hmac_hash1 the attacker may obtain hmac_hash1(hash(somename,empty),dhexp_real(key_e(alice,bob,sid_5),dhexp_real(key_s(bob),g))) in phase 1.
attacker_p1(hmac_hash1(hash(somename,empty),dhexp_real(key_e(alice,bob,sid_5),dhexp_real(key_s(bob),g)))).

37. By 36, the attacker may know hmac_hash1(hash(somename,empty),dhexp_real(key_e(alice,bob,sid_5),dhexp_real(key_s(bob),g))) in phase 1.
By 30, the attacker may know dhexp_real(key_e(alice,bob,sid_5),dhexp_real(key_m(bob),g)) in phase 1.
Using the function hmac_hash2 the attacker may obtain hmac_hash2(hmac_hash1(hash(somename,empty),dhexp_real(key_e(alice,bob,sid_5),dhexp_real(key_s(bob),g))),dhexp_real(key_e(alice,bob,sid_5),dhexp_real(key_m(bob),g))) in phase 1.
attacker_p1(hmac_hash2(hmac_hash1(hash(somename,empty),dhexp_real(key_e(alice,bob,sid_5),dhexp_real(key_s(bob),g))),dhexp_real(key_e(alice,bob,sid_5),dhexp_real(key_m(bob),g)))).

38. By 37, the attacker may know hmac_hash2(hmac_hash1(hash(somename,empty),dhexp_real(key_e(alice,bob,sid_5),dhexp_real(key_s(bob),g))),dhexp_real(key_e(alice,bob,sid_5),dhexp_real(key_m(bob),g))) in phase 1.
By 22, the attacker may know minnonce in phase 1.
By 24, the attacker may know hash(hash(hash(hash(hash(somename,empty),empty),validkey(dhexp_real(key_s(bob),g))),validkey(dhexp_real(key_m(bob),g))),validkey(dhexp_real(key_e(alice,bob,sid_5),g))) in phase 1.
By 23, the attacker may know encrypt(hmac_hash2(hmac_hash1(hash(somename,empty),dhexp_real(key_e(alice,bob,sid_5),dhexp_real(key_s(bob),g))),dhexp_real(key_e(alice,bob,sid_5),dhexp_real(key_m(bob),g))),minnonce,hash(hash(hash(hash(hash(somename,empty),empty),validkey(dhexp_real(key_s(bob),g))),validkey(dhexp_real(key_m(bob),g))),validkey(dhexp_real(key_e(alice,bob,sid_5),g))),validkey(dhexp_real(key_m(alice),g))) in phase 1.
Using the function decrypt the attacker may obtain aeadpack(true,hash(hash(hash(hash(hash(somename,empty),empty),validkey(dhexp_real(key_s(bob),g))),validkey(dhexp_real(key_m(bob),g))),validkey(dhexp_real(key_e(alice,bob,sid_5),g))),validkey(dhexp_real(key_m(alice),g))) in phase 1.
attacker_p1(aeadpack(true,hash(hash(hash(hash(hash(somename,empty),empty),validkey(dhexp_real(key_s(bob),g))),validkey(dhexp_real(key_m(bob),g))),validkey(dhexp_real(key_e(alice,bob,sid_5),g))),validkey(dhexp_real(key_m(alice),g)))).

39. By 38, the attacker may know aeadpack(true,hash(hash(hash(hash(hash(somename,empty),empty),validkey(dhexp_real(key_s(bob),g))),validkey(dhexp_real(key_m(bob),g))),validkey(dhexp_real(key_e(alice,bob,sid_5),g))),validkey(dhexp_real(key_m(alice),g))) in phase 1.
Using the function 3-proj-aeadpack the attacker may obtain validkey(dhexp_real(key_m(alice),g)) in phase 1.
attacker_p1(validkey(dhexp_real(key_m(alice),g))).

40. By 31, the attacker may know key_s(bob) in phase 1.
By 39, the attacker may know validkey(dhexp_real(key_m(alice),g)) in phase 1.
Using the function dhexp the attacker may obtain dhexp_real(key_m(alice),dhexp_real(key_s(bob),g)) in phase 1.
attacker_p1(dhexp_real(key_m(alice),dhexp_real(key_s(bob),g))).

41. By 36, the attacker may know hmac_hash1(hash(somename,empty),dhexp_real(key_e(alice,bob,sid_5),dhexp_real(key_s(bob),g))) in phase 1.
By 30, the attacker may know dhexp_real(key_e(alice,bob,sid_5),dhexp_real(key_m(bob),g)) in phase 1.
Using the function hmac_hash1 the attacker may obtain hmac_hash1(hmac_hash1(hash(somename,empty),dhexp_real(key_e(alice,bob,sid_5),dhexp_real(key_s(bob),g))),dhexp_real(key_e(alice,bob,sid_5),dhexp_real(key_m(bob),g))) in phase 1.
attacker_p1(hmac_hash1(hmac_hash1(hash(somename,empty),dhexp_real(key_e(alice,bob,sid_5),dhexp_real(key_s(bob),g))),dhexp_real(key_e(alice,bob,sid_5),dhexp_real(key_m(bob),g)))).

42. By 41, the attacker may know hmac_hash1(hmac_hash1(hash(somename,empty),dhexp_real(key_e(alice,bob,sid_5),dhexp_real(key_s(bob),g))),dhexp_real(key_e(alice,bob,sid_5),dhexp_real(key_m(bob),g))) in phase 1.
By 40, the attacker may know dhexp_real(key_m(alice),dhexp_real(key_s(bob),g)) in phase 1.
Using the function hmac_hash2 the attacker may obtain hmac_hash2(hmac_hash1(hmac_hash1(hash(somename,empty),dhexp_real(key_e(alice,bob,sid_5),dhexp_real(key_s(bob),g))),dhexp_real(key_e(alice,bob,sid_5),dhexp_real(key_m(bob),g))),dhexp_real(key_m(alice),dhexp_real(key_s(bob),g))) in phase 1.
attacker_p1(hmac_hash2(hmac_hash1(hmac_hash1(hash(somename,empty),dhexp_real(key_e(alice,bob,sid_5),dhexp_real(key_s(bob),g))),dhexp_real(key_e(alice,bob,sid_5),dhexp_real(key_m(bob),g))),dhexp_real(key_m(alice),dhexp_real(key_s(bob),g)))).

43. By 42, the attacker may know hmac_hash2(hmac_hash1(hmac_hash1(hash(somename,empty),dhexp_real(key_e(alice,bob,sid_5),dhexp_real(key_s(bob),g))),dhexp_real(key_e(alice,bob,sid_5),dhexp_real(key_m(bob),g))),dhexp_real(key_m(alice),dhexp_real(key_s(bob),g))) in phase 1.
By 22, the attacker may know minnonce in phase 1.
By 21, the attacker may know hash(hash(hash(hash(hash(hash(somename,empty),empty),validkey(dhexp_real(key_s(bob),g))),validkey(dhexp_real(key_m(bob),g))),validkey(dhexp_real(key_e(alice,bob,sid_5),g))),encrypt(hmac_hash2(hmac_hash1(hash(somename,empty),dhexp_real(key_e(alice,bob,sid_5),dhexp_real(key_s(bob),g))),dhexp_real(key_e(alice,bob,sid_5),dhexp_real(key_m(bob),g))),minnonce,hash(hash(hash(hash(hash(somename,empty),empty),validkey(dhexp_real(key_s(bob),g))),validkey(dhexp_real(key_m(bob),g))),validkey(dhexp_real(key_e(alice,bob,sid_5),g))),validkey(dhexp_real(key_m(alice),g)))) in phase 1.
By 6, the attacker may know encrypt(hmac_hash2(hmac_hash1(hmac_hash1(hash(somename,empty),dhexp_real(key_e(alice,bob,sid_5),dhexp_real(key_s(bob),g))),dhexp_real(key_e(alice,bob,sid_5),dhexp_real(key_m(bob),g))),dhexp_real(key_m(alice),dhexp_real(key_s(bob),g))),minnonce,hash(hash(hash(hash(hash(hash(somename,empty),empty),validkey(dhexp_real(key_s(bob),g))),validkey(dhexp_real(key_m(bob),g))),validkey(dhexp_real(key_e(alice,bob,sid_5),g))),encrypt(hmac_hash2(hmac_hash1(hash(somename,empty),dhexp_real(key_e(alice,bob,sid_5),dhexp_real(key_s(bob),g))),dhexp_real(key_e(alice,bob,sid_5),dhexp_real(key_m(bob),g))),minnonce,hash(hash(hash(hash(hash(somename,empty),empty),validkey(dhexp_real(key_s(bob),g))),validkey(dhexp_real(key_m(bob),g))),validkey(dhexp_real(key_e(alice,bob,sid_5),g))),validkey(dhexp_real(key_m(alice),g)))),msg_a(alice,bob,sid_5)) in phase 1.
Using the function decrypt the attacker may obtain aeadpack(true,hash(hash(hash(hash(hash(hash(somename,empty),empty),validkey(dhexp_real(key_s(bob),g))),validkey(dhexp_real(key_m(bob),g))),validkey(dhexp_real(key_e(alice,bob,sid_5),g))),encrypt(hmac_hash2(hmac_hash1(hash(somename,empty),dhexp_real(key_e(alice,bob,sid_5),dhexp_real(key_s(bob),g))),dhexp_real(key_e(alice,bob,sid_5),dhexp_real(key_m(bob),g))),minnonce,hash(hash(hash(hash(hash(somename,empty),empty),validkey(dhexp_real(key_s(bob),g))),validkey(dhexp_real(key_m(bob),g))),validkey(dhexp_real(key_e(alice,bob,sid_5),g))),validkey(dhexp_real(key_m(alice),g)))),msg_a(alice,bob,sid_5)) in phase 1.
attacker_p1(aeadpack(true,hash(hash(hash(hash(hash(hash(somename,empty),empty),validkey(dhexp_real(key_s(bob),g))),validkey(dhexp_real(key_m(bob),g))),validkey(dhexp_real(key_e(alice,bob,sid_5),g))),encrypt(hmac_hash2(hmac_hash1(hash(somename,empty),dhexp_real(key_e(alice,bob,sid_5),dhexp_real(key_s(bob),g))),dhexp_real(key_e(alice,bob,sid_5),dhexp_real(key_m(bob),g))),minnonce,hash(hash(hash(hash(hash(somename,empty),empty),validkey(dhexp_real(key_s(bob),g))),validkey(dhexp_real(key_m(bob),g))),validkey(dhexp_real(key_e(alice,bob,sid_5),g))),validkey(dhexp_real(key_m(alice),g)))),msg_a(alice,bob,sid_5))).

44. By 43, the attacker may know aeadpack(true,hash(hash(hash(hash(hash(hash(somename,empty),empty),validkey(dhexp_real(key_s(bob),g))),validkey(dhexp_real(key_m(bob),g))),validkey(dhexp_real(key_e(alice,bob,sid_5),g))),encrypt(hmac_hash2(hmac_hash1(hash(somename,empty),dhexp_real(key_e(alice,bob,sid_5),dhexp_real(key_s(bob),g))),dhexp_real(key_e(alice,bob,sid_5),dhexp_real(key_m(bob),g))),minnonce,hash(hash(hash(hash(hash(somename,empty),empty),validkey(dhexp_real(key_s(bob),g))),validkey(dhexp_real(key_m(bob),g))),validkey(dhexp_real(key_e(alice,bob,sid_5),g))),validkey(dhexp_real(key_m(alice),g)))),msg_a(alice,bob,sid_5)) in phase 1.
Using the function 3-proj-aeadpack the attacker may obtain msg_a(alice,bob,sid_5) in phase 1.
attacker_p1(msg_a(alice,bob,sid_5)).

45. By 44, attacker_p1(msg_a(alice,bob,sid_5)).
The goal is reached, represented in the following fact:
attacker_p1(msg_a(alice,bob,sid_5)).


RESULT attacker_p1(msg_a(alice,bob,sid_a)) ==> (event(LeakS(phase0,bob)) && event(LeakM(phase0,bob))) || (event(LeakS(px,bob)) && event(LeakM(px,bob)) && event(LeakS(pz,alice)) && event(LeakM(pz,alice))) cannot be proved.
Starting query attacker_p1(msg_a(alice,bob,sid_a)) ==> event(LeakS(phase0,bob)) && event(LeakM(phase0,bob))
goal reachable: begin(LeakM(phase1,bob)) && begin(LeakS(phase1,bob)) && begin(SendMsg(alice,bob,stagepack_a(sid_5),msg_a(alice,bob,sid_5))) -> attacker_p1(msg_a(alice,bob,sid_5))
Abbreviations:
sid_5 = sid[!1 = @sid]

Derivation:
Abbreviations:
sid_5 = sid[!1 = @sid]

1. Using the function pub the attacker may obtain pub.
attacker(pub).

2. The entry statestore(alice,bob,sid_5,statepack_a(handshakestatepack(symmetricstatepack(cipherstatepack(empty,minnonce),hash(somename,empty),hash(hash(hash(hash(somename,empty),empty),validkey(dhexp_real(key_s(bob),g))),validkey(dhexp_real(key_m(bob),g)))),keypairpack(empty,empty),keypairpack(empty,empty),keypairpack(empty,empty),validkey(dhexp_real(key_s(bob),g)),validkey(dhexp_real(key_m(bob),g)),empty,empty,true))) may be inserted in a table at insert {50}.
table(statestore(alice,bob,sid_5,statepack_a(handshakestatepack(symmetricstatepack(cipherstatepack(empty,minnonce),hash(somename,empty),hash(hash(hash(hash(somename,empty),empty),validkey(dhexp_real(key_s(bob),g))),validkey(dhexp_real(key_m(bob),g)))),keypairpack(empty,empty),keypairpack(empty,empty),keypairpack(empty,empty),validkey(dhexp_real(key_s(bob),g)),validkey(dhexp_real(key_m(bob),g)),empty,empty,true)))).

3. The entry statestore(alice,bob,sid_5,statepack_a(handshakestatepack(symmetricstatepack(cipherstatepack(empty,minnonce),hash(somename,empty),hash(hash(hash(hash(somename,empty),empty),validkey(dhexp_real(key_s(bob),g))),validkey(dhexp_real(key_m(bob),g)))),keypairpack(empty,empty),keypairpack(empty,empty),keypairpack(empty,empty),validkey(dhexp_real(key_s(bob),g)),validkey(dhexp_real(key_m(bob),g)),empty,empty,true))) that may be in a table by 2 may be read at get {244}.
The event SendMsg(alice,bob,stagepack_a(sid_5),msg_a(alice,bob,sid_5)) may be executed at {242}.
So the message concat3(validkey(dhexp_real(key_e(alice,bob,sid_5),g)),encrypt(hmac_hash2(hmac_hash1(hash(somename,empty),dhexp_real(key_e(alice,bob,sid_5),dhexp_real(key_s(bob),g))),dhexp_real(key_e(alice,bob,sid_5),dhexp_real(key_m(bob),g))),minnonce,hash(hash(hash(hash(hash(somename,empty),empty),validkey(dhexp_real(key_s(bob),g))),validkey(dhexp_real(key_m(bob),g))),validkey(dhexp_real(key_e(alice,bob,sid_5),g))),validkey(dhexp_real(key_m(alice),g))),encrypt(hmac_hash2(hmac_hash1(hmac_hash1(hash(somename,empty),dhexp_real(key_e(alice,bob,sid_5),dhexp_real(key_s(bob),g))),dhexp_real(key_e(alice,bob,sid_5),dhexp_real(key_m(bob),g))),dhexp_real(key_m(alice),dhexp_real(key_s(bob),g))),minnonce,hash(hash(hash(hash(hash(hash(somename,empty),empty),validkey(dhexp_real(key_s(bob),g))),validkey(dhexp_real(key_m(bob),g))),validkey(dhexp_real(key_e(alice,bob,sid_5),g))),encrypt(hmac_hash2(hmac_hash1(hash(somename,empty),dhexp_real(key_e(alice,bob,sid_5),dhexp_real(key_s(bob),g))),dhexp_real(key_e(alice,bob,sid_5),dhexp_real(key_m(bob),g))),minnonce,hash(hash(hash(hash(hash(somename,empty),empty),validkey(dhexp_real(key_s(bob),g))),validkey(dhexp_real(key_m(bob),g))),validkey(dhexp_real(key_e(alice,bob,sid_5),g))),validkey(dhexp_real(key_m(alice),g)))),msg_a(alice,bob,sid_5))) may be sent on channel pub at output {243}.
mess(pub,concat3(validkey(dhexp_real(key_e(alice,bob,sid_5),g)),encrypt(hmac_hash2(hmac_hash1(hash(somename,empty),dhexp_real(key_e(alice,bob,sid_5),dhexp_real(key_s(bob),g))),dhexp_real(key_e(alice,bob,sid_5),dhexp_real(key_m(bob),g))),minnonce,hash(hash(hash(hash(hash(somename,empty),empty),validkey(dhexp_real(key_s(bob),g))),validkey(dhexp_real(key_m(bob),g))),validkey(dhexp_real(key_e(alice,bob,sid_5),g))),validkey(dhexp_real(key_m(alice),g))),encrypt(hmac_hash2(hmac_hash1(hmac_hash1(hash(somename,empty),dhexp_real(key_e(alice,bob,sid_5),dhexp_real(key_s(bob),g))),dhexp_real(key_e(alice,bob,sid_5),dhexp_real(key_m(bob),g))),dhexp_real(key_m(alice),dhexp_real(key_s(bob),g))),minnonce,hash(hash(hash(hash(hash(hash(somename,empty),empty),validkey(dhexp_real(key_s(bob),g))),validkey(dhexp_real(key_m(bob),g))),validkey(dhexp_real(key_e(alice,bob,sid_5),g))),encrypt(hmac_hash2(hmac_hash1(hash(somename,empty),dhexp_real(key_e(alice,bob,sid_5),dhexp_real(key_s(bob),g))),dhexp_real(key_e(alice,bob,sid_5),dhexp_real(key_m(bob),g))),minnonce,hash(hash(hash(hash(hash(somename,empty),empty),validkey(dhexp_real(key_s(bob),g))),validkey(dhexp_real(key_m(bob),g))),validkey(dhexp_real(key_e(alice,bob,sid_5),g))),validkey(dhexp_real(key_m(alice),g)))),msg_a(alice,bob,sid_5)))).

4. By 1, the attacker may have the channel pub.
By 3, the message concat3(validkey(dhexp_real(key_e(alice,bob,sid_5),g)),encrypt(hmac_hash2(hmac_hash1(hash(somename,empty),dhexp_real(key_e(alice,bob,sid_5),dhexp_real(key_s(bob),g))),dhexp_real(key_e(alice,bob,sid_5),dhexp_real(key_m(bob),g))),minnonce,hash(hash(hash(hash(hash(somename,empty),empty),validkey(dhexp_real(key_s(bob),g))),validkey(dhexp_real(key_m(bob),g))),validkey(dhexp_real(key_e(alice,bob,sid_5),g))),validkey(dhexp_real(key_m(alice),g))),encrypt(hmac_hash2(hmac_hash1(hmac_hash1(hash(somename,empty),dhexp_real(key_e(alice,bob,sid_5),dhexp_real(key_s(bob),g))),dhexp_real(key_e(alice,bob,sid_5),dhexp_real(key_m(bob),g))),dhexp_real(key_m(alice),dhexp_real(key_s(bob),g))),minnonce,hash(hash(hash(hash(hash(hash(somename,empty),empty),validkey(dhexp_real(key_s(bob),g))),validkey(dhexp_real(key_m(bob),g))),validkey(dhexp_real(key_e(alice,bob,sid_5),g))),encrypt(hmac_hash2(hmac_hash1(hash(somename,empty),dhexp_real(key_e(alice,bob,sid_5),dhexp_real(key_s(bob),g))),dhexp_real(key_e(alice,bob,sid_5),dhexp_real(key_m(bob),g))),minnonce,hash(hash(hash(hash(hash(somename,empty),empty),validkey(dhexp_real(key_s(bob),g))),validkey(dhexp_real(key_m(bob),g))),validkey(dhexp_real(key_e(alice,bob,sid_5),g))),validkey(dhexp_real(key_m(alice),g)))),msg_a(alice,bob,sid_5))) may be sent on this channel.
So the attacker may obtain the message concat3(validkey(dhexp_real(key_e(alice,bob,sid_5),g)),encrypt(hmac_hash2(hmac_hash1(hash(somename,empty),dhexp_real(key_e(alice,bob,sid_5),dhexp_real(key_s(bob),g))),dhexp_real(key_e(alice,bob,sid_5),dhexp_real(key_m(bob),g))),minnonce,hash(hash(hash(hash(hash(somename,empty),empty),validkey(dhexp_real(key_s(bob),g))),validkey(dhexp_real(key_m(bob),g))),validkey(dhexp_real(key_e(alice,bob,sid_5),g))),validkey(dhexp_real(key_m(alice),g))),encrypt(hmac_hash2(hmac_hash1(hmac_hash1(hash(somename,empty),dhexp_real(key_e(alice,bob,sid_5),dhexp_real(key_s(bob),g))),dhexp_real(key_e(alice,bob,sid_5),dhexp_real(key_m(bob),g))),dhexp_real(key_m(alice),dhexp_real(key_s(bob),g))),minnonce,hash(hash(hash(hash(hash(hash(somename,empty),empty),validkey(dhexp_real(key_s(bob),g))),validkey(dhexp_real(key_m(bob),g))),validkey(dhexp_real(key_e(alice,bob,sid_5),g))),encrypt(hmac_hash2(hmac_hash1(hash(somename,empty),dhexp_real(key_e(alice,bob,sid_5),dhexp_real(key_s(bob),g))),dhexp_real(key_e(alice,bob,sid_5),dhexp_real(key_m(bob),g))),minnonce,hash(hash(hash(hash(hash(somename,empty),empty),validkey(dhexp_real(key_s(bob),g))),validkey(dhexp_real(key_m(bob),g))),validkey(dhexp_real(key_e(alice,bob,sid_5),g))),validkey(dhexp_real(key_m(alice),g)))),msg_a(alice,bob,sid_5))) by listening on this channel.
attacker(concat3(validkey(dhexp_real(key_e(alice,bob,sid_5),g)),encrypt(hmac_hash2(hmac_hash1(hash(somename,empty),dhexp_real(key_e(alice,bob,sid_5),dhexp_real(key_s(bob),g))),dhexp_real(key_e(alice,bob,sid_5),dhexp_real(key_m(bob),g))),minnonce,hash(hash(hash(hash(hash(somename,empty),empty),validkey(dhexp_real(key_s(bob),g))),validkey(dhexp_real(key_m(bob),g))),validkey(dhexp_real(key_e(alice,bob,sid_5),g))),validkey(dhexp_real(key_m(alice),g))),encrypt(hmac_hash2(hmac_hash1(hmac_hash1(hash(somename,empty),dhexp_real(key_e(alice,bob,sid_5),dhexp_real(key_s(bob),g))),dhexp_real(key_e(alice,bob,sid_5),dhexp_real(key_m(bob),g))),dhexp_real(key_m(alice),dhexp_real(key_s(bob),g))),minnonce,hash(hash(hash(hash(hash(hash(somename,empty),empty),validkey(dhexp_real(key_s(bob),g))),validkey(dhexp_real(key_m(bob),g))),validkey(dhexp_real(key_e(alice,bob,sid_5),g))),encrypt(hmac_hash2(hmac_hash1(hash(somename,empty),dhexp_real(key_e(alice,bob,sid_5),dhexp_real(key_s(bob),g))),dhexp_real(key_e(alice,bob,sid_5),dhexp_real(key_m(bob),g))),minnonce,hash(hash(hash(hash(hash(somename,empty),empty),validkey(dhexp_real(key_s(bob),g))),validkey(dhexp_real(key_m(bob),g))),validkey(dhexp_real(key_e(alice,bob,sid_5),g))),validkey(dhexp_real(key_m(alice),g)))),msg_a(alice,bob,sid_5)))).

5. By 4, the attacker may know concat3(validkey(dhexp_real(key_e(alice,bob,sid_5),g)),encrypt(hmac_hash2(hmac_hash1(hash(somename,empty),dhexp_real(key_e(alice,bob,sid_5),dhexp_real(key_s(bob),g))),dhexp_real(key_e(alice,bob,sid_5),dhexp_real(key_m(bob),g))),minnonce,hash(hash(hash(hash(hash(somename,empty),empty),validkey(dhexp_real(key_s(bob),g))),validkey(dhexp_real(key_m(bob),g))),validkey(dhexp_real(key_e(alice,bob,sid_5),g))),validkey(dhexp_real(key_m(alice),g))),encrypt(hmac_hash2(hmac_hash1(hmac_hash1(hash(somename,empty),dhexp_real(key_e(alice,bob,sid_5),dhexp_real(key_s(bob),g))),dhexp_real(key_e(alice,bob,sid_5),dhexp_real(key_m(bob),g))),dhexp_real(key_m(alice),dhexp_real(key_s(bob),g))),minnonce,hash(hash(hash(hash(hash(hash(somename,empty),empty),validkey(dhexp_real(key_s(bob),g))),validkey(dhexp_real(key_m(bob),g))),validkey(dhexp_real(key_e(alice,bob,sid_5),g))),encrypt(hmac_hash2(hmac_hash1(hash(somename,empty),dhexp_real(key_e(alice,bob,sid_5),dhexp_real(key_s(bob),g))),dhexp_real(key_e(alice,bob,sid_5),dhexp_real(key_m(bob),g))),minnonce,hash(hash(hash(hash(hash(somename,empty),empty),validkey(dhexp_real(key_s(bob),g))),validkey(dhexp_real(key_m(bob),g))),validkey(dhexp_real(key_e(alice,bob,sid_5),g))),validkey(dhexp_real(key_m(alice),g)))),msg_a(alice,bob,sid_5))).
Using the function 3-proj-concat3 the attacker may obtain encrypt(hmac_hash2(hmac_hash1(hmac_hash1(hash(somename,empty),dhexp_real(key_e(alice,bob,sid_5),dhexp_real(key_s(bob),g))),dhexp_real(key_e(alice,bob,sid_5),dhexp_real(key_m(bob),g))),dhexp_real(key_m(alice),dhexp_real(key_s(bob),g))),minnonce,hash(hash(hash(hash(hash(hash(somename,empty),empty),validkey(dhexp_real(key_s(bob),g))),validkey(dhexp_real(key_m(bob),g))),validkey(dhexp_real(key_e(alice,bob,sid_5),g))),encrypt(hmac_hash2(hmac_hash1(hash(somename,empty),dhexp_real(key_e(alice,bob,sid_5),dhexp_real(key_s(bob),g))),dhexp_real(key_e(alice,bob,sid_5),dhexp_real(key_m(bob),g))),minnonce,hash(hash(hash(hash(hash(somename,empty),empty),validkey(dhexp_real(key_s(bob),g))),validkey(dhexp_real(key_m(bob),g))),validkey(dhexp_real(key_e(alice,bob,sid_5),g))),validkey(dhexp_real(key_m(alice),g)))),msg_a(alice,bob,sid_5)).
attacker(encrypt(hmac_hash2(hmac_hash1(hmac_hash1(hash(somename,empty),dhexp_real(key_e(alice,bob,sid_5),dhexp_real(key_s(bob),g))),dhexp_real(key_e(alice,bob,sid_5),dhexp_real(key_m(bob),g))),dhexp_real(key_m(alice),dhexp_real(key_s(bob),g))),minnonce,hash(hash(hash(hash(hash(hash(somename,empty),empty),validkey(dhexp_real(key_s(bob),g))),validkey(dhexp_real(key_m(bob),g))),validkey(dhexp_real(key_e(alice,bob,sid_5),g))),encrypt(hmac_hash2(hmac_hash1(hash(somename,empty),dhexp_real(key_e(alice,bob,sid_5),dhexp_real(key_s(bob),g))),dhexp_real(key_e(alice,bob,sid_5),dhexp_real(key_m(bob),g))),minnonce,hash(hash(hash(hash(hash(somename,empty),empty),validkey(dhexp_real(key_s(bob),g))),validkey(dhexp_real(key_m(bob),g))),validkey(dhexp_real(key_e(alice,bob,sid_5),g))),validkey(dhexp_real(key_m(alice),g)))),msg_a(alice,bob,sid_5))).

6. By 5, the attacker may know encrypt(hmac_hash2(hmac_hash1(hmac_hash1(hash(somename,empty),dhexp_real(key_e(alice,bob,sid_5),dhexp_real(key_s(bob),g))),dhexp_real(key_e(alice,bob,sid_5),dhexp_real(key_m(bob),g))),dhexp_real(key_m(alice),dhexp_real(key_s(bob),g))),minnonce,hash(hash(hash(hash(hash(hash(somename,empty),empty),validkey(dhexp_real(key_s(bob),g))),validkey(dhexp_real(key_m(bob),g))),validkey(dhexp_real(key_e(alice,bob,sid_5),g))),encrypt(hmac_hash2(hmac_hash1(hash(somename,empty),dhexp_real(key_e(alice,bob,sid_5),dhexp_real(key_s(bob),g))),dhexp_real(key_e(alice,bob,sid_5),dhexp_real(key_m(bob),g))),minnonce,hash(hash(hash(hash(hash(somename,empty),empty),validkey(dhexp_real(key_s(bob),g))),validkey(dhexp_real(key_m(bob),g))),validkey(dhexp_real(key_e(alice,bob,sid_5),g))),validkey(dhexp_real(key_m(alice),g)))),msg_a(alice,bob,sid_5)).
So the attacker may know encrypt(hmac_hash2(hmac_hash1(hmac_hash1(hash(somename,empty),dhexp_real(key_e(alice,bob,sid_5),dhexp_real(key_s(bob),g))),dhexp_real(key_e(alice,bob,sid_5),dhexp_real(key_m(bob),g))),dhexp_real(key_m(alice),dhexp_real(key_s(bob),g))),minnonce,hash(hash(hash(hash(hash(hash(somename,empty),empty),validkey(dhexp_real(key_s(bob),g))),validkey(dhexp_real(key_m(bob),g))),validkey(dhexp_real(key_e(alice,bob,sid_5),g))),encrypt(hmac_hash2(hmac_hash1(hash(somename,empty),dhexp_real(key_e(alice,bob,sid_5),dhexp_real(key_s(bob),g))),dhexp_real(key_e(alice,bob,sid_5),dhexp_real(key_m(bob),g))),minnonce,hash(hash(hash(hash(hash(somename,empty),empty),validkey(dhexp_real(key_s(bob),g))),validkey(dhexp_real(key_m(bob),g))),validkey(dhexp_real(key_e(alice,bob,sid_5),g))),validkey(dhexp_real(key_m(alice),g)))),msg_a(alice,bob,sid_5)) in phase 1.
attacker_p1(encrypt(hmac_hash2(hmac_hash1(hmac_hash1(hash(somename,empty),dhexp_real(key_e(alice,bob,sid_5),dhexp_real(key_s(bob),g))),dhexp_real(key_e(alice,bob,sid_5),dhexp_real(key_m(bob),g))),dhexp_real(key_m(alice),dhexp_real(key_s(bob),g))),minnonce,hash(hash(hash(hash(hash(hash(somename,empty),empty),validkey(dhexp_real(key_s(bob),g))),validkey(dhexp_real(key_m(bob),g))),validkey(dhexp_real(key_e(alice,bob,sid_5),g))),encrypt(hmac_hash2(hmac_hash1(hash(somename,empty),dhexp_real(key_e(alice,bob,sid_5),dhexp_real(key_s(bob),g))),dhexp_real(key_e(alice,bob,sid_5),dhexp_real(key_m(bob),g))),minnonce,hash(hash(hash(hash(hash(somename,empty),empty),validkey(dhexp_real(key_s(bob),g))),validkey(dhexp_real(key_m(bob),g))),validkey(dhexp_real(key_e(alice,bob,sid_5),g))),validkey(dhexp_real(key_m(alice),g)))),msg_a(alice,bob,sid_5))).

7. By 4, the attacker may know concat3(validkey(dhexp_real(key_e(alice,bob,sid_5),g)),encrypt(hmac_hash2(hmac_hash1(hash(somename,empty),dhexp_real(key_e(alice,bob,sid_5),dhexp_real(key_s(bob),g))),dhexp_real(key_e(alice,bob,sid_5),dhexp_real(key_m(bob),g))),minnonce,hash(hash(hash(hash(hash(somename,empty),empty),validkey(dhexp_real(key_s(bob),g))),validkey(dhexp_real(key_m(bob),g))),validkey(dhexp_real(key_e(alice,bob,sid_5),g))),validkey(dhexp_real(key_m(alice),g))),encrypt(hmac_hash2(hmac_hash1(hmac_hash1(hash(somename,empty),dhexp_real(key_e(alice,bob,sid_5),dhexp_real(key_s(bob),g))),dhexp_real(key_e(alice,bob,sid_5),dhexp_real(key_m(bob),g))),dhexp_real(key_m(alice),dhexp_real(key_s(bob),g))),minnonce,hash(hash(hash(hash(hash(hash(somename,empty),empty),validkey(dhexp_real(key_s(bob),g))),validkey(dhexp_real(key_m(bob),g))),validkey(dhexp_real(key_e(alice,bob,sid_5),g))),encrypt(hmac_hash2(hmac_hash1(hash(somename,empty),dhexp_real(key_e(alice,bob,sid_5),dhexp_real(key_s(bob),g))),dhexp_real(key_e(alice,bob,sid_5),dhexp_real(key_m(bob),g))),minnonce,hash(hash(hash(hash(hash(somename,empty),empty),validkey(dhexp_real(key_s(bob),g))),validkey(dhexp_real(key_m(bob),g))),validkey(dhexp_real(key_e(alice,bob,sid_5),g))),validkey(dhexp_real(key_m(alice),g)))),msg_a(alice,bob,sid_5))).
Using the function 2-proj-concat3 the attacker may obtain encrypt(hmac_hash2(hmac_hash1(hash(somename,empty),dhexp_real(key_e(alice,bob,sid_5),dhexp_real(key_s(bob),g))),dhexp_real(key_e(alice,bob,sid_5),dhexp_real(key_m(bob),g))),minnonce,hash(hash(hash(hash(hash(somename,empty),empty),validkey(dhexp_real(key_s(bob),g))),validkey(dhexp_real(key_m(bob),g))),validkey(dhexp_real(key_e(alice,bob,sid_5),g))),validkey(dhexp_real(key_m(alice),g))).
attacker(encrypt(hmac_hash2(hmac_hash1(hash(somename,empty),dhexp_real(key_e(alice,bob,sid_5),dhexp_real(key_s(bob),g))),dhexp_real(key_e(alice,bob,sid_5),dhexp_real(key_m(bob),g))),minnonce,hash(hash(hash(hash(hash(somename,empty),empty),validkey(dhexp_real(key_s(bob),g))),validkey(dhexp_real(key_m(bob),g))),validkey(dhexp_real(key_e(alice,bob,sid_5),g))),validkey(dhexp_real(key_m(alice),g)))).

8. By 4, the attacker may know concat3(validkey(dhexp_real(key_e(alice,bob,sid_5),g)),encrypt(hmac_hash2(hmac_hash1(hash(somename,empty),dhexp_real(key_e(alice,bob,sid_5),dhexp_real(key_s(bob),g))),dhexp_real(key_e(alice,bob,sid_5),dhexp_real(key_m(bob),g))),minnonce,hash(hash(hash(hash(hash(somename,empty),empty),validkey(dhexp_real(key_s(bob),g))),validkey(dhexp_real(key_m(bob),g))),validkey(dhexp_real(key_e(alice,bob,sid_5),g))),validkey(dhexp_real(key_m(alice),g))),encrypt(hmac_hash2(hmac_hash1(hmac_hash1(hash(somename,empty),dhexp_real(key_e(alice,bob,sid_5),dhexp_real(key_s(bob),g))),dhexp_real(key_e(alice,bob,sid_5),dhexp_real(key_m(bob),g))),dhexp_real(key_m(alice),dhexp_real(key_s(bob),g))),minnonce,hash(hash(hash(hash(hash(hash(somename,empty),empty),validkey(dhexp_real(key_s(bob),g))),validkey(dhexp_real(key_m(bob),g))),validkey(dhexp_real(key_e(alice,bob,sid_5),g))),encrypt(hmac_hash2(hmac_hash1(hash(somename,empty),dhexp_real(key_e(alice,bob,sid_5),dhexp_real(key_s(bob),g))),dhexp_real(key_e(alice,bob,sid_5),dhexp_real(key_m(bob),g))),minnonce,hash(hash(hash(hash(hash(somename,empty),empty),validkey(dhexp_real(key_s(bob),g))),validkey(dhexp_real(key_m(bob),g))),validkey(dhexp_real(key_e(alice,bob,sid_5),g))),validkey(dhexp_real(key_m(alice),g)))),msg_a(alice,bob,sid_5))).
Using the function 1-proj-concat3 the attacker may obtain validkey(dhexp_real(key_e(alice,bob,sid_5),g)).
attacker(validkey(dhexp_real(key_e(alice,bob,sid_5),g))).

9. The message (validkey(dhexp_real(key_s(bob),g)),validkey(dhexp_real(key_m(bob),g))) may be sent on channel pub at output {511}.
mess(pub,(validkey(dhexp_real(key_s(bob),g)),validkey(dhexp_real(key_m(bob),g)))).

10. By 1, the attacker may have the channel pub.
By 9, the message (validkey(dhexp_real(key_s(bob),g)),validkey(dhexp_real(key_m(bob),g))) may be sent on this channel.
So the attacker may obtain the message (validkey(dhexp_real(key_s(bob),g)),validkey(dhexp_real(key_m(bob),g))) by listening on this channel.
attacker((validkey(dhexp_real(key_s(bob),g)),validkey(dhexp_real(key_m(bob),g)))).

11. By 10, the attacker may know (validkey(dhexp_real(key_s(bob),g)),validkey(dhexp_real(key_m(bob),g))).
Using the function 2-proj-2-tuple the attacker may obtain validkey(dhexp_real(key_m(bob),g)).
attacker(validkey(dhexp_real(key_m(bob),g))).

12. By 10, the attacker may know (validkey(dhexp_real(key_s(bob),g)),validkey(dhexp_real(key_m(bob),g))).
Using the function 1-proj-2-tuple the attacker may obtain validkey(dhexp_real(key_s(bob),g)).
attacker(validkey(dhexp_real(key_s(bob),g))).

13. Using the function empty the attacker may obtain empty.
attacker(empty).

14. Using the function somename the attacker may obtain somename.
attacker(somename).

15. By 14, the attacker may know somename.
By 13, the attacker may know empty.
Using the function hash the attacker may obtain hash(somename,empty).
attacker(hash(somename,empty)).

16. By 15, the attacker may know hash(somename,empty).
By 13, the attacker may know empty.
Using the function hash the attacker may obtain hash(hash(somename,empty),empty).
attacker(hash(hash(somename,empty),empty)).

17. By 16, the attacker may know hash(hash(somename,empty),empty).
By 12, the attacker may know validkey(dhexp_real(key_s(bob),g)).
Using the function hash the attacker may obtain hash(hash(hash(somename,empty),empty),validkey(dhexp_real(key_s(bob),g))).
attacker(hash(hash(hash(somename,empty),empty),validkey(dhexp_real(key_s(bob),g)))).

18. By 17, the attacker may know hash(hash(hash(somename,empty),empty),validkey(dhexp_real(key_s(bob),g))).
By 11, the attacker may know validkey(dhexp_real(key_m(bob),g)).
Using the function hash the attacker may obtain hash(hash(hash(hash(somename,empty),empty),validkey(dhexp_real(key_s(bob),g))),validkey(dhexp_real(key_m(bob),g))).
attacker(hash(hash(hash(hash(somename,empty),empty),validkey(dhexp_real(key_s(bob),g))),validkey(dhexp_real(key_m(bob),g)))).

19. By 18, the attacker may know hash(hash(hash(hash(somename,empty),empty),validkey(dhexp_real(key_s(bob),g))),validkey(dhexp_real(key_m(bob),g))).
By 8, the attacker may know validkey(dhexp_real(key_e(alice,bob,sid_5),g)).
Using the function hash the attacker may obtain hash(hash(hash(hash(hash(somename,empty),empty),validkey(dhexp_real(key_s(bob),g))),validkey(dhexp_real(key_m(bob),g))),validkey(dhexp_real(key_e(alice,bob,sid_5),g))).
attacker(hash(hash(hash(hash(hash(somename,empty),empty),validkey(dhexp_real(key_s(bob),g))),validkey(dhexp_real(key_m(bob),g))),validkey(dhexp_real(key_e(alice,bob,sid_5),g)))).

20. By 19, the attacker may know hash(hash(hash(hash(hash(somename,empty),empty),validkey(dhexp_real(key_s(bob),g))),validkey(dhexp_real(key_m(bob),g))),validkey(dhexp_real(key_e(alice,bob,sid_5),g))).
By 7, the attacker may know encrypt(hmac_hash2(hmac_hash1(hash(somename,empty),dhexp_real(key_e(alice,bob,sid_5),dhexp_real(key_s(bob),g))),dhexp_real(key_e(alice,bob,sid_5),dhexp_real(key_m(bob),g))),minnonce,hash(hash(hash(hash(hash(somename,empty),empty),validkey(dhexp_real(key_s(bob),g))),validkey(dhexp_real(key_m(bob),g))),validkey(dhexp_real(key_e(alice,bob,sid_5),g))),validkey(dhexp_real(key_m(alice),g))).
Using the function hash the attacker may obtain hash(hash(hash(hash(hash(hash(somename,empty),empty),validkey(dhexp_real(key_s(bob),g))),validkey(dhexp_real(key_m(bob),g))),validkey(dhexp_real(key_e(alice,bob,sid_5),g))),encrypt(hmac_hash2(hmac_hash1(hash(somename,empty),dhexp_real(key_e(alice,bob,sid_5),dhexp_real(key_s(bob),g))),dhexp_real(key_e(alice,bob,sid_5),dhexp_real(key_m(bob),g))),minnonce,hash(hash(hash(hash(hash(somename,empty),empty),validkey(dhexp_real(key_s(bob),g))),validkey(dhexp_real(key_m(bob),g))),validkey(dhexp_real(key_e(alice,bob,sid_5),g))),validkey(dhexp_real(key_m(alice),g)))).
attacker(hash(hash(hash(hash(hash(hash(somename,empty),empty),validkey(dhexp_real(key_s(bob),g))),validkey(dhexp_real(key_m(bob),g))),validkey(dhexp_real(key_e(alice,bob,sid_5),g))),encrypt(hmac_hash2(hmac_hash1(hash(somename,empty),dhexp_real(key_e(alice,bob,sid_5),dhexp_real(key_s(bob),g))),dhexp_real(key_e(alice,bob,sid_5),dhexp_real(key_m(bob),g))),minnonce,hash(hash(hash(hash(hash(somename,empty),empty),validkey(dhexp_real(key_s(bob),g))),validkey(dhexp_real(key_m(bob),g))),validkey(dhexp_real(key_e(alice,bob,sid_5),g))),validkey(dhexp_real(key_m(alice),g))))).

21. By 20, the attacker may know hash(hash(hash(hash(hash(hash(somename,empty),empty),validkey(dhexp_real(key_s(bob),g))),validkey(dhexp_real(key_m(bob),g))),validkey(dhexp_real(key_e(alice,bob,sid_5),g))),encrypt(hmac_hash2(hmac_hash1(hash(somename,empty),dhexp_real(key_e(alice,bob,sid_5),dhexp_real(key_s(bob),g))),dhexp_real(key_e(alice,bob,sid_5),dhexp_real(key_m(bob),g))),minnonce,hash(hash(hash(hash(hash(somename,empty),empty),validkey(dhexp_real(key_s(bob),g))),validkey(dhexp_real(key_m(bob),g))),validkey(dhexp_real(key_e(alice,bob,sid_5),g))),validkey(dhexp_real(key_m(alice),g)))).
So the attacker may know hash(hash(hash(hash(hash(hash(somename,empty),empty),validkey(dhexp_real(key_s(bob),g))),validkey(dhexp_real(key_m(bob),g))),validkey(dhexp_real(key_e(alice,bob,sid_5),g))),encrypt(hmac_hash2(hmac_hash1(hash(somename,empty),dhexp_real(key_e(alice,bob,sid_5),dhexp_real(key_s(bob),g))),dhexp_real(key_e(alice,bob,sid_5),dhexp_real(key_m(bob),g))),minnonce,hash(hash(hash(hash(hash(somename,empty),empty),validkey(dhexp_real(key_s(bob),g))),validkey(dhexp_real(key_m(bob),g))),validkey(dhexp_real(key_e(alice,bob,sid_5),g))),validkey(dhexp_real(key_m(alice),g)))) in phase 1.
attacker_p1(hash(hash(hash(hash(hash(hash(somename,empty),empty),validkey(dhexp_real(key_s(bob),g))),validkey(dhexp_real(key_m(bob),g))),validkey(dhexp_real(key_e(alice,bob,sid_5),g))),encrypt(hmac_hash2(hmac_hash1(hash(somename,empty),dhexp_real(key_e(alice,bob,sid_5),dhexp_real(key_s(bob),g))),dhexp_real(key_e(alice,bob,sid_5),dhexp_real(key_m(bob),g))),minnonce,hash(hash(hash(hash(hash(somename,empty),empty),validkey(dhexp_real(key_s(bob),g))),validkey(dhexp_real(key_m(bob),g))),validkey(dhexp_real(key_e(alice,bob,sid_5),g))),validkey(dhexp_real(key_m(alice),g))))).

22. Using the function minnonce the attacker may obtain minnonce in phase 1.
attacker_p1(minnonce).

23. By 7, the attacker may know encrypt(hmac_hash2(hmac_hash1(hash(somename,empty),dhexp_real(key_e(alice,bob,sid_5),dhexp_real(key_s(bob),g))),dhexp_real(key_e(alice,bob,sid_5),dhexp_real(key_m(bob),g))),minnonce,hash(hash(hash(hash(hash(somename,empty),empty),validkey(dhexp_real(key_s(bob),g))),validkey(dhexp_real(key_m(bob),g))),validkey(dhexp_real(key_e(alice,bob,sid_5),g))),validkey(dhexp_real(key_m(alice),g))).
So the attacker may know encrypt(hmac_hash2(hmac_hash1(hash(somename,empty),dhexp_real(key_e(alice,bob,sid_5),dhexp_real(key_s(bob),g))),dhexp_real(key_e(alice,bob,sid_5),dhexp_real(key_m(bob),g))),minnonce,hash(hash(hash(hash(hash(somename,empty),empty),validkey(dhexp_real(key_s(bob),g))),validkey(dhexp_real(key_m(bob),g))),validkey(dhexp_real(key_e(alice,bob,sid_5),g))),validkey(dhexp_real(key_m(alice),g))) in phase 1.
attacker_p1(encrypt(hmac_hash2(hmac_hash1(hash(somename,empty),dhexp_real(key_e(alice,bob,sid_5),dhexp_real(key_s(bob),g))),dhexp_real(key_e(alice,bob,sid_5),dhexp_real(key_m(bob),g))),minnonce,hash(hash(hash(hash(hash(somename,empty),empty),validkey(dhexp_real(key_s(bob),g))),validkey(dhexp_real(key_m(bob),g))),validkey(dhexp_real(key_e(alice,bob,sid_5),g))),validkey(dhexp_real(key_m(alice),g)))).

24. By 19, the attacker may know hash(hash(hash(hash(hash(somename,empty),empty),validkey(dhexp_real(key_s(bob),g))),validkey(dhexp_real(key_m(bob),g))),validkey(dhexp_real(key_e(alice,bob,sid_5),g))).
So the attacker may know hash(hash(hash(hash(hash(somename,empty),empty),validkey(dhexp_real(key_s(bob),g))),validkey(dhexp_real(key_m(bob),g))),validkey(dhexp_real(key_e(alice,bob,sid_5),g))) in phase 1.
attacker_p1(hash(hash(hash(hash(hash(somename,empty),empty),validkey(dhexp_real(key_s(bob),g))),validkey(dhexp_real(key_m(bob),g))),validkey(dhexp_real(key_e(alice,bob,sid_5),g)))).

25. By 8, the attacker may know validkey(dhexp_real(key_e(alice,bob,sid_5),g)).
So the attacker may know validkey(dhexp_real(key_e(alice,bob,sid_5),g)) in phase 1.
attacker_p1(validkey(dhexp_real(key_e(alice,bob,sid_5),g))).

26. Using the function pub the attacker may obtain pub in phase 1.
attacker_p1(pub).

27. The event LeakS(phase1,bob) may be executed at {757}.
The event LeakM(phase1,bob) may be executed at {758}.
So the message (key_s(bob),key_m(bob)) may be sent on channel pub in phase 1 at output {759}.
mess_p1(pub,(key_s(bob),key_m(bob))).

28. By 26, the attacker may have the channel pub in phase 1.
By 27, the message (key_s(bob),key_m(bob)) in phase 1 may be sent on this channel.
So the attacker may obtain the message (key_s(bob),key_m(bob)) in phase 1 by listening on this channel.
attacker_p1((key_s(bob),key_m(bob))).

29. By 28, the attacker may know (key_s(bob),key_m(bob)) in phase 1.
Using the function 2-proj-2-tuple the attacker may obtain key_m(bob) in phase 1.
attacker_p1(key_m(bob)).

30. By 29, the attacker may know key_m(bob) in phase 1.
By 25, the attacker may know validkey(dhexp_real(key_e(alice,bob,sid_5),g)) in phase 1.
Using the function dhexp the attacker may obtain dhexp_real(key_e(alice,bob,sid_5),dhexp_real(key_m(bob),g)) in phase 1.
attacker_p1(dhexp_real(key_e(alice,bob,sid_5),dhexp_real(key_m(bob),g))).

31. By 28, the attacker may know (key_s(bob),key_m(bob)) in phase 1.
Using the function 1-proj-2-tuple the attacker may obtain key_s(bob) in phase 1.
attacker_p1(key_s(bob)).

32. By 31, the attacker may know key_s(bob) in phase 1.
By 25, the attacker may know validkey(dhexp_real(key_e(alice,bob,sid_5),g)) in phase 1.
Using the function dhexp the attacker may obtain dhexp_real(key_e(alice,bob,sid_5),dhexp_real(key_s(bob),g)) in phase 1.
attacker_p1(dhexp_real(key_e(alice,bob,sid_5),dhexp_real(key_s(bob),g))).

33. Using the function empty the attacker may obtain empty in phase 1.
attacker_p1(empty).

34. Using the function somename the attacker may obtain somename in phase 1.
attacker_p1(somename).

35. By 34, the attacker may know somename in phase 1.
By 33, the attacker may know empty in phase 1.
Using the function hash the attacker may obtain hash(somename,empty) in phase 1.
attacker_p1(hash(somename,empty)).

36. By 35, the attacker may know hash(somename,empty) in phase 1.
By 32, the attacker may know dhexp_real(key_e(alice,bob,sid_5),dhexp_real(key_s(bob),g)) in phase 1.
Using the function hmac_hash1 the attacker may obtain hmac_hash1(hash(somename,empty),dhexp_real(key_e(alice,bob,sid_5),dhexp_real(key_s(bob),g))) in phase 1.
attacker_p1(hmac_hash1(hash(somename,empty),dhexp_real(key_e(alice,bob,sid_5),dhexp_real(key_s(bob),g)))).

37. By 36, the attacker may know hmac_hash1(hash(somename,empty),dhexp_real(key_e(alice,bob,sid_5),dhexp_real(key_s(bob),g))) in phase 1.
By 30, the attacker may know dhexp_real(key_e(alice,bob,sid_5),dhexp_real(key_m(bob),g)) in phase 1.
Using the function hmac_hash2 the attacker may obtain hmac_hash2(hmac_hash1(hash(somename,empty),dhexp_real(key_e(alice,bob,sid_5),dhexp_real(key_s(bob),g))),dhexp_real(key_e(alice,bob,sid_5),dhexp_real(key_m(bob),g))) in phase 1.
attacker_p1(hmac_hash2(hmac_hash1(hash(somename,empty),dhexp_real(key_e(alice,bob,sid_5),dhexp_real(key_s(bob),g))),dhexp_real(key_e(alice,bob,sid_5),dhexp_real(key_m(bob),g)))).

38. By 37, the attacker may know hmac_hash2(hmac_hash1(hash(somename,empty),dhexp_real(key_e(alice,bob,sid_5),dhexp_real(key_s(bob),g))),dhexp_real(key_e(alice,bob,sid_5),dhexp_real(key_m(bob),g))) in phase 1.
By 22, the attacker may know minnonce in phase 1.
By 24, the attacker may know hash(hash(hash(hash(hash(somename,empty),empty),validkey(dhexp_real(key_s(bob),g))),validkey(dhexp_real(key_m(bob),g))),validkey(dhexp_real(key_e(alice,bob,sid_5),g))) in phase 1.
By 23, the attacker may know encrypt(hmac_hash2(hmac_hash1(hash(somename,empty),dhexp_real(key_e(alice,bob,sid_5),dhexp_real(key_s(bob),g))),dhexp_real(key_e(alice,bob,sid_5),dhexp_real(key_m(bob),g))),minnonce,hash(hash(hash(hash(hash(somename,empty),empty),validkey(dhexp_real(key_s(bob),g))),validkey(dhexp_real(key_m(bob),g))),validkey(dhexp_real(key_e(alice,bob,sid_5),g))),validkey(dhexp_real(key_m(alice),g))) in phase 1.
Using the function decrypt the attacker may obtain aeadpack(true,hash(hash(hash(hash(hash(somename,empty),empty),validkey(dhexp_real(key_s(bob),g))),validkey(dhexp_real(key_m(bob),g))),validkey(dhexp_real(key_e(alice,bob,sid_5),g))),validkey(dhexp_real(key_m(alice),g))) in phase 1.
attacker_p1(aeadpack(true,hash(hash(hash(hash(hash(somename,empty),empty),validkey(dhexp_real(key_s(bob),g))),validkey(dhexp_real(key_m(bob),g))),validkey(dhexp_real(key_e(alice,bob,sid_5),g))),validkey(dhexp_real(key_m(alice),g)))).

39. By 38, the attacker may know aeadpack(true,hash(hash(hash(hash(hash(somename,empty),empty),validkey(dhexp_real(key_s(bob),g))),validkey(dhexp_real(key_m(bob),g))),validkey(dhexp_real(key_e(alice,bob,sid_5),g))),validkey(dhexp_real(key_m(alice),g))) in phase 1.
Using the function 3-proj-aeadpack the attacker may obtain validkey(dhexp_real(key_m(alice),g)) in phase 1.
attacker_p1(validkey(dhexp_real(key_m(alice),g))).

40. By 31, the attacker may know key_s(bob) in phase 1.
By 39, the attacker may know validkey(dhexp_real(key_m(alice),g)) in phase 1.
Using the function dhexp the attacker may obtain dhexp_real(key_m(alice),dhexp_real(key_s(bob),g)) in phase 1.
attacker_p1(dhexp_real(key_m(alice),dhexp_real(key_s(bob),g))).

41. By 36, the attacker may know hmac_hash1(hash(somename,empty),dhexp_real(key_e(alice,bob,sid_5),dhexp_real(key_s(bob),g))) in phase 1.
By 30, the attacker may know dhexp_real(key_e(alice,bob,sid_5),dhexp_real(key_m(bob),g)) in phase 1.
Using the function hmac_hash1 the attacker may obtain hmac_hash1(hmac_hash1(hash(somename,empty),dhexp_real(key_e(alice,bob,sid_5),dhexp_real(key_s(bob),g))),dhexp_real(key_e(alice,bob,sid_5),dhexp_real(key_m(bob),g))) in phase 1.
attacker_p1(hmac_hash1(hmac_hash1(hash(somename,empty),dhexp_real(key_e(alice,bob,sid_5),dhexp_real(key_s(bob),g))),dhexp_real(key_e(alice,bob,sid_5),dhexp_real(key_m(bob),g)))).

42. By 41, the attacker may know hmac_hash1(hmac_hash1(hash(somename,empty),dhexp_real(key_e(alice,bob,sid_5),dhexp_real(key_s(bob),g))),dhexp_real(key_e(alice,bob,sid_5),dhexp_real(key_m(bob),g))) in phase 1.
By 40, the attacker may know dhexp_real(key_m(alice),dhexp_real(key_s(bob),g)) in phase 1.
Using the function hmac_hash2 the attacker may obtain hmac_hash2(hmac_hash1(hmac_hash1(hash(somename,empty),dhexp_real(key_e(alice,bob,sid_5),dhexp_real(key_s(bob),g))),dhexp_real(key_e(alice,bob,sid_5),dhexp_real(key_m(bob),g))),dhexp_real(key_m(alice),dhexp_real(key_s(bob),g))) in phase 1.
attacker_p1(hmac_hash2(hmac_hash1(hmac_hash1(hash(somename,empty),dhexp_real(key_e(alice,bob,sid_5),dhexp_real(key_s(bob),g))),dhexp_real(key_e(alice,bob,sid_5),dhexp_real(key_m(bob),g))),dhexp_real(key_m(alice),dhexp_real(key_s(bob),g)))).

43. By 42, the attacker may know hmac_hash2(hmac_hash1(hmac_hash1(hash(somename,empty),dhexp_real(key_e(alice,bob,sid_5),dhexp_real(key_s(bob),g))),dhexp_real(key_e(alice,bob,sid_5),dhexp_real(key_m(bob),g))),dhexp_real(key_m(alice),dhexp_real(key_s(bob),g))) in phase 1.
By 22, the attacker may know minnonce in phase 1.
By 21, the attacker may know hash(hash(hash(hash(hash(hash(somename,empty),empty),validkey(dhexp_real(key_s(bob),g))),validkey(dhexp_real(key_m(bob),g))),validkey(dhexp_real(key_e(alice,bob,sid_5),g))),encrypt(hmac_hash2(hmac_hash1(hash(somename,empty),dhexp_real(key_e(alice,bob,sid_5),dhexp_real(key_s(bob),g))),dhexp_real(key_e(alice,bob,sid_5),dhexp_real(key_m(bob),g))),minnonce,hash(hash(hash(hash(hash(somename,empty),empty),validkey(dhexp_real(key_s(bob),g))),validkey(dhexp_real(key_m(bob),g))),validkey(dhexp_real(key_e(alice,bob,sid_5),g))),validkey(dhexp_real(key_m(alice),g)))) in phase 1.
By 6, the attacker may know encrypt(hmac_hash2(hmac_hash1(hmac_hash1(hash(somename,empty),dhexp_real(key_e(alice,bob,sid_5),dhexp_real(key_s(bob),g))),dhexp_real(key_e(alice,bob,sid_5),dhexp_real(key_m(bob),g))),dhexp_real(key_m(alice),dhexp_real(key_s(bob),g))),minnonce,hash(hash(hash(hash(hash(hash(somename,empty),empty),validkey(dhexp_real(key_s(bob),g))),validkey(dhexp_real(key_m(bob),g))),validkey(dhexp_real(key_e(alice,bob,sid_5),g))),encrypt(hmac_hash2(hmac_hash1(hash(somename,empty),dhexp_real(key_e(alice,bob,sid_5),dhexp_real(key_s(bob),g))),dhexp_real(key_e(alice,bob,sid_5),dhexp_real(key_m(bob),g))),minnonce,hash(hash(hash(hash(hash(somename,empty),empty),validkey(dhexp_real(key_s(bob),g))),validkey(dhexp_real(key_m(bob),g))),validkey(dhexp_real(key_e(alice,bob,sid_5),g))),validkey(dhexp_real(key_m(alice),g)))),msg_a(alice,bob,sid_5)) in phase 1.
Using the function decrypt the attacker may obtain aeadpack(true,hash(hash(hash(hash(hash(hash(somename,empty),empty),validkey(dhexp_real(key_s(bob),g))),validkey(dhexp_real(key_m(bob),g))),validkey(dhexp_real(key_e(alice,bob,sid_5),g))),encrypt(hmac_hash2(hmac_hash1(hash(somename,empty),dhexp_real(key_e(alice,bob,sid_5),dhexp_real(key_s(bob),g))),dhexp_real(key_e(alice,bob,sid_5),dhexp_real(key_m(bob),g))),minnonce,hash(hash(hash(hash(hash(somename,empty),empty),validkey(dhexp_real(key_s(bob),g))),validkey(dhexp_real(key_m(bob),g))),validkey(dhexp_real(key_e(alice,bob,sid_5),g))),validkey(dhexp_real(key_m(alice),g)))),msg_a(alice,bob,sid_5)) in phase 1.
attacker_p1(aeadpack(true,hash(hash(hash(hash(hash(hash(somename,empty),empty),validkey(dhexp_real(key_s(bob),g))),validkey(dhexp_real(key_m(bob),g))),validkey(dhexp_real(key_e(alice,bob,sid_5),g))),encrypt(hmac_hash2(hmac_hash1(hash(somename,empty),dhexp_real(key_e(alice,bob,sid_5),dhexp_real(key_s(bob),g))),dhexp_real(key_e(alice,bob,sid_5),dhexp_real(key_m(bob),g))),minnonce,hash(hash(hash(hash(hash(somename,empty),empty),validkey(dhexp_real(key_s(bob),g))),validkey(dhexp_real(key_m(bob),g))),validkey(dhexp_real(key_e(alice,bob,sid_5),g))),validkey(dhexp_real(key_m(alice),g)))),msg_a(alice,bob,sid_5))).

44. By 43, the attacker may know aeadpack(true,hash(hash(hash(hash(hash(hash(somename,empty),empty),validkey(dhexp_real(key_s(bob),g))),validkey(dhexp_real(key_m(bob),g))),validkey(dhexp_real(key_e(alice,bob,sid_5),g))),encrypt(hmac_hash2(hmac_hash1(hash(somename,empty),dhexp_real(key_e(alice,bob,sid_5),dhexp_real(key_s(bob),g))),dhexp_real(key_e(alice,bob,sid_5),dhexp_real(key_m(bob),g))),minnonce,hash(hash(hash(hash(hash(somename,empty),empty),validkey(dhexp_real(key_s(bob),g))),validkey(dhexp_real(key_m(bob),g))),validkey(dhexp_real(key_e(alice,bob,sid_5),g))),validkey(dhexp_real(key_m(alice),g)))),msg_a(alice,bob,sid_5)) in phase 1.
Using the function 3-proj-aeadpack the attacker may obtain msg_a(alice,bob,sid_5) in phase 1.
attacker_p1(msg_a(alice,bob,sid_5)).

45. By 44, attacker_p1(msg_a(alice,bob,sid_5)).
The goal is reached, represented in the following fact:
attacker_p1(msg_a(alice,bob,sid_5)).


RESULT attacker_p1(msg_a(alice,bob,sid_a)) ==> event(LeakS(phase0,bob)) && event(LeakM(phase0,bob)) cannot be proved.
Starting query not event(RecvEnd(true))
RESULT not event(RecvEnd(true)) is true.

--------------------------------------------------------------
Verification summary:

Query event(RecvMsg(bob,alice,stagepack_a(sid_b),m_10)) ==> event(SendMsg(alice,bob,stagepack_a(sid_a),m_10)) is true.

Query event(RecvMsg(bob,alice,stagepack_a(sid_b),m_10)) ==> event(SendMsg(alice,c,stagepack_a(sid_a),m_10)) || (event(LeakS(phase0,alice)) && event(LeakM(phase0,alice))) || (event(LeakS(phase0,bob)) && event(LeakM(phase0,bob))) is true.

Query event(RecvMsg(bob,alice,stagepack_a(sid_b),m_10)) ==> event(SendMsg(alice,c,stagepack_a(sid_a),m_10)) || (event(LeakS(phase0,alice)) && event(LeakM(phase0,alice))) is true.

Query event(RecvMsg(bob,alice,stagepack_a(sid_b),m_10)) ==> event(SendMsg(alice,bob,stagepack_a(sid_a),m_10)) || (event(LeakS(phase0,alice)) && event(LeakM(phase0,alice))) || (event(LeakS(phase0,bob)) && event(LeakM(phase0,bob))) is true.

Query event(RecvMsg(bob,alice,stagepack_a(sid_b),m_10)) ==> event(SendMsg(alice,bob,stagepack_a(sid_a),m_10)) || (event(LeakS(phase0,alice)) && event(LeakM(phase0,alice))) is true.

Query not attacker_p1(msg_a(alice,bob,sid_a)) cannot be proved.

Query attacker_p1(msg_a(alice,bob,sid_a)) ==> event(LeakS(px,bob)) && event(LeakM(px,bob)) is true.

Query attacker_p1(msg_a(alice,bob,sid_a)) ==> (event(LeakS(phase0,bob)) && event(LeakM(phase0,bob))) || (event(LeakS(px,bob)) && event(LeakM(px,bob)) && event(LeakS(pz,alice)) && event(LeakM(pz,alice))) cannot be proved.

Query attacker_p1(msg_a(alice,bob,sid_a)) ==> event(LeakS(phase0,bob)) && event(LeakM(phase0,bob)) cannot be proved.

Query not event(RecvEnd(true)) is true.

--------------------------------------------------------------


File "pv/NX-X'X'.xnoise.passive.pv", line 226, characters 7-8:
Warning: identifier ck rebound.
File "pv/NX-X'X'.xnoise.passive.pv", line 235, characters 7-8:
Warning: identifier ck rebound.
File "pv/NX-X'X'.xnoise.passive.pv", line 236, characters 7-8:
Warning: identifier cs rebound.
File "pv/NX-X'X'.xnoise.passive.pv", line 236, character 36:
Warning: identifier h rebound.
File "pv/NX-X'X'.xnoise.passive.pv", line 275, character 6:
Warning: identifier e rebound.
File "pv/NX-X'X'.xnoise.passive.pv", line 276, characters 6-7:
Warning: identifier ne rebound.
File "pv/NX-X'X'.xnoise.passive.pv", line 277, characters 6-7:
Warning: identifier ss rebound.
File "pv/NX-X'X'.xnoise.passive.pv", line 279, characters 7-8:
Warning: identifier ss rebound.
File "pv/NX-X'X'.xnoise.passive.pv", line 279, characters 26-35:
Warning: identifier ciphertext rebound.
File "pv/NX-X'X'.xnoise.passive.pv", line 280, characters 6-7:
Warning: identifier hs rebound.
File "pv/NX-X'X'.xnoise.passive.pv", line 287, character 6:
Warning: identifier e rebound.
File "pv/NX-X'X'.xnoise.passive.pv", line 288, characters 6-7:
Warning: identifier ne rebound.
File "pv/NX-X'X'.xnoise.passive.pv", line 289, characters 6-7:
Warning: identifier ss rebound.
File "pv/NX-X'X'.xnoise.passive.pv", line 291, characters 6-7:
Warning: identifier ss rebound.
File "pv/NX-X'X'.xnoise.passive.pv", line 293, character 6:
Warning: identifier s rebound.
File "pv/NX-X'X'.xnoise.passive.pv", line 294, characters 7-8:
Warning: identifier ss rebound.
File "pv/NX-X'X'.xnoise.passive.pv", line 294, characters 26-27:
Warning: identifier ns rebound.
File "pv/NX-X'X'.xnoise.passive.pv", line 296, character 6:
Warning: identifier m rebound.
File "pv/NX-X'X'.xnoise.passive.pv", line 297, characters 7-8:
Warning: identifier ss rebound.
File "pv/NX-X'X'.xnoise.passive.pv", line 297, characters 26-27:
Warning: identifier nm rebound.
File "pv/NX-X'X'.xnoise.passive.pv", line 299, characters 6-7:
Warning: identifier ss rebound.
File "pv/NX-X'X'.xnoise.passive.pv", line 300, characters 6-7:
Warning: identifier ss rebound.
File "pv/NX-X'X'.xnoise.passive.pv", line 302, characters 7-8:
Warning: identifier ss rebound.
File "pv/NX-X'X'.xnoise.passive.pv", line 302, characters 26-35:
Warning: identifier ciphertext rebound.
File "pv/NX-X'X'.xnoise.passive.pv", line 303, characters 6-7:
Warning: identifier hs rebound.
File "pv/NX-X'X'.xnoise.passive.pv", line 314, character 6:
Warning: identifier m rebound.
File "pv/NX-X'X'.xnoise.passive.pv", line 315, characters 7-8:
Warning: identifier ss rebound.
File "pv/NX-X'X'.xnoise.passive.pv", line 315, characters 26-27:
Warning: identifier nm rebound.
File "pv/NX-X'X'.xnoise.passive.pv", line 318, characters 6-7:
Warning: identifier ss rebound.
File "pv/NX-X'X'.xnoise.passive.pv", line 320, characters 7-8:
Warning: identifier ss rebound.
File "pv/NX-X'X'.xnoise.passive.pv", line 320, characters 26-35:
Warning: identifier ciphertext rebound.
File "pv/NX-X'X'.xnoise.passive.pv", line 321, characters 6-7:
Warning: identifier hs rebound.
File "pv/NX-X'X'.xnoise.passive.pv", line 329, characters 7-8:
Warning: identifier ss rebound.
File "pv/NX-X'X'.xnoise.passive.pv", line 329, characters 26-35:
Warning: identifier ciphertext rebound.
File "pv/NX-X'X'.xnoise.passive.pv", line 330, characters 6-7:
Warning: identifier hs rebound.
File "pv/NX-X'X'.xnoise.passive.pv", line 337, characters 7-8:
Warning: identifier ss rebound.
File "pv/NX-X'X'.xnoise.passive.pv", line 337, characters 26-35:
Warning: identifier ciphertext rebound.
File "pv/NX-X'X'.xnoise.passive.pv", line 338, characters 6-7:
Warning: identifier hs rebound.
File "pv/NX-X'X'.xnoise.passive.pv", line 346, characters 6-7:
Warning: identifier re rebound.
File "pv/NX-X'X'.xnoise.passive.pv", line 347, characters 6-7:
Warning: identifier ss rebound.
File "pv/NX-X'X'.xnoise.passive.pv", line 349, characters 7-8:
Warning: identifier ss rebound.
File "pv/NX-X'X'.xnoise.passive.pv", line 351, characters 13-14:
Warning: identifier hs rebound.
File "pv/NX-X'X'.xnoise.passive.pv", line 359, characters 6-7:
Warning: identifier re rebound.
File "pv/NX-X'X'.xnoise.passive.pv", line 360, characters 6-7:
Warning: identifier ss rebound.
File "pv/NX-X'X'.xnoise.passive.pv", line 362, characters 6-7:
Warning: identifier ss rebound.
File "pv/NX-X'X'.xnoise.passive.pv", line 364, characters 7-8:
Warning: identifier ss rebound.
File "pv/NX-X'X'.xnoise.passive.pv", line 364, characters 26-27:
Warning: identifier ne rebound.
File "pv/NX-X'X'.xnoise.passive.pv", line 364, characters 40-45:
Warning: identifier valid1 rebound.
File "pv/NX-X'X'.xnoise.passive.pv", line 365, characters 6-7:
Warning: identifier rs rebound.
File "pv/NX-X'X'.xnoise.passive.pv", line 367, characters 7-8:
Warning: identifier ss rebound.
File "pv/NX-X'X'.xnoise.passive.pv", line 367, characters 26-27:
Warning: identifier ne rebound.
File "pv/NX-X'X'.xnoise.passive.pv", line 368, characters 6-7:
Warning: identifier rm rebound.
File "pv/NX-X'X'.xnoise.passive.pv", line 370, characters 6-7:
Warning: identifier ss rebound.
File "pv/NX-X'X'.xnoise.passive.pv", line 371, characters 6-7:
Warning: identifier ss rebound.
File "pv/NX-X'X'.xnoise.passive.pv", line 373, characters 7-8:
Warning: identifier ss rebound.
File "pv/NX-X'X'.xnoise.passive.pv", line 375, characters 13-14:
Warning: identifier hs rebound.
File "pv/NX-X'X'.xnoise.passive.pv", line 387, characters 7-8:
Warning: identifier ss rebound.
File "pv/NX-X'X'.xnoise.passive.pv", line 388, characters 6-7:
Warning: identifier rm rebound.
File "pv/NX-X'X'.xnoise.passive.pv", line 391, characters 6-7:
Warning: identifier ss rebound.
File "pv/NX-X'X'.xnoise.passive.pv", line 393, characters 7-8:
Warning: identifier ss rebound.
File "pv/NX-X'X'.xnoise.passive.pv", line 395, characters 13-14:
Warning: identifier hs rebound.
File "pv/NX-X'X'.xnoise.passive.pv", line 404, characters 7-8:
Warning: identifier ss rebound.
File "pv/NX-X'X'.xnoise.passive.pv", line 406, characters 13-14:
Warning: identifier hs rebound.
File "pv/NX-X'X'.xnoise.passive.pv", line 414, characters 7-8:
Warning: identifier ss rebound.
File "pv/NX-X'X'.xnoise.passive.pv", line 416, characters 13-14:
Warning: identifier hs rebound.
File "pv/NX-X'X'.xnoise.passive.pv", line 601, characters 7-8:
Warning: identifier hs rebound.
File "pv/NX-X'X'.xnoise.passive.pv", line 602, characters 8-9:
Warning: identifier hs rebound.
File "pv/NX-X'X'.xnoise.passive.pv", line 593, characters 7-8:
Warning: identifier hs rebound.
File "pv/NX-X'X'.xnoise.passive.pv", line 595, characters 8-9:
Warning: identifier hs rebound.
File "pv/NX-X'X'.xnoise.passive.pv", line 587, characters 8-9:
Warning: identifier hs rebound.
File "pv/NX-X'X'.xnoise.passive.pv", line 581, characters 8-9:
Warning: identifier hs rebound.
File "pv/NX-X'X'.xnoise.passive.pv", line 574, characters 8-9:
Warning: identifier hs rebound.
File "pv/NX-X'X'.xnoise.passive.pv", line 657, characters 7-8:
Warning: identifier hs rebound.
File "pv/NX-X'X'.xnoise.passive.pv", line 659, characters 8-9:
Warning: identifier hs rebound.
File "pv/NX-X'X'.xnoise.passive.pv", line 650, characters 7-8:
Warning: identifier hs rebound.
File "pv/NX-X'X'.xnoise.passive.pv", line 651, characters 8-9:
Warning: identifier hs rebound.
File "pv/NX-X'X'.xnoise.passive.pv", line 644, characters 8-9:
Warning: identifier hs rebound.
File "pv/NX-X'X'.xnoise.passive.pv", line 637, characters 8-9:
Warning: identifier hs rebound.
File "pv/NX-X'X'.xnoise.passive.pv", line 631, characters 8-9:
Warning: identifier hs rebound.
Linear part:
dhexp_real(b,dhexp_real(a,g)) = dhexp_real(a,dhexp_real(b,g))
Completing equations...
Completed equations:
dhexp_real(b,dhexp_real(a,g)) = dhexp_real(a,dhexp_real(b,g))
Convergent part: No equation.
Process 0 (that is, the initial process):
{1}out(pub, (key_s(charlie),key_m(charlie)));
{2}!
{3}new sid: sessionid;
(
    {4}let me: principal = alice in
    {5}let them: principal = bob in
    {6}let sid_1: sessionid = sid in
    {7}let s: keypair = keypairpack(empty,empty) in
    {8}let m: keypair = keypairpack(empty,empty) in
    {9}out(pub, (getpublickey(s),getpublickey(m)));
    (
        {10}let e: keypair = keypairpack(empty,empty) in
        {11}let rs: key = empty in
        {12}let rm: key = empty in
        {13}let re: key = empty in
        {14}let prologue: bitstring = empty in
        {15}let psk: key = empty in
        {16}let protocol_name: bitstring = somename in
        {17}let h: bitstring = hash(protocol_name,empty) in
        {18}let ck: key = h in
        {19}let k: key = empty in
        {20}let cs: cipherstate = cipherstatepack(k,minnonce) in
        {21}let ss: symmetricstate = symmetricstatepack(cs,ck,h) in
        {22}let v: bitstring = catch-fail(symmetricstateunpack(ss)) in
        {23}let v_1: bool = (not-caught-fail(v) && success?(1-proj-3-tuple(v))) in
        {24}let h_1: bitstring = (if v_1 then 3-proj-3-tuple(v) else caught-fail) in
        {25}let ck_1: key = (if v_1 then 2-proj-3-tuple(v) else caught-fail) in
        {26}let cs_1: cipherstate = (if v_1 then 1-proj-3-tuple(v) else caught-fail) in
        {27}let ss_1: symmetricstate = catch-fail((if v_1 then symmetricstatepack(cs_1,ck_1,hash(h_1,prologue)) else fail-any)) in
        {28}let v_2: bool = not-caught-fail(ss_1) in
        {29}let hs: handshakestate = (if v_2 then handshakestatepack(ss_1,s,m,e,rs,rm,re,psk,true) else fail-any) in
        {30}insert statestore(me,them,sid_1,statepack_a(hs))
    ) | (
        {101}get statestore(=me,=them,=sid_1,statepack_a(hs_1: handshakestate)) in
        {31}let payload: bitstring = msg_a(me,them,sid_1) in
        {32}let v_3: bitstring = catch-fail(handshakestateunpack(hs_1)) in
        {33}let v_4: bool = (not-caught-fail(v_3) && success?(1-proj-9-tuple(v_3))) in
        {34}let initiator_1: bool = (if v_4 then 9-proj-9-tuple(v_3) else caught-fail) in
        {35}let psk_1: key = (if v_4 then 8-proj-9-tuple(v_3) else caught-fail) in
        {36}let re_1: key = (if v_4 then 7-proj-9-tuple(v_3) else caught-fail) in
        {37}let rm_1: key = (if v_4 then 6-proj-9-tuple(v_3) else caught-fail) in
        {38}let rs_1: key = (if v_4 then 5-proj-9-tuple(v_3) else caught-fail) in
        {39}let e_1: keypair = (if v_4 then 4-proj-9-tuple(v_3) else caught-fail) in
        {40}let m_1: keypair = (if v_4 then 3-proj-9-tuple(v_3) else caught-fail) in
        {41}let s_1: keypair = (if v_4 then 2-proj-9-tuple(v_3) else caught-fail) in
        {42}let ss_2: symmetricstate = (if v_4 then 1-proj-9-tuple(v_3) else caught-fail) in
        {43}let v_5: bitstring = (if v_4 then catch-fail((empty,empty,empty)) else caught-fail) in
        {44}let v_6: bool = (not-caught-fail(v_5) && success?(1-proj-3-tuple(v_5))) in
        {45}let ciphertext: bitstring = (if v_6 then 3-proj-3-tuple(v_5) else caught-fail) in
        {46}let ns: bitstring = (if v_6 then 2-proj-3-tuple(v_5) else caught-fail) in
        {47}let ne: bitstring = (if v_6 then 1-proj-3-tuple(v_5) else caught-fail) in
        {48}let basis: key = (if v_6 then key_e(me,them,sid_1) else caught-fail) in
        {49}let public_key: key = (if v_6 then catch-fail(dhexp(basis,validkey(g))) else caught-fail) in
        {50}let v_7: bool = not-caught-fail(public_key) in
        {51}let e_2: keypair = (if v_6 then catch-fail((if v_7 then keypairpack(validkey(public_key),basis) else fail-any)) else caught-fail) in
        {52}let v_8: bool = not-caught-fail(e_2) in
        {53}let ne_1: bitstring = (if v_8 then catch-fail(getpublickey(e_2)) else caught-fail) in
        {54}let v_9: bool = not-caught-fail(ne_1) in
        {55}let v_10: bitstring = (if v_9 then catch-fail(symmetricstateunpack(ss_2)) else caught-fail) in
        {56}let v_11: bool = (not-caught-fail(v_10) && success?(1-proj-3-tuple(v_10))) in
        {57}let h_2: bitstring = (if v_11 then 3-proj-3-tuple(v_10) else caught-fail) in
        {58}let ck_2: key = (if v_11 then 2-proj-3-tuple(v_10) else caught-fail) in
        {59}let cs_2: cipherstate = (if v_11 then 1-proj-3-tuple(v_10) else caught-fail) in
        {60}let ss_3: symmetricstate = (if v_9 then catch-fail((if v_11 then symmetricstatepack(cs_2,ck_2,hash(h_2,ne_1)) else fail-any)) else caught-fail) in
        {61}let v_12: bool = not-caught-fail(ss_3) in
        {62}let v_13: bitstring = (if v_12 then catch-fail(symmetricstateunpack(ss_3)) else caught-fail) in
        {63}let v_14: bool = (not-caught-fail(v_13) && success?(1-proj-3-tuple(v_13))) in
        {64}let h_3: bitstring = (if v_14 then 3-proj-3-tuple(v_13) else caught-fail) in
        {65}let ck_3: key = (if v_14 then 2-proj-3-tuple(v_13) else caught-fail) in
        {66}let cs_3: cipherstate = (if v_14 then 1-proj-3-tuple(v_13) else caught-fail) in
        {67}let v_15: bitstring = (if v_14 then catch-fail(cipherstateunpack(cs_3)) else caught-fail) in
        {68}let v_16: bool = (not-caught-fail(v_15) && success?(1-proj-2-tuple(v_15))) in
        {69}let n: nonce = (if v_16 then 2-proj-2-tuple(v_15) else caught-fail) in
        {70}let k_1: key = (if v_16 then 1-proj-2-tuple(v_15) else caught-fail) in
        {71}let e_3: bitstring = (if v_16 then encrypt(k_1,n,h_3,payload) else caught-fail) in
        {72}let n_1: nonce = (if v_16 then increment_nonce(n) else caught-fail) in
        {73}let v_17: bitstring = (if v_16 then catch-fail(cipherstateunpack(cs_3)) else caught-fail) in
        {74}let v_18: bool = (not-caught-fail(v_17) && success?(1-proj-2-tuple(v_17))) in
        {75}let o: nonce = (if v_18 then 2-proj-2-tuple(v_17) else caught-fail) in
        {76}let k_2: key = (if v_18 then 1-proj-2-tuple(v_17) else caught-fail) in
        {77}let csi: cipherstate = (if v_16 then catch-fail((if v_18 then cipherstatepack(k_2,n_1) else fail-any)) else caught-fail) in
        {78}let v_19: bool = not-caught-fail(csi) in
        {79}let v_20: bitstring = (if v_14 then catch-fail((if v_16 then (if v_19 then (csi,e_3) else fail-any) else fail-any)) else caught-fail) in
        {80}let v_21: bool = (not-caught-fail(v_20) && success?(1-proj-2-tuple(v_20))) in
        {81}let ciphertext_1: bitstring = (if v_21 then 2-proj-2-tuple(v_20) else caught-fail) in
        {82}let csi_1: cipherstate = (if v_21 then 1-proj-2-tuple(v_20) else caught-fail) in
        {83}let ss_4: symmetricstate = (if v_21 then symmetricstatepack(csi_1,ck_3,h_3) else caught-fail) in
        {84}let v_22: bitstring = (if v_21 then catch-fail(symmetricstateunpack(ss_4)) else caught-fail) in
        {85}let v_23: bool = (not-caught-fail(v_22) && success?(1-proj-3-tuple(v_22))) in
        {86}let h_4: bitstring = (if v_23 then 3-proj-3-tuple(v_22) else caught-fail) in
        {87}let ck_4: key = (if v_23 then 2-proj-3-tuple(v_22) else caught-fail) in
        {88}let cs_4: cipherstate = (if v_23 then 1-proj-3-tuple(v_22) else caught-fail) in
        {89}let ssi: symmetricstate = (if v_21 then catch-fail((if v_23 then symmetricstatepack(cs_4,ck_4,hash(h_4,ciphertext_1)) else fail-any)) else caught-fail) in
        {90}let v_24: bool = not-caught-fail(ssi) in
        {91}let v_25: bitstring = (if v_12 then catch-fail((if v_14 then (if v_21 then (if v_24 then (ssi,ciphertext_1) else fail-any) else fail-any) else fail-any)) else caught-fail) in
        {92}let v_26: bool = (not-caught-fail(v_25) && success?(1-proj-2-tuple(v_25))) in
        {93}let ciphertext_2: bitstring = (if v_26 then 2-proj-2-tuple(v_25) else caught-fail) in
        {94}let ss_5: symmetricstate = (if v_26 then 1-proj-2-tuple(v_25) else caught-fail) in
        {95}let hs_2: handshakestate = (if v_26 then handshakestatepack(ss_5,s_1,m_1,e_2,rs_1,rm_1,re_1,psk_1,initiator_1) else caught-fail) in
        {96}let message_buffer: bitstring = (if v_26 then concat3(ne_1,ns,ciphertext_2) else caught-fail) in
        {97}let (hs_3: handshakestate,message_a: bitstring) = (if v_4 then (if v_6 then (if v_8 then (if v_9 then (if v_12 then (if v_26 then (hs_2,message_buffer) else fail-any) else fail-any) else fail-any) else fail-any) else fail-any) else fail-any) in
        {98}event SendMsg(me,them,stagepack_a(sid_1),msg_a(me,them,sid_1));
        {99}insert statestore(me,them,sid_1,statepack_b(hs_3));
        {100}out(pub, message_a)
    ) | (
        {328}get statestore(=me,=them,=sid_1,statepack_b(hs_4: handshakestate)) in
        {102}in(pub, message_b: bitstring);
        {103}let v_27: bitstring = catch-fail(handshakestateunpack(hs_4)) in
        {104}let v_28: bool = (not-caught-fail(v_27) && success?(1-proj-9-tuple(v_27))) in
        {105}let initiator_2: bool = (if v_28 then 9-proj-9-tuple(v_27) else caught-fail) in
        {106}let psk_2: key = (if v_28 then 8-proj-9-tuple(v_27) else caught-fail) in
        {107}let re_2: key = (if v_28 then 7-proj-9-tuple(v_27) else caught-fail) in
        {108}let rm_2: key = (if v_28 then 6-proj-9-tuple(v_27) else caught-fail) in
        {109}let rs_2: key = (if v_28 then 5-proj-9-tuple(v_27) else caught-fail) in
        {110}let e_4: keypair = (if v_28 then 4-proj-9-tuple(v_27) else caught-fail) in
        {111}let m_2: keypair = (if v_28 then 3-proj-9-tuple(v_27) else caught-fail) in
        {112}let s_2: keypair = (if v_28 then 2-proj-9-tuple(v_27) else caught-fail) in
        {113}let ss_6: symmetricstate = (if v_28 then 1-proj-9-tuple(v_27) else caught-fail) in
        {114}let v_29: bitstring = (if v_28 then catch-fail(deconcat4(message_b)) else caught-fail) in
        {115}let v_30: bool = (not-caught-fail(v_29) && success?(1-proj-4-tuple(v_29))) in
        {116}let ciphertext_3: bitstring = (if v_30 then 4-proj-4-tuple(v_29) else caught-fail) in
        {117}let nm: bitstring = (if v_30 then 3-proj-4-tuple(v_29) else caught-fail) in
        {118}let ns_1: bitstring = (if v_30 then 2-proj-4-tuple(v_29) else caught-fail) in
        {119}let ne_2: bitstring = (if v_30 then 1-proj-4-tuple(v_29) else caught-fail) in
        {120}let valid1: bool = (if v_30 then true else caught-fail) in
        {121}let re_3: key = (if v_30 then ne_2 else caught-fail) in
        {122}let v_31: bitstring = (if v_30 then catch-fail(symmetricstateunpack(ss_6)) else caught-fail) in
        {123}let v_32: bool = (not-caught-fail(v_31) && success?(1-proj-3-tuple(v_31))) in
        {124}let h_5: bitstring = (if v_32 then 3-proj-3-tuple(v_31) else caught-fail) in
        {125}let ck_5: key = (if v_32 then 2-proj-3-tuple(v_31) else caught-fail) in
        {126}let cs_5: cipherstate = (if v_32 then 1-proj-3-tuple(v_31) else caught-fail) in
        {127}let ss_7: symmetricstate = (if v_30 then catch-fail((if v_32 then symmetricstatepack(cs_5,ck_5,hash(h_5,re_3)) else fail-any)) else caught-fail) in
        {128}let v_33: bool = not-caught-fail(ss_7) in
        {129}let v_34: bitstring = (if v_33 then catch-fail(keypairunpack(e_4)) else caught-fail) in
        {130}let v_35: bool = (not-caught-fail(v_34) && success?(1-proj-2-tuple(v_34))) in
        {131}let my_private_key: key = (if v_35 then 2-proj-2-tuple(v_34) else caught-fail) in
        {132}let my_public_key: key = (if v_35 then 1-proj-2-tuple(v_34) else caught-fail) in
        {133}let input_key_material: key = (if v_33 then catch-fail((if v_35 then dhexp(my_private_key,re_3) else fail-any)) else caught-fail) in
        {134}let v_36: bool = not-caught-fail(input_key_material) in
        {135}let v_37: bitstring = (if v_36 then catch-fail(symmetricstateunpack(ss_7)) else caught-fail) in
        {136}let v_38: bool = (not-caught-fail(v_37) && success?(1-proj-3-tuple(v_37))) in
        {137}let h_6: bitstring = (if v_38 then 3-proj-3-tuple(v_37) else caught-fail) in
        {138}let ck_6: key = (if v_38 then 2-proj-3-tuple(v_37) else caught-fail) in
        {139}let cs_6: cipherstate = (if v_38 then 1-proj-3-tuple(v_37) else caught-fail) in
        {140}let output1: key = (if v_38 then hmac_hash1(ck_6,input_key_material) else caught-fail) in
        {141}let output2: key = (if v_38 then hmac_hash2(ck_6,input_key_material) else caught-fail) in
        {142}let output3: key = (if v_38 then hmac_hash3(ck_6,input_key_material) else caught-fail) in
        {143}let v_39: bitstring = (if v_38 then catch-fail((output1,output2,output3)) else caught-fail) in
        {144}let v_40: bool = (not-caught-fail(v_39) && success?(1-proj-3-tuple(v_39))) in
        {145}let output_3: key = (if v_40 then 3-proj-3-tuple(v_39) else caught-fail) in
        {146}let temp_k: key = (if v_40 then 2-proj-3-tuple(v_39) else caught-fail) in
        {147}let ck_7: key = (if v_40 then 1-proj-3-tuple(v_39) else caught-fail) in
        {148}let ss_8: symmetricstate = (if v_33 then catch-fail((if v_36 then (if v_38 then (if v_40 then symmetricstatepack(cipherstatepack(temp_k,minnonce),ck_7,h_6) else fail-any) else fail-any) else fail-any)) else caught-fail) in
        {149}let v_41: bool = not-caught-fail(ss_8) in
        {150}let v_42: bitstring = (if v_41 then catch-fail(symmetricstateunpack(ss_8)) else caught-fail) in
        {151}let v_43: bool = (not-caught-fail(v_42) && success?(1-proj-3-tuple(v_42))) in
        {152}let h_7: bitstring = (if v_43 then 3-proj-3-tuple(v_42) else caught-fail) in
        {153}let ck_8: key = (if v_43 then 2-proj-3-tuple(v_42) else caught-fail) in
        {154}let cs_7: cipherstate = (if v_43 then 1-proj-3-tuple(v_42) else caught-fail) in
        {155}let v_44: bitstring = (if v_43 then catch-fail(cipherstateunpack(cs_7)) else caught-fail) in
        {156}let v_45: bool = (not-caught-fail(v_44) && success?(1-proj-2-tuple(v_44))) in
        {157}let n_2: nonce = (if v_45 then 2-proj-2-tuple(v_44) else caught-fail) in
        {158}let k_3: key = (if v_45 then 1-proj-2-tuple(v_44) else caught-fail) in
        {159}let d: aead = (if v_45 then catch-fail(decrypt(k_3,n_2,h_7,ns_1)) else caught-fail) in
        {160}let v_46: bool = not-caught-fail(d) in
        {161}let v_47: bitstring = (if v_46 then catch-fail(aeadunpack(d)) else caught-fail) in
        {162}let v_48: bool = (not-caught-fail(v_47) && success?(1-proj-3-tuple(v_47))) in
        {163}let plaintext: bitstring = (if v_48 then 3-proj-3-tuple(v_47) else caught-fail) in
        {164}let adi: bitstring = (if v_48 then 2-proj-3-tuple(v_47) else caught-fail) in
        {165}let valid: bool = (if v_48 then 1-proj-3-tuple(v_47) else caught-fail) in
        {166}let n_3: nonce = (if v_48 then increment_nonce(n_2) else caught-fail) in
        {167}let v_49: bitstring = (if v_48 then catch-fail(cipherstateunpack(cs_7)) else caught-fail) in
        {168}let v_50: bool = (not-caught-fail(v_49) && success?(1-proj-2-tuple(v_49))) in
        {169}let o_1: nonce = (if v_50 then 2-proj-2-tuple(v_49) else caught-fail) in
        {170}let k_4: key = (if v_50 then 1-proj-2-tuple(v_49) else caught-fail) in
        {171}let csi_2: cipherstate = (if v_48 then catch-fail((if v_50 then cipherstatepack(k_4,n_3) else fail-any)) else caught-fail) in
        {172}let v_51: bool = not-caught-fail(csi_2) in
        {173}let v_52: bitstring = (if v_43 then catch-fail((if v_45 then (if v_46 then (if v_48 then (if v_51 then (csi_2,plaintext,valid) else fail-any) else fail-any) else fail-any) else fail-any)) else caught-fail) in
        {174}let v_53: bool = (not-caught-fail(v_52) && success?(1-proj-3-tuple(v_52))) in
        {175}let valid_1: bool = (if v_53 then 3-proj-3-tuple(v_52) else caught-fail) in
        {176}let plaintext_1: bitstring = (if v_53 then 2-proj-3-tuple(v_52) else caught-fail) in
        {177}let csi_3: cipherstate = (if v_53 then 1-proj-3-tuple(v_52) else caught-fail) in
        {178}let ss_9: symmetricstate = (if v_53 then symmetricstatepack(csi_3,ck_8,h_7) else caught-fail) in
        {179}let v_54: bitstring = (if v_53 then catch-fail(symmetricstateunpack(ss_9)) else caught-fail) in
        {180}let v_55: bool = (not-caught-fail(v_54) && success?(1-proj-3-tuple(v_54))) in
        {181}let h_8: bitstring = (if v_55 then 3-proj-3-tuple(v_54) else caught-fail) in
        {182}let ck_9: key = (if v_55 then 2-proj-3-tuple(v_54) else caught-fail) in
        {183}let cs_8: cipherstate = (if v_55 then 1-proj-3-tuple(v_54) else caught-fail) in
        {184}let ssi_1: symmetricstate = (if v_53 then catch-fail((if v_55 then symmetricstatepack(cs_8,ck_9,hash(h_8,ns_1)) else fail-any)) else caught-fail) in
        {185}let v_56: bool = not-caught-fail(ssi_1) in
        {186}let v_57: bitstring = (if v_41 then catch-fail((if v_43 then (if v_53 then (if v_56 then (ssi_1,plaintext_1,valid_1) else fail-any) else fail-any) else fail-any)) else caught-fail) in
        {187}let v_58: bool = (not-caught-fail(v_57) && success?(1-proj-3-tuple(v_57))) in
        {188}let valid1_1: bool = (if v_58 then 3-proj-3-tuple(v_57) else caught-fail) in
        {189}let ne_3: bitstring = (if v_58 then 2-proj-3-tuple(v_57) else caught-fail) in
        {190}let ss_10: symmetricstate = (if v_58 then 1-proj-3-tuple(v_57) else caught-fail) in
        {191}let rs_3: key = (if v_58 then ne_3 else caught-fail) in
        {192}let v_59: bitstring = (if v_58 then catch-fail(symmetricstateunpack(ss_10)) else caught-fail) in
        {193}let v_60: bool = (not-caught-fail(v_59) && success?(1-proj-3-tuple(v_59))) in
        {194}let h_9: bitstring = (if v_60 then 3-proj-3-tuple(v_59) else caught-fail) in
        {195}let ck_10: key = (if v_60 then 2-proj-3-tuple(v_59) else caught-fail) in
        {196}let cs_9: cipherstate = (if v_60 then 1-proj-3-tuple(v_59) else caught-fail) in
        {197}let v_61: bitstring = (if v_60 then catch-fail(cipherstateunpack(cs_9)) else caught-fail) in
        {198}let v_62: bool = (not-caught-fail(v_61) && success?(1-proj-2-tuple(v_61))) in
        {199}let n_4: nonce = (if v_62 then 2-proj-2-tuple(v_61) else caught-fail) in
        {200}let k_5: key = (if v_62 then 1-proj-2-tuple(v_61) else caught-fail) in
        {201}let d_1: aead = (if v_62 then catch-fail(decrypt(k_5,n_4,h_9,nm)) else caught-fail) in
        {202}let v_63: bool = not-caught-fail(d_1) in
        {203}let v_64: bitstring = (if v_63 then catch-fail(aeadunpack(d_1)) else caught-fail) in
        {204}let v_65: bool = (not-caught-fail(v_64) && success?(1-proj-3-tuple(v_64))) in
        {205}let plaintext_2: bitstring = (if v_65 then 3-proj-3-tuple(v_64) else caught-fail) in
        {206}let adi_1: bitstring = (if v_65 then 2-proj-3-tuple(v_64) else caught-fail) in
        {207}let valid_2: bool = (if v_65 then 1-proj-3-tuple(v_64) else caught-fail) in
        {208}let n_5: nonce = (if v_65 then increment_nonce(n_4) else caught-fail) in
        {209}let v_66: bitstring = (if v_65 then catch-fail(cipherstateunpack(cs_9)) else caught-fail) in
        {210}let v_67: bool = (not-caught-fail(v_66) && success?(1-proj-2-tuple(v_66))) in
        {211}let o_2: nonce = (if v_67 then 2-proj-2-tuple(v_66) else caught-fail) in
        {212}let k_6: key = (if v_67 then 1-proj-2-tuple(v_66) else caught-fail) in
        {213}let csi_4: cipherstate = (if v_65 then catch-fail((if v_67 then cipherstatepack(k_6,n_5) else fail-any)) else caught-fail) in
        {214}let v_68: bool = not-caught-fail(csi_4) in
        {215}let v_69: bitstring = (if v_60 then catch-fail((if v_62 then (if v_63 then (if v_65 then (if v_68 then (csi_4,plaintext_2,valid_2) else fail-any) else fail-any) else fail-any) else fail-any)) else caught-fail) in
        {216}let v_70: bool = (not-caught-fail(v_69) && success?(1-proj-3-tuple(v_69))) in
        {217}let valid_3: bool = (if v_70 then 3-proj-3-tuple(v_69) else caught-fail) in
        {218}let plaintext_3: bitstring = (if v_70 then 2-proj-3-tuple(v_69) else caught-fail) in
        {219}let csi_5: cipherstate = (if v_70 then 1-proj-3-tuple(v_69) else caught-fail) in
        {220}let ss_11: symmetricstate = (if v_70 then symmetricstatepack(csi_5,ck_10,h_9) else caught-fail) in
        {221}let v_71: bitstring = (if v_70 then catch-fail(symmetricstateunpack(ss_11)) else caught-fail) in
        {222}let v_72: bool = (not-caught-fail(v_71) && success?(1-proj-3-tuple(v_71))) in
        {223}let h_10: bitstring = (if v_72 then 3-proj-3-tuple(v_71) else caught-fail) in
        {224}let ck_11: key = (if v_72 then 2-proj-3-tuple(v_71) else caught-fail) in
        {225}let cs_10: cipherstate = (if v_72 then 1-proj-3-tuple(v_71) else caught-fail) in
        {226}let ssi_2: symmetricstate = (if v_70 then catch-fail((if v_72 then symmetricstatepack(cs_10,ck_11,hash(h_10,nm)) else fail-any)) else caught-fail) in
        {227}let v_73: bool = not-caught-fail(ssi_2) in
        {228}let v_74: bitstring = (if v_58 then catch-fail((if v_60 then (if v_70 then (if v_73 then (ssi_2,plaintext_3,valid_3) else fail-any) else fail-any) else fail-any)) else caught-fail) in
        {229}let v_75: bool = (not-caught-fail(v_74) && success?(1-proj-3-tuple(v_74))) in
        {230}let valid2: bool = (if v_75 then 3-proj-3-tuple(v_74) else caught-fail) in
        {231}let ne_4: bitstring = (if v_75 then 2-proj-3-tuple(v_74) else caught-fail) in
        {232}let ss_12: symmetricstate = (if v_75 then 1-proj-3-tuple(v_74) else caught-fail) in
        {233}let rm_3: key = (if v_75 then ne_4 else caught-fail) in
        {234}let v_76: bitstring = (if v_75 then catch-fail(keypairunpack(e_4)) else caught-fail) in
        {235}let v_77: bool = (not-caught-fail(v_76) && success?(1-proj-2-tuple(v_76))) in
        {236}let my_private_key_1: key = (if v_77 then 2-proj-2-tuple(v_76) else caught-fail) in
        {237}let my_public_key_1: key = (if v_77 then 1-proj-2-tuple(v_76) else caught-fail) in
        {238}let input_key_material_1: key = (if v_75 then catch-fail((if v_77 then dhexp(my_private_key_1,rs_3) else fail-any)) else caught-fail) in
        {239}let v_78: bool = not-caught-fail(input_key_material_1) in
        {240}let v_79: bitstring = (if v_78 then catch-fail(symmetricstateunpack(ss_12)) else caught-fail) in
        {241}let v_80: bool = (not-caught-fail(v_79) && success?(1-proj-3-tuple(v_79))) in
        {242}let h_11: bitstring = (if v_80 then 3-proj-3-tuple(v_79) else caught-fail) in
        {243}let ck_12: key = (if v_80 then 2-proj-3-tuple(v_79) else caught-fail) in
        {244}let cs_11: cipherstate = (if v_80 then 1-proj-3-tuple(v_79) else caught-fail) in
        {245}let output1_1: key = (if v_80 then hmac_hash1(ck_12,input_key_material_1) else caught-fail) in
        {246}let output2_1: key = (if v_80 then hmac_hash2(ck_12,input_key_material_1) else caught-fail) in
        {247}let output3_1: key = (if v_80 then hmac_hash3(ck_12,input_key_material_1) else caught-fail) in
        {248}let v_81: bitstring = (if v_80 then catch-fail((output1_1,output2_1,output3_1)) else caught-fail) in
        {249}let v_82: bool = (not-caught-fail(v_81) && success?(1-proj-3-tuple(v_81))) in
        {250}let output: key = (if v_82 then 3-proj-3-tuple(v_81) else caught-fail) in
        {251}let temp_k_1: key = (if v_82 then 2-proj-3-tuple(v_81) else caught-fail) in
        {252}let ck_13: key = (if v_82 then 1-proj-3-tuple(v_81) else caught-fail) in
        {253}let ss_13: symmetricstate = (if v_75 then catch-fail((if v_78 then (if v_80 then (if v_82 then symmetricstatepack(cipherstatepack(temp_k_1,minnonce),ck_13,h_11) else fail-any) else fail-any) else fail-any)) else caught-fail) in
        {254}let v_83: bool = not-caught-fail(ss_13) in
        {255}let v_84: bitstring = (if v_83 then catch-fail(keypairunpack(e_4)) else caught-fail) in
        {256}let v_85: bool = (not-caught-fail(v_84) && success?(1-proj-2-tuple(v_84))) in
        {257}let my_private_key_2: key = (if v_85 then 2-proj-2-tuple(v_84) else caught-fail) in
        {258}let my_public_key_2: key = (if v_85 then 1-proj-2-tuple(v_84) else caught-fail) in
        {259}let input_key_material_2: key = (if v_83 then catch-fail((if v_85 then dhexp(my_private_key_2,rm_3) else fail-any)) else caught-fail) in
        {260}let v_86: bool = not-caught-fail(input_key_material_2) in
        {261}let v_87: bitstring = (if v_86 then catch-fail(symmetricstateunpack(ss_13)) else caught-fail) in
        {262}let v_88: bool = (not-caught-fail(v_87) && success?(1-proj-3-tuple(v_87))) in
        {263}let h_12: bitstring = (if v_88 then 3-proj-3-tuple(v_87) else caught-fail) in
        {264}let ck_14: key = (if v_88 then 2-proj-3-tuple(v_87) else caught-fail) in
        {265}let cs_12: cipherstate = (if v_88 then 1-proj-3-tuple(v_87) else caught-fail) in
        {266}let output1_2: key = (if v_88 then hmac_hash1(ck_14,input_key_material_2) else caught-fail) in
        {267}let output2_2: key = (if v_88 then hmac_hash2(ck_14,input_key_material_2) else caught-fail) in
        {268}let output3_2: key = (if v_88 then hmac_hash3(ck_14,input_key_material_2) else caught-fail) in
        {269}let v_89: bitstring = (if v_88 then catch-fail((output1_2,output2_2,output3_2)) else caught-fail) in
        {270}let v_90: bool = (not-caught-fail(v_89) && success?(1-proj-3-tuple(v_89))) in
        {271}let output_1: key = (if v_90 then 3-proj-3-tuple(v_89) else caught-fail) in
        {272}let temp_k_2: key = (if v_90 then 2-proj-3-tuple(v_89) else caught-fail) in
        {273}let ck_15: key = (if v_90 then 1-proj-3-tuple(v_89) else caught-fail) in
        {274}let ss_14: symmetricstate = (if v_83 then catch-fail((if v_86 then (if v_88 then (if v_90 then symmetricstatepack(cipherstatepack(temp_k_2,minnonce),ck_15,h_12) else fail-any) else fail-any) else fail-any)) else caught-fail) in
        {275}let v_91: bool = not-caught-fail(ss_14) in
        {276}let v_92: bitstring = (if v_91 then catch-fail(symmetricstateunpack(ss_14)) else caught-fail) in
        {277}let v_93: bool = (not-caught-fail(v_92) && success?(1-proj-3-tuple(v_92))) in
        {278}let h_13: bitstring = (if v_93 then 3-proj-3-tuple(v_92) else caught-fail) in
        {279}let ck_16: key = (if v_93 then 2-proj-3-tuple(v_92) else caught-fail) in
        {280}let cs_13: cipherstate = (if v_93 then 1-proj-3-tuple(v_92) else caught-fail) in
        {281}let v_94: bitstring = (if v_93 then catch-fail(cipherstateunpack(cs_13)) else caught-fail) in
        {282}let v_95: bool = (not-caught-fail(v_94) && success?(1-proj-2-tuple(v_94))) in
        {283}let n_6: nonce = (if v_95 then 2-proj-2-tuple(v_94) else caught-fail) in
        {284}let k_7: key = (if v_95 then 1-proj-2-tuple(v_94) else caught-fail) in
        {285}let d_2: aead = (if v_95 then catch-fail(decrypt(k_7,n_6,h_13,ciphertext_3)) else caught-fail) in
        {286}let v_96: bool = not-caught-fail(d_2) in
        {287}let v_97: bitstring = (if v_96 then catch-fail(aeadunpack(d_2)) else caught-fail) in
        {288}let v_98: bool = (not-caught-fail(v_97) && success?(1-proj-3-tuple(v_97))) in
        {289}let plaintext_4: bitstring = (if v_98 then 3-proj-3-tuple(v_97) else caught-fail) in
        {290}let adi_2: bitstring = (if v_98 then 2-proj-3-tuple(v_97) else caught-fail) in
        {291}let valid_4: bool = (if v_98 then 1-proj-3-tuple(v_97) else caught-fail) in
        {292}let n_7: nonce = (if v_98 then increment_nonce(n_6) else caught-fail) in
        {293}let v_99: bitstring = (if v_98 then catch-fail(cipherstateunpack(cs_13)) else caught-fail) in
        {294}let v_100: bool = (not-caught-fail(v_99) && success?(1-proj-2-tuple(v_99))) in
        {295}let o_3: nonce = (if v_100 then 2-proj-2-tuple(v_99) else caught-fail) in
        {296}let k_8: key = (if v_100 then 1-proj-2-tuple(v_99) else caught-fail) in
        {297}let csi_6: cipherstate = (if v_98 then catch-fail((if v_100 then cipherstatepack(k_8,n_7) else fail-any)) else caught-fail) in
        {298}let v_101: bool = not-caught-fail(csi_6) in
        {299}let v_102: bitstring = (if v_93 then catch-fail((if v_95 then (if v_96 then (if v_98 then (if v_101 then (csi_6,plaintext_4,valid_4) else fail-any) else fail-any) else fail-any) else fail-any)) else caught-fail) in
        {300}let v_103: bool = (not-caught-fail(v_102) && success?(1-proj-3-tuple(v_102))) in
        {301}let valid_5: bool = (if v_103 then 3-proj-3-tuple(v_102) else caught-fail) in
        {302}let plaintext_5: bitstring = (if v_103 then 2-proj-3-tuple(v_102) else caught-fail) in
        {303}let csi_7: cipherstate = (if v_103 then 1-proj-3-tuple(v_102) else caught-fail) in
        {304}let ss_15: symmetricstate = (if v_103 then symmetricstatepack(csi_7,ck_16,h_13) else caught-fail) in
        {305}let v_104: bitstring = (if v_103 then catch-fail(symmetricstateunpack(ss_15)) else caught-fail) in
        {306}let v_105: bool = (not-caught-fail(v_104) && success?(1-proj-3-tuple(v_104))) in
        {307}let h_14: bitstring = (if v_105 then 3-proj-3-tuple(v_104) else caught-fail) in
        {308}let ck_17: key = (if v_105 then 2-proj-3-tuple(v_104) else caught-fail) in
        {309}let cs_14: cipherstate = (if v_105 then 1-proj-3-tuple(v_104) else caught-fail) in
        {310}let ssi_3: symmetricstate = (if v_103 then catch-fail((if v_105 then symmetricstatepack(cs_14,ck_17,hash(h_14,ciphertext_3)) else fail-any)) else caught-fail) in
        {311}let v_106: bool = not-caught-fail(ssi_3) in
        {312}let v_107: bitstring = (if v_91 then catch-fail((if v_93 then (if v_103 then (if v_106 then (ssi_3,plaintext_5,valid_5) else fail-any) else fail-any) else fail-any)) else caught-fail) in
        {313}let v_108: bool = (not-caught-fail(v_107) && success?(1-proj-3-tuple(v_107))) in
        {314}let valid3: bool = (if v_108 then 3-proj-3-tuple(v_107) else caught-fail) in
        {315}let plaintext_6: bitstring = (if v_108 then 2-proj-3-tuple(v_107) else caught-fail) in
        {316}let ss_16: symmetricstate = (if v_108 then 1-proj-3-tuple(v_107) else caught-fail) in
        {317}let basis_1: key = (if v_108 then key_s(them) else caught-fail) in
        {318}let public_key_1: key = (if v_108 then catch-fail(dhexp(basis_1,validkey(g))) else caught-fail) in
        {319}let v_109: bool = not-caught-fail(public_key_1) in
        {320}let basis_2: key = (if v_108 then key_m(them) else caught-fail) in
        {321}let public_key_2: key = (if v_108 then catch-fail(dhexp(basis_2,validkey(g))) else caught-fail) in
        {322}let v_110: bool = not-caught-fail(public_key_2) in
        {323}let v_111: bool = (if v_108 then catch-fail(((valid1_1 && (valid2 && valid3)) && ((rs_3 = getpublickey((if v_109 then keypairpack(validkey(public_key_1),basis_1) else fail-any))) && (rm_3 = getpublickey((if v_110 then keypairpack(validkey(public_key_2),basis_2) else fail-any)))))) else caught-fail) in
        {324}let hs_5: handshakestate = (if v_111 then handshakestatepack(ss_16,s_2,m_2,e_4,rs_3,rm_3,re_3,psk_2,initiator_2) else caught-fail) in
        {325}let (hs_6: handshakestate,plaintext_b: bitstring,valid_6: bool) = (if v_28 then (if v_30 then (if v_33 then (if v_41 then (if v_58 then (if v_75 then (if v_83 then (if v_91 then (if v_108 then (if undo-catch-fail(v_111) then (hs_5,plaintext_6,true) else fail-any) else fail-any) else fail-any) else fail-any) else fail-any) else fail-any) else fail-any) else fail-any) else fail-any) else fail-any) in
        {326}event RecvMsg(me,them,stagepack_b(sid_1),plaintext_b);
        {327}insert statestore(me,them,sid_1,statepack_c(hs_6))
    ) | (
        {468}get statestore(=me,=them,=sid_1,statepack_c(hs_7: handshakestate)) in
        {329}let payload_1: bitstring = msg_c(me,them,sid_1) in
        {330}let v_112: bitstring = catch-fail(handshakestateunpack(hs_7)) in
        {331}let v_113: bool = (not-caught-fail(v_112) && success?(1-proj-9-tuple(v_112))) in
        {332}let initiator_3: bool = (if v_113 then 9-proj-9-tuple(v_112) else caught-fail) in
        {333}let psk_3: key = (if v_113 then 8-proj-9-tuple(v_112) else caught-fail) in
        {334}let re_4: key = (if v_113 then 7-proj-9-tuple(v_112) else caught-fail) in
        {335}let rm_4: key = (if v_113 then 6-proj-9-tuple(v_112) else caught-fail) in
        {336}let rs_4: key = (if v_113 then 5-proj-9-tuple(v_112) else caught-fail) in
        {337}let e_5: keypair = (if v_113 then 4-proj-9-tuple(v_112) else caught-fail) in
        {338}let m_3: keypair = (if v_113 then 3-proj-9-tuple(v_112) else caught-fail) in
        {339}let s_3: keypair = (if v_113 then 2-proj-9-tuple(v_112) else caught-fail) in
        {340}let ss_17: symmetricstate = (if v_113 then 1-proj-9-tuple(v_112) else caught-fail) in
        {341}let v_114: bitstring = (if v_113 then catch-fail((empty,empty,empty,empty)) else caught-fail) in
        {342}let v_115: bool = (not-caught-fail(v_114) && success?(1-proj-4-tuple(v_114))) in
        {343}let ciphertext_4: bitstring = (if v_115 then 4-proj-4-tuple(v_114) else caught-fail) in
        {344}let nm_1: bitstring = (if v_115 then 3-proj-4-tuple(v_114) else caught-fail) in
        {345}let ns_2: bitstring = (if v_115 then 2-proj-4-tuple(v_114) else caught-fail) in
        {346}let ne_5: bitstring = (if v_115 then 1-proj-4-tuple(v_114) else caught-fail) in
        {347}let basis_3: key = (if v_115 then key_m(me) else caught-fail) in
        {348}let public_key_3: key = (if v_115 then catch-fail(dhexp(basis_3,validkey(g))) else caught-fail) in
        {349}let v_116: bool = not-caught-fail(public_key_3) in
        {350}let m_4: keypair = (if v_115 then catch-fail((if v_116 then keypairpack(validkey(public_key_3),basis_3) else fail-any)) else caught-fail) in
        {351}let v_117: bool = not-caught-fail(m_4) in
        {352}let plaintext_7: bitstring = (if v_117 then catch-fail(getpublickey(m_4)) else caught-fail) in
        {353}let v_118: bool = not-caught-fail(plaintext_7) in
        {354}let v_119: bitstring = (if v_118 then catch-fail(symmetricstateunpack(ss_17)) else caught-fail) in
        {355}let v_120: bool = (not-caught-fail(v_119) && success?(1-proj-3-tuple(v_119))) in
        {356}let h_15: bitstring = (if v_120 then 3-proj-3-tuple(v_119) else caught-fail) in
        {357}let ck_18: key = (if v_120 then 2-proj-3-tuple(v_119) else caught-fail) in
        {358}let cs_15: cipherstate = (if v_120 then 1-proj-3-tuple(v_119) else caught-fail) in
        {359}let v_121: bitstring = (if v_120 then catch-fail(cipherstateunpack(cs_15)) else caught-fail) in
        {360}let v_122: bool = (not-caught-fail(v_121) && success?(1-proj-2-tuple(v_121))) in
        {361}let n_8: nonce = (if v_122 then 2-proj-2-tuple(v_121) else caught-fail) in
        {362}let k_9: key = (if v_122 then 1-proj-2-tuple(v_121) else caught-fail) in
        {363}let e_6: bitstring = (if v_122 then encrypt(k_9,n_8,h_15,plaintext_7) else caught-fail) in
        {364}let n_9: nonce = (if v_122 then increment_nonce(n_8) else caught-fail) in
        {365}let v_123: bitstring = (if v_122 then catch-fail(cipherstateunpack(cs_15)) else caught-fail) in
        {366}let v_124: bool = (not-caught-fail(v_123) && success?(1-proj-2-tuple(v_123))) in
        {367}let o_4: nonce = (if v_124 then 2-proj-2-tuple(v_123) else caught-fail) in
        {368}let k_10: key = (if v_124 then 1-proj-2-tuple(v_123) else caught-fail) in
        {369}let csi_8: cipherstate = (if v_122 then catch-fail((if v_124 then cipherstatepack(k_10,n_9) else fail-any)) else caught-fail) in
        {370}let v_125: bool = not-caught-fail(csi_8) in
        {371}let v_126: bitstring = (if v_120 then catch-fail((if v_122 then (if v_125 then (csi_8,e_6) else fail-any) else fail-any)) else caught-fail) in
        {372}let v_127: bool = (not-caught-fail(v_126) && success?(1-proj-2-tuple(v_126))) in
        {373}let ciphertext_5: bitstring = (if v_127 then 2-proj-2-tuple(v_126) else caught-fail) in
        {374}let csi_9: cipherstate = (if v_127 then 1-proj-2-tuple(v_126) else caught-fail) in
        {375}let ss_18: symmetricstate = (if v_127 then symmetricstatepack(csi_9,ck_18,h_15) else caught-fail) in
        {376}let v_128: bitstring = (if v_127 then catch-fail(symmetricstateunpack(ss_18)) else caught-fail) in
        {377}let v_129: bool = (not-caught-fail(v_128) && success?(1-proj-3-tuple(v_128))) in
        {378}let h_16: bitstring = (if v_129 then 3-proj-3-tuple(v_128) else caught-fail) in
        {379}let ck_19: key = (if v_129 then 2-proj-3-tuple(v_128) else caught-fail) in
        {380}let cs_16: cipherstate = (if v_129 then 1-proj-3-tuple(v_128) else caught-fail) in
        {381}let ssi_4: symmetricstate = (if v_127 then catch-fail((if v_129 then symmetricstatepack(cs_16,ck_19,hash(h_16,ciphertext_5)) else fail-any)) else caught-fail) in
        {382}let v_130: bool = not-caught-fail(ssi_4) in
        {383}let v_131: bitstring = (if v_117 then catch-fail((if v_118 then (if v_120 then (if v_127 then (if v_130 then (ssi_4,ciphertext_5) else fail-any) else fail-any) else fail-any) else fail-any)) else caught-fail) in
        {384}let v_132: bool = (not-caught-fail(v_131) && success?(1-proj-2-tuple(v_131))) in
        {385}let nm_2: bitstring = (if v_132 then 2-proj-2-tuple(v_131) else caught-fail) in
        {386}let ss_19: symmetricstate = (if v_132 then 1-proj-2-tuple(v_131) else caught-fail) in
        {387}let v_133: bitstring = (if v_132 then catch-fail(keypairunpack(m_4)) else caught-fail) in
        {388}let v_134: bool = (not-caught-fail(v_133) && success?(1-proj-2-tuple(v_133))) in
        {389}let my_private_key_3: key = (if v_134 then 2-proj-2-tuple(v_133) else caught-fail) in
        {390}let my_public_key_3: key = (if v_134 then 1-proj-2-tuple(v_133) else caught-fail) in
        {391}let input_key_material_3: key = (if v_132 then catch-fail((if v_134 then dhexp(my_private_key_3,re_4) else fail-any)) else caught-fail) in
        {392}let v_135: bool = not-caught-fail(input_key_material_3) in
        {393}let v_136: bitstring = (if v_135 then catch-fail(symmetricstateunpack(ss_19)) else caught-fail) in
        {394}let v_137: bool = (not-caught-fail(v_136) && success?(1-proj-3-tuple(v_136))) in
        {395}let h_17: bitstring = (if v_137 then 3-proj-3-tuple(v_136) else caught-fail) in
        {396}let ck_20: key = (if v_137 then 2-proj-3-tuple(v_136) else caught-fail) in
        {397}let cs_17: cipherstate = (if v_137 then 1-proj-3-tuple(v_136) else caught-fail) in
        {398}let output1_3: key = (if v_137 then hmac_hash1(ck_20,input_key_material_3) else caught-fail) in
        {399}let output2_3: key = (if v_137 then hmac_hash2(ck_20,input_key_material_3) else caught-fail) in
        {400}let output3_3: key = (if v_137 then hmac_hash3(ck_20,input_key_material_3) else caught-fail) in
        {401}let v_138: bitstring = (if v_137 then catch-fail((output1_3,output2_3,output3_3)) else caught-fail) in
        {402}let v_139: bool = (not-caught-fail(v_138) && success?(1-proj-3-tuple(v_138))) in
        {403}let output_2: key = (if v_139 then 3-proj-3-tuple(v_138) else caught-fail) in
        {404}let temp_k_3: key = (if v_139 then 2-proj-3-tuple(v_138) else caught-fail) in
        {405}let ck_21: key = (if v_139 then 1-proj-3-tuple(v_138) else caught-fail) in
        {406}let ss_20: symmetricstate = (if v_132 then catch-fail((if v_135 then (if v_137 then (if v_139 then symmetricstatepack(cipherstatepack(temp_k_3,minnonce),ck_21,h_17) else fail-any) else fail-any) else fail-any)) else caught-fail) in
        {407}let v_140: bool = not-caught-fail(ss_20) in
        {408}let v_141: bitstring = (if v_140 then catch-fail(symmetricstateunpack(ss_20)) else caught-fail) in
        {409}let v_142: bool = (not-caught-fail(v_141) && success?(1-proj-3-tuple(v_141))) in
        {410}let h_18: bitstring = (if v_142 then 3-proj-3-tuple(v_141) else caught-fail) in
        {411}let ck_22: key = (if v_142 then 2-proj-3-tuple(v_141) else caught-fail) in
        {412}let cs_18: cipherstate = (if v_142 then 1-proj-3-tuple(v_141) else caught-fail) in
        {413}let v_143: bitstring = (if v_142 then catch-fail(cipherstateunpack(cs_18)) else caught-fail) in
        {414}let v_144: bool = (not-caught-fail(v_143) && success?(1-proj-2-tuple(v_143))) in
        {415}let n_10: nonce = (if v_144 then 2-proj-2-tuple(v_143) else caught-fail) in
        {416}let k_11: key = (if v_144 then 1-proj-2-tuple(v_143) else caught-fail) in
        {417}let e_7: bitstring = (if v_144 then encrypt(k_11,n_10,h_18,payload_1) else caught-fail) in
        {418}let n_11: nonce = (if v_144 then increment_nonce(n_10) else caught-fail) in
        {419}let v_145: bitstring = (if v_144 then catch-fail(cipherstateunpack(cs_18)) else caught-fail) in
        {420}let v_146: bool = (not-caught-fail(v_145) && success?(1-proj-2-tuple(v_145))) in
        {421}let o_5: nonce = (if v_146 then 2-proj-2-tuple(v_145) else caught-fail) in
        {422}let k_12: key = (if v_146 then 1-proj-2-tuple(v_145) else caught-fail) in
        {423}let csi_10: cipherstate = (if v_144 then catch-fail((if v_146 then cipherstatepack(k_12,n_11) else fail-any)) else caught-fail) in
        {424}let v_147: bool = not-caught-fail(csi_10) in
        {425}let v_148: bitstring = (if v_142 then catch-fail((if v_144 then (if v_147 then (csi_10,e_7) else fail-any) else fail-any)) else caught-fail) in
        {426}let v_149: bool = (not-caught-fail(v_148) && success?(1-proj-2-tuple(v_148))) in
        {427}let ciphertext_6: bitstring = (if v_149 then 2-proj-2-tuple(v_148) else caught-fail) in
        {428}let csi_11: cipherstate = (if v_149 then 1-proj-2-tuple(v_148) else caught-fail) in
        {429}let ss_21: symmetricstate = (if v_149 then symmetricstatepack(csi_11,ck_22,h_18) else caught-fail) in
        {430}let v_150: bitstring = (if v_149 then catch-fail(symmetricstateunpack(ss_21)) else caught-fail) in
        {431}let v_151: bool = (not-caught-fail(v_150) && success?(1-proj-3-tuple(v_150))) in
        {432}let h_19: bitstring = (if v_151 then 3-proj-3-tuple(v_150) else caught-fail) in
        {433}let ck_23: key = (if v_151 then 2-proj-3-tuple(v_150) else caught-fail) in
        {434}let cs_19: cipherstate = (if v_151 then 1-proj-3-tuple(v_150) else caught-fail) in
        {435}let ssi_5: symmetricstate = (if v_149 then catch-fail((if v_151 then symmetricstatepack(cs_19,ck_23,hash(h_19,ciphertext_6)) else fail-any)) else caught-fail) in
        {436}let v_152: bool = not-caught-fail(ssi_5) in
        {437}let v_153: bitstring = (if v_140 then catch-fail((if v_142 then (if v_149 then (if v_152 then (ssi_5,ciphertext_6) else fail-any) else fail-any) else fail-any)) else caught-fail) in
        {438}let v_154: bool = (not-caught-fail(v_153) && success?(1-proj-2-tuple(v_153))) in
        {439}let ciphertext_7: bitstring = (if v_154 then 2-proj-2-tuple(v_153) else caught-fail) in
        {440}let ss_22: symmetricstate = (if v_154 then 1-proj-2-tuple(v_153) else caught-fail) in
        {441}let hs_8: handshakestate = (if v_154 then handshakestatepack(ss_22,s_3,m_4,e_5,rs_4,rm_4,re_4,psk_3,initiator_3) else caught-fail) in
        {442}let message_buffer_1: bitstring = (if v_154 then concat3(ne_5,nm_2,ciphertext_7) else caught-fail) in
        {443}let v_155: bitstring = (if v_154 then catch-fail(symmetricstateunpack(ss_22)) else caught-fail) in
        {444}let v_156: bool = (not-caught-fail(v_155) && success?(1-proj-3-tuple(v_155))) in
        {445}let h_20: bitstring = (if v_156 then 3-proj-3-tuple(v_155) else caught-fail) in
        {446}let ck_24: key = (if v_156 then 2-proj-3-tuple(v_155) else caught-fail) in
        {447}let cs_20: cipherstate = (if v_156 then 1-proj-3-tuple(v_155) else caught-fail) in
        {448}let input_key_material_4: key = (if v_156 then zero else caught-fail) in
        {449}let output1_4: key = (if v_156 then hmac_hash1(ck_24,input_key_material_4) else caught-fail) in
        {450}let output2_4: key = (if v_156 then hmac_hash2(ck_24,input_key_material_4) else caught-fail) in
        {451}let output3_4: key = (if v_156 then hmac_hash3(ck_24,input_key_material_4) else caught-fail) in
        {452}let v_157: bitstring = (if v_156 then catch-fail((output1_4,output2_4,output3_4)) else caught-fail) in
        {453}let v_158: bool = (not-caught-fail(v_157) && success?(1-proj-3-tuple(v_157))) in
        {454}let temp_k3: key = (if v_158 then 3-proj-3-tuple(v_157) else caught-fail) in
        {455}let temp_k2: key = (if v_158 then 2-proj-3-tuple(v_157) else caught-fail) in
        {456}let temp_k1: key = (if v_158 then 1-proj-3-tuple(v_157) else caught-fail) in
        {457}let cs1: cipherstate = (if v_158 then cipherstatepack(temp_k1,minnonce) else caught-fail) in
        {458}let cs2: cipherstate = (if v_158 then cipherstatepack(temp_k2,minnonce) else caught-fail) in
        {459}let v_159: bitstring = (if v_154 then catch-fail((if v_156 then (if v_158 then (ss_22,cs1,cs2) else fail-any) else fail-any)) else caught-fail) in
        {460}let v_160: bool = (not-caught-fail(v_159) && success?(1-proj-3-tuple(v_159))) in
        {461}let cs2_1: cipherstate = (if v_160 then 3-proj-3-tuple(v_159) else caught-fail) in
        {462}let cs1_1: cipherstate = (if v_160 then 2-proj-3-tuple(v_159) else caught-fail) in
        {463}let ssi_6: symmetricstate = (if v_160 then 1-proj-3-tuple(v_159) else caught-fail) in
        {464}let (hs_9: handshakestate,message_c: bitstring,cs1_2: cipherstate,cs2_2: cipherstate) = (if v_113 then (if v_115 then (if v_117 then (if v_132 then (if v_140 then (if v_154 then (if v_160 then (hs_8,message_buffer_1,cs1_1,cs2_1) else fail-any) else fail-any) else fail-any) else fail-any) else fail-any) else fail-any) else fail-any) in
        {465}event SendMsg(me,them,stagepack_c(sid_1),msg_c(me,them,sid_1));
        {466}insert statestore(me,them,sid_1,statepack_d(hs_9,cs1_2,cs2_2));
        {467}out(pub, message_c)
    ) | (
        {469}!
        {535}get statestore(=me,=them,=sid_1,statepack_d(hs_10: handshakestate,cs1_3: cipherstate,cs2_3: cipherstate)) in
        {470}let hs_11: handshakestate = handshakestatesetcs(hs_10,cs2_3) in
        {471}in(pub, message_d: bitstring);
        {472}let v_161: bitstring = catch-fail(handshakestateunpack(hs_11)) in
        {473}let v_162: bool = (not-caught-fail(v_161) && success?(1-proj-9-tuple(v_161))) in
        {474}let initiator_4: bool = (if v_162 then 9-proj-9-tuple(v_161) else caught-fail) in
        {475}let psk_4: key = (if v_162 then 8-proj-9-tuple(v_161) else caught-fail) in
        {476}let re_5: key = (if v_162 then 7-proj-9-tuple(v_161) else caught-fail) in
        {477}let rm_5: key = (if v_162 then 6-proj-9-tuple(v_161) else caught-fail) in
        {478}let rs_5: key = (if v_162 then 5-proj-9-tuple(v_161) else caught-fail) in
        {479}let e_8: keypair = (if v_162 then 4-proj-9-tuple(v_161) else caught-fail) in
        {480}let m_5: keypair = (if v_162 then 3-proj-9-tuple(v_161) else caught-fail) in
        {481}let s_4: keypair = (if v_162 then 2-proj-9-tuple(v_161) else caught-fail) in
        {482}let ss_23: symmetricstate = (if v_162 then 1-proj-9-tuple(v_161) else caught-fail) in
        {483}let v_163: bitstring = (if v_162 then catch-fail(deconcat3(message_d)) else caught-fail) in
        {484}let v_164: bool = (not-caught-fail(v_163) && success?(1-proj-3-tuple(v_163))) in
        {485}let ciphertext_8: bitstring = (if v_164 then 3-proj-3-tuple(v_163) else caught-fail) in
        {486}let ns_3: bitstring = (if v_164 then 2-proj-3-tuple(v_163) else caught-fail) in
        {487}let ne_6: bitstring = (if v_164 then 1-proj-3-tuple(v_163) else caught-fail) in
        {488}let valid1_2: bool = (if v_164 then true else caught-fail) in
        {489}let v_165: bitstring = (if v_164 then catch-fail(symmetricstateunpack(ss_23)) else caught-fail) in
        {490}let v_166: bool = (not-caught-fail(v_165) && success?(1-proj-3-tuple(v_165))) in
        {491}let h_21: bitstring = (if v_166 then 3-proj-3-tuple(v_165) else caught-fail) in
        {492}let ck_25: key = (if v_166 then 2-proj-3-tuple(v_165) else caught-fail) in
        {493}let cs_21: cipherstate = (if v_166 then 1-proj-3-tuple(v_165) else caught-fail) in
        {494}let v_167: bitstring = (if v_166 then catch-fail(cipherstateunpack(cs_21)) else caught-fail) in
        {495}let v_168: bool = (not-caught-fail(v_167) && success?(1-proj-2-tuple(v_167))) in
        {496}let n_12: nonce = (if v_168 then 2-proj-2-tuple(v_167) else caught-fail) in
        {497}let k_13: key = (if v_168 then 1-proj-2-tuple(v_167) else caught-fail) in
        {498}let d_3: aead = (if v_168 then catch-fail(decrypt(k_13,n_12,h_21,ciphertext_8)) else caught-fail) in
        {499}let v_169: bool = not-caught-fail(d_3) in
        {500}let v_170: bitstring = (if v_169 then catch-fail(aeadunpack(d_3)) else caught-fail) in
        {501}let v_171: bool = (not-caught-fail(v_170) && success?(1-proj-3-tuple(v_170))) in
        {502}let plaintext_8: bitstring = (if v_171 then 3-proj-3-tuple(v_170) else caught-fail) in
        {503}let adi_3: bitstring = (if v_171 then 2-proj-3-tuple(v_170) else caught-fail) in
        {504}let valid_7: bool = (if v_171 then 1-proj-3-tuple(v_170) else caught-fail) in
        {505}let n_13: nonce = (if v_171 then increment_nonce(n_12) else caught-fail) in
        {506}let v_172: bitstring = (if v_171 then catch-fail(cipherstateunpack(cs_21)) else caught-fail) in
        {507}let v_173: bool = (not-caught-fail(v_172) && success?(1-proj-2-tuple(v_172))) in
        {508}let o_6: nonce = (if v_173 then 2-proj-2-tuple(v_172) else caught-fail) in
        {509}let k_14: key = (if v_173 then 1-proj-2-tuple(v_172) else caught-fail) in
        {510}let csi_12: cipherstate = (if v_171 then catch-fail((if v_173 then cipherstatepack(k_14,n_13) else fail-any)) else caught-fail) in
        {511}let v_174: bool = not-caught-fail(csi_12) in
        {512}let v_175: bitstring = (if v_166 then catch-fail((if v_168 then (if v_169 then (if v_171 then (if v_174 then (csi_12,plaintext_8,valid_7) else fail-any) else fail-any) else fail-any) else fail-any)) else caught-fail) in
        {513}let v_176: bool = (not-caught-fail(v_175) && success?(1-proj-3-tuple(v_175))) in
        {514}let valid_8: bool = (if v_176 then 3-proj-3-tuple(v_175) else caught-fail) in
        {515}let plaintext_9: bitstring = (if v_176 then 2-proj-3-tuple(v_175) else caught-fail) in
        {516}let csi_13: cipherstate = (if v_176 then 1-proj-3-tuple(v_175) else caught-fail) in
        {517}let ss_24: symmetricstate = (if v_176 then symmetricstatepack(csi_13,ck_25,h_21) else caught-fail) in
        {518}let v_177: bitstring = (if v_176 then catch-fail(symmetricstateunpack(ss_24)) else caught-fail) in
        {519}let v_178: bool = (not-caught-fail(v_177) && success?(1-proj-3-tuple(v_177))) in
        {520}let h_22: bitstring = (if v_178 then 3-proj-3-tuple(v_177) else caught-fail) in
        {521}let ck_26: key = (if v_178 then 2-proj-3-tuple(v_177) else caught-fail) in
        {522}let cs_22: cipherstate = (if v_178 then 1-proj-3-tuple(v_177) else caught-fail) in
        {523}let ssi_7: symmetricstate = (if v_176 then catch-fail((if v_178 then symmetricstatepack(cs_22,ck_26,hash(h_22,ciphertext_8)) else fail-any)) else caught-fail) in
        {524}let v_179: bool = not-caught-fail(ssi_7) in
        {525}let v_180: bitstring = (if v_164 then catch-fail((if v_166 then (if v_176 then (if v_179 then (ssi_7,plaintext_9,valid_8) else fail-any) else fail-any) else fail-any)) else caught-fail) in
        {526}let v_181: bool = (not-caught-fail(v_180) && success?(1-proj-3-tuple(v_180))) in
        {527}let valid2_1: bool = (if v_181 then 3-proj-3-tuple(v_180) else caught-fail) in
        {528}let plaintext_10: bitstring = (if v_181 then 2-proj-3-tuple(v_180) else caught-fail) in
        {529}let ss_25: symmetricstate = (if v_181 then 1-proj-3-tuple(v_180) else caught-fail) in
        {530}let v_182: bool = (if v_181 then catch-fail((valid1_2 && valid2_1)) else caught-fail) in
        {531}let hs_12: handshakestate = (if v_182 then handshakestatepack(ss_25,s_4,m_5,e_8,rs_5,rm_5,re_5,psk_4,initiator_4) else caught-fail) in
        {532}let (hs_13: handshakestate,plaintext_d: bitstring,valid_9: bool) = (if v_162 then (if v_164 then (if v_181 then (if undo-catch-fail(v_182) then (hs_12,plaintext_10,true) else fail-any) else fail-any) else fail-any) else fail-any) in
        {533}event RecvMsg(me,them,stagepack_d(sid_1),plaintext_d);
        {534}insert statestore(me,them,sid_1,statepack_e(hs_13,cs1_3,handshakestategetcs(hs_13)))
    ) | (
        {536}!
        {593}get statestore(=me,=them,=sid_1,statepack_e(hs_14: handshakestate,cs1_4: cipherstate,cs2_4: cipherstate)) in
        {537}let hs_15: handshakestate = handshakestatesetcs(hs_14,cs1_4) in
        {538}let payload_2: bitstring = msg_e(me,them,sid_1) in
        {539}let v_183: bitstring = catch-fail(handshakestateunpack(hs_15)) in
        {540}let v_184: bool = (not-caught-fail(v_183) && success?(1-proj-9-tuple(v_183))) in
        {541}let initiator_5: bool = (if v_184 then 9-proj-9-tuple(v_183) else caught-fail) in
        {542}let psk_5: key = (if v_184 then 8-proj-9-tuple(v_183) else caught-fail) in
        {543}let re_6: key = (if v_184 then 7-proj-9-tuple(v_183) else caught-fail) in
        {544}let rm_6: key = (if v_184 then 6-proj-9-tuple(v_183) else caught-fail) in
        {545}let rs_6: key = (if v_184 then 5-proj-9-tuple(v_183) else caught-fail) in
        {546}let e_9: keypair = (if v_184 then 4-proj-9-tuple(v_183) else caught-fail) in
        {547}let m_6: keypair = (if v_184 then 3-proj-9-tuple(v_183) else caught-fail) in
        {548}let s_5: keypair = (if v_184 then 2-proj-9-tuple(v_183) else caught-fail) in
        {549}let ss_26: symmetricstate = (if v_184 then 1-proj-9-tuple(v_183) else caught-fail) in
        {550}let v_185: bitstring = (if v_184 then catch-fail((empty,empty,empty)) else caught-fail) in
        {551}let v_186: bool = (not-caught-fail(v_185) && success?(1-proj-3-tuple(v_185))) in
        {552}let ciphertext_9: bitstring = (if v_186 then 3-proj-3-tuple(v_185) else caught-fail) in
        {553}let ns_4: bitstring = (if v_186 then 2-proj-3-tuple(v_185) else caught-fail) in
        {554}let ne_7: bitstring = (if v_186 then 1-proj-3-tuple(v_185) else caught-fail) in
        {555}let v_187: bitstring = (if v_186 then catch-fail(symmetricstateunpack(ss_26)) else caught-fail) in
        {556}let v_188: bool = (not-caught-fail(v_187) && success?(1-proj-3-tuple(v_187))) in
        {557}let h_23: bitstring = (if v_188 then 3-proj-3-tuple(v_187) else caught-fail) in
        {558}let ck_27: key = (if v_188 then 2-proj-3-tuple(v_187) else caught-fail) in
        {559}let cs_23: cipherstate = (if v_188 then 1-proj-3-tuple(v_187) else caught-fail) in
        {560}let v_189: bitstring = (if v_188 then catch-fail(cipherstateunpack(cs_23)) else caught-fail) in
        {561}let v_190: bool = (not-caught-fail(v_189) && success?(1-proj-2-tuple(v_189))) in
        {562}let n_14: nonce = (if v_190 then 2-proj-2-tuple(v_189) else caught-fail) in
        {563}let k_15: key = (if v_190 then 1-proj-2-tuple(v_189) else caught-fail) in
        {564}let e_10: bitstring = (if v_190 then encrypt(k_15,n_14,h_23,payload_2) else caught-fail) in
        {565}let n_15: nonce = (if v_190 then increment_nonce(n_14) else caught-fail) in
        {566}let v_191: bitstring = (if v_190 then catch-fail(cipherstateunpack(cs_23)) else caught-fail) in
        {567}let v_192: bool = (not-caught-fail(v_191) && success?(1-proj-2-tuple(v_191))) in
        {568}let o_7: nonce = (if v_192 then 2-proj-2-tuple(v_191) else caught-fail) in
        {569}let k_16: key = (if v_192 then 1-proj-2-tuple(v_191) else caught-fail) in
        {570}let csi_14: cipherstate = (if v_190 then catch-fail((if v_192 then cipherstatepack(k_16,n_15) else fail-any)) else caught-fail) in
        {571}let v_193: bool = not-caught-fail(csi_14) in
        {572}let v_194: bitstring = (if v_188 then catch-fail((if v_190 then (if v_193 then (csi_14,e_10) else fail-any) else fail-any)) else caught-fail) in
        {573}let v_195: bool = (not-caught-fail(v_194) && success?(1-proj-2-tuple(v_194))) in
        {574}let ciphertext_10: bitstring = (if v_195 then 2-proj-2-tuple(v_194) else caught-fail) in
        {575}let csi_15: cipherstate = (if v_195 then 1-proj-2-tuple(v_194) else caught-fail) in
        {576}let ss_27: symmetricstate = (if v_195 then symmetricstatepack(csi_15,ck_27,h_23) else caught-fail) in
        {577}let v_196: bitstring = (if v_195 then catch-fail(symmetricstateunpack(ss_27)) else caught-fail) in
        {578}let v_197: bool = (not-caught-fail(v_196) && success?(1-proj-3-tuple(v_196))) in
        {579}let h_24: bitstring = (if v_197 then 3-proj-3-tuple(v_196) else caught-fail) in
        {580}let ck_28: key = (if v_197 then 2-proj-3-tuple(v_196) else caught-fail) in
        {581}let cs_24: cipherstate = (if v_197 then 1-proj-3-tuple(v_196) else caught-fail) in
        {582}let ssi_8: symmetricstate = (if v_195 then catch-fail((if v_197 then symmetricstatepack(cs_24,ck_28,hash(h_24,ciphertext_10)) else fail-any)) else caught-fail) in
        {583}let v_198: bool = not-caught-fail(ssi_8) in
        {584}let v_199: bitstring = (if v_186 then catch-fail((if v_188 then (if v_195 then (if v_198 then (ssi_8,ciphertext_10) else fail-any) else fail-any) else fail-any)) else caught-fail) in
        {585}let v_200: bool = (not-caught-fail(v_199) && success?(1-proj-2-tuple(v_199))) in
        {586}let ciphertext_11: bitstring = (if v_200 then 2-proj-2-tuple(v_199) else caught-fail) in
        {587}let ss_28: symmetricstate = (if v_200 then 1-proj-2-tuple(v_199) else caught-fail) in
        {588}let hs_16: handshakestate = (if v_200 then handshakestatepack(ss_28,s_5,m_6,e_9,rs_6,rm_6,re_6,psk_5,initiator_5) else caught-fail) in
        {589}let message_buffer_2: bitstring = (if v_200 then concat3(ne_7,ns_4,ciphertext_11) else caught-fail) in
        {590}let (hs_17: handshakestate,message_e: bitstring) = (if v_184 then (if v_186 then (if v_200 then (hs_16,message_buffer_2) else fail-any) else fail-any) else fail-any) in
        {591}event SendMsg(me,them,stagepack_e(sid_1),msg_e(me,them,sid_1));
        {592}out(pub, message_e)
    ) | (
        {594}event LeakS(phase0,me);
        {595}event LeakM(phase0,me);
        {596}out(pub, (key_s(me),key_m(me)))
    ) | (
        {597}phase 1;
        {598}event LeakS(phase1,me);
        {599}event LeakM(phase1,me);
        {600}out(pub, (key_s(me),key_m(me)))
    )
) | (
    {601}let me_1: principal = alice in
    {602}let them_1: principal = charlie in
    {603}let sid_2: sessionid = sid in
    {604}let s_6: keypair = keypairpack(empty,empty) in
    {605}let m_7: keypair = keypairpack(empty,empty) in
    {606}out(pub, (getpublickey(s_6),getpublickey(m_7)));
    (
        {607}let e_11: keypair = keypairpack(empty,empty) in
        {608}let rs_7: key = empty in
        {609}let rm_7: key = empty in
        {610}let re_7: key = empty in
        {611}let prologue_1: bitstring = empty in
        {612}let psk_6: key = empty in
        {613}let protocol_name_1: bitstring = somename in
        {614}let h_25: bitstring = hash(protocol_name_1,empty) in
        {615}let ck_29: key = h_25 in
        {616}let k_17: key = empty in
        {617}let cs_25: cipherstate = cipherstatepack(k_17,minnonce) in
        {618}let ss_29: symmetricstate = symmetricstatepack(cs_25,ck_29,h_25) in
        {619}let v_201: bitstring = catch-fail(symmetricstateunpack(ss_29)) in
        {620}let v_202: bool = (not-caught-fail(v_201) && success?(1-proj-3-tuple(v_201))) in
        {621}let h_26: bitstring = (if v_202 then 3-proj-3-tuple(v_201) else caught-fail) in
        {622}let ck_30: key = (if v_202 then 2-proj-3-tuple(v_201) else caught-fail) in
        {623}let cs_26: cipherstate = (if v_202 then 1-proj-3-tuple(v_201) else caught-fail) in
        {624}let ss_30: symmetricstate = catch-fail((if v_202 then symmetricstatepack(cs_26,ck_30,hash(h_26,prologue_1)) else fail-any)) in
        {625}let v_203: bool = not-caught-fail(ss_30) in
        {626}let hs_18: handshakestate = (if v_203 then handshakestatepack(ss_30,s_6,m_7,e_11,rs_7,rm_7,re_7,psk_6,true) else fail-any) in
        {627}insert statestore(me_1,them_1,sid_2,statepack_a(hs_18))
    ) | (
        {698}get statestore(=me_1,=them_1,=sid_2,statepack_a(hs_19: handshakestate)) in
        {628}let payload_3: bitstring = msg_a(me_1,them_1,sid_2) in
        {629}let v_204: bitstring = catch-fail(handshakestateunpack(hs_19)) in
        {630}let v_205: bool = (not-caught-fail(v_204) && success?(1-proj-9-tuple(v_204))) in
        {631}let initiator_6: bool = (if v_205 then 9-proj-9-tuple(v_204) else caught-fail) in
        {632}let psk_7: key = (if v_205 then 8-proj-9-tuple(v_204) else caught-fail) in
        {633}let re_8: key = (if v_205 then 7-proj-9-tuple(v_204) else caught-fail) in
        {634}let rm_8: key = (if v_205 then 6-proj-9-tuple(v_204) else caught-fail) in
        {635}let rs_8: key = (if v_205 then 5-proj-9-tuple(v_204) else caught-fail) in
        {636}let e_12: keypair = (if v_205 then 4-proj-9-tuple(v_204) else caught-fail) in
        {637}let m_8: keypair = (if v_205 then 3-proj-9-tuple(v_204) else caught-fail) in
        {638}let s_7: keypair = (if v_205 then 2-proj-9-tuple(v_204) else caught-fail) in
        {639}let ss_31: symmetricstate = (if v_205 then 1-proj-9-tuple(v_204) else caught-fail) in
        {640}let v_206: bitstring = (if v_205 then catch-fail((empty,empty,empty)) else caught-fail) in
        {641}let v_207: bool = (not-caught-fail(v_206) && success?(1-proj-3-tuple(v_206))) in
        {642}let ciphertext_12: bitstring = (if v_207 then 3-proj-3-tuple(v_206) else caught-fail) in
        {643}let ns_5: bitstring = (if v_207 then 2-proj-3-tuple(v_206) else caught-fail) in
        {644}let ne_8: bitstring = (if v_207 then 1-proj-3-tuple(v_206) else caught-fail) in
        {645}let basis_4: key = (if v_207 then key_e(me_1,them_1,sid_2) else caught-fail) in
        {646}let public_key_4: key = (if v_207 then catch-fail(dhexp(basis_4,validkey(g))) else caught-fail) in
        {647}let v_208: bool = not-caught-fail(public_key_4) in
        {648}let e_13: keypair = (if v_207 then catch-fail((if v_208 then keypairpack(validkey(public_key_4),basis_4) else fail-any)) else caught-fail) in
        {649}let v_209: bool = not-caught-fail(e_13) in
        {650}let ne_9: bitstring = (if v_209 then catch-fail(getpublickey(e_13)) else caught-fail) in
        {651}let v_210: bool = not-caught-fail(ne_9) in
        {652}let v_211: bitstring = (if v_210 then catch-fail(symmetricstateunpack(ss_31)) else caught-fail) in
        {653}let v_212: bool = (not-caught-fail(v_211) && success?(1-proj-3-tuple(v_211))) in
        {654}let h_27: bitstring = (if v_212 then 3-proj-3-tuple(v_211) else caught-fail) in
        {655}let ck_31: key = (if v_212 then 2-proj-3-tuple(v_211) else caught-fail) in
        {656}let cs_27: cipherstate = (if v_212 then 1-proj-3-tuple(v_211) else caught-fail) in
        {657}let ss_32: symmetricstate = (if v_210 then catch-fail((if v_212 then symmetricstatepack(cs_27,ck_31,hash(h_27,ne_9)) else fail-any)) else caught-fail) in
        {658}let v_213: bool = not-caught-fail(ss_32) in
        {659}let v_214: bitstring = (if v_213 then catch-fail(symmetricstateunpack(ss_32)) else caught-fail) in
        {660}let v_215: bool = (not-caught-fail(v_214) && success?(1-proj-3-tuple(v_214))) in
        {661}let h_28: bitstring = (if v_215 then 3-proj-3-tuple(v_214) else caught-fail) in
        {662}let ck_32: key = (if v_215 then 2-proj-3-tuple(v_214) else caught-fail) in
        {663}let cs_28: cipherstate = (if v_215 then 1-proj-3-tuple(v_214) else caught-fail) in
        {664}let v_216: bitstring = (if v_215 then catch-fail(cipherstateunpack(cs_28)) else caught-fail) in
        {665}let v_217: bool = (not-caught-fail(v_216) && success?(1-proj-2-tuple(v_216))) in
        {666}let n_16: nonce = (if v_217 then 2-proj-2-tuple(v_216) else caught-fail) in
        {667}let k_18: key = (if v_217 then 1-proj-2-tuple(v_216) else caught-fail) in
        {668}let e_14: bitstring = (if v_217 then encrypt(k_18,n_16,h_28,payload_3) else caught-fail) in
        {669}let n_17: nonce = (if v_217 then increment_nonce(n_16) else caught-fail) in
        {670}let v_218: bitstring = (if v_217 then catch-fail(cipherstateunpack(cs_28)) else caught-fail) in
        {671}let v_219: bool = (not-caught-fail(v_218) && success?(1-proj-2-tuple(v_218))) in
        {672}let o_8: nonce = (if v_219 then 2-proj-2-tuple(v_218) else caught-fail) in
        {673}let k_19: key = (if v_219 then 1-proj-2-tuple(v_218) else caught-fail) in
        {674}let csi_16: cipherstate = (if v_217 then catch-fail((if v_219 then cipherstatepack(k_19,n_17) else fail-any)) else caught-fail) in
        {675}let v_220: bool = not-caught-fail(csi_16) in
        {676}let v_221: bitstring = (if v_215 then catch-fail((if v_217 then (if v_220 then (csi_16,e_14) else fail-any) else fail-any)) else caught-fail) in
        {677}let v_222: bool = (not-caught-fail(v_221) && success?(1-proj-2-tuple(v_221))) in
        {678}let ciphertext_13: bitstring = (if v_222 then 2-proj-2-tuple(v_221) else caught-fail) in
        {679}let csi_17: cipherstate = (if v_222 then 1-proj-2-tuple(v_221) else caught-fail) in
        {680}let ss_33: symmetricstate = (if v_222 then symmetricstatepack(csi_17,ck_32,h_28) else caught-fail) in
        {681}let v_223: bitstring = (if v_222 then catch-fail(symmetricstateunpack(ss_33)) else caught-fail) in
        {682}let v_224: bool = (not-caught-fail(v_223) && success?(1-proj-3-tuple(v_223))) in
        {683}let h_29: bitstring = (if v_224 then 3-proj-3-tuple(v_223) else caught-fail) in
        {684}let ck_33: key = (if v_224 then 2-proj-3-tuple(v_223) else caught-fail) in
        {685}let cs_29: cipherstate = (if v_224 then 1-proj-3-tuple(v_223) else caught-fail) in
        {686}let ssi_9: symmetricstate = (if v_222 then catch-fail((if v_224 then symmetricstatepack(cs_29,ck_33,hash(h_29,ciphertext_13)) else fail-any)) else caught-fail) in
        {687}let v_225: bool = not-caught-fail(ssi_9) in
        {688}let v_226: bitstring = (if v_213 then catch-fail((if v_215 then (if v_222 then (if v_225 then (ssi_9,ciphertext_13) else fail-any) else fail-any) else fail-any)) else caught-fail) in
        {689}let v_227: bool = (not-caught-fail(v_226) && success?(1-proj-2-tuple(v_226))) in
        {690}let ciphertext_14: bitstring = (if v_227 then 2-proj-2-tuple(v_226) else caught-fail) in
        {691}let ss_34: symmetricstate = (if v_227 then 1-proj-2-tuple(v_226) else caught-fail) in
        {692}let hs_20: handshakestate = (if v_227 then handshakestatepack(ss_34,s_7,m_8,e_13,rs_8,rm_8,re_8,psk_7,initiator_6) else caught-fail) in
        {693}let message_buffer_3: bitstring = (if v_227 then concat3(ne_9,ns_5,ciphertext_14) else caught-fail) in
        {694}let (hs_21: handshakestate,message_a_1: bitstring) = (if v_205 then (if v_207 then (if v_209 then (if v_210 then (if v_213 then (if v_227 then (hs_20,message_buffer_3) else fail-any) else fail-any) else fail-any) else fail-any) else fail-any) else fail-any) in
        {695}event SendMsg(me_1,them_1,stagepack_a(sid_2),msg_a(me_1,them_1,sid_2));
        {696}insert statestore(me_1,them_1,sid_2,statepack_b(hs_21));
        {697}out(pub, message_a_1)
    ) | (
        {925}get statestore(=me_1,=them_1,=sid_2,statepack_b(hs_22: handshakestate)) in
        {699}in(pub, message_b_1: bitstring);
        {700}let v_228: bitstring = catch-fail(handshakestateunpack(hs_22)) in
        {701}let v_229: bool = (not-caught-fail(v_228) && success?(1-proj-9-tuple(v_228))) in
        {702}let initiator_7: bool = (if v_229 then 9-proj-9-tuple(v_228) else caught-fail) in
        {703}let psk_8: key = (if v_229 then 8-proj-9-tuple(v_228) else caught-fail) in
        {704}let re_9: key = (if v_229 then 7-proj-9-tuple(v_228) else caught-fail) in
        {705}let rm_9: key = (if v_229 then 6-proj-9-tuple(v_228) else caught-fail) in
        {706}let rs_9: key = (if v_229 then 5-proj-9-tuple(v_228) else caught-fail) in
        {707}let e_15: keypair = (if v_229 then 4-proj-9-tuple(v_228) else caught-fail) in
        {708}let m_9: keypair = (if v_229 then 3-proj-9-tuple(v_228) else caught-fail) in
        {709}let s_8: keypair = (if v_229 then 2-proj-9-tuple(v_228) else caught-fail) in
        {710}let ss_35: symmetricstate = (if v_229 then 1-proj-9-tuple(v_228) else caught-fail) in
        {711}let v_230: bitstring = (if v_229 then catch-fail(deconcat4(message_b_1)) else caught-fail) in
        {712}let v_231: bool = (not-caught-fail(v_230) && success?(1-proj-4-tuple(v_230))) in
        {713}let ciphertext_15: bitstring = (if v_231 then 4-proj-4-tuple(v_230) else caught-fail) in
        {714}let nm_3: bitstring = (if v_231 then 3-proj-4-tuple(v_230) else caught-fail) in
        {715}let ns_6: bitstring = (if v_231 then 2-proj-4-tuple(v_230) else caught-fail) in
        {716}let ne_10: bitstring = (if v_231 then 1-proj-4-tuple(v_230) else caught-fail) in
        {717}let valid1_3: bool = (if v_231 then true else caught-fail) in
        {718}let re_10: key = (if v_231 then ne_10 else caught-fail) in
        {719}let v_232: bitstring = (if v_231 then catch-fail(symmetricstateunpack(ss_35)) else caught-fail) in
        {720}let v_233: bool = (not-caught-fail(v_232) && success?(1-proj-3-tuple(v_232))) in
        {721}let h_30: bitstring = (if v_233 then 3-proj-3-tuple(v_232) else caught-fail) in
        {722}let ck_34: key = (if v_233 then 2-proj-3-tuple(v_232) else caught-fail) in
        {723}let cs_30: cipherstate = (if v_233 then 1-proj-3-tuple(v_232) else caught-fail) in
        {724}let ss_36: symmetricstate = (if v_231 then catch-fail((if v_233 then symmetricstatepack(cs_30,ck_34,hash(h_30,re_10)) else fail-any)) else caught-fail) in
        {725}let v_234: bool = not-caught-fail(ss_36) in
        {726}let v_235: bitstring = (if v_234 then catch-fail(keypairunpack(e_15)) else caught-fail) in
        {727}let v_236: bool = (not-caught-fail(v_235) && success?(1-proj-2-tuple(v_235))) in
        {728}let my_private_key_4: key = (if v_236 then 2-proj-2-tuple(v_235) else caught-fail) in
        {729}let my_public_key_4: key = (if v_236 then 1-proj-2-tuple(v_235) else caught-fail) in
        {730}let input_key_material_5: key = (if v_234 then catch-fail((if v_236 then dhexp(my_private_key_4,re_10) else fail-any)) else caught-fail) in
        {731}let v_237: bool = not-caught-fail(input_key_material_5) in
        {732}let v_238: bitstring = (if v_237 then catch-fail(symmetricstateunpack(ss_36)) else caught-fail) in
        {733}let v_239: bool = (not-caught-fail(v_238) && success?(1-proj-3-tuple(v_238))) in
        {734}let h_31: bitstring = (if v_239 then 3-proj-3-tuple(v_238) else caught-fail) in
        {735}let ck_35: key = (if v_239 then 2-proj-3-tuple(v_238) else caught-fail) in
        {736}let cs_31: cipherstate = (if v_239 then 1-proj-3-tuple(v_238) else caught-fail) in
        {737}let output1_5: key = (if v_239 then hmac_hash1(ck_35,input_key_material_5) else caught-fail) in
        {738}let output2_5: key = (if v_239 then hmac_hash2(ck_35,input_key_material_5) else caught-fail) in
        {739}let output3_5: key = (if v_239 then hmac_hash3(ck_35,input_key_material_5) else caught-fail) in
        {740}let v_240: bitstring = (if v_239 then catch-fail((output1_5,output2_5,output3_5)) else caught-fail) in
        {741}let v_241: bool = (not-caught-fail(v_240) && success?(1-proj-3-tuple(v_240))) in
        {742}let output_4: key = (if v_241 then 3-proj-3-tuple(v_240) else caught-fail) in
        {743}let temp_k_4: key = (if v_241 then 2-proj-3-tuple(v_240) else caught-fail) in
        {744}let ck_36: key = (if v_241 then 1-proj-3-tuple(v_240) else caught-fail) in
        {745}let ss_37: symmetricstate = (if v_234 then catch-fail((if v_237 then (if v_239 then (if v_241 then symmetricstatepack(cipherstatepack(temp_k_4,minnonce),ck_36,h_31) else fail-any) else fail-any) else fail-any)) else caught-fail) in
        {746}let v_242: bool = not-caught-fail(ss_37) in
        {747}let v_243: bitstring = (if v_242 then catch-fail(symmetricstateunpack(ss_37)) else caught-fail) in
        {748}let v_244: bool = (not-caught-fail(v_243) && success?(1-proj-3-tuple(v_243))) in
        {749}let h_32: bitstring = (if v_244 then 3-proj-3-tuple(v_243) else caught-fail) in
        {750}let ck_37: key = (if v_244 then 2-proj-3-tuple(v_243) else caught-fail) in
        {751}let cs_32: cipherstate = (if v_244 then 1-proj-3-tuple(v_243) else caught-fail) in
        {752}let v_245: bitstring = (if v_244 then catch-fail(cipherstateunpack(cs_32)) else caught-fail) in
        {753}let v_246: bool = (not-caught-fail(v_245) && success?(1-proj-2-tuple(v_245))) in
        {754}let n_18: nonce = (if v_246 then 2-proj-2-tuple(v_245) else caught-fail) in
        {755}let k_20: key = (if v_246 then 1-proj-2-tuple(v_245) else caught-fail) in
        {756}let d_4: aead = (if v_246 then catch-fail(decrypt(k_20,n_18,h_32,ns_6)) else caught-fail) in
        {757}let v_247: bool = not-caught-fail(d_4) in
        {758}let v_248: bitstring = (if v_247 then catch-fail(aeadunpack(d_4)) else caught-fail) in
        {759}let v_249: bool = (not-caught-fail(v_248) && success?(1-proj-3-tuple(v_248))) in
        {760}let plaintext_11: bitstring = (if v_249 then 3-proj-3-tuple(v_248) else caught-fail) in
        {761}let adi_4: bitstring = (if v_249 then 2-proj-3-tuple(v_248) else caught-fail) in
        {762}let valid_10: bool = (if v_249 then 1-proj-3-tuple(v_248) else caught-fail) in
        {763}let n_19: nonce = (if v_249 then increment_nonce(n_18) else caught-fail) in
        {764}let v_250: bitstring = (if v_249 then catch-fail(cipherstateunpack(cs_32)) else caught-fail) in
        {765}let v_251: bool = (not-caught-fail(v_250) && success?(1-proj-2-tuple(v_250))) in
        {766}let o_9: nonce = (if v_251 then 2-proj-2-tuple(v_250) else caught-fail) in
        {767}let k_21: key = (if v_251 then 1-proj-2-tuple(v_250) else caught-fail) in
        {768}let csi_18: cipherstate = (if v_249 then catch-fail((if v_251 then cipherstatepack(k_21,n_19) else fail-any)) else caught-fail) in
        {769}let v_252: bool = not-caught-fail(csi_18) in
        {770}let v_253: bitstring = (if v_244 then catch-fail((if v_246 then (if v_247 then (if v_249 then (if v_252 then (csi_18,plaintext_11,valid_10) else fail-any) else fail-any) else fail-any) else fail-any)) else caught-fail) in
        {771}let v_254: bool = (not-caught-fail(v_253) && success?(1-proj-3-tuple(v_253))) in
        {772}let valid_11: bool = (if v_254 then 3-proj-3-tuple(v_253) else caught-fail) in
        {773}let plaintext_12: bitstring = (if v_254 then 2-proj-3-tuple(v_253) else caught-fail) in
        {774}let csi_19: cipherstate = (if v_254 then 1-proj-3-tuple(v_253) else caught-fail) in
        {775}let ss_38: symmetricstate = (if v_254 then symmetricstatepack(csi_19,ck_37,h_32) else caught-fail) in
        {776}let v_255: bitstring = (if v_254 then catch-fail(symmetricstateunpack(ss_38)) else caught-fail) in
        {777}let v_256: bool = (not-caught-fail(v_255) && success?(1-proj-3-tuple(v_255))) in
        {778}let h_33: bitstring = (if v_256 then 3-proj-3-tuple(v_255) else caught-fail) in
        {779}let ck_38: key = (if v_256 then 2-proj-3-tuple(v_255) else caught-fail) in
        {780}let cs_33: cipherstate = (if v_256 then 1-proj-3-tuple(v_255) else caught-fail) in
        {781}let ssi_10: symmetricstate = (if v_254 then catch-fail((if v_256 then symmetricstatepack(cs_33,ck_38,hash(h_33,ns_6)) else fail-any)) else caught-fail) in
        {782}let v_257: bool = not-caught-fail(ssi_10) in
        {783}let v_258: bitstring = (if v_242 then catch-fail((if v_244 then (if v_254 then (if v_257 then (ssi_10,plaintext_12,valid_11) else fail-any) else fail-any) else fail-any)) else caught-fail) in
        {784}let v_259: bool = (not-caught-fail(v_258) && success?(1-proj-3-tuple(v_258))) in
        {785}let valid1_4: bool = (if v_259 then 3-proj-3-tuple(v_258) else caught-fail) in
        {786}let ne_11: bitstring = (if v_259 then 2-proj-3-tuple(v_258) else caught-fail) in
        {787}let ss_39: symmetricstate = (if v_259 then 1-proj-3-tuple(v_258) else caught-fail) in
        {788}let rs_10: key = (if v_259 then ne_11 else caught-fail) in
        {789}let v_260: bitstring = (if v_259 then catch-fail(symmetricstateunpack(ss_39)) else caught-fail) in
        {790}let v_261: bool = (not-caught-fail(v_260) && success?(1-proj-3-tuple(v_260))) in
        {791}let h_34: bitstring = (if v_261 then 3-proj-3-tuple(v_260) else caught-fail) in
        {792}let ck_39: key = (if v_261 then 2-proj-3-tuple(v_260) else caught-fail) in
        {793}let cs_34: cipherstate = (if v_261 then 1-proj-3-tuple(v_260) else caught-fail) in
        {794}let v_262: bitstring = (if v_261 then catch-fail(cipherstateunpack(cs_34)) else caught-fail) in
        {795}let v_263: bool = (not-caught-fail(v_262) && success?(1-proj-2-tuple(v_262))) in
        {796}let n_20: nonce = (if v_263 then 2-proj-2-tuple(v_262) else caught-fail) in
        {797}let k_22: key = (if v_263 then 1-proj-2-tuple(v_262) else caught-fail) in
        {798}let d_5: aead = (if v_263 then catch-fail(decrypt(k_22,n_20,h_34,nm_3)) else caught-fail) in
        {799}let v_264: bool = not-caught-fail(d_5) in
        {800}let v_265: bitstring = (if v_264 then catch-fail(aeadunpack(d_5)) else caught-fail) in
        {801}let v_266: bool = (not-caught-fail(v_265) && success?(1-proj-3-tuple(v_265))) in
        {802}let plaintext_13: bitstring = (if v_266 then 3-proj-3-tuple(v_265) else caught-fail) in
        {803}let adi_5: bitstring = (if v_266 then 2-proj-3-tuple(v_265) else caught-fail) in
        {804}let valid_12: bool = (if v_266 then 1-proj-3-tuple(v_265) else caught-fail) in
        {805}let n_21: nonce = (if v_266 then increment_nonce(n_20) else caught-fail) in
        {806}let v_267: bitstring = (if v_266 then catch-fail(cipherstateunpack(cs_34)) else caught-fail) in
        {807}let v_268: bool = (not-caught-fail(v_267) && success?(1-proj-2-tuple(v_267))) in
        {808}let o_10: nonce = (if v_268 then 2-proj-2-tuple(v_267) else caught-fail) in
        {809}let k_23: key = (if v_268 then 1-proj-2-tuple(v_267) else caught-fail) in
        {810}let csi_20: cipherstate = (if v_266 then catch-fail((if v_268 then cipherstatepack(k_23,n_21) else fail-any)) else caught-fail) in
        {811}let v_269: bool = not-caught-fail(csi_20) in
        {812}let v_270: bitstring = (if v_261 then catch-fail((if v_263 then (if v_264 then (if v_266 then (if v_269 then (csi_20,plaintext_13,valid_12) else fail-any) else fail-any) else fail-any) else fail-any)) else caught-fail) in
        {813}let v_271: bool = (not-caught-fail(v_270) && success?(1-proj-3-tuple(v_270))) in
        {814}let valid_13: bool = (if v_271 then 3-proj-3-tuple(v_270) else caught-fail) in
        {815}let plaintext_14: bitstring = (if v_271 then 2-proj-3-tuple(v_270) else caught-fail) in
        {816}let csi_21: cipherstate = (if v_271 then 1-proj-3-tuple(v_270) else caught-fail) in
        {817}let ss_40: symmetricstate = (if v_271 then symmetricstatepack(csi_21,ck_39,h_34) else caught-fail) in
        {818}let v_272: bitstring = (if v_271 then catch-fail(symmetricstateunpack(ss_40)) else caught-fail) in
        {819}let v_273: bool = (not-caught-fail(v_272) && success?(1-proj-3-tuple(v_272))) in
        {820}let h_35: bitstring = (if v_273 then 3-proj-3-tuple(v_272) else caught-fail) in
        {821}let ck_40: key = (if v_273 then 2-proj-3-tuple(v_272) else caught-fail) in
        {822}let cs_35: cipherstate = (if v_273 then 1-proj-3-tuple(v_272) else caught-fail) in
        {823}let ssi_11: symmetricstate = (if v_271 then catch-fail((if v_273 then symmetricstatepack(cs_35,ck_40,hash(h_35,nm_3)) else fail-any)) else caught-fail) in
        {824}let v_274: bool = not-caught-fail(ssi_11) in
        {825}let v_275: bitstring = (if v_259 then catch-fail((if v_261 then (if v_271 then (if v_274 then (ssi_11,plaintext_14,valid_13) else fail-any) else fail-any) else fail-any)) else caught-fail) in
        {826}let v_276: bool = (not-caught-fail(v_275) && success?(1-proj-3-tuple(v_275))) in
        {827}let valid2_2: bool = (if v_276 then 3-proj-3-tuple(v_275) else caught-fail) in
        {828}let ne_12: bitstring = (if v_276 then 2-proj-3-tuple(v_275) else caught-fail) in
        {829}let ss_41: symmetricstate = (if v_276 then 1-proj-3-tuple(v_275) else caught-fail) in
        {830}let rm_10: key = (if v_276 then ne_12 else caught-fail) in
        {831}let v_277: bitstring = (if v_276 then catch-fail(keypairunpack(e_15)) else caught-fail) in
        {832}let v_278: bool = (not-caught-fail(v_277) && success?(1-proj-2-tuple(v_277))) in
        {833}let my_private_key_5: key = (if v_278 then 2-proj-2-tuple(v_277) else caught-fail) in
        {834}let my_public_key_5: key = (if v_278 then 1-proj-2-tuple(v_277) else caught-fail) in
        {835}let input_key_material_6: key = (if v_276 then catch-fail((if v_278 then dhexp(my_private_key_5,rs_10) else fail-any)) else caught-fail) in
        {836}let v_279: bool = not-caught-fail(input_key_material_6) in
        {837}let v_280: bitstring = (if v_279 then catch-fail(symmetricstateunpack(ss_41)) else caught-fail) in
        {838}let v_281: bool = (not-caught-fail(v_280) && success?(1-proj-3-tuple(v_280))) in
        {839}let h_36: bitstring = (if v_281 then 3-proj-3-tuple(v_280) else caught-fail) in
        {840}let ck_41: key = (if v_281 then 2-proj-3-tuple(v_280) else caught-fail) in
        {841}let cs_36: cipherstate = (if v_281 then 1-proj-3-tuple(v_280) else caught-fail) in
        {842}let output1_6: key = (if v_281 then hmac_hash1(ck_41,input_key_material_6) else caught-fail) in
        {843}let output2_6: key = (if v_281 then hmac_hash2(ck_41,input_key_material_6) else caught-fail) in
        {844}let output3_6: key = (if v_281 then hmac_hash3(ck_41,input_key_material_6) else caught-fail) in
        {845}let v_282: bitstring = (if v_281 then catch-fail((output1_6,output2_6,output3_6)) else caught-fail) in
        {846}let v_283: bool = (not-caught-fail(v_282) && success?(1-proj-3-tuple(v_282))) in
        {847}let output_5: key = (if v_283 then 3-proj-3-tuple(v_282) else caught-fail) in
        {848}let temp_k_5: key = (if v_283 then 2-proj-3-tuple(v_282) else caught-fail) in
        {849}let ck_42: key = (if v_283 then 1-proj-3-tuple(v_282) else caught-fail) in
        {850}let ss_42: symmetricstate = (if v_276 then catch-fail((if v_279 then (if v_281 then (if v_283 then symmetricstatepack(cipherstatepack(temp_k_5,minnonce),ck_42,h_36) else fail-any) else fail-any) else fail-any)) else caught-fail) in
        {851}let v_284: bool = not-caught-fail(ss_42) in
        {852}let v_285: bitstring = (if v_284 then catch-fail(keypairunpack(e_15)) else caught-fail) in
        {853}let v_286: bool = (not-caught-fail(v_285) && success?(1-proj-2-tuple(v_285))) in
        {854}let my_private_key_6: key = (if v_286 then 2-proj-2-tuple(v_285) else caught-fail) in
        {855}let my_public_key_6: key = (if v_286 then 1-proj-2-tuple(v_285) else caught-fail) in
        {856}let input_key_material_7: key = (if v_284 then catch-fail((if v_286 then dhexp(my_private_key_6,rm_10) else fail-any)) else caught-fail) in
        {857}let v_287: bool = not-caught-fail(input_key_material_7) in
        {858}let v_288: bitstring = (if v_287 then catch-fail(symmetricstateunpack(ss_42)) else caught-fail) in
        {859}let v_289: bool = (not-caught-fail(v_288) && success?(1-proj-3-tuple(v_288))) in
        {860}let h_37: bitstring = (if v_289 then 3-proj-3-tuple(v_288) else caught-fail) in
        {861}let ck_43: key = (if v_289 then 2-proj-3-tuple(v_288) else caught-fail) in
        {862}let cs_37: cipherstate = (if v_289 then 1-proj-3-tuple(v_288) else caught-fail) in
        {863}let output1_7: key = (if v_289 then hmac_hash1(ck_43,input_key_material_7) else caught-fail) in
        {864}let output2_7: key = (if v_289 then hmac_hash2(ck_43,input_key_material_7) else caught-fail) in
        {865}let output3_7: key = (if v_289 then hmac_hash3(ck_43,input_key_material_7) else caught-fail) in
        {866}let v_290: bitstring = (if v_289 then catch-fail((output1_7,output2_7,output3_7)) else caught-fail) in
        {867}let v_291: bool = (not-caught-fail(v_290) && success?(1-proj-3-tuple(v_290))) in
        {868}let output_6: key = (if v_291 then 3-proj-3-tuple(v_290) else caught-fail) in
        {869}let temp_k_6: key = (if v_291 then 2-proj-3-tuple(v_290) else caught-fail) in
        {870}let ck_44: key = (if v_291 then 1-proj-3-tuple(v_290) else caught-fail) in
        {871}let ss_43: symmetricstate = (if v_284 then catch-fail((if v_287 then (if v_289 then (if v_291 then symmetricstatepack(cipherstatepack(temp_k_6,minnonce),ck_44,h_37) else fail-any) else fail-any) else fail-any)) else caught-fail) in
        {872}let v_292: bool = not-caught-fail(ss_43) in
        {873}let v_293: bitstring = (if v_292 then catch-fail(symmetricstateunpack(ss_43)) else caught-fail) in
        {874}let v_294: bool = (not-caught-fail(v_293) && success?(1-proj-3-tuple(v_293))) in
        {875}let h_38: bitstring = (if v_294 then 3-proj-3-tuple(v_293) else caught-fail) in
        {876}let ck_45: key = (if v_294 then 2-proj-3-tuple(v_293) else caught-fail) in
        {877}let cs_38: cipherstate = (if v_294 then 1-proj-3-tuple(v_293) else caught-fail) in
        {878}let v_295: bitstring = (if v_294 then catch-fail(cipherstateunpack(cs_38)) else caught-fail) in
        {879}let v_296: bool = (not-caught-fail(v_295) && success?(1-proj-2-tuple(v_295))) in
        {880}let n_22: nonce = (if v_296 then 2-proj-2-tuple(v_295) else caught-fail) in
        {881}let k_24: key = (if v_296 then 1-proj-2-tuple(v_295) else caught-fail) in
        {882}let d_6: aead = (if v_296 then catch-fail(decrypt(k_24,n_22,h_38,ciphertext_15)) else caught-fail) in
        {883}let v_297: bool = not-caught-fail(d_6) in
        {884}let v_298: bitstring = (if v_297 then catch-fail(aeadunpack(d_6)) else caught-fail) in
        {885}let v_299: bool = (not-caught-fail(v_298) && success?(1-proj-3-tuple(v_298))) in
        {886}let plaintext_15: bitstring = (if v_299 then 3-proj-3-tuple(v_298) else caught-fail) in
        {887}let adi_6: bitstring = (if v_299 then 2-proj-3-tuple(v_298) else caught-fail) in
        {888}let valid_14: bool = (if v_299 then 1-proj-3-tuple(v_298) else caught-fail) in
        {889}let n_23: nonce = (if v_299 then increment_nonce(n_22) else caught-fail) in
        {890}let v_300: bitstring = (if v_299 then catch-fail(cipherstateunpack(cs_38)) else caught-fail) in
        {891}let v_301: bool = (not-caught-fail(v_300) && success?(1-proj-2-tuple(v_300))) in
        {892}let o_11: nonce = (if v_301 then 2-proj-2-tuple(v_300) else caught-fail) in
        {893}let k_25: key = (if v_301 then 1-proj-2-tuple(v_300) else caught-fail) in
        {894}let csi_22: cipherstate = (if v_299 then catch-fail((if v_301 then cipherstatepack(k_25,n_23) else fail-any)) else caught-fail) in
        {895}let v_302: bool = not-caught-fail(csi_22) in
        {896}let v_303: bitstring = (if v_294 then catch-fail((if v_296 then (if v_297 then (if v_299 then (if v_302 then (csi_22,plaintext_15,valid_14) else fail-any) else fail-any) else fail-any) else fail-any)) else caught-fail) in
        {897}let v_304: bool = (not-caught-fail(v_303) && success?(1-proj-3-tuple(v_303))) in
        {898}let valid_15: bool = (if v_304 then 3-proj-3-tuple(v_303) else caught-fail) in
        {899}let plaintext_16: bitstring = (if v_304 then 2-proj-3-tuple(v_303) else caught-fail) in
        {900}let csi_23: cipherstate = (if v_304 then 1-proj-3-tuple(v_303) else caught-fail) in
        {901}let ss_44: symmetricstate = (if v_304 then symmetricstatepack(csi_23,ck_45,h_38) else caught-fail) in
        {902}let v_305: bitstring = (if v_304 then catch-fail(symmetricstateunpack(ss_44)) else caught-fail) in
        {903}let v_306: bool = (not-caught-fail(v_305) && success?(1-proj-3-tuple(v_305))) in
        {904}let h_39: bitstring = (if v_306 then 3-proj-3-tuple(v_305) else caught-fail) in
        {905}let ck_46: key = (if v_306 then 2-proj-3-tuple(v_305) else caught-fail) in
        {906}let cs_39: cipherstate = (if v_306 then 1-proj-3-tuple(v_305) else caught-fail) in
        {907}let ssi_12: symmetricstate = (if v_304 then catch-fail((if v_306 then symmetricstatepack(cs_39,ck_46,hash(h_39,ciphertext_15)) else fail-any)) else caught-fail) in
        {908}let v_307: bool = not-caught-fail(ssi_12) in
        {909}let v_308: bitstring = (if v_292 then catch-fail((if v_294 then (if v_304 then (if v_307 then (ssi_12,plaintext_16,valid_15) else fail-any) else fail-any) else fail-any)) else caught-fail) in
        {910}let v_309: bool = (not-caught-fail(v_308) && success?(1-proj-3-tuple(v_308))) in
        {911}let valid3_1: bool = (if v_309 then 3-proj-3-tuple(v_308) else caught-fail) in
        {912}let plaintext_17: bitstring = (if v_309 then 2-proj-3-tuple(v_308) else caught-fail) in
        {913}let ss_45: symmetricstate = (if v_309 then 1-proj-3-tuple(v_308) else caught-fail) in
        {914}let basis_5: key = (if v_309 then key_s(them_1) else caught-fail) in
        {915}let public_key_5: key = (if v_309 then catch-fail(dhexp(basis_5,validkey(g))) else caught-fail) in
        {916}let v_310: bool = not-caught-fail(public_key_5) in
        {917}let basis_6: key = (if v_309 then key_m(them_1) else caught-fail) in
        {918}let public_key_6: key = (if v_309 then catch-fail(dhexp(basis_6,validkey(g))) else caught-fail) in
        {919}let v_311: bool = not-caught-fail(public_key_6) in
        {920}let v_312: bool = (if v_309 then catch-fail(((valid1_4 && (valid2_2 && valid3_1)) && ((rs_10 = getpublickey((if v_310 then keypairpack(validkey(public_key_5),basis_5) else fail-any))) && (rm_10 = getpublickey((if v_311 then keypairpack(validkey(public_key_6),basis_6) else fail-any)))))) else caught-fail) in
        {921}let hs_23: handshakestate = (if v_312 then handshakestatepack(ss_45,s_8,m_9,e_15,rs_10,rm_10,re_10,psk_8,initiator_7) else caught-fail) in
        {922}let (hs_24: handshakestate,plaintext_b_1: bitstring,valid_16: bool) = (if v_229 then (if v_231 then (if v_234 then (if v_242 then (if v_259 then (if v_276 then (if v_284 then (if v_292 then (if v_309 then (if undo-catch-fail(v_312) then (hs_23,plaintext_17,true) else fail-any) else fail-any) else fail-any) else fail-any) else fail-any) else fail-any) else fail-any) else fail-any) else fail-any) else fail-any) in
        {923}event RecvMsg(me_1,them_1,stagepack_b(sid_2),plaintext_b_1);
        {924}insert statestore(me_1,them_1,sid_2,statepack_c(hs_24))
    ) | (
        {1065}get statestore(=me_1,=them_1,=sid_2,statepack_c(hs_25: handshakestate)) in
        {926}let payload_4: bitstring = msg_c(me_1,them_1,sid_2) in
        {927}let v_313: bitstring = catch-fail(handshakestateunpack(hs_25)) in
        {928}let v_314: bool = (not-caught-fail(v_313) && success?(1-proj-9-tuple(v_313))) in
        {929}let initiator_8: bool = (if v_314 then 9-proj-9-tuple(v_313) else caught-fail) in
        {930}let psk_9: key = (if v_314 then 8-proj-9-tuple(v_313) else caught-fail) in
        {931}let re_11: key = (if v_314 then 7-proj-9-tuple(v_313) else caught-fail) in
        {932}let rm_11: key = (if v_314 then 6-proj-9-tuple(v_313) else caught-fail) in
        {933}let rs_11: key = (if v_314 then 5-proj-9-tuple(v_313) else caught-fail) in
        {934}let e_16: keypair = (if v_314 then 4-proj-9-tuple(v_313) else caught-fail) in
        {935}let m_10: keypair = (if v_314 then 3-proj-9-tuple(v_313) else caught-fail) in
        {936}let s_9: keypair = (if v_314 then 2-proj-9-tuple(v_313) else caught-fail) in
        {937}let ss_46: symmetricstate = (if v_314 then 1-proj-9-tuple(v_313) else caught-fail) in
        {938}let v_315: bitstring = (if v_314 then catch-fail((empty,empty,empty,empty)) else caught-fail) in
        {939}let v_316: bool = (not-caught-fail(v_315) && success?(1-proj-4-tuple(v_315))) in
        {940}let ciphertext_16: bitstring = (if v_316 then 4-proj-4-tuple(v_315) else caught-fail) in
        {941}let nm_4: bitstring = (if v_316 then 3-proj-4-tuple(v_315) else caught-fail) in
        {942}let ns_7: bitstring = (if v_316 then 2-proj-4-tuple(v_315) else caught-fail) in
        {943}let ne_13: bitstring = (if v_316 then 1-proj-4-tuple(v_315) else caught-fail) in
        {944}let basis_7: key = (if v_316 then key_m(me_1) else caught-fail) in
        {945}let public_key_7: key = (if v_316 then catch-fail(dhexp(basis_7,validkey(g))) else caught-fail) in
        {946}let v_317: bool = not-caught-fail(public_key_7) in
        {947}let m_11: keypair = (if v_316 then catch-fail((if v_317 then keypairpack(validkey(public_key_7),basis_7) else fail-any)) else caught-fail) in
        {948}let v_318: bool = not-caught-fail(m_11) in
        {949}let plaintext_18: bitstring = (if v_318 then catch-fail(getpublickey(m_11)) else caught-fail) in
        {950}let v_319: bool = not-caught-fail(plaintext_18) in
        {951}let v_320: bitstring = (if v_319 then catch-fail(symmetricstateunpack(ss_46)) else caught-fail) in
        {952}let v_321: bool = (not-caught-fail(v_320) && success?(1-proj-3-tuple(v_320))) in
        {953}let h_40: bitstring = (if v_321 then 3-proj-3-tuple(v_320) else caught-fail) in
        {954}let ck_47: key = (if v_321 then 2-proj-3-tuple(v_320) else caught-fail) in
        {955}let cs_40: cipherstate = (if v_321 then 1-proj-3-tuple(v_320) else caught-fail) in
        {956}let v_322: bitstring = (if v_321 then catch-fail(cipherstateunpack(cs_40)) else caught-fail) in
        {957}let v_323: bool = (not-caught-fail(v_322) && success?(1-proj-2-tuple(v_322))) in
        {958}let n_24: nonce = (if v_323 then 2-proj-2-tuple(v_322) else caught-fail) in
        {959}let k_26: key = (if v_323 then 1-proj-2-tuple(v_322) else caught-fail) in
        {960}let e_17: bitstring = (if v_323 then encrypt(k_26,n_24,h_40,plaintext_18) else caught-fail) in
        {961}let n_25: nonce = (if v_323 then increment_nonce(n_24) else caught-fail) in
        {962}let v_324: bitstring = (if v_323 then catch-fail(cipherstateunpack(cs_40)) else caught-fail) in
        {963}let v_325: bool = (not-caught-fail(v_324) && success?(1-proj-2-tuple(v_324))) in
        {964}let o_12: nonce = (if v_325 then 2-proj-2-tuple(v_324) else caught-fail) in
        {965}let k_27: key = (if v_325 then 1-proj-2-tuple(v_324) else caught-fail) in
        {966}let csi_24: cipherstate = (if v_323 then catch-fail((if v_325 then cipherstatepack(k_27,n_25) else fail-any)) else caught-fail) in
        {967}let v_326: bool = not-caught-fail(csi_24) in
        {968}let v_327: bitstring = (if v_321 then catch-fail((if v_323 then (if v_326 then (csi_24,e_17) else fail-any) else fail-any)) else caught-fail) in
        {969}let v_328: bool = (not-caught-fail(v_327) && success?(1-proj-2-tuple(v_327))) in
        {970}let ciphertext_17: bitstring = (if v_328 then 2-proj-2-tuple(v_327) else caught-fail) in
        {971}let csi_25: cipherstate = (if v_328 then 1-proj-2-tuple(v_327) else caught-fail) in
        {972}let ss_47: symmetricstate = (if v_328 then symmetricstatepack(csi_25,ck_47,h_40) else caught-fail) in
        {973}let v_329: bitstring = (if v_328 then catch-fail(symmetricstateunpack(ss_47)) else caught-fail) in
        {974}let v_330: bool = (not-caught-fail(v_329) && success?(1-proj-3-tuple(v_329))) in
        {975}let h_41: bitstring = (if v_330 then 3-proj-3-tuple(v_329) else caught-fail) in
        {976}let ck_48: key = (if v_330 then 2-proj-3-tuple(v_329) else caught-fail) in
        {977}let cs_41: cipherstate = (if v_330 then 1-proj-3-tuple(v_329) else caught-fail) in
        {978}let ssi_13: symmetricstate = (if v_328 then catch-fail((if v_330 then symmetricstatepack(cs_41,ck_48,hash(h_41,ciphertext_17)) else fail-any)) else caught-fail) in
        {979}let v_331: bool = not-caught-fail(ssi_13) in
        {980}let v_332: bitstring = (if v_318 then catch-fail((if v_319 then (if v_321 then (if v_328 then (if v_331 then (ssi_13,ciphertext_17) else fail-any) else fail-any) else fail-any) else fail-any)) else caught-fail) in
        {981}let v_333: bool = (not-caught-fail(v_332) && success?(1-proj-2-tuple(v_332))) in
        {982}let nm_5: bitstring = (if v_333 then 2-proj-2-tuple(v_332) else caught-fail) in
        {983}let ss_48: symmetricstate = (if v_333 then 1-proj-2-tuple(v_332) else caught-fail) in
        {984}let v_334: bitstring = (if v_333 then catch-fail(keypairunpack(m_11)) else caught-fail) in
        {985}let v_335: bool = (not-caught-fail(v_334) && success?(1-proj-2-tuple(v_334))) in
        {986}let my_private_key_7: key = (if v_335 then 2-proj-2-tuple(v_334) else caught-fail) in
        {987}let my_public_key_7: key = (if v_335 then 1-proj-2-tuple(v_334) else caught-fail) in
        {988}let input_key_material_8: key = (if v_333 then catch-fail((if v_335 then dhexp(my_private_key_7,re_11) else fail-any)) else caught-fail) in
        {989}let v_336: bool = not-caught-fail(input_key_material_8) in
        {990}let v_337: bitstring = (if v_336 then catch-fail(symmetricstateunpack(ss_48)) else caught-fail) in
        {991}let v_338: bool = (not-caught-fail(v_337) && success?(1-proj-3-tuple(v_337))) in
        {992}let h_42: bitstring = (if v_338 then 3-proj-3-tuple(v_337) else caught-fail) in
        {993}let ck_49: key = (if v_338 then 2-proj-3-tuple(v_337) else caught-fail) in
        {994}let cs_42: cipherstate = (if v_338 then 1-proj-3-tuple(v_337) else caught-fail) in
        {995}let output1_8: key = (if v_338 then hmac_hash1(ck_49,input_key_material_8) else caught-fail) in
        {996}let output2_8: key = (if v_338 then hmac_hash2(ck_49,input_key_material_8) else caught-fail) in
        {997}let output3_8: key = (if v_338 then hmac_hash3(ck_49,input_key_material_8) else caught-fail) in
        {998}let v_339: bitstring = (if v_338 then catch-fail((output1_8,output2_8,output3_8)) else caught-fail) in
        {999}let v_340: bool = (not-caught-fail(v_339) && success?(1-proj-3-tuple(v_339))) in
        {1000}let output_7: key = (if v_340 then 3-proj-3-tuple(v_339) else caught-fail) in
        {1001}let temp_k_7: key = (if v_340 then 2-proj-3-tuple(v_339) else caught-fail) in
        {1002}let ck_50: key = (if v_340 then 1-proj-3-tuple(v_339) else caught-fail) in
        {1003}let ss_49: symmetricstate = (if v_333 then catch-fail((if v_336 then (if v_338 then (if v_340 then symmetricstatepack(cipherstatepack(temp_k_7,minnonce),ck_50,h_42) else fail-any) else fail-any) else fail-any)) else caught-fail) in
        {1004}let v_341: bool = not-caught-fail(ss_49) in
        {1005}let v_342: bitstring = (if v_341 then catch-fail(symmetricstateunpack(ss_49)) else caught-fail) in
        {1006}let v_343: bool = (not-caught-fail(v_342) && success?(1-proj-3-tuple(v_342))) in
        {1007}let h_43: bitstring = (if v_343 then 3-proj-3-tuple(v_342) else caught-fail) in
        {1008}let ck_51: key = (if v_343 then 2-proj-3-tuple(v_342) else caught-fail) in
        {1009}let cs_43: cipherstate = (if v_343 then 1-proj-3-tuple(v_342) else caught-fail) in
        {1010}let v_344: bitstring = (if v_343 then catch-fail(cipherstateunpack(cs_43)) else caught-fail) in
        {1011}let v_345: bool = (not-caught-fail(v_344) && success?(1-proj-2-tuple(v_344))) in
        {1012}let n_26: nonce = (if v_345 then 2-proj-2-tuple(v_344) else caught-fail) in
        {1013}let k_28: key = (if v_345 then 1-proj-2-tuple(v_344) else caught-fail) in
        {1014}let e_18: bitstring = (if v_345 then encrypt(k_28,n_26,h_43,payload_4) else caught-fail) in
        {1015}let n_27: nonce = (if v_345 then increment_nonce(n_26) else caught-fail) in
        {1016}let v_346: bitstring = (if v_345 then catch-fail(cipherstateunpack(cs_43)) else caught-fail) in
        {1017}let v_347: bool = (not-caught-fail(v_346) && success?(1-proj-2-tuple(v_346))) in
        {1018}let o_13: nonce = (if v_347 then 2-proj-2-tuple(v_346) else caught-fail) in
        {1019}let k_29: key = (if v_347 then 1-proj-2-tuple(v_346) else caught-fail) in
        {1020}let csi_26: cipherstate = (if v_345 then catch-fail((if v_347 then cipherstatepack(k_29,n_27) else fail-any)) else caught-fail) in
        {1021}let v_348: bool = not-caught-fail(csi_26) in
        {1022}let v_349: bitstring = (if v_343 then catch-fail((if v_345 then (if v_348 then (csi_26,e_18) else fail-any) else fail-any)) else caught-fail) in
        {1023}let v_350: bool = (not-caught-fail(v_349) && success?(1-proj-2-tuple(v_349))) in
        {1024}let ciphertext_18: bitstring = (if v_350 then 2-proj-2-tuple(v_349) else caught-fail) in
        {1025}let csi_27: cipherstate = (if v_350 then 1-proj-2-tuple(v_349) else caught-fail) in
        {1026}let ss_50: symmetricstate = (if v_350 then symmetricstatepack(csi_27,ck_51,h_43) else caught-fail) in
        {1027}let v_351: bitstring = (if v_350 then catch-fail(symmetricstateunpack(ss_50)) else caught-fail) in
        {1028}let v_352: bool = (not-caught-fail(v_351) && success?(1-proj-3-tuple(v_351))) in
        {1029}let h_44: bitstring = (if v_352 then 3-proj-3-tuple(v_351) else caught-fail) in
        {1030}let ck_52: key = (if v_352 then 2-proj-3-tuple(v_351) else caught-fail) in
        {1031}let cs_44: cipherstate = (if v_352 then 1-proj-3-tuple(v_351) else caught-fail) in
        {1032}let ssi_14: symmetricstate = (if v_350 then catch-fail((if v_352 then symmetricstatepack(cs_44,ck_52,hash(h_44,ciphertext_18)) else fail-any)) else caught-fail) in
        {1033}let v_353: bool = not-caught-fail(ssi_14) in
        {1034}let v_354: bitstring = (if v_341 then catch-fail((if v_343 then (if v_350 then (if v_353 then (ssi_14,ciphertext_18) else fail-any) else fail-any) else fail-any)) else caught-fail) in
        {1035}let v_355: bool = (not-caught-fail(v_354) && success?(1-proj-2-tuple(v_354))) in
        {1036}let ciphertext_19: bitstring = (if v_355 then 2-proj-2-tuple(v_354) else caught-fail) in
        {1037}let ss_51: symmetricstate = (if v_355 then 1-proj-2-tuple(v_354) else caught-fail) in
        {1038}let hs_26: handshakestate = (if v_355 then handshakestatepack(ss_51,s_9,m_11,e_16,rs_11,rm_11,re_11,psk_9,initiator_8) else caught-fail) in
        {1039}let message_buffer_4: bitstring = (if v_355 then concat3(ne_13,nm_5,ciphertext_19) else caught-fail) in
        {1040}let v_356: bitstring = (if v_355 then catch-fail(symmetricstateunpack(ss_51)) else caught-fail) in
        {1041}let v_357: bool = (not-caught-fail(v_356) && success?(1-proj-3-tuple(v_356))) in
        {1042}let h_45: bitstring = (if v_357 then 3-proj-3-tuple(v_356) else caught-fail) in
        {1043}let ck_53: key = (if v_357 then 2-proj-3-tuple(v_356) else caught-fail) in
        {1044}let cs_45: cipherstate = (if v_357 then 1-proj-3-tuple(v_356) else caught-fail) in
        {1045}let input_key_material_9: key = (if v_357 then zero else caught-fail) in
        {1046}let output1_9: key = (if v_357 then hmac_hash1(ck_53,input_key_material_9) else caught-fail) in
        {1047}let output2_9: key = (if v_357 then hmac_hash2(ck_53,input_key_material_9) else caught-fail) in
        {1048}let output3_9: key = (if v_357 then hmac_hash3(ck_53,input_key_material_9) else caught-fail) in
        {1049}let v_358: bitstring = (if v_357 then catch-fail((output1_9,output2_9,output3_9)) else caught-fail) in
        {1050}let v_359: bool = (not-caught-fail(v_358) && success?(1-proj-3-tuple(v_358))) in
        {1051}let temp_k3_1: key = (if v_359 then 3-proj-3-tuple(v_358) else caught-fail) in
        {1052}let temp_k2_1: key = (if v_359 then 2-proj-3-tuple(v_358) else caught-fail) in
        {1053}let temp_k1_1: key = (if v_359 then 1-proj-3-tuple(v_358) else caught-fail) in
        {1054}let cs1_5: cipherstate = (if v_359 then cipherstatepack(temp_k1_1,minnonce) else caught-fail) in
        {1055}let cs2_5: cipherstate = (if v_359 then cipherstatepack(temp_k2_1,minnonce) else caught-fail) in
        {1056}let v_360: bitstring = (if v_355 then catch-fail((if v_357 then (if v_359 then (ss_51,cs1_5,cs2_5) else fail-any) else fail-any)) else caught-fail) in
        {1057}let v_361: bool = (not-caught-fail(v_360) && success?(1-proj-3-tuple(v_360))) in
        {1058}let cs2_6: cipherstate = (if v_361 then 3-proj-3-tuple(v_360) else caught-fail) in
        {1059}let cs1_6: cipherstate = (if v_361 then 2-proj-3-tuple(v_360) else caught-fail) in
        {1060}let ssi_15: symmetricstate = (if v_361 then 1-proj-3-tuple(v_360) else caught-fail) in
        {1061}let (hs_27: handshakestate,message_c_1: bitstring,cs1_7: cipherstate,cs2_7: cipherstate) = (if v_314 then (if v_316 then (if v_318 then (if v_333 then (if v_341 then (if v_355 then (if v_361 then (hs_26,message_buffer_4,cs1_6,cs2_6) else fail-any) else fail-any) else fail-any) else fail-any) else fail-any) else fail-any) else fail-any) in
        {1062}event SendMsg(me_1,them_1,stagepack_c(sid_2),msg_c(me_1,them_1,sid_2));
        {1063}insert statestore(me_1,them_1,sid_2,statepack_d(hs_27,cs1_7,cs2_7));
        {1064}out(pub, message_c_1)
    ) | (
        {1066}!
        {1132}get statestore(=me_1,=them_1,=sid_2,statepack_d(hs_28: handshakestate,cs1_8: cipherstate,cs2_8: cipherstate)) in
        {1067}let hs_29: handshakestate = handshakestatesetcs(hs_28,cs2_8) in
        {1068}in(pub, message_d_1: bitstring);
        {1069}let v_362: bitstring = catch-fail(handshakestateunpack(hs_29)) in
        {1070}let v_363: bool = (not-caught-fail(v_362) && success?(1-proj-9-tuple(v_362))) in
        {1071}let initiator_9: bool = (if v_363 then 9-proj-9-tuple(v_362) else caught-fail) in
        {1072}let psk_10: key = (if v_363 then 8-proj-9-tuple(v_362) else caught-fail) in
        {1073}let re_12: key = (if v_363 then 7-proj-9-tuple(v_362) else caught-fail) in
        {1074}let rm_12: key = (if v_363 then 6-proj-9-tuple(v_362) else caught-fail) in
        {1075}let rs_12: key = (if v_363 then 5-proj-9-tuple(v_362) else caught-fail) in
        {1076}let e_19: keypair = (if v_363 then 4-proj-9-tuple(v_362) else caught-fail) in
        {1077}let m_12: keypair = (if v_363 then 3-proj-9-tuple(v_362) else caught-fail) in
        {1078}let s_10: keypair = (if v_363 then 2-proj-9-tuple(v_362) else caught-fail) in
        {1079}let ss_52: symmetricstate = (if v_363 then 1-proj-9-tuple(v_362) else caught-fail) in
        {1080}let v_364: bitstring = (if v_363 then catch-fail(deconcat3(message_d_1)) else caught-fail) in
        {1081}let v_365: bool = (not-caught-fail(v_364) && success?(1-proj-3-tuple(v_364))) in
        {1082}let ciphertext_20: bitstring = (if v_365 then 3-proj-3-tuple(v_364) else caught-fail) in
        {1083}let ns_8: bitstring = (if v_365 then 2-proj-3-tuple(v_364) else caught-fail) in
        {1084}let ne_14: bitstring = (if v_365 then 1-proj-3-tuple(v_364) else caught-fail) in
        {1085}let valid1_5: bool = (if v_365 then true else caught-fail) in
        {1086}let v_366: bitstring = (if v_365 then catch-fail(symmetricstateunpack(ss_52)) else caught-fail) in
        {1087}let v_367: bool = (not-caught-fail(v_366) && success?(1-proj-3-tuple(v_366))) in
        {1088}let h_46: bitstring = (if v_367 then 3-proj-3-tuple(v_366) else caught-fail) in
        {1089}let ck_54: key = (if v_367 then 2-proj-3-tuple(v_366) else caught-fail) in
        {1090}let cs_46: cipherstate = (if v_367 then 1-proj-3-tuple(v_366) else caught-fail) in
        {1091}let v_368: bitstring = (if v_367 then catch-fail(cipherstateunpack(cs_46)) else caught-fail) in
        {1092}let v_369: bool = (not-caught-fail(v_368) && success?(1-proj-2-tuple(v_368))) in
        {1093}let n_28: nonce = (if v_369 then 2-proj-2-tuple(v_368) else caught-fail) in
        {1094}let k_30: key = (if v_369 then 1-proj-2-tuple(v_368) else caught-fail) in
        {1095}let d_7: aead = (if v_369 then catch-fail(decrypt(k_30,n_28,h_46,ciphertext_20)) else caught-fail) in
        {1096}let v_370: bool = not-caught-fail(d_7) in
        {1097}let v_371: bitstring = (if v_370 then catch-fail(aeadunpack(d_7)) else caught-fail) in
        {1098}let v_372: bool = (not-caught-fail(v_371) && success?(1-proj-3-tuple(v_371))) in
        {1099}let plaintext_19: bitstring = (if v_372 then 3-proj-3-tuple(v_371) else caught-fail) in
        {1100}let adi_7: bitstring = (if v_372 then 2-proj-3-tuple(v_371) else caught-fail) in
        {1101}let valid_17: bool = (if v_372 then 1-proj-3-tuple(v_371) else caught-fail) in
        {1102}let n_29: nonce = (if v_372 then increment_nonce(n_28) else caught-fail) in
        {1103}let v_373: bitstring = (if v_372 then catch-fail(cipherstateunpack(cs_46)) else caught-fail) in
        {1104}let v_374: bool = (not-caught-fail(v_373) && success?(1-proj-2-tuple(v_373))) in
        {1105}let o_14: nonce = (if v_374 then 2-proj-2-tuple(v_373) else caught-fail) in
        {1106}let k_31: key = (if v_374 then 1-proj-2-tuple(v_373) else caught-fail) in
        {1107}let csi_28: cipherstate = (if v_372 then catch-fail((if v_374 then cipherstatepack(k_31,n_29) else fail-any)) else caught-fail) in
        {1108}let v_375: bool = not-caught-fail(csi_28) in
        {1109}let v_376: bitstring = (if v_367 then catch-fail((if v_369 then (if v_370 then (if v_372 then (if v_375 then (csi_28,plaintext_19,valid_17) else fail-any) else fail-any) else fail-any) else fail-any)) else caught-fail) in
        {1110}let v_377: bool = (not-caught-fail(v_376) && success?(1-proj-3-tuple(v_376))) in
        {1111}let valid_18: bool = (if v_377 then 3-proj-3-tuple(v_376) else caught-fail) in
        {1112}let plaintext_20: bitstring = (if v_377 then 2-proj-3-tuple(v_376) else caught-fail) in
        {1113}let csi_29: cipherstate = (if v_377 then 1-proj-3-tuple(v_376) else caught-fail) in
        {1114}let ss_53: symmetricstate = (if v_377 then symmetricstatepack(csi_29,ck_54,h_46) else caught-fail) in
        {1115}let v_378: bitstring = (if v_377 then catch-fail(symmetricstateunpack(ss_53)) else caught-fail) in
        {1116}let v_379: bool = (not-caught-fail(v_378) && success?(1-proj-3-tuple(v_378))) in
        {1117}let h_47: bitstring = (if v_379 then 3-proj-3-tuple(v_378) else caught-fail) in
        {1118}let ck_55: key = (if v_379 then 2-proj-3-tuple(v_378) else caught-fail) in
        {1119}let cs_47: cipherstate = (if v_379 then 1-proj-3-tuple(v_378) else caught-fail) in
        {1120}let ssi_16: symmetricstate = (if v_377 then catch-fail((if v_379 then symmetricstatepack(cs_47,ck_55,hash(h_47,ciphertext_20)) else fail-any)) else caught-fail) in
        {1121}let v_380: bool = not-caught-fail(ssi_16) in
        {1122}let v_381: bitstring = (if v_365 then catch-fail((if v_367 then (if v_377 then (if v_380 then (ssi_16,plaintext_20,valid_18) else fail-any) else fail-any) else fail-any)) else caught-fail) in
        {1123}let v_382: bool = (not-caught-fail(v_381) && success?(1-proj-3-tuple(v_381))) in
        {1124}let valid2_3: bool = (if v_382 then 3-proj-3-tuple(v_381) else caught-fail) in
        {1125}let plaintext_21: bitstring = (if v_382 then 2-proj-3-tuple(v_381) else caught-fail) in
        {1126}let ss_54: symmetricstate = (if v_382 then 1-proj-3-tuple(v_381) else caught-fail) in
        {1127}let v_383: bool = (if v_382 then catch-fail((valid1_5 && valid2_3)) else caught-fail) in
        {1128}let hs_30: handshakestate = (if v_383 then handshakestatepack(ss_54,s_10,m_12,e_19,rs_12,rm_12,re_12,psk_10,initiator_9) else caught-fail) in
        {1129}let (hs_31: handshakestate,plaintext_d_1: bitstring,valid_19: bool) = (if v_363 then (if v_365 then (if v_382 then (if undo-catch-fail(v_383) then (hs_30,plaintext_21,true) else fail-any) else fail-any) else fail-any) else fail-any) in
        {1130}event RecvMsg(me_1,them_1,stagepack_d(sid_2),plaintext_d_1);
        {1131}insert statestore(me_1,them_1,sid_2,statepack_e(hs_31,cs1_8,handshakestategetcs(hs_31)))
    ) | (
        {1133}!
        {1190}get statestore(=me_1,=them_1,=sid_2,statepack_e(hs_32: handshakestate,cs1_9: cipherstate,cs2_9: cipherstate)) in
        {1134}let hs_33: handshakestate = handshakestatesetcs(hs_32,cs1_9) in
        {1135}let payload_5: bitstring = msg_e(me_1,them_1,sid_2) in
        {1136}let v_384: bitstring = catch-fail(handshakestateunpack(hs_33)) in
        {1137}let v_385: bool = (not-caught-fail(v_384) && success?(1-proj-9-tuple(v_384))) in
        {1138}let initiator_10: bool = (if v_385 then 9-proj-9-tuple(v_384) else caught-fail) in
        {1139}let psk_11: key = (if v_385 then 8-proj-9-tuple(v_384) else caught-fail) in
        {1140}let re_13: key = (if v_385 then 7-proj-9-tuple(v_384) else caught-fail) in
        {1141}let rm_13: key = (if v_385 then 6-proj-9-tuple(v_384) else caught-fail) in
        {1142}let rs_13: key = (if v_385 then 5-proj-9-tuple(v_384) else caught-fail) in
        {1143}let e_20: keypair = (if v_385 then 4-proj-9-tuple(v_384) else caught-fail) in
        {1144}let m_13: keypair = (if v_385 then 3-proj-9-tuple(v_384) else caught-fail) in
        {1145}let s_11: keypair = (if v_385 then 2-proj-9-tuple(v_384) else caught-fail) in
        {1146}let ss_55: symmetricstate = (if v_385 then 1-proj-9-tuple(v_384) else caught-fail) in
        {1147}let v_386: bitstring = (if v_385 then catch-fail((empty,empty,empty)) else caught-fail) in
        {1148}let v_387: bool = (not-caught-fail(v_386) && success?(1-proj-3-tuple(v_386))) in
        {1149}let ciphertext_21: bitstring = (if v_387 then 3-proj-3-tuple(v_386) else caught-fail) in
        {1150}let ns_9: bitstring = (if v_387 then 2-proj-3-tuple(v_386) else caught-fail) in
        {1151}let ne_15: bitstring = (if v_387 then 1-proj-3-tuple(v_386) else caught-fail) in
        {1152}let v_388: bitstring = (if v_387 then catch-fail(symmetricstateunpack(ss_55)) else caught-fail) in
        {1153}let v_389: bool = (not-caught-fail(v_388) && success?(1-proj-3-tuple(v_388))) in
        {1154}let h_48: bitstring = (if v_389 then 3-proj-3-tuple(v_388) else caught-fail) in
        {1155}let ck_56: key = (if v_389 then 2-proj-3-tuple(v_388) else caught-fail) in
        {1156}let cs_48: cipherstate = (if v_389 then 1-proj-3-tuple(v_388) else caught-fail) in
        {1157}let v_390: bitstring = (if v_389 then catch-fail(cipherstateunpack(cs_48)) else caught-fail) in
        {1158}let v_391: bool = (not-caught-fail(v_390) && success?(1-proj-2-tuple(v_390))) in
        {1159}let n_30: nonce = (if v_391 then 2-proj-2-tuple(v_390) else caught-fail) in
        {1160}let k_32: key = (if v_391 then 1-proj-2-tuple(v_390) else caught-fail) in
        {1161}let e_21: bitstring = (if v_391 then encrypt(k_32,n_30,h_48,payload_5) else caught-fail) in
        {1162}let n_31: nonce = (if v_391 then increment_nonce(n_30) else caught-fail) in
        {1163}let v_392: bitstring = (if v_391 then catch-fail(cipherstateunpack(cs_48)) else caught-fail) in
        {1164}let v_393: bool = (not-caught-fail(v_392) && success?(1-proj-2-tuple(v_392))) in
        {1165}let o_15: nonce = (if v_393 then 2-proj-2-tuple(v_392) else caught-fail) in
        {1166}let k_33: key = (if v_393 then 1-proj-2-tuple(v_392) else caught-fail) in
        {1167}let csi_30: cipherstate = (if v_391 then catch-fail((if v_393 then cipherstatepack(k_33,n_31) else fail-any)) else caught-fail) in
        {1168}let v_394: bool = not-caught-fail(csi_30) in
        {1169}let v_395: bitstring = (if v_389 then catch-fail((if v_391 then (if v_394 then (csi_30,e_21) else fail-any) else fail-any)) else caught-fail) in
        {1170}let v_396: bool = (not-caught-fail(v_395) && success?(1-proj-2-tuple(v_395))) in
        {1171}let ciphertext_22: bitstring = (if v_396 then 2-proj-2-tuple(v_395) else caught-fail) in
        {1172}let csi_31: cipherstate = (if v_396 then 1-proj-2-tuple(v_395) else caught-fail) in
        {1173}let ss_56: symmetricstate = (if v_396 then symmetricstatepack(csi_31,ck_56,h_48) else caught-fail) in
        {1174}let v_397: bitstring = (if v_396 then catch-fail(symmetricstateunpack(ss_56)) else caught-fail) in
        {1175}let v_398: bool = (not-caught-fail(v_397) && success?(1-proj-3-tuple(v_397))) in
        {1176}let h_49: bitstring = (if v_398 then 3-proj-3-tuple(v_397) else caught-fail) in
        {1177}let ck_57: key = (if v_398 then 2-proj-3-tuple(v_397) else caught-fail) in
        {1178}let cs_49: cipherstate = (if v_398 then 1-proj-3-tuple(v_397) else caught-fail) in
        {1179}let ssi_17: symmetricstate = (if v_396 then catch-fail((if v_398 then symmetricstatepack(cs_49,ck_57,hash(h_49,ciphertext_22)) else fail-any)) else caught-fail) in
        {1180}let v_399: bool = not-caught-fail(ssi_17) in
        {1181}let v_400: bitstring = (if v_387 then catch-fail((if v_389 then (if v_396 then (if v_399 then (ssi_17,ciphertext_22) else fail-any) else fail-any) else fail-any)) else caught-fail) in
        {1182}let v_401: bool = (not-caught-fail(v_400) && success?(1-proj-2-tuple(v_400))) in
        {1183}let ciphertext_23: bitstring = (if v_401 then 2-proj-2-tuple(v_400) else caught-fail) in
        {1184}let ss_57: symmetricstate = (if v_401 then 1-proj-2-tuple(v_400) else caught-fail) in
        {1185}let hs_34: handshakestate = (if v_401 then handshakestatepack(ss_57,s_11,m_13,e_20,rs_13,rm_13,re_13,psk_11,initiator_10) else caught-fail) in
        {1186}let message_buffer_5: bitstring = (if v_401 then concat3(ne_15,ns_9,ciphertext_23) else caught-fail) in
        {1187}let (hs_35: handshakestate,message_e_1: bitstring) = (if v_385 then (if v_387 then (if v_401 then (hs_34,message_buffer_5) else fail-any) else fail-any) else fail-any) in
        {1188}event SendMsg(me_1,them_1,stagepack_e(sid_2),msg_e(me_1,them_1,sid_2));
        {1189}out(pub, message_e_1)
    ) | (
        {1191}event LeakS(phase0,me_1);
        {1192}event LeakM(phase0,me_1);
        {1193}out(pub, (key_s(me_1),key_m(me_1)))
    ) | (
        {1194}phase 1;
        {1195}event LeakS(phase1,me_1);
        {1196}event LeakM(phase1,me_1);
        {1197}out(pub, (key_s(me_1),key_m(me_1)))
    )
) | (
    {1198}let me_2: principal = bob in
    {1199}let them_2: principal = alice in
    {1200}let sid_3: sessionid = sid in
    {1201}let s_12: keypair = keypairpack(empty,empty) in
    {1202}let m_14: keypair = keypairpack(empty,empty) in
    {1203}out(pub, (getpublickey(s_12),getpublickey(m_14)));
    (
        {1204}let e_22: keypair = keypairpack(empty,empty) in
        {1205}let rs_14: key = empty in
        {1206}let rm_14: key = empty in
        {1207}let re_14: key = empty in
        {1208}let prologue_2: bitstring = empty in
        {1209}let psk_12: key = empty in
        {1210}let protocol_name_2: bitstring = somename in
        {1211}let h_50: bitstring = hash(protocol_name_2,empty) in
        {1212}let ck_58: key = h_50 in
        {1213}let k_34: key = empty in
        {1214}let cs_50: cipherstate = cipherstatepack(k_34,minnonce) in
        {1215}let ss_58: symmetricstate = symmetricstatepack(cs_50,ck_58,h_50) in
        {1216}let v_402: bitstring = catch-fail(symmetricstateunpack(ss_58)) in
        {1217}let v_403: bool = (not-caught-fail(v_402) && success?(1-proj-3-tuple(v_402))) in
        {1218}let h_51: bitstring = (if v_403 then 3-proj-3-tuple(v_402) else caught-fail) in
        {1219}let ck_59: key = (if v_403 then 2-proj-3-tuple(v_402) else caught-fail) in
        {1220}let cs_51: cipherstate = (if v_403 then 1-proj-3-tuple(v_402) else caught-fail) in
        {1221}let ss_59: symmetricstate = catch-fail((if v_403 then symmetricstatepack(cs_51,ck_59,hash(h_51,prologue_2)) else fail-any)) in
        {1222}let v_404: bool = not-caught-fail(ss_59) in
        {1223}let hs_36: handshakestate = (if v_404 then handshakestatepack(ss_59,s_12,m_14,e_22,rs_14,rm_14,re_14,psk_12,false) else fail-any) in
        {1224}insert statestore(me_2,them_2,sid_3,statepack_a(hs_36))
    ) | (
        {1297}get statestore(=me_2,=them_2,=sid_3,statepack_a(hs_37: handshakestate)) in
        {1225}in(pub, message_a_2: bitstring);
        {1226}let v_405: bitstring = catch-fail(handshakestateunpack(hs_37)) in
        {1227}let v_406: bool = (not-caught-fail(v_405) && success?(1-proj-9-tuple(v_405))) in
        {1228}let initiator_11: bool = (if v_406 then 9-proj-9-tuple(v_405) else caught-fail) in
        {1229}let psk_13: key = (if v_406 then 8-proj-9-tuple(v_405) else caught-fail) in
        {1230}let re_15: key = (if v_406 then 7-proj-9-tuple(v_405) else caught-fail) in
        {1231}let rm_15: key = (if v_406 then 6-proj-9-tuple(v_405) else caught-fail) in
        {1232}let rs_15: key = (if v_406 then 5-proj-9-tuple(v_405) else caught-fail) in
        {1233}let e_23: keypair = (if v_406 then 4-proj-9-tuple(v_405) else caught-fail) in
        {1234}let m_15: keypair = (if v_406 then 3-proj-9-tuple(v_405) else caught-fail) in
        {1235}let s_13: keypair = (if v_406 then 2-proj-9-tuple(v_405) else caught-fail) in
        {1236}let ss_60: symmetricstate = (if v_406 then 1-proj-9-tuple(v_405) else caught-fail) in
        {1237}let v_407: bitstring = (if v_406 then catch-fail(deconcat3(message_a_2)) else caught-fail) in
        {1238}let v_408: bool = (not-caught-fail(v_407) && success?(1-proj-3-tuple(v_407))) in
        {1239}let ciphertext_24: bitstring = (if v_408 then 3-proj-3-tuple(v_407) else caught-fail) in
        {1240}let ns_10: bitstring = (if v_408 then 2-proj-3-tuple(v_407) else caught-fail) in
        {1241}let ne_16: bitstring = (if v_408 then 1-proj-3-tuple(v_407) else caught-fail) in
        {1242}let valid1_6: bool = (if v_408 then true else caught-fail) in
        {1243}let re_16: key = (if v_408 then ne_16 else caught-fail) in
        {1244}let v_409: bitstring = (if v_408 then catch-fail(symmetricstateunpack(ss_60)) else caught-fail) in
        {1245}let v_410: bool = (not-caught-fail(v_409) && success?(1-proj-3-tuple(v_409))) in
        {1246}let h_52: bitstring = (if v_410 then 3-proj-3-tuple(v_409) else caught-fail) in
        {1247}let ck_60: key = (if v_410 then 2-proj-3-tuple(v_409) else caught-fail) in
        {1248}let cs_52: cipherstate = (if v_410 then 1-proj-3-tuple(v_409) else caught-fail) in
        {1249}let ss_61: symmetricstate = (if v_408 then catch-fail((if v_410 then symmetricstatepack(cs_52,ck_60,hash(h_52,re_16)) else fail-any)) else caught-fail) in
        {1250}let v_411: bool = not-caught-fail(ss_61) in
        {1251}let v_412: bitstring = (if v_411 then catch-fail(symmetricstateunpack(ss_61)) else caught-fail) in
        {1252}let v_413: bool = (not-caught-fail(v_412) && success?(1-proj-3-tuple(v_412))) in
        {1253}let h_53: bitstring = (if v_413 then 3-proj-3-tuple(v_412) else caught-fail) in
        {1254}let ck_61: key = (if v_413 then 2-proj-3-tuple(v_412) else caught-fail) in
        {1255}let cs_53: cipherstate = (if v_413 then 1-proj-3-tuple(v_412) else caught-fail) in
        {1256}let v_414: bitstring = (if v_413 then catch-fail(cipherstateunpack(cs_53)) else caught-fail) in
        {1257}let v_415: bool = (not-caught-fail(v_414) && success?(1-proj-2-tuple(v_414))) in
        {1258}let n_32: nonce = (if v_415 then 2-proj-2-tuple(v_414) else caught-fail) in
        {1259}let k_35: key = (if v_415 then 1-proj-2-tuple(v_414) else caught-fail) in
        {1260}let d_8: aead = (if v_415 then catch-fail(decrypt(k_35,n_32,h_53,ciphertext_24)) else caught-fail) in
        {1261}let v_416: bool = not-caught-fail(d_8) in
        {1262}let v_417: bitstring = (if v_416 then catch-fail(aeadunpack(d_8)) else caught-fail) in
        {1263}let v_418: bool = (not-caught-fail(v_417) && success?(1-proj-3-tuple(v_417))) in
        {1264}let plaintext_22: bitstring = (if v_418 then 3-proj-3-tuple(v_417) else caught-fail) in
        {1265}let adi_8: bitstring = (if v_418 then 2-proj-3-tuple(v_417) else caught-fail) in
        {1266}let valid_20: bool = (if v_418 then 1-proj-3-tuple(v_417) else caught-fail) in
        {1267}let n_33: nonce = (if v_418 then increment_nonce(n_32) else caught-fail) in
        {1268}let v_419: bitstring = (if v_418 then catch-fail(cipherstateunpack(cs_53)) else caught-fail) in
        {1269}let v_420: bool = (not-caught-fail(v_419) && success?(1-proj-2-tuple(v_419))) in
        {1270}let o_16: nonce = (if v_420 then 2-proj-2-tuple(v_419) else caught-fail) in
        {1271}let k_36: key = (if v_420 then 1-proj-2-tuple(v_419) else caught-fail) in
        {1272}let csi_32: cipherstate = (if v_418 then catch-fail((if v_420 then cipherstatepack(k_36,n_33) else fail-any)) else caught-fail) in
        {1273}let v_421: bool = not-caught-fail(csi_32) in
        {1274}let v_422: bitstring = (if v_413 then catch-fail((if v_415 then (if v_416 then (if v_418 then (if v_421 then (csi_32,plaintext_22,valid_20) else fail-any) else fail-any) else fail-any) else fail-any)) else caught-fail) in
        {1275}let v_423: bool = (not-caught-fail(v_422) && success?(1-proj-3-tuple(v_422))) in
        {1276}let valid_21: bool = (if v_423 then 3-proj-3-tuple(v_422) else caught-fail) in
        {1277}let plaintext_23: bitstring = (if v_423 then 2-proj-3-tuple(v_422) else caught-fail) in
        {1278}let csi_33: cipherstate = (if v_423 then 1-proj-3-tuple(v_422) else caught-fail) in
        {1279}let ss_62: symmetricstate = (if v_423 then symmetricstatepack(csi_33,ck_61,h_53) else caught-fail) in
        {1280}let v_424: bitstring = (if v_423 then catch-fail(symmetricstateunpack(ss_62)) else caught-fail) in
        {1281}let v_425: bool = (not-caught-fail(v_424) && success?(1-proj-3-tuple(v_424))) in
        {1282}let h_54: bitstring = (if v_425 then 3-proj-3-tuple(v_424) else caught-fail) in
        {1283}let ck_62: key = (if v_425 then 2-proj-3-tuple(v_424) else caught-fail) in
        {1284}let cs_54: cipherstate = (if v_425 then 1-proj-3-tuple(v_424) else caught-fail) in
        {1285}let ssi_18: symmetricstate = (if v_423 then catch-fail((if v_425 then symmetricstatepack(cs_54,ck_62,hash(h_54,ciphertext_24)) else fail-any)) else caught-fail) in
        {1286}let v_426: bool = not-caught-fail(ssi_18) in
        {1287}let v_427: bitstring = (if v_411 then catch-fail((if v_413 then (if v_423 then (if v_426 then (ssi_18,plaintext_23,valid_21) else fail-any) else fail-any) else fail-any)) else caught-fail) in
        {1288}let v_428: bool = (not-caught-fail(v_427) && success?(1-proj-3-tuple(v_427))) in
        {1289}let valid2_4: bool = (if v_428 then 3-proj-3-tuple(v_427) else caught-fail) in
        {1290}let plaintext_24: bitstring = (if v_428 then 2-proj-3-tuple(v_427) else caught-fail) in
        {1291}let ss_63: symmetricstate = (if v_428 then 1-proj-3-tuple(v_427) else caught-fail) in
        {1292}let v_429: bool = (if v_428 then catch-fail((valid1_6 && valid2_4)) else caught-fail) in
        {1293}let hs_38: handshakestate = (if v_429 then handshakestatepack(ss_63,s_13,m_15,e_23,rs_15,rm_15,re_16,psk_13,initiator_11) else caught-fail) in
        {1294}let (hs_39: handshakestate,plaintext_a: bitstring,valid_22: bool) = (if v_406 then (if v_408 then (if v_411 then (if v_428 then (if undo-catch-fail(v_429) then (hs_38,plaintext_24,true) else fail-any) else fail-any) else fail-any) else fail-any) else fail-any) in
        {1295}event RecvMsg(me_2,them_2,stagepack_a(sid_3),plaintext_a);
        {1296}insert statestore(me_2,them_2,sid_3,statepack_b(hs_39))
    ) | (
        {1512}get statestore(=me_2,=them_2,=sid_3,statepack_b(hs_40: handshakestate)) in
        {1298}let payload_6: bitstring = msg_b(me_2,them_2,sid_3) in
        {1299}let v_430: bitstring = catch-fail(handshakestateunpack(hs_40)) in
        {1300}let v_431: bool = (not-caught-fail(v_430) && success?(1-proj-9-tuple(v_430))) in
        {1301}let initiator_12: bool = (if v_431 then 9-proj-9-tuple(v_430) else caught-fail) in
        {1302}let psk_14: key = (if v_431 then 8-proj-9-tuple(v_430) else caught-fail) in
        {1303}let re_17: key = (if v_431 then 7-proj-9-tuple(v_430) else caught-fail) in
        {1304}let rm_16: key = (if v_431 then 6-proj-9-tuple(v_430) else caught-fail) in
        {1305}let rs_16: key = (if v_431 then 5-proj-9-tuple(v_430) else caught-fail) in
        {1306}let e_24: keypair = (if v_431 then 4-proj-9-tuple(v_430) else caught-fail) in
        {1307}let m_16: keypair = (if v_431 then 3-proj-9-tuple(v_430) else caught-fail) in
        {1308}let s_14: keypair = (if v_431 then 2-proj-9-tuple(v_430) else caught-fail) in
        {1309}let ss_64: symmetricstate = (if v_431 then 1-proj-9-tuple(v_430) else caught-fail) in
        {1310}let v_432: bitstring = (if v_431 then catch-fail((empty,empty,empty,empty)) else caught-fail) in
        {1311}let v_433: bool = (not-caught-fail(v_432) && success?(1-proj-4-tuple(v_432))) in
        {1312}let ciphertext_25: bitstring = (if v_433 then 4-proj-4-tuple(v_432) else caught-fail) in
        {1313}let nm_6: bitstring = (if v_433 then 3-proj-4-tuple(v_432) else caught-fail) in
        {1314}let ns_11: bitstring = (if v_433 then 2-proj-4-tuple(v_432) else caught-fail) in
        {1315}let ne_17: bitstring = (if v_433 then 1-proj-4-tuple(v_432) else caught-fail) in
        {1316}let basis_8: key = (if v_433 then key_e(me_2,them_2,sid_3) else caught-fail) in
        {1317}let public_key_8: key = (if v_433 then catch-fail(dhexp(basis_8,validkey(g))) else caught-fail) in
        {1318}let v_434: bool = not-caught-fail(public_key_8) in
        {1319}let e_25: keypair = (if v_433 then catch-fail((if v_434 then keypairpack(validkey(public_key_8),basis_8) else fail-any)) else caught-fail) in
        {1320}let v_435: bool = not-caught-fail(e_25) in
        {1321}let ne_18: bitstring = (if v_435 then catch-fail(getpublickey(e_25)) else caught-fail) in
        {1322}let v_436: bool = not-caught-fail(ne_18) in
        {1323}let v_437: bitstring = (if v_436 then catch-fail(symmetricstateunpack(ss_64)) else caught-fail) in
        {1324}let v_438: bool = (not-caught-fail(v_437) && success?(1-proj-3-tuple(v_437))) in
        {1325}let h_55: bitstring = (if v_438 then 3-proj-3-tuple(v_437) else caught-fail) in
        {1326}let ck_63: key = (if v_438 then 2-proj-3-tuple(v_437) else caught-fail) in
        {1327}let cs_55: cipherstate = (if v_438 then 1-proj-3-tuple(v_437) else caught-fail) in
        {1328}let ss_65: symmetricstate = (if v_436 then catch-fail((if v_438 then symmetricstatepack(cs_55,ck_63,hash(h_55,ne_18)) else fail-any)) else caught-fail) in
        {1329}let v_439: bool = not-caught-fail(ss_65) in
        {1330}let v_440: bitstring = (if v_439 then catch-fail(keypairunpack(e_25)) else caught-fail) in
        {1331}let v_441: bool = (not-caught-fail(v_440) && success?(1-proj-2-tuple(v_440))) in
        {1332}let my_private_key_8: key = (if v_441 then 2-proj-2-tuple(v_440) else caught-fail) in
        {1333}let my_public_key_8: key = (if v_441 then 1-proj-2-tuple(v_440) else caught-fail) in
        {1334}let input_key_material_10: key = (if v_439 then catch-fail((if v_441 then dhexp(my_private_key_8,re_17) else fail-any)) else caught-fail) in
        {1335}let v_442: bool = not-caught-fail(input_key_material_10) in
        {1336}let v_443: bitstring = (if v_442 then catch-fail(symmetricstateunpack(ss_65)) else caught-fail) in
        {1337}let v_444: bool = (not-caught-fail(v_443) && success?(1-proj-3-tuple(v_443))) in
        {1338}let h_56: bitstring = (if v_444 then 3-proj-3-tuple(v_443) else caught-fail) in
        {1339}let ck_64: key = (if v_444 then 2-proj-3-tuple(v_443) else caught-fail) in
        {1340}let cs_56: cipherstate = (if v_444 then 1-proj-3-tuple(v_443) else caught-fail) in
        {1341}let output1_10: key = (if v_444 then hmac_hash1(ck_64,input_key_material_10) else caught-fail) in
        {1342}let output2_10: key = (if v_444 then hmac_hash2(ck_64,input_key_material_10) else caught-fail) in
        {1343}let output3_10: key = (if v_444 then hmac_hash3(ck_64,input_key_material_10) else caught-fail) in
        {1344}let v_445: bitstring = (if v_444 then catch-fail((output1_10,output2_10,output3_10)) else caught-fail) in
        {1345}let v_446: bool = (not-caught-fail(v_445) && success?(1-proj-3-tuple(v_445))) in
        {1346}let output_8: key = (if v_446 then 3-proj-3-tuple(v_445) else caught-fail) in
        {1347}let temp_k_8: key = (if v_446 then 2-proj-3-tuple(v_445) else caught-fail) in
        {1348}let ck_65: key = (if v_446 then 1-proj-3-tuple(v_445) else caught-fail) in
        {1349}let ss_66: symmetricstate = (if v_439 then catch-fail((if v_442 then (if v_444 then (if v_446 then symmetricstatepack(cipherstatepack(temp_k_8,minnonce),ck_65,h_56) else fail-any) else fail-any) else fail-any)) else caught-fail) in
        {1350}let v_447: bool = not-caught-fail(ss_66) in
        {1351}let basis_9: key = (if v_447 then key_s(me_2) else caught-fail) in
        {1352}let public_key_9: key = (if v_447 then catch-fail(dhexp(basis_9,validkey(g))) else caught-fail) in
        {1353}let v_448: bool = not-caught-fail(public_key_9) in
        {1354}let s_15: keypair = (if v_447 then catch-fail((if v_448 then keypairpack(validkey(public_key_9),basis_9) else fail-any)) else caught-fail) in
        {1355}let v_449: bool = not-caught-fail(s_15) in
        {1356}let plaintext_25: bitstring = (if v_449 then catch-fail(getpublickey(s_15)) else caught-fail) in
        {1357}let v_450: bool = not-caught-fail(plaintext_25) in
        {1358}let v_451: bitstring = (if v_450 then catch-fail(symmetricstateunpack(ss_66)) else caught-fail) in
        {1359}let v_452: bool = (not-caught-fail(v_451) && success?(1-proj-3-tuple(v_451))) in
        {1360}let h_57: bitstring = (if v_452 then 3-proj-3-tuple(v_451) else caught-fail) in
        {1361}let ck_66: key = (if v_452 then 2-proj-3-tuple(v_451) else caught-fail) in
        {1362}let cs_57: cipherstate = (if v_452 then 1-proj-3-tuple(v_451) else caught-fail) in
        {1363}let v_453: bitstring = (if v_452 then catch-fail(cipherstateunpack(cs_57)) else caught-fail) in
        {1364}let v_454: bool = (not-caught-fail(v_453) && success?(1-proj-2-tuple(v_453))) in
        {1365}let n_34: nonce = (if v_454 then 2-proj-2-tuple(v_453) else caught-fail) in
        {1366}let k_37: key = (if v_454 then 1-proj-2-tuple(v_453) else caught-fail) in
        {1367}let e_26: bitstring = (if v_454 then encrypt(k_37,n_34,h_57,plaintext_25) else caught-fail) in
        {1368}let n_35: nonce = (if v_454 then increment_nonce(n_34) else caught-fail) in
        {1369}let v_455: bitstring = (if v_454 then catch-fail(cipherstateunpack(cs_57)) else caught-fail) in
        {1370}let v_456: bool = (not-caught-fail(v_455) && success?(1-proj-2-tuple(v_455))) in
        {1371}let o_17: nonce = (if v_456 then 2-proj-2-tuple(v_455) else caught-fail) in
        {1372}let k_38: key = (if v_456 then 1-proj-2-tuple(v_455) else caught-fail) in
        {1373}let csi_34: cipherstate = (if v_454 then catch-fail((if v_456 then cipherstatepack(k_38,n_35) else fail-any)) else caught-fail) in
        {1374}let v_457: bool = not-caught-fail(csi_34) in
        {1375}let v_458: bitstring = (if v_452 then catch-fail((if v_454 then (if v_457 then (csi_34,e_26) else fail-any) else fail-any)) else caught-fail) in
        {1376}let v_459: bool = (not-caught-fail(v_458) && success?(1-proj-2-tuple(v_458))) in
        {1377}let ciphertext_26: bitstring = (if v_459 then 2-proj-2-tuple(v_458) else caught-fail) in
        {1378}let csi_35: cipherstate = (if v_459 then 1-proj-2-tuple(v_458) else caught-fail) in
        {1379}let ss_67: symmetricstate = (if v_459 then symmetricstatepack(csi_35,ck_66,h_57) else caught-fail) in
        {1380}let v_460: bitstring = (if v_459 then catch-fail(symmetricstateunpack(ss_67)) else caught-fail) in
        {1381}let v_461: bool = (not-caught-fail(v_460) && success?(1-proj-3-tuple(v_460))) in
        {1382}let h_58: bitstring = (if v_461 then 3-proj-3-tuple(v_460) else caught-fail) in
        {1383}let ck_67: key = (if v_461 then 2-proj-3-tuple(v_460) else caught-fail) in
        {1384}let cs_58: cipherstate = (if v_461 then 1-proj-3-tuple(v_460) else caught-fail) in
        {1385}let ssi_19: symmetricstate = (if v_459 then catch-fail((if v_461 then symmetricstatepack(cs_58,ck_67,hash(h_58,ciphertext_26)) else fail-any)) else caught-fail) in
        {1386}let v_462: bool = not-caught-fail(ssi_19) in
        {1387}let v_463: bitstring = (if v_449 then catch-fail((if v_450 then (if v_452 then (if v_459 then (if v_462 then (ssi_19,ciphertext_26) else fail-any) else fail-any) else fail-any) else fail-any)) else caught-fail) in
        {1388}let v_464: bool = (not-caught-fail(v_463) && success?(1-proj-2-tuple(v_463))) in
        {1389}let ns_12: bitstring = (if v_464 then 2-proj-2-tuple(v_463) else caught-fail) in
        {1390}let ss_68: symmetricstate = (if v_464 then 1-proj-2-tuple(v_463) else caught-fail) in
        {1391}let basis_10: key = (if v_464 then key_m(me_2) else caught-fail) in
        {1392}let public_key_10: key = (if v_464 then catch-fail(dhexp(basis_10,validkey(g))) else caught-fail) in
        {1393}let v_465: bool = not-caught-fail(public_key_10) in
        {1394}let m_17: keypair = (if v_464 then catch-fail((if v_465 then keypairpack(validkey(public_key_10),basis_10) else fail-any)) else caught-fail) in
        {1395}let v_466: bool = not-caught-fail(m_17) in
        {1396}let plaintext_26: bitstring = (if v_466 then catch-fail(getpublickey(m_17)) else caught-fail) in
        {1397}let v_467: bool = not-caught-fail(plaintext_26) in
        {1398}let v_468: bitstring = (if v_467 then catch-fail(symmetricstateunpack(ss_68)) else caught-fail) in
        {1399}let v_469: bool = (not-caught-fail(v_468) && success?(1-proj-3-tuple(v_468))) in
        {1400}let h_59: bitstring = (if v_469 then 3-proj-3-tuple(v_468) else caught-fail) in
        {1401}let ck_68: key = (if v_469 then 2-proj-3-tuple(v_468) else caught-fail) in
        {1402}let cs_59: cipherstate = (if v_469 then 1-proj-3-tuple(v_468) else caught-fail) in
        {1403}let v_470: bitstring = (if v_469 then catch-fail(cipherstateunpack(cs_59)) else caught-fail) in
        {1404}let v_471: bool = (not-caught-fail(v_470) && success?(1-proj-2-tuple(v_470))) in
        {1405}let n_36: nonce = (if v_471 then 2-proj-2-tuple(v_470) else caught-fail) in
        {1406}let k_39: key = (if v_471 then 1-proj-2-tuple(v_470) else caught-fail) in
        {1407}let e_27: bitstring = (if v_471 then encrypt(k_39,n_36,h_59,plaintext_26) else caught-fail) in
        {1408}let n_37: nonce = (if v_471 then increment_nonce(n_36) else caught-fail) in
        {1409}let v_472: bitstring = (if v_471 then catch-fail(cipherstateunpack(cs_59)) else caught-fail) in
        {1410}let v_473: bool = (not-caught-fail(v_472) && success?(1-proj-2-tuple(v_472))) in
        {1411}let o_18: nonce = (if v_473 then 2-proj-2-tuple(v_472) else caught-fail) in
        {1412}let k_40: key = (if v_473 then 1-proj-2-tuple(v_472) else caught-fail) in
        {1413}let csi_36: cipherstate = (if v_471 then catch-fail((if v_473 then cipherstatepack(k_40,n_37) else fail-any)) else caught-fail) in
        {1414}let v_474: bool = not-caught-fail(csi_36) in
        {1415}let v_475: bitstring = (if v_469 then catch-fail((if v_471 then (if v_474 then (csi_36,e_27) else fail-any) else fail-any)) else caught-fail) in
        {1416}let v_476: bool = (not-caught-fail(v_475) && success?(1-proj-2-tuple(v_475))) in
        {1417}let ciphertext_27: bitstring = (if v_476 then 2-proj-2-tuple(v_475) else caught-fail) in
        {1418}let csi_37: cipherstate = (if v_476 then 1-proj-2-tuple(v_475) else caught-fail) in
        {1419}let ss_69: symmetricstate = (if v_476 then symmetricstatepack(csi_37,ck_68,h_59) else caught-fail) in
        {1420}let v_477: bitstring = (if v_476 then catch-fail(symmetricstateunpack(ss_69)) else caught-fail) in
        {1421}let v_478: bool = (not-caught-fail(v_477) && success?(1-proj-3-tuple(v_477))) in
        {1422}let h_60: bitstring = (if v_478 then 3-proj-3-tuple(v_477) else caught-fail) in
        {1423}let ck_69: key = (if v_478 then 2-proj-3-tuple(v_477) else caught-fail) in
        {1424}let cs_60: cipherstate = (if v_478 then 1-proj-3-tuple(v_477) else caught-fail) in
        {1425}let ssi_20: symmetricstate = (if v_476 then catch-fail((if v_478 then symmetricstatepack(cs_60,ck_69,hash(h_60,ciphertext_27)) else fail-any)) else caught-fail) in
        {1426}let v_479: bool = not-caught-fail(ssi_20) in
        {1427}let v_480: bitstring = (if v_466 then catch-fail((if v_467 then (if v_469 then (if v_476 then (if v_479 then (ssi_20,ciphertext_27) else fail-any) else fail-any) else fail-any) else fail-any)) else caught-fail) in
        {1428}let v_481: bool = (not-caught-fail(v_480) && success?(1-proj-2-tuple(v_480))) in
        {1429}let nm_7: bitstring = (if v_481 then 2-proj-2-tuple(v_480) else caught-fail) in
        {1430}let ss_70: symmetricstate = (if v_481 then 1-proj-2-tuple(v_480) else caught-fail) in
        {1431}let v_482: bitstring = (if v_481 then catch-fail(keypairunpack(s_15)) else caught-fail) in
        {1432}let v_483: bool = (not-caught-fail(v_482) && success?(1-proj-2-tuple(v_482))) in
        {1433}let my_private_key_9: key = (if v_483 then 2-proj-2-tuple(v_482) else caught-fail) in
        {1434}let my_public_key_9: key = (if v_483 then 1-proj-2-tuple(v_482) else caught-fail) in
        {1435}let input_key_material_11: key = (if v_481 then catch-fail((if v_483 then dhexp(my_private_key_9,re_17) else fail-any)) else caught-fail) in
        {1436}let v_484: bool = not-caught-fail(input_key_material_11) in
        {1437}let v_485: bitstring = (if v_484 then catch-fail(symmetricstateunpack(ss_70)) else caught-fail) in
        {1438}let v_486: bool = (not-caught-fail(v_485) && success?(1-proj-3-tuple(v_485))) in
        {1439}let h_61: bitstring = (if v_486 then 3-proj-3-tuple(v_485) else caught-fail) in
        {1440}let ck_70: key = (if v_486 then 2-proj-3-tuple(v_485) else caught-fail) in
        {1441}let cs_61: cipherstate = (if v_486 then 1-proj-3-tuple(v_485) else caught-fail) in
        {1442}let output1_11: key = (if v_486 then hmac_hash1(ck_70,input_key_material_11) else caught-fail) in
        {1443}let output2_11: key = (if v_486 then hmac_hash2(ck_70,input_key_material_11) else caught-fail) in
        {1444}let output3_11: key = (if v_486 then hmac_hash3(ck_70,input_key_material_11) else caught-fail) in
        {1445}let v_487: bitstring = (if v_486 then catch-fail((output1_11,output2_11,output3_11)) else caught-fail) in
        {1446}let v_488: bool = (not-caught-fail(v_487) && success?(1-proj-3-tuple(v_487))) in
        {1447}let output_9: key = (if v_488 then 3-proj-3-tuple(v_487) else caught-fail) in
        {1448}let temp_k_9: key = (if v_488 then 2-proj-3-tuple(v_487) else caught-fail) in
        {1449}let ck_71: key = (if v_488 then 1-proj-3-tuple(v_487) else caught-fail) in
        {1450}let ss_71: symmetricstate = (if v_481 then catch-fail((if v_484 then (if v_486 then (if v_488 then symmetricstatepack(cipherstatepack(temp_k_9,minnonce),ck_71,h_61) else fail-any) else fail-any) else fail-any)) else caught-fail) in
        {1451}let v_489: bool = not-caught-fail(ss_71) in
        {1452}let v_490: bitstring = (if v_489 then catch-fail(keypairunpack(m_17)) else caught-fail) in
        {1453}let v_491: bool = (not-caught-fail(v_490) && success?(1-proj-2-tuple(v_490))) in
        {1454}let my_private_key_10: key = (if v_491 then 2-proj-2-tuple(v_490) else caught-fail) in
        {1455}let my_public_key_10: key = (if v_491 then 1-proj-2-tuple(v_490) else caught-fail) in
        {1456}let input_key_material_12: key = (if v_489 then catch-fail((if v_491 then dhexp(my_private_key_10,re_17) else fail-any)) else caught-fail) in
        {1457}let v_492: bool = not-caught-fail(input_key_material_12) in
        {1458}let v_493: bitstring = (if v_492 then catch-fail(symmetricstateunpack(ss_71)) else caught-fail) in
        {1459}let v_494: bool = (not-caught-fail(v_493) && success?(1-proj-3-tuple(v_493))) in
        {1460}let h_62: bitstring = (if v_494 then 3-proj-3-tuple(v_493) else caught-fail) in
        {1461}let ck_72: key = (if v_494 then 2-proj-3-tuple(v_493) else caught-fail) in
        {1462}let cs_62: cipherstate = (if v_494 then 1-proj-3-tuple(v_493) else caught-fail) in
        {1463}let output1_12: key = (if v_494 then hmac_hash1(ck_72,input_key_material_12) else caught-fail) in
        {1464}let output2_12: key = (if v_494 then hmac_hash2(ck_72,input_key_material_12) else caught-fail) in
        {1465}let output3_12: key = (if v_494 then hmac_hash3(ck_72,input_key_material_12) else caught-fail) in
        {1466}let v_495: bitstring = (if v_494 then catch-fail((output1_12,output2_12,output3_12)) else caught-fail) in
        {1467}let v_496: bool = (not-caught-fail(v_495) && success?(1-proj-3-tuple(v_495))) in
        {1468}let output_10: key = (if v_496 then 3-proj-3-tuple(v_495) else caught-fail) in
        {1469}let temp_k_10: key = (if v_496 then 2-proj-3-tuple(v_495) else caught-fail) in
        {1470}let ck_73: key = (if v_496 then 1-proj-3-tuple(v_495) else caught-fail) in
        {1471}let ss_72: symmetricstate = (if v_489 then catch-fail((if v_492 then (if v_494 then (if v_496 then symmetricstatepack(cipherstatepack(temp_k_10,minnonce),ck_73,h_62) else fail-any) else fail-any) else fail-any)) else caught-fail) in
        {1472}let v_497: bool = not-caught-fail(ss_72) in
        {1473}let v_498: bitstring = (if v_497 then catch-fail(symmetricstateunpack(ss_72)) else caught-fail) in
        {1474}let v_499: bool = (not-caught-fail(v_498) && success?(1-proj-3-tuple(v_498))) in
        {1475}let h_63: bitstring = (if v_499 then 3-proj-3-tuple(v_498) else caught-fail) in
        {1476}let ck_74: key = (if v_499 then 2-proj-3-tuple(v_498) else caught-fail) in
        {1477}let cs_63: cipherstate = (if v_499 then 1-proj-3-tuple(v_498) else caught-fail) in
        {1478}let v_500: bitstring = (if v_499 then catch-fail(cipherstateunpack(cs_63)) else caught-fail) in
        {1479}let v_501: bool = (not-caught-fail(v_500) && success?(1-proj-2-tuple(v_500))) in
        {1480}let n_38: nonce = (if v_501 then 2-proj-2-tuple(v_500) else caught-fail) in
        {1481}let k_41: key = (if v_501 then 1-proj-2-tuple(v_500) else caught-fail) in
        {1482}let e_28: bitstring = (if v_501 then encrypt(k_41,n_38,h_63,payload_6) else caught-fail) in
        {1483}let n_39: nonce = (if v_501 then increment_nonce(n_38) else caught-fail) in
        {1484}let v_502: bitstring = (if v_501 then catch-fail(cipherstateunpack(cs_63)) else caught-fail) in
        {1485}let v_503: bool = (not-caught-fail(v_502) && success?(1-proj-2-tuple(v_502))) in
        {1486}let o_19: nonce = (if v_503 then 2-proj-2-tuple(v_502) else caught-fail) in
        {1487}let k_42: key = (if v_503 then 1-proj-2-tuple(v_502) else caught-fail) in
        {1488}let csi_38: cipherstate = (if v_501 then catch-fail((if v_503 then cipherstatepack(k_42,n_39) else fail-any)) else caught-fail) in
        {1489}let v_504: bool = not-caught-fail(csi_38) in
        {1490}let v_505: bitstring = (if v_499 then catch-fail((if v_501 then (if v_504 then (csi_38,e_28) else fail-any) else fail-any)) else caught-fail) in
        {1491}let v_506: bool = (not-caught-fail(v_505) && success?(1-proj-2-tuple(v_505))) in
        {1492}let ciphertext_28: bitstring = (if v_506 then 2-proj-2-tuple(v_505) else caught-fail) in
        {1493}let csi_39: cipherstate = (if v_506 then 1-proj-2-tuple(v_505) else caught-fail) in
        {1494}let ss_73: symmetricstate = (if v_506 then symmetricstatepack(csi_39,ck_74,h_63) else caught-fail) in
        {1495}let v_507: bitstring = (if v_506 then catch-fail(symmetricstateunpack(ss_73)) else caught-fail) in
        {1496}let v_508: bool = (not-caught-fail(v_507) && success?(1-proj-3-tuple(v_507))) in
        {1497}let h_64: bitstring = (if v_508 then 3-proj-3-tuple(v_507) else caught-fail) in
        {1498}let ck_75: key = (if v_508 then 2-proj-3-tuple(v_507) else caught-fail) in
        {1499}let cs_64: cipherstate = (if v_508 then 1-proj-3-tuple(v_507) else caught-fail) in
        {1500}let ssi_21: symmetricstate = (if v_506 then catch-fail((if v_508 then symmetricstatepack(cs_64,ck_75,hash(h_64,ciphertext_28)) else fail-any)) else caught-fail) in
        {1501}let v_509: bool = not-caught-fail(ssi_21) in
        {1502}let v_510: bitstring = (if v_497 then catch-fail((if v_499 then (if v_506 then (if v_509 then (ssi_21,ciphertext_28) else fail-any) else fail-any) else fail-any)) else caught-fail) in
        {1503}let v_511: bool = (not-caught-fail(v_510) && success?(1-proj-2-tuple(v_510))) in
        {1504}let ciphertext_29: bitstring = (if v_511 then 2-proj-2-tuple(v_510) else caught-fail) in
        {1505}let ss_74: symmetricstate = (if v_511 then 1-proj-2-tuple(v_510) else caught-fail) in
        {1506}let hs_41: handshakestate = (if v_511 then handshakestatepack(ss_74,s_15,m_17,e_25,rs_16,rm_16,re_17,psk_14,initiator_12) else caught-fail) in
        {1507}let message_buffer_6: bitstring = (if v_511 then concat4(ne_18,ns_12,nm_7,ciphertext_29) else caught-fail) in
        {1508}let (hs_42: handshakestate,message_b_2: bitstring) = (if v_431 then (if v_433 then (if v_435 then (if v_436 then (if v_439 then (if v_447 then (if v_449 then (if v_464 then (if v_466 then (if v_481 then (if v_489 then (if v_497 then (if v_511 then (hs_41,message_buffer_6) else fail-any) else fail-any) else fail-any) else fail-any) else fail-any) else fail-any) else fail-any) else fail-any) else fail-any) else fail-any) else fail-any) else fail-any) else fail-any) in
        {1509}event SendMsg(me_2,them_2,stagepack_b(sid_3),msg_b(me_2,them_2,sid_3));
        {1510}insert statestore(me_2,them_2,sid_3,statepack_c(hs_42));
        {1511}out(pub, message_b_2)
    ) | (
        {1667}get statestore(=me_2,=them_2,=sid_3,statepack_c(hs_43: handshakestate)) in
        {1513}in(pub, message_c_2: bitstring);
        {1514}let v_512: bitstring = catch-fail(handshakestateunpack(hs_43)) in
        {1515}let v_513: bool = (not-caught-fail(v_512) && success?(1-proj-9-tuple(v_512))) in
        {1516}let initiator_13: bool = (if v_513 then 9-proj-9-tuple(v_512) else caught-fail) in
        {1517}let psk_15: key = (if v_513 then 8-proj-9-tuple(v_512) else caught-fail) in
        {1518}let re_18: key = (if v_513 then 7-proj-9-tuple(v_512) else caught-fail) in
        {1519}let rm_17: key = (if v_513 then 6-proj-9-tuple(v_512) else caught-fail) in
        {1520}let rs_17: key = (if v_513 then 5-proj-9-tuple(v_512) else caught-fail) in
        {1521}let e_29: keypair = (if v_513 then 4-proj-9-tuple(v_512) else caught-fail) in
        {1522}let m_18: keypair = (if v_513 then 3-proj-9-tuple(v_512) else caught-fail) in
        {1523}let s_16: keypair = (if v_513 then 2-proj-9-tuple(v_512) else caught-fail) in
        {1524}let ss_75: symmetricstate = (if v_513 then 1-proj-9-tuple(v_512) else caught-fail) in
        {1525}let v_514: bitstring = (if v_513 then catch-fail(deconcat3(message_c_2)) else caught-fail) in
        {1526}let v_515: bool = (not-caught-fail(v_514) && success?(1-proj-3-tuple(v_514))) in
        {1527}let ciphertext_30: bitstring = (if v_515 then 3-proj-3-tuple(v_514) else caught-fail) in
        {1528}let nm_8: bitstring = (if v_515 then 2-proj-3-tuple(v_514) else caught-fail) in
        {1529}let ne_19: bitstring = (if v_515 then 1-proj-3-tuple(v_514) else caught-fail) in
        {1530}let valid1_7: bool = (if v_515 then true else caught-fail) in
        {1531}let v_516: bitstring = (if v_515 then catch-fail(symmetricstateunpack(ss_75)) else caught-fail) in
        {1532}let v_517: bool = (not-caught-fail(v_516) && success?(1-proj-3-tuple(v_516))) in
        {1533}let h_65: bitstring = (if v_517 then 3-proj-3-tuple(v_516) else caught-fail) in
        {1534}let ck_76: key = (if v_517 then 2-proj-3-tuple(v_516) else caught-fail) in
        {1535}let cs_65: cipherstate = (if v_517 then 1-proj-3-tuple(v_516) else caught-fail) in
        {1536}let v_518: bitstring = (if v_517 then catch-fail(cipherstateunpack(cs_65)) else caught-fail) in
        {1537}let v_519: bool = (not-caught-fail(v_518) && success?(1-proj-2-tuple(v_518))) in
        {1538}let n_40: nonce = (if v_519 then 2-proj-2-tuple(v_518) else caught-fail) in
        {1539}let k_43: key = (if v_519 then 1-proj-2-tuple(v_518) else caught-fail) in
        {1540}let d_9: aead = (if v_519 then catch-fail(decrypt(k_43,n_40,h_65,nm_8)) else caught-fail) in
        {1541}let v_520: bool = not-caught-fail(d_9) in
        {1542}let v_521: bitstring = (if v_520 then catch-fail(aeadunpack(d_9)) else caught-fail) in
        {1543}let v_522: bool = (not-caught-fail(v_521) && success?(1-proj-3-tuple(v_521))) in
        {1544}let plaintext_27: bitstring = (if v_522 then 3-proj-3-tuple(v_521) else caught-fail) in
        {1545}let adi_9: bitstring = (if v_522 then 2-proj-3-tuple(v_521) else caught-fail) in
        {1546}let valid_23: bool = (if v_522 then 1-proj-3-tuple(v_521) else caught-fail) in
        {1547}let n_41: nonce = (if v_522 then increment_nonce(n_40) else caught-fail) in
        {1548}let v_523: bitstring = (if v_522 then catch-fail(cipherstateunpack(cs_65)) else caught-fail) in
        {1549}let v_524: bool = (not-caught-fail(v_523) && success?(1-proj-2-tuple(v_523))) in
        {1550}let o_20: nonce = (if v_524 then 2-proj-2-tuple(v_523) else caught-fail) in
        {1551}let k_44: key = (if v_524 then 1-proj-2-tuple(v_523) else caught-fail) in
        {1552}let csi_40: cipherstate = (if v_522 then catch-fail((if v_524 then cipherstatepack(k_44,n_41) else fail-any)) else caught-fail) in
        {1553}let v_525: bool = not-caught-fail(csi_40) in
        {1554}let v_526: bitstring = (if v_517 then catch-fail((if v_519 then (if v_520 then (if v_522 then (if v_525 then (csi_40,plaintext_27,valid_23) else fail-any) else fail-any) else fail-any) else fail-any)) else caught-fail) in
        {1555}let v_527: bool = (not-caught-fail(v_526) && success?(1-proj-3-tuple(v_526))) in
        {1556}let valid_24: bool = (if v_527 then 3-proj-3-tuple(v_526) else caught-fail) in
        {1557}let plaintext_28: bitstring = (if v_527 then 2-proj-3-tuple(v_526) else caught-fail) in
        {1558}let csi_41: cipherstate = (if v_527 then 1-proj-3-tuple(v_526) else caught-fail) in
        {1559}let ss_76: symmetricstate = (if v_527 then symmetricstatepack(csi_41,ck_76,h_65) else caught-fail) in
        {1560}let v_528: bitstring = (if v_527 then catch-fail(symmetricstateunpack(ss_76)) else caught-fail) in
        {1561}let v_529: bool = (not-caught-fail(v_528) && success?(1-proj-3-tuple(v_528))) in
        {1562}let h_66: bitstring = (if v_529 then 3-proj-3-tuple(v_528) else caught-fail) in
        {1563}let ck_77: key = (if v_529 then 2-proj-3-tuple(v_528) else caught-fail) in
        {1564}let cs_66: cipherstate = (if v_529 then 1-proj-3-tuple(v_528) else caught-fail) in
        {1565}let ssi_22: symmetricstate = (if v_527 then catch-fail((if v_529 then symmetricstatepack(cs_66,ck_77,hash(h_66,nm_8)) else fail-any)) else caught-fail) in
        {1566}let v_530: bool = not-caught-fail(ssi_22) in
        {1567}let v_531: bitstring = (if v_515 then catch-fail((if v_517 then (if v_527 then (if v_530 then (ssi_22,plaintext_28,valid_24) else fail-any) else fail-any) else fail-any)) else caught-fail) in
        {1568}let v_532: bool = (not-caught-fail(v_531) && success?(1-proj-3-tuple(v_531))) in
        {1569}let valid2_5: bool = (if v_532 then 3-proj-3-tuple(v_531) else caught-fail) in
        {1570}let nem: bitstring = (if v_532 then 2-proj-3-tuple(v_531) else caught-fail) in
        {1571}let ss_77: symmetricstate = (if v_532 then 1-proj-3-tuple(v_531) else caught-fail) in
        {1572}let rm_18: key = (if v_532 then nem else caught-fail) in
        {1573}let v_533: bitstring = (if v_532 then catch-fail(keypairunpack(e_29)) else caught-fail) in
        {1574}let v_534: bool = (not-caught-fail(v_533) && success?(1-proj-2-tuple(v_533))) in
        {1575}let my_private_key_11: key = (if v_534 then 2-proj-2-tuple(v_533) else caught-fail) in
        {1576}let my_public_key_11: key = (if v_534 then 1-proj-2-tuple(v_533) else caught-fail) in
        {1577}let input_key_material_13: key = (if v_532 then catch-fail((if v_534 then dhexp(my_private_key_11,rm_18) else fail-any)) else caught-fail) in
        {1578}let v_535: bool = not-caught-fail(input_key_material_13) in
        {1579}let v_536: bitstring = (if v_535 then catch-fail(symmetricstateunpack(ss_77)) else caught-fail) in
        {1580}let v_537: bool = (not-caught-fail(v_536) && success?(1-proj-3-tuple(v_536))) in
        {1581}let h_67: bitstring = (if v_537 then 3-proj-3-tuple(v_536) else caught-fail) in
        {1582}let ck_78: key = (if v_537 then 2-proj-3-tuple(v_536) else caught-fail) in
        {1583}let cs_67: cipherstate = (if v_537 then 1-proj-3-tuple(v_536) else caught-fail) in
        {1584}let output1_13: key = (if v_537 then hmac_hash1(ck_78,input_key_material_13) else caught-fail) in
        {1585}let output2_13: key = (if v_537 then hmac_hash2(ck_78,input_key_material_13) else caught-fail) in
        {1586}let output3_13: key = (if v_537 then hmac_hash3(ck_78,input_key_material_13) else caught-fail) in
        {1587}let v_538: bitstring = (if v_537 then catch-fail((output1_13,output2_13,output3_13)) else caught-fail) in
        {1588}let v_539: bool = (not-caught-fail(v_538) && success?(1-proj-3-tuple(v_538))) in
        {1589}let output_11: key = (if v_539 then 3-proj-3-tuple(v_538) else caught-fail) in
        {1590}let temp_k_11: key = (if v_539 then 2-proj-3-tuple(v_538) else caught-fail) in
        {1591}let ck_79: key = (if v_539 then 1-proj-3-tuple(v_538) else caught-fail) in
        {1592}let ss_78: symmetricstate = (if v_532 then catch-fail((if v_535 then (if v_537 then (if v_539 then symmetricstatepack(cipherstatepack(temp_k_11,minnonce),ck_79,h_67) else fail-any) else fail-any) else fail-any)) else caught-fail) in
        {1593}let v_540: bool = not-caught-fail(ss_78) in
        {1594}let v_541: bitstring = (if v_540 then catch-fail(symmetricstateunpack(ss_78)) else caught-fail) in
        {1595}let v_542: bool = (not-caught-fail(v_541) && success?(1-proj-3-tuple(v_541))) in
        {1596}let h_68: bitstring = (if v_542 then 3-proj-3-tuple(v_541) else caught-fail) in
        {1597}let ck_80: key = (if v_542 then 2-proj-3-tuple(v_541) else caught-fail) in
        {1598}let cs_68: cipherstate = (if v_542 then 1-proj-3-tuple(v_541) else caught-fail) in
        {1599}let v_543: bitstring = (if v_542 then catch-fail(cipherstateunpack(cs_68)) else caught-fail) in
        {1600}let v_544: bool = (not-caught-fail(v_543) && success?(1-proj-2-tuple(v_543))) in
        {1601}let n_42: nonce = (if v_544 then 2-proj-2-tuple(v_543) else caught-fail) in
        {1602}let k_45: key = (if v_544 then 1-proj-2-tuple(v_543) else caught-fail) in
        {1603}let d_10: aead = (if v_544 then catch-fail(decrypt(k_45,n_42,h_68,ciphertext_30)) else caught-fail) in
        {1604}let v_545: bool = not-caught-fail(d_10) in
        {1605}let v_546: bitstring = (if v_545 then catch-fail(aeadunpack(d_10)) else caught-fail) in
        {1606}let v_547: bool = (not-caught-fail(v_546) && success?(1-proj-3-tuple(v_546))) in
        {1607}let plaintext_29: bitstring = (if v_547 then 3-proj-3-tuple(v_546) else caught-fail) in
        {1608}let adi_10: bitstring = (if v_547 then 2-proj-3-tuple(v_546) else caught-fail) in
        {1609}let valid_25: bool = (if v_547 then 1-proj-3-tuple(v_546) else caught-fail) in
        {1610}let n_43: nonce = (if v_547 then increment_nonce(n_42) else caught-fail) in
        {1611}let v_548: bitstring = (if v_547 then catch-fail(cipherstateunpack(cs_68)) else caught-fail) in
        {1612}let v_549: bool = (not-caught-fail(v_548) && success?(1-proj-2-tuple(v_548))) in
        {1613}let o_21: nonce = (if v_549 then 2-proj-2-tuple(v_548) else caught-fail) in
        {1614}let k_46: key = (if v_549 then 1-proj-2-tuple(v_548) else caught-fail) in
        {1615}let csi_42: cipherstate = (if v_547 then catch-fail((if v_549 then cipherstatepack(k_46,n_43) else fail-any)) else caught-fail) in
        {1616}let v_550: bool = not-caught-fail(csi_42) in
        {1617}let v_551: bitstring = (if v_542 then catch-fail((if v_544 then (if v_545 then (if v_547 then (if v_550 then (csi_42,plaintext_29,valid_25) else fail-any) else fail-any) else fail-any) else fail-any)) else caught-fail) in
        {1618}let v_552: bool = (not-caught-fail(v_551) && success?(1-proj-3-tuple(v_551))) in
        {1619}let valid_26: bool = (if v_552 then 3-proj-3-tuple(v_551) else caught-fail) in
        {1620}let plaintext_30: bitstring = (if v_552 then 2-proj-3-tuple(v_551) else caught-fail) in
        {1621}let csi_43: cipherstate = (if v_552 then 1-proj-3-tuple(v_551) else caught-fail) in
        {1622}let ss_79: symmetricstate = (if v_552 then symmetricstatepack(csi_43,ck_80,h_68) else caught-fail) in
        {1623}let v_553: bitstring = (if v_552 then catch-fail(symmetricstateunpack(ss_79)) else caught-fail) in
        {1624}let v_554: bool = (not-caught-fail(v_553) && success?(1-proj-3-tuple(v_553))) in
        {1625}let h_69: bitstring = (if v_554 then 3-proj-3-tuple(v_553) else caught-fail) in
        {1626}let ck_81: key = (if v_554 then 2-proj-3-tuple(v_553) else caught-fail) in
        {1627}let cs_69: cipherstate = (if v_554 then 1-proj-3-tuple(v_553) else caught-fail) in
        {1628}let ssi_23: symmetricstate = (if v_552 then catch-fail((if v_554 then symmetricstatepack(cs_69,ck_81,hash(h_69,ciphertext_30)) else fail-any)) else caught-fail) in
        {1629}let v_555: bool = not-caught-fail(ssi_23) in
        {1630}let v_556: bitstring = (if v_540 then catch-fail((if v_542 then (if v_552 then (if v_555 then (ssi_23,plaintext_30,valid_26) else fail-any) else fail-any) else fail-any)) else caught-fail) in
        {1631}let v_557: bool = (not-caught-fail(v_556) && success?(1-proj-3-tuple(v_556))) in
        {1632}let valid3_2: bool = (if v_557 then 3-proj-3-tuple(v_556) else caught-fail) in
        {1633}let plaintext_31: bitstring = (if v_557 then 2-proj-3-tuple(v_556) else caught-fail) in
        {1634}let ss_80: symmetricstate = (if v_557 then 1-proj-3-tuple(v_556) else caught-fail) in
        {1635}let basis_11: key = (if v_557 then key_s(them_2) else caught-fail) in
        {1636}let public_key_11: key = (if v_557 then catch-fail(dhexp(basis_11,validkey(g))) else caught-fail) in
        {1637}let v_558: bool = not-caught-fail(public_key_11) in
        {1638}let basis_12: key = (if v_557 then key_m(them_2) else caught-fail) in
        {1639}let public_key_12: key = (if v_557 then catch-fail(dhexp(basis_12,validkey(g))) else caught-fail) in
        {1640}let v_559: bool = not-caught-fail(public_key_12) in
        {1641}let v_560: bool = (if v_557 then catch-fail(((valid1_7 && (valid2_5 && valid3_2)) && ((rs_17 = getpublickey((if v_558 then keypairpack(validkey(public_key_11),basis_11) else fail-any))) && (rm_18 = getpublickey((if v_559 then keypairpack(validkey(public_key_12),basis_12) else fail-any)))))) else caught-fail) in
        {1642}let hs_44: handshakestate = (if v_560 then handshakestatepack(ss_80,s_16,m_18,e_29,rs_17,rm_18,re_18,psk_15,initiator_13) else caught-fail) in
        {1643}let v_561: bitstring = (if v_560 then catch-fail(symmetricstateunpack(ss_80)) else caught-fail) in
        {1644}let v_562: bool = (not-caught-fail(v_561) && success?(1-proj-3-tuple(v_561))) in
        {1645}let h_70: bitstring = (if v_562 then 3-proj-3-tuple(v_561) else caught-fail) in
        {1646}let ck_82: key = (if v_562 then 2-proj-3-tuple(v_561) else caught-fail) in
        {1647}let cs_70: cipherstate = (if v_562 then 1-proj-3-tuple(v_561) else caught-fail) in
        {1648}let input_key_material_14: key = (if v_562 then zero else caught-fail) in
        {1649}let output1_14: key = (if v_562 then hmac_hash1(ck_82,input_key_material_14) else caught-fail) in
        {1650}let output2_14: key = (if v_562 then hmac_hash2(ck_82,input_key_material_14) else caught-fail) in
        {1651}let output3_14: key = (if v_562 then hmac_hash3(ck_82,input_key_material_14) else caught-fail) in
        {1652}let v_563: bitstring = (if v_562 then catch-fail((output1_14,output2_14,output3_14)) else caught-fail) in
        {1653}let v_564: bool = (not-caught-fail(v_563) && success?(1-proj-3-tuple(v_563))) in
        {1654}let temp_k3_2: key = (if v_564 then 3-proj-3-tuple(v_563) else caught-fail) in
        {1655}let temp_k2_2: key = (if v_564 then 2-proj-3-tuple(v_563) else caught-fail) in
        {1656}let temp_k1_2: key = (if v_564 then 1-proj-3-tuple(v_563) else caught-fail) in
        {1657}let cs1_10: cipherstate = (if v_564 then cipherstatepack(temp_k1_2,minnonce) else caught-fail) in
        {1658}let cs2_10: cipherstate = (if v_564 then cipherstatepack(temp_k2_2,minnonce) else caught-fail) in
        {1659}let v_565: bitstring = (if v_560 then catch-fail((if v_562 then (if v_564 then (ss_80,cs1_10,cs2_10) else fail-any) else fail-any)) else caught-fail) in
        {1660}let v_566: bool = (not-caught-fail(v_565) && success?(1-proj-3-tuple(v_565))) in
        {1661}let cs2_11: cipherstate = (if v_566 then 3-proj-3-tuple(v_565) else caught-fail) in
        {1662}let cs1_11: cipherstate = (if v_566 then 2-proj-3-tuple(v_565) else caught-fail) in
        {1663}let ssi_24: symmetricstate = (if v_566 then 1-proj-3-tuple(v_565) else caught-fail) in
        {1664}let (hs_45: handshakestate,plaintext_c: bitstring,valid_27: bool,cs1_12: cipherstate,cs2_12: cipherstate) = (if v_513 then (if v_515 then (if v_532 then (if v_540 then (if v_557 then (if undo-catch-fail(v_560) then (if v_566 then (hs_44,plaintext_31,true,cs1_11,cs2_11) else fail-any) else fail-any) else fail-any) else fail-any) else fail-any) else fail-any) else fail-any) in
        {1665}event RecvMsg(me_2,them_2,stagepack_c(sid_3),plaintext_c);
        {1666}insert statestore(me_2,them_2,sid_3,statepack_d(hs_45,cs1_12,cs2_12))
    ) | (
        {1668}!
        {1726}get statestore(=me_2,=them_2,=sid_3,statepack_d(hs_46: handshakestate,cs1_13: cipherstate,cs2_13: cipherstate)) in
        {1669}let hs_47: handshakestate = handshakestatesetcs(hs_46,cs2_13) in
        {1670}let payload_7: bitstring = msg_d(me_2,them_2,sid_3) in
        {1671}let v_567: bitstring = catch-fail(handshakestateunpack(hs_47)) in
        {1672}let v_568: bool = (not-caught-fail(v_567) && success?(1-proj-9-tuple(v_567))) in
        {1673}let initiator_14: bool = (if v_568 then 9-proj-9-tuple(v_567) else caught-fail) in
        {1674}let psk_16: key = (if v_568 then 8-proj-9-tuple(v_567) else caught-fail) in
        {1675}let re_19: key = (if v_568 then 7-proj-9-tuple(v_567) else caught-fail) in
        {1676}let rm_19: key = (if v_568 then 6-proj-9-tuple(v_567) else caught-fail) in
        {1677}let rs_18: key = (if v_568 then 5-proj-9-tuple(v_567) else caught-fail) in
        {1678}let e_30: keypair = (if v_568 then 4-proj-9-tuple(v_567) else caught-fail) in
        {1679}let m_19: keypair = (if v_568 then 3-proj-9-tuple(v_567) else caught-fail) in
        {1680}let s_17: keypair = (if v_568 then 2-proj-9-tuple(v_567) else caught-fail) in
        {1681}let ss_81: symmetricstate = (if v_568 then 1-proj-9-tuple(v_567) else caught-fail) in
        {1682}let v_569: bitstring = (if v_568 then catch-fail((empty,empty,empty)) else caught-fail) in
        {1683}let v_570: bool = (not-caught-fail(v_569) && success?(1-proj-3-tuple(v_569))) in
        {1684}let ciphertext_31: bitstring = (if v_570 then 3-proj-3-tuple(v_569) else caught-fail) in
        {1685}let ns_13: bitstring = (if v_570 then 2-proj-3-tuple(v_569) else caught-fail) in
        {1686}let ne_20: bitstring = (if v_570 then 1-proj-3-tuple(v_569) else caught-fail) in
        {1687}let v_571: bitstring = (if v_570 then catch-fail(symmetricstateunpack(ss_81)) else caught-fail) in
        {1688}let v_572: bool = (not-caught-fail(v_571) && success?(1-proj-3-tuple(v_571))) in
        {1689}let h_71: bitstring = (if v_572 then 3-proj-3-tuple(v_571) else caught-fail) in
        {1690}let ck_83: key = (if v_572 then 2-proj-3-tuple(v_571) else caught-fail) in
        {1691}let cs_71: cipherstate = (if v_572 then 1-proj-3-tuple(v_571) else caught-fail) in
        {1692}let v_573: bitstring = (if v_572 then catch-fail(cipherstateunpack(cs_71)) else caught-fail) in
        {1693}let v_574: bool = (not-caught-fail(v_573) && success?(1-proj-2-tuple(v_573))) in
        {1694}let n_44: nonce = (if v_574 then 2-proj-2-tuple(v_573) else caught-fail) in
        {1695}let k_47: key = (if v_574 then 1-proj-2-tuple(v_573) else caught-fail) in
        {1696}let e_31: bitstring = (if v_574 then encrypt(k_47,n_44,h_71,payload_7) else caught-fail) in
        {1697}let n_45: nonce = (if v_574 then increment_nonce(n_44) else caught-fail) in
        {1698}let v_575: bitstring = (if v_574 then catch-fail(cipherstateunpack(cs_71)) else caught-fail) in
        {1699}let v_576: bool = (not-caught-fail(v_575) && success?(1-proj-2-tuple(v_575))) in
        {1700}let o_22: nonce = (if v_576 then 2-proj-2-tuple(v_575) else caught-fail) in
        {1701}let k_48: key = (if v_576 then 1-proj-2-tuple(v_575) else caught-fail) in
        {1702}let csi_44: cipherstate = (if v_574 then catch-fail((if v_576 then cipherstatepack(k_48,n_45) else fail-any)) else caught-fail) in
        {1703}let v_577: bool = not-caught-fail(csi_44) in
        {1704}let v_578: bitstring = (if v_572 then catch-fail((if v_574 then (if v_577 then (csi_44,e_31) else fail-any) else fail-any)) else caught-fail) in
        {1705}let v_579: bool = (not-caught-fail(v_578) && success?(1-proj-2-tuple(v_578))) in
        {1706}let ciphertext_32: bitstring = (if v_579 then 2-proj-2-tuple(v_578) else caught-fail) in
        {1707}let csi_45: cipherstate = (if v_579 then 1-proj-2-tuple(v_578) else caught-fail) in
        {1708}let ss_82: symmetricstate = (if v_579 then symmetricstatepack(csi_45,ck_83,h_71) else caught-fail) in
        {1709}let v_580: bitstring = (if v_579 then catch-fail(symmetricstateunpack(ss_82)) else caught-fail) in
        {1710}let v_581: bool = (not-caught-fail(v_580) && success?(1-proj-3-tuple(v_580))) in
        {1711}let h_72: bitstring = (if v_581 then 3-proj-3-tuple(v_580) else caught-fail) in
        {1712}let ck_84: key = (if v_581 then 2-proj-3-tuple(v_580) else caught-fail) in
        {1713}let cs_72: cipherstate = (if v_581 then 1-proj-3-tuple(v_580) else caught-fail) in
        {1714}let ssi_25: symmetricstate = (if v_579 then catch-fail((if v_581 then symmetricstatepack(cs_72,ck_84,hash(h_72,ciphertext_32)) else fail-any)) else caught-fail) in
        {1715}let v_582: bool = not-caught-fail(ssi_25) in
        {1716}let v_583: bitstring = (if v_570 then catch-fail((if v_572 then (if v_579 then (if v_582 then (ssi_25,ciphertext_32) else fail-any) else fail-any) else fail-any)) else caught-fail) in
        {1717}let v_584: bool = (not-caught-fail(v_583) && success?(1-proj-2-tuple(v_583))) in
        {1718}let ciphertext_33: bitstring = (if v_584 then 2-proj-2-tuple(v_583) else caught-fail) in
        {1719}let ss_83: symmetricstate = (if v_584 then 1-proj-2-tuple(v_583) else caught-fail) in
        {1720}let hs_48: handshakestate = (if v_584 then handshakestatepack(ss_83,s_17,m_19,e_30,rs_18,rm_19,re_19,psk_16,initiator_14) else caught-fail) in
        {1721}let message_buffer_7: bitstring = (if v_584 then concat3(ne_20,ns_13,ciphertext_33) else caught-fail) in
        {1722}let (hs_49: handshakestate,message_d_2: bitstring) = (if v_568 then (if v_570 then (if v_584 then (hs_48,message_buffer_7) else fail-any) else fail-any) else fail-any) in
        {1723}event SendMsg(me_2,them_2,stagepack_d(sid_3),msg_d(me_2,them_2,sid_3));
        {1724}insert statestore(me_2,them_2,sid_3,statepack_e(hs_49,cs1_13,handshakestategetcs(hs_49)));
        {1725}out(pub, message_d_2)
    ) | (
        {1727}!
        {1793}get statestore(=me_2,=them_2,=sid_3,statepack_e(hs_50: handshakestate,cs1_14: cipherstate,cs2_14: cipherstate)) in
        {1728}let hs_51: handshakestate = handshakestatesetcs(hs_50,cs1_14) in
        {1729}in(pub, message_e_2: bitstring);
        {1730}let v_585: bitstring = catch-fail(handshakestateunpack(hs_51)) in
        {1731}let v_586: bool = (not-caught-fail(v_585) && success?(1-proj-9-tuple(v_585))) in
        {1732}let initiator_15: bool = (if v_586 then 9-proj-9-tuple(v_585) else caught-fail) in
        {1733}let psk_17: key = (if v_586 then 8-proj-9-tuple(v_585) else caught-fail) in
        {1734}let re_20: key = (if v_586 then 7-proj-9-tuple(v_585) else caught-fail) in
        {1735}let rm_20: key = (if v_586 then 6-proj-9-tuple(v_585) else caught-fail) in
        {1736}let rs_19: key = (if v_586 then 5-proj-9-tuple(v_585) else caught-fail) in
        {1737}let e_32: keypair = (if v_586 then 4-proj-9-tuple(v_585) else caught-fail) in
        {1738}let m_20: keypair = (if v_586 then 3-proj-9-tuple(v_585) else caught-fail) in
        {1739}let s_18: keypair = (if v_586 then 2-proj-9-tuple(v_585) else caught-fail) in
        {1740}let ss_84: symmetricstate = (if v_586 then 1-proj-9-tuple(v_585) else caught-fail) in
        {1741}let v_587: bitstring = (if v_586 then catch-fail(deconcat3(message_e_2)) else caught-fail) in
        {1742}let v_588: bool = (not-caught-fail(v_587) && success?(1-proj-3-tuple(v_587))) in
        {1743}let ciphertext_34: bitstring = (if v_588 then 3-proj-3-tuple(v_587) else caught-fail) in
        {1744}let ns_14: bitstring = (if v_588 then 2-proj-3-tuple(v_587) else caught-fail) in
        {1745}let ne_21: bitstring = (if v_588 then 1-proj-3-tuple(v_587) else caught-fail) in
        {1746}let valid1_8: bool = (if v_588 then true else caught-fail) in
        {1747}let v_589: bitstring = (if v_588 then catch-fail(symmetricstateunpack(ss_84)) else caught-fail) in
        {1748}let v_590: bool = (not-caught-fail(v_589) && success?(1-proj-3-tuple(v_589))) in
        {1749}let h_73: bitstring = (if v_590 then 3-proj-3-tuple(v_589) else caught-fail) in
        {1750}let ck_85: key = (if v_590 then 2-proj-3-tuple(v_589) else caught-fail) in
        {1751}let cs_73: cipherstate = (if v_590 then 1-proj-3-tuple(v_589) else caught-fail) in
        {1752}let v_591: bitstring = (if v_590 then catch-fail(cipherstateunpack(cs_73)) else caught-fail) in
        {1753}let v_592: bool = (not-caught-fail(v_591) && success?(1-proj-2-tuple(v_591))) in
        {1754}let n_46: nonce = (if v_592 then 2-proj-2-tuple(v_591) else caught-fail) in
        {1755}let k_49: key = (if v_592 then 1-proj-2-tuple(v_591) else caught-fail) in
        {1756}let d_11: aead = (if v_592 then catch-fail(decrypt(k_49,n_46,h_73,ciphertext_34)) else caught-fail) in
        {1757}let v_593: bool = not-caught-fail(d_11) in
        {1758}let v_594: bitstring = (if v_593 then catch-fail(aeadunpack(d_11)) else caught-fail) in
        {1759}let v_595: bool = (not-caught-fail(v_594) && success?(1-proj-3-tuple(v_594))) in
        {1760}let plaintext_32: bitstring = (if v_595 then 3-proj-3-tuple(v_594) else caught-fail) in
        {1761}let adi_11: bitstring = (if v_595 then 2-proj-3-tuple(v_594) else caught-fail) in
        {1762}let valid_28: bool = (if v_595 then 1-proj-3-tuple(v_594) else caught-fail) in
        {1763}let n_47: nonce = (if v_595 then increment_nonce(n_46) else caught-fail) in
        {1764}let v_596: bitstring = (if v_595 then catch-fail(cipherstateunpack(cs_73)) else caught-fail) in
        {1765}let v_597: bool = (not-caught-fail(v_596) && success?(1-proj-2-tuple(v_596))) in
        {1766}let o_23: nonce = (if v_597 then 2-proj-2-tuple(v_596) else caught-fail) in
        {1767}let k_50: key = (if v_597 then 1-proj-2-tuple(v_596) else caught-fail) in
        {1768}let csi_46: cipherstate = (if v_595 then catch-fail((if v_597 then cipherstatepack(k_50,n_47) else fail-any)) else caught-fail) in
        {1769}let v_598: bool = not-caught-fail(csi_46) in
        {1770}let v_599: bitstring = (if v_590 then catch-fail((if v_592 then (if v_593 then (if v_595 then (if v_598 then (csi_46,plaintext_32,valid_28) else fail-any) else fail-any) else fail-any) else fail-any)) else caught-fail) in
        {1771}let v_600: bool = (not-caught-fail(v_599) && success?(1-proj-3-tuple(v_599))) in
        {1772}let valid_29: bool = (if v_600 then 3-proj-3-tuple(v_599) else caught-fail) in
        {1773}let plaintext_33: bitstring = (if v_600 then 2-proj-3-tuple(v_599) else caught-fail) in
        {1774}let csi_47: cipherstate = (if v_600 then 1-proj-3-tuple(v_599) else caught-fail) in
        {1775}let ss_85: symmetricstate = (if v_600 then symmetricstatepack(csi_47,ck_85,h_73) else caught-fail) in
        {1776}let v_601: bitstring = (if v_600 then catch-fail(symmetricstateunpack(ss_85)) else caught-fail) in
        {1777}let v_602: bool = (not-caught-fail(v_601) && success?(1-proj-3-tuple(v_601))) in
        {1778}let h_74: bitstring = (if v_602 then 3-proj-3-tuple(v_601) else caught-fail) in
        {1779}let ck_86: key = (if v_602 then 2-proj-3-tuple(v_601) else caught-fail) in
        {1780}let cs_74: cipherstate = (if v_602 then 1-proj-3-tuple(v_601) else caught-fail) in
        {1781}let ssi_26: symmetricstate = (if v_600 then catch-fail((if v_602 then symmetricstatepack(cs_74,ck_86,hash(h_74,ciphertext_34)) else fail-any)) else caught-fail) in
        {1782}let v_603: bool = not-caught-fail(ssi_26) in
        {1783}let v_604: bitstring = (if v_588 then catch-fail((if v_590 then (if v_600 then (if v_603 then (ssi_26,plaintext_33,valid_29) else fail-any) else fail-any) else fail-any)) else caught-fail) in
        {1784}let v_605: bool = (not-caught-fail(v_604) && success?(1-proj-3-tuple(v_604))) in
        {1785}let valid2_6: bool = (if v_605 then 3-proj-3-tuple(v_604) else caught-fail) in
        {1786}let plaintext_34: bitstring = (if v_605 then 2-proj-3-tuple(v_604) else caught-fail) in
        {1787}let ss_86: symmetricstate = (if v_605 then 1-proj-3-tuple(v_604) else caught-fail) in
        {1788}let v_606: bool = (if v_605 then catch-fail((valid1_8 && valid2_6)) else caught-fail) in
        {1789}let hs_52: handshakestate = (if v_606 then handshakestatepack(ss_86,s_18,m_20,e_32,rs_19,rm_20,re_20,psk_17,initiator_15) else caught-fail) in
        {1790}let (hs_53: handshakestate,plaintext_e: bitstring,valid_30: bool) = (if v_586 then (if v_588 then (if v_605 then (if undo-catch-fail(v_606) then (hs_52,plaintext_34,true) else fail-any) else fail-any) else fail-any) else fail-any) in
        {1791}event RecvMsg(me_2,them_2,stagepack_e(sid_3),plaintext_e);
        {1792}event RecvEnd(valid_30)
    ) | (
        {1794}event LeakS(phase0,me_2);
        {1795}event LeakM(phase0,me_2);
        {1796}out(pub, (key_s(me_2),key_m(me_2)))
    ) | (
        {1797}phase 1;
        {1798}event LeakS(phase1,me_2);
        {1799}event LeakM(phase1,me_2);
        {1800}out(pub, (key_s(me_2),key_m(me_2)))
    )
) | (
    {1801}let me_3: principal = bob in
    {1802}let them_3: principal = charlie in
    {1803}let sid_4: sessionid = sid in
    {1804}let s_19: keypair = keypairpack(empty,empty) in
    {1805}let m_21: keypair = keypairpack(empty,empty) in
    {1806}out(pub, (getpublickey(s_19),getpublickey(m_21)));
    (
        {1807}let e_33: keypair = keypairpack(empty,empty) in
        {1808}let rs_20: key = empty in
        {1809}let rm_21: key = empty in
        {1810}let re_21: key = empty in
        {1811}let prologue_3: bitstring = empty in
        {1812}let psk_18: key = empty in
        {1813}let protocol_name_3: bitstring = somename in
        {1814}let h_75: bitstring = hash(protocol_name_3,empty) in
        {1815}let ck_87: key = h_75 in
        {1816}let k_51: key = empty in
        {1817}let cs_75: cipherstate = cipherstatepack(k_51,minnonce) in
        {1818}let ss_87: symmetricstate = symmetricstatepack(cs_75,ck_87,h_75) in
        {1819}let v_607: bitstring = catch-fail(symmetricstateunpack(ss_87)) in
        {1820}let v_608: bool = (not-caught-fail(v_607) && success?(1-proj-3-tuple(v_607))) in
        {1821}let h_76: bitstring = (if v_608 then 3-proj-3-tuple(v_607) else caught-fail) in
        {1822}let ck_88: key = (if v_608 then 2-proj-3-tuple(v_607) else caught-fail) in
        {1823}let cs_76: cipherstate = (if v_608 then 1-proj-3-tuple(v_607) else caught-fail) in
        {1824}let ss_88: symmetricstate = catch-fail((if v_608 then symmetricstatepack(cs_76,ck_88,hash(h_76,prologue_3)) else fail-any)) in
        {1825}let v_609: bool = not-caught-fail(ss_88) in
        {1826}let hs_54: handshakestate = (if v_609 then handshakestatepack(ss_88,s_19,m_21,e_33,rs_20,rm_21,re_21,psk_18,false) else fail-any) in
        {1827}insert statestore(me_3,them_3,sid_4,statepack_a(hs_54))
    ) | (
        {1900}get statestore(=me_3,=them_3,=sid_4,statepack_a(hs_55: handshakestate)) in
        {1828}in(pub, message_a_3: bitstring);
        {1829}let v_610: bitstring = catch-fail(handshakestateunpack(hs_55)) in
        {1830}let v_611: bool = (not-caught-fail(v_610) && success?(1-proj-9-tuple(v_610))) in
        {1831}let initiator_16: bool = (if v_611 then 9-proj-9-tuple(v_610) else caught-fail) in
        {1832}let psk_19: key = (if v_611 then 8-proj-9-tuple(v_610) else caught-fail) in
        {1833}let re_22: key = (if v_611 then 7-proj-9-tuple(v_610) else caught-fail) in
        {1834}let rm_22: key = (if v_611 then 6-proj-9-tuple(v_610) else caught-fail) in
        {1835}let rs_21: key = (if v_611 then 5-proj-9-tuple(v_610) else caught-fail) in
        {1836}let e_34: keypair = (if v_611 then 4-proj-9-tuple(v_610) else caught-fail) in
        {1837}let m_22: keypair = (if v_611 then 3-proj-9-tuple(v_610) else caught-fail) in
        {1838}let s_20: keypair = (if v_611 then 2-proj-9-tuple(v_610) else caught-fail) in
        {1839}let ss_89: symmetricstate = (if v_611 then 1-proj-9-tuple(v_610) else caught-fail) in
        {1840}let v_612: bitstring = (if v_611 then catch-fail(deconcat3(message_a_3)) else caught-fail) in
        {1841}let v_613: bool = (not-caught-fail(v_612) && success?(1-proj-3-tuple(v_612))) in
        {1842}let ciphertext_35: bitstring = (if v_613 then 3-proj-3-tuple(v_612) else caught-fail) in
        {1843}let ns_15: bitstring = (if v_613 then 2-proj-3-tuple(v_612) else caught-fail) in
        {1844}let ne_22: bitstring = (if v_613 then 1-proj-3-tuple(v_612) else caught-fail) in
        {1845}let valid1_9: bool = (if v_613 then true else caught-fail) in
        {1846}let re_23: key = (if v_613 then ne_22 else caught-fail) in
        {1847}let v_614: bitstring = (if v_613 then catch-fail(symmetricstateunpack(ss_89)) else caught-fail) in
        {1848}let v_615: bool = (not-caught-fail(v_614) && success?(1-proj-3-tuple(v_614))) in
        {1849}let h_77: bitstring = (if v_615 then 3-proj-3-tuple(v_614) else caught-fail) in
        {1850}let ck_89: key = (if v_615 then 2-proj-3-tuple(v_614) else caught-fail) in
        {1851}let cs_77: cipherstate = (if v_615 then 1-proj-3-tuple(v_614) else caught-fail) in
        {1852}let ss_90: symmetricstate = (if v_613 then catch-fail((if v_615 then symmetricstatepack(cs_77,ck_89,hash(h_77,re_23)) else fail-any)) else caught-fail) in
        {1853}let v_616: bool = not-caught-fail(ss_90) in
        {1854}let v_617: bitstring = (if v_616 then catch-fail(symmetricstateunpack(ss_90)) else caught-fail) in
        {1855}let v_618: bool = (not-caught-fail(v_617) && success?(1-proj-3-tuple(v_617))) in
        {1856}let h_78: bitstring = (if v_618 then 3-proj-3-tuple(v_617) else caught-fail) in
        {1857}let ck_90: key = (if v_618 then 2-proj-3-tuple(v_617) else caught-fail) in
        {1858}let cs_78: cipherstate = (if v_618 then 1-proj-3-tuple(v_617) else caught-fail) in
        {1859}let v_619: bitstring = (if v_618 then catch-fail(cipherstateunpack(cs_78)) else caught-fail) in
        {1860}let v_620: bool = (not-caught-fail(v_619) && success?(1-proj-2-tuple(v_619))) in
        {1861}let n_48: nonce = (if v_620 then 2-proj-2-tuple(v_619) else caught-fail) in
        {1862}let k_52: key = (if v_620 then 1-proj-2-tuple(v_619) else caught-fail) in
        {1863}let d_12: aead = (if v_620 then catch-fail(decrypt(k_52,n_48,h_78,ciphertext_35)) else caught-fail) in
        {1864}let v_621: bool = not-caught-fail(d_12) in
        {1865}let v_622: bitstring = (if v_621 then catch-fail(aeadunpack(d_12)) else caught-fail) in
        {1866}let v_623: bool = (not-caught-fail(v_622) && success?(1-proj-3-tuple(v_622))) in
        {1867}let plaintext_35: bitstring = (if v_623 then 3-proj-3-tuple(v_622) else caught-fail) in
        {1868}let adi_12: bitstring = (if v_623 then 2-proj-3-tuple(v_622) else caught-fail) in
        {1869}let valid_31: bool = (if v_623 then 1-proj-3-tuple(v_622) else caught-fail) in
        {1870}let n_49: nonce = (if v_623 then increment_nonce(n_48) else caught-fail) in
        {1871}let v_624: bitstring = (if v_623 then catch-fail(cipherstateunpack(cs_78)) else caught-fail) in
        {1872}let v_625: bool = (not-caught-fail(v_624) && success?(1-proj-2-tuple(v_624))) in
        {1873}let o_24: nonce = (if v_625 then 2-proj-2-tuple(v_624) else caught-fail) in
        {1874}let k_53: key = (if v_625 then 1-proj-2-tuple(v_624) else caught-fail) in
        {1875}let csi_48: cipherstate = (if v_623 then catch-fail((if v_625 then cipherstatepack(k_53,n_49) else fail-any)) else caught-fail) in
        {1876}let v_626: bool = not-caught-fail(csi_48) in
        {1877}let v_627: bitstring = (if v_618 then catch-fail((if v_620 then (if v_621 then (if v_623 then (if v_626 then (csi_48,plaintext_35,valid_31) else fail-any) else fail-any) else fail-any) else fail-any)) else caught-fail) in
        {1878}let v_628: bool = (not-caught-fail(v_627) && success?(1-proj-3-tuple(v_627))) in
        {1879}let valid_32: bool = (if v_628 then 3-proj-3-tuple(v_627) else caught-fail) in
        {1880}let plaintext_36: bitstring = (if v_628 then 2-proj-3-tuple(v_627) else caught-fail) in
        {1881}let csi_49: cipherstate = (if v_628 then 1-proj-3-tuple(v_627) else caught-fail) in
        {1882}let ss_91: symmetricstate = (if v_628 then symmetricstatepack(csi_49,ck_90,h_78) else caught-fail) in
        {1883}let v_629: bitstring = (if v_628 then catch-fail(symmetricstateunpack(ss_91)) else caught-fail) in
        {1884}let v_630: bool = (not-caught-fail(v_629) && success?(1-proj-3-tuple(v_629))) in
        {1885}let h_79: bitstring = (if v_630 then 3-proj-3-tuple(v_629) else caught-fail) in
        {1886}let ck_91: key = (if v_630 then 2-proj-3-tuple(v_629) else caught-fail) in
        {1887}let cs_79: cipherstate = (if v_630 then 1-proj-3-tuple(v_629) else caught-fail) in
        {1888}let ssi_27: symmetricstate = (if v_628 then catch-fail((if v_630 then symmetricstatepack(cs_79,ck_91,hash(h_79,ciphertext_35)) else fail-any)) else caught-fail) in
        {1889}let v_631: bool = not-caught-fail(ssi_27) in
        {1890}let v_632: bitstring = (if v_616 then catch-fail((if v_618 then (if v_628 then (if v_631 then (ssi_27,plaintext_36,valid_32) else fail-any) else fail-any) else fail-any)) else caught-fail) in
        {1891}let v_633: bool = (not-caught-fail(v_632) && success?(1-proj-3-tuple(v_632))) in
        {1892}let valid2_7: bool = (if v_633 then 3-proj-3-tuple(v_632) else caught-fail) in
        {1893}let plaintext_37: bitstring = (if v_633 then 2-proj-3-tuple(v_632) else caught-fail) in
        {1894}let ss_92: symmetricstate = (if v_633 then 1-proj-3-tuple(v_632) else caught-fail) in
        {1895}let v_634: bool = (if v_633 then catch-fail((valid1_9 && valid2_7)) else caught-fail) in
        {1896}let hs_56: handshakestate = (if v_634 then handshakestatepack(ss_92,s_20,m_22,e_34,rs_21,rm_22,re_23,psk_19,initiator_16) else caught-fail) in
        {1897}let (hs_57: handshakestate,plaintext_a_1: bitstring,valid_33: bool) = (if v_611 then (if v_613 then (if v_616 then (if v_633 then (if undo-catch-fail(v_634) then (hs_56,plaintext_37,true) else fail-any) else fail-any) else fail-any) else fail-any) else fail-any) in
        {1898}event RecvMsg(me_3,them_3,stagepack_a(sid_4),plaintext_a_1);
        {1899}insert statestore(me_3,them_3,sid_4,statepack_b(hs_57))
    ) | (
        {2115}get statestore(=me_3,=them_3,=sid_4,statepack_b(hs_58: handshakestate)) in
        {1901}let payload_8: bitstring = msg_b(me_3,them_3,sid_4) in
        {1902}let v_635: bitstring = catch-fail(handshakestateunpack(hs_58)) in
        {1903}let v_636: bool = (not-caught-fail(v_635) && success?(1-proj-9-tuple(v_635))) in
        {1904}let initiator_17: bool = (if v_636 then 9-proj-9-tuple(v_635) else caught-fail) in
        {1905}let psk_20: key = (if v_636 then 8-proj-9-tuple(v_635) else caught-fail) in
        {1906}let re_24: key = (if v_636 then 7-proj-9-tuple(v_635) else caught-fail) in
        {1907}let rm_23: key = (if v_636 then 6-proj-9-tuple(v_635) else caught-fail) in
        {1908}let rs_22: key = (if v_636 then 5-proj-9-tuple(v_635) else caught-fail) in
        {1909}let e_35: keypair = (if v_636 then 4-proj-9-tuple(v_635) else caught-fail) in
        {1910}let m_23: keypair = (if v_636 then 3-proj-9-tuple(v_635) else caught-fail) in
        {1911}let s_21: keypair = (if v_636 then 2-proj-9-tuple(v_635) else caught-fail) in
        {1912}let ss_93: symmetricstate = (if v_636 then 1-proj-9-tuple(v_635) else caught-fail) in
        {1913}let v_637: bitstring = (if v_636 then catch-fail((empty,empty,empty,empty)) else caught-fail) in
        {1914}let v_638: bool = (not-caught-fail(v_637) && success?(1-proj-4-tuple(v_637))) in
        {1915}let ciphertext_36: bitstring = (if v_638 then 4-proj-4-tuple(v_637) else caught-fail) in
        {1916}let nm_9: bitstring = (if v_638 then 3-proj-4-tuple(v_637) else caught-fail) in
        {1917}let ns_16: bitstring = (if v_638 then 2-proj-4-tuple(v_637) else caught-fail) in
        {1918}let ne_23: bitstring = (if v_638 then 1-proj-4-tuple(v_637) else caught-fail) in
        {1919}let basis_13: key = (if v_638 then key_e(me_3,them_3,sid_4) else caught-fail) in
        {1920}let public_key_13: key = (if v_638 then catch-fail(dhexp(basis_13,validkey(g))) else caught-fail) in
        {1921}let v_639: bool = not-caught-fail(public_key_13) in
        {1922}let e_36: keypair = (if v_638 then catch-fail((if v_639 then keypairpack(validkey(public_key_13),basis_13) else fail-any)) else caught-fail) in
        {1923}let v_640: bool = not-caught-fail(e_36) in
        {1924}let ne_24: bitstring = (if v_640 then catch-fail(getpublickey(e_36)) else caught-fail) in
        {1925}let v_641: bool = not-caught-fail(ne_24) in
        {1926}let v_642: bitstring = (if v_641 then catch-fail(symmetricstateunpack(ss_93)) else caught-fail) in
        {1927}let v_643: bool = (not-caught-fail(v_642) && success?(1-proj-3-tuple(v_642))) in
        {1928}let h_80: bitstring = (if v_643 then 3-proj-3-tuple(v_642) else caught-fail) in
        {1929}let ck_92: key = (if v_643 then 2-proj-3-tuple(v_642) else caught-fail) in
        {1930}let cs_80: cipherstate = (if v_643 then 1-proj-3-tuple(v_642) else caught-fail) in
        {1931}let ss_94: symmetricstate = (if v_641 then catch-fail((if v_643 then symmetricstatepack(cs_80,ck_92,hash(h_80,ne_24)) else fail-any)) else caught-fail) in
        {1932}let v_644: bool = not-caught-fail(ss_94) in
        {1933}let v_645: bitstring = (if v_644 then catch-fail(keypairunpack(e_36)) else caught-fail) in
        {1934}let v_646: bool = (not-caught-fail(v_645) && success?(1-proj-2-tuple(v_645))) in
        {1935}let my_private_key_12: key = (if v_646 then 2-proj-2-tuple(v_645) else caught-fail) in
        {1936}let my_public_key_12: key = (if v_646 then 1-proj-2-tuple(v_645) else caught-fail) in
        {1937}let input_key_material_15: key = (if v_644 then catch-fail((if v_646 then dhexp(my_private_key_12,re_24) else fail-any)) else caught-fail) in
        {1938}let v_647: bool = not-caught-fail(input_key_material_15) in
        {1939}let v_648: bitstring = (if v_647 then catch-fail(symmetricstateunpack(ss_94)) else caught-fail) in
        {1940}let v_649: bool = (not-caught-fail(v_648) && success?(1-proj-3-tuple(v_648))) in
        {1941}let h_81: bitstring = (if v_649 then 3-proj-3-tuple(v_648) else caught-fail) in
        {1942}let ck_93: key = (if v_649 then 2-proj-3-tuple(v_648) else caught-fail) in
        {1943}let cs_81: cipherstate = (if v_649 then 1-proj-3-tuple(v_648) else caught-fail) in
        {1944}let output1_15: key = (if v_649 then hmac_hash1(ck_93,input_key_material_15) else caught-fail) in
        {1945}let output2_15: key = (if v_649 then hmac_hash2(ck_93,input_key_material_15) else caught-fail) in
        {1946}let output3_15: key = (if v_649 then hmac_hash3(ck_93,input_key_material_15) else caught-fail) in
        {1947}let v_650: bitstring = (if v_649 then catch-fail((output1_15,output2_15,output3_15)) else caught-fail) in
        {1948}let v_651: bool = (not-caught-fail(v_650) && success?(1-proj-3-tuple(v_650))) in
        {1949}let output_12: key = (if v_651 then 3-proj-3-tuple(v_650) else caught-fail) in
        {1950}let temp_k_12: key = (if v_651 then 2-proj-3-tuple(v_650) else caught-fail) in
        {1951}let ck_94: key = (if v_651 then 1-proj-3-tuple(v_650) else caught-fail) in
        {1952}let ss_95: symmetricstate = (if v_644 then catch-fail((if v_647 then (if v_649 then (if v_651 then symmetricstatepack(cipherstatepack(temp_k_12,minnonce),ck_94,h_81) else fail-any) else fail-any) else fail-any)) else caught-fail) in
        {1953}let v_652: bool = not-caught-fail(ss_95) in
        {1954}let basis_14: key = (if v_652 then key_s(me_3) else caught-fail) in
        {1955}let public_key_14: key = (if v_652 then catch-fail(dhexp(basis_14,validkey(g))) else caught-fail) in
        {1956}let v_653: bool = not-caught-fail(public_key_14) in
        {1957}let s_22: keypair = (if v_652 then catch-fail((if v_653 then keypairpack(validkey(public_key_14),basis_14) else fail-any)) else caught-fail) in
        {1958}let v_654: bool = not-caught-fail(s_22) in
        {1959}let plaintext_38: bitstring = (if v_654 then catch-fail(getpublickey(s_22)) else caught-fail) in
        {1960}let v_655: bool = not-caught-fail(plaintext_38) in
        {1961}let v_656: bitstring = (if v_655 then catch-fail(symmetricstateunpack(ss_95)) else caught-fail) in
        {1962}let v_657: bool = (not-caught-fail(v_656) && success?(1-proj-3-tuple(v_656))) in
        {1963}let h_82: bitstring = (if v_657 then 3-proj-3-tuple(v_656) else caught-fail) in
        {1964}let ck_95: key = (if v_657 then 2-proj-3-tuple(v_656) else caught-fail) in
        {1965}let cs_82: cipherstate = (if v_657 then 1-proj-3-tuple(v_656) else caught-fail) in
        {1966}let v_658: bitstring = (if v_657 then catch-fail(cipherstateunpack(cs_82)) else caught-fail) in
        {1967}let v_659: bool = (not-caught-fail(v_658) && success?(1-proj-2-tuple(v_658))) in
        {1968}let n_50: nonce = (if v_659 then 2-proj-2-tuple(v_658) else caught-fail) in
        {1969}let k_54: key = (if v_659 then 1-proj-2-tuple(v_658) else caught-fail) in
        {1970}let e_37: bitstring = (if v_659 then encrypt(k_54,n_50,h_82,plaintext_38) else caught-fail) in
        {1971}let n_51: nonce = (if v_659 then increment_nonce(n_50) else caught-fail) in
        {1972}let v_660: bitstring = (if v_659 then catch-fail(cipherstateunpack(cs_82)) else caught-fail) in
        {1973}let v_661: bool = (not-caught-fail(v_660) && success?(1-proj-2-tuple(v_660))) in
        {1974}let o_25: nonce = (if v_661 then 2-proj-2-tuple(v_660) else caught-fail) in
        {1975}let k_55: key = (if v_661 then 1-proj-2-tuple(v_660) else caught-fail) in
        {1976}let csi_50: cipherstate = (if v_659 then catch-fail((if v_661 then cipherstatepack(k_55,n_51) else fail-any)) else caught-fail) in
        {1977}let v_662: bool = not-caught-fail(csi_50) in
        {1978}let v_663: bitstring = (if v_657 then catch-fail((if v_659 then (if v_662 then (csi_50,e_37) else fail-any) else fail-any)) else caught-fail) in
        {1979}let v_664: bool = (not-caught-fail(v_663) && success?(1-proj-2-tuple(v_663))) in
        {1980}let ciphertext_37: bitstring = (if v_664 then 2-proj-2-tuple(v_663) else caught-fail) in
        {1981}let csi_51: cipherstate = (if v_664 then 1-proj-2-tuple(v_663) else caught-fail) in
        {1982}let ss_96: symmetricstate = (if v_664 then symmetricstatepack(csi_51,ck_95,h_82) else caught-fail) in
        {1983}let v_665: bitstring = (if v_664 then catch-fail(symmetricstateunpack(ss_96)) else caught-fail) in
        {1984}let v_666: bool = (not-caught-fail(v_665) && success?(1-proj-3-tuple(v_665))) in
        {1985}let h_83: bitstring = (if v_666 then 3-proj-3-tuple(v_665) else caught-fail) in
        {1986}let ck_96: key = (if v_666 then 2-proj-3-tuple(v_665) else caught-fail) in
        {1987}let cs_83: cipherstate = (if v_666 then 1-proj-3-tuple(v_665) else caught-fail) in
        {1988}let ssi_28: symmetricstate = (if v_664 then catch-fail((if v_666 then symmetricstatepack(cs_83,ck_96,hash(h_83,ciphertext_37)) else fail-any)) else caught-fail) in
        {1989}let v_667: bool = not-caught-fail(ssi_28) in
        {1990}let v_668: bitstring = (if v_654 then catch-fail((if v_655 then (if v_657 then (if v_664 then (if v_667 then (ssi_28,ciphertext_37) else fail-any) else fail-any) else fail-any) else fail-any)) else caught-fail) in
        {1991}let v_669: bool = (not-caught-fail(v_668) && success?(1-proj-2-tuple(v_668))) in
        {1992}let ns_17: bitstring = (if v_669 then 2-proj-2-tuple(v_668) else caught-fail) in
        {1993}let ss_97: symmetricstate = (if v_669 then 1-proj-2-tuple(v_668) else caught-fail) in
        {1994}let basis_15: key = (if v_669 then key_m(me_3) else caught-fail) in
        {1995}let public_key_15: key = (if v_669 then catch-fail(dhexp(basis_15,validkey(g))) else caught-fail) in
        {1996}let v_670: bool = not-caught-fail(public_key_15) in
        {1997}let m_24: keypair = (if v_669 then catch-fail((if v_670 then keypairpack(validkey(public_key_15),basis_15) else fail-any)) else caught-fail) in
        {1998}let v_671: bool = not-caught-fail(m_24) in
        {1999}let plaintext_39: bitstring = (if v_671 then catch-fail(getpublickey(m_24)) else caught-fail) in
        {2000}let v_672: bool = not-caught-fail(plaintext_39) in
        {2001}let v_673: bitstring = (if v_672 then catch-fail(symmetricstateunpack(ss_97)) else caught-fail) in
        {2002}let v_674: bool = (not-caught-fail(v_673) && success?(1-proj-3-tuple(v_673))) in
        {2003}let h_84: bitstring = (if v_674 then 3-proj-3-tuple(v_673) else caught-fail) in
        {2004}let ck_97: key = (if v_674 then 2-proj-3-tuple(v_673) else caught-fail) in
        {2005}let cs_84: cipherstate = (if v_674 then 1-proj-3-tuple(v_673) else caught-fail) in
        {2006}let v_675: bitstring = (if v_674 then catch-fail(cipherstateunpack(cs_84)) else caught-fail) in
        {2007}let v_676: bool = (not-caught-fail(v_675) && success?(1-proj-2-tuple(v_675))) in
        {2008}let n_52: nonce = (if v_676 then 2-proj-2-tuple(v_675) else caught-fail) in
        {2009}let k_56: key = (if v_676 then 1-proj-2-tuple(v_675) else caught-fail) in
        {2010}let e_38: bitstring = (if v_676 then encrypt(k_56,n_52,h_84,plaintext_39) else caught-fail) in
        {2011}let n_53: nonce = (if v_676 then increment_nonce(n_52) else caught-fail) in
        {2012}let v_677: bitstring = (if v_676 then catch-fail(cipherstateunpack(cs_84)) else caught-fail) in
        {2013}let v_678: bool = (not-caught-fail(v_677) && success?(1-proj-2-tuple(v_677))) in
        {2014}let o_26: nonce = (if v_678 then 2-proj-2-tuple(v_677) else caught-fail) in
        {2015}let k_57: key = (if v_678 then 1-proj-2-tuple(v_677) else caught-fail) in
        {2016}let csi_52: cipherstate = (if v_676 then catch-fail((if v_678 then cipherstatepack(k_57,n_53) else fail-any)) else caught-fail) in
        {2017}let v_679: bool = not-caught-fail(csi_52) in
        {2018}let v_680: bitstring = (if v_674 then catch-fail((if v_676 then (if v_679 then (csi_52,e_38) else fail-any) else fail-any)) else caught-fail) in
        {2019}let v_681: bool = (not-caught-fail(v_680) && success?(1-proj-2-tuple(v_680))) in
        {2020}let ciphertext_38: bitstring = (if v_681 then 2-proj-2-tuple(v_680) else caught-fail) in
        {2021}let csi_53: cipherstate = (if v_681 then 1-proj-2-tuple(v_680) else caught-fail) in
        {2022}let ss_98: symmetricstate = (if v_681 then symmetricstatepack(csi_53,ck_97,h_84) else caught-fail) in
        {2023}let v_682: bitstring = (if v_681 then catch-fail(symmetricstateunpack(ss_98)) else caught-fail) in
        {2024}let v_683: bool = (not-caught-fail(v_682) && success?(1-proj-3-tuple(v_682))) in
        {2025}let h_85: bitstring = (if v_683 then 3-proj-3-tuple(v_682) else caught-fail) in
        {2026}let ck_98: key = (if v_683 then 2-proj-3-tuple(v_682) else caught-fail) in
        {2027}let cs_85: cipherstate = (if v_683 then 1-proj-3-tuple(v_682) else caught-fail) in
        {2028}let ssi_29: symmetricstate = (if v_681 then catch-fail((if v_683 then symmetricstatepack(cs_85,ck_98,hash(h_85,ciphertext_38)) else fail-any)) else caught-fail) in
        {2029}let v_684: bool = not-caught-fail(ssi_29) in
        {2030}let v_685: bitstring = (if v_671 then catch-fail((if v_672 then (if v_674 then (if v_681 then (if v_684 then (ssi_29,ciphertext_38) else fail-any) else fail-any) else fail-any) else fail-any)) else caught-fail) in
        {2031}let v_686: bool = (not-caught-fail(v_685) && success?(1-proj-2-tuple(v_685))) in
        {2032}let nm_10: bitstring = (if v_686 then 2-proj-2-tuple(v_685) else caught-fail) in
        {2033}let ss_99: symmetricstate = (if v_686 then 1-proj-2-tuple(v_685) else caught-fail) in
        {2034}let v_687: bitstring = (if v_686 then catch-fail(keypairunpack(s_22)) else caught-fail) in
        {2035}let v_688: bool = (not-caught-fail(v_687) && success?(1-proj-2-tuple(v_687))) in
        {2036}let my_private_key_13: key = (if v_688 then 2-proj-2-tuple(v_687) else caught-fail) in
        {2037}let my_public_key_13: key = (if v_688 then 1-proj-2-tuple(v_687) else caught-fail) in
        {2038}let input_key_material_16: key = (if v_686 then catch-fail((if v_688 then dhexp(my_private_key_13,re_24) else fail-any)) else caught-fail) in
        {2039}let v_689: bool = not-caught-fail(input_key_material_16) in
        {2040}let v_690: bitstring = (if v_689 then catch-fail(symmetricstateunpack(ss_99)) else caught-fail) in
        {2041}let v_691: bool = (not-caught-fail(v_690) && success?(1-proj-3-tuple(v_690))) in
        {2042}let h_86: bitstring = (if v_691 then 3-proj-3-tuple(v_690) else caught-fail) in
        {2043}let ck_99: key = (if v_691 then 2-proj-3-tuple(v_690) else caught-fail) in
        {2044}let cs_86: cipherstate = (if v_691 then 1-proj-3-tuple(v_690) else caught-fail) in
        {2045}let output1_16: key = (if v_691 then hmac_hash1(ck_99,input_key_material_16) else caught-fail) in
        {2046}let output2_16: key = (if v_691 then hmac_hash2(ck_99,input_key_material_16) else caught-fail) in
        {2047}let output3_16: key = (if v_691 then hmac_hash3(ck_99,input_key_material_16) else caught-fail) in
        {2048}let v_692: bitstring = (if v_691 then catch-fail((output1_16,output2_16,output3_16)) else caught-fail) in
        {2049}let v_693: bool = (not-caught-fail(v_692) && success?(1-proj-3-tuple(v_692))) in
        {2050}let output_13: key = (if v_693 then 3-proj-3-tuple(v_692) else caught-fail) in
        {2051}let temp_k_13: key = (if v_693 then 2-proj-3-tuple(v_692) else caught-fail) in
        {2052}let ck_100: key = (if v_693 then 1-proj-3-tuple(v_692) else caught-fail) in
        {2053}let ss_100: symmetricstate = (if v_686 then catch-fail((if v_689 then (if v_691 then (if v_693 then symmetricstatepack(cipherstatepack(temp_k_13,minnonce),ck_100,h_86) else fail-any) else fail-any) else fail-any)) else caught-fail) in
        {2054}let v_694: bool = not-caught-fail(ss_100) in
        {2055}let v_695: bitstring = (if v_694 then catch-fail(keypairunpack(m_24)) else caught-fail) in
        {2056}let v_696: bool = (not-caught-fail(v_695) && success?(1-proj-2-tuple(v_695))) in
        {2057}let my_private_key_14: key = (if v_696 then 2-proj-2-tuple(v_695) else caught-fail) in
        {2058}let my_public_key_14: key = (if v_696 then 1-proj-2-tuple(v_695) else caught-fail) in
        {2059}let input_key_material_17: key = (if v_694 then catch-fail((if v_696 then dhexp(my_private_key_14,re_24) else fail-any)) else caught-fail) in
        {2060}let v_697: bool = not-caught-fail(input_key_material_17) in
        {2061}let v_698: bitstring = (if v_697 then catch-fail(symmetricstateunpack(ss_100)) else caught-fail) in
        {2062}let v_699: bool = (not-caught-fail(v_698) && success?(1-proj-3-tuple(v_698))) in
        {2063}let h_87: bitstring = (if v_699 then 3-proj-3-tuple(v_698) else caught-fail) in
        {2064}let ck_101: key = (if v_699 then 2-proj-3-tuple(v_698) else caught-fail) in
        {2065}let cs_87: cipherstate = (if v_699 then 1-proj-3-tuple(v_698) else caught-fail) in
        {2066}let output1_17: key = (if v_699 then hmac_hash1(ck_101,input_key_material_17) else caught-fail) in
        {2067}let output2_17: key = (if v_699 then hmac_hash2(ck_101,input_key_material_17) else caught-fail) in
        {2068}let output3_17: key = (if v_699 then hmac_hash3(ck_101,input_key_material_17) else caught-fail) in
        {2069}let v_700: bitstring = (if v_699 then catch-fail((output1_17,output2_17,output3_17)) else caught-fail) in
        {2070}let v_701: bool = (not-caught-fail(v_700) && success?(1-proj-3-tuple(v_700))) in
        {2071}let output_14: key = (if v_701 then 3-proj-3-tuple(v_700) else caught-fail) in
        {2072}let temp_k_14: key = (if v_701 then 2-proj-3-tuple(v_700) else caught-fail) in
        {2073}let ck_102: key = (if v_701 then 1-proj-3-tuple(v_700) else caught-fail) in
        {2074}let ss_101: symmetricstate = (if v_694 then catch-fail((if v_697 then (if v_699 then (if v_701 then symmetricstatepack(cipherstatepack(temp_k_14,minnonce),ck_102,h_87) else fail-any) else fail-any) else fail-any)) else caught-fail) in
        {2075}let v_702: bool = not-caught-fail(ss_101) in
        {2076}let v_703: bitstring = (if v_702 then catch-fail(symmetricstateunpack(ss_101)) else caught-fail) in
        {2077}let v_704: bool = (not-caught-fail(v_703) && success?(1-proj-3-tuple(v_703))) in
        {2078}let h_88: bitstring = (if v_704 then 3-proj-3-tuple(v_703) else caught-fail) in
        {2079}let ck_103: key = (if v_704 then 2-proj-3-tuple(v_703) else caught-fail) in
        {2080}let cs_88: cipherstate = (if v_704 then 1-proj-3-tuple(v_703) else caught-fail) in
        {2081}let v_705: bitstring = (if v_704 then catch-fail(cipherstateunpack(cs_88)) else caught-fail) in
        {2082}let v_706: bool = (not-caught-fail(v_705) && success?(1-proj-2-tuple(v_705))) in
        {2083}let n_54: nonce = (if v_706 then 2-proj-2-tuple(v_705) else caught-fail) in
        {2084}let k_58: key = (if v_706 then 1-proj-2-tuple(v_705) else caught-fail) in
        {2085}let e_39: bitstring = (if v_706 then encrypt(k_58,n_54,h_88,payload_8) else caught-fail) in
        {2086}let n_55: nonce = (if v_706 then increment_nonce(n_54) else caught-fail) in
        {2087}let v_707: bitstring = (if v_706 then catch-fail(cipherstateunpack(cs_88)) else caught-fail) in
        {2088}let v_708: bool = (not-caught-fail(v_707) && success?(1-proj-2-tuple(v_707))) in
        {2089}let o_27: nonce = (if v_708 then 2-proj-2-tuple(v_707) else caught-fail) in
        {2090}let k_59: key = (if v_708 then 1-proj-2-tuple(v_707) else caught-fail) in
        {2091}let csi_54: cipherstate = (if v_706 then catch-fail((if v_708 then cipherstatepack(k_59,n_55) else fail-any)) else caught-fail) in
        {2092}let v_709: bool = not-caught-fail(csi_54) in
        {2093}let v_710: bitstring = (if v_704 then catch-fail((if v_706 then (if v_709 then (csi_54,e_39) else fail-any) else fail-any)) else caught-fail) in
        {2094}let v_711: bool = (not-caught-fail(v_710) && success?(1-proj-2-tuple(v_710))) in
        {2095}let ciphertext_39: bitstring = (if v_711 then 2-proj-2-tuple(v_710) else caught-fail) in
        {2096}let csi_55: cipherstate = (if v_711 then 1-proj-2-tuple(v_710) else caught-fail) in
        {2097}let ss_102: symmetricstate = (if v_711 then symmetricstatepack(csi_55,ck_103,h_88) else caught-fail) in
        {2098}let v_712: bitstring = (if v_711 then catch-fail(symmetricstateunpack(ss_102)) else caught-fail) in
        {2099}let v_713: bool = (not-caught-fail(v_712) && success?(1-proj-3-tuple(v_712))) in
        {2100}let h_89: bitstring = (if v_713 then 3-proj-3-tuple(v_712) else caught-fail) in
        {2101}let ck_104: key = (if v_713 then 2-proj-3-tuple(v_712) else caught-fail) in
        {2102}let cs_89: cipherstate = (if v_713 then 1-proj-3-tuple(v_712) else caught-fail) in
        {2103}let ssi_30: symmetricstate = (if v_711 then catch-fail((if v_713 then symmetricstatepack(cs_89,ck_104,hash(h_89,ciphertext_39)) else fail-any)) else caught-fail) in
        {2104}let v_714: bool = not-caught-fail(ssi_30) in
        {2105}let v_715: bitstring = (if v_702 then catch-fail((if v_704 then (if v_711 then (if v_714 then (ssi_30,ciphertext_39) else fail-any) else fail-any) else fail-any)) else caught-fail) in
        {2106}let v_716: bool = (not-caught-fail(v_715) && success?(1-proj-2-tuple(v_715))) in
        {2107}let ciphertext_40: bitstring = (if v_716 then 2-proj-2-tuple(v_715) else caught-fail) in
        {2108}let ss_103: symmetricstate = (if v_716 then 1-proj-2-tuple(v_715) else caught-fail) in
        {2109}let hs_59: handshakestate = (if v_716 then handshakestatepack(ss_103,s_22,m_24,e_36,rs_22,rm_23,re_24,psk_20,initiator_17) else caught-fail) in
        {2110}let message_buffer_8: bitstring = (if v_716 then concat4(ne_24,ns_17,nm_10,ciphertext_40) else caught-fail) in
        {2111}let (hs_60: handshakestate,message_b_3: bitstring) = (if v_636 then (if v_638 then (if v_640 then (if v_641 then (if v_644 then (if v_652 then (if v_654 then (if v_669 then (if v_671 then (if v_686 then (if v_694 then (if v_702 then (if v_716 then (hs_59,message_buffer_8) else fail-any) else fail-any) else fail-any) else fail-any) else fail-any) else fail-any) else fail-any) else fail-any) else fail-any) else fail-any) else fail-any) else fail-any) else fail-any) in
        {2112}event SendMsg(me_3,them_3,stagepack_b(sid_4),msg_b(me_3,them_3,sid_4));
        {2113}insert statestore(me_3,them_3,sid_4,statepack_c(hs_60));
        {2114}out(pub, message_b_3)
    ) | (
        {2270}get statestore(=me_3,=them_3,=sid_4,statepack_c(hs_61: handshakestate)) in
        {2116}in(pub, message_c_3: bitstring);
        {2117}let v_717: bitstring = catch-fail(handshakestateunpack(hs_61)) in
        {2118}let v_718: bool = (not-caught-fail(v_717) && success?(1-proj-9-tuple(v_717))) in
        {2119}let initiator_18: bool = (if v_718 then 9-proj-9-tuple(v_717) else caught-fail) in
        {2120}let psk_21: key = (if v_718 then 8-proj-9-tuple(v_717) else caught-fail) in
        {2121}let re_25: key = (if v_718 then 7-proj-9-tuple(v_717) else caught-fail) in
        {2122}let rm_24: key = (if v_718 then 6-proj-9-tuple(v_717) else caught-fail) in
        {2123}let rs_23: key = (if v_718 then 5-proj-9-tuple(v_717) else caught-fail) in
        {2124}let e_40: keypair = (if v_718 then 4-proj-9-tuple(v_717) else caught-fail) in
        {2125}let m_25: keypair = (if v_718 then 3-proj-9-tuple(v_717) else caught-fail) in
        {2126}let s_23: keypair = (if v_718 then 2-proj-9-tuple(v_717) else caught-fail) in
        {2127}let ss_104: symmetricstate = (if v_718 then 1-proj-9-tuple(v_717) else caught-fail) in
        {2128}let v_719: bitstring = (if v_718 then catch-fail(deconcat3(message_c_3)) else caught-fail) in
        {2129}let v_720: bool = (not-caught-fail(v_719) && success?(1-proj-3-tuple(v_719))) in
        {2130}let ciphertext_41: bitstring = (if v_720 then 3-proj-3-tuple(v_719) else caught-fail) in
        {2131}let nm_11: bitstring = (if v_720 then 2-proj-3-tuple(v_719) else caught-fail) in
        {2132}let ne_25: bitstring = (if v_720 then 1-proj-3-tuple(v_719) else caught-fail) in
        {2133}let valid1_10: bool = (if v_720 then true else caught-fail) in
        {2134}let v_721: bitstring = (if v_720 then catch-fail(symmetricstateunpack(ss_104)) else caught-fail) in
        {2135}let v_722: bool = (not-caught-fail(v_721) && success?(1-proj-3-tuple(v_721))) in
        {2136}let h_90: bitstring = (if v_722 then 3-proj-3-tuple(v_721) else caught-fail) in
        {2137}let ck_105: key = (if v_722 then 2-proj-3-tuple(v_721) else caught-fail) in
        {2138}let cs_90: cipherstate = (if v_722 then 1-proj-3-tuple(v_721) else caught-fail) in
        {2139}let v_723: bitstring = (if v_722 then catch-fail(cipherstateunpack(cs_90)) else caught-fail) in
        {2140}let v_724: bool = (not-caught-fail(v_723) && success?(1-proj-2-tuple(v_723))) in
        {2141}let n_56: nonce = (if v_724 then 2-proj-2-tuple(v_723) else caught-fail) in
        {2142}let k_60: key = (if v_724 then 1-proj-2-tuple(v_723) else caught-fail) in
        {2143}let d_13: aead = (if v_724 then catch-fail(decrypt(k_60,n_56,h_90,nm_11)) else caught-fail) in
        {2144}let v_725: bool = not-caught-fail(d_13) in
        {2145}let v_726: bitstring = (if v_725 then catch-fail(aeadunpack(d_13)) else caught-fail) in
        {2146}let v_727: bool = (not-caught-fail(v_726) && success?(1-proj-3-tuple(v_726))) in
        {2147}let plaintext_40: bitstring = (if v_727 then 3-proj-3-tuple(v_726) else caught-fail) in
        {2148}let adi_13: bitstring = (if v_727 then 2-proj-3-tuple(v_726) else caught-fail) in
        {2149}let valid_34: bool = (if v_727 then 1-proj-3-tuple(v_726) else caught-fail) in
        {2150}let n_57: nonce = (if v_727 then increment_nonce(n_56) else caught-fail) in
        {2151}let v_728: bitstring = (if v_727 then catch-fail(cipherstateunpack(cs_90)) else caught-fail) in
        {2152}let v_729: bool = (not-caught-fail(v_728) && success?(1-proj-2-tuple(v_728))) in
        {2153}let o_28: nonce = (if v_729 then 2-proj-2-tuple(v_728) else caught-fail) in
        {2154}let k_61: key = (if v_729 then 1-proj-2-tuple(v_728) else caught-fail) in
        {2155}let csi_56: cipherstate = (if v_727 then catch-fail((if v_729 then cipherstatepack(k_61,n_57) else fail-any)) else caught-fail) in
        {2156}let v_730: bool = not-caught-fail(csi_56) in
        {2157}let v_731: bitstring = (if v_722 then catch-fail((if v_724 then (if v_725 then (if v_727 then (if v_730 then (csi_56,plaintext_40,valid_34) else fail-any) else fail-any) else fail-any) else fail-any)) else caught-fail) in
        {2158}let v_732: bool = (not-caught-fail(v_731) && success?(1-proj-3-tuple(v_731))) in
        {2159}let valid_35: bool = (if v_732 then 3-proj-3-tuple(v_731) else caught-fail) in
        {2160}let plaintext_41: bitstring = (if v_732 then 2-proj-3-tuple(v_731) else caught-fail) in
        {2161}let csi_57: cipherstate = (if v_732 then 1-proj-3-tuple(v_731) else caught-fail) in
        {2162}let ss_105: symmetricstate = (if v_732 then symmetricstatepack(csi_57,ck_105,h_90) else caught-fail) in
        {2163}let v_733: bitstring = (if v_732 then catch-fail(symmetricstateunpack(ss_105)) else caught-fail) in
        {2164}let v_734: bool = (not-caught-fail(v_733) && success?(1-proj-3-tuple(v_733))) in
        {2165}let h_91: bitstring = (if v_734 then 3-proj-3-tuple(v_733) else caught-fail) in
        {2166}let ck_106: key = (if v_734 then 2-proj-3-tuple(v_733) else caught-fail) in
        {2167}let cs_91: cipherstate = (if v_734 then 1-proj-3-tuple(v_733) else caught-fail) in
        {2168}let ssi_31: symmetricstate = (if v_732 then catch-fail((if v_734 then symmetricstatepack(cs_91,ck_106,hash(h_91,nm_11)) else fail-any)) else caught-fail) in
        {2169}let v_735: bool = not-caught-fail(ssi_31) in
        {2170}let v_736: bitstring = (if v_720 then catch-fail((if v_722 then (if v_732 then (if v_735 then (ssi_31,plaintext_41,valid_35) else fail-any) else fail-any) else fail-any)) else caught-fail) in
        {2171}let v_737: bool = (not-caught-fail(v_736) && success?(1-proj-3-tuple(v_736))) in
        {2172}let valid2_8: bool = (if v_737 then 3-proj-3-tuple(v_736) else caught-fail) in
        {2173}let nem_1: bitstring = (if v_737 then 2-proj-3-tuple(v_736) else caught-fail) in
        {2174}let ss_106: symmetricstate = (if v_737 then 1-proj-3-tuple(v_736) else caught-fail) in
        {2175}let rm_25: key = (if v_737 then nem_1 else caught-fail) in
        {2176}let v_738: bitstring = (if v_737 then catch-fail(keypairunpack(e_40)) else caught-fail) in
        {2177}let v_739: bool = (not-caught-fail(v_738) && success?(1-proj-2-tuple(v_738))) in
        {2178}let my_private_key_15: key = (if v_739 then 2-proj-2-tuple(v_738) else caught-fail) in
        {2179}let my_public_key_15: key = (if v_739 then 1-proj-2-tuple(v_738) else caught-fail) in
        {2180}let input_key_material_18: key = (if v_737 then catch-fail((if v_739 then dhexp(my_private_key_15,rm_25) else fail-any)) else caught-fail) in
        {2181}let v_740: bool = not-caught-fail(input_key_material_18) in
        {2182}let v_741: bitstring = (if v_740 then catch-fail(symmetricstateunpack(ss_106)) else caught-fail) in
        {2183}let v_742: bool = (not-caught-fail(v_741) && success?(1-proj-3-tuple(v_741))) in
        {2184}let h_92: bitstring = (if v_742 then 3-proj-3-tuple(v_741) else caught-fail) in
        {2185}let ck_107: key = (if v_742 then 2-proj-3-tuple(v_741) else caught-fail) in
        {2186}let cs_92: cipherstate = (if v_742 then 1-proj-3-tuple(v_741) else caught-fail) in
        {2187}let output1_18: key = (if v_742 then hmac_hash1(ck_107,input_key_material_18) else caught-fail) in
        {2188}let output2_18: key = (if v_742 then hmac_hash2(ck_107,input_key_material_18) else caught-fail) in
        {2189}let output3_18: key = (if v_742 then hmac_hash3(ck_107,input_key_material_18) else caught-fail) in
        {2190}let v_743: bitstring = (if v_742 then catch-fail((output1_18,output2_18,output3_18)) else caught-fail) in
        {2191}let v_744: bool = (not-caught-fail(v_743) && success?(1-proj-3-tuple(v_743))) in
        {2192}let output_15: key = (if v_744 then 3-proj-3-tuple(v_743) else caught-fail) in
        {2193}let temp_k_15: key = (if v_744 then 2-proj-3-tuple(v_743) else caught-fail) in
        {2194}let ck_108: key = (if v_744 then 1-proj-3-tuple(v_743) else caught-fail) in
        {2195}let ss_107: symmetricstate = (if v_737 then catch-fail((if v_740 then (if v_742 then (if v_744 then symmetricstatepack(cipherstatepack(temp_k_15,minnonce),ck_108,h_92) else fail-any) else fail-any) else fail-any)) else caught-fail) in
        {2196}let v_745: bool = not-caught-fail(ss_107) in
        {2197}let v_746: bitstring = (if v_745 then catch-fail(symmetricstateunpack(ss_107)) else caught-fail) in
        {2198}let v_747: bool = (not-caught-fail(v_746) && success?(1-proj-3-tuple(v_746))) in
        {2199}let h_93: bitstring = (if v_747 then 3-proj-3-tuple(v_746) else caught-fail) in
        {2200}let ck_109: key = (if v_747 then 2-proj-3-tuple(v_746) else caught-fail) in
        {2201}let cs_93: cipherstate = (if v_747 then 1-proj-3-tuple(v_746) else caught-fail) in
        {2202}let v_748: bitstring = (if v_747 then catch-fail(cipherstateunpack(cs_93)) else caught-fail) in
        {2203}let v_749: bool = (not-caught-fail(v_748) && success?(1-proj-2-tuple(v_748))) in
        {2204}let n_58: nonce = (if v_749 then 2-proj-2-tuple(v_748) else caught-fail) in
        {2205}let k_62: key = (if v_749 then 1-proj-2-tuple(v_748) else caught-fail) in
        {2206}let d_14: aead = (if v_749 then catch-fail(decrypt(k_62,n_58,h_93,ciphertext_41)) else caught-fail) in
        {2207}let v_750: bool = not-caught-fail(d_14) in
        {2208}let v_751: bitstring = (if v_750 then catch-fail(aeadunpack(d_14)) else caught-fail) in
        {2209}let v_752: bool = (not-caught-fail(v_751) && success?(1-proj-3-tuple(v_751))) in
        {2210}let plaintext_42: bitstring = (if v_752 then 3-proj-3-tuple(v_751) else caught-fail) in
        {2211}let adi_14: bitstring = (if v_752 then 2-proj-3-tuple(v_751) else caught-fail) in
        {2212}let valid_36: bool = (if v_752 then 1-proj-3-tuple(v_751) else caught-fail) in
        {2213}let n_59: nonce = (if v_752 then increment_nonce(n_58) else caught-fail) in
        {2214}let v_753: bitstring = (if v_752 then catch-fail(cipherstateunpack(cs_93)) else caught-fail) in
        {2215}let v_754: bool = (not-caught-fail(v_753) && success?(1-proj-2-tuple(v_753))) in
        {2216}let o_29: nonce = (if v_754 then 2-proj-2-tuple(v_753) else caught-fail) in
        {2217}let k_63: key = (if v_754 then 1-proj-2-tuple(v_753) else caught-fail) in
        {2218}let csi_58: cipherstate = (if v_752 then catch-fail((if v_754 then cipherstatepack(k_63,n_59) else fail-any)) else caught-fail) in
        {2219}let v_755: bool = not-caught-fail(csi_58) in
        {2220}let v_756: bitstring = (if v_747 then catch-fail((if v_749 then (if v_750 then (if v_752 then (if v_755 then (csi_58,plaintext_42,valid_36) else fail-any) else fail-any) else fail-any) else fail-any)) else caught-fail) in
        {2221}let v_757: bool = (not-caught-fail(v_756) && success?(1-proj-3-tuple(v_756))) in
        {2222}let valid_37: bool = (if v_757 then 3-proj-3-tuple(v_756) else caught-fail) in
        {2223}let plaintext_43: bitstring = (if v_757 then 2-proj-3-tuple(v_756) else caught-fail) in
        {2224}let csi_59: cipherstate = (if v_757 then 1-proj-3-tuple(v_756) else caught-fail) in
        {2225}let ss_108: symmetricstate = (if v_757 then symmetricstatepack(csi_59,ck_109,h_93) else caught-fail) in
        {2226}let v_758: bitstring = (if v_757 then catch-fail(symmetricstateunpack(ss_108)) else caught-fail) in
        {2227}let v_759: bool = (not-caught-fail(v_758) && success?(1-proj-3-tuple(v_758))) in
        {2228}let h_94: bitstring = (if v_759 then 3-proj-3-tuple(v_758) else caught-fail) in
        {2229}let ck_110: key = (if v_759 then 2-proj-3-tuple(v_758) else caught-fail) in
        {2230}let cs_94: cipherstate = (if v_759 then 1-proj-3-tuple(v_758) else caught-fail) in
        {2231}let ssi_32: symmetricstate = (if v_757 then catch-fail((if v_759 then symmetricstatepack(cs_94,ck_110,hash(h_94,ciphertext_41)) else fail-any)) else caught-fail) in
        {2232}let v_760: bool = not-caught-fail(ssi_32) in
        {2233}let v_761: bitstring = (if v_745 then catch-fail((if v_747 then (if v_757 then (if v_760 then (ssi_32,plaintext_43,valid_37) else fail-any) else fail-any) else fail-any)) else caught-fail) in
        {2234}let v_762: bool = (not-caught-fail(v_761) && success?(1-proj-3-tuple(v_761))) in
        {2235}let valid3_3: bool = (if v_762 then 3-proj-3-tuple(v_761) else caught-fail) in
        {2236}let plaintext_44: bitstring = (if v_762 then 2-proj-3-tuple(v_761) else caught-fail) in
        {2237}let ss_109: symmetricstate = (if v_762 then 1-proj-3-tuple(v_761) else caught-fail) in
        {2238}let basis_16: key = (if v_762 then key_s(them_3) else caught-fail) in
        {2239}let public_key_16: key = (if v_762 then catch-fail(dhexp(basis_16,validkey(g))) else caught-fail) in
        {2240}let v_763: bool = not-caught-fail(public_key_16) in
        {2241}let basis_17: key = (if v_762 then key_m(them_3) else caught-fail) in
        {2242}let public_key_17: key = (if v_762 then catch-fail(dhexp(basis_17,validkey(g))) else caught-fail) in
        {2243}let v_764: bool = not-caught-fail(public_key_17) in
        {2244}let v_765: bool = (if v_762 then catch-fail(((valid1_10 && (valid2_8 && valid3_3)) && ((rs_23 = getpublickey((if v_763 then keypairpack(validkey(public_key_16),basis_16) else fail-any))) && (rm_25 = getpublickey((if v_764 then keypairpack(validkey(public_key_17),basis_17) else fail-any)))))) else caught-fail) in
        {2245}let hs_62: handshakestate = (if v_765 then handshakestatepack(ss_109,s_23,m_25,e_40,rs_23,rm_25,re_25,psk_21,initiator_18) else caught-fail) in
        {2246}let v_766: bitstring = (if v_765 then catch-fail(symmetricstateunpack(ss_109)) else caught-fail) in
        {2247}let v_767: bool = (not-caught-fail(v_766) && success?(1-proj-3-tuple(v_766))) in
        {2248}let h_95: bitstring = (if v_767 then 3-proj-3-tuple(v_766) else caught-fail) in
        {2249}let ck_111: key = (if v_767 then 2-proj-3-tuple(v_766) else caught-fail) in
        {2250}let cs_95: cipherstate = (if v_767 then 1-proj-3-tuple(v_766) else caught-fail) in
        {2251}let input_key_material_19: key = (if v_767 then zero else caught-fail) in
        {2252}let output1_19: key = (if v_767 then hmac_hash1(ck_111,input_key_material_19) else caught-fail) in
        {2253}let output2_19: key = (if v_767 then hmac_hash2(ck_111,input_key_material_19) else caught-fail) in
        {2254}let output3_19: key = (if v_767 then hmac_hash3(ck_111,input_key_material_19) else caught-fail) in
        {2255}let v_768: bitstring = (if v_767 then catch-fail((output1_19,output2_19,output3_19)) else caught-fail) in
        {2256}let v_769: bool = (not-caught-fail(v_768) && success?(1-proj-3-tuple(v_768))) in
        {2257}let temp_k3_3: key = (if v_769 then 3-proj-3-tuple(v_768) else caught-fail) in
        {2258}let temp_k2_3: key = (if v_769 then 2-proj-3-tuple(v_768) else caught-fail) in
        {2259}let temp_k1_3: key = (if v_769 then 1-proj-3-tuple(v_768) else caught-fail) in
        {2260}let cs1_15: cipherstate = (if v_769 then cipherstatepack(temp_k1_3,minnonce) else caught-fail) in
        {2261}let cs2_15: cipherstate = (if v_769 then cipherstatepack(temp_k2_3,minnonce) else caught-fail) in
        {2262}let v_770: bitstring = (if v_765 then catch-fail((if v_767 then (if v_769 then (ss_109,cs1_15,cs2_15) else fail-any) else fail-any)) else caught-fail) in
        {2263}let v_771: bool = (not-caught-fail(v_770) && success?(1-proj-3-tuple(v_770))) in
        {2264}let cs2_16: cipherstate = (if v_771 then 3-proj-3-tuple(v_770) else caught-fail) in
        {2265}let cs1_16: cipherstate = (if v_771 then 2-proj-3-tuple(v_770) else caught-fail) in
        {2266}let ssi_33: symmetricstate = (if v_771 then 1-proj-3-tuple(v_770) else caught-fail) in
        {2267}let (hs_63: handshakestate,plaintext_c_1: bitstring,valid_38: bool,cs1_17: cipherstate,cs2_17: cipherstate) = (if v_718 then (if v_720 then (if v_737 then (if v_745 then (if v_762 then (if undo-catch-fail(v_765) then (if v_771 then (hs_62,plaintext_44,true,cs1_16,cs2_16) else fail-any) else fail-any) else fail-any) else fail-any) else fail-any) else fail-any) else fail-any) in
        {2268}event RecvMsg(me_3,them_3,stagepack_c(sid_4),plaintext_c_1);
        {2269}insert statestore(me_3,them_3,sid_4,statepack_d(hs_63,cs1_17,cs2_17))
    ) | (
        {2271}!
        {2329}get statestore(=me_3,=them_3,=sid_4,statepack_d(hs_64: handshakestate,cs1_18: cipherstate,cs2_18: cipherstate)) in
        {2272}let hs_65: handshakestate = handshakestatesetcs(hs_64,cs2_18) in
        {2273}let payload_9: bitstring = msg_d(me_3,them_3,sid_4) in
        {2274}let v_772: bitstring = catch-fail(handshakestateunpack(hs_65)) in
        {2275}let v_773: bool = (not-caught-fail(v_772) && success?(1-proj-9-tuple(v_772))) in
        {2276}let initiator_19: bool = (if v_773 then 9-proj-9-tuple(v_772) else caught-fail) in
        {2277}let psk_22: key = (if v_773 then 8-proj-9-tuple(v_772) else caught-fail) in
        {2278}let re_26: key = (if v_773 then 7-proj-9-tuple(v_772) else caught-fail) in
        {2279}let rm_26: key = (if v_773 then 6-proj-9-tuple(v_772) else caught-fail) in
        {2280}let rs_24: key = (if v_773 then 5-proj-9-tuple(v_772) else caught-fail) in
        {2281}let e_41: keypair = (if v_773 then 4-proj-9-tuple(v_772) else caught-fail) in
        {2282}let m_26: keypair = (if v_773 then 3-proj-9-tuple(v_772) else caught-fail) in
        {2283}let s_24: keypair = (if v_773 then 2-proj-9-tuple(v_772) else caught-fail) in
        {2284}let ss_110: symmetricstate = (if v_773 then 1-proj-9-tuple(v_772) else caught-fail) in
        {2285}let v_774: bitstring = (if v_773 then catch-fail((empty,empty,empty)) else caught-fail) in
        {2286}let v_775: bool = (not-caught-fail(v_774) && success?(1-proj-3-tuple(v_774))) in
        {2287}let ciphertext_42: bitstring = (if v_775 then 3-proj-3-tuple(v_774) else caught-fail) in
        {2288}let ns_18: bitstring = (if v_775 then 2-proj-3-tuple(v_774) else caught-fail) in
        {2289}let ne_26: bitstring = (if v_775 then 1-proj-3-tuple(v_774) else caught-fail) in
        {2290}let v_776: bitstring = (if v_775 then catch-fail(symmetricstateunpack(ss_110)) else caught-fail) in
        {2291}let v_777: bool = (not-caught-fail(v_776) && success?(1-proj-3-tuple(v_776))) in
        {2292}let h_96: bitstring = (if v_777 then 3-proj-3-tuple(v_776) else caught-fail) in
        {2293}let ck_112: key = (if v_777 then 2-proj-3-tuple(v_776) else caught-fail) in
        {2294}let cs_96: cipherstate = (if v_777 then 1-proj-3-tuple(v_776) else caught-fail) in
        {2295}let v_778: bitstring = (if v_777 then catch-fail(cipherstateunpack(cs_96)) else caught-fail) in
        {2296}let v_779: bool = (not-caught-fail(v_778) && success?(1-proj-2-tuple(v_778))) in
        {2297}let n_60: nonce = (if v_779 then 2-proj-2-tuple(v_778) else caught-fail) in
        {2298}let k_64: key = (if v_779 then 1-proj-2-tuple(v_778) else caught-fail) in
        {2299}let e_42: bitstring = (if v_779 then encrypt(k_64,n_60,h_96,payload_9) else caught-fail) in
        {2300}let n_61: nonce = (if v_779 then increment_nonce(n_60) else caught-fail) in
        {2301}let v_780: bitstring = (if v_779 then catch-fail(cipherstateunpack(cs_96)) else caught-fail) in
        {2302}let v_781: bool = (not-caught-fail(v_780) && success?(1-proj-2-tuple(v_780))) in
        {2303}let o_30: nonce = (if v_781 then 2-proj-2-tuple(v_780) else caught-fail) in
        {2304}let k_65: key = (if v_781 then 1-proj-2-tuple(v_780) else caught-fail) in
        {2305}let csi_60: cipherstate = (if v_779 then catch-fail((if v_781 then cipherstatepack(k_65,n_61) else fail-any)) else caught-fail) in
        {2306}let v_782: bool = not-caught-fail(csi_60) in
        {2307}let v_783: bitstring = (if v_777 then catch-fail((if v_779 then (if v_782 then (csi_60,e_42) else fail-any) else fail-any)) else caught-fail) in
        {2308}let v_784: bool = (not-caught-fail(v_783) && success?(1-proj-2-tuple(v_783))) in
        {2309}let ciphertext_43: bitstring = (if v_784 then 2-proj-2-tuple(v_783) else caught-fail) in
        {2310}let csi_61: cipherstate = (if v_784 then 1-proj-2-tuple(v_783) else caught-fail) in
        {2311}let ss_111: symmetricstate = (if v_784 then symmetricstatepack(csi_61,ck_112,h_96) else caught-fail) in
        {2312}let v_785: bitstring = (if v_784 then catch-fail(symmetricstateunpack(ss_111)) else caught-fail) in
        {2313}let v_786: bool = (not-caught-fail(v_785) && success?(1-proj-3-tuple(v_785))) in
        {2314}let h_97: bitstring = (if v_786 then 3-proj-3-tuple(v_785) else caught-fail) in
        {2315}let ck_113: key = (if v_786 then 2-proj-3-tuple(v_785) else caught-fail) in
        {2316}let cs_97: cipherstate = (if v_786 then 1-proj-3-tuple(v_785) else caught-fail) in
        {2317}let ssi_34: symmetricstate = (if v_784 then catch-fail((if v_786 then symmetricstatepack(cs_97,ck_113,hash(h_97,ciphertext_43)) else fail-any)) else caught-fail) in
        {2318}let v_787: bool = not-caught-fail(ssi_34) in
        {2319}let v_788: bitstring = (if v_775 then catch-fail((if v_777 then (if v_784 then (if v_787 then (ssi_34,ciphertext_43) else fail-any) else fail-any) else fail-any)) else caught-fail) in
        {2320}let v_789: bool = (not-caught-fail(v_788) && success?(1-proj-2-tuple(v_788))) in
        {2321}let ciphertext_44: bitstring = (if v_789 then 2-proj-2-tuple(v_788) else caught-fail) in
        {2322}let ss_112: symmetricstate = (if v_789 then 1-proj-2-tuple(v_788) else caught-fail) in
        {2323}let hs_66: handshakestate = (if v_789 then handshakestatepack(ss_112,s_24,m_26,e_41,rs_24,rm_26,re_26,psk_22,initiator_19) else caught-fail) in
        {2324}let message_buffer_9: bitstring = (if v_789 then concat3(ne_26,ns_18,ciphertext_44) else caught-fail) in
        {2325}let (hs_67: handshakestate,message_d_3: bitstring) = (if v_773 then (if v_775 then (if v_789 then (hs_66,message_buffer_9) else fail-any) else fail-any) else fail-any) in
        {2326}event SendMsg(me_3,them_3,stagepack_d(sid_4),msg_d(me_3,them_3,sid_4));
        {2327}insert statestore(me_3,them_3,sid_4,statepack_e(hs_67,cs1_18,handshakestategetcs(hs_67)));
        {2328}out(pub, message_d_3)
    ) | (
        {2330}!
        {2396}get statestore(=me_3,=them_3,=sid_4,statepack_e(hs_68: handshakestate,cs1_19: cipherstate,cs2_19: cipherstate)) in
        {2331}let hs_69: handshakestate = handshakestatesetcs(hs_68,cs1_19) in
        {2332}in(pub, message_e_3: bitstring);
        {2333}let v_790: bitstring = catch-fail(handshakestateunpack(hs_69)) in
        {2334}let v_791: bool = (not-caught-fail(v_790) && success?(1-proj-9-tuple(v_790))) in
        {2335}let initiator_20: bool = (if v_791 then 9-proj-9-tuple(v_790) else caught-fail) in
        {2336}let psk_23: key = (if v_791 then 8-proj-9-tuple(v_790) else caught-fail) in
        {2337}let re_27: key = (if v_791 then 7-proj-9-tuple(v_790) else caught-fail) in
        {2338}let rm_27: key = (if v_791 then 6-proj-9-tuple(v_790) else caught-fail) in
        {2339}let rs_25: key = (if v_791 then 5-proj-9-tuple(v_790) else caught-fail) in
        {2340}let e_43: keypair = (if v_791 then 4-proj-9-tuple(v_790) else caught-fail) in
        {2341}let m_27: keypair = (if v_791 then 3-proj-9-tuple(v_790) else caught-fail) in
        {2342}let s_25: keypair = (if v_791 then 2-proj-9-tuple(v_790) else caught-fail) in
        {2343}let ss_113: symmetricstate = (if v_791 then 1-proj-9-tuple(v_790) else caught-fail) in
        {2344}let v_792: bitstring = (if v_791 then catch-fail(deconcat3(message_e_3)) else caught-fail) in
        {2345}let v_793: bool = (not-caught-fail(v_792) && success?(1-proj-3-tuple(v_792))) in
        {2346}let ciphertext_45: bitstring = (if v_793 then 3-proj-3-tuple(v_792) else caught-fail) in
        {2347}let ns_19: bitstring = (if v_793 then 2-proj-3-tuple(v_792) else caught-fail) in
        {2348}let ne_27: bitstring = (if v_793 then 1-proj-3-tuple(v_792) else caught-fail) in
        {2349}let valid1_11: bool = (if v_793 then true else caught-fail) in
        {2350}let v_794: bitstring = (if v_793 then catch-fail(symmetricstateunpack(ss_113)) else caught-fail) in
        {2351}let v_795: bool = (not-caught-fail(v_794) && success?(1-proj-3-tuple(v_794))) in
        {2352}let h_98: bitstring = (if v_795 then 3-proj-3-tuple(v_794) else caught-fail) in
        {2353}let ck_114: key = (if v_795 then 2-proj-3-tuple(v_794) else caught-fail) in
        {2354}let cs_98: cipherstate = (if v_795 then 1-proj-3-tuple(v_794) else caught-fail) in
        {2355}let v_796: bitstring = (if v_795 then catch-fail(cipherstateunpack(cs_98)) else caught-fail) in
        {2356}let v_797: bool = (not-caught-fail(v_796) && success?(1-proj-2-tuple(v_796))) in
        {2357}let n_62: nonce = (if v_797 then 2-proj-2-tuple(v_796) else caught-fail) in
        {2358}let k_66: key = (if v_797 then 1-proj-2-tuple(v_796) else caught-fail) in
        {2359}let d_15: aead = (if v_797 then catch-fail(decrypt(k_66,n_62,h_98,ciphertext_45)) else caught-fail) in
        {2360}let v_798: bool = not-caught-fail(d_15) in
        {2361}let v_799: bitstring = (if v_798 then catch-fail(aeadunpack(d_15)) else caught-fail) in
        {2362}let v_800: bool = (not-caught-fail(v_799) && success?(1-proj-3-tuple(v_799))) in
        {2363}let plaintext_45: bitstring = (if v_800 then 3-proj-3-tuple(v_799) else caught-fail) in
        {2364}let adi_15: bitstring = (if v_800 then 2-proj-3-tuple(v_799) else caught-fail) in
        {2365}let valid_39: bool = (if v_800 then 1-proj-3-tuple(v_799) else caught-fail) in
        {2366}let n_63: nonce = (if v_800 then increment_nonce(n_62) else caught-fail) in
        {2367}let v_801: bitstring = (if v_800 then catch-fail(cipherstateunpack(cs_98)) else caught-fail) in
        {2368}let v_802: bool = (not-caught-fail(v_801) && success?(1-proj-2-tuple(v_801))) in
        {2369}let o_31: nonce = (if v_802 then 2-proj-2-tuple(v_801) else caught-fail) in
        {2370}let k_67: key = (if v_802 then 1-proj-2-tuple(v_801) else caught-fail) in
        {2371}let csi_62: cipherstate = (if v_800 then catch-fail((if v_802 then cipherstatepack(k_67,n_63) else fail-any)) else caught-fail) in
        {2372}let v_803: bool = not-caught-fail(csi_62) in
        {2373}let v_804: bitstring = (if v_795 then catch-fail((if v_797 then (if v_798 then (if v_800 then (if v_803 then (csi_62,plaintext_45,valid_39) else fail-any) else fail-any) else fail-any) else fail-any)) else caught-fail) in
        {2374}let v_805: bool = (not-caught-fail(v_804) && success?(1-proj-3-tuple(v_804))) in
        {2375}let valid_40: bool = (if v_805 then 3-proj-3-tuple(v_804) else caught-fail) in
        {2376}let plaintext_46: bitstring = (if v_805 then 2-proj-3-tuple(v_804) else caught-fail) in
        {2377}let csi_63: cipherstate = (if v_805 then 1-proj-3-tuple(v_804) else caught-fail) in
        {2378}let ss_114: symmetricstate = (if v_805 then symmetricstatepack(csi_63,ck_114,h_98) else caught-fail) in
        {2379}let v_806: bitstring = (if v_805 then catch-fail(symmetricstateunpack(ss_114)) else caught-fail) in
        {2380}let v_807: bool = (not-caught-fail(v_806) && success?(1-proj-3-tuple(v_806))) in
        {2381}let h_99: bitstring = (if v_807 then 3-proj-3-tuple(v_806) else caught-fail) in
        {2382}let ck_115: key = (if v_807 then 2-proj-3-tuple(v_806) else caught-fail) in
        {2383}let cs_99: cipherstate = (if v_807 then 1-proj-3-tuple(v_806) else caught-fail) in
        {2384}let ssi_35: symmetricstate = (if v_805 then catch-fail((if v_807 then symmetricstatepack(cs_99,ck_115,hash(h_99,ciphertext_45)) else fail-any)) else caught-fail) in
        {2385}let v_808: bool = not-caught-fail(ssi_35) in
        {2386}let v_809: bitstring = (if v_793 then catch-fail((if v_795 then (if v_805 then (if v_808 then (ssi_35,plaintext_46,valid_40) else fail-any) else fail-any) else fail-any)) else caught-fail) in
        {2387}let v_810: bool = (not-caught-fail(v_809) && success?(1-proj-3-tuple(v_809))) in
        {2388}let valid2_9: bool = (if v_810 then 3-proj-3-tuple(v_809) else caught-fail) in
        {2389}let plaintext_47: bitstring = (if v_810 then 2-proj-3-tuple(v_809) else caught-fail) in
        {2390}let ss_115: symmetricstate = (if v_810 then 1-proj-3-tuple(v_809) else caught-fail) in
        {2391}let v_811: bool = (if v_810 then catch-fail((valid1_11 && valid2_9)) else caught-fail) in
        {2392}let hs_70: handshakestate = (if v_811 then handshakestatepack(ss_115,s_25,m_27,e_43,rs_25,rm_27,re_27,psk_23,initiator_20) else caught-fail) in
        {2393}let (hs_71: handshakestate,plaintext_e_1: bitstring,valid_41: bool) = (if v_791 then (if v_793 then (if v_810 then (if undo-catch-fail(v_811) then (hs_70,plaintext_47,true) else fail-any) else fail-any) else fail-any) else fail-any) in
        {2394}event RecvMsg(me_3,them_3,stagepack_e(sid_4),plaintext_e_1);
        {2395}event RecvEnd(valid_41)
    ) | (
        {2397}event LeakS(phase0,me_3);
        {2398}event LeakM(phase0,me_3);
        {2399}out(pub, (key_s(me_3),key_m(me_3)))
    ) | (
        {2400}phase 1;
        {2401}event LeakS(phase1,me_3);
        {2402}event LeakM(phase1,me_3);
        {2403}out(pub, (key_s(me_3),key_m(me_3)))
    )
)

--  Process 1 (that is, process 0, with let moved downwards):
{1}out(pub, (key_s(charlie),key_m(charlie)));
{2}!
{3}new sid: sessionid;
(
    {8}let m: keypair = keypairpack(empty,empty) in
    {7}let s: keypair = keypairpack(empty,empty) in
    {9}out(pub, (getpublickey(s),getpublickey(m)));
    {6}let sid_1: sessionid = sid in
    {5}let them: principal = bob in
    {4}let me: principal = alice in
    (
        {19}let k: key = empty in
        {20}let cs: cipherstate = cipherstatepack(k,minnonce) in
        {16}let protocol_name: bitstring = somename in
        {17}let h: bitstring = hash(protocol_name,empty) in
        {18}let ck: key = h in
        {21}let ss: symmetricstate = symmetricstatepack(cs,ck,h) in
        {22}let v: bitstring = catch-fail(symmetricstateunpack(ss)) in
        {23}let v_1: bool = (not-caught-fail(v) && success?(1-proj-3-tuple(v))) in
        {24}let h_1: bitstring = (if v_1 then 3-proj-3-tuple(v) else caught-fail) in
        {25}let ck_1: key = (if v_1 then 2-proj-3-tuple(v) else caught-fail) in
        {26}let cs_1: cipherstate = (if v_1 then 1-proj-3-tuple(v) else caught-fail) in
        {14}let prologue: bitstring = empty in
        {27}let ss_1: symmetricstate = catch-fail((if v_1 then symmetricstatepack(cs_1,ck_1,hash(h_1,prologue)) else fail-any)) in
        {28}let v_2: bool = not-caught-fail(ss_1) in
        {15}let psk: key = empty in
        {13}let re: key = empty in
        {12}let rm: key = empty in
        {11}let rs: key = empty in
        {10}let e: keypair = keypairpack(empty,empty) in
        {29}let hs: handshakestate = (if v_2 then handshakestatepack(ss_1,s,m,e,rs,rm,re,psk,true) else fail-any) in
        {30}insert statestore(me,them,sid_1,statepack_a(hs))
    ) | (
        {101}get statestore(=me,=them,=sid_1,statepack_a(hs_1: handshakestate)) in
        {32}let v_3: bitstring = catch-fail(handshakestateunpack(hs_1)) in
        {33}let v_4: bool = (not-caught-fail(v_3) && success?(1-proj-9-tuple(v_3))) in
        {34}let initiator_1: bool = (if v_4 then 9-proj-9-tuple(v_3) else caught-fail) in
        {35}let psk_1: key = (if v_4 then 8-proj-9-tuple(v_3) else caught-fail) in
        {36}let re_1: key = (if v_4 then 7-proj-9-tuple(v_3) else caught-fail) in
        {37}let rm_1: key = (if v_4 then 6-proj-9-tuple(v_3) else caught-fail) in
        {38}let rs_1: key = (if v_4 then 5-proj-9-tuple(v_3) else caught-fail) in
        {39}let e_1: keypair = (if v_4 then 4-proj-9-tuple(v_3) else caught-fail) in
        {40}let m_1: keypair = (if v_4 then 3-proj-9-tuple(v_3) else caught-fail) in
        {41}let s_1: keypair = (if v_4 then 2-proj-9-tuple(v_3) else caught-fail) in
        {42}let ss_2: symmetricstate = (if v_4 then 1-proj-9-tuple(v_3) else caught-fail) in
        {43}let v_5: bitstring = (if v_4 then catch-fail((empty,empty,empty)) else caught-fail) in
        {44}let v_6: bool = (not-caught-fail(v_5) && success?(1-proj-3-tuple(v_5))) in
        {45}let ciphertext: bitstring = (if v_6 then 3-proj-3-tuple(v_5) else caught-fail) in
        {46}let ns: bitstring = (if v_6 then 2-proj-3-tuple(v_5) else caught-fail) in
        {47}let ne: bitstring = (if v_6 then 1-proj-3-tuple(v_5) else caught-fail) in
        {48}let basis: key = (if v_6 then key_e(me,them,sid_1) else caught-fail) in
        {49}let public_key: key = (if v_6 then catch-fail(dhexp(basis,validkey(g))) else caught-fail) in
        {50}let v_7: bool = not-caught-fail(public_key) in
        {51}let e_2: keypair = (if v_6 then catch-fail((if v_7 then keypairpack(validkey(public_key),basis) else fail-any)) else caught-fail) in
        {52}let v_8: bool = not-caught-fail(e_2) in
        {53}let ne_1: bitstring = (if v_8 then catch-fail(getpublickey(e_2)) else caught-fail) in
        {54}let v_9: bool = not-caught-fail(ne_1) in
        {55}let v_10: bitstring = (if v_9 then catch-fail(symmetricstateunpack(ss_2)) else caught-fail) in
        {56}let v_11: bool = (not-caught-fail(v_10) && success?(1-proj-3-tuple(v_10))) in
        {57}let h_2: bitstring = (if v_11 then 3-proj-3-tuple(v_10) else caught-fail) in
        {58}let ck_2: key = (if v_11 then 2-proj-3-tuple(v_10) else caught-fail) in
        {59}let cs_2: cipherstate = (if v_11 then 1-proj-3-tuple(v_10) else caught-fail) in
        {60}let ss_3: symmetricstate = (if v_9 then catch-fail((if v_11 then symmetricstatepack(cs_2,ck_2,hash(h_2,ne_1)) else fail-any)) else caught-fail) in
        {61}let v_12: bool = not-caught-fail(ss_3) in
        {62}let v_13: bitstring = (if v_12 then catch-fail(symmetricstateunpack(ss_3)) else caught-fail) in
        {63}let v_14: bool = (not-caught-fail(v_13) && success?(1-proj-3-tuple(v_13))) in
        {64}let h_3: bitstring = (if v_14 then 3-proj-3-tuple(v_13) else caught-fail) in
        {65}let ck_3: key = (if v_14 then 2-proj-3-tuple(v_13) else caught-fail) in
        {66}let cs_3: cipherstate = (if v_14 then 1-proj-3-tuple(v_13) else caught-fail) in
        {67}let v_15: bitstring = (if v_14 then catch-fail(cipherstateunpack(cs_3)) else caught-fail) in
        {68}let v_16: bool = (not-caught-fail(v_15) && success?(1-proj-2-tuple(v_15))) in
        {69}let n: nonce = (if v_16 then 2-proj-2-tuple(v_15) else caught-fail) in
        {70}let k_1: key = (if v_16 then 1-proj-2-tuple(v_15) else caught-fail) in
        {73}let v_17: bitstring = (if v_16 then catch-fail(cipherstateunpack(cs_3)) else caught-fail) in
        {74}let v_18: bool = (not-caught-fail(v_17) && success?(1-proj-2-tuple(v_17))) in
        {75}let o: nonce = (if v_18 then 2-proj-2-tuple(v_17) else caught-fail) in
        {76}let k_2: key = (if v_18 then 1-proj-2-tuple(v_17) else caught-fail) in
        {72}let n_1: nonce = (if v_16 then increment_nonce(n) else caught-fail) in
        {77}let csi: cipherstate = (if v_16 then catch-fail((if v_18 then cipherstatepack(k_2,n_1) else fail-any)) else caught-fail) in
        {78}let v_19: bool = not-caught-fail(csi) in
        {31}let payload: bitstring = msg_a(me,them,sid_1) in
        {71}let e_3: bitstring = (if v_16 then encrypt(k_1,n,h_3,payload) else caught-fail) in
        {79}let v_20: bitstring = (if v_14 then catch-fail((if v_16 then (if v_19 then (csi,e_3) else fail-any) else fail-any)) else caught-fail) in
        {80}let v_21: bool = (not-caught-fail(v_20) && success?(1-proj-2-tuple(v_20))) in
        {81}let ciphertext_1: bitstring = (if v_21 then 2-proj-2-tuple(v_20) else caught-fail) in
        {82}let csi_1: cipherstate = (if v_21 then 1-proj-2-tuple(v_20) else caught-fail) in
        {83}let ss_4: symmetricstate = (if v_21 then symmetricstatepack(csi_1,ck_3,h_3) else caught-fail) in
        {84}let v_22: bitstring = (if v_21 then catch-fail(symmetricstateunpack(ss_4)) else caught-fail) in
        {85}let v_23: bool = (not-caught-fail(v_22) && success?(1-proj-3-tuple(v_22))) in
        {86}let h_4: bitstring = (if v_23 then 3-proj-3-tuple(v_22) else caught-fail) in
        {87}let ck_4: key = (if v_23 then 2-proj-3-tuple(v_22) else caught-fail) in
        {88}let cs_4: cipherstate = (if v_23 then 1-proj-3-tuple(v_22) else caught-fail) in
        {89}let ssi: symmetricstate = (if v_21 then catch-fail((if v_23 then symmetricstatepack(cs_4,ck_4,hash(h_4,ciphertext_1)) else fail-any)) else caught-fail) in
        {90}let v_24: bool = not-caught-fail(ssi) in
        {91}let v_25: bitstring = (if v_12 then catch-fail((if v_14 then (if v_21 then (if v_24 then (ssi,ciphertext_1) else fail-any) else fail-any) else fail-any)) else caught-fail) in
        {92}let v_26: bool = (not-caught-fail(v_25) && success?(1-proj-2-tuple(v_25))) in
        {93}let ciphertext_2: bitstring = (if v_26 then 2-proj-2-tuple(v_25) else caught-fail) in
        {94}let ss_5: symmetricstate = (if v_26 then 1-proj-2-tuple(v_25) else caught-fail) in
        {96}let message_buffer: bitstring = (if v_26 then concat3(ne_1,ns,ciphertext_2) else caught-fail) in
        {95}let hs_2: handshakestate = (if v_26 then handshakestatepack(ss_5,s_1,m_1,e_2,rs_1,rm_1,re_1,psk_1,initiator_1) else caught-fail) in
        {97}let (hs_3: handshakestate,message_a: bitstring) = (if v_4 then (if v_6 then (if v_8 then (if v_9 then (if v_12 then (if v_26 then (hs_2,message_buffer) else fail-any) else fail-any) else fail-any) else fail-any) else fail-any) else fail-any) in
        {98}event SendMsg(me,them,stagepack_a(sid_1),msg_a(me,them,sid_1));
        {99}insert statestore(me,them,sid_1,statepack_b(hs_3));
        {100}out(pub, message_a)
    ) | (
        {328}get statestore(=me,=them,=sid_1,statepack_b(hs_4: handshakestate)) in
        {102}in(pub, message_b: bitstring);
        {103}let v_27: bitstring = catch-fail(handshakestateunpack(hs_4)) in
        {104}let v_28: bool = (not-caught-fail(v_27) && success?(1-proj-9-tuple(v_27))) in
        {105}let initiator_2: bool = (if v_28 then 9-proj-9-tuple(v_27) else caught-fail) in
        {106}let psk_2: key = (if v_28 then 8-proj-9-tuple(v_27) else caught-fail) in
        {107}let re_2: key = (if v_28 then 7-proj-9-tuple(v_27) else caught-fail) in
        {108}let rm_2: key = (if v_28 then 6-proj-9-tuple(v_27) else caught-fail) in
        {109}let rs_2: key = (if v_28 then 5-proj-9-tuple(v_27) else caught-fail) in
        {110}let e_4: keypair = (if v_28 then 4-proj-9-tuple(v_27) else caught-fail) in
        {111}let m_2: keypair = (if v_28 then 3-proj-9-tuple(v_27) else caught-fail) in
        {112}let s_2: keypair = (if v_28 then 2-proj-9-tuple(v_27) else caught-fail) in
        {113}let ss_6: symmetricstate = (if v_28 then 1-proj-9-tuple(v_27) else caught-fail) in
        {114}let v_29: bitstring = (if v_28 then catch-fail(deconcat4(message_b)) else caught-fail) in
        {115}let v_30: bool = (not-caught-fail(v_29) && success?(1-proj-4-tuple(v_29))) in
        {116}let ciphertext_3: bitstring = (if v_30 then 4-proj-4-tuple(v_29) else caught-fail) in
        {117}let nm: bitstring = (if v_30 then 3-proj-4-tuple(v_29) else caught-fail) in
        {118}let ns_1: bitstring = (if v_30 then 2-proj-4-tuple(v_29) else caught-fail) in
        {119}let ne_2: bitstring = (if v_30 then 1-proj-4-tuple(v_29) else caught-fail) in
        {122}let v_31: bitstring = (if v_30 then catch-fail(symmetricstateunpack(ss_6)) else caught-fail) in
        {123}let v_32: bool = (not-caught-fail(v_31) && success?(1-proj-3-tuple(v_31))) in
        {124}let h_5: bitstring = (if v_32 then 3-proj-3-tuple(v_31) else caught-fail) in
        {125}let ck_5: key = (if v_32 then 2-proj-3-tuple(v_31) else caught-fail) in
        {126}let cs_5: cipherstate = (if v_32 then 1-proj-3-tuple(v_31) else caught-fail) in
        {121}let re_3: key = (if v_30 then ne_2 else caught-fail) in
        {127}let ss_7: symmetricstate = (if v_30 then catch-fail((if v_32 then symmetricstatepack(cs_5,ck_5,hash(h_5,re_3)) else fail-any)) else caught-fail) in
        {128}let v_33: bool = not-caught-fail(ss_7) in
        {129}let v_34: bitstring = (if v_33 then catch-fail(keypairunpack(e_4)) else caught-fail) in
        {130}let v_35: bool = (not-caught-fail(v_34) && success?(1-proj-2-tuple(v_34))) in
        {131}let my_private_key: key = (if v_35 then 2-proj-2-tuple(v_34) else caught-fail) in
        {132}let my_public_key: key = (if v_35 then 1-proj-2-tuple(v_34) else caught-fail) in
        {133}let input_key_material: key = (if v_33 then catch-fail((if v_35 then dhexp(my_private_key,re_3) else fail-any)) else caught-fail) in
        {134}let v_36: bool = not-caught-fail(input_key_material) in
        {135}let v_37: bitstring = (if v_36 then catch-fail(symmetricstateunpack(ss_7)) else caught-fail) in
        {136}let v_38: bool = (not-caught-fail(v_37) && success?(1-proj-3-tuple(v_37))) in
        {137}let h_6: bitstring = (if v_38 then 3-proj-3-tuple(v_37) else caught-fail) in
        {138}let ck_6: key = (if v_38 then 2-proj-3-tuple(v_37) else caught-fail) in
        {139}let cs_6: cipherstate = (if v_38 then 1-proj-3-tuple(v_37) else caught-fail) in
        {142}let output3: key = (if v_38 then hmac_hash3(ck_6,input_key_material) else caught-fail) in
        {141}let output2: key = (if v_38 then hmac_hash2(ck_6,input_key_material) else caught-fail) in
        {140}let output1: key = (if v_38 then hmac_hash1(ck_6,input_key_material) else caught-fail) in
        {143}let v_39: bitstring = (if v_38 then catch-fail((output1,output2,output3)) else caught-fail) in
        {144}let v_40: bool = (not-caught-fail(v_39) && success?(1-proj-3-tuple(v_39))) in
        {145}let output_3: key = (if v_40 then 3-proj-3-tuple(v_39) else caught-fail) in
        {146}let temp_k: key = (if v_40 then 2-proj-3-tuple(v_39) else caught-fail) in
        {147}let ck_7: key = (if v_40 then 1-proj-3-tuple(v_39) else caught-fail) in
        {148}let ss_8: symmetricstate = (if v_33 then catch-fail((if v_36 then (if v_38 then (if v_40 then symmetricstatepack(cipherstatepack(temp_k,minnonce),ck_7,h_6) else fail-any) else fail-any) else fail-any)) else caught-fail) in
        {149}let v_41: bool = not-caught-fail(ss_8) in
        {150}let v_42: bitstring = (if v_41 then catch-fail(symmetricstateunpack(ss_8)) else caught-fail) in
        {151}let v_43: bool = (not-caught-fail(v_42) && success?(1-proj-3-tuple(v_42))) in
        {152}let h_7: bitstring = (if v_43 then 3-proj-3-tuple(v_42) else caught-fail) in
        {153}let ck_8: key = (if v_43 then 2-proj-3-tuple(v_42) else caught-fail) in
        {154}let cs_7: cipherstate = (if v_43 then 1-proj-3-tuple(v_42) else caught-fail) in
        {155}let v_44: bitstring = (if v_43 then catch-fail(cipherstateunpack(cs_7)) else caught-fail) in
        {156}let v_45: bool = (not-caught-fail(v_44) && success?(1-proj-2-tuple(v_44))) in
        {157}let n_2: nonce = (if v_45 then 2-proj-2-tuple(v_44) else caught-fail) in
        {158}let k_3: key = (if v_45 then 1-proj-2-tuple(v_44) else caught-fail) in
        {159}let d: aead = (if v_45 then catch-fail(decrypt(k_3,n_2,h_7,ns_1)) else caught-fail) in
        {160}let v_46: bool = not-caught-fail(d) in
        {161}let v_47: bitstring = (if v_46 then catch-fail(aeadunpack(d)) else caught-fail) in
        {162}let v_48: bool = (not-caught-fail(v_47) && success?(1-proj-3-tuple(v_47))) in
        {163}let plaintext: bitstring = (if v_48 then 3-proj-3-tuple(v_47) else caught-fail) in
        {164}let adi: bitstring = (if v_48 then 2-proj-3-tuple(v_47) else caught-fail) in
        {165}let valid: bool = (if v_48 then 1-proj-3-tuple(v_47) else caught-fail) in
        {167}let v_49: bitstring = (if v_48 then catch-fail(cipherstateunpack(cs_7)) else caught-fail) in
        {168}let v_50: bool = (not-caught-fail(v_49) && success?(1-proj-2-tuple(v_49))) in
        {169}let o_1: nonce = (if v_50 then 2-proj-2-tuple(v_49) else caught-fail) in
        {170}let k_4: key = (if v_50 then 1-proj-2-tuple(v_49) else caught-fail) in
        {166}let n_3: nonce = (if v_48 then increment_nonce(n_2) else caught-fail) in
        {171}let csi_2: cipherstate = (if v_48 then catch-fail((if v_50 then cipherstatepack(k_4,n_3) else fail-any)) else caught-fail) in
        {172}let v_51: bool = not-caught-fail(csi_2) in
        {173}let v_52: bitstring = (if v_43 then catch-fail((if v_45 then (if v_46 then (if v_48 then (if v_51 then (csi_2,plaintext,valid) else fail-any) else fail-any) else fail-any) else fail-any)) else caught-fail) in
        {174}let v_53: bool = (not-caught-fail(v_52) && success?(1-proj-3-tuple(v_52))) in
        {175}let valid_1: bool = (if v_53 then 3-proj-3-tuple(v_52) else caught-fail) in
        {176}let plaintext_1: bitstring = (if v_53 then 2-proj-3-tuple(v_52) else caught-fail) in
        {177}let csi_3: cipherstate = (if v_53 then 1-proj-3-tuple(v_52) else caught-fail) in
        {178}let ss_9: symmetricstate = (if v_53 then symmetricstatepack(csi_3,ck_8,h_7) else caught-fail) in
        {179}let v_54: bitstring = (if v_53 then catch-fail(symmetricstateunpack(ss_9)) else caught-fail) in
        {180}let v_55: bool = (not-caught-fail(v_54) && success?(1-proj-3-tuple(v_54))) in
        {181}let h_8: bitstring = (if v_55 then 3-proj-3-tuple(v_54) else caught-fail) in
        {182}let ck_9: key = (if v_55 then 2-proj-3-tuple(v_54) else caught-fail) in
        {183}let cs_8: cipherstate = (if v_55 then 1-proj-3-tuple(v_54) else caught-fail) in
        {184}let ssi_1: symmetricstate = (if v_53 then catch-fail((if v_55 then symmetricstatepack(cs_8,ck_9,hash(h_8,ns_1)) else fail-any)) else caught-fail) in
        {185}let v_56: bool = not-caught-fail(ssi_1) in
        {186}let v_57: bitstring = (if v_41 then catch-fail((if v_43 then (if v_53 then (if v_56 then (ssi_1,plaintext_1,valid_1) else fail-any) else fail-any) else fail-any)) else caught-fail) in
        {187}let v_58: bool = (not-caught-fail(v_57) && success?(1-proj-3-tuple(v_57))) in
        {188}let valid1_1: bool = (if v_58 then 3-proj-3-tuple(v_57) else caught-fail) in
        {189}let ne_3: bitstring = (if v_58 then 2-proj-3-tuple(v_57) else caught-fail) in
        {190}let ss_10: symmetricstate = (if v_58 then 1-proj-3-tuple(v_57) else caught-fail) in
        {192}let v_59: bitstring = (if v_58 then catch-fail(symmetricstateunpack(ss_10)) else caught-fail) in
        {193}let v_60: bool = (not-caught-fail(v_59) && success?(1-proj-3-tuple(v_59))) in
        {194}let h_9: bitstring = (if v_60 then 3-proj-3-tuple(v_59) else caught-fail) in
        {195}let ck_10: key = (if v_60 then 2-proj-3-tuple(v_59) else caught-fail) in
        {196}let cs_9: cipherstate = (if v_60 then 1-proj-3-tuple(v_59) else caught-fail) in
        {197}let v_61: bitstring = (if v_60 then catch-fail(cipherstateunpack(cs_9)) else caught-fail) in
        {198}let v_62: bool = (not-caught-fail(v_61) && success?(1-proj-2-tuple(v_61))) in
        {199}let n_4: nonce = (if v_62 then 2-proj-2-tuple(v_61) else caught-fail) in
        {200}let k_5: key = (if v_62 then 1-proj-2-tuple(v_61) else caught-fail) in
        {201}let d_1: aead = (if v_62 then catch-fail(decrypt(k_5,n_4,h_9,nm)) else caught-fail) in
        {202}let v_63: bool = not-caught-fail(d_1) in
        {203}let v_64: bitstring = (if v_63 then catch-fail(aeadunpack(d_1)) else caught-fail) in
        {204}let v_65: bool = (not-caught-fail(v_64) && success?(1-proj-3-tuple(v_64))) in
        {205}let plaintext_2: bitstring = (if v_65 then 3-proj-3-tuple(v_64) else caught-fail) in
        {206}let adi_1: bitstring = (if v_65 then 2-proj-3-tuple(v_64) else caught-fail) in
        {207}let valid_2: bool = (if v_65 then 1-proj-3-tuple(v_64) else caught-fail) in
        {209}let v_66: bitstring = (if v_65 then catch-fail(cipherstateunpack(cs_9)) else caught-fail) in
        {210}let v_67: bool = (not-caught-fail(v_66) && success?(1-proj-2-tuple(v_66))) in
        {211}let o_2: nonce = (if v_67 then 2-proj-2-tuple(v_66) else caught-fail) in
        {212}let k_6: key = (if v_67 then 1-proj-2-tuple(v_66) else caught-fail) in
        {208}let n_5: nonce = (if v_65 then increment_nonce(n_4) else caught-fail) in
        {213}let csi_4: cipherstate = (if v_65 then catch-fail((if v_67 then cipherstatepack(k_6,n_5) else fail-any)) else caught-fail) in
        {214}let v_68: bool = not-caught-fail(csi_4) in
        {215}let v_69: bitstring = (if v_60 then catch-fail((if v_62 then (if v_63 then (if v_65 then (if v_68 then (csi_4,plaintext_2,valid_2) else fail-any) else fail-any) else fail-any) else fail-any)) else caught-fail) in
        {216}let v_70: bool = (not-caught-fail(v_69) && success?(1-proj-3-tuple(v_69))) in
        {217}let valid_3: bool = (if v_70 then 3-proj-3-tuple(v_69) else caught-fail) in
        {218}let plaintext_3: bitstring = (if v_70 then 2-proj-3-tuple(v_69) else caught-fail) in
        {219}let csi_5: cipherstate = (if v_70 then 1-proj-3-tuple(v_69) else caught-fail) in
        {220}let ss_11: symmetricstate = (if v_70 then symmetricstatepack(csi_5,ck_10,h_9) else caught-fail) in
        {221}let v_71: bitstring = (if v_70 then catch-fail(symmetricstateunpack(ss_11)) else caught-fail) in
        {222}let v_72: bool = (not-caught-fail(v_71) && success?(1-proj-3-tuple(v_71))) in
        {223}let h_10: bitstring = (if v_72 then 3-proj-3-tuple(v_71) else caught-fail) in
        {224}let ck_11: key = (if v_72 then 2-proj-3-tuple(v_71) else caught-fail) in
        {225}let cs_10: cipherstate = (if v_72 then 1-proj-3-tuple(v_71) else caught-fail) in
        {226}let ssi_2: symmetricstate = (if v_70 then catch-fail((if v_72 then symmetricstatepack(cs_10,ck_11,hash(h_10,nm)) else fail-any)) else caught-fail) in
        {227}let v_73: bool = not-caught-fail(ssi_2) in
        {228}let v_74: bitstring = (if v_58 then catch-fail((if v_60 then (if v_70 then (if v_73 then (ssi_2,plaintext_3,valid_3) else fail-any) else fail-any) else fail-any)) else caught-fail) in
        {229}let v_75: bool = (not-caught-fail(v_74) && success?(1-proj-3-tuple(v_74))) in
        {230}let valid2: bool = (if v_75 then 3-proj-3-tuple(v_74) else caught-fail) in
        {231}let ne_4: bitstring = (if v_75 then 2-proj-3-tuple(v_74) else caught-fail) in
        {232}let ss_12: symmetricstate = (if v_75 then 1-proj-3-tuple(v_74) else caught-fail) in
        {234}let v_76: bitstring = (if v_75 then catch-fail(keypairunpack(e_4)) else caught-fail) in
        {235}let v_77: bool = (not-caught-fail(v_76) && success?(1-proj-2-tuple(v_76))) in
        {236}let my_private_key_1: key = (if v_77 then 2-proj-2-tuple(v_76) else caught-fail) in
        {237}let my_public_key_1: key = (if v_77 then 1-proj-2-tuple(v_76) else caught-fail) in
        {191}let rs_3: key = (if v_58 then ne_3 else caught-fail) in
        {238}let input_key_material_1: key = (if v_75 then catch-fail((if v_77 then dhexp(my_private_key_1,rs_3) else fail-any)) else caught-fail) in
        {239}let v_78: bool = not-caught-fail(input_key_material_1) in
        {240}let v_79: bitstring = (if v_78 then catch-fail(symmetricstateunpack(ss_12)) else caught-fail) in
        {241}let v_80: bool = (not-caught-fail(v_79) && success?(1-proj-3-tuple(v_79))) in
        {242}let h_11: bitstring = (if v_80 then 3-proj-3-tuple(v_79) else caught-fail) in
        {243}let ck_12: key = (if v_80 then 2-proj-3-tuple(v_79) else caught-fail) in
        {244}let cs_11: cipherstate = (if v_80 then 1-proj-3-tuple(v_79) else caught-fail) in
        {247}let output3_1: key = (if v_80 then hmac_hash3(ck_12,input_key_material_1) else caught-fail) in
        {246}let output2_1: key = (if v_80 then hmac_hash2(ck_12,input_key_material_1) else caught-fail) in
        {245}let output1_1: key = (if v_80 then hmac_hash1(ck_12,input_key_material_1) else caught-fail) in
        {248}let v_81: bitstring = (if v_80 then catch-fail((output1_1,output2_1,output3_1)) else caught-fail) in
        {249}let v_82: bool = (not-caught-fail(v_81) && success?(1-proj-3-tuple(v_81))) in
        {250}let output: key = (if v_82 then 3-proj-3-tuple(v_81) else caught-fail) in
        {251}let temp_k_1: key = (if v_82 then 2-proj-3-tuple(v_81) else caught-fail) in
        {252}let ck_13: key = (if v_82 then 1-proj-3-tuple(v_81) else caught-fail) in
        {253}let ss_13: symmetricstate = (if v_75 then catch-fail((if v_78 then (if v_80 then (if v_82 then symmetricstatepack(cipherstatepack(temp_k_1,minnonce),ck_13,h_11) else fail-any) else fail-any) else fail-any)) else caught-fail) in
        {254}let v_83: bool = not-caught-fail(ss_13) in
        {255}let v_84: bitstring = (if v_83 then catch-fail(keypairunpack(e_4)) else caught-fail) in
        {256}let v_85: bool = (not-caught-fail(v_84) && success?(1-proj-2-tuple(v_84))) in
        {257}let my_private_key_2: key = (if v_85 then 2-proj-2-tuple(v_84) else caught-fail) in
        {258}let my_public_key_2: key = (if v_85 then 1-proj-2-tuple(v_84) else caught-fail) in
        {233}let rm_3: key = (if v_75 then ne_4 else caught-fail) in
        {259}let input_key_material_2: key = (if v_83 then catch-fail((if v_85 then dhexp(my_private_key_2,rm_3) else fail-any)) else caught-fail) in
        {260}let v_86: bool = not-caught-fail(input_key_material_2) in
        {261}let v_87: bitstring = (if v_86 then catch-fail(symmetricstateunpack(ss_13)) else caught-fail) in
        {262}let v_88: bool = (not-caught-fail(v_87) && success?(1-proj-3-tuple(v_87))) in
        {263}let h_12: bitstring = (if v_88 then 3-proj-3-tuple(v_87) else caught-fail) in
        {264}let ck_14: key = (if v_88 then 2-proj-3-tuple(v_87) else caught-fail) in
        {265}let cs_12: cipherstate = (if v_88 then 1-proj-3-tuple(v_87) else caught-fail) in
        {268}let output3_2: key = (if v_88 then hmac_hash3(ck_14,input_key_material_2) else caught-fail) in
        {267}let output2_2: key = (if v_88 then hmac_hash2(ck_14,input_key_material_2) else caught-fail) in
        {266}let output1_2: key = (if v_88 then hmac_hash1(ck_14,input_key_material_2) else caught-fail) in
        {269}let v_89: bitstring = (if v_88 then catch-fail((output1_2,output2_2,output3_2)) else caught-fail) in
        {270}let v_90: bool = (not-caught-fail(v_89) && success?(1-proj-3-tuple(v_89))) in
        {271}let output_1: key = (if v_90 then 3-proj-3-tuple(v_89) else caught-fail) in
        {272}let temp_k_2: key = (if v_90 then 2-proj-3-tuple(v_89) else caught-fail) in
        {273}let ck_15: key = (if v_90 then 1-proj-3-tuple(v_89) else caught-fail) in
        {274}let ss_14: symmetricstate = (if v_83 then catch-fail((if v_86 then (if v_88 then (if v_90 then symmetricstatepack(cipherstatepack(temp_k_2,minnonce),ck_15,h_12) else fail-any) else fail-any) else fail-any)) else caught-fail) in
        {275}let v_91: bool = not-caught-fail(ss_14) in
        {276}let v_92: bitstring = (if v_91 then catch-fail(symmetricstateunpack(ss_14)) else caught-fail) in
        {277}let v_93: bool = (not-caught-fail(v_92) && success?(1-proj-3-tuple(v_92))) in
        {278}let h_13: bitstring = (if v_93 then 3-proj-3-tuple(v_92) else caught-fail) in
        {279}let ck_16: key = (if v_93 then 2-proj-3-tuple(v_92) else caught-fail) in
        {280}let cs_13: cipherstate = (if v_93 then 1-proj-3-tuple(v_92) else caught-fail) in
        {281}let v_94: bitstring = (if v_93 then catch-fail(cipherstateunpack(cs_13)) else caught-fail) in
        {282}let v_95: bool = (not-caught-fail(v_94) && success?(1-proj-2-tuple(v_94))) in
        {283}let n_6: nonce = (if v_95 then 2-proj-2-tuple(v_94) else caught-fail) in
        {284}let k_7: key = (if v_95 then 1-proj-2-tuple(v_94) else caught-fail) in
        {285}let d_2: aead = (if v_95 then catch-fail(decrypt(k_7,n_6,h_13,ciphertext_3)) else caught-fail) in
        {286}let v_96: bool = not-caught-fail(d_2) in
        {287}let v_97: bitstring = (if v_96 then catch-fail(aeadunpack(d_2)) else caught-fail) in
        {288}let v_98: bool = (not-caught-fail(v_97) && success?(1-proj-3-tuple(v_97))) in
        {289}let plaintext_4: bitstring = (if v_98 then 3-proj-3-tuple(v_97) else caught-fail) in
        {290}let adi_2: bitstring = (if v_98 then 2-proj-3-tuple(v_97) else caught-fail) in
        {291}let valid_4: bool = (if v_98 then 1-proj-3-tuple(v_97) else caught-fail) in
        {293}let v_99: bitstring = (if v_98 then catch-fail(cipherstateunpack(cs_13)) else caught-fail) in
        {294}let v_100: bool = (not-caught-fail(v_99) && success?(1-proj-2-tuple(v_99))) in
        {295}let o_3: nonce = (if v_100 then 2-proj-2-tuple(v_99) else caught-fail) in
        {296}let k_8: key = (if v_100 then 1-proj-2-tuple(v_99) else caught-fail) in
        {292}let n_7: nonce = (if v_98 then increment_nonce(n_6) else caught-fail) in
        {297}let csi_6: cipherstate = (if v_98 then catch-fail((if v_100 then cipherstatepack(k_8,n_7) else fail-any)) else caught-fail) in
        {298}let v_101: bool = not-caught-fail(csi_6) in
        {299}let v_102: bitstring = (if v_93 then catch-fail((if v_95 then (if v_96 then (if v_98 then (if v_101 then (csi_6,plaintext_4,valid_4) else fail-any) else fail-any) else fail-any) else fail-any)) else caught-fail) in
        {300}let v_103: bool = (not-caught-fail(v_102) && success?(1-proj-3-tuple(v_102))) in
        {301}let valid_5: bool = (if v_103 then 3-proj-3-tuple(v_102) else caught-fail) in
        {302}let plaintext_5: bitstring = (if v_103 then 2-proj-3-tuple(v_102) else caught-fail) in
        {303}let csi_7: cipherstate = (if v_103 then 1-proj-3-tuple(v_102) else caught-fail) in
        {304}let ss_15: symmetricstate = (if v_103 then symmetricstatepack(csi_7,ck_16,h_13) else caught-fail) in
        {305}let v_104: bitstring = (if v_103 then catch-fail(symmetricstateunpack(ss_15)) else caught-fail) in
        {306}let v_105: bool = (not-caught-fail(v_104) && success?(1-proj-3-tuple(v_104))) in
        {307}let h_14: bitstring = (if v_105 then 3-proj-3-tuple(v_104) else caught-fail) in
        {308}let ck_17: key = (if v_105 then 2-proj-3-tuple(v_104) else caught-fail) in
        {309}let cs_14: cipherstate = (if v_105 then 1-proj-3-tuple(v_104) else caught-fail) in
        {310}let ssi_3: symmetricstate = (if v_103 then catch-fail((if v_105 then symmetricstatepack(cs_14,ck_17,hash(h_14,ciphertext_3)) else fail-any)) else caught-fail) in
        {311}let v_106: bool = not-caught-fail(ssi_3) in
        {312}let v_107: bitstring = (if v_91 then catch-fail((if v_93 then (if v_103 then (if v_106 then (ssi_3,plaintext_5,valid_5) else fail-any) else fail-any) else fail-any)) else caught-fail) in
        {313}let v_108: bool = (not-caught-fail(v_107) && success?(1-proj-3-tuple(v_107))) in
        {314}let valid3: bool = (if v_108 then 3-proj-3-tuple(v_107) else caught-fail) in
        {315}let plaintext_6: bitstring = (if v_108 then 2-proj-3-tuple(v_107) else caught-fail) in
        {316}let ss_16: symmetricstate = (if v_108 then 1-proj-3-tuple(v_107) else caught-fail) in
        {320}let basis_2: key = (if v_108 then key_m(them) else caught-fail) in
        {321}let public_key_2: key = (if v_108 then catch-fail(dhexp(basis_2,validkey(g))) else caught-fail) in
        {322}let v_110: bool = not-caught-fail(public_key_2) in
        {317}let basis_1: key = (if v_108 then key_s(them) else caught-fail) in
        {318}let public_key_1: key = (if v_108 then catch-fail(dhexp(basis_1,validkey(g))) else caught-fail) in
        {319}let v_109: bool = not-caught-fail(public_key_1) in
        {323}let v_111: bool = (if v_108 then catch-fail(((valid1_1 && (valid2 && valid3)) && ((rs_3 = getpublickey((if v_109 then keypairpack(validkey(public_key_1),basis_1) else fail-any))) && (rm_3 = getpublickey((if v_110 then keypairpack(validkey(public_key_2),basis_2) else fail-any)))))) else caught-fail) in
        {324}let hs_5: handshakestate = (if v_111 then handshakestatepack(ss_16,s_2,m_2,e_4,rs_3,rm_3,re_3,psk_2,initiator_2) else caught-fail) in
        {325}let (hs_6: handshakestate,plaintext_b: bitstring,valid_6: bool) = (if v_28 then (if v_30 then (if v_33 then (if v_41 then (if v_58 then (if v_75 then (if v_83 then (if v_91 then (if v_108 then (if undo-catch-fail(v_111) then (hs_5,plaintext_6,true) else fail-any) else fail-any) else fail-any) else fail-any) else fail-any) else fail-any) else fail-any) else fail-any) else fail-any) else fail-any) in
        {326}event RecvMsg(me,them,stagepack_b(sid_1),plaintext_b);
        {327}insert statestore(me,them,sid_1,statepack_c(hs_6))
    ) | (
        {468}get statestore(=me,=them,=sid_1,statepack_c(hs_7: handshakestate)) in
        {330}let v_112: bitstring = catch-fail(handshakestateunpack(hs_7)) in
        {331}let v_113: bool = (not-caught-fail(v_112) && success?(1-proj-9-tuple(v_112))) in
        {332}let initiator_3: bool = (if v_113 then 9-proj-9-tuple(v_112) else caught-fail) in
        {333}let psk_3: key = (if v_113 then 8-proj-9-tuple(v_112) else caught-fail) in
        {334}let re_4: key = (if v_113 then 7-proj-9-tuple(v_112) else caught-fail) in
        {335}let rm_4: key = (if v_113 then 6-proj-9-tuple(v_112) else caught-fail) in
        {336}let rs_4: key = (if v_113 then 5-proj-9-tuple(v_112) else caught-fail) in
        {337}let e_5: keypair = (if v_113 then 4-proj-9-tuple(v_112) else caught-fail) in
        {338}let m_3: keypair = (if v_113 then 3-proj-9-tuple(v_112) else caught-fail) in
        {339}let s_3: keypair = (if v_113 then 2-proj-9-tuple(v_112) else caught-fail) in
        {340}let ss_17: symmetricstate = (if v_113 then 1-proj-9-tuple(v_112) else caught-fail) in
        {341}let v_114: bitstring = (if v_113 then catch-fail((empty,empty,empty,empty)) else caught-fail) in
        {342}let v_115: bool = (not-caught-fail(v_114) && success?(1-proj-4-tuple(v_114))) in
        {343}let ciphertext_4: bitstring = (if v_115 then 4-proj-4-tuple(v_114) else caught-fail) in
        {344}let nm_1: bitstring = (if v_115 then 3-proj-4-tuple(v_114) else caught-fail) in
        {345}let ns_2: bitstring = (if v_115 then 2-proj-4-tuple(v_114) else caught-fail) in
        {346}let ne_5: bitstring = (if v_115 then 1-proj-4-tuple(v_114) else caught-fail) in
        {347}let basis_3: key = (if v_115 then key_m(me) else caught-fail) in
        {348}let public_key_3: key = (if v_115 then catch-fail(dhexp(basis_3,validkey(g))) else caught-fail) in
        {349}let v_116: bool = not-caught-fail(public_key_3) in
        {350}let m_4: keypair = (if v_115 then catch-fail((if v_116 then keypairpack(validkey(public_key_3),basis_3) else fail-any)) else caught-fail) in
        {351}let v_117: bool = not-caught-fail(m_4) in
        {352}let plaintext_7: bitstring = (if v_117 then catch-fail(getpublickey(m_4)) else caught-fail) in
        {353}let v_118: bool = not-caught-fail(plaintext_7) in
        {354}let v_119: bitstring = (if v_118 then catch-fail(symmetricstateunpack(ss_17)) else caught-fail) in
        {355}let v_120: bool = (not-caught-fail(v_119) && success?(1-proj-3-tuple(v_119))) in
        {356}let h_15: bitstring = (if v_120 then 3-proj-3-tuple(v_119) else caught-fail) in
        {357}let ck_18: key = (if v_120 then 2-proj-3-tuple(v_119) else caught-fail) in
        {358}let cs_15: cipherstate = (if v_120 then 1-proj-3-tuple(v_119) else caught-fail) in
        {359}let v_121: bitstring = (if v_120 then catch-fail(cipherstateunpack(cs_15)) else caught-fail) in
        {360}let v_122: bool = (not-caught-fail(v_121) && success?(1-proj-2-tuple(v_121))) in
        {361}let n_8: nonce = (if v_122 then 2-proj-2-tuple(v_121) else caught-fail) in
        {362}let k_9: key = (if v_122 then 1-proj-2-tuple(v_121) else caught-fail) in
        {365}let v_123: bitstring = (if v_122 then catch-fail(cipherstateunpack(cs_15)) else caught-fail) in
        {366}let v_124: bool = (not-caught-fail(v_123) && success?(1-proj-2-tuple(v_123))) in
        {367}let o_4: nonce = (if v_124 then 2-proj-2-tuple(v_123) else caught-fail) in
        {368}let k_10: key = (if v_124 then 1-proj-2-tuple(v_123) else caught-fail) in
        {364}let n_9: nonce = (if v_122 then increment_nonce(n_8) else caught-fail) in
        {369}let csi_8: cipherstate = (if v_122 then catch-fail((if v_124 then cipherstatepack(k_10,n_9) else fail-any)) else caught-fail) in
        {370}let v_125: bool = not-caught-fail(csi_8) in
        {363}let e_6: bitstring = (if v_122 then encrypt(k_9,n_8,h_15,plaintext_7) else caught-fail) in
        {371}let v_126: bitstring = (if v_120 then catch-fail((if v_122 then (if v_125 then (csi_8,e_6) else fail-any) else fail-any)) else caught-fail) in
        {372}let v_127: bool = (not-caught-fail(v_126) && success?(1-proj-2-tuple(v_126))) in
        {373}let ciphertext_5: bitstring = (if v_127 then 2-proj-2-tuple(v_126) else caught-fail) in
        {374}let csi_9: cipherstate = (if v_127 then 1-proj-2-tuple(v_126) else caught-fail) in
        {375}let ss_18: symmetricstate = (if v_127 then symmetricstatepack(csi_9,ck_18,h_15) else caught-fail) in
        {376}let v_128: bitstring = (if v_127 then catch-fail(symmetricstateunpack(ss_18)) else caught-fail) in
        {377}let v_129: bool = (not-caught-fail(v_128) && success?(1-proj-3-tuple(v_128))) in
        {378}let h_16: bitstring = (if v_129 then 3-proj-3-tuple(v_128) else caught-fail) in
        {379}let ck_19: key = (if v_129 then 2-proj-3-tuple(v_128) else caught-fail) in
        {380}let cs_16: cipherstate = (if v_129 then 1-proj-3-tuple(v_128) else caught-fail) in
        {381}let ssi_4: symmetricstate = (if v_127 then catch-fail((if v_129 then symmetricstatepack(cs_16,ck_19,hash(h_16,ciphertext_5)) else fail-any)) else caught-fail) in
        {382}let v_130: bool = not-caught-fail(ssi_4) in
        {383}let v_131: bitstring = (if v_117 then catch-fail((if v_118 then (if v_120 then (if v_127 then (if v_130 then (ssi_4,ciphertext_5) else fail-any) else fail-any) else fail-any) else fail-any)) else caught-fail) in
        {384}let v_132: bool = (not-caught-fail(v_131) && success?(1-proj-2-tuple(v_131))) in
        {385}let nm_2: bitstring = (if v_132 then 2-proj-2-tuple(v_131) else caught-fail) in
        {386}let ss_19: symmetricstate = (if v_132 then 1-proj-2-tuple(v_131) else caught-fail) in
        {387}let v_133: bitstring = (if v_132 then catch-fail(keypairunpack(m_4)) else caught-fail) in
        {388}let v_134: bool = (not-caught-fail(v_133) && success?(1-proj-2-tuple(v_133))) in
        {389}let my_private_key_3: key = (if v_134 then 2-proj-2-tuple(v_133) else caught-fail) in
        {390}let my_public_key_3: key = (if v_134 then 1-proj-2-tuple(v_133) else caught-fail) in
        {391}let input_key_material_3: key = (if v_132 then catch-fail((if v_134 then dhexp(my_private_key_3,re_4) else fail-any)) else caught-fail) in
        {392}let v_135: bool = not-caught-fail(input_key_material_3) in
        {393}let v_136: bitstring = (if v_135 then catch-fail(symmetricstateunpack(ss_19)) else caught-fail) in
        {394}let v_137: bool = (not-caught-fail(v_136) && success?(1-proj-3-tuple(v_136))) in
        {395}let h_17: bitstring = (if v_137 then 3-proj-3-tuple(v_136) else caught-fail) in
        {396}let ck_20: key = (if v_137 then 2-proj-3-tuple(v_136) else caught-fail) in
        {397}let cs_17: cipherstate = (if v_137 then 1-proj-3-tuple(v_136) else caught-fail) in
        {400}let output3_3: key = (if v_137 then hmac_hash3(ck_20,input_key_material_3) else caught-fail) in
        {399}let output2_3: key = (if v_137 then hmac_hash2(ck_20,input_key_material_3) else caught-fail) in
        {398}let output1_3: key = (if v_137 then hmac_hash1(ck_20,input_key_material_3) else caught-fail) in
        {401}let v_138: bitstring = (if v_137 then catch-fail((output1_3,output2_3,output3_3)) else caught-fail) in
        {402}let v_139: bool = (not-caught-fail(v_138) && success?(1-proj-3-tuple(v_138))) in
        {403}let output_2: key = (if v_139 then 3-proj-3-tuple(v_138) else caught-fail) in
        {404}let temp_k_3: key = (if v_139 then 2-proj-3-tuple(v_138) else caught-fail) in
        {405}let ck_21: key = (if v_139 then 1-proj-3-tuple(v_138) else caught-fail) in
        {406}let ss_20: symmetricstate = (if v_132 then catch-fail((if v_135 then (if v_137 then (if v_139 then symmetricstatepack(cipherstatepack(temp_k_3,minnonce),ck_21,h_17) else fail-any) else fail-any) else fail-any)) else caught-fail) in
        {407}let v_140: bool = not-caught-fail(ss_20) in
        {408}let v_141: bitstring = (if v_140 then catch-fail(symmetricstateunpack(ss_20)) else caught-fail) in
        {409}let v_142: bool = (not-caught-fail(v_141) && success?(1-proj-3-tuple(v_141))) in
        {410}let h_18: bitstring = (if v_142 then 3-proj-3-tuple(v_141) else caught-fail) in
        {411}let ck_22: key = (if v_142 then 2-proj-3-tuple(v_141) else caught-fail) in
        {412}let cs_18: cipherstate = (if v_142 then 1-proj-3-tuple(v_141) else caught-fail) in
        {413}let v_143: bitstring = (if v_142 then catch-fail(cipherstateunpack(cs_18)) else caught-fail) in
        {414}let v_144: bool = (not-caught-fail(v_143) && success?(1-proj-2-tuple(v_143))) in
        {415}let n_10: nonce = (if v_144 then 2-proj-2-tuple(v_143) else caught-fail) in
        {416}let k_11: key = (if v_144 then 1-proj-2-tuple(v_143) else caught-fail) in
        {419}let v_145: bitstring = (if v_144 then catch-fail(cipherstateunpack(cs_18)) else caught-fail) in
        {420}let v_146: bool = (not-caught-fail(v_145) && success?(1-proj-2-tuple(v_145))) in
        {421}let o_5: nonce = (if v_146 then 2-proj-2-tuple(v_145) else caught-fail) in
        {422}let k_12: key = (if v_146 then 1-proj-2-tuple(v_145) else caught-fail) in
        {418}let n_11: nonce = (if v_144 then increment_nonce(n_10) else caught-fail) in
        {423}let csi_10: cipherstate = (if v_144 then catch-fail((if v_146 then cipherstatepack(k_12,n_11) else fail-any)) else caught-fail) in
        {424}let v_147: bool = not-caught-fail(csi_10) in
        {329}let payload_1: bitstring = msg_c(me,them,sid_1) in
        {417}let e_7: bitstring = (if v_144 then encrypt(k_11,n_10,h_18,payload_1) else caught-fail) in
        {425}let v_148: bitstring = (if v_142 then catch-fail((if v_144 then (if v_147 then (csi_10,e_7) else fail-any) else fail-any)) else caught-fail) in
        {426}let v_149: bool = (not-caught-fail(v_148) && success?(1-proj-2-tuple(v_148))) in
        {427}let ciphertext_6: bitstring = (if v_149 then 2-proj-2-tuple(v_148) else caught-fail) in
        {428}let csi_11: cipherstate = (if v_149 then 1-proj-2-tuple(v_148) else caught-fail) in
        {429}let ss_21: symmetricstate = (if v_149 then symmetricstatepack(csi_11,ck_22,h_18) else caught-fail) in
        {430}let v_150: bitstring = (if v_149 then catch-fail(symmetricstateunpack(ss_21)) else caught-fail) in
        {431}let v_151: bool = (not-caught-fail(v_150) && success?(1-proj-3-tuple(v_150))) in
        {432}let h_19: bitstring = (if v_151 then 3-proj-3-tuple(v_150) else caught-fail) in
        {433}let ck_23: key = (if v_151 then 2-proj-3-tuple(v_150) else caught-fail) in
        {434}let cs_19: cipherstate = (if v_151 then 1-proj-3-tuple(v_150) else caught-fail) in
        {435}let ssi_5: symmetricstate = (if v_149 then catch-fail((if v_151 then symmetricstatepack(cs_19,ck_23,hash(h_19,ciphertext_6)) else fail-any)) else caught-fail) in
        {436}let v_152: bool = not-caught-fail(ssi_5) in
        {437}let v_153: bitstring = (if v_140 then catch-fail((if v_142 then (if v_149 then (if v_152 then (ssi_5,ciphertext_6) else fail-any) else fail-any) else fail-any)) else caught-fail) in
        {438}let v_154: bool = (not-caught-fail(v_153) && success?(1-proj-2-tuple(v_153))) in
        {439}let ciphertext_7: bitstring = (if v_154 then 2-proj-2-tuple(v_153) else caught-fail) in
        {440}let ss_22: symmetricstate = (if v_154 then 1-proj-2-tuple(v_153) else caught-fail) in
        {443}let v_155: bitstring = (if v_154 then catch-fail(symmetricstateunpack(ss_22)) else caught-fail) in
        {444}let v_156: bool = (not-caught-fail(v_155) && success?(1-proj-3-tuple(v_155))) in
        {445}let h_20: bitstring = (if v_156 then 3-proj-3-tuple(v_155) else caught-fail) in
        {446}let ck_24: key = (if v_156 then 2-proj-3-tuple(v_155) else caught-fail) in
        {447}let cs_20: cipherstate = (if v_156 then 1-proj-3-tuple(v_155) else caught-fail) in
        {448}let input_key_material_4: key = (if v_156 then zero else caught-fail) in
        {451}let output3_4: key = (if v_156 then hmac_hash3(ck_24,input_key_material_4) else caught-fail) in
        {450}let output2_4: key = (if v_156 then hmac_hash2(ck_24,input_key_material_4) else caught-fail) in
        {449}let output1_4: key = (if v_156 then hmac_hash1(ck_24,input_key_material_4) else caught-fail) in
        {452}let v_157: bitstring = (if v_156 then catch-fail((output1_4,output2_4,output3_4)) else caught-fail) in
        {453}let v_158: bool = (not-caught-fail(v_157) && success?(1-proj-3-tuple(v_157))) in
        {454}let temp_k3: key = (if v_158 then 3-proj-3-tuple(v_157) else caught-fail) in
        {455}let temp_k2: key = (if v_158 then 2-proj-3-tuple(v_157) else caught-fail) in
        {456}let temp_k1: key = (if v_158 then 1-proj-3-tuple(v_157) else caught-fail) in
        {458}let cs2: cipherstate = (if v_158 then cipherstatepack(temp_k2,minnonce) else caught-fail) in
        {457}let cs1: cipherstate = (if v_158 then cipherstatepack(temp_k1,minnonce) else caught-fail) in
        {459}let v_159: bitstring = (if v_154 then catch-fail((if v_156 then (if v_158 then (ss_22,cs1,cs2) else fail-any) else fail-any)) else caught-fail) in
        {460}let v_160: bool = (not-caught-fail(v_159) && success?(1-proj-3-tuple(v_159))) in
        {461}let cs2_1: cipherstate = (if v_160 then 3-proj-3-tuple(v_159) else caught-fail) in
        {462}let cs1_1: cipherstate = (if v_160 then 2-proj-3-tuple(v_159) else caught-fail) in
        {463}let ssi_6: symmetricstate = (if v_160 then 1-proj-3-tuple(v_159) else caught-fail) in
        {442}let message_buffer_1: bitstring = (if v_154 then concat3(ne_5,nm_2,ciphertext_7) else caught-fail) in
        {441}let hs_8: handshakestate = (if v_154 then handshakestatepack(ss_22,s_3,m_4,e_5,rs_4,rm_4,re_4,psk_3,initiator_3) else caught-fail) in
        {464}let (hs_9: handshakestate,message_c: bitstring,cs1_2: cipherstate,cs2_2: cipherstate) = (if v_113 then (if v_115 then (if v_117 then (if v_132 then (if v_140 then (if v_154 then (if v_160 then (hs_8,message_buffer_1,cs1_1,cs2_1) else fail-any) else fail-any) else fail-any) else fail-any) else fail-any) else fail-any) else fail-any) in
        {465}event SendMsg(me,them,stagepack_c(sid_1),msg_c(me,them,sid_1));
        {466}insert statestore(me,them,sid_1,statepack_d(hs_9,cs1_2,cs2_2));
        {467}out(pub, message_c)
    ) | (
        {469}!
        {535}get statestore(=me,=them,=sid_1,statepack_d(hs_10: handshakestate,cs1_3: cipherstate,cs2_3: cipherstate)) in
        {470}let hs_11: handshakestate = handshakestatesetcs(hs_10,cs2_3) in
        {471}in(pub, message_d: bitstring);
        {472}let v_161: bitstring = catch-fail(handshakestateunpack(hs_11)) in
        {473}let v_162: bool = (not-caught-fail(v_161) && success?(1-proj-9-tuple(v_161))) in
        {474}let initiator_4: bool = (if v_162 then 9-proj-9-tuple(v_161) else caught-fail) in
        {475}let psk_4: key = (if v_162 then 8-proj-9-tuple(v_161) else caught-fail) in
        {476}let re_5: key = (if v_162 then 7-proj-9-tuple(v_161) else caught-fail) in
        {477}let rm_5: key = (if v_162 then 6-proj-9-tuple(v_161) else caught-fail) in
        {478}let rs_5: key = (if v_162 then 5-proj-9-tuple(v_161) else caught-fail) in
        {479}let e_8: keypair = (if v_162 then 4-proj-9-tuple(v_161) else caught-fail) in
        {480}let m_5: keypair = (if v_162 then 3-proj-9-tuple(v_161) else caught-fail) in
        {481}let s_4: keypair = (if v_162 then 2-proj-9-tuple(v_161) else caught-fail) in
        {482}let ss_23: symmetricstate = (if v_162 then 1-proj-9-tuple(v_161) else caught-fail) in
        {483}let v_163: bitstring = (if v_162 then catch-fail(deconcat3(message_d)) else caught-fail) in
        {484}let v_164: bool = (not-caught-fail(v_163) && success?(1-proj-3-tuple(v_163))) in
        {485}let ciphertext_8: bitstring = (if v_164 then 3-proj-3-tuple(v_163) else caught-fail) in
        {486}let ns_3: bitstring = (if v_164 then 2-proj-3-tuple(v_163) else caught-fail) in
        {487}let ne_6: bitstring = (if v_164 then 1-proj-3-tuple(v_163) else caught-fail) in
        {489}let v_165: bitstring = (if v_164 then catch-fail(symmetricstateunpack(ss_23)) else caught-fail) in
        {490}let v_166: bool = (not-caught-fail(v_165) && success?(1-proj-3-tuple(v_165))) in
        {491}let h_21: bitstring = (if v_166 then 3-proj-3-tuple(v_165) else caught-fail) in
        {492}let ck_25: key = (if v_166 then 2-proj-3-tuple(v_165) else caught-fail) in
        {493}let cs_21: cipherstate = (if v_166 then 1-proj-3-tuple(v_165) else caught-fail) in
        {494}let v_167: bitstring = (if v_166 then catch-fail(cipherstateunpack(cs_21)) else caught-fail) in
        {495}let v_168: bool = (not-caught-fail(v_167) && success?(1-proj-2-tuple(v_167))) in
        {496}let n_12: nonce = (if v_168 then 2-proj-2-tuple(v_167) else caught-fail) in
        {497}let k_13: key = (if v_168 then 1-proj-2-tuple(v_167) else caught-fail) in
        {498}let d_3: aead = (if v_168 then catch-fail(decrypt(k_13,n_12,h_21,ciphertext_8)) else caught-fail) in
        {499}let v_169: bool = not-caught-fail(d_3) in
        {500}let v_170: bitstring = (if v_169 then catch-fail(aeadunpack(d_3)) else caught-fail) in
        {501}let v_171: bool = (not-caught-fail(v_170) && success?(1-proj-3-tuple(v_170))) in
        {502}let plaintext_8: bitstring = (if v_171 then 3-proj-3-tuple(v_170) else caught-fail) in
        {503}let adi_3: bitstring = (if v_171 then 2-proj-3-tuple(v_170) else caught-fail) in
        {504}let valid_7: bool = (if v_171 then 1-proj-3-tuple(v_170) else caught-fail) in
        {506}let v_172: bitstring = (if v_171 then catch-fail(cipherstateunpack(cs_21)) else caught-fail) in
        {507}let v_173: bool = (not-caught-fail(v_172) && success?(1-proj-2-tuple(v_172))) in
        {508}let o_6: nonce = (if v_173 then 2-proj-2-tuple(v_172) else caught-fail) in
        {509}let k_14: key = (if v_173 then 1-proj-2-tuple(v_172) else caught-fail) in
        {505}let n_13: nonce = (if v_171 then increment_nonce(n_12) else caught-fail) in
        {510}let csi_12: cipherstate = (if v_171 then catch-fail((if v_173 then cipherstatepack(k_14,n_13) else fail-any)) else caught-fail) in
        {511}let v_174: bool = not-caught-fail(csi_12) in
        {512}let v_175: bitstring = (if v_166 then catch-fail((if v_168 then (if v_169 then (if v_171 then (if v_174 then (csi_12,plaintext_8,valid_7) else fail-any) else fail-any) else fail-any) else fail-any)) else caught-fail) in
        {513}let v_176: bool = (not-caught-fail(v_175) && success?(1-proj-3-tuple(v_175))) in
        {514}let valid_8: bool = (if v_176 then 3-proj-3-tuple(v_175) else caught-fail) in
        {515}let plaintext_9: bitstring = (if v_176 then 2-proj-3-tuple(v_175) else caught-fail) in
        {516}let csi_13: cipherstate = (if v_176 then 1-proj-3-tuple(v_175) else caught-fail) in
        {517}let ss_24: symmetricstate = (if v_176 then symmetricstatepack(csi_13,ck_25,h_21) else caught-fail) in
        {518}let v_177: bitstring = (if v_176 then catch-fail(symmetricstateunpack(ss_24)) else caught-fail) in
        {519}let v_178: bool = (not-caught-fail(v_177) && success?(1-proj-3-tuple(v_177))) in
        {520}let h_22: bitstring = (if v_178 then 3-proj-3-tuple(v_177) else caught-fail) in
        {521}let ck_26: key = (if v_178 then 2-proj-3-tuple(v_177) else caught-fail) in
        {522}let cs_22: cipherstate = (if v_178 then 1-proj-3-tuple(v_177) else caught-fail) in
        {523}let ssi_7: symmetricstate = (if v_176 then catch-fail((if v_178 then symmetricstatepack(cs_22,ck_26,hash(h_22,ciphertext_8)) else fail-any)) else caught-fail) in
        {524}let v_179: bool = not-caught-fail(ssi_7) in
        {525}let v_180: bitstring = (if v_164 then catch-fail((if v_166 then (if v_176 then (if v_179 then (ssi_7,plaintext_9,valid_8) else fail-any) else fail-any) else fail-any)) else caught-fail) in
        {526}let v_181: bool = (not-caught-fail(v_180) && success?(1-proj-3-tuple(v_180))) in
        {527}let valid2_1: bool = (if v_181 then 3-proj-3-tuple(v_180) else caught-fail) in
        {528}let plaintext_10: bitstring = (if v_181 then 2-proj-3-tuple(v_180) else caught-fail) in
        {529}let ss_25: symmetricstate = (if v_181 then 1-proj-3-tuple(v_180) else caught-fail) in
        {488}let valid1_2: bool = (if v_164 then true else caught-fail) in
        {530}let v_182: bool = (if v_181 then catch-fail((valid1_2 && valid2_1)) else caught-fail) in
        {531}let hs_12: handshakestate = (if v_182 then handshakestatepack(ss_25,s_4,m_5,e_8,rs_5,rm_5,re_5,psk_4,initiator_4) else caught-fail) in
        {532}let (hs_13: handshakestate,plaintext_d: bitstring,valid_9: bool) = (if v_162 then (if v_164 then (if v_181 then (if undo-catch-fail(v_182) then (hs_12,plaintext_10,true) else fail-any) else fail-any) else fail-any) else fail-any) in
        {533}event RecvMsg(me,them,stagepack_d(sid_1),plaintext_d);
        {534}insert statestore(me,them,sid_1,statepack_e(hs_13,cs1_3,handshakestategetcs(hs_13)))
    ) | (
        {536}!
        {593}get statestore(=me,=them,=sid_1,statepack_e(hs_14: handshakestate,cs1_4: cipherstate,cs2_4: cipherstate)) in
        {537}let hs_15: handshakestate = handshakestatesetcs(hs_14,cs1_4) in
        {539}let v_183: bitstring = catch-fail(handshakestateunpack(hs_15)) in
        {540}let v_184: bool = (not-caught-fail(v_183) && success?(1-proj-9-tuple(v_183))) in
        {541}let initiator_5: bool = (if v_184 then 9-proj-9-tuple(v_183) else caught-fail) in
        {542}let psk_5: key = (if v_184 then 8-proj-9-tuple(v_183) else caught-fail) in
        {543}let re_6: key = (if v_184 then 7-proj-9-tuple(v_183) else caught-fail) in
        {544}let rm_6: key = (if v_184 then 6-proj-9-tuple(v_183) else caught-fail) in
        {545}let rs_6: key = (if v_184 then 5-proj-9-tuple(v_183) else caught-fail) in
        {546}let e_9: keypair = (if v_184 then 4-proj-9-tuple(v_183) else caught-fail) in
        {547}let m_6: keypair = (if v_184 then 3-proj-9-tuple(v_183) else caught-fail) in
        {548}let s_5: keypair = (if v_184 then 2-proj-9-tuple(v_183) else caught-fail) in
        {549}let ss_26: symmetricstate = (if v_184 then 1-proj-9-tuple(v_183) else caught-fail) in
        {550}let v_185: bitstring = (if v_184 then catch-fail((empty,empty,empty)) else caught-fail) in
        {551}let v_186: bool = (not-caught-fail(v_185) && success?(1-proj-3-tuple(v_185))) in
        {552}let ciphertext_9: bitstring = (if v_186 then 3-proj-3-tuple(v_185) else caught-fail) in
        {553}let ns_4: bitstring = (if v_186 then 2-proj-3-tuple(v_185) else caught-fail) in
        {554}let ne_7: bitstring = (if v_186 then 1-proj-3-tuple(v_185) else caught-fail) in
        {555}let v_187: bitstring = (if v_186 then catch-fail(symmetricstateunpack(ss_26)) else caught-fail) in
        {556}let v_188: bool = (not-caught-fail(v_187) && success?(1-proj-3-tuple(v_187))) in
        {557}let h_23: bitstring = (if v_188 then 3-proj-3-tuple(v_187) else caught-fail) in
        {558}let ck_27: key = (if v_188 then 2-proj-3-tuple(v_187) else caught-fail) in
        {559}let cs_23: cipherstate = (if v_188 then 1-proj-3-tuple(v_187) else caught-fail) in
        {560}let v_189: bitstring = (if v_188 then catch-fail(cipherstateunpack(cs_23)) else caught-fail) in
        {561}let v_190: bool = (not-caught-fail(v_189) && success?(1-proj-2-tuple(v_189))) in
        {562}let n_14: nonce = (if v_190 then 2-proj-2-tuple(v_189) else caught-fail) in
        {563}let k_15: key = (if v_190 then 1-proj-2-tuple(v_189) else caught-fail) in
        {566}let v_191: bitstring = (if v_190 then catch-fail(cipherstateunpack(cs_23)) else caught-fail) in
        {567}let v_192: bool = (not-caught-fail(v_191) && success?(1-proj-2-tuple(v_191))) in
        {568}let o_7: nonce = (if v_192 then 2-proj-2-tuple(v_191) else caught-fail) in
        {569}let k_16: key = (if v_192 then 1-proj-2-tuple(v_191) else caught-fail) in
        {565}let n_15: nonce = (if v_190 then increment_nonce(n_14) else caught-fail) in
        {570}let csi_14: cipherstate = (if v_190 then catch-fail((if v_192 then cipherstatepack(k_16,n_15) else fail-any)) else caught-fail) in
        {571}let v_193: bool = not-caught-fail(csi_14) in
        {538}let payload_2: bitstring = msg_e(me,them,sid_1) in
        {564}let e_10: bitstring = (if v_190 then encrypt(k_15,n_14,h_23,payload_2) else caught-fail) in
        {572}let v_194: bitstring = (if v_188 then catch-fail((if v_190 then (if v_193 then (csi_14,e_10) else fail-any) else fail-any)) else caught-fail) in
        {573}let v_195: bool = (not-caught-fail(v_194) && success?(1-proj-2-tuple(v_194))) in
        {574}let ciphertext_10: bitstring = (if v_195 then 2-proj-2-tuple(v_194) else caught-fail) in
        {575}let csi_15: cipherstate = (if v_195 then 1-proj-2-tuple(v_194) else caught-fail) in
        {576}let ss_27: symmetricstate = (if v_195 then symmetricstatepack(csi_15,ck_27,h_23) else caught-fail) in
        {577}let v_196: bitstring = (if v_195 then catch-fail(symmetricstateunpack(ss_27)) else caught-fail) in
        {578}let v_197: bool = (not-caught-fail(v_196) && success?(1-proj-3-tuple(v_196))) in
        {579}let h_24: bitstring = (if v_197 then 3-proj-3-tuple(v_196) else caught-fail) in
        {580}let ck_28: key = (if v_197 then 2-proj-3-tuple(v_196) else caught-fail) in
        {581}let cs_24: cipherstate = (if v_197 then 1-proj-3-tuple(v_196) else caught-fail) in
        {582}let ssi_8: symmetricstate = (if v_195 then catch-fail((if v_197 then symmetricstatepack(cs_24,ck_28,hash(h_24,ciphertext_10)) else fail-any)) else caught-fail) in
        {583}let v_198: bool = not-caught-fail(ssi_8) in
        {584}let v_199: bitstring = (if v_186 then catch-fail((if v_188 then (if v_195 then (if v_198 then (ssi_8,ciphertext_10) else fail-any) else fail-any) else fail-any)) else caught-fail) in
        {585}let v_200: bool = (not-caught-fail(v_199) && success?(1-proj-2-tuple(v_199))) in
        {586}let ciphertext_11: bitstring = (if v_200 then 2-proj-2-tuple(v_199) else caught-fail) in
        {587}let ss_28: symmetricstate = (if v_200 then 1-proj-2-tuple(v_199) else caught-fail) in
        {589}let message_buffer_2: bitstring = (if v_200 then concat3(ne_7,ns_4,ciphertext_11) else caught-fail) in
        {588}let hs_16: handshakestate = (if v_200 then handshakestatepack(ss_28,s_5,m_6,e_9,rs_6,rm_6,re_6,psk_5,initiator_5) else caught-fail) in
        {590}let (hs_17: handshakestate,message_e: bitstring) = (if v_184 then (if v_186 then (if v_200 then (hs_16,message_buffer_2) else fail-any) else fail-any) else fail-any) in
        {591}event SendMsg(me,them,stagepack_e(sid_1),msg_e(me,them,sid_1));
        {592}out(pub, message_e)
    ) | (
        {594}event LeakS(phase0,me);
        {595}event LeakM(phase0,me);
        {596}out(pub, (key_s(me),key_m(me)))
    ) | (
        {597}phase 1;
        {598}event LeakS(phase1,me);
        {599}event LeakM(phase1,me);
        {600}out(pub, (key_s(me),key_m(me)))
    )
) | (
    {605}let m_7: keypair = keypairpack(empty,empty) in
    {604}let s_6: keypair = keypairpack(empty,empty) in
    {606}out(pub, (getpublickey(s_6),getpublickey(m_7)));
    {603}let sid_2: sessionid = sid in
    {602}let them_1: principal = charlie in
    {601}let me_1: principal = alice in
    (
        {616}let k_17: key = empty in
        {617}let cs_25: cipherstate = cipherstatepack(k_17,minnonce) in
        {613}let protocol_name_1: bitstring = somename in
        {614}let h_25: bitstring = hash(protocol_name_1,empty) in
        {615}let ck_29: key = h_25 in
        {618}let ss_29: symmetricstate = symmetricstatepack(cs_25,ck_29,h_25) in
        {619}let v_201: bitstring = catch-fail(symmetricstateunpack(ss_29)) in
        {620}let v_202: bool = (not-caught-fail(v_201) && success?(1-proj-3-tuple(v_201))) in
        {621}let h_26: bitstring = (if v_202 then 3-proj-3-tuple(v_201) else caught-fail) in
        {622}let ck_30: key = (if v_202 then 2-proj-3-tuple(v_201) else caught-fail) in
        {623}let cs_26: cipherstate = (if v_202 then 1-proj-3-tuple(v_201) else caught-fail) in
        {611}let prologue_1: bitstring = empty in
        {624}let ss_30: symmetricstate = catch-fail((if v_202 then symmetricstatepack(cs_26,ck_30,hash(h_26,prologue_1)) else fail-any)) in
        {625}let v_203: bool = not-caught-fail(ss_30) in
        {612}let psk_6: key = empty in
        {610}let re_7: key = empty in
        {609}let rm_7: key = empty in
        {608}let rs_7: key = empty in
        {607}let e_11: keypair = keypairpack(empty,empty) in
        {626}let hs_18: handshakestate = (if v_203 then handshakestatepack(ss_30,s_6,m_7,e_11,rs_7,rm_7,re_7,psk_6,true) else fail-any) in
        {627}insert statestore(me_1,them_1,sid_2,statepack_a(hs_18))
    ) | (
        {698}get statestore(=me_1,=them_1,=sid_2,statepack_a(hs_19: handshakestate)) in
        {629}let v_204: bitstring = catch-fail(handshakestateunpack(hs_19)) in
        {630}let v_205: bool = (not-caught-fail(v_204) && success?(1-proj-9-tuple(v_204))) in
        {631}let initiator_6: bool = (if v_205 then 9-proj-9-tuple(v_204) else caught-fail) in
        {632}let psk_7: key = (if v_205 then 8-proj-9-tuple(v_204) else caught-fail) in
        {633}let re_8: key = (if v_205 then 7-proj-9-tuple(v_204) else caught-fail) in
        {634}let rm_8: key = (if v_205 then 6-proj-9-tuple(v_204) else caught-fail) in
        {635}let rs_8: key = (if v_205 then 5-proj-9-tuple(v_204) else caught-fail) in
        {636}let e_12: keypair = (if v_205 then 4-proj-9-tuple(v_204) else caught-fail) in
        {637}let m_8: keypair = (if v_205 then 3-proj-9-tuple(v_204) else caught-fail) in
        {638}let s_7: keypair = (if v_205 then 2-proj-9-tuple(v_204) else caught-fail) in
        {639}let ss_31: symmetricstate = (if v_205 then 1-proj-9-tuple(v_204) else caught-fail) in
        {640}let v_206: bitstring = (if v_205 then catch-fail((empty,empty,empty)) else caught-fail) in
        {641}let v_207: bool = (not-caught-fail(v_206) && success?(1-proj-3-tuple(v_206))) in
        {642}let ciphertext_12: bitstring = (if v_207 then 3-proj-3-tuple(v_206) else caught-fail) in
        {643}let ns_5: bitstring = (if v_207 then 2-proj-3-tuple(v_206) else caught-fail) in
        {644}let ne_8: bitstring = (if v_207 then 1-proj-3-tuple(v_206) else caught-fail) in
        {645}let basis_4: key = (if v_207 then key_e(me_1,them_1,sid_2) else caught-fail) in
        {646}let public_key_4: key = (if v_207 then catch-fail(dhexp(basis_4,validkey(g))) else caught-fail) in
        {647}let v_208: bool = not-caught-fail(public_key_4) in
        {648}let e_13: keypair = (if v_207 then catch-fail((if v_208 then keypairpack(validkey(public_key_4),basis_4) else fail-any)) else caught-fail) in
        {649}let v_209: bool = not-caught-fail(e_13) in
        {650}let ne_9: bitstring = (if v_209 then catch-fail(getpublickey(e_13)) else caught-fail) in
        {651}let v_210: bool = not-caught-fail(ne_9) in
        {652}let v_211: bitstring = (if v_210 then catch-fail(symmetricstateunpack(ss_31)) else caught-fail) in
        {653}let v_212: bool = (not-caught-fail(v_211) && success?(1-proj-3-tuple(v_211))) in
        {654}let h_27: bitstring = (if v_212 then 3-proj-3-tuple(v_211) else caught-fail) in
        {655}let ck_31: key = (if v_212 then 2-proj-3-tuple(v_211) else caught-fail) in
        {656}let cs_27: cipherstate = (if v_212 then 1-proj-3-tuple(v_211) else caught-fail) in
        {657}let ss_32: symmetricstate = (if v_210 then catch-fail((if v_212 then symmetricstatepack(cs_27,ck_31,hash(h_27,ne_9)) else fail-any)) else caught-fail) in
        {658}let v_213: bool = not-caught-fail(ss_32) in
        {659}let v_214: bitstring = (if v_213 then catch-fail(symmetricstateunpack(ss_32)) else caught-fail) in
        {660}let v_215: bool = (not-caught-fail(v_214) && success?(1-proj-3-tuple(v_214))) in
        {661}let h_28: bitstring = (if v_215 then 3-proj-3-tuple(v_214) else caught-fail) in
        {662}let ck_32: key = (if v_215 then 2-proj-3-tuple(v_214) else caught-fail) in
        {663}let cs_28: cipherstate = (if v_215 then 1-proj-3-tuple(v_214) else caught-fail) in
        {664}let v_216: bitstring = (if v_215 then catch-fail(cipherstateunpack(cs_28)) else caught-fail) in
        {665}let v_217: bool = (not-caught-fail(v_216) && success?(1-proj-2-tuple(v_216))) in
        {666}let n_16: nonce = (if v_217 then 2-proj-2-tuple(v_216) else caught-fail) in
        {667}let k_18: key = (if v_217 then 1-proj-2-tuple(v_216) else caught-fail) in
        {670}let v_218: bitstring = (if v_217 then catch-fail(cipherstateunpack(cs_28)) else caught-fail) in
        {671}let v_219: bool = (not-caught-fail(v_218) && success?(1-proj-2-tuple(v_218))) in
        {672}let o_8: nonce = (if v_219 then 2-proj-2-tuple(v_218) else caught-fail) in
        {673}let k_19: key = (if v_219 then 1-proj-2-tuple(v_218) else caught-fail) in
        {669}let n_17: nonce = (if v_217 then increment_nonce(n_16) else caught-fail) in
        {674}let csi_16: cipherstate = (if v_217 then catch-fail((if v_219 then cipherstatepack(k_19,n_17) else fail-any)) else caught-fail) in
        {675}let v_220: bool = not-caught-fail(csi_16) in
        {628}let payload_3: bitstring = msg_a(me_1,them_1,sid_2) in
        {668}let e_14: bitstring = (if v_217 then encrypt(k_18,n_16,h_28,payload_3) else caught-fail) in
        {676}let v_221: bitstring = (if v_215 then catch-fail((if v_217 then (if v_220 then (csi_16,e_14) else fail-any) else fail-any)) else caught-fail) in
        {677}let v_222: bool = (not-caught-fail(v_221) && success?(1-proj-2-tuple(v_221))) in
        {678}let ciphertext_13: bitstring = (if v_222 then 2-proj-2-tuple(v_221) else caught-fail) in
        {679}let csi_17: cipherstate = (if v_222 then 1-proj-2-tuple(v_221) else caught-fail) in
        {680}let ss_33: symmetricstate = (if v_222 then symmetricstatepack(csi_17,ck_32,h_28) else caught-fail) in
        {681}let v_223: bitstring = (if v_222 then catch-fail(symmetricstateunpack(ss_33)) else caught-fail) in
        {682}let v_224: bool = (not-caught-fail(v_223) && success?(1-proj-3-tuple(v_223))) in
        {683}let h_29: bitstring = (if v_224 then 3-proj-3-tuple(v_223) else caught-fail) in
        {684}let ck_33: key = (if v_224 then 2-proj-3-tuple(v_223) else caught-fail) in
        {685}let cs_29: cipherstate = (if v_224 then 1-proj-3-tuple(v_223) else caught-fail) in
        {686}let ssi_9: symmetricstate = (if v_222 then catch-fail((if v_224 then symmetricstatepack(cs_29,ck_33,hash(h_29,ciphertext_13)) else fail-any)) else caught-fail) in
        {687}let v_225: bool = not-caught-fail(ssi_9) in
        {688}let v_226: bitstring = (if v_213 then catch-fail((if v_215 then (if v_222 then (if v_225 then (ssi_9,ciphertext_13) else fail-any) else fail-any) else fail-any)) else caught-fail) in
        {689}let v_227: bool = (not-caught-fail(v_226) && success?(1-proj-2-tuple(v_226))) in
        {690}let ciphertext_14: bitstring = (if v_227 then 2-proj-2-tuple(v_226) else caught-fail) in
        {691}let ss_34: symmetricstate = (if v_227 then 1-proj-2-tuple(v_226) else caught-fail) in
        {693}let message_buffer_3: bitstring = (if v_227 then concat3(ne_9,ns_5,ciphertext_14) else caught-fail) in
        {692}let hs_20: handshakestate = (if v_227 then handshakestatepack(ss_34,s_7,m_8,e_13,rs_8,rm_8,re_8,psk_7,initiator_6) else caught-fail) in
        {694}let (hs_21: handshakestate,message_a_1: bitstring) = (if v_205 then (if v_207 then (if v_209 then (if v_210 then (if v_213 then (if v_227 then (hs_20,message_buffer_3) else fail-any) else fail-any) else fail-any) else fail-any) else fail-any) else fail-any) in
        {695}event SendMsg(me_1,them_1,stagepack_a(sid_2),msg_a(me_1,them_1,sid_2));
        {696}insert statestore(me_1,them_1,sid_2,statepack_b(hs_21));
        {697}out(pub, message_a_1)
    ) | (
        {925}get statestore(=me_1,=them_1,=sid_2,statepack_b(hs_22: handshakestate)) in
        {699}in(pub, message_b_1: bitstring);
        {700}let v_228: bitstring = catch-fail(handshakestateunpack(hs_22)) in
        {701}let v_229: bool = (not-caught-fail(v_228) && success?(1-proj-9-tuple(v_228))) in
        {702}let initiator_7: bool = (if v_229 then 9-proj-9-tuple(v_228) else caught-fail) in
        {703}let psk_8: key = (if v_229 then 8-proj-9-tuple(v_228) else caught-fail) in
        {704}let re_9: key = (if v_229 then 7-proj-9-tuple(v_228) else caught-fail) in
        {705}let rm_9: key = (if v_229 then 6-proj-9-tuple(v_228) else caught-fail) in
        {706}let rs_9: key = (if v_229 then 5-proj-9-tuple(v_228) else caught-fail) in
        {707}let e_15: keypair = (if v_229 then 4-proj-9-tuple(v_228) else caught-fail) in
        {708}let m_9: keypair = (if v_229 then 3-proj-9-tuple(v_228) else caught-fail) in
        {709}let s_8: keypair = (if v_229 then 2-proj-9-tuple(v_228) else caught-fail) in
        {710}let ss_35: symmetricstate = (if v_229 then 1-proj-9-tuple(v_228) else caught-fail) in
        {711}let v_230: bitstring = (if v_229 then catch-fail(deconcat4(message_b_1)) else caught-fail) in
        {712}let v_231: bool = (not-caught-fail(v_230) && success?(1-proj-4-tuple(v_230))) in
        {713}let ciphertext_15: bitstring = (if v_231 then 4-proj-4-tuple(v_230) else caught-fail) in
        {714}let nm_3: bitstring = (if v_231 then 3-proj-4-tuple(v_230) else caught-fail) in
        {715}let ns_6: bitstring = (if v_231 then 2-proj-4-tuple(v_230) else caught-fail) in
        {716}let ne_10: bitstring = (if v_231 then 1-proj-4-tuple(v_230) else caught-fail) in
        {719}let v_232: bitstring = (if v_231 then catch-fail(symmetricstateunpack(ss_35)) else caught-fail) in
        {720}let v_233: bool = (not-caught-fail(v_232) && success?(1-proj-3-tuple(v_232))) in
        {721}let h_30: bitstring = (if v_233 then 3-proj-3-tuple(v_232) else caught-fail) in
        {722}let ck_34: key = (if v_233 then 2-proj-3-tuple(v_232) else caught-fail) in
        {723}let cs_30: cipherstate = (if v_233 then 1-proj-3-tuple(v_232) else caught-fail) in
        {718}let re_10: key = (if v_231 then ne_10 else caught-fail) in
        {724}let ss_36: symmetricstate = (if v_231 then catch-fail((if v_233 then symmetricstatepack(cs_30,ck_34,hash(h_30,re_10)) else fail-any)) else caught-fail) in
        {725}let v_234: bool = not-caught-fail(ss_36) in
        {726}let v_235: bitstring = (if v_234 then catch-fail(keypairunpack(e_15)) else caught-fail) in
        {727}let v_236: bool = (not-caught-fail(v_235) && success?(1-proj-2-tuple(v_235))) in
        {728}let my_private_key_4: key = (if v_236 then 2-proj-2-tuple(v_235) else caught-fail) in
        {729}let my_public_key_4: key = (if v_236 then 1-proj-2-tuple(v_235) else caught-fail) in
        {730}let input_key_material_5: key = (if v_234 then catch-fail((if v_236 then dhexp(my_private_key_4,re_10) else fail-any)) else caught-fail) in
        {731}let v_237: bool = not-caught-fail(input_key_material_5) in
        {732}let v_238: bitstring = (if v_237 then catch-fail(symmetricstateunpack(ss_36)) else caught-fail) in
        {733}let v_239: bool = (not-caught-fail(v_238) && success?(1-proj-3-tuple(v_238))) in
        {734}let h_31: bitstring = (if v_239 then 3-proj-3-tuple(v_238) else caught-fail) in
        {735}let ck_35: key = (if v_239 then 2-proj-3-tuple(v_238) else caught-fail) in
        {736}let cs_31: cipherstate = (if v_239 then 1-proj-3-tuple(v_238) else caught-fail) in
        {739}let output3_5: key = (if v_239 then hmac_hash3(ck_35,input_key_material_5) else caught-fail) in
        {738}let output2_5: key = (if v_239 then hmac_hash2(ck_35,input_key_material_5) else caught-fail) in
        {737}let output1_5: key = (if v_239 then hmac_hash1(ck_35,input_key_material_5) else caught-fail) in
        {740}let v_240: bitstring = (if v_239 then catch-fail((output1_5,output2_5,output3_5)) else caught-fail) in
        {741}let v_241: bool = (not-caught-fail(v_240) && success?(1-proj-3-tuple(v_240))) in
        {742}let output_4: key = (if v_241 then 3-proj-3-tuple(v_240) else caught-fail) in
        {743}let temp_k_4: key = (if v_241 then 2-proj-3-tuple(v_240) else caught-fail) in
        {744}let ck_36: key = (if v_241 then 1-proj-3-tuple(v_240) else caught-fail) in
        {745}let ss_37: symmetricstate = (if v_234 then catch-fail((if v_237 then (if v_239 then (if v_241 then symmetricstatepack(cipherstatepack(temp_k_4,minnonce),ck_36,h_31) else fail-any) else fail-any) else fail-any)) else caught-fail) in
        {746}let v_242: bool = not-caught-fail(ss_37) in
        {747}let v_243: bitstring = (if v_242 then catch-fail(symmetricstateunpack(ss_37)) else caught-fail) in
        {748}let v_244: bool = (not-caught-fail(v_243) && success?(1-proj-3-tuple(v_243))) in
        {749}let h_32: bitstring = (if v_244 then 3-proj-3-tuple(v_243) else caught-fail) in
        {750}let ck_37: key = (if v_244 then 2-proj-3-tuple(v_243) else caught-fail) in
        {751}let cs_32: cipherstate = (if v_244 then 1-proj-3-tuple(v_243) else caught-fail) in
        {752}let v_245: bitstring = (if v_244 then catch-fail(cipherstateunpack(cs_32)) else caught-fail) in
        {753}let v_246: bool = (not-caught-fail(v_245) && success?(1-proj-2-tuple(v_245))) in
        {754}let n_18: nonce = (if v_246 then 2-proj-2-tuple(v_245) else caught-fail) in
        {755}let k_20: key = (if v_246 then 1-proj-2-tuple(v_245) else caught-fail) in
        {756}let d_4: aead = (if v_246 then catch-fail(decrypt(k_20,n_18,h_32,ns_6)) else caught-fail) in
        {757}let v_247: bool = not-caught-fail(d_4) in
        {758}let v_248: bitstring = (if v_247 then catch-fail(aeadunpack(d_4)) else caught-fail) in
        {759}let v_249: bool = (not-caught-fail(v_248) && success?(1-proj-3-tuple(v_248))) in
        {760}let plaintext_11: bitstring = (if v_249 then 3-proj-3-tuple(v_248) else caught-fail) in
        {761}let adi_4: bitstring = (if v_249 then 2-proj-3-tuple(v_248) else caught-fail) in
        {762}let valid_10: bool = (if v_249 then 1-proj-3-tuple(v_248) else caught-fail) in
        {764}let v_250: bitstring = (if v_249 then catch-fail(cipherstateunpack(cs_32)) else caught-fail) in
        {765}let v_251: bool = (not-caught-fail(v_250) && success?(1-proj-2-tuple(v_250))) in
        {766}let o_9: nonce = (if v_251 then 2-proj-2-tuple(v_250) else caught-fail) in
        {767}let k_21: key = (if v_251 then 1-proj-2-tuple(v_250) else caught-fail) in
        {763}let n_19: nonce = (if v_249 then increment_nonce(n_18) else caught-fail) in
        {768}let csi_18: cipherstate = (if v_249 then catch-fail((if v_251 then cipherstatepack(k_21,n_19) else fail-any)) else caught-fail) in
        {769}let v_252: bool = not-caught-fail(csi_18) in
        {770}let v_253: bitstring = (if v_244 then catch-fail((if v_246 then (if v_247 then (if v_249 then (if v_252 then (csi_18,plaintext_11,valid_10) else fail-any) else fail-any) else fail-any) else fail-any)) else caught-fail) in
        {771}let v_254: bool = (not-caught-fail(v_253) && success?(1-proj-3-tuple(v_253))) in
        {772}let valid_11: bool = (if v_254 then 3-proj-3-tuple(v_253) else caught-fail) in
        {773}let plaintext_12: bitstring = (if v_254 then 2-proj-3-tuple(v_253) else caught-fail) in
        {774}let csi_19: cipherstate = (if v_254 then 1-proj-3-tuple(v_253) else caught-fail) in
        {775}let ss_38: symmetricstate = (if v_254 then symmetricstatepack(csi_19,ck_37,h_32) else caught-fail) in
        {776}let v_255: bitstring = (if v_254 then catch-fail(symmetricstateunpack(ss_38)) else caught-fail) in
        {777}let v_256: bool = (not-caught-fail(v_255) && success?(1-proj-3-tuple(v_255))) in
        {778}let h_33: bitstring = (if v_256 then 3-proj-3-tuple(v_255) else caught-fail) in
        {779}let ck_38: key = (if v_256 then 2-proj-3-tuple(v_255) else caught-fail) in
        {780}let cs_33: cipherstate = (if v_256 then 1-proj-3-tuple(v_255) else caught-fail) in
        {781}let ssi_10: symmetricstate = (if v_254 then catch-fail((if v_256 then symmetricstatepack(cs_33,ck_38,hash(h_33,ns_6)) else fail-any)) else caught-fail) in
        {782}let v_257: bool = not-caught-fail(ssi_10) in
        {783}let v_258: bitstring = (if v_242 then catch-fail((if v_244 then (if v_254 then (if v_257 then (ssi_10,plaintext_12,valid_11) else fail-any) else fail-any) else fail-any)) else caught-fail) in
        {784}let v_259: bool = (not-caught-fail(v_258) && success?(1-proj-3-tuple(v_258))) in
        {785}let valid1_4: bool = (if v_259 then 3-proj-3-tuple(v_258) else caught-fail) in
        {786}let ne_11: bitstring = (if v_259 then 2-proj-3-tuple(v_258) else caught-fail) in
        {787}let ss_39: symmetricstate = (if v_259 then 1-proj-3-tuple(v_258) else caught-fail) in
        {789}let v_260: bitstring = (if v_259 then catch-fail(symmetricstateunpack(ss_39)) else caught-fail) in
        {790}let v_261: bool = (not-caught-fail(v_260) && success?(1-proj-3-tuple(v_260))) in
        {791}let h_34: bitstring = (if v_261 then 3-proj-3-tuple(v_260) else caught-fail) in
        {792}let ck_39: key = (if v_261 then 2-proj-3-tuple(v_260) else caught-fail) in
        {793}let cs_34: cipherstate = (if v_261 then 1-proj-3-tuple(v_260) else caught-fail) in
        {794}let v_262: bitstring = (if v_261 then catch-fail(cipherstateunpack(cs_34)) else caught-fail) in
        {795}let v_263: bool = (not-caught-fail(v_262) && success?(1-proj-2-tuple(v_262))) in
        {796}let n_20: nonce = (if v_263 then 2-proj-2-tuple(v_262) else caught-fail) in
        {797}let k_22: key = (if v_263 then 1-proj-2-tuple(v_262) else caught-fail) in
        {798}let d_5: aead = (if v_263 then catch-fail(decrypt(k_22,n_20,h_34,nm_3)) else caught-fail) in
        {799}let v_264: bool = not-caught-fail(d_5) in
        {800}let v_265: bitstring = (if v_264 then catch-fail(aeadunpack(d_5)) else caught-fail) in
        {801}let v_266: bool = (not-caught-fail(v_265) && success?(1-proj-3-tuple(v_265))) in
        {802}let plaintext_13: bitstring = (if v_266 then 3-proj-3-tuple(v_265) else caught-fail) in
        {803}let adi_5: bitstring = (if v_266 then 2-proj-3-tuple(v_265) else caught-fail) in
        {804}let valid_12: bool = (if v_266 then 1-proj-3-tuple(v_265) else caught-fail) in
        {806}let v_267: bitstring = (if v_266 then catch-fail(cipherstateunpack(cs_34)) else caught-fail) in
        {807}let v_268: bool = (not-caught-fail(v_267) && success?(1-proj-2-tuple(v_267))) in
        {808}let o_10: nonce = (if v_268 then 2-proj-2-tuple(v_267) else caught-fail) in
        {809}let k_23: key = (if v_268 then 1-proj-2-tuple(v_267) else caught-fail) in
        {805}let n_21: nonce = (if v_266 then increment_nonce(n_20) else caught-fail) in
        {810}let csi_20: cipherstate = (if v_266 then catch-fail((if v_268 then cipherstatepack(k_23,n_21) else fail-any)) else caught-fail) in
        {811}let v_269: bool = not-caught-fail(csi_20) in
        {812}let v_270: bitstring = (if v_261 then catch-fail((if v_263 then (if v_264 then (if v_266 then (if v_269 then (csi_20,plaintext_13,valid_12) else fail-any) else fail-any) else fail-any) else fail-any)) else caught-fail) in
        {813}let v_271: bool = (not-caught-fail(v_270) && success?(1-proj-3-tuple(v_270))) in
        {814}let valid_13: bool = (if v_271 then 3-proj-3-tuple(v_270) else caught-fail) in
        {815}let plaintext_14: bitstring = (if v_271 then 2-proj-3-tuple(v_270) else caught-fail) in
        {816}let csi_21: cipherstate = (if v_271 then 1-proj-3-tuple(v_270) else caught-fail) in
        {817}let ss_40: symmetricstate = (if v_271 then symmetricstatepack(csi_21,ck_39,h_34) else caught-fail) in
        {818}let v_272: bitstring = (if v_271 then catch-fail(symmetricstateunpack(ss_40)) else caught-fail) in
        {819}let v_273: bool = (not-caught-fail(v_272) && success?(1-proj-3-tuple(v_272))) in
        {820}let h_35: bitstring = (if v_273 then 3-proj-3-tuple(v_272) else caught-fail) in
        {821}let ck_40: key = (if v_273 then 2-proj-3-tuple(v_272) else caught-fail) in
        {822}let cs_35: cipherstate = (if v_273 then 1-proj-3-tuple(v_272) else caught-fail) in
        {823}let ssi_11: symmetricstate = (if v_271 then catch-fail((if v_273 then symmetricstatepack(cs_35,ck_40,hash(h_35,nm_3)) else fail-any)) else caught-fail) in
        {824}let v_274: bool = not-caught-fail(ssi_11) in
        {825}let v_275: bitstring = (if v_259 then catch-fail((if v_261 then (if v_271 then (if v_274 then (ssi_11,plaintext_14,valid_13) else fail-any) else fail-any) else fail-any)) else caught-fail) in
        {826}let v_276: bool = (not-caught-fail(v_275) && success?(1-proj-3-tuple(v_275))) in
        {827}let valid2_2: bool = (if v_276 then 3-proj-3-tuple(v_275) else caught-fail) in
        {828}let ne_12: bitstring = (if v_276 then 2-proj-3-tuple(v_275) else caught-fail) in
        {829}let ss_41: symmetricstate = (if v_276 then 1-proj-3-tuple(v_275) else caught-fail) in
        {831}let v_277: bitstring = (if v_276 then catch-fail(keypairunpack(e_15)) else caught-fail) in
        {832}let v_278: bool = (not-caught-fail(v_277) && success?(1-proj-2-tuple(v_277))) in
        {833}let my_private_key_5: key = (if v_278 then 2-proj-2-tuple(v_277) else caught-fail) in
        {834}let my_public_key_5: key = (if v_278 then 1-proj-2-tuple(v_277) else caught-fail) in
        {788}let rs_10: key = (if v_259 then ne_11 else caught-fail) in
        {835}let input_key_material_6: key = (if v_276 then catch-fail((if v_278 then dhexp(my_private_key_5,rs_10) else fail-any)) else caught-fail) in
        {836}let v_279: bool = not-caught-fail(input_key_material_6) in
        {837}let v_280: bitstring = (if v_279 then catch-fail(symmetricstateunpack(ss_41)) else caught-fail) in
        {838}let v_281: bool = (not-caught-fail(v_280) && success?(1-proj-3-tuple(v_280))) in
        {839}let h_36: bitstring = (if v_281 then 3-proj-3-tuple(v_280) else caught-fail) in
        {840}let ck_41: key = (if v_281 then 2-proj-3-tuple(v_280) else caught-fail) in
        {841}let cs_36: cipherstate = (if v_281 then 1-proj-3-tuple(v_280) else caught-fail) in
        {844}let output3_6: key = (if v_281 then hmac_hash3(ck_41,input_key_material_6) else caught-fail) in
        {843}let output2_6: key = (if v_281 then hmac_hash2(ck_41,input_key_material_6) else caught-fail) in
        {842}let output1_6: key = (if v_281 then hmac_hash1(ck_41,input_key_material_6) else caught-fail) in
        {845}let v_282: bitstring = (if v_281 then catch-fail((output1_6,output2_6,output3_6)) else caught-fail) in
        {846}let v_283: bool = (not-caught-fail(v_282) && success?(1-proj-3-tuple(v_282))) in
        {847}let output_5: key = (if v_283 then 3-proj-3-tuple(v_282) else caught-fail) in
        {848}let temp_k_5: key = (if v_283 then 2-proj-3-tuple(v_282) else caught-fail) in
        {849}let ck_42: key = (if v_283 then 1-proj-3-tuple(v_282) else caught-fail) in
        {850}let ss_42: symmetricstate = (if v_276 then catch-fail((if v_279 then (if v_281 then (if v_283 then symmetricstatepack(cipherstatepack(temp_k_5,minnonce),ck_42,h_36) else fail-any) else fail-any) else fail-any)) else caught-fail) in
        {851}let v_284: bool = not-caught-fail(ss_42) in
        {852}let v_285: bitstring = (if v_284 then catch-fail(keypairunpack(e_15)) else caught-fail) in
        {853}let v_286: bool = (not-caught-fail(v_285) && success?(1-proj-2-tuple(v_285))) in
        {854}let my_private_key_6: key = (if v_286 then 2-proj-2-tuple(v_285) else caught-fail) in
        {855}let my_public_key_6: key = (if v_286 then 1-proj-2-tuple(v_285) else caught-fail) in
        {830}let rm_10: key = (if v_276 then ne_12 else caught-fail) in
        {856}let input_key_material_7: key = (if v_284 then catch-fail((if v_286 then dhexp(my_private_key_6,rm_10) else fail-any)) else caught-fail) in
        {857}let v_287: bool = not-caught-fail(input_key_material_7) in
        {858}let v_288: bitstring = (if v_287 then catch-fail(symmetricstateunpack(ss_42)) else caught-fail) in
        {859}let v_289: bool = (not-caught-fail(v_288) && success?(1-proj-3-tuple(v_288))) in
        {860}let h_37: bitstring = (if v_289 then 3-proj-3-tuple(v_288) else caught-fail) in
        {861}let ck_43: key = (if v_289 then 2-proj-3-tuple(v_288) else caught-fail) in
        {862}let cs_37: cipherstate = (if v_289 then 1-proj-3-tuple(v_288) else caught-fail) in
        {865}let output3_7: key = (if v_289 then hmac_hash3(ck_43,input_key_material_7) else caught-fail) in
        {864}let output2_7: key = (if v_289 then hmac_hash2(ck_43,input_key_material_7) else caught-fail) in
        {863}let output1_7: key = (if v_289 then hmac_hash1(ck_43,input_key_material_7) else caught-fail) in
        {866}let v_290: bitstring = (if v_289 then catch-fail((output1_7,output2_7,output3_7)) else caught-fail) in
        {867}let v_291: bool = (not-caught-fail(v_290) && success?(1-proj-3-tuple(v_290))) in
        {868}let output_6: key = (if v_291 then 3-proj-3-tuple(v_290) else caught-fail) in
        {869}let temp_k_6: key = (if v_291 then 2-proj-3-tuple(v_290) else caught-fail) in
        {870}let ck_44: key = (if v_291 then 1-proj-3-tuple(v_290) else caught-fail) in
        {871}let ss_43: symmetricstate = (if v_284 then catch-fail((if v_287 then (if v_289 then (if v_291 then symmetricstatepack(cipherstatepack(temp_k_6,minnonce),ck_44,h_37) else fail-any) else fail-any) else fail-any)) else caught-fail) in
        {872}let v_292: bool = not-caught-fail(ss_43) in
        {873}let v_293: bitstring = (if v_292 then catch-fail(symmetricstateunpack(ss_43)) else caught-fail) in
        {874}let v_294: bool = (not-caught-fail(v_293) && success?(1-proj-3-tuple(v_293))) in
        {875}let h_38: bitstring = (if v_294 then 3-proj-3-tuple(v_293) else caught-fail) in
        {876}let ck_45: key = (if v_294 then 2-proj-3-tuple(v_293) else caught-fail) in
        {877}let cs_38: cipherstate = (if v_294 then 1-proj-3-tuple(v_293) else caught-fail) in
        {878}let v_295: bitstring = (if v_294 then catch-fail(cipherstateunpack(cs_38)) else caught-fail) in
        {879}let v_296: bool = (not-caught-fail(v_295) && success?(1-proj-2-tuple(v_295))) in
        {880}let n_22: nonce = (if v_296 then 2-proj-2-tuple(v_295) else caught-fail) in
        {881}let k_24: key = (if v_296 then 1-proj-2-tuple(v_295) else caught-fail) in
        {882}let d_6: aead = (if v_296 then catch-fail(decrypt(k_24,n_22,h_38,ciphertext_15)) else caught-fail) in
        {883}let v_297: bool = not-caught-fail(d_6) in
        {884}let v_298: bitstring = (if v_297 then catch-fail(aeadunpack(d_6)) else caught-fail) in
        {885}let v_299: bool = (not-caught-fail(v_298) && success?(1-proj-3-tuple(v_298))) in
        {886}let plaintext_15: bitstring = (if v_299 then 3-proj-3-tuple(v_298) else caught-fail) in
        {887}let adi_6: bitstring = (if v_299 then 2-proj-3-tuple(v_298) else caught-fail) in
        {888}let valid_14: bool = (if v_299 then 1-proj-3-tuple(v_298) else caught-fail) in
        {890}let v_300: bitstring = (if v_299 then catch-fail(cipherstateunpack(cs_38)) else caught-fail) in
        {891}let v_301: bool = (not-caught-fail(v_300) && success?(1-proj-2-tuple(v_300))) in
        {892}let o_11: nonce = (if v_301 then 2-proj-2-tuple(v_300) else caught-fail) in
        {893}let k_25: key = (if v_301 then 1-proj-2-tuple(v_300) else caught-fail) in
        {889}let n_23: nonce = (if v_299 then increment_nonce(n_22) else caught-fail) in
        {894}let csi_22: cipherstate = (if v_299 then catch-fail((if v_301 then cipherstatepack(k_25,n_23) else fail-any)) else caught-fail) in
        {895}let v_302: bool = not-caught-fail(csi_22) in
        {896}let v_303: bitstring = (if v_294 then catch-fail((if v_296 then (if v_297 then (if v_299 then (if v_302 then (csi_22,plaintext_15,valid_14) else fail-any) else fail-any) else fail-any) else fail-any)) else caught-fail) in
        {897}let v_304: bool = (not-caught-fail(v_303) && success?(1-proj-3-tuple(v_303))) in
        {898}let valid_15: bool = (if v_304 then 3-proj-3-tuple(v_303) else caught-fail) in
        {899}let plaintext_16: bitstring = (if v_304 then 2-proj-3-tuple(v_303) else caught-fail) in
        {900}let csi_23: cipherstate = (if v_304 then 1-proj-3-tuple(v_303) else caught-fail) in
        {901}let ss_44: symmetricstate = (if v_304 then symmetricstatepack(csi_23,ck_45,h_38) else caught-fail) in
        {902}let v_305: bitstring = (if v_304 then catch-fail(symmetricstateunpack(ss_44)) else caught-fail) in
        {903}let v_306: bool = (not-caught-fail(v_305) && success?(1-proj-3-tuple(v_305))) in
        {904}let h_39: bitstring = (if v_306 then 3-proj-3-tuple(v_305) else caught-fail) in
        {905}let ck_46: key = (if v_306 then 2-proj-3-tuple(v_305) else caught-fail) in
        {906}let cs_39: cipherstate = (if v_306 then 1-proj-3-tuple(v_305) else caught-fail) in
        {907}let ssi_12: symmetricstate = (if v_304 then catch-fail((if v_306 then symmetricstatepack(cs_39,ck_46,hash(h_39,ciphertext_15)) else fail-any)) else caught-fail) in
        {908}let v_307: bool = not-caught-fail(ssi_12) in
        {909}let v_308: bitstring = (if v_292 then catch-fail((if v_294 then (if v_304 then (if v_307 then (ssi_12,plaintext_16,valid_15) else fail-any) else fail-any) else fail-any)) else caught-fail) in
        {910}let v_309: bool = (not-caught-fail(v_308) && success?(1-proj-3-tuple(v_308))) in
        {911}let valid3_1: bool = (if v_309 then 3-proj-3-tuple(v_308) else caught-fail) in
        {912}let plaintext_17: bitstring = (if v_309 then 2-proj-3-tuple(v_308) else caught-fail) in
        {913}let ss_45: symmetricstate = (if v_309 then 1-proj-3-tuple(v_308) else caught-fail) in
        {917}let basis_6: key = (if v_309 then key_m(them_1) else caught-fail) in
        {918}let public_key_6: key = (if v_309 then catch-fail(dhexp(basis_6,validkey(g))) else caught-fail) in
        {919}let v_311: bool = not-caught-fail(public_key_6) in
        {914}let basis_5: key = (if v_309 then key_s(them_1) else caught-fail) in
        {915}let public_key_5: key = (if v_309 then catch-fail(dhexp(basis_5,validkey(g))) else caught-fail) in
        {916}let v_310: bool = not-caught-fail(public_key_5) in
        {920}let v_312: bool = (if v_309 then catch-fail(((valid1_4 && (valid2_2 && valid3_1)) && ((rs_10 = getpublickey((if v_310 then keypairpack(validkey(public_key_5),basis_5) else fail-any))) && (rm_10 = getpublickey((if v_311 then keypairpack(validkey(public_key_6),basis_6) else fail-any)))))) else caught-fail) in
        {921}let hs_23: handshakestate = (if v_312 then handshakestatepack(ss_45,s_8,m_9,e_15,rs_10,rm_10,re_10,psk_8,initiator_7) else caught-fail) in
        {922}let (hs_24: handshakestate,plaintext_b_1: bitstring,valid_16: bool) = (if v_229 then (if v_231 then (if v_234 then (if v_242 then (if v_259 then (if v_276 then (if v_284 then (if v_292 then (if v_309 then (if undo-catch-fail(v_312) then (hs_23,plaintext_17,true) else fail-any) else fail-any) else fail-any) else fail-any) else fail-any) else fail-any) else fail-any) else fail-any) else fail-any) else fail-any) in
        {923}event RecvMsg(me_1,them_1,stagepack_b(sid_2),plaintext_b_1);
        {924}insert statestore(me_1,them_1,sid_2,statepack_c(hs_24))
    ) | (
        {1065}get statestore(=me_1,=them_1,=sid_2,statepack_c(hs_25: handshakestate)) in
        {927}let v_313: bitstring = catch-fail(handshakestateunpack(hs_25)) in
        {928}let v_314: bool = (not-caught-fail(v_313) && success?(1-proj-9-tuple(v_313))) in
        {929}let initiator_8: bool = (if v_314 then 9-proj-9-tuple(v_313) else caught-fail) in
        {930}let psk_9: key = (if v_314 then 8-proj-9-tuple(v_313) else caught-fail) in
        {931}let re_11: key = (if v_314 then 7-proj-9-tuple(v_313) else caught-fail) in
        {932}let rm_11: key = (if v_314 then 6-proj-9-tuple(v_313) else caught-fail) in
        {933}let rs_11: key = (if v_314 then 5-proj-9-tuple(v_313) else caught-fail) in
        {934}let e_16: keypair = (if v_314 then 4-proj-9-tuple(v_313) else caught-fail) in
        {935}let m_10: keypair = (if v_314 then 3-proj-9-tuple(v_313) else caught-fail) in
        {936}let s_9: keypair = (if v_314 then 2-proj-9-tuple(v_313) else caught-fail) in
        {937}let ss_46: symmetricstate = (if v_314 then 1-proj-9-tuple(v_313) else caught-fail) in
        {938}let v_315: bitstring = (if v_314 then catch-fail((empty,empty,empty,empty)) else caught-fail) in
        {939}let v_316: bool = (not-caught-fail(v_315) && success?(1-proj-4-tuple(v_315))) in
        {940}let ciphertext_16: bitstring = (if v_316 then 4-proj-4-tuple(v_315) else caught-fail) in
        {941}let nm_4: bitstring = (if v_316 then 3-proj-4-tuple(v_315) else caught-fail) in
        {942}let ns_7: bitstring = (if v_316 then 2-proj-4-tuple(v_315) else caught-fail) in
        {943}let ne_13: bitstring = (if v_316 then 1-proj-4-tuple(v_315) else caught-fail) in
        {944}let basis_7: key = (if v_316 then key_m(me_1) else caught-fail) in
        {945}let public_key_7: key = (if v_316 then catch-fail(dhexp(basis_7,validkey(g))) else caught-fail) in
        {946}let v_317: bool = not-caught-fail(public_key_7) in
        {947}let m_11: keypair = (if v_316 then catch-fail((if v_317 then keypairpack(validkey(public_key_7),basis_7) else fail-any)) else caught-fail) in
        {948}let v_318: bool = not-caught-fail(m_11) in
        {949}let plaintext_18: bitstring = (if v_318 then catch-fail(getpublickey(m_11)) else caught-fail) in
        {950}let v_319: bool = not-caught-fail(plaintext_18) in
        {951}let v_320: bitstring = (if v_319 then catch-fail(symmetricstateunpack(ss_46)) else caught-fail) in
        {952}let v_321: bool = (not-caught-fail(v_320) && success?(1-proj-3-tuple(v_320))) in
        {953}let h_40: bitstring = (if v_321 then 3-proj-3-tuple(v_320) else caught-fail) in
        {954}let ck_47: key = (if v_321 then 2-proj-3-tuple(v_320) else caught-fail) in
        {955}let cs_40: cipherstate = (if v_321 then 1-proj-3-tuple(v_320) else caught-fail) in
        {956}let v_322: bitstring = (if v_321 then catch-fail(cipherstateunpack(cs_40)) else caught-fail) in
        {957}let v_323: bool = (not-caught-fail(v_322) && success?(1-proj-2-tuple(v_322))) in
        {958}let n_24: nonce = (if v_323 then 2-proj-2-tuple(v_322) else caught-fail) in
        {959}let k_26: key = (if v_323 then 1-proj-2-tuple(v_322) else caught-fail) in
        {962}let v_324: bitstring = (if v_323 then catch-fail(cipherstateunpack(cs_40)) else caught-fail) in
        {963}let v_325: bool = (not-caught-fail(v_324) && success?(1-proj-2-tuple(v_324))) in
        {964}let o_12: nonce = (if v_325 then 2-proj-2-tuple(v_324) else caught-fail) in
        {965}let k_27: key = (if v_325 then 1-proj-2-tuple(v_324) else caught-fail) in
        {961}let n_25: nonce = (if v_323 then increment_nonce(n_24) else caught-fail) in
        {966}let csi_24: cipherstate = (if v_323 then catch-fail((if v_325 then cipherstatepack(k_27,n_25) else fail-any)) else caught-fail) in
        {967}let v_326: bool = not-caught-fail(csi_24) in
        {960}let e_17: bitstring = (if v_323 then encrypt(k_26,n_24,h_40,plaintext_18) else caught-fail) in
        {968}let v_327: bitstring = (if v_321 then catch-fail((if v_323 then (if v_326 then (csi_24,e_17) else fail-any) else fail-any)) else caught-fail) in
        {969}let v_328: bool = (not-caught-fail(v_327) && success?(1-proj-2-tuple(v_327))) in
        {970}let ciphertext_17: bitstring = (if v_328 then 2-proj-2-tuple(v_327) else caught-fail) in
        {971}let csi_25: cipherstate = (if v_328 then 1-proj-2-tuple(v_327) else caught-fail) in
        {972}let ss_47: symmetricstate = (if v_328 then symmetricstatepack(csi_25,ck_47,h_40) else caught-fail) in
        {973}let v_329: bitstring = (if v_328 then catch-fail(symmetricstateunpack(ss_47)) else caught-fail) in
        {974}let v_330: bool = (not-caught-fail(v_329) && success?(1-proj-3-tuple(v_329))) in
        {975}let h_41: bitstring = (if v_330 then 3-proj-3-tuple(v_329) else caught-fail) in
        {976}let ck_48: key = (if v_330 then 2-proj-3-tuple(v_329) else caught-fail) in
        {977}let cs_41: cipherstate = (if v_330 then 1-proj-3-tuple(v_329) else caught-fail) in
        {978}let ssi_13: symmetricstate = (if v_328 then catch-fail((if v_330 then symmetricstatepack(cs_41,ck_48,hash(h_41,ciphertext_17)) else fail-any)) else caught-fail) in
        {979}let v_331: bool = not-caught-fail(ssi_13) in
        {980}let v_332: bitstring = (if v_318 then catch-fail((if v_319 then (if v_321 then (if v_328 then (if v_331 then (ssi_13,ciphertext_17) else fail-any) else fail-any) else fail-any) else fail-any)) else caught-fail) in
        {981}let v_333: bool = (not-caught-fail(v_332) && success?(1-proj-2-tuple(v_332))) in
        {982}let nm_5: bitstring = (if v_333 then 2-proj-2-tuple(v_332) else caught-fail) in
        {983}let ss_48: symmetricstate = (if v_333 then 1-proj-2-tuple(v_332) else caught-fail) in
        {984}let v_334: bitstring = (if v_333 then catch-fail(keypairunpack(m_11)) else caught-fail) in
        {985}let v_335: bool = (not-caught-fail(v_334) && success?(1-proj-2-tuple(v_334))) in
        {986}let my_private_key_7: key = (if v_335 then 2-proj-2-tuple(v_334) else caught-fail) in
        {987}let my_public_key_7: key = (if v_335 then 1-proj-2-tuple(v_334) else caught-fail) in
        {988}let input_key_material_8: key = (if v_333 then catch-fail((if v_335 then dhexp(my_private_key_7,re_11) else fail-any)) else caught-fail) in
        {989}let v_336: bool = not-caught-fail(input_key_material_8) in
        {990}let v_337: bitstring = (if v_336 then catch-fail(symmetricstateunpack(ss_48)) else caught-fail) in
        {991}let v_338: bool = (not-caught-fail(v_337) && success?(1-proj-3-tuple(v_337))) in
        {992}let h_42: bitstring = (if v_338 then 3-proj-3-tuple(v_337) else caught-fail) in
        {993}let ck_49: key = (if v_338 then 2-proj-3-tuple(v_337) else caught-fail) in
        {994}let cs_42: cipherstate = (if v_338 then 1-proj-3-tuple(v_337) else caught-fail) in
        {997}let output3_8: key = (if v_338 then hmac_hash3(ck_49,input_key_material_8) else caught-fail) in
        {996}let output2_8: key = (if v_338 then hmac_hash2(ck_49,input_key_material_8) else caught-fail) in
        {995}let output1_8: key = (if v_338 then hmac_hash1(ck_49,input_key_material_8) else caught-fail) in
        {998}let v_339: bitstring = (if v_338 then catch-fail((output1_8,output2_8,output3_8)) else caught-fail) in
        {999}let v_340: bool = (not-caught-fail(v_339) && success?(1-proj-3-tuple(v_339))) in
        {1000}let output_7: key = (if v_340 then 3-proj-3-tuple(v_339) else caught-fail) in
        {1001}let temp_k_7: key = (if v_340 then 2-proj-3-tuple(v_339) else caught-fail) in
        {1002}let ck_50: key = (if v_340 then 1-proj-3-tuple(v_339) else caught-fail) in
        {1003}let ss_49: symmetricstate = (if v_333 then catch-fail((if v_336 then (if v_338 then (if v_340 then symmetricstatepack(cipherstatepack(temp_k_7,minnonce),ck_50,h_42) else fail-any) else fail-any) else fail-any)) else caught-fail) in
        {1004}let v_341: bool = not-caught-fail(ss_49) in
        {1005}let v_342: bitstring = (if v_341 then catch-fail(symmetricstateunpack(ss_49)) else caught-fail) in
        {1006}let v_343: bool = (not-caught-fail(v_342) && success?(1-proj-3-tuple(v_342))) in
        {1007}let h_43: bitstring = (if v_343 then 3-proj-3-tuple(v_342) else caught-fail) in
        {1008}let ck_51: key = (if v_343 then 2-proj-3-tuple(v_342) else caught-fail) in
        {1009}let cs_43: cipherstate = (if v_343 then 1-proj-3-tuple(v_342) else caught-fail) in
        {1010}let v_344: bitstring = (if v_343 then catch-fail(cipherstateunpack(cs_43)) else caught-fail) in
        {1011}let v_345: bool = (not-caught-fail(v_344) && success?(1-proj-2-tuple(v_344))) in
        {1012}let n_26: nonce = (if v_345 then 2-proj-2-tuple(v_344) else caught-fail) in
        {1013}let k_28: key = (if v_345 then 1-proj-2-tuple(v_344) else caught-fail) in
        {1016}let v_346: bitstring = (if v_345 then catch-fail(cipherstateunpack(cs_43)) else caught-fail) in
        {1017}let v_347: bool = (not-caught-fail(v_346) && success?(1-proj-2-tuple(v_346))) in
        {1018}let o_13: nonce = (if v_347 then 2-proj-2-tuple(v_346) else caught-fail) in
        {1019}let k_29: key = (if v_347 then 1-proj-2-tuple(v_346) else caught-fail) in
        {1015}let n_27: nonce = (if v_345 then increment_nonce(n_26) else caught-fail) in
        {1020}let csi_26: cipherstate = (if v_345 then catch-fail((if v_347 then cipherstatepack(k_29,n_27) else fail-any)) else caught-fail) in
        {1021}let v_348: bool = not-caught-fail(csi_26) in
        {926}let payload_4: bitstring = msg_c(me_1,them_1,sid_2) in
        {1014}let e_18: bitstring = (if v_345 then encrypt(k_28,n_26,h_43,payload_4) else caught-fail) in
        {1022}let v_349: bitstring = (if v_343 then catch-fail((if v_345 then (if v_348 then (csi_26,e_18) else fail-any) else fail-any)) else caught-fail) in
        {1023}let v_350: bool = (not-caught-fail(v_349) && success?(1-proj-2-tuple(v_349))) in
        {1024}let ciphertext_18: bitstring = (if v_350 then 2-proj-2-tuple(v_349) else caught-fail) in
        {1025}let csi_27: cipherstate = (if v_350 then 1-proj-2-tuple(v_349) else caught-fail) in
        {1026}let ss_50: symmetricstate = (if v_350 then symmetricstatepack(csi_27,ck_51,h_43) else caught-fail) in
        {1027}let v_351: bitstring = (if v_350 then catch-fail(symmetricstateunpack(ss_50)) else caught-fail) in
        {1028}let v_352: bool = (not-caught-fail(v_351) && success?(1-proj-3-tuple(v_351))) in
        {1029}let h_44: bitstring = (if v_352 then 3-proj-3-tuple(v_351) else caught-fail) in
        {1030}let ck_52: key = (if v_352 then 2-proj-3-tuple(v_351) else caught-fail) in
        {1031}let cs_44: cipherstate = (if v_352 then 1-proj-3-tuple(v_351) else caught-fail) in
        {1032}let ssi_14: symmetricstate = (if v_350 then catch-fail((if v_352 then symmetricstatepack(cs_44,ck_52,hash(h_44,ciphertext_18)) else fail-any)) else caught-fail) in
        {1033}let v_353: bool = not-caught-fail(ssi_14) in
        {1034}let v_354: bitstring = (if v_341 then catch-fail((if v_343 then (if v_350 then (if v_353 then (ssi_14,ciphertext_18) else fail-any) else fail-any) else fail-any)) else caught-fail) in
        {1035}let v_355: bool = (not-caught-fail(v_354) && success?(1-proj-2-tuple(v_354))) in
        {1036}let ciphertext_19: bitstring = (if v_355 then 2-proj-2-tuple(v_354) else caught-fail) in
        {1037}let ss_51: symmetricstate = (if v_355 then 1-proj-2-tuple(v_354) else caught-fail) in
        {1040}let v_356: bitstring = (if v_355 then catch-fail(symmetricstateunpack(ss_51)) else caught-fail) in
        {1041}let v_357: bool = (not-caught-fail(v_356) && success?(1-proj-3-tuple(v_356))) in
        {1042}let h_45: bitstring = (if v_357 then 3-proj-3-tuple(v_356) else caught-fail) in
        {1043}let ck_53: key = (if v_357 then 2-proj-3-tuple(v_356) else caught-fail) in
        {1044}let cs_45: cipherstate = (if v_357 then 1-proj-3-tuple(v_356) else caught-fail) in
        {1045}let input_key_material_9: key = (if v_357 then zero else caught-fail) in
        {1048}let output3_9: key = (if v_357 then hmac_hash3(ck_53,input_key_material_9) else caught-fail) in
        {1047}let output2_9: key = (if v_357 then hmac_hash2(ck_53,input_key_material_9) else caught-fail) in
        {1046}let output1_9: key = (if v_357 then hmac_hash1(ck_53,input_key_material_9) else caught-fail) in
        {1049}let v_358: bitstring = (if v_357 then catch-fail((output1_9,output2_9,output3_9)) else caught-fail) in
        {1050}let v_359: bool = (not-caught-fail(v_358) && success?(1-proj-3-tuple(v_358))) in
        {1051}let temp_k3_1: key = (if v_359 then 3-proj-3-tuple(v_358) else caught-fail) in
        {1052}let temp_k2_1: key = (if v_359 then 2-proj-3-tuple(v_358) else caught-fail) in
        {1053}let temp_k1_1: key = (if v_359 then 1-proj-3-tuple(v_358) else caught-fail) in
        {1055}let cs2_5: cipherstate = (if v_359 then cipherstatepack(temp_k2_1,minnonce) else caught-fail) in
        {1054}let cs1_5: cipherstate = (if v_359 then cipherstatepack(temp_k1_1,minnonce) else caught-fail) in
        {1056}let v_360: bitstring = (if v_355 then catch-fail((if v_357 then (if v_359 then (ss_51,cs1_5,cs2_5) else fail-any) else fail-any)) else caught-fail) in
        {1057}let v_361: bool = (not-caught-fail(v_360) && success?(1-proj-3-tuple(v_360))) in
        {1058}let cs2_6: cipherstate = (if v_361 then 3-proj-3-tuple(v_360) else caught-fail) in
        {1059}let cs1_6: cipherstate = (if v_361 then 2-proj-3-tuple(v_360) else caught-fail) in
        {1060}let ssi_15: symmetricstate = (if v_361 then 1-proj-3-tuple(v_360) else caught-fail) in
        {1039}let message_buffer_4: bitstring = (if v_355 then concat3(ne_13,nm_5,ciphertext_19) else caught-fail) in
        {1038}let hs_26: handshakestate = (if v_355 then handshakestatepack(ss_51,s_9,m_11,e_16,rs_11,rm_11,re_11,psk_9,initiator_8) else caught-fail) in
        {1061}let (hs_27: handshakestate,message_c_1: bitstring,cs1_7: cipherstate,cs2_7: cipherstate) = (if v_314 then (if v_316 then (if v_318 then (if v_333 then (if v_341 then (if v_355 then (if v_361 then (hs_26,message_buffer_4,cs1_6,cs2_6) else fail-any) else fail-any) else fail-any) else fail-any) else fail-any) else fail-any) else fail-any) in
        {1062}event SendMsg(me_1,them_1,stagepack_c(sid_2),msg_c(me_1,them_1,sid_2));
        {1063}insert statestore(me_1,them_1,sid_2,statepack_d(hs_27,cs1_7,cs2_7));
        {1064}out(pub, message_c_1)
    ) | (
        {1066}!
        {1132}get statestore(=me_1,=them_1,=sid_2,statepack_d(hs_28: handshakestate,cs1_8: cipherstate,cs2_8: cipherstate)) in
        {1067}let hs_29: handshakestate = handshakestatesetcs(hs_28,cs2_8) in
        {1068}in(pub, message_d_1: bitstring);
        {1069}let v_362: bitstring = catch-fail(handshakestateunpack(hs_29)) in
        {1070}let v_363: bool = (not-caught-fail(v_362) && success?(1-proj-9-tuple(v_362))) in
        {1071}let initiator_9: bool = (if v_363 then 9-proj-9-tuple(v_362) else caught-fail) in
        {1072}let psk_10: key = (if v_363 then 8-proj-9-tuple(v_362) else caught-fail) in
        {1073}let re_12: key = (if v_363 then 7-proj-9-tuple(v_362) else caught-fail) in
        {1074}let rm_12: key = (if v_363 then 6-proj-9-tuple(v_362) else caught-fail) in
        {1075}let rs_12: key = (if v_363 then 5-proj-9-tuple(v_362) else caught-fail) in
        {1076}let e_19: keypair = (if v_363 then 4-proj-9-tuple(v_362) else caught-fail) in
        {1077}let m_12: keypair = (if v_363 then 3-proj-9-tuple(v_362) else caught-fail) in
        {1078}let s_10: keypair = (if v_363 then 2-proj-9-tuple(v_362) else caught-fail) in
        {1079}let ss_52: symmetricstate = (if v_363 then 1-proj-9-tuple(v_362) else caught-fail) in
        {1080}let v_364: bitstring = (if v_363 then catch-fail(deconcat3(message_d_1)) else caught-fail) in
        {1081}let v_365: bool = (not-caught-fail(v_364) && success?(1-proj-3-tuple(v_364))) in
        {1082}let ciphertext_20: bitstring = (if v_365 then 3-proj-3-tuple(v_364) else caught-fail) in
        {1083}let ns_8: bitstring = (if v_365 then 2-proj-3-tuple(v_364) else caught-fail) in
        {1084}let ne_14: bitstring = (if v_365 then 1-proj-3-tuple(v_364) else caught-fail) in
        {1086}let v_366: bitstring = (if v_365 then catch-fail(symmetricstateunpack(ss_52)) else caught-fail) in
        {1087}let v_367: bool = (not-caught-fail(v_366) && success?(1-proj-3-tuple(v_366))) in
        {1088}let h_46: bitstring = (if v_367 then 3-proj-3-tuple(v_366) else caught-fail) in
        {1089}let ck_54: key = (if v_367 then 2-proj-3-tuple(v_366) else caught-fail) in
        {1090}let cs_46: cipherstate = (if v_367 then 1-proj-3-tuple(v_366) else caught-fail) in
        {1091}let v_368: bitstring = (if v_367 then catch-fail(cipherstateunpack(cs_46)) else caught-fail) in
        {1092}let v_369: bool = (not-caught-fail(v_368) && success?(1-proj-2-tuple(v_368))) in
        {1093}let n_28: nonce = (if v_369 then 2-proj-2-tuple(v_368) else caught-fail) in
        {1094}let k_30: key = (if v_369 then 1-proj-2-tuple(v_368) else caught-fail) in
        {1095}let d_7: aead = (if v_369 then catch-fail(decrypt(k_30,n_28,h_46,ciphertext_20)) else caught-fail) in
        {1096}let v_370: bool = not-caught-fail(d_7) in
        {1097}let v_371: bitstring = (if v_370 then catch-fail(aeadunpack(d_7)) else caught-fail) in
        {1098}let v_372: bool = (not-caught-fail(v_371) && success?(1-proj-3-tuple(v_371))) in
        {1099}let plaintext_19: bitstring = (if v_372 then 3-proj-3-tuple(v_371) else caught-fail) in
        {1100}let adi_7: bitstring = (if v_372 then 2-proj-3-tuple(v_371) else caught-fail) in
        {1101}let valid_17: bool = (if v_372 then 1-proj-3-tuple(v_371) else caught-fail) in
        {1103}let v_373: bitstring = (if v_372 then catch-fail(cipherstateunpack(cs_46)) else caught-fail) in
        {1104}let v_374: bool = (not-caught-fail(v_373) && success?(1-proj-2-tuple(v_373))) in
        {1105}let o_14: nonce = (if v_374 then 2-proj-2-tuple(v_373) else caught-fail) in
        {1106}let k_31: key = (if v_374 then 1-proj-2-tuple(v_373) else caught-fail) in
        {1102}let n_29: nonce = (if v_372 then increment_nonce(n_28) else caught-fail) in
        {1107}let csi_28: cipherstate = (if v_372 then catch-fail((if v_374 then cipherstatepack(k_31,n_29) else fail-any)) else caught-fail) in
        {1108}let v_375: bool = not-caught-fail(csi_28) in
        {1109}let v_376: bitstring = (if v_367 then catch-fail((if v_369 then (if v_370 then (if v_372 then (if v_375 then (csi_28,plaintext_19,valid_17) else fail-any) else fail-any) else fail-any) else fail-any)) else caught-fail) in
        {1110}let v_377: bool = (not-caught-fail(v_376) && success?(1-proj-3-tuple(v_376))) in
        {1111}let valid_18: bool = (if v_377 then 3-proj-3-tuple(v_376) else caught-fail) in
        {1112}let plaintext_20: bitstring = (if v_377 then 2-proj-3-tuple(v_376) else caught-fail) in
        {1113}let csi_29: cipherstate = (if v_377 then 1-proj-3-tuple(v_376) else caught-fail) in
        {1114}let ss_53: symmetricstate = (if v_377 then symmetricstatepack(csi_29,ck_54,h_46) else caught-fail) in
        {1115}let v_378: bitstring = (if v_377 then catch-fail(symmetricstateunpack(ss_53)) else caught-fail) in
        {1116}let v_379: bool = (not-caught-fail(v_378) && success?(1-proj-3-tuple(v_378))) in
        {1117}let h_47: bitstring = (if v_379 then 3-proj-3-tuple(v_378) else caught-fail) in
        {1118}let ck_55: key = (if v_379 then 2-proj-3-tuple(v_378) else caught-fail) in
        {1119}let cs_47: cipherstate = (if v_379 then 1-proj-3-tuple(v_378) else caught-fail) in
        {1120}let ssi_16: symmetricstate = (if v_377 then catch-fail((if v_379 then symmetricstatepack(cs_47,ck_55,hash(h_47,ciphertext_20)) else fail-any)) else caught-fail) in
        {1121}let v_380: bool = not-caught-fail(ssi_16) in
        {1122}let v_381: bitstring = (if v_365 then catch-fail((if v_367 then (if v_377 then (if v_380 then (ssi_16,plaintext_20,valid_18) else fail-any) else fail-any) else fail-any)) else caught-fail) in
        {1123}let v_382: bool = (not-caught-fail(v_381) && success?(1-proj-3-tuple(v_381))) in
        {1124}let valid2_3: bool = (if v_382 then 3-proj-3-tuple(v_381) else caught-fail) in
        {1125}let plaintext_21: bitstring = (if v_382 then 2-proj-3-tuple(v_381) else caught-fail) in
        {1126}let ss_54: symmetricstate = (if v_382 then 1-proj-3-tuple(v_381) else caught-fail) in
        {1085}let valid1_5: bool = (if v_365 then true else caught-fail) in
        {1127}let v_383: bool = (if v_382 then catch-fail((valid1_5 && valid2_3)) else caught-fail) in
        {1128}let hs_30: handshakestate = (if v_383 then handshakestatepack(ss_54,s_10,m_12,e_19,rs_12,rm_12,re_12,psk_10,initiator_9) else caught-fail) in
        {1129}let (hs_31: handshakestate,plaintext_d_1: bitstring,valid_19: bool) = (if v_363 then (if v_365 then (if v_382 then (if undo-catch-fail(v_383) then (hs_30,plaintext_21,true) else fail-any) else fail-any) else fail-any) else fail-any) in
        {1130}event RecvMsg(me_1,them_1,stagepack_d(sid_2),plaintext_d_1);
        {1131}insert statestore(me_1,them_1,sid_2,statepack_e(hs_31,cs1_8,handshakestategetcs(hs_31)))
    ) | (
        {1133}!
        {1190}get statestore(=me_1,=them_1,=sid_2,statepack_e(hs_32: handshakestate,cs1_9: cipherstate,cs2_9: cipherstate)) in
        {1134}let hs_33: handshakestate = handshakestatesetcs(hs_32,cs1_9) in
        {1136}let v_384: bitstring = catch-fail(handshakestateunpack(hs_33)) in
        {1137}let v_385: bool = (not-caught-fail(v_384) && success?(1-proj-9-tuple(v_384))) in
        {1138}let initiator_10: bool = (if v_385 then 9-proj-9-tuple(v_384) else caught-fail) in
        {1139}let psk_11: key = (if v_385 then 8-proj-9-tuple(v_384) else caught-fail) in
        {1140}let re_13: key = (if v_385 then 7-proj-9-tuple(v_384) else caught-fail) in
        {1141}let rm_13: key = (if v_385 then 6-proj-9-tuple(v_384) else caught-fail) in
        {1142}let rs_13: key = (if v_385 then 5-proj-9-tuple(v_384) else caught-fail) in
        {1143}let e_20: keypair = (if v_385 then 4-proj-9-tuple(v_384) else caught-fail) in
        {1144}let m_13: keypair = (if v_385 then 3-proj-9-tuple(v_384) else caught-fail) in
        {1145}let s_11: keypair = (if v_385 then 2-proj-9-tuple(v_384) else caught-fail) in
        {1146}let ss_55: symmetricstate = (if v_385 then 1-proj-9-tuple(v_384) else caught-fail) in
        {1147}let v_386: bitstring = (if v_385 then catch-fail((empty,empty,empty)) else caught-fail) in
        {1148}let v_387: bool = (not-caught-fail(v_386) && success?(1-proj-3-tuple(v_386))) in
        {1149}let ciphertext_21: bitstring = (if v_387 then 3-proj-3-tuple(v_386) else caught-fail) in
        {1150}let ns_9: bitstring = (if v_387 then 2-proj-3-tuple(v_386) else caught-fail) in
        {1151}let ne_15: bitstring = (if v_387 then 1-proj-3-tuple(v_386) else caught-fail) in
        {1152}let v_388: bitstring = (if v_387 then catch-fail(symmetricstateunpack(ss_55)) else caught-fail) in
        {1153}let v_389: bool = (not-caught-fail(v_388) && success?(1-proj-3-tuple(v_388))) in
        {1154}let h_48: bitstring = (if v_389 then 3-proj-3-tuple(v_388) else caught-fail) in
        {1155}let ck_56: key = (if v_389 then 2-proj-3-tuple(v_388) else caught-fail) in
        {1156}let cs_48: cipherstate = (if v_389 then 1-proj-3-tuple(v_388) else caught-fail) in
        {1157}let v_390: bitstring = (if v_389 then catch-fail(cipherstateunpack(cs_48)) else caught-fail) in
        {1158}let v_391: bool = (not-caught-fail(v_390) && success?(1-proj-2-tuple(v_390))) in
        {1159}let n_30: nonce = (if v_391 then 2-proj-2-tuple(v_390) else caught-fail) in
        {1160}let k_32: key = (if v_391 then 1-proj-2-tuple(v_390) else caught-fail) in
        {1163}let v_392: bitstring = (if v_391 then catch-fail(cipherstateunpack(cs_48)) else caught-fail) in
        {1164}let v_393: bool = (not-caught-fail(v_392) && success?(1-proj-2-tuple(v_392))) in
        {1165}let o_15: nonce = (if v_393 then 2-proj-2-tuple(v_392) else caught-fail) in
        {1166}let k_33: key = (if v_393 then 1-proj-2-tuple(v_392) else caught-fail) in
        {1162}let n_31: nonce = (if v_391 then increment_nonce(n_30) else caught-fail) in
        {1167}let csi_30: cipherstate = (if v_391 then catch-fail((if v_393 then cipherstatepack(k_33,n_31) else fail-any)) else caught-fail) in
        {1168}let v_394: bool = not-caught-fail(csi_30) in
        {1135}let payload_5: bitstring = msg_e(me_1,them_1,sid_2) in
        {1161}let e_21: bitstring = (if v_391 then encrypt(k_32,n_30,h_48,payload_5) else caught-fail) in
        {1169}let v_395: bitstring = (if v_389 then catch-fail((if v_391 then (if v_394 then (csi_30,e_21) else fail-any) else fail-any)) else caught-fail) in
        {1170}let v_396: bool = (not-caught-fail(v_395) && success?(1-proj-2-tuple(v_395))) in
        {1171}let ciphertext_22: bitstring = (if v_396 then 2-proj-2-tuple(v_395) else caught-fail) in
        {1172}let csi_31: cipherstate = (if v_396 then 1-proj-2-tuple(v_395) else caught-fail) in
        {1173}let ss_56: symmetricstate = (if v_396 then symmetricstatepack(csi_31,ck_56,h_48) else caught-fail) in
        {1174}let v_397: bitstring = (if v_396 then catch-fail(symmetricstateunpack(ss_56)) else caught-fail) in
        {1175}let v_398: bool = (not-caught-fail(v_397) && success?(1-proj-3-tuple(v_397))) in
        {1176}let h_49: bitstring = (if v_398 then 3-proj-3-tuple(v_397) else caught-fail) in
        {1177}let ck_57: key = (if v_398 then 2-proj-3-tuple(v_397) else caught-fail) in
        {1178}let cs_49: cipherstate = (if v_398 then 1-proj-3-tuple(v_397) else caught-fail) in
        {1179}let ssi_17: symmetricstate = (if v_396 then catch-fail((if v_398 then symmetricstatepack(cs_49,ck_57,hash(h_49,ciphertext_22)) else fail-any)) else caught-fail) in
        {1180}let v_399: bool = not-caught-fail(ssi_17) in
        {1181}let v_400: bitstring = (if v_387 then catch-fail((if v_389 then (if v_396 then (if v_399 then (ssi_17,ciphertext_22) else fail-any) else fail-any) else fail-any)) else caught-fail) in
        {1182}let v_401: bool = (not-caught-fail(v_400) && success?(1-proj-2-tuple(v_400))) in
        {1183}let ciphertext_23: bitstring = (if v_401 then 2-proj-2-tuple(v_400) else caught-fail) in
        {1184}let ss_57: symmetricstate = (if v_401 then 1-proj-2-tuple(v_400) else caught-fail) in
        {1186}let message_buffer_5: bitstring = (if v_401 then concat3(ne_15,ns_9,ciphertext_23) else caught-fail) in
        {1185}let hs_34: handshakestate = (if v_401 then handshakestatepack(ss_57,s_11,m_13,e_20,rs_13,rm_13,re_13,psk_11,initiator_10) else caught-fail) in
        {1187}let (hs_35: handshakestate,message_e_1: bitstring) = (if v_385 then (if v_387 then (if v_401 then (hs_34,message_buffer_5) else fail-any) else fail-any) else fail-any) in
        {1188}event SendMsg(me_1,them_1,stagepack_e(sid_2),msg_e(me_1,them_1,sid_2));
        {1189}out(pub, message_e_1)
    ) | (
        {1191}event LeakS(phase0,me_1);
        {1192}event LeakM(phase0,me_1);
        {1193}out(pub, (key_s(me_1),key_m(me_1)))
    ) | (
        {1194}phase 1;
        {1195}event LeakS(phase1,me_1);
        {1196}event LeakM(phase1,me_1);
        {1197}out(pub, (key_s(me_1),key_m(me_1)))
    )
) | (
    {1202}let m_14: keypair = keypairpack(empty,empty) in
    {1201}let s_12: keypair = keypairpack(empty,empty) in
    {1203}out(pub, (getpublickey(s_12),getpublickey(m_14)));
    {1200}let sid_3: sessionid = sid in
    {1199}let them_2: principal = alice in
    {1198}let me_2: principal = bob in
    (
        {1213}let k_34: key = empty in
        {1214}let cs_50: cipherstate = cipherstatepack(k_34,minnonce) in
        {1210}let protocol_name_2: bitstring = somename in
        {1211}let h_50: bitstring = hash(protocol_name_2,empty) in
        {1212}let ck_58: key = h_50 in
        {1215}let ss_58: symmetricstate = symmetricstatepack(cs_50,ck_58,h_50) in
        {1216}let v_402: bitstring = catch-fail(symmetricstateunpack(ss_58)) in
        {1217}let v_403: bool = (not-caught-fail(v_402) && success?(1-proj-3-tuple(v_402))) in
        {1218}let h_51: bitstring = (if v_403 then 3-proj-3-tuple(v_402) else caught-fail) in
        {1219}let ck_59: key = (if v_403 then 2-proj-3-tuple(v_402) else caught-fail) in
        {1220}let cs_51: cipherstate = (if v_403 then 1-proj-3-tuple(v_402) else caught-fail) in
        {1208}let prologue_2: bitstring = empty in
        {1221}let ss_59: symmetricstate = catch-fail((if v_403 then symmetricstatepack(cs_51,ck_59,hash(h_51,prologue_2)) else fail-any)) in
        {1222}let v_404: bool = not-caught-fail(ss_59) in
        {1209}let psk_12: key = empty in
        {1207}let re_14: key = empty in
        {1206}let rm_14: key = empty in
        {1205}let rs_14: key = empty in
        {1204}let e_22: keypair = keypairpack(empty,empty) in
        {1223}let hs_36: handshakestate = (if v_404 then handshakestatepack(ss_59,s_12,m_14,e_22,rs_14,rm_14,re_14,psk_12,false) else fail-any) in
        {1224}insert statestore(me_2,them_2,sid_3,statepack_a(hs_36))
    ) | (
        {1297}get statestore(=me_2,=them_2,=sid_3,statepack_a(hs_37: handshakestate)) in
        {1225}in(pub, message_a_2: bitstring);
        {1226}let v_405: bitstring = catch-fail(handshakestateunpack(hs_37)) in
        {1227}let v_406: bool = (not-caught-fail(v_405) && success?(1-proj-9-tuple(v_405))) in
        {1228}let initiator_11: bool = (if v_406 then 9-proj-9-tuple(v_405) else caught-fail) in
        {1229}let psk_13: key = (if v_406 then 8-proj-9-tuple(v_405) else caught-fail) in
        {1230}let re_15: key = (if v_406 then 7-proj-9-tuple(v_405) else caught-fail) in
        {1231}let rm_15: key = (if v_406 then 6-proj-9-tuple(v_405) else caught-fail) in
        {1232}let rs_15: key = (if v_406 then 5-proj-9-tuple(v_405) else caught-fail) in
        {1233}let e_23: keypair = (if v_406 then 4-proj-9-tuple(v_405) else caught-fail) in
        {1234}let m_15: keypair = (if v_406 then 3-proj-9-tuple(v_405) else caught-fail) in
        {1235}let s_13: keypair = (if v_406 then 2-proj-9-tuple(v_405) else caught-fail) in
        {1236}let ss_60: symmetricstate = (if v_406 then 1-proj-9-tuple(v_405) else caught-fail) in
        {1237}let v_407: bitstring = (if v_406 then catch-fail(deconcat3(message_a_2)) else caught-fail) in
        {1238}let v_408: bool = (not-caught-fail(v_407) && success?(1-proj-3-tuple(v_407))) in
        {1239}let ciphertext_24: bitstring = (if v_408 then 3-proj-3-tuple(v_407) else caught-fail) in
        {1240}let ns_10: bitstring = (if v_408 then 2-proj-3-tuple(v_407) else caught-fail) in
        {1241}let ne_16: bitstring = (if v_408 then 1-proj-3-tuple(v_407) else caught-fail) in
        {1244}let v_409: bitstring = (if v_408 then catch-fail(symmetricstateunpack(ss_60)) else caught-fail) in
        {1245}let v_410: bool = (not-caught-fail(v_409) && success?(1-proj-3-tuple(v_409))) in
        {1246}let h_52: bitstring = (if v_410 then 3-proj-3-tuple(v_409) else caught-fail) in
        {1247}let ck_60: key = (if v_410 then 2-proj-3-tuple(v_409) else caught-fail) in
        {1248}let cs_52: cipherstate = (if v_410 then 1-proj-3-tuple(v_409) else caught-fail) in
        {1243}let re_16: key = (if v_408 then ne_16 else caught-fail) in
        {1249}let ss_61: symmetricstate = (if v_408 then catch-fail((if v_410 then symmetricstatepack(cs_52,ck_60,hash(h_52,re_16)) else fail-any)) else caught-fail) in
        {1250}let v_411: bool = not-caught-fail(ss_61) in
        {1251}let v_412: bitstring = (if v_411 then catch-fail(symmetricstateunpack(ss_61)) else caught-fail) in
        {1252}let v_413: bool = (not-caught-fail(v_412) && success?(1-proj-3-tuple(v_412))) in
        {1253}let h_53: bitstring = (if v_413 then 3-proj-3-tuple(v_412) else caught-fail) in
        {1254}let ck_61: key = (if v_413 then 2-proj-3-tuple(v_412) else caught-fail) in
        {1255}let cs_53: cipherstate = (if v_413 then 1-proj-3-tuple(v_412) else caught-fail) in
        {1256}let v_414: bitstring = (if v_413 then catch-fail(cipherstateunpack(cs_53)) else caught-fail) in
        {1257}let v_415: bool = (not-caught-fail(v_414) && success?(1-proj-2-tuple(v_414))) in
        {1258}let n_32: nonce = (if v_415 then 2-proj-2-tuple(v_414) else caught-fail) in
        {1259}let k_35: key = (if v_415 then 1-proj-2-tuple(v_414) else caught-fail) in
        {1260}let d_8: aead = (if v_415 then catch-fail(decrypt(k_35,n_32,h_53,ciphertext_24)) else caught-fail) in
        {1261}let v_416: bool = not-caught-fail(d_8) in
        {1262}let v_417: bitstring = (if v_416 then catch-fail(aeadunpack(d_8)) else caught-fail) in
        {1263}let v_418: bool = (not-caught-fail(v_417) && success?(1-proj-3-tuple(v_417))) in
        {1264}let plaintext_22: bitstring = (if v_418 then 3-proj-3-tuple(v_417) else caught-fail) in
        {1265}let adi_8: bitstring = (if v_418 then 2-proj-3-tuple(v_417) else caught-fail) in
        {1266}let valid_20: bool = (if v_418 then 1-proj-3-tuple(v_417) else caught-fail) in
        {1268}let v_419: bitstring = (if v_418 then catch-fail(cipherstateunpack(cs_53)) else caught-fail) in
        {1269}let v_420: bool = (not-caught-fail(v_419) && success?(1-proj-2-tuple(v_419))) in
        {1270}let o_16: nonce = (if v_420 then 2-proj-2-tuple(v_419) else caught-fail) in
        {1271}let k_36: key = (if v_420 then 1-proj-2-tuple(v_419) else caught-fail) in
        {1267}let n_33: nonce = (if v_418 then increment_nonce(n_32) else caught-fail) in
        {1272}let csi_32: cipherstate = (if v_418 then catch-fail((if v_420 then cipherstatepack(k_36,n_33) else fail-any)) else caught-fail) in
        {1273}let v_421: bool = not-caught-fail(csi_32) in
        {1274}let v_422: bitstring = (if v_413 then catch-fail((if v_415 then (if v_416 then (if v_418 then (if v_421 then (csi_32,plaintext_22,valid_20) else fail-any) else fail-any) else fail-any) else fail-any)) else caught-fail) in
        {1275}let v_423: bool = (not-caught-fail(v_422) && success?(1-proj-3-tuple(v_422))) in
        {1276}let valid_21: bool = (if v_423 then 3-proj-3-tuple(v_422) else caught-fail) in
        {1277}let plaintext_23: bitstring = (if v_423 then 2-proj-3-tuple(v_422) else caught-fail) in
        {1278}let csi_33: cipherstate = (if v_423 then 1-proj-3-tuple(v_422) else caught-fail) in
        {1279}let ss_62: symmetricstate = (if v_423 then symmetricstatepack(csi_33,ck_61,h_53) else caught-fail) in
        {1280}let v_424: bitstring = (if v_423 then catch-fail(symmetricstateunpack(ss_62)) else caught-fail) in
        {1281}let v_425: bool = (not-caught-fail(v_424) && success?(1-proj-3-tuple(v_424))) in
        {1282}let h_54: bitstring = (if v_425 then 3-proj-3-tuple(v_424) else caught-fail) in
        {1283}let ck_62: key = (if v_425 then 2-proj-3-tuple(v_424) else caught-fail) in
        {1284}let cs_54: cipherstate = (if v_425 then 1-proj-3-tuple(v_424) else caught-fail) in
        {1285}let ssi_18: symmetricstate = (if v_423 then catch-fail((if v_425 then symmetricstatepack(cs_54,ck_62,hash(h_54,ciphertext_24)) else fail-any)) else caught-fail) in
        {1286}let v_426: bool = not-caught-fail(ssi_18) in
        {1287}let v_427: bitstring = (if v_411 then catch-fail((if v_413 then (if v_423 then (if v_426 then (ssi_18,plaintext_23,valid_21) else fail-any) else fail-any) else fail-any)) else caught-fail) in
        {1288}let v_428: bool = (not-caught-fail(v_427) && success?(1-proj-3-tuple(v_427))) in
        {1289}let valid2_4: bool = (if v_428 then 3-proj-3-tuple(v_427) else caught-fail) in
        {1290}let plaintext_24: bitstring = (if v_428 then 2-proj-3-tuple(v_427) else caught-fail) in
        {1291}let ss_63: symmetricstate = (if v_428 then 1-proj-3-tuple(v_427) else caught-fail) in
        {1242}let valid1_6: bool = (if v_408 then true else caught-fail) in
        {1292}let v_429: bool = (if v_428 then catch-fail((valid1_6 && valid2_4)) else caught-fail) in
        {1293}let hs_38: handshakestate = (if v_429 then handshakestatepack(ss_63,s_13,m_15,e_23,rs_15,rm_15,re_16,psk_13,initiator_11) else caught-fail) in
        {1294}let (hs_39: handshakestate,plaintext_a: bitstring,valid_22: bool) = (if v_406 then (if v_408 then (if v_411 then (if v_428 then (if undo-catch-fail(v_429) then (hs_38,plaintext_24,true) else fail-any) else fail-any) else fail-any) else fail-any) else fail-any) in
        {1295}event RecvMsg(me_2,them_2,stagepack_a(sid_3),plaintext_a);
        {1296}insert statestore(me_2,them_2,sid_3,statepack_b(hs_39))
    ) | (
        {1512}get statestore(=me_2,=them_2,=sid_3,statepack_b(hs_40: handshakestate)) in
        {1299}let v_430: bitstring = catch-fail(handshakestateunpack(hs_40)) in
        {1300}let v_431: bool = (not-caught-fail(v_430) && success?(1-proj-9-tuple(v_430))) in
        {1301}let initiator_12: bool = (if v_431 then 9-proj-9-tuple(v_430) else caught-fail) in
        {1302}let psk_14: key = (if v_431 then 8-proj-9-tuple(v_430) else caught-fail) in
        {1303}let re_17: key = (if v_431 then 7-proj-9-tuple(v_430) else caught-fail) in
        {1304}let rm_16: key = (if v_431 then 6-proj-9-tuple(v_430) else caught-fail) in
        {1305}let rs_16: key = (if v_431 then 5-proj-9-tuple(v_430) else caught-fail) in
        {1306}let e_24: keypair = (if v_431 then 4-proj-9-tuple(v_430) else caught-fail) in
        {1307}let m_16: keypair = (if v_431 then 3-proj-9-tuple(v_430) else caught-fail) in
        {1308}let s_14: keypair = (if v_431 then 2-proj-9-tuple(v_430) else caught-fail) in
        {1309}let ss_64: symmetricstate = (if v_431 then 1-proj-9-tuple(v_430) else caught-fail) in
        {1310}let v_432: bitstring = (if v_431 then catch-fail((empty,empty,empty,empty)) else caught-fail) in
        {1311}let v_433: bool = (not-caught-fail(v_432) && success?(1-proj-4-tuple(v_432))) in
        {1312}let ciphertext_25: bitstring = (if v_433 then 4-proj-4-tuple(v_432) else caught-fail) in
        {1313}let nm_6: bitstring = (if v_433 then 3-proj-4-tuple(v_432) else caught-fail) in
        {1314}let ns_11: bitstring = (if v_433 then 2-proj-4-tuple(v_432) else caught-fail) in
        {1315}let ne_17: bitstring = (if v_433 then 1-proj-4-tuple(v_432) else caught-fail) in
        {1316}let basis_8: key = (if v_433 then key_e(me_2,them_2,sid_3) else caught-fail) in
        {1317}let public_key_8: key = (if v_433 then catch-fail(dhexp(basis_8,validkey(g))) else caught-fail) in
        {1318}let v_434: bool = not-caught-fail(public_key_8) in
        {1319}let e_25: keypair = (if v_433 then catch-fail((if v_434 then keypairpack(validkey(public_key_8),basis_8) else fail-any)) else caught-fail) in
        {1320}let v_435: bool = not-caught-fail(e_25) in
        {1321}let ne_18: bitstring = (if v_435 then catch-fail(getpublickey(e_25)) else caught-fail) in
        {1322}let v_436: bool = not-caught-fail(ne_18) in
        {1323}let v_437: bitstring = (if v_436 then catch-fail(symmetricstateunpack(ss_64)) else caught-fail) in
        {1324}let v_438: bool = (not-caught-fail(v_437) && success?(1-proj-3-tuple(v_437))) in
        {1325}let h_55: bitstring = (if v_438 then 3-proj-3-tuple(v_437) else caught-fail) in
        {1326}let ck_63: key = (if v_438 then 2-proj-3-tuple(v_437) else caught-fail) in
        {1327}let cs_55: cipherstate = (if v_438 then 1-proj-3-tuple(v_437) else caught-fail) in
        {1328}let ss_65: symmetricstate = (if v_436 then catch-fail((if v_438 then symmetricstatepack(cs_55,ck_63,hash(h_55,ne_18)) else fail-any)) else caught-fail) in
        {1329}let v_439: bool = not-caught-fail(ss_65) in
        {1330}let v_440: bitstring = (if v_439 then catch-fail(keypairunpack(e_25)) else caught-fail) in
        {1331}let v_441: bool = (not-caught-fail(v_440) && success?(1-proj-2-tuple(v_440))) in
        {1332}let my_private_key_8: key = (if v_441 then 2-proj-2-tuple(v_440) else caught-fail) in
        {1333}let my_public_key_8: key = (if v_441 then 1-proj-2-tuple(v_440) else caught-fail) in
        {1334}let input_key_material_10: key = (if v_439 then catch-fail((if v_441 then dhexp(my_private_key_8,re_17) else fail-any)) else caught-fail) in
        {1335}let v_442: bool = not-caught-fail(input_key_material_10) in
        {1336}let v_443: bitstring = (if v_442 then catch-fail(symmetricstateunpack(ss_65)) else caught-fail) in
        {1337}let v_444: bool = (not-caught-fail(v_443) && success?(1-proj-3-tuple(v_443))) in
        {1338}let h_56: bitstring = (if v_444 then 3-proj-3-tuple(v_443) else caught-fail) in
        {1339}let ck_64: key = (if v_444 then 2-proj-3-tuple(v_443) else caught-fail) in
        {1340}let cs_56: cipherstate = (if v_444 then 1-proj-3-tuple(v_443) else caught-fail) in
        {1343}let output3_10: key = (if v_444 then hmac_hash3(ck_64,input_key_material_10) else caught-fail) in
        {1342}let output2_10: key = (if v_444 then hmac_hash2(ck_64,input_key_material_10) else caught-fail) in
        {1341}let output1_10: key = (if v_444 then hmac_hash1(ck_64,input_key_material_10) else caught-fail) in
        {1344}let v_445: bitstring = (if v_444 then catch-fail((output1_10,output2_10,output3_10)) else caught-fail) in
        {1345}let v_446: bool = (not-caught-fail(v_445) && success?(1-proj-3-tuple(v_445))) in
        {1346}let output_8: key = (if v_446 then 3-proj-3-tuple(v_445) else caught-fail) in
        {1347}let temp_k_8: key = (if v_446 then 2-proj-3-tuple(v_445) else caught-fail) in
        {1348}let ck_65: key = (if v_446 then 1-proj-3-tuple(v_445) else caught-fail) in
        {1349}let ss_66: symmetricstate = (if v_439 then catch-fail((if v_442 then (if v_444 then (if v_446 then symmetricstatepack(cipherstatepack(temp_k_8,minnonce),ck_65,h_56) else fail-any) else fail-any) else fail-any)) else caught-fail) in
        {1350}let v_447: bool = not-caught-fail(ss_66) in
        {1351}let basis_9: key = (if v_447 then key_s(me_2) else caught-fail) in
        {1352}let public_key_9: key = (if v_447 then catch-fail(dhexp(basis_9,validkey(g))) else caught-fail) in
        {1353}let v_448: bool = not-caught-fail(public_key_9) in
        {1354}let s_15: keypair = (if v_447 then catch-fail((if v_448 then keypairpack(validkey(public_key_9),basis_9) else fail-any)) else caught-fail) in
        {1355}let v_449: bool = not-caught-fail(s_15) in
        {1356}let plaintext_25: bitstring = (if v_449 then catch-fail(getpublickey(s_15)) else caught-fail) in
        {1357}let v_450: bool = not-caught-fail(plaintext_25) in
        {1358}let v_451: bitstring = (if v_450 then catch-fail(symmetricstateunpack(ss_66)) else caught-fail) in
        {1359}let v_452: bool = (not-caught-fail(v_451) && success?(1-proj-3-tuple(v_451))) in
        {1360}let h_57: bitstring = (if v_452 then 3-proj-3-tuple(v_451) else caught-fail) in
        {1361}let ck_66: key = (if v_452 then 2-proj-3-tuple(v_451) else caught-fail) in
        {1362}let cs_57: cipherstate = (if v_452 then 1-proj-3-tuple(v_451) else caught-fail) in
        {1363}let v_453: bitstring = (if v_452 then catch-fail(cipherstateunpack(cs_57)) else caught-fail) in
        {1364}let v_454: bool = (not-caught-fail(v_453) && success?(1-proj-2-tuple(v_453))) in
        {1365}let n_34: nonce = (if v_454 then 2-proj-2-tuple(v_453) else caught-fail) in
        {1366}let k_37: key = (if v_454 then 1-proj-2-tuple(v_453) else caught-fail) in
        {1369}let v_455: bitstring = (if v_454 then catch-fail(cipherstateunpack(cs_57)) else caught-fail) in
        {1370}let v_456: bool = (not-caught-fail(v_455) && success?(1-proj-2-tuple(v_455))) in
        {1371}let o_17: nonce = (if v_456 then 2-proj-2-tuple(v_455) else caught-fail) in
        {1372}let k_38: key = (if v_456 then 1-proj-2-tuple(v_455) else caught-fail) in
        {1368}let n_35: nonce = (if v_454 then increment_nonce(n_34) else caught-fail) in
        {1373}let csi_34: cipherstate = (if v_454 then catch-fail((if v_456 then cipherstatepack(k_38,n_35) else fail-any)) else caught-fail) in
        {1374}let v_457: bool = not-caught-fail(csi_34) in
        {1367}let e_26: bitstring = (if v_454 then encrypt(k_37,n_34,h_57,plaintext_25) else caught-fail) in
        {1375}let v_458: bitstring = (if v_452 then catch-fail((if v_454 then (if v_457 then (csi_34,e_26) else fail-any) else fail-any)) else caught-fail) in
        {1376}let v_459: bool = (not-caught-fail(v_458) && success?(1-proj-2-tuple(v_458))) in
        {1377}let ciphertext_26: bitstring = (if v_459 then 2-proj-2-tuple(v_458) else caught-fail) in
        {1378}let csi_35: cipherstate = (if v_459 then 1-proj-2-tuple(v_458) else caught-fail) in
        {1379}let ss_67: symmetricstate = (if v_459 then symmetricstatepack(csi_35,ck_66,h_57) else caught-fail) in
        {1380}let v_460: bitstring = (if v_459 then catch-fail(symmetricstateunpack(ss_67)) else caught-fail) in
        {1381}let v_461: bool = (not-caught-fail(v_460) && success?(1-proj-3-tuple(v_460))) in
        {1382}let h_58: bitstring = (if v_461 then 3-proj-3-tuple(v_460) else caught-fail) in
        {1383}let ck_67: key = (if v_461 then 2-proj-3-tuple(v_460) else caught-fail) in
        {1384}let cs_58: cipherstate = (if v_461 then 1-proj-3-tuple(v_460) else caught-fail) in
        {1385}let ssi_19: symmetricstate = (if v_459 then catch-fail((if v_461 then symmetricstatepack(cs_58,ck_67,hash(h_58,ciphertext_26)) else fail-any)) else caught-fail) in
        {1386}let v_462: bool = not-caught-fail(ssi_19) in
        {1387}let v_463: bitstring = (if v_449 then catch-fail((if v_450 then (if v_452 then (if v_459 then (if v_462 then (ssi_19,ciphertext_26) else fail-any) else fail-any) else fail-any) else fail-any)) else caught-fail) in
        {1388}let v_464: bool = (not-caught-fail(v_463) && success?(1-proj-2-tuple(v_463))) in
        {1389}let ns_12: bitstring = (if v_464 then 2-proj-2-tuple(v_463) else caught-fail) in
        {1390}let ss_68: symmetricstate = (if v_464 then 1-proj-2-tuple(v_463) else caught-fail) in
        {1391}let basis_10: key = (if v_464 then key_m(me_2) else caught-fail) in
        {1392}let public_key_10: key = (if v_464 then catch-fail(dhexp(basis_10,validkey(g))) else caught-fail) in
        {1393}let v_465: bool = not-caught-fail(public_key_10) in
        {1394}let m_17: keypair = (if v_464 then catch-fail((if v_465 then keypairpack(validkey(public_key_10),basis_10) else fail-any)) else caught-fail) in
        {1395}let v_466: bool = not-caught-fail(m_17) in
        {1396}let plaintext_26: bitstring = (if v_466 then catch-fail(getpublickey(m_17)) else caught-fail) in
        {1397}let v_467: bool = not-caught-fail(plaintext_26) in
        {1398}let v_468: bitstring = (if v_467 then catch-fail(symmetricstateunpack(ss_68)) else caught-fail) in
        {1399}let v_469: bool = (not-caught-fail(v_468) && success?(1-proj-3-tuple(v_468))) in
        {1400}let h_59: bitstring = (if v_469 then 3-proj-3-tuple(v_468) else caught-fail) in
        {1401}let ck_68: key = (if v_469 then 2-proj-3-tuple(v_468) else caught-fail) in
        {1402}let cs_59: cipherstate = (if v_469 then 1-proj-3-tuple(v_468) else caught-fail) in
        {1403}let v_470: bitstring = (if v_469 then catch-fail(cipherstateunpack(cs_59)) else caught-fail) in
        {1404}let v_471: bool = (not-caught-fail(v_470) && success?(1-proj-2-tuple(v_470))) in
        {1405}let n_36: nonce = (if v_471 then 2-proj-2-tuple(v_470) else caught-fail) in
        {1406}let k_39: key = (if v_471 then 1-proj-2-tuple(v_470) else caught-fail) in
        {1409}let v_472: bitstring = (if v_471 then catch-fail(cipherstateunpack(cs_59)) else caught-fail) in
        {1410}let v_473: bool = (not-caught-fail(v_472) && success?(1-proj-2-tuple(v_472))) in
        {1411}let o_18: nonce = (if v_473 then 2-proj-2-tuple(v_472) else caught-fail) in
        {1412}let k_40: key = (if v_473 then 1-proj-2-tuple(v_472) else caught-fail) in
        {1408}let n_37: nonce = (if v_471 then increment_nonce(n_36) else caught-fail) in
        {1413}let csi_36: cipherstate = (if v_471 then catch-fail((if v_473 then cipherstatepack(k_40,n_37) else fail-any)) else caught-fail) in
        {1414}let v_474: bool = not-caught-fail(csi_36) in
        {1407}let e_27: bitstring = (if v_471 then encrypt(k_39,n_36,h_59,plaintext_26) else caught-fail) in
        {1415}let v_475: bitstring = (if v_469 then catch-fail((if v_471 then (if v_474 then (csi_36,e_27) else fail-any) else fail-any)) else caught-fail) in
        {1416}let v_476: bool = (not-caught-fail(v_475) && success?(1-proj-2-tuple(v_475))) in
        {1417}let ciphertext_27: bitstring = (if v_476 then 2-proj-2-tuple(v_475) else caught-fail) in
        {1418}let csi_37: cipherstate = (if v_476 then 1-proj-2-tuple(v_475) else caught-fail) in
        {1419}let ss_69: symmetricstate = (if v_476 then symmetricstatepack(csi_37,ck_68,h_59) else caught-fail) in
        {1420}let v_477: bitstring = (if v_476 then catch-fail(symmetricstateunpack(ss_69)) else caught-fail) in
        {1421}let v_478: bool = (not-caught-fail(v_477) && success?(1-proj-3-tuple(v_477))) in
        {1422}let h_60: bitstring = (if v_478 then 3-proj-3-tuple(v_477) else caught-fail) in
        {1423}let ck_69: key = (if v_478 then 2-proj-3-tuple(v_477) else caught-fail) in
        {1424}let cs_60: cipherstate = (if v_478 then 1-proj-3-tuple(v_477) else caught-fail) in
        {1425}let ssi_20: symmetricstate = (if v_476 then catch-fail((if v_478 then symmetricstatepack(cs_60,ck_69,hash(h_60,ciphertext_27)) else fail-any)) else caught-fail) in
        {1426}let v_479: bool = not-caught-fail(ssi_20) in
        {1427}let v_480: bitstring = (if v_466 then catch-fail((if v_467 then (if v_469 then (if v_476 then (if v_479 then (ssi_20,ciphertext_27) else fail-any) else fail-any) else fail-any) else fail-any)) else caught-fail) in
        {1428}let v_481: bool = (not-caught-fail(v_480) && success?(1-proj-2-tuple(v_480))) in
        {1429}let nm_7: bitstring = (if v_481 then 2-proj-2-tuple(v_480) else caught-fail) in
        {1430}let ss_70: symmetricstate = (if v_481 then 1-proj-2-tuple(v_480) else caught-fail) in
        {1431}let v_482: bitstring = (if v_481 then catch-fail(keypairunpack(s_15)) else caught-fail) in
        {1432}let v_483: bool = (not-caught-fail(v_482) && success?(1-proj-2-tuple(v_482))) in
        {1433}let my_private_key_9: key = (if v_483 then 2-proj-2-tuple(v_482) else caught-fail) in
        {1434}let my_public_key_9: key = (if v_483 then 1-proj-2-tuple(v_482) else caught-fail) in
        {1435}let input_key_material_11: key = (if v_481 then catch-fail((if v_483 then dhexp(my_private_key_9,re_17) else fail-any)) else caught-fail) in
        {1436}let v_484: bool = not-caught-fail(input_key_material_11) in
        {1437}let v_485: bitstring = (if v_484 then catch-fail(symmetricstateunpack(ss_70)) else caught-fail) in
        {1438}let v_486: bool = (not-caught-fail(v_485) && success?(1-proj-3-tuple(v_485))) in
        {1439}let h_61: bitstring = (if v_486 then 3-proj-3-tuple(v_485) else caught-fail) in
        {1440}let ck_70: key = (if v_486 then 2-proj-3-tuple(v_485) else caught-fail) in
        {1441}let cs_61: cipherstate = (if v_486 then 1-proj-3-tuple(v_485) else caught-fail) in
        {1444}let output3_11: key = (if v_486 then hmac_hash3(ck_70,input_key_material_11) else caught-fail) in
        {1443}let output2_11: key = (if v_486 then hmac_hash2(ck_70,input_key_material_11) else caught-fail) in
        {1442}let output1_11: key = (if v_486 then hmac_hash1(ck_70,input_key_material_11) else caught-fail) in
        {1445}let v_487: bitstring = (if v_486 then catch-fail((output1_11,output2_11,output3_11)) else caught-fail) in
        {1446}let v_488: bool = (not-caught-fail(v_487) && success?(1-proj-3-tuple(v_487))) in
        {1447}let output_9: key = (if v_488 then 3-proj-3-tuple(v_487) else caught-fail) in
        {1448}let temp_k_9: key = (if v_488 then 2-proj-3-tuple(v_487) else caught-fail) in
        {1449}let ck_71: key = (if v_488 then 1-proj-3-tuple(v_487) else caught-fail) in
        {1450}let ss_71: symmetricstate = (if v_481 then catch-fail((if v_484 then (if v_486 then (if v_488 then symmetricstatepack(cipherstatepack(temp_k_9,minnonce),ck_71,h_61) else fail-any) else fail-any) else fail-any)) else caught-fail) in
        {1451}let v_489: bool = not-caught-fail(ss_71) in
        {1452}let v_490: bitstring = (if v_489 then catch-fail(keypairunpack(m_17)) else caught-fail) in
        {1453}let v_491: bool = (not-caught-fail(v_490) && success?(1-proj-2-tuple(v_490))) in
        {1454}let my_private_key_10: key = (if v_491 then 2-proj-2-tuple(v_490) else caught-fail) in
        {1455}let my_public_key_10: key = (if v_491 then 1-proj-2-tuple(v_490) else caught-fail) in
        {1456}let input_key_material_12: key = (if v_489 then catch-fail((if v_491 then dhexp(my_private_key_10,re_17) else fail-any)) else caught-fail) in
        {1457}let v_492: bool = not-caught-fail(input_key_material_12) in
        {1458}let v_493: bitstring = (if v_492 then catch-fail(symmetricstateunpack(ss_71)) else caught-fail) in
        {1459}let v_494: bool = (not-caught-fail(v_493) && success?(1-proj-3-tuple(v_493))) in
        {1460}let h_62: bitstring = (if v_494 then 3-proj-3-tuple(v_493) else caught-fail) in
        {1461}let ck_72: key = (if v_494 then 2-proj-3-tuple(v_493) else caught-fail) in
        {1462}let cs_62: cipherstate = (if v_494 then 1-proj-3-tuple(v_493) else caught-fail) in
        {1465}let output3_12: key = (if v_494 then hmac_hash3(ck_72,input_key_material_12) else caught-fail) in
        {1464}let output2_12: key = (if v_494 then hmac_hash2(ck_72,input_key_material_12) else caught-fail) in
        {1463}let output1_12: key = (if v_494 then hmac_hash1(ck_72,input_key_material_12) else caught-fail) in
        {1466}let v_495: bitstring = (if v_494 then catch-fail((output1_12,output2_12,output3_12)) else caught-fail) in
        {1467}let v_496: bool = (not-caught-fail(v_495) && success?(1-proj-3-tuple(v_495))) in
        {1468}let output_10: key = (if v_496 then 3-proj-3-tuple(v_495) else caught-fail) in
        {1469}let temp_k_10: key = (if v_496 then 2-proj-3-tuple(v_495) else caught-fail) in
        {1470}let ck_73: key = (if v_496 then 1-proj-3-tuple(v_495) else caught-fail) in
        {1471}let ss_72: symmetricstate = (if v_489 then catch-fail((if v_492 then (if v_494 then (if v_496 then symmetricstatepack(cipherstatepack(temp_k_10,minnonce),ck_73,h_62) else fail-any) else fail-any) else fail-any)) else caught-fail) in
        {1472}let v_497: bool = not-caught-fail(ss_72) in
        {1473}let v_498: bitstring = (if v_497 then catch-fail(symmetricstateunpack(ss_72)) else caught-fail) in
        {1474}let v_499: bool = (not-caught-fail(v_498) && success?(1-proj-3-tuple(v_498))) in
        {1475}let h_63: bitstring = (if v_499 then 3-proj-3-tuple(v_498) else caught-fail) in
        {1476}let ck_74: key = (if v_499 then 2-proj-3-tuple(v_498) else caught-fail) in
        {1477}let cs_63: cipherstate = (if v_499 then 1-proj-3-tuple(v_498) else caught-fail) in
        {1478}let v_500: bitstring = (if v_499 then catch-fail(cipherstateunpack(cs_63)) else caught-fail) in
        {1479}let v_501: bool = (not-caught-fail(v_500) && success?(1-proj-2-tuple(v_500))) in
        {1480}let n_38: nonce = (if v_501 then 2-proj-2-tuple(v_500) else caught-fail) in
        {1481}let k_41: key = (if v_501 then 1-proj-2-tuple(v_500) else caught-fail) in
        {1484}let v_502: bitstring = (if v_501 then catch-fail(cipherstateunpack(cs_63)) else caught-fail) in
        {1485}let v_503: bool = (not-caught-fail(v_502) && success?(1-proj-2-tuple(v_502))) in
        {1486}let o_19: nonce = (if v_503 then 2-proj-2-tuple(v_502) else caught-fail) in
        {1487}let k_42: key = (if v_503 then 1-proj-2-tuple(v_502) else caught-fail) in
        {1483}let n_39: nonce = (if v_501 then increment_nonce(n_38) else caught-fail) in
        {1488}let csi_38: cipherstate = (if v_501 then catch-fail((if v_503 then cipherstatepack(k_42,n_39) else fail-any)) else caught-fail) in
        {1489}let v_504: bool = not-caught-fail(csi_38) in
        {1298}let payload_6: bitstring = msg_b(me_2,them_2,sid_3) in
        {1482}let e_28: bitstring = (if v_501 then encrypt(k_41,n_38,h_63,payload_6) else caught-fail) in
        {1490}let v_505: bitstring = (if v_499 then catch-fail((if v_501 then (if v_504 then (csi_38,e_28) else fail-any) else fail-any)) else caught-fail) in
        {1491}let v_506: bool = (not-caught-fail(v_505) && success?(1-proj-2-tuple(v_505))) in
        {1492}let ciphertext_28: bitstring = (if v_506 then 2-proj-2-tuple(v_505) else caught-fail) in
        {1493}let csi_39: cipherstate = (if v_506 then 1-proj-2-tuple(v_505) else caught-fail) in
        {1494}let ss_73: symmetricstate = (if v_506 then symmetricstatepack(csi_39,ck_74,h_63) else caught-fail) in
        {1495}let v_507: bitstring = (if v_506 then catch-fail(symmetricstateunpack(ss_73)) else caught-fail) in
        {1496}let v_508: bool = (not-caught-fail(v_507) && success?(1-proj-3-tuple(v_507))) in
        {1497}let h_64: bitstring = (if v_508 then 3-proj-3-tuple(v_507) else caught-fail) in
        {1498}let ck_75: key = (if v_508 then 2-proj-3-tuple(v_507) else caught-fail) in
        {1499}let cs_64: cipherstate = (if v_508 then 1-proj-3-tuple(v_507) else caught-fail) in
        {1500}let ssi_21: symmetricstate = (if v_506 then catch-fail((if v_508 then symmetricstatepack(cs_64,ck_75,hash(h_64,ciphertext_28)) else fail-any)) else caught-fail) in
        {1501}let v_509: bool = not-caught-fail(ssi_21) in
        {1502}let v_510: bitstring = (if v_497 then catch-fail((if v_499 then (if v_506 then (if v_509 then (ssi_21,ciphertext_28) else fail-any) else fail-any) else fail-any)) else caught-fail) in
        {1503}let v_511: bool = (not-caught-fail(v_510) && success?(1-proj-2-tuple(v_510))) in
        {1504}let ciphertext_29: bitstring = (if v_511 then 2-proj-2-tuple(v_510) else caught-fail) in
        {1505}let ss_74: symmetricstate = (if v_511 then 1-proj-2-tuple(v_510) else caught-fail) in
        {1507}let message_buffer_6: bitstring = (if v_511 then concat4(ne_18,ns_12,nm_7,ciphertext_29) else caught-fail) in
        {1506}let hs_41: handshakestate = (if v_511 then handshakestatepack(ss_74,s_15,m_17,e_25,rs_16,rm_16,re_17,psk_14,initiator_12) else caught-fail) in
        {1508}let (hs_42: handshakestate,message_b_2: bitstring) = (if v_431 then (if v_433 then (if v_435 then (if v_436 then (if v_439 then (if v_447 then (if v_449 then (if v_464 then (if v_466 then (if v_481 then (if v_489 then (if v_497 then (if v_511 then (hs_41,message_buffer_6) else fail-any) else fail-any) else fail-any) else fail-any) else fail-any) else fail-any) else fail-any) else fail-any) else fail-any) else fail-any) else fail-any) else fail-any) else fail-any) in
        {1509}event SendMsg(me_2,them_2,stagepack_b(sid_3),msg_b(me_2,them_2,sid_3));
        {1510}insert statestore(me_2,them_2,sid_3,statepack_c(hs_42));
        {1511}out(pub, message_b_2)
    ) | (
        {1667}get statestore(=me_2,=them_2,=sid_3,statepack_c(hs_43: handshakestate)) in
        {1513}in(pub, message_c_2: bitstring);
        {1514}let v_512: bitstring = catch-fail(handshakestateunpack(hs_43)) in
        {1515}let v_513: bool = (not-caught-fail(v_512) && success?(1-proj-9-tuple(v_512))) in
        {1516}let initiator_13: bool = (if v_513 then 9-proj-9-tuple(v_512) else caught-fail) in
        {1517}let psk_15: key = (if v_513 then 8-proj-9-tuple(v_512) else caught-fail) in
        {1518}let re_18: key = (if v_513 then 7-proj-9-tuple(v_512) else caught-fail) in
        {1519}let rm_17: key = (if v_513 then 6-proj-9-tuple(v_512) else caught-fail) in
        {1520}let rs_17: key = (if v_513 then 5-proj-9-tuple(v_512) else caught-fail) in
        {1521}let e_29: keypair = (if v_513 then 4-proj-9-tuple(v_512) else caught-fail) in
        {1522}let m_18: keypair = (if v_513 then 3-proj-9-tuple(v_512) else caught-fail) in
        {1523}let s_16: keypair = (if v_513 then 2-proj-9-tuple(v_512) else caught-fail) in
        {1524}let ss_75: symmetricstate = (if v_513 then 1-proj-9-tuple(v_512) else caught-fail) in
        {1525}let v_514: bitstring = (if v_513 then catch-fail(deconcat3(message_c_2)) else caught-fail) in
        {1526}let v_515: bool = (not-caught-fail(v_514) && success?(1-proj-3-tuple(v_514))) in
        {1527}let ciphertext_30: bitstring = (if v_515 then 3-proj-3-tuple(v_514) else caught-fail) in
        {1528}let nm_8: bitstring = (if v_515 then 2-proj-3-tuple(v_514) else caught-fail) in
        {1529}let ne_19: bitstring = (if v_515 then 1-proj-3-tuple(v_514) else caught-fail) in
        {1531}let v_516: bitstring = (if v_515 then catch-fail(symmetricstateunpack(ss_75)) else caught-fail) in
        {1532}let v_517: bool = (not-caught-fail(v_516) && success?(1-proj-3-tuple(v_516))) in
        {1533}let h_65: bitstring = (if v_517 then 3-proj-3-tuple(v_516) else caught-fail) in
        {1534}let ck_76: key = (if v_517 then 2-proj-3-tuple(v_516) else caught-fail) in
        {1535}let cs_65: cipherstate = (if v_517 then 1-proj-3-tuple(v_516) else caught-fail) in
        {1536}let v_518: bitstring = (if v_517 then catch-fail(cipherstateunpack(cs_65)) else caught-fail) in
        {1537}let v_519: bool = (not-caught-fail(v_518) && success?(1-proj-2-tuple(v_518))) in
        {1538}let n_40: nonce = (if v_519 then 2-proj-2-tuple(v_518) else caught-fail) in
        {1539}let k_43: key = (if v_519 then 1-proj-2-tuple(v_518) else caught-fail) in
        {1540}let d_9: aead = (if v_519 then catch-fail(decrypt(k_43,n_40,h_65,nm_8)) else caught-fail) in
        {1541}let v_520: bool = not-caught-fail(d_9) in
        {1542}let v_521: bitstring = (if v_520 then catch-fail(aeadunpack(d_9)) else caught-fail) in
        {1543}let v_522: bool = (not-caught-fail(v_521) && success?(1-proj-3-tuple(v_521))) in
        {1544}let plaintext_27: bitstring = (if v_522 then 3-proj-3-tuple(v_521) else caught-fail) in
        {1545}let adi_9: bitstring = (if v_522 then 2-proj-3-tuple(v_521) else caught-fail) in
        {1546}let valid_23: bool = (if v_522 then 1-proj-3-tuple(v_521) else caught-fail) in
        {1548}let v_523: bitstring = (if v_522 then catch-fail(cipherstateunpack(cs_65)) else caught-fail) in
        {1549}let v_524: bool = (not-caught-fail(v_523) && success?(1-proj-2-tuple(v_523))) in
        {1550}let o_20: nonce = (if v_524 then 2-proj-2-tuple(v_523) else caught-fail) in
        {1551}let k_44: key = (if v_524 then 1-proj-2-tuple(v_523) else caught-fail) in
        {1547}let n_41: nonce = (if v_522 then increment_nonce(n_40) else caught-fail) in
        {1552}let csi_40: cipherstate = (if v_522 then catch-fail((if v_524 then cipherstatepack(k_44,n_41) else fail-any)) else caught-fail) in
        {1553}let v_525: bool = not-caught-fail(csi_40) in
        {1554}let v_526: bitstring = (if v_517 then catch-fail((if v_519 then (if v_520 then (if v_522 then (if v_525 then (csi_40,plaintext_27,valid_23) else fail-any) else fail-any) else fail-any) else fail-any)) else caught-fail) in
        {1555}let v_527: bool = (not-caught-fail(v_526) && success?(1-proj-3-tuple(v_526))) in
        {1556}let valid_24: bool = (if v_527 then 3-proj-3-tuple(v_526) else caught-fail) in
        {1557}let plaintext_28: bitstring = (if v_527 then 2-proj-3-tuple(v_526) else caught-fail) in
        {1558}let csi_41: cipherstate = (if v_527 then 1-proj-3-tuple(v_526) else caught-fail) in
        {1559}let ss_76: symmetricstate = (if v_527 then symmetricstatepack(csi_41,ck_76,h_65) else caught-fail) in
        {1560}let v_528: bitstring = (if v_527 then catch-fail(symmetricstateunpack(ss_76)) else caught-fail) in
        {1561}let v_529: bool = (not-caught-fail(v_528) && success?(1-proj-3-tuple(v_528))) in
        {1562}let h_66: bitstring = (if v_529 then 3-proj-3-tuple(v_528) else caught-fail) in
        {1563}let ck_77: key = (if v_529 then 2-proj-3-tuple(v_528) else caught-fail) in
        {1564}let cs_66: cipherstate = (if v_529 then 1-proj-3-tuple(v_528) else caught-fail) in
        {1565}let ssi_22: symmetricstate = (if v_527 then catch-fail((if v_529 then symmetricstatepack(cs_66,ck_77,hash(h_66,nm_8)) else fail-any)) else caught-fail) in
        {1566}let v_530: bool = not-caught-fail(ssi_22) in
        {1567}let v_531: bitstring = (if v_515 then catch-fail((if v_517 then (if v_527 then (if v_530 then (ssi_22,plaintext_28,valid_24) else fail-any) else fail-any) else fail-any)) else caught-fail) in
        {1568}let v_532: bool = (not-caught-fail(v_531) && success?(1-proj-3-tuple(v_531))) in
        {1569}let valid2_5: bool = (if v_532 then 3-proj-3-tuple(v_531) else caught-fail) in
        {1570}let nem: bitstring = (if v_532 then 2-proj-3-tuple(v_531) else caught-fail) in
        {1571}let ss_77: symmetricstate = (if v_532 then 1-proj-3-tuple(v_531) else caught-fail) in
        {1573}let v_533: bitstring = (if v_532 then catch-fail(keypairunpack(e_29)) else caught-fail) in
        {1574}let v_534: bool = (not-caught-fail(v_533) && success?(1-proj-2-tuple(v_533))) in
        {1575}let my_private_key_11: key = (if v_534 then 2-proj-2-tuple(v_533) else caught-fail) in
        {1576}let my_public_key_11: key = (if v_534 then 1-proj-2-tuple(v_533) else caught-fail) in
        {1572}let rm_18: key = (if v_532 then nem else caught-fail) in
        {1577}let input_key_material_13: key = (if v_532 then catch-fail((if v_534 then dhexp(my_private_key_11,rm_18) else fail-any)) else caught-fail) in
        {1578}let v_535: bool = not-caught-fail(input_key_material_13) in
        {1579}let v_536: bitstring = (if v_535 then catch-fail(symmetricstateunpack(ss_77)) else caught-fail) in
        {1580}let v_537: bool = (not-caught-fail(v_536) && success?(1-proj-3-tuple(v_536))) in
        {1581}let h_67: bitstring = (if v_537 then 3-proj-3-tuple(v_536) else caught-fail) in
        {1582}let ck_78: key = (if v_537 then 2-proj-3-tuple(v_536) else caught-fail) in
        {1583}let cs_67: cipherstate = (if v_537 then 1-proj-3-tuple(v_536) else caught-fail) in
        {1586}let output3_13: key = (if v_537 then hmac_hash3(ck_78,input_key_material_13) else caught-fail) in
        {1585}let output2_13: key = (if v_537 then hmac_hash2(ck_78,input_key_material_13) else caught-fail) in
        {1584}let output1_13: key = (if v_537 then hmac_hash1(ck_78,input_key_material_13) else caught-fail) in
        {1587}let v_538: bitstring = (if v_537 then catch-fail((output1_13,output2_13,output3_13)) else caught-fail) in
        {1588}let v_539: bool = (not-caught-fail(v_538) && success?(1-proj-3-tuple(v_538))) in
        {1589}let output_11: key = (if v_539 then 3-proj-3-tuple(v_538) else caught-fail) in
        {1590}let temp_k_11: key = (if v_539 then 2-proj-3-tuple(v_538) else caught-fail) in
        {1591}let ck_79: key = (if v_539 then 1-proj-3-tuple(v_538) else caught-fail) in
        {1592}let ss_78: symmetricstate = (if v_532 then catch-fail((if v_535 then (if v_537 then (if v_539 then symmetricstatepack(cipherstatepack(temp_k_11,minnonce),ck_79,h_67) else fail-any) else fail-any) else fail-any)) else caught-fail) in
        {1593}let v_540: bool = not-caught-fail(ss_78) in
        {1594}let v_541: bitstring = (if v_540 then catch-fail(symmetricstateunpack(ss_78)) else caught-fail) in
        {1595}let v_542: bool = (not-caught-fail(v_541) && success?(1-proj-3-tuple(v_541))) in
        {1596}let h_68: bitstring = (if v_542 then 3-proj-3-tuple(v_541) else caught-fail) in
        {1597}let ck_80: key = (if v_542 then 2-proj-3-tuple(v_541) else caught-fail) in
        {1598}let cs_68: cipherstate = (if v_542 then 1-proj-3-tuple(v_541) else caught-fail) in
        {1599}let v_543: bitstring = (if v_542 then catch-fail(cipherstateunpack(cs_68)) else caught-fail) in
        {1600}let v_544: bool = (not-caught-fail(v_543) && success?(1-proj-2-tuple(v_543))) in
        {1601}let n_42: nonce = (if v_544 then 2-proj-2-tuple(v_543) else caught-fail) in
        {1602}let k_45: key = (if v_544 then 1-proj-2-tuple(v_543) else caught-fail) in
        {1603}let d_10: aead = (if v_544 then catch-fail(decrypt(k_45,n_42,h_68,ciphertext_30)) else caught-fail) in
        {1604}let v_545: bool = not-caught-fail(d_10) in
        {1605}let v_546: bitstring = (if v_545 then catch-fail(aeadunpack(d_10)) else caught-fail) in
        {1606}let v_547: bool = (not-caught-fail(v_546) && success?(1-proj-3-tuple(v_546))) in
        {1607}let plaintext_29: bitstring = (if v_547 then 3-proj-3-tuple(v_546) else caught-fail) in
        {1608}let adi_10: bitstring = (if v_547 then 2-proj-3-tuple(v_546) else caught-fail) in
        {1609}let valid_25: bool = (if v_547 then 1-proj-3-tuple(v_546) else caught-fail) in
        {1611}let v_548: bitstring = (if v_547 then catch-fail(cipherstateunpack(cs_68)) else caught-fail) in
        {1612}let v_549: bool = (not-caught-fail(v_548) && success?(1-proj-2-tuple(v_548))) in
        {1613}let o_21: nonce = (if v_549 then 2-proj-2-tuple(v_548) else caught-fail) in
        {1614}let k_46: key = (if v_549 then 1-proj-2-tuple(v_548) else caught-fail) in
        {1610}let n_43: nonce = (if v_547 then increment_nonce(n_42) else caught-fail) in
        {1615}let csi_42: cipherstate = (if v_547 then catch-fail((if v_549 then cipherstatepack(k_46,n_43) else fail-any)) else caught-fail) in
        {1616}let v_550: bool = not-caught-fail(csi_42) in
        {1617}let v_551: bitstring = (if v_542 then catch-fail((if v_544 then (if v_545 then (if v_547 then (if v_550 then (csi_42,plaintext_29,valid_25) else fail-any) else fail-any) else fail-any) else fail-any)) else caught-fail) in
        {1618}let v_552: bool = (not-caught-fail(v_551) && success?(1-proj-3-tuple(v_551))) in
        {1619}let valid_26: bool = (if v_552 then 3-proj-3-tuple(v_551) else caught-fail) in
        {1620}let plaintext_30: bitstring = (if v_552 then 2-proj-3-tuple(v_551) else caught-fail) in
        {1621}let csi_43: cipherstate = (if v_552 then 1-proj-3-tuple(v_551) else caught-fail) in
        {1622}let ss_79: symmetricstate = (if v_552 then symmetricstatepack(csi_43,ck_80,h_68) else caught-fail) in
        {1623}let v_553: bitstring = (if v_552 then catch-fail(symmetricstateunpack(ss_79)) else caught-fail) in
        {1624}let v_554: bool = (not-caught-fail(v_553) && success?(1-proj-3-tuple(v_553))) in
        {1625}let h_69: bitstring = (if v_554 then 3-proj-3-tuple(v_553) else caught-fail) in
        {1626}let ck_81: key = (if v_554 then 2-proj-3-tuple(v_553) else caught-fail) in
        {1627}let cs_69: cipherstate = (if v_554 then 1-proj-3-tuple(v_553) else caught-fail) in
        {1628}let ssi_23: symmetricstate = (if v_552 then catch-fail((if v_554 then symmetricstatepack(cs_69,ck_81,hash(h_69,ciphertext_30)) else fail-any)) else caught-fail) in
        {1629}let v_555: bool = not-caught-fail(ssi_23) in
        {1630}let v_556: bitstring = (if v_540 then catch-fail((if v_542 then (if v_552 then (if v_555 then (ssi_23,plaintext_30,valid_26) else fail-any) else fail-any) else fail-any)) else caught-fail) in
        {1631}let v_557: bool = (not-caught-fail(v_556) && success?(1-proj-3-tuple(v_556))) in
        {1632}let valid3_2: bool = (if v_557 then 3-proj-3-tuple(v_556) else caught-fail) in
        {1633}let plaintext_31: bitstring = (if v_557 then 2-proj-3-tuple(v_556) else caught-fail) in
        {1634}let ss_80: symmetricstate = (if v_557 then 1-proj-3-tuple(v_556) else caught-fail) in
        {1638}let basis_12: key = (if v_557 then key_m(them_2) else caught-fail) in
        {1639}let public_key_12: key = (if v_557 then catch-fail(dhexp(basis_12,validkey(g))) else caught-fail) in
        {1640}let v_559: bool = not-caught-fail(public_key_12) in
        {1635}let basis_11: key = (if v_557 then key_s(them_2) else caught-fail) in
        {1636}let public_key_11: key = (if v_557 then catch-fail(dhexp(basis_11,validkey(g))) else caught-fail) in
        {1637}let v_558: bool = not-caught-fail(public_key_11) in
        {1530}let valid1_7: bool = (if v_515 then true else caught-fail) in
        {1641}let v_560: bool = (if v_557 then catch-fail(((valid1_7 && (valid2_5 && valid3_2)) && ((rs_17 = getpublickey((if v_558 then keypairpack(validkey(public_key_11),basis_11) else fail-any))) && (rm_18 = getpublickey((if v_559 then keypairpack(validkey(public_key_12),basis_12) else fail-any)))))) else caught-fail) in
        {1643}let v_561: bitstring = (if v_560 then catch-fail(symmetricstateunpack(ss_80)) else caught-fail) in
        {1644}let v_562: bool = (not-caught-fail(v_561) && success?(1-proj-3-tuple(v_561))) in
        {1645}let h_70: bitstring = (if v_562 then 3-proj-3-tuple(v_561) else caught-fail) in
        {1646}let ck_82: key = (if v_562 then 2-proj-3-tuple(v_561) else caught-fail) in
        {1647}let cs_70: cipherstate = (if v_562 then 1-proj-3-tuple(v_561) else caught-fail) in
        {1648}let input_key_material_14: key = (if v_562 then zero else caught-fail) in
        {1651}let output3_14: key = (if v_562 then hmac_hash3(ck_82,input_key_material_14) else caught-fail) in
        {1650}let output2_14: key = (if v_562 then hmac_hash2(ck_82,input_key_material_14) else caught-fail) in
        {1649}let output1_14: key = (if v_562 then hmac_hash1(ck_82,input_key_material_14) else caught-fail) in
        {1652}let v_563: bitstring = (if v_562 then catch-fail((output1_14,output2_14,output3_14)) else caught-fail) in
        {1653}let v_564: bool = (not-caught-fail(v_563) && success?(1-proj-3-tuple(v_563))) in
        {1654}let temp_k3_2: key = (if v_564 then 3-proj-3-tuple(v_563) else caught-fail) in
        {1655}let temp_k2_2: key = (if v_564 then 2-proj-3-tuple(v_563) else caught-fail) in
        {1656}let temp_k1_2: key = (if v_564 then 1-proj-3-tuple(v_563) else caught-fail) in
        {1658}let cs2_10: cipherstate = (if v_564 then cipherstatepack(temp_k2_2,minnonce) else caught-fail) in
        {1657}let cs1_10: cipherstate = (if v_564 then cipherstatepack(temp_k1_2,minnonce) else caught-fail) in
        {1659}let v_565: bitstring = (if v_560 then catch-fail((if v_562 then (if v_564 then (ss_80,cs1_10,cs2_10) else fail-any) else fail-any)) else caught-fail) in
        {1660}let v_566: bool = (not-caught-fail(v_565) && success?(1-proj-3-tuple(v_565))) in
        {1661}let cs2_11: cipherstate = (if v_566 then 3-proj-3-tuple(v_565) else caught-fail) in
        {1662}let cs1_11: cipherstate = (if v_566 then 2-proj-3-tuple(v_565) else caught-fail) in
        {1663}let ssi_24: symmetricstate = (if v_566 then 1-proj-3-tuple(v_565) else caught-fail) in
        {1642}let hs_44: handshakestate = (if v_560 then handshakestatepack(ss_80,s_16,m_18,e_29,rs_17,rm_18,re_18,psk_15,initiator_13) else caught-fail) in
        {1664}let (hs_45: handshakestate,plaintext_c: bitstring,valid_27: bool,cs1_12: cipherstate,cs2_12: cipherstate) = (if v_513 then (if v_515 then (if v_532 then (if v_540 then (if v_557 then (if undo-catch-fail(v_560) then (if v_566 then (hs_44,plaintext_31,true,cs1_11,cs2_11) else fail-any) else fail-any) else fail-any) else fail-any) else fail-any) else fail-any) else fail-any) in
        {1665}event RecvMsg(me_2,them_2,stagepack_c(sid_3),plaintext_c);
        {1666}insert statestore(me_2,them_2,sid_3,statepack_d(hs_45,cs1_12,cs2_12))
    ) | (
        {1668}!
        {1726}get statestore(=me_2,=them_2,=sid_3,statepack_d(hs_46: handshakestate,cs1_13: cipherstate,cs2_13: cipherstate)) in
        {1669}let hs_47: handshakestate = handshakestatesetcs(hs_46,cs2_13) in
        {1671}let v_567: bitstring = catch-fail(handshakestateunpack(hs_47)) in
        {1672}let v_568: bool = (not-caught-fail(v_567) && success?(1-proj-9-tuple(v_567))) in
        {1673}let initiator_14: bool = (if v_568 then 9-proj-9-tuple(v_567) else caught-fail) in
        {1674}let psk_16: key = (if v_568 then 8-proj-9-tuple(v_567) else caught-fail) in
        {1675}let re_19: key = (if v_568 then 7-proj-9-tuple(v_567) else caught-fail) in
        {1676}let rm_19: key = (if v_568 then 6-proj-9-tuple(v_567) else caught-fail) in
        {1677}let rs_18: key = (if v_568 then 5-proj-9-tuple(v_567) else caught-fail) in
        {1678}let e_30: keypair = (if v_568 then 4-proj-9-tuple(v_567) else caught-fail) in
        {1679}let m_19: keypair = (if v_568 then 3-proj-9-tuple(v_567) else caught-fail) in
        {1680}let s_17: keypair = (if v_568 then 2-proj-9-tuple(v_567) else caught-fail) in
        {1681}let ss_81: symmetricstate = (if v_568 then 1-proj-9-tuple(v_567) else caught-fail) in
        {1682}let v_569: bitstring = (if v_568 then catch-fail((empty,empty,empty)) else caught-fail) in
        {1683}let v_570: bool = (not-caught-fail(v_569) && success?(1-proj-3-tuple(v_569))) in
        {1684}let ciphertext_31: bitstring = (if v_570 then 3-proj-3-tuple(v_569) else caught-fail) in
        {1685}let ns_13: bitstring = (if v_570 then 2-proj-3-tuple(v_569) else caught-fail) in
        {1686}let ne_20: bitstring = (if v_570 then 1-proj-3-tuple(v_569) else caught-fail) in
        {1687}let v_571: bitstring = (if v_570 then catch-fail(symmetricstateunpack(ss_81)) else caught-fail) in
        {1688}let v_572: bool = (not-caught-fail(v_571) && success?(1-proj-3-tuple(v_571))) in
        {1689}let h_71: bitstring = (if v_572 then 3-proj-3-tuple(v_571) else caught-fail) in
        {1690}let ck_83: key = (if v_572 then 2-proj-3-tuple(v_571) else caught-fail) in
        {1691}let cs_71: cipherstate = (if v_572 then 1-proj-3-tuple(v_571) else caught-fail) in
        {1692}let v_573: bitstring = (if v_572 then catch-fail(cipherstateunpack(cs_71)) else caught-fail) in
        {1693}let v_574: bool = (not-caught-fail(v_573) && success?(1-proj-2-tuple(v_573))) in
        {1694}let n_44: nonce = (if v_574 then 2-proj-2-tuple(v_573) else caught-fail) in
        {1695}let k_47: key = (if v_574 then 1-proj-2-tuple(v_573) else caught-fail) in
        {1698}let v_575: bitstring = (if v_574 then catch-fail(cipherstateunpack(cs_71)) else caught-fail) in
        {1699}let v_576: bool = (not-caught-fail(v_575) && success?(1-proj-2-tuple(v_575))) in
        {1700}let o_22: nonce = (if v_576 then 2-proj-2-tuple(v_575) else caught-fail) in
        {1701}let k_48: key = (if v_576 then 1-proj-2-tuple(v_575) else caught-fail) in
        {1697}let n_45: nonce = (if v_574 then increment_nonce(n_44) else caught-fail) in
        {1702}let csi_44: cipherstate = (if v_574 then catch-fail((if v_576 then cipherstatepack(k_48,n_45) else fail-any)) else caught-fail) in
        {1703}let v_577: bool = not-caught-fail(csi_44) in
        {1670}let payload_7: bitstring = msg_d(me_2,them_2,sid_3) in
        {1696}let e_31: bitstring = (if v_574 then encrypt(k_47,n_44,h_71,payload_7) else caught-fail) in
        {1704}let v_578: bitstring = (if v_572 then catch-fail((if v_574 then (if v_577 then (csi_44,e_31) else fail-any) else fail-any)) else caught-fail) in
        {1705}let v_579: bool = (not-caught-fail(v_578) && success?(1-proj-2-tuple(v_578))) in
        {1706}let ciphertext_32: bitstring = (if v_579 then 2-proj-2-tuple(v_578) else caught-fail) in
        {1707}let csi_45: cipherstate = (if v_579 then 1-proj-2-tuple(v_578) else caught-fail) in
        {1708}let ss_82: symmetricstate = (if v_579 then symmetricstatepack(csi_45,ck_83,h_71) else caught-fail) in
        {1709}let v_580: bitstring = (if v_579 then catch-fail(symmetricstateunpack(ss_82)) else caught-fail) in
        {1710}let v_581: bool = (not-caught-fail(v_580) && success?(1-proj-3-tuple(v_580))) in
        {1711}let h_72: bitstring = (if v_581 then 3-proj-3-tuple(v_580) else caught-fail) in
        {1712}let ck_84: key = (if v_581 then 2-proj-3-tuple(v_580) else caught-fail) in
        {1713}let cs_72: cipherstate = (if v_581 then 1-proj-3-tuple(v_580) else caught-fail) in
        {1714}let ssi_25: symmetricstate = (if v_579 then catch-fail((if v_581 then symmetricstatepack(cs_72,ck_84,hash(h_72,ciphertext_32)) else fail-any)) else caught-fail) in
        {1715}let v_582: bool = not-caught-fail(ssi_25) in
        {1716}let v_583: bitstring = (if v_570 then catch-fail((if v_572 then (if v_579 then (if v_582 then (ssi_25,ciphertext_32) else fail-any) else fail-any) else fail-any)) else caught-fail) in
        {1717}let v_584: bool = (not-caught-fail(v_583) && success?(1-proj-2-tuple(v_583))) in
        {1718}let ciphertext_33: bitstring = (if v_584 then 2-proj-2-tuple(v_583) else caught-fail) in
        {1719}let ss_83: symmetricstate = (if v_584 then 1-proj-2-tuple(v_583) else caught-fail) in
        {1721}let message_buffer_7: bitstring = (if v_584 then concat3(ne_20,ns_13,ciphertext_33) else caught-fail) in
        {1720}let hs_48: handshakestate = (if v_584 then handshakestatepack(ss_83,s_17,m_19,e_30,rs_18,rm_19,re_19,psk_16,initiator_14) else caught-fail) in
        {1722}let (hs_49: handshakestate,message_d_2: bitstring) = (if v_568 then (if v_570 then (if v_584 then (hs_48,message_buffer_7) else fail-any) else fail-any) else fail-any) in
        {1723}event SendMsg(me_2,them_2,stagepack_d(sid_3),msg_d(me_2,them_2,sid_3));
        {1724}insert statestore(me_2,them_2,sid_3,statepack_e(hs_49,cs1_13,handshakestategetcs(hs_49)));
        {1725}out(pub, message_d_2)
    ) | (
        {1727}!
        {1793}get statestore(=me_2,=them_2,=sid_3,statepack_e(hs_50: handshakestate,cs1_14: cipherstate,cs2_14: cipherstate)) in
        {1728}let hs_51: handshakestate = handshakestatesetcs(hs_50,cs1_14) in
        {1729}in(pub, message_e_2: bitstring);
        {1730}let v_585: bitstring = catch-fail(handshakestateunpack(hs_51)) in
        {1731}let v_586: bool = (not-caught-fail(v_585) && success?(1-proj-9-tuple(v_585))) in
        {1732}let initiator_15: bool = (if v_586 then 9-proj-9-tuple(v_585) else caught-fail) in
        {1733}let psk_17: key = (if v_586 then 8-proj-9-tuple(v_585) else caught-fail) in
        {1734}let re_20: key = (if v_586 then 7-proj-9-tuple(v_585) else caught-fail) in
        {1735}let rm_20: key = (if v_586 then 6-proj-9-tuple(v_585) else caught-fail) in
        {1736}let rs_19: key = (if v_586 then 5-proj-9-tuple(v_585) else caught-fail) in
        {1737}let e_32: keypair = (if v_586 then 4-proj-9-tuple(v_585) else caught-fail) in
        {1738}let m_20: keypair = (if v_586 then 3-proj-9-tuple(v_585) else caught-fail) in
        {1739}let s_18: keypair = (if v_586 then 2-proj-9-tuple(v_585) else caught-fail) in
        {1740}let ss_84: symmetricstate = (if v_586 then 1-proj-9-tuple(v_585) else caught-fail) in
        {1741}let v_587: bitstring = (if v_586 then catch-fail(deconcat3(message_e_2)) else caught-fail) in
        {1742}let v_588: bool = (not-caught-fail(v_587) && success?(1-proj-3-tuple(v_587))) in
        {1743}let ciphertext_34: bitstring = (if v_588 then 3-proj-3-tuple(v_587) else caught-fail) in
        {1744}let ns_14: bitstring = (if v_588 then 2-proj-3-tuple(v_587) else caught-fail) in
        {1745}let ne_21: bitstring = (if v_588 then 1-proj-3-tuple(v_587) else caught-fail) in
        {1747}let v_589: bitstring = (if v_588 then catch-fail(symmetricstateunpack(ss_84)) else caught-fail) in
        {1748}let v_590: bool = (not-caught-fail(v_589) && success?(1-proj-3-tuple(v_589))) in
        {1749}let h_73: bitstring = (if v_590 then 3-proj-3-tuple(v_589) else caught-fail) in
        {1750}let ck_85: key = (if v_590 then 2-proj-3-tuple(v_589) else caught-fail) in
        {1751}let cs_73: cipherstate = (if v_590 then 1-proj-3-tuple(v_589) else caught-fail) in
        {1752}let v_591: bitstring = (if v_590 then catch-fail(cipherstateunpack(cs_73)) else caught-fail) in
        {1753}let v_592: bool = (not-caught-fail(v_591) && success?(1-proj-2-tuple(v_591))) in
        {1754}let n_46: nonce = (if v_592 then 2-proj-2-tuple(v_591) else caught-fail) in
        {1755}let k_49: key = (if v_592 then 1-proj-2-tuple(v_591) else caught-fail) in
        {1756}let d_11: aead = (if v_592 then catch-fail(decrypt(k_49,n_46,h_73,ciphertext_34)) else caught-fail) in
        {1757}let v_593: bool = not-caught-fail(d_11) in
        {1758}let v_594: bitstring = (if v_593 then catch-fail(aeadunpack(d_11)) else caught-fail) in
        {1759}let v_595: bool = (not-caught-fail(v_594) && success?(1-proj-3-tuple(v_594))) in
        {1760}let plaintext_32: bitstring = (if v_595 then 3-proj-3-tuple(v_594) else caught-fail) in
        {1761}let adi_11: bitstring = (if v_595 then 2-proj-3-tuple(v_594) else caught-fail) in
        {1762}let valid_28: bool = (if v_595 then 1-proj-3-tuple(v_594) else caught-fail) in
        {1764}let v_596: bitstring = (if v_595 then catch-fail(cipherstateunpack(cs_73)) else caught-fail) in
        {1765}let v_597: bool = (not-caught-fail(v_596) && success?(1-proj-2-tuple(v_596))) in
        {1766}let o_23: nonce = (if v_597 then 2-proj-2-tuple(v_596) else caught-fail) in
        {1767}let k_50: key = (if v_597 then 1-proj-2-tuple(v_596) else caught-fail) in
        {1763}let n_47: nonce = (if v_595 then increment_nonce(n_46) else caught-fail) in
        {1768}let csi_46: cipherstate = (if v_595 then catch-fail((if v_597 then cipherstatepack(k_50,n_47) else fail-any)) else caught-fail) in
        {1769}let v_598: bool = not-caught-fail(csi_46) in
        {1770}let v_599: bitstring = (if v_590 then catch-fail((if v_592 then (if v_593 then (if v_595 then (if v_598 then (csi_46,plaintext_32,valid_28) else fail-any) else fail-any) else fail-any) else fail-any)) else caught-fail) in
        {1771}let v_600: bool = (not-caught-fail(v_599) && success?(1-proj-3-tuple(v_599))) in
        {1772}let valid_29: bool = (if v_600 then 3-proj-3-tuple(v_599) else caught-fail) in
        {1773}let plaintext_33: bitstring = (if v_600 then 2-proj-3-tuple(v_599) else caught-fail) in
        {1774}let csi_47: cipherstate = (if v_600 then 1-proj-3-tuple(v_599) else caught-fail) in
        {1775}let ss_85: symmetricstate = (if v_600 then symmetricstatepack(csi_47,ck_85,h_73) else caught-fail) in
        {1776}let v_601: bitstring = (if v_600 then catch-fail(symmetricstateunpack(ss_85)) else caught-fail) in
        {1777}let v_602: bool = (not-caught-fail(v_601) && success?(1-proj-3-tuple(v_601))) in
        {1778}let h_74: bitstring = (if v_602 then 3-proj-3-tuple(v_601) else caught-fail) in
        {1779}let ck_86: key = (if v_602 then 2-proj-3-tuple(v_601) else caught-fail) in
        {1780}let cs_74: cipherstate = (if v_602 then 1-proj-3-tuple(v_601) else caught-fail) in
        {1781}let ssi_26: symmetricstate = (if v_600 then catch-fail((if v_602 then symmetricstatepack(cs_74,ck_86,hash(h_74,ciphertext_34)) else fail-any)) else caught-fail) in
        {1782}let v_603: bool = not-caught-fail(ssi_26) in
        {1783}let v_604: bitstring = (if v_588 then catch-fail((if v_590 then (if v_600 then (if v_603 then (ssi_26,plaintext_33,valid_29) else fail-any) else fail-any) else fail-any)) else caught-fail) in
        {1784}let v_605: bool = (not-caught-fail(v_604) && success?(1-proj-3-tuple(v_604))) in
        {1785}let valid2_6: bool = (if v_605 then 3-proj-3-tuple(v_604) else caught-fail) in
        {1786}let plaintext_34: bitstring = (if v_605 then 2-proj-3-tuple(v_604) else caught-fail) in
        {1787}let ss_86: symmetricstate = (if v_605 then 1-proj-3-tuple(v_604) else caught-fail) in
        {1746}let valid1_8: bool = (if v_588 then true else caught-fail) in
        {1788}let v_606: bool = (if v_605 then catch-fail((valid1_8 && valid2_6)) else caught-fail) in
        {1789}let hs_52: handshakestate = (if v_606 then handshakestatepack(ss_86,s_18,m_20,e_32,rs_19,rm_20,re_20,psk_17,initiator_15) else caught-fail) in
        {1790}let (hs_53: handshakestate,plaintext_e: bitstring,valid_30: bool) = (if v_586 then (if v_588 then (if v_605 then (if undo-catch-fail(v_606) then (hs_52,plaintext_34,true) else fail-any) else fail-any) else fail-any) else fail-any) in
        {1791}event RecvMsg(me_2,them_2,stagepack_e(sid_3),plaintext_e);
        {1792}event RecvEnd(valid_30)
    ) | (
        {1794}event LeakS(phase0,me_2);
        {1795}event LeakM(phase0,me_2);
        {1796}out(pub, (key_s(me_2),key_m(me_2)))
    ) | (
        {1797}phase 1;
        {1798}event LeakS(phase1,me_2);
        {1799}event LeakM(phase1,me_2);
        {1800}out(pub, (key_s(me_2),key_m(me_2)))
    )
) | (
    {1805}let m_21: keypair = keypairpack(empty,empty) in
    {1804}let s_19: keypair = keypairpack(empty,empty) in
    {1806}out(pub, (getpublickey(s_19),getpublickey(m_21)));
    {1803}let sid_4: sessionid = sid in
    {1802}let them_3: principal = charlie in
    {1801}let me_3: principal = bob in
    (
        {1816}let k_51: key = empty in
        {1817}let cs_75: cipherstate = cipherstatepack(k_51,minnonce) in
        {1813}let protocol_name_3: bitstring = somename in
        {1814}let h_75: bitstring = hash(protocol_name_3,empty) in
        {1815}let ck_87: key = h_75 in
        {1818}let ss_87: symmetricstate = symmetricstatepack(cs_75,ck_87,h_75) in
        {1819}let v_607: bitstring = catch-fail(symmetricstateunpack(ss_87)) in
        {1820}let v_608: bool = (not-caught-fail(v_607) && success?(1-proj-3-tuple(v_607))) in
        {1821}let h_76: bitstring = (if v_608 then 3-proj-3-tuple(v_607) else caught-fail) in
        {1822}let ck_88: key = (if v_608 then 2-proj-3-tuple(v_607) else caught-fail) in
        {1823}let cs_76: cipherstate = (if v_608 then 1-proj-3-tuple(v_607) else caught-fail) in
        {1811}let prologue_3: bitstring = empty in
        {1824}let ss_88: symmetricstate = catch-fail((if v_608 then symmetricstatepack(cs_76,ck_88,hash(h_76,prologue_3)) else fail-any)) in
        {1825}let v_609: bool = not-caught-fail(ss_88) in
        {1812}let psk_18: key = empty in
        {1810}let re_21: key = empty in
        {1809}let rm_21: key = empty in
        {1808}let rs_20: key = empty in
        {1807}let e_33: keypair = keypairpack(empty,empty) in
        {1826}let hs_54: handshakestate = (if v_609 then handshakestatepack(ss_88,s_19,m_21,e_33,rs_20,rm_21,re_21,psk_18,false) else fail-any) in
        {1827}insert statestore(me_3,them_3,sid_4,statepack_a(hs_54))
    ) | (
        {1900}get statestore(=me_3,=them_3,=sid_4,statepack_a(hs_55: handshakestate)) in
        {1828}in(pub, message_a_3: bitstring);
        {1829}let v_610: bitstring = catch-fail(handshakestateunpack(hs_55)) in
        {1830}let v_611: bool = (not-caught-fail(v_610) && success?(1-proj-9-tuple(v_610))) in
        {1831}let initiator_16: bool = (if v_611 then 9-proj-9-tuple(v_610) else caught-fail) in
        {1832}let psk_19: key = (if v_611 then 8-proj-9-tuple(v_610) else caught-fail) in
        {1833}let re_22: key = (if v_611 then 7-proj-9-tuple(v_610) else caught-fail) in
        {1834}let rm_22: key = (if v_611 then 6-proj-9-tuple(v_610) else caught-fail) in
        {1835}let rs_21: key = (if v_611 then 5-proj-9-tuple(v_610) else caught-fail) in
        {1836}let e_34: keypair = (if v_611 then 4-proj-9-tuple(v_610) else caught-fail) in
        {1837}let m_22: keypair = (if v_611 then 3-proj-9-tuple(v_610) else caught-fail) in
        {1838}let s_20: keypair = (if v_611 then 2-proj-9-tuple(v_610) else caught-fail) in
        {1839}let ss_89: symmetricstate = (if v_611 then 1-proj-9-tuple(v_610) else caught-fail) in
        {1840}let v_612: bitstring = (if v_611 then catch-fail(deconcat3(message_a_3)) else caught-fail) in
        {1841}let v_613: bool = (not-caught-fail(v_612) && success?(1-proj-3-tuple(v_612))) in
        {1842}let ciphertext_35: bitstring = (if v_613 then 3-proj-3-tuple(v_612) else caught-fail) in
        {1843}let ns_15: bitstring = (if v_613 then 2-proj-3-tuple(v_612) else caught-fail) in
        {1844}let ne_22: bitstring = (if v_613 then 1-proj-3-tuple(v_612) else caught-fail) in
        {1847}let v_614: bitstring = (if v_613 then catch-fail(symmetricstateunpack(ss_89)) else caught-fail) in
        {1848}let v_615: bool = (not-caught-fail(v_614) && success?(1-proj-3-tuple(v_614))) in
        {1849}let h_77: bitstring = (if v_615 then 3-proj-3-tuple(v_614) else caught-fail) in
        {1850}let ck_89: key = (if v_615 then 2-proj-3-tuple(v_614) else caught-fail) in
        {1851}let cs_77: cipherstate = (if v_615 then 1-proj-3-tuple(v_614) else caught-fail) in
        {1846}let re_23: key = (if v_613 then ne_22 else caught-fail) in
        {1852}let ss_90: symmetricstate = (if v_613 then catch-fail((if v_615 then symmetricstatepack(cs_77,ck_89,hash(h_77,re_23)) else fail-any)) else caught-fail) in
        {1853}let v_616: bool = not-caught-fail(ss_90) in
        {1854}let v_617: bitstring = (if v_616 then catch-fail(symmetricstateunpack(ss_90)) else caught-fail) in
        {1855}let v_618: bool = (not-caught-fail(v_617) && success?(1-proj-3-tuple(v_617))) in
        {1856}let h_78: bitstring = (if v_618 then 3-proj-3-tuple(v_617) else caught-fail) in
        {1857}let ck_90: key = (if v_618 then 2-proj-3-tuple(v_617) else caught-fail) in
        {1858}let cs_78: cipherstate = (if v_618 then 1-proj-3-tuple(v_617) else caught-fail) in
        {1859}let v_619: bitstring = (if v_618 then catch-fail(cipherstateunpack(cs_78)) else caught-fail) in
        {1860}let v_620: bool = (not-caught-fail(v_619) && success?(1-proj-2-tuple(v_619))) in
        {1861}let n_48: nonce = (if v_620 then 2-proj-2-tuple(v_619) else caught-fail) in
        {1862}let k_52: key = (if v_620 then 1-proj-2-tuple(v_619) else caught-fail) in
        {1863}let d_12: aead = (if v_620 then catch-fail(decrypt(k_52,n_48,h_78,ciphertext_35)) else caught-fail) in
        {1864}let v_621: bool = not-caught-fail(d_12) in
        {1865}let v_622: bitstring = (if v_621 then catch-fail(aeadunpack(d_12)) else caught-fail) in
        {1866}let v_623: bool = (not-caught-fail(v_622) && success?(1-proj-3-tuple(v_622))) in
        {1867}let plaintext_35: bitstring = (if v_623 then 3-proj-3-tuple(v_622) else caught-fail) in
        {1868}let adi_12: bitstring = (if v_623 then 2-proj-3-tuple(v_622) else caught-fail) in
        {1869}let valid_31: bool = (if v_623 then 1-proj-3-tuple(v_622) else caught-fail) in
        {1871}let v_624: bitstring = (if v_623 then catch-fail(cipherstateunpack(cs_78)) else caught-fail) in
        {1872}let v_625: bool = (not-caught-fail(v_624) && success?(1-proj-2-tuple(v_624))) in
        {1873}let o_24: nonce = (if v_625 then 2-proj-2-tuple(v_624) else caught-fail) in
        {1874}let k_53: key = (if v_625 then 1-proj-2-tuple(v_624) else caught-fail) in
        {1870}let n_49: nonce = (if v_623 then increment_nonce(n_48) else caught-fail) in
        {1875}let csi_48: cipherstate = (if v_623 then catch-fail((if v_625 then cipherstatepack(k_53,n_49) else fail-any)) else caught-fail) in
        {1876}let v_626: bool = not-caught-fail(csi_48) in
        {1877}let v_627: bitstring = (if v_618 then catch-fail((if v_620 then (if v_621 then (if v_623 then (if v_626 then (csi_48,plaintext_35,valid_31) else fail-any) else fail-any) else fail-any) else fail-any)) else caught-fail) in
        {1878}let v_628: bool = (not-caught-fail(v_627) && success?(1-proj-3-tuple(v_627))) in
        {1879}let valid_32: bool = (if v_628 then 3-proj-3-tuple(v_627) else caught-fail) in
        {1880}let plaintext_36: bitstring = (if v_628 then 2-proj-3-tuple(v_627) else caught-fail) in
        {1881}let csi_49: cipherstate = (if v_628 then 1-proj-3-tuple(v_627) else caught-fail) in
        {1882}let ss_91: symmetricstate = (if v_628 then symmetricstatepack(csi_49,ck_90,h_78) else caught-fail) in
        {1883}let v_629: bitstring = (if v_628 then catch-fail(symmetricstateunpack(ss_91)) else caught-fail) in
        {1884}let v_630: bool = (not-caught-fail(v_629) && success?(1-proj-3-tuple(v_629))) in
        {1885}let h_79: bitstring = (if v_630 then 3-proj-3-tuple(v_629) else caught-fail) in
        {1886}let ck_91: key = (if v_630 then 2-proj-3-tuple(v_629) else caught-fail) in
        {1887}let cs_79: cipherstate = (if v_630 then 1-proj-3-tuple(v_629) else caught-fail) in
        {1888}let ssi_27: symmetricstate = (if v_628 then catch-fail((if v_630 then symmetricstatepack(cs_79,ck_91,hash(h_79,ciphertext_35)) else fail-any)) else caught-fail) in
        {1889}let v_631: bool = not-caught-fail(ssi_27) in
        {1890}let v_632: bitstring = (if v_616 then catch-fail((if v_618 then (if v_628 then (if v_631 then (ssi_27,plaintext_36,valid_32) else fail-any) else fail-any) else fail-any)) else caught-fail) in
        {1891}let v_633: bool = (not-caught-fail(v_632) && success?(1-proj-3-tuple(v_632))) in
        {1892}let valid2_7: bool = (if v_633 then 3-proj-3-tuple(v_632) else caught-fail) in
        {1893}let plaintext_37: bitstring = (if v_633 then 2-proj-3-tuple(v_632) else caught-fail) in
        {1894}let ss_92: symmetricstate = (if v_633 then 1-proj-3-tuple(v_632) else caught-fail) in
        {1845}let valid1_9: bool = (if v_613 then true else caught-fail) in
        {1895}let v_634: bool = (if v_633 then catch-fail((valid1_9 && valid2_7)) else caught-fail) in
        {1896}let hs_56: handshakestate = (if v_634 then handshakestatepack(ss_92,s_20,m_22,e_34,rs_21,rm_22,re_23,psk_19,initiator_16) else caught-fail) in
        {1897}let (hs_57: handshakestate,plaintext_a_1: bitstring,valid_33: bool) = (if v_611 then (if v_613 then (if v_616 then (if v_633 then (if undo-catch-fail(v_634) then (hs_56,plaintext_37,true) else fail-any) else fail-any) else fail-any) else fail-any) else fail-any) in
        {1898}event RecvMsg(me_3,them_3,stagepack_a(sid_4),plaintext_a_1);
        {1899}insert statestore(me_3,them_3,sid_4,statepack_b(hs_57))
    ) | (
        {2115}get statestore(=me_3,=them_3,=sid_4,statepack_b(hs_58: handshakestate)) in
        {1902}let v_635: bitstring = catch-fail(handshakestateunpack(hs_58)) in
        {1903}let v_636: bool = (not-caught-fail(v_635) && success?(1-proj-9-tuple(v_635))) in
        {1904}let initiator_17: bool = (if v_636 then 9-proj-9-tuple(v_635) else caught-fail) in
        {1905}let psk_20: key = (if v_636 then 8-proj-9-tuple(v_635) else caught-fail) in
        {1906}let re_24: key = (if v_636 then 7-proj-9-tuple(v_635) else caught-fail) in
        {1907}let rm_23: key = (if v_636 then 6-proj-9-tuple(v_635) else caught-fail) in
        {1908}let rs_22: key = (if v_636 then 5-proj-9-tuple(v_635) else caught-fail) in
        {1909}let e_35: keypair = (if v_636 then 4-proj-9-tuple(v_635) else caught-fail) in
        {1910}let m_23: keypair = (if v_636 then 3-proj-9-tuple(v_635) else caught-fail) in
        {1911}let s_21: keypair = (if v_636 then 2-proj-9-tuple(v_635) else caught-fail) in
        {1912}let ss_93: symmetricstate = (if v_636 then 1-proj-9-tuple(v_635) else caught-fail) in
        {1913}let v_637: bitstring = (if v_636 then catch-fail((empty,empty,empty,empty)) else caught-fail) in
        {1914}let v_638: bool = (not-caught-fail(v_637) && success?(1-proj-4-tuple(v_637))) in
        {1915}let ciphertext_36: bitstring = (if v_638 then 4-proj-4-tuple(v_637) else caught-fail) in
        {1916}let nm_9: bitstring = (if v_638 then 3-proj-4-tuple(v_637) else caught-fail) in
        {1917}let ns_16: bitstring = (if v_638 then 2-proj-4-tuple(v_637) else caught-fail) in
        {1918}let ne_23: bitstring = (if v_638 then 1-proj-4-tuple(v_637) else caught-fail) in
        {1919}let basis_13: key = (if v_638 then key_e(me_3,them_3,sid_4) else caught-fail) in
        {1920}let public_key_13: key = (if v_638 then catch-fail(dhexp(basis_13,validkey(g))) else caught-fail) in
        {1921}let v_639: bool = not-caught-fail(public_key_13) in
        {1922}let e_36: keypair = (if v_638 then catch-fail((if v_639 then keypairpack(validkey(public_key_13),basis_13) else fail-any)) else caught-fail) in
        {1923}let v_640: bool = not-caught-fail(e_36) in
        {1924}let ne_24: bitstring = (if v_640 then catch-fail(getpublickey(e_36)) else caught-fail) in
        {1925}let v_641: bool = not-caught-fail(ne_24) in
        {1926}let v_642: bitstring = (if v_641 then catch-fail(symmetricstateunpack(ss_93)) else caught-fail) in
        {1927}let v_643: bool = (not-caught-fail(v_642) && success?(1-proj-3-tuple(v_642))) in
        {1928}let h_80: bitstring = (if v_643 then 3-proj-3-tuple(v_642) else caught-fail) in
        {1929}let ck_92: key = (if v_643 then 2-proj-3-tuple(v_642) else caught-fail) in
        {1930}let cs_80: cipherstate = (if v_643 then 1-proj-3-tuple(v_642) else caught-fail) in
        {1931}let ss_94: symmetricstate = (if v_641 then catch-fail((if v_643 then symmetricstatepack(cs_80,ck_92,hash(h_80,ne_24)) else fail-any)) else caught-fail) in
        {1932}let v_644: bool = not-caught-fail(ss_94) in
        {1933}let v_645: bitstring = (if v_644 then catch-fail(keypairunpack(e_36)) else caught-fail) in
        {1934}let v_646: bool = (not-caught-fail(v_645) && success?(1-proj-2-tuple(v_645))) in
        {1935}let my_private_key_12: key = (if v_646 then 2-proj-2-tuple(v_645) else caught-fail) in
        {1936}let my_public_key_12: key = (if v_646 then 1-proj-2-tuple(v_645) else caught-fail) in
        {1937}let input_key_material_15: key = (if v_644 then catch-fail((if v_646 then dhexp(my_private_key_12,re_24) else fail-any)) else caught-fail) in
        {1938}let v_647: bool = not-caught-fail(input_key_material_15) in
        {1939}let v_648: bitstring = (if v_647 then catch-fail(symmetricstateunpack(ss_94)) else caught-fail) in
        {1940}let v_649: bool = (not-caught-fail(v_648) && success?(1-proj-3-tuple(v_648))) in
        {1941}let h_81: bitstring = (if v_649 then 3-proj-3-tuple(v_648) else caught-fail) in
        {1942}let ck_93: key = (if v_649 then 2-proj-3-tuple(v_648) else caught-fail) in
        {1943}let cs_81: cipherstate = (if v_649 then 1-proj-3-tuple(v_648) else caught-fail) in
        {1946}let output3_15: key = (if v_649 then hmac_hash3(ck_93,input_key_material_15) else caught-fail) in
        {1945}let output2_15: key = (if v_649 then hmac_hash2(ck_93,input_key_material_15) else caught-fail) in
        {1944}let output1_15: key = (if v_649 then hmac_hash1(ck_93,input_key_material_15) else caught-fail) in
        {1947}let v_650: bitstring = (if v_649 then catch-fail((output1_15,output2_15,output3_15)) else caught-fail) in
        {1948}let v_651: bool = (not-caught-fail(v_650) && success?(1-proj-3-tuple(v_650))) in
        {1949}let output_12: key = (if v_651 then 3-proj-3-tuple(v_650) else caught-fail) in
        {1950}let temp_k_12: key = (if v_651 then 2-proj-3-tuple(v_650) else caught-fail) in
        {1951}let ck_94: key = (if v_651 then 1-proj-3-tuple(v_650) else caught-fail) in
        {1952}let ss_95: symmetricstate = (if v_644 then catch-fail((if v_647 then (if v_649 then (if v_651 then symmetricstatepack(cipherstatepack(temp_k_12,minnonce),ck_94,h_81) else fail-any) else fail-any) else fail-any)) else caught-fail) in
        {1953}let v_652: bool = not-caught-fail(ss_95) in
        {1954}let basis_14: key = (if v_652 then key_s(me_3) else caught-fail) in
        {1955}let public_key_14: key = (if v_652 then catch-fail(dhexp(basis_14,validkey(g))) else caught-fail) in
        {1956}let v_653: bool = not-caught-fail(public_key_14) in
        {1957}let s_22: keypair = (if v_652 then catch-fail((if v_653 then keypairpack(validkey(public_key_14),basis_14) else fail-any)) else caught-fail) in
        {1958}let v_654: bool = not-caught-fail(s_22) in
        {1959}let plaintext_38: bitstring = (if v_654 then catch-fail(getpublickey(s_22)) else caught-fail) in
        {1960}let v_655: bool = not-caught-fail(plaintext_38) in
        {1961}let v_656: bitstring = (if v_655 then catch-fail(symmetricstateunpack(ss_95)) else caught-fail) in
        {1962}let v_657: bool = (not-caught-fail(v_656) && success?(1-proj-3-tuple(v_656))) in
        {1963}let h_82: bitstring = (if v_657 then 3-proj-3-tuple(v_656) else caught-fail) in
        {1964}let ck_95: key = (if v_657 then 2-proj-3-tuple(v_656) else caught-fail) in
        {1965}let cs_82: cipherstate = (if v_657 then 1-proj-3-tuple(v_656) else caught-fail) in
        {1966}let v_658: bitstring = (if v_657 then catch-fail(cipherstateunpack(cs_82)) else caught-fail) in
        {1967}let v_659: bool = (not-caught-fail(v_658) && success?(1-proj-2-tuple(v_658))) in
        {1968}let n_50: nonce = (if v_659 then 2-proj-2-tuple(v_658) else caught-fail) in
        {1969}let k_54: key = (if v_659 then 1-proj-2-tuple(v_658) else caught-fail) in
        {1972}let v_660: bitstring = (if v_659 then catch-fail(cipherstateunpack(cs_82)) else caught-fail) in
        {1973}let v_661: bool = (not-caught-fail(v_660) && success?(1-proj-2-tuple(v_660))) in
        {1974}let o_25: nonce = (if v_661 then 2-proj-2-tuple(v_660) else caught-fail) in
        {1975}let k_55: key = (if v_661 then 1-proj-2-tuple(v_660) else caught-fail) in
        {1971}let n_51: nonce = (if v_659 then increment_nonce(n_50) else caught-fail) in
        {1976}let csi_50: cipherstate = (if v_659 then catch-fail((if v_661 then cipherstatepack(k_55,n_51) else fail-any)) else caught-fail) in
        {1977}let v_662: bool = not-caught-fail(csi_50) in
        {1970}let e_37: bitstring = (if v_659 then encrypt(k_54,n_50,h_82,plaintext_38) else caught-fail) in
        {1978}let v_663: bitstring = (if v_657 then catch-fail((if v_659 then (if v_662 then (csi_50,e_37) else fail-any) else fail-any)) else caught-fail) in
        {1979}let v_664: bool = (not-caught-fail(v_663) && success?(1-proj-2-tuple(v_663))) in
        {1980}let ciphertext_37: bitstring = (if v_664 then 2-proj-2-tuple(v_663) else caught-fail) in
        {1981}let csi_51: cipherstate = (if v_664 then 1-proj-2-tuple(v_663) else caught-fail) in
        {1982}let ss_96: symmetricstate = (if v_664 then symmetricstatepack(csi_51,ck_95,h_82) else caught-fail) in
        {1983}let v_665: bitstring = (if v_664 then catch-fail(symmetricstateunpack(ss_96)) else caught-fail) in
        {1984}let v_666: bool = (not-caught-fail(v_665) && success?(1-proj-3-tuple(v_665))) in
        {1985}let h_83: bitstring = (if v_666 then 3-proj-3-tuple(v_665) else caught-fail) in
        {1986}let ck_96: key = (if v_666 then 2-proj-3-tuple(v_665) else caught-fail) in
        {1987}let cs_83: cipherstate = (if v_666 then 1-proj-3-tuple(v_665) else caught-fail) in
        {1988}let ssi_28: symmetricstate = (if v_664 then catch-fail((if v_666 then symmetricstatepack(cs_83,ck_96,hash(h_83,ciphertext_37)) else fail-any)) else caught-fail) in
        {1989}let v_667: bool = not-caught-fail(ssi_28) in
        {1990}let v_668: bitstring = (if v_654 then catch-fail((if v_655 then (if v_657 then (if v_664 then (if v_667 then (ssi_28,ciphertext_37) else fail-any) else fail-any) else fail-any) else fail-any)) else caught-fail) in
        {1991}let v_669: bool = (not-caught-fail(v_668) && success?(1-proj-2-tuple(v_668))) in
        {1992}let ns_17: bitstring = (if v_669 then 2-proj-2-tuple(v_668) else caught-fail) in
        {1993}let ss_97: symmetricstate = (if v_669 then 1-proj-2-tuple(v_668) else caught-fail) in
        {1994}let basis_15: key = (if v_669 then key_m(me_3) else caught-fail) in
        {1995}let public_key_15: key = (if v_669 then catch-fail(dhexp(basis_15,validkey(g))) else caught-fail) in
        {1996}let v_670: bool = not-caught-fail(public_key_15) in
        {1997}let m_24: keypair = (if v_669 then catch-fail((if v_670 then keypairpack(validkey(public_key_15),basis_15) else fail-any)) else caught-fail) in
        {1998}let v_671: bool = not-caught-fail(m_24) in
        {1999}let plaintext_39: bitstring = (if v_671 then catch-fail(getpublickey(m_24)) else caught-fail) in
        {2000}let v_672: bool = not-caught-fail(plaintext_39) in
        {2001}let v_673: bitstring = (if v_672 then catch-fail(symmetricstateunpack(ss_97)) else caught-fail) in
        {2002}let v_674: bool = (not-caught-fail(v_673) && success?(1-proj-3-tuple(v_673))) in
        {2003}let h_84: bitstring = (if v_674 then 3-proj-3-tuple(v_673) else caught-fail) in
        {2004}let ck_97: key = (if v_674 then 2-proj-3-tuple(v_673) else caught-fail) in
        {2005}let cs_84: cipherstate = (if v_674 then 1-proj-3-tuple(v_673) else caught-fail) in
        {2006}let v_675: bitstring = (if v_674 then catch-fail(cipherstateunpack(cs_84)) else caught-fail) in
        {2007}let v_676: bool = (not-caught-fail(v_675) && success?(1-proj-2-tuple(v_675))) in
        {2008}let n_52: nonce = (if v_676 then 2-proj-2-tuple(v_675) else caught-fail) in
        {2009}let k_56: key = (if v_676 then 1-proj-2-tuple(v_675) else caught-fail) in
        {2012}let v_677: bitstring = (if v_676 then catch-fail(cipherstateunpack(cs_84)) else caught-fail) in
        {2013}let v_678: bool = (not-caught-fail(v_677) && success?(1-proj-2-tuple(v_677))) in
        {2014}let o_26: nonce = (if v_678 then 2-proj-2-tuple(v_677) else caught-fail) in
        {2015}let k_57: key = (if v_678 then 1-proj-2-tuple(v_677) else caught-fail) in
        {2011}let n_53: nonce = (if v_676 then increment_nonce(n_52) else caught-fail) in
        {2016}let csi_52: cipherstate = (if v_676 then catch-fail((if v_678 then cipherstatepack(k_57,n_53) else fail-any)) else caught-fail) in
        {2017}let v_679: bool = not-caught-fail(csi_52) in
        {2010}let e_38: bitstring = (if v_676 then encrypt(k_56,n_52,h_84,plaintext_39) else caught-fail) in
        {2018}let v_680: bitstring = (if v_674 then catch-fail((if v_676 then (if v_679 then (csi_52,e_38) else fail-any) else fail-any)) else caught-fail) in
        {2019}let v_681: bool = (not-caught-fail(v_680) && success?(1-proj-2-tuple(v_680))) in
        {2020}let ciphertext_38: bitstring = (if v_681 then 2-proj-2-tuple(v_680) else caught-fail) in
        {2021}let csi_53: cipherstate = (if v_681 then 1-proj-2-tuple(v_680) else caught-fail) in
        {2022}let ss_98: symmetricstate = (if v_681 then symmetricstatepack(csi_53,ck_97,h_84) else caught-fail) in
        {2023}let v_682: bitstring = (if v_681 then catch-fail(symmetricstateunpack(ss_98)) else caught-fail) in
        {2024}let v_683: bool = (not-caught-fail(v_682) && success?(1-proj-3-tuple(v_682))) in
        {2025}let h_85: bitstring = (if v_683 then 3-proj-3-tuple(v_682) else caught-fail) in
        {2026}let ck_98: key = (if v_683 then 2-proj-3-tuple(v_682) else caught-fail) in
        {2027}let cs_85: cipherstate = (if v_683 then 1-proj-3-tuple(v_682) else caught-fail) in
        {2028}let ssi_29: symmetricstate = (if v_681 then catch-fail((if v_683 then symmetricstatepack(cs_85,ck_98,hash(h_85,ciphertext_38)) else fail-any)) else caught-fail) in
        {2029}let v_684: bool = not-caught-fail(ssi_29) in
        {2030}let v_685: bitstring = (if v_671 then catch-fail((if v_672 then (if v_674 then (if v_681 then (if v_684 then (ssi_29,ciphertext_38) else fail-any) else fail-any) else fail-any) else fail-any)) else caught-fail) in
        {2031}let v_686: bool = (not-caught-fail(v_685) && success?(1-proj-2-tuple(v_685))) in
        {2032}let nm_10: bitstring = (if v_686 then 2-proj-2-tuple(v_685) else caught-fail) in
        {2033}let ss_99: symmetricstate = (if v_686 then 1-proj-2-tuple(v_685) else caught-fail) in
        {2034}let v_687: bitstring = (if v_686 then catch-fail(keypairunpack(s_22)) else caught-fail) in
        {2035}let v_688: bool = (not-caught-fail(v_687) && success?(1-proj-2-tuple(v_687))) in
        {2036}let my_private_key_13: key = (if v_688 then 2-proj-2-tuple(v_687) else caught-fail) in
        {2037}let my_public_key_13: key = (if v_688 then 1-proj-2-tuple(v_687) else caught-fail) in
        {2038}let input_key_material_16: key = (if v_686 then catch-fail((if v_688 then dhexp(my_private_key_13,re_24) else fail-any)) else caught-fail) in
        {2039}let v_689: bool = not-caught-fail(input_key_material_16) in
        {2040}let v_690: bitstring = (if v_689 then catch-fail(symmetricstateunpack(ss_99)) else caught-fail) in
        {2041}let v_691: bool = (not-caught-fail(v_690) && success?(1-proj-3-tuple(v_690))) in
        {2042}let h_86: bitstring = (if v_691 then 3-proj-3-tuple(v_690) else caught-fail) in
        {2043}let ck_99: key = (if v_691 then 2-proj-3-tuple(v_690) else caught-fail) in
        {2044}let cs_86: cipherstate = (if v_691 then 1-proj-3-tuple(v_690) else caught-fail) in
        {2047}let output3_16: key = (if v_691 then hmac_hash3(ck_99,input_key_material_16) else caught-fail) in
        {2046}let output2_16: key = (if v_691 then hmac_hash2(ck_99,input_key_material_16) else caught-fail) in
        {2045}let output1_16: key = (if v_691 then hmac_hash1(ck_99,input_key_material_16) else caught-fail) in
        {2048}let v_692: bitstring = (if v_691 then catch-fail((output1_16,output2_16,output3_16)) else caught-fail) in
        {2049}let v_693: bool = (not-caught-fail(v_692) && success?(1-proj-3-tuple(v_692))) in
        {2050}let output_13: key = (if v_693 then 3-proj-3-tuple(v_692) else caught-fail) in
        {2051}let temp_k_13: key = (if v_693 then 2-proj-3-tuple(v_692) else caught-fail) in
        {2052}let ck_100: key = (if v_693 then 1-proj-3-tuple(v_692) else caught-fail) in
        {2053}let ss_100: symmetricstate = (if v_686 then catch-fail((if v_689 then (if v_691 then (if v_693 then symmetricstatepack(cipherstatepack(temp_k_13,minnonce),ck_100,h_86) else fail-any) else fail-any) else fail-any)) else caught-fail) in
        {2054}let v_694: bool = not-caught-fail(ss_100) in
        {2055}let v_695: bitstring = (if v_694 then catch-fail(keypairunpack(m_24)) else caught-fail) in
        {2056}let v_696: bool = (not-caught-fail(v_695) && success?(1-proj-2-tuple(v_695))) in
        {2057}let my_private_key_14: key = (if v_696 then 2-proj-2-tuple(v_695) else caught-fail) in
        {2058}let my_public_key_14: key = (if v_696 then 1-proj-2-tuple(v_695) else caught-fail) in
        {2059}let input_key_material_17: key = (if v_694 then catch-fail((if v_696 then dhexp(my_private_key_14,re_24) else fail-any)) else caught-fail) in
        {2060}let v_697: bool = not-caught-fail(input_key_material_17) in
        {2061}let v_698: bitstring = (if v_697 then catch-fail(symmetricstateunpack(ss_100)) else caught-fail) in
        {2062}let v_699: bool = (not-caught-fail(v_698) && success?(1-proj-3-tuple(v_698))) in
        {2063}let h_87: bitstring = (if v_699 then 3-proj-3-tuple(v_698) else caught-fail) in
        {2064}let ck_101: key = (if v_699 then 2-proj-3-tuple(v_698) else caught-fail) in
        {2065}let cs_87: cipherstate = (if v_699 then 1-proj-3-tuple(v_698) else caught-fail) in
        {2068}let output3_17: key = (if v_699 then hmac_hash3(ck_101,input_key_material_17) else caught-fail) in
        {2067}let output2_17: key = (if v_699 then hmac_hash2(ck_101,input_key_material_17) else caught-fail) in
        {2066}let output1_17: key = (if v_699 then hmac_hash1(ck_101,input_key_material_17) else caught-fail) in
        {2069}let v_700: bitstring = (if v_699 then catch-fail((output1_17,output2_17,output3_17)) else caught-fail) in
        {2070}let v_701: bool = (not-caught-fail(v_700) && success?(1-proj-3-tuple(v_700))) in
        {2071}let output_14: key = (if v_701 then 3-proj-3-tuple(v_700) else caught-fail) in
        {2072}let temp_k_14: key = (if v_701 then 2-proj-3-tuple(v_700) else caught-fail) in
        {2073}let ck_102: key = (if v_701 then 1-proj-3-tuple(v_700) else caught-fail) in
        {2074}let ss_101: symmetricstate = (if v_694 then catch-fail((if v_697 then (if v_699 then (if v_701 then symmetricstatepack(cipherstatepack(temp_k_14,minnonce),ck_102,h_87) else fail-any) else fail-any) else fail-any)) else caught-fail) in
        {2075}let v_702: bool = not-caught-fail(ss_101) in
        {2076}let v_703: bitstring = (if v_702 then catch-fail(symmetricstateunpack(ss_101)) else caught-fail) in
        {2077}let v_704: bool = (not-caught-fail(v_703) && success?(1-proj-3-tuple(v_703))) in
        {2078}let h_88: bitstring = (if v_704 then 3-proj-3-tuple(v_703) else caught-fail) in
        {2079}let ck_103: key = (if v_704 then 2-proj-3-tuple(v_703) else caught-fail) in
        {2080}let cs_88: cipherstate = (if v_704 then 1-proj-3-tuple(v_703) else caught-fail) in
        {2081}let v_705: bitstring = (if v_704 then catch-fail(cipherstateunpack(cs_88)) else caught-fail) in
        {2082}let v_706: bool = (not-caught-fail(v_705) && success?(1-proj-2-tuple(v_705))) in
        {2083}let n_54: nonce = (if v_706 then 2-proj-2-tuple(v_705) else caught-fail) in
        {2084}let k_58: key = (if v_706 then 1-proj-2-tuple(v_705) else caught-fail) in
        {2087}let v_707: bitstring = (if v_706 then catch-fail(cipherstateunpack(cs_88)) else caught-fail) in
        {2088}let v_708: bool = (not-caught-fail(v_707) && success?(1-proj-2-tuple(v_707))) in
        {2089}let o_27: nonce = (if v_708 then 2-proj-2-tuple(v_707) else caught-fail) in
        {2090}let k_59: key = (if v_708 then 1-proj-2-tuple(v_707) else caught-fail) in
        {2086}let n_55: nonce = (if v_706 then increment_nonce(n_54) else caught-fail) in
        {2091}let csi_54: cipherstate = (if v_706 then catch-fail((if v_708 then cipherstatepack(k_59,n_55) else fail-any)) else caught-fail) in
        {2092}let v_709: bool = not-caught-fail(csi_54) in
        {1901}let payload_8: bitstring = msg_b(me_3,them_3,sid_4) in
        {2085}let e_39: bitstring = (if v_706 then encrypt(k_58,n_54,h_88,payload_8) else caught-fail) in
        {2093}let v_710: bitstring = (if v_704 then catch-fail((if v_706 then (if v_709 then (csi_54,e_39) else fail-any) else fail-any)) else caught-fail) in
        {2094}let v_711: bool = (not-caught-fail(v_710) && success?(1-proj-2-tuple(v_710))) in
        {2095}let ciphertext_39: bitstring = (if v_711 then 2-proj-2-tuple(v_710) else caught-fail) in
        {2096}let csi_55: cipherstate = (if v_711 then 1-proj-2-tuple(v_710) else caught-fail) in
        {2097}let ss_102: symmetricstate = (if v_711 then symmetricstatepack(csi_55,ck_103,h_88) else caught-fail) in
        {2098}let v_712: bitstring = (if v_711 then catch-fail(symmetricstateunpack(ss_102)) else caught-fail) in
        {2099}let v_713: bool = (not-caught-fail(v_712) && success?(1-proj-3-tuple(v_712))) in
        {2100}let h_89: bitstring = (if v_713 then 3-proj-3-tuple(v_712) else caught-fail) in
        {2101}let ck_104: key = (if v_713 then 2-proj-3-tuple(v_712) else caught-fail) in
        {2102}let cs_89: cipherstate = (if v_713 then 1-proj-3-tuple(v_712) else caught-fail) in
        {2103}let ssi_30: symmetricstate = (if v_711 then catch-fail((if v_713 then symmetricstatepack(cs_89,ck_104,hash(h_89,ciphertext_39)) else fail-any)) else caught-fail) in
        {2104}let v_714: bool = not-caught-fail(ssi_30) in
        {2105}let v_715: bitstring = (if v_702 then catch-fail((if v_704 then (if v_711 then (if v_714 then (ssi_30,ciphertext_39) else fail-any) else fail-any) else fail-any)) else caught-fail) in
        {2106}let v_716: bool = (not-caught-fail(v_715) && success?(1-proj-2-tuple(v_715))) in
        {2107}let ciphertext_40: bitstring = (if v_716 then 2-proj-2-tuple(v_715) else caught-fail) in
        {2108}let ss_103: symmetricstate = (if v_716 then 1-proj-2-tuple(v_715) else caught-fail) in
        {2110}let message_buffer_8: bitstring = (if v_716 then concat4(ne_24,ns_17,nm_10,ciphertext_40) else caught-fail) in
        {2109}let hs_59: handshakestate = (if v_716 then handshakestatepack(ss_103,s_22,m_24,e_36,rs_22,rm_23,re_24,psk_20,initiator_17) else caught-fail) in
        {2111}let (hs_60: handshakestate,message_b_3: bitstring) = (if v_636 then (if v_638 then (if v_640 then (if v_641 then (if v_644 then (if v_652 then (if v_654 then (if v_669 then (if v_671 then (if v_686 then (if v_694 then (if v_702 then (if v_716 then (hs_59,message_buffer_8) else fail-any) else fail-any) else fail-any) else fail-any) else fail-any) else fail-any) else fail-any) else fail-any) else fail-any) else fail-any) else fail-any) else fail-any) else fail-any) in
        {2112}event SendMsg(me_3,them_3,stagepack_b(sid_4),msg_b(me_3,them_3,sid_4));
        {2113}insert statestore(me_3,them_3,sid_4,statepack_c(hs_60));
        {2114}out(pub, message_b_3)
    ) | (
        {2270}get statestore(=me_3,=them_3,=sid_4,statepack_c(hs_61: handshakestate)) in
        {2116}in(pub, message_c_3: bitstring);
        {2117}let v_717: bitstring = catch-fail(handshakestateunpack(hs_61)) in
        {2118}let v_718: bool = (not-caught-fail(v_717) && success?(1-proj-9-tuple(v_717))) in
        {2119}let initiator_18: bool = (if v_718 then 9-proj-9-tuple(v_717) else caught-fail) in
        {2120}let psk_21: key = (if v_718 then 8-proj-9-tuple(v_717) else caught-fail) in
        {2121}let re_25: key = (if v_718 then 7-proj-9-tuple(v_717) else caught-fail) in
        {2122}let rm_24: key = (if v_718 then 6-proj-9-tuple(v_717) else caught-fail) in
        {2123}let rs_23: key = (if v_718 then 5-proj-9-tuple(v_717) else caught-fail) in
        {2124}let e_40: keypair = (if v_718 then 4-proj-9-tuple(v_717) else caught-fail) in
        {2125}let m_25: keypair = (if v_718 then 3-proj-9-tuple(v_717) else caught-fail) in
        {2126}let s_23: keypair = (if v_718 then 2-proj-9-tuple(v_717) else caught-fail) in
        {2127}let ss_104: symmetricstate = (if v_718 then 1-proj-9-tuple(v_717) else caught-fail) in
        {2128}let v_719: bitstring = (if v_718 then catch-fail(deconcat3(message_c_3)) else caught-fail) in
        {2129}let v_720: bool = (not-caught-fail(v_719) && success?(1-proj-3-tuple(v_719))) in
        {2130}let ciphertext_41: bitstring = (if v_720 then 3-proj-3-tuple(v_719) else caught-fail) in
        {2131}let nm_11: bitstring = (if v_720 then 2-proj-3-tuple(v_719) else caught-fail) in
        {2132}let ne_25: bitstring = (if v_720 then 1-proj-3-tuple(v_719) else caught-fail) in
        {2134}let v_721: bitstring = (if v_720 then catch-fail(symmetricstateunpack(ss_104)) else caught-fail) in
        {2135}let v_722: bool = (not-caught-fail(v_721) && success?(1-proj-3-tuple(v_721))) in
        {2136}let h_90: bitstring = (if v_722 then 3-proj-3-tuple(v_721) else caught-fail) in
        {2137}let ck_105: key = (if v_722 then 2-proj-3-tuple(v_721) else caught-fail) in
        {2138}let cs_90: cipherstate = (if v_722 then 1-proj-3-tuple(v_721) else caught-fail) in
        {2139}let v_723: bitstring = (if v_722 then catch-fail(cipherstateunpack(cs_90)) else caught-fail) in
        {2140}let v_724: bool = (not-caught-fail(v_723) && success?(1-proj-2-tuple(v_723))) in
        {2141}let n_56: nonce = (if v_724 then 2-proj-2-tuple(v_723) else caught-fail) in
        {2142}let k_60: key = (if v_724 then 1-proj-2-tuple(v_723) else caught-fail) in
        {2143}let d_13: aead = (if v_724 then catch-fail(decrypt(k_60,n_56,h_90,nm_11)) else caught-fail) in
        {2144}let v_725: bool = not-caught-fail(d_13) in
        {2145}let v_726: bitstring = (if v_725 then catch-fail(aeadunpack(d_13)) else caught-fail) in
        {2146}let v_727: bool = (not-caught-fail(v_726) && success?(1-proj-3-tuple(v_726))) in
        {2147}let plaintext_40: bitstring = (if v_727 then 3-proj-3-tuple(v_726) else caught-fail) in
        {2148}let adi_13: bitstring = (if v_727 then 2-proj-3-tuple(v_726) else caught-fail) in
        {2149}let valid_34: bool = (if v_727 then 1-proj-3-tuple(v_726) else caught-fail) in
        {2151}let v_728: bitstring = (if v_727 then catch-fail(cipherstateunpack(cs_90)) else caught-fail) in
        {2152}let v_729: bool = (not-caught-fail(v_728) && success?(1-proj-2-tuple(v_728))) in
        {2153}let o_28: nonce = (if v_729 then 2-proj-2-tuple(v_728) else caught-fail) in
        {2154}let k_61: key = (if v_729 then 1-proj-2-tuple(v_728) else caught-fail) in
        {2150}let n_57: nonce = (if v_727 then increment_nonce(n_56) else caught-fail) in
        {2155}let csi_56: cipherstate = (if v_727 then catch-fail((if v_729 then cipherstatepack(k_61,n_57) else fail-any)) else caught-fail) in
        {2156}let v_730: bool = not-caught-fail(csi_56) in
        {2157}let v_731: bitstring = (if v_722 then catch-fail((if v_724 then (if v_725 then (if v_727 then (if v_730 then (csi_56,plaintext_40,valid_34) else fail-any) else fail-any) else fail-any) else fail-any)) else caught-fail) in
        {2158}let v_732: bool = (not-caught-fail(v_731) && success?(1-proj-3-tuple(v_731))) in
        {2159}let valid_35: bool = (if v_732 then 3-proj-3-tuple(v_731) else caught-fail) in
        {2160}let plaintext_41: bitstring = (if v_732 then 2-proj-3-tuple(v_731) else caught-fail) in
        {2161}let csi_57: cipherstate = (if v_732 then 1-proj-3-tuple(v_731) else caught-fail) in
        {2162}let ss_105: symmetricstate = (if v_732 then symmetricstatepack(csi_57,ck_105,h_90) else caught-fail) in
        {2163}let v_733: bitstring = (if v_732 then catch-fail(symmetricstateunpack(ss_105)) else caught-fail) in
        {2164}let v_734: bool = (not-caught-fail(v_733) && success?(1-proj-3-tuple(v_733))) in
        {2165}let h_91: bitstring = (if v_734 then 3-proj-3-tuple(v_733) else caught-fail) in
        {2166}let ck_106: key = (if v_734 then 2-proj-3-tuple(v_733) else caught-fail) in
        {2167}let cs_91: cipherstate = (if v_734 then 1-proj-3-tuple(v_733) else caught-fail) in
        {2168}let ssi_31: symmetricstate = (if v_732 then catch-fail((if v_734 then symmetricstatepack(cs_91,ck_106,hash(h_91,nm_11)) else fail-any)) else caught-fail) in
        {2169}let v_735: bool = not-caught-fail(ssi_31) in
        {2170}let v_736: bitstring = (if v_720 then catch-fail((if v_722 then (if v_732 then (if v_735 then (ssi_31,plaintext_41,valid_35) else fail-any) else fail-any) else fail-any)) else caught-fail) in
        {2171}let v_737: bool = (not-caught-fail(v_736) && success?(1-proj-3-tuple(v_736))) in
        {2172}let valid2_8: bool = (if v_737 then 3-proj-3-tuple(v_736) else caught-fail) in
        {2173}let nem_1: bitstring = (if v_737 then 2-proj-3-tuple(v_736) else caught-fail) in
        {2174}let ss_106: symmetricstate = (if v_737 then 1-proj-3-tuple(v_736) else caught-fail) in
        {2176}let v_738: bitstring = (if v_737 then catch-fail(keypairunpack(e_40)) else caught-fail) in
        {2177}let v_739: bool = (not-caught-fail(v_738) && success?(1-proj-2-tuple(v_738))) in
        {2178}let my_private_key_15: key = (if v_739 then 2-proj-2-tuple(v_738) else caught-fail) in
        {2179}let my_public_key_15: key = (if v_739 then 1-proj-2-tuple(v_738) else caught-fail) in
        {2175}let rm_25: key = (if v_737 then nem_1 else caught-fail) in
        {2180}let input_key_material_18: key = (if v_737 then catch-fail((if v_739 then dhexp(my_private_key_15,rm_25) else fail-any)) else caught-fail) in
        {2181}let v_740: bool = not-caught-fail(input_key_material_18) in
        {2182}let v_741: bitstring = (if v_740 then catch-fail(symmetricstateunpack(ss_106)) else caught-fail) in
        {2183}let v_742: bool = (not-caught-fail(v_741) && success?(1-proj-3-tuple(v_741))) in
        {2184}let h_92: bitstring = (if v_742 then 3-proj-3-tuple(v_741) else caught-fail) in
        {2185}let ck_107: key = (if v_742 then 2-proj-3-tuple(v_741) else caught-fail) in
        {2186}let cs_92: cipherstate = (if v_742 then 1-proj-3-tuple(v_741) else caught-fail) in
        {2189}let output3_18: key = (if v_742 then hmac_hash3(ck_107,input_key_material_18) else caught-fail) in
        {2188}let output2_18: key = (if v_742 then hmac_hash2(ck_107,input_key_material_18) else caught-fail) in
        {2187}let output1_18: key = (if v_742 then hmac_hash1(ck_107,input_key_material_18) else caught-fail) in
        {2190}let v_743: bitstring = (if v_742 then catch-fail((output1_18,output2_18,output3_18)) else caught-fail) in
        {2191}let v_744: bool = (not-caught-fail(v_743) && success?(1-proj-3-tuple(v_743))) in
        {2192}let output_15: key = (if v_744 then 3-proj-3-tuple(v_743) else caught-fail) in
        {2193}let temp_k_15: key = (if v_744 then 2-proj-3-tuple(v_743) else caught-fail) in
        {2194}let ck_108: key = (if v_744 then 1-proj-3-tuple(v_743) else caught-fail) in
        {2195}let ss_107: symmetricstate = (if v_737 then catch-fail((if v_740 then (if v_742 then (if v_744 then symmetricstatepack(cipherstatepack(temp_k_15,minnonce),ck_108,h_92) else fail-any) else fail-any) else fail-any)) else caught-fail) in
        {2196}let v_745: bool = not-caught-fail(ss_107) in
        {2197}let v_746: bitstring = (if v_745 then catch-fail(symmetricstateunpack(ss_107)) else caught-fail) in
        {2198}let v_747: bool = (not-caught-fail(v_746) && success?(1-proj-3-tuple(v_746))) in
        {2199}let h_93: bitstring = (if v_747 then 3-proj-3-tuple(v_746) else caught-fail) in
        {2200}let ck_109: key = (if v_747 then 2-proj-3-tuple(v_746) else caught-fail) in
        {2201}let cs_93: cipherstate = (if v_747 then 1-proj-3-tuple(v_746) else caught-fail) in
        {2202}let v_748: bitstring = (if v_747 then catch-fail(cipherstateunpack(cs_93)) else caught-fail) in
        {2203}let v_749: bool = (not-caught-fail(v_748) && success?(1-proj-2-tuple(v_748))) in
        {2204}let n_58: nonce = (if v_749 then 2-proj-2-tuple(v_748) else caught-fail) in
        {2205}let k_62: key = (if v_749 then 1-proj-2-tuple(v_748) else caught-fail) in
        {2206}let d_14: aead = (if v_749 then catch-fail(decrypt(k_62,n_58,h_93,ciphertext_41)) else caught-fail) in
        {2207}let v_750: bool = not-caught-fail(d_14) in
        {2208}let v_751: bitstring = (if v_750 then catch-fail(aeadunpack(d_14)) else caught-fail) in
        {2209}let v_752: bool = (not-caught-fail(v_751) && success?(1-proj-3-tuple(v_751))) in
        {2210}let plaintext_42: bitstring = (if v_752 then 3-proj-3-tuple(v_751) else caught-fail) in
        {2211}let adi_14: bitstring = (if v_752 then 2-proj-3-tuple(v_751) else caught-fail) in
        {2212}let valid_36: bool = (if v_752 then 1-proj-3-tuple(v_751) else caught-fail) in
        {2214}let v_753: bitstring = (if v_752 then catch-fail(cipherstateunpack(cs_93)) else caught-fail) in
        {2215}let v_754: bool = (not-caught-fail(v_753) && success?(1-proj-2-tuple(v_753))) in
        {2216}let o_29: nonce = (if v_754 then 2-proj-2-tuple(v_753) else caught-fail) in
        {2217}let k_63: key = (if v_754 then 1-proj-2-tuple(v_753) else caught-fail) in
        {2213}let n_59: nonce = (if v_752 then increment_nonce(n_58) else caught-fail) in
        {2218}let csi_58: cipherstate = (if v_752 then catch-fail((if v_754 then cipherstatepack(k_63,n_59) else fail-any)) else caught-fail) in
        {2219}let v_755: bool = not-caught-fail(csi_58) in
        {2220}let v_756: bitstring = (if v_747 then catch-fail((if v_749 then (if v_750 then (if v_752 then (if v_755 then (csi_58,plaintext_42,valid_36) else fail-any) else fail-any) else fail-any) else fail-any)) else caught-fail) in
        {2221}let v_757: bool = (not-caught-fail(v_756) && success?(1-proj-3-tuple(v_756))) in
        {2222}let valid_37: bool = (if v_757 then 3-proj-3-tuple(v_756) else caught-fail) in
        {2223}let plaintext_43: bitstring = (if v_757 then 2-proj-3-tuple(v_756) else caught-fail) in
        {2224}let csi_59: cipherstate = (if v_757 then 1-proj-3-tuple(v_756) else caught-fail) in
        {2225}let ss_108: symmetricstate = (if v_757 then symmetricstatepack(csi_59,ck_109,h_93) else caught-fail) in
        {2226}let v_758: bitstring = (if v_757 then catch-fail(symmetricstateunpack(ss_108)) else caught-fail) in
        {2227}let v_759: bool = (not-caught-fail(v_758) && success?(1-proj-3-tuple(v_758))) in
        {2228}let h_94: bitstring = (if v_759 then 3-proj-3-tuple(v_758) else caught-fail) in
        {2229}let ck_110: key = (if v_759 then 2-proj-3-tuple(v_758) else caught-fail) in
        {2230}let cs_94: cipherstate = (if v_759 then 1-proj-3-tuple(v_758) else caught-fail) in
        {2231}let ssi_32: symmetricstate = (if v_757 then catch-fail((if v_759 then symmetricstatepack(cs_94,ck_110,hash(h_94,ciphertext_41)) else fail-any)) else caught-fail) in
        {2232}let v_760: bool = not-caught-fail(ssi_32) in
        {2233}let v_761: bitstring = (if v_745 then catch-fail((if v_747 then (if v_757 then (if v_760 then (ssi_32,plaintext_43,valid_37) else fail-any) else fail-any) else fail-any)) else caught-fail) in
        {2234}let v_762: bool = (not-caught-fail(v_761) && success?(1-proj-3-tuple(v_761))) in
        {2235}let valid3_3: bool = (if v_762 then 3-proj-3-tuple(v_761) else caught-fail) in
        {2236}let plaintext_44: bitstring = (if v_762 then 2-proj-3-tuple(v_761) else caught-fail) in
        {2237}let ss_109: symmetricstate = (if v_762 then 1-proj-3-tuple(v_761) else caught-fail) in
        {2241}let basis_17: key = (if v_762 then key_m(them_3) else caught-fail) in
        {2242}let public_key_17: key = (if v_762 then catch-fail(dhexp(basis_17,validkey(g))) else caught-fail) in
        {2243}let v_764: bool = not-caught-fail(public_key_17) in
        {2238}let basis_16: key = (if v_762 then key_s(them_3) else caught-fail) in
        {2239}let public_key_16: key = (if v_762 then catch-fail(dhexp(basis_16,validkey(g))) else caught-fail) in
        {2240}let v_763: bool = not-caught-fail(public_key_16) in
        {2133}let valid1_10: bool = (if v_720 then true else caught-fail) in
        {2244}let v_765: bool = (if v_762 then catch-fail(((valid1_10 && (valid2_8 && valid3_3)) && ((rs_23 = getpublickey((if v_763 then keypairpack(validkey(public_key_16),basis_16) else fail-any))) && (rm_25 = getpublickey((if v_764 then keypairpack(validkey(public_key_17),basis_17) else fail-any)))))) else caught-fail) in
        {2246}let v_766: bitstring = (if v_765 then catch-fail(symmetricstateunpack(ss_109)) else caught-fail) in
        {2247}let v_767: bool = (not-caught-fail(v_766) && success?(1-proj-3-tuple(v_766))) in
        {2248}let h_95: bitstring = (if v_767 then 3-proj-3-tuple(v_766) else caught-fail) in
        {2249}let ck_111: key = (if v_767 then 2-proj-3-tuple(v_766) else caught-fail) in
        {2250}let cs_95: cipherstate = (if v_767 then 1-proj-3-tuple(v_766) else caught-fail) in
        {2251}let input_key_material_19: key = (if v_767 then zero else caught-fail) in
        {2254}let output3_19: key = (if v_767 then hmac_hash3(ck_111,input_key_material_19) else caught-fail) in
        {2253}let output2_19: key = (if v_767 then hmac_hash2(ck_111,input_key_material_19) else caught-fail) in
        {2252}let output1_19: key = (if v_767 then hmac_hash1(ck_111,input_key_material_19) else caught-fail) in
        {2255}let v_768: bitstring = (if v_767 then catch-fail((output1_19,output2_19,output3_19)) else caught-fail) in
        {2256}let v_769: bool = (not-caught-fail(v_768) && success?(1-proj-3-tuple(v_768))) in
        {2257}let temp_k3_3: key = (if v_769 then 3-proj-3-tuple(v_768) else caught-fail) in
        {2258}let temp_k2_3: key = (if v_769 then 2-proj-3-tuple(v_768) else caught-fail) in
        {2259}let temp_k1_3: key = (if v_769 then 1-proj-3-tuple(v_768) else caught-fail) in
        {2261}let cs2_15: cipherstate = (if v_769 then cipherstatepack(temp_k2_3,minnonce) else caught-fail) in
        {2260}let cs1_15: cipherstate = (if v_769 then cipherstatepack(temp_k1_3,minnonce) else caught-fail) in
        {2262}let v_770: bitstring = (if v_765 then catch-fail((if v_767 then (if v_769 then (ss_109,cs1_15,cs2_15) else fail-any) else fail-any)) else caught-fail) in
        {2263}let v_771: bool = (not-caught-fail(v_770) && success?(1-proj-3-tuple(v_770))) in
        {2264}let cs2_16: cipherstate = (if v_771 then 3-proj-3-tuple(v_770) else caught-fail) in
        {2265}let cs1_16: cipherstate = (if v_771 then 2-proj-3-tuple(v_770) else caught-fail) in
        {2266}let ssi_33: symmetricstate = (if v_771 then 1-proj-3-tuple(v_770) else caught-fail) in
        {2245}let hs_62: handshakestate = (if v_765 then handshakestatepack(ss_109,s_23,m_25,e_40,rs_23,rm_25,re_25,psk_21,initiator_18) else caught-fail) in
        {2267}let (hs_63: handshakestate,plaintext_c_1: bitstring,valid_38: bool,cs1_17: cipherstate,cs2_17: cipherstate) = (if v_718 then (if v_720 then (if v_737 then (if v_745 then (if v_762 then (if undo-catch-fail(v_765) then (if v_771 then (hs_62,plaintext_44,true,cs1_16,cs2_16) else fail-any) else fail-any) else fail-any) else fail-any) else fail-any) else fail-any) else fail-any) in
        {2268}event RecvMsg(me_3,them_3,stagepack_c(sid_4),plaintext_c_1);
        {2269}insert statestore(me_3,them_3,sid_4,statepack_d(hs_63,cs1_17,cs2_17))
    ) | (
        {2271}!
        {2329}get statestore(=me_3,=them_3,=sid_4,statepack_d(hs_64: handshakestate,cs1_18: cipherstate,cs2_18: cipherstate)) in
        {2272}let hs_65: handshakestate = handshakestatesetcs(hs_64,cs2_18) in
        {2274}let v_772: bitstring = catch-fail(handshakestateunpack(hs_65)) in
        {2275}let v_773: bool = (not-caught-fail(v_772) && success?(1-proj-9-tuple(v_772))) in
        {2276}let initiator_19: bool = (if v_773 then 9-proj-9-tuple(v_772) else caught-fail) in
        {2277}let psk_22: key = (if v_773 then 8-proj-9-tuple(v_772) else caught-fail) in
        {2278}let re_26: key = (if v_773 then 7-proj-9-tuple(v_772) else caught-fail) in
        {2279}let rm_26: key = (if v_773 then 6-proj-9-tuple(v_772) else caught-fail) in
        {2280}let rs_24: key = (if v_773 then 5-proj-9-tuple(v_772) else caught-fail) in
        {2281}let e_41: keypair = (if v_773 then 4-proj-9-tuple(v_772) else caught-fail) in
        {2282}let m_26: keypair = (if v_773 then 3-proj-9-tuple(v_772) else caught-fail) in
        {2283}let s_24: keypair = (if v_773 then 2-proj-9-tuple(v_772) else caught-fail) in
        {2284}let ss_110: symmetricstate = (if v_773 then 1-proj-9-tuple(v_772) else caught-fail) in
        {2285}let v_774: bitstring = (if v_773 then catch-fail((empty,empty,empty)) else caught-fail) in
        {2286}let v_775: bool = (not-caught-fail(v_774) && success?(1-proj-3-tuple(v_774))) in
        {2287}let ciphertext_42: bitstring = (if v_775 then 3-proj-3-tuple(v_774) else caught-fail) in
        {2288}let ns_18: bitstring = (if v_775 then 2-proj-3-tuple(v_774) else caught-fail) in
        {2289}let ne_26: bitstring = (if v_775 then 1-proj-3-tuple(v_774) else caught-fail) in
        {2290}let v_776: bitstring = (if v_775 then catch-fail(symmetricstateunpack(ss_110)) else caught-fail) in
        {2291}let v_777: bool = (not-caught-fail(v_776) && success?(1-proj-3-tuple(v_776))) in
        {2292}let h_96: bitstring = (if v_777 then 3-proj-3-tuple(v_776) else caught-fail) in
        {2293}let ck_112: key = (if v_777 then 2-proj-3-tuple(v_776) else caught-fail) in
        {2294}let cs_96: cipherstate = (if v_777 then 1-proj-3-tuple(v_776) else caught-fail) in
        {2295}let v_778: bitstring = (if v_777 then catch-fail(cipherstateunpack(cs_96)) else caught-fail) in
        {2296}let v_779: bool = (not-caught-fail(v_778) && success?(1-proj-2-tuple(v_778))) in
        {2297}let n_60: nonce = (if v_779 then 2-proj-2-tuple(v_778) else caught-fail) in
        {2298}let k_64: key = (if v_779 then 1-proj-2-tuple(v_778) else caught-fail) in
        {2301}let v_780: bitstring = (if v_779 then catch-fail(cipherstateunpack(cs_96)) else caught-fail) in
        {2302}let v_781: bool = (not-caught-fail(v_780) && success?(1-proj-2-tuple(v_780))) in
        {2303}let o_30: nonce = (if v_781 then 2-proj-2-tuple(v_780) else caught-fail) in
        {2304}let k_65: key = (if v_781 then 1-proj-2-tuple(v_780) else caught-fail) in
        {2300}let n_61: nonce = (if v_779 then increment_nonce(n_60) else caught-fail) in
        {2305}let csi_60: cipherstate = (if v_779 then catch-fail((if v_781 then cipherstatepack(k_65,n_61) else fail-any)) else caught-fail) in
        {2306}let v_782: bool = not-caught-fail(csi_60) in
        {2273}let payload_9: bitstring = msg_d(me_3,them_3,sid_4) in
        {2299}let e_42: bitstring = (if v_779 then encrypt(k_64,n_60,h_96,payload_9) else caught-fail) in
        {2307}let v_783: bitstring = (if v_777 then catch-fail((if v_779 then (if v_782 then (csi_60,e_42) else fail-any) else fail-any)) else caught-fail) in
        {2308}let v_784: bool = (not-caught-fail(v_783) && success?(1-proj-2-tuple(v_783))) in
        {2309}let ciphertext_43: bitstring = (if v_784 then 2-proj-2-tuple(v_783) else caught-fail) in
        {2310}let csi_61: cipherstate = (if v_784 then 1-proj-2-tuple(v_783) else caught-fail) in
        {2311}let ss_111: symmetricstate = (if v_784 then symmetricstatepack(csi_61,ck_112,h_96) else caught-fail) in
        {2312}let v_785: bitstring = (if v_784 then catch-fail(symmetricstateunpack(ss_111)) else caught-fail) in
        {2313}let v_786: bool = (not-caught-fail(v_785) && success?(1-proj-3-tuple(v_785))) in
        {2314}let h_97: bitstring = (if v_786 then 3-proj-3-tuple(v_785) else caught-fail) in
        {2315}let ck_113: key = (if v_786 then 2-proj-3-tuple(v_785) else caught-fail) in
        {2316}let cs_97: cipherstate = (if v_786 then 1-proj-3-tuple(v_785) else caught-fail) in
        {2317}let ssi_34: symmetricstate = (if v_784 then catch-fail((if v_786 then symmetricstatepack(cs_97,ck_113,hash(h_97,ciphertext_43)) else fail-any)) else caught-fail) in
        {2318}let v_787: bool = not-caught-fail(ssi_34) in
        {2319}let v_788: bitstring = (if v_775 then catch-fail((if v_777 then (if v_784 then (if v_787 then (ssi_34,ciphertext_43) else fail-any) else fail-any) else fail-any)) else caught-fail) in
        {2320}let v_789: bool = (not-caught-fail(v_788) && success?(1-proj-2-tuple(v_788))) in
        {2321}let ciphertext_44: bitstring = (if v_789 then 2-proj-2-tuple(v_788) else caught-fail) in
        {2322}let ss_112: symmetricstate = (if v_789 then 1-proj-2-tuple(v_788) else caught-fail) in
        {2324}let message_buffer_9: bitstring = (if v_789 then concat3(ne_26,ns_18,ciphertext_44) else caught-fail) in
        {2323}let hs_66: handshakestate = (if v_789 then handshakestatepack(ss_112,s_24,m_26,e_41,rs_24,rm_26,re_26,psk_22,initiator_19) else caught-fail) in
        {2325}let (hs_67: handshakestate,message_d_3: bitstring) = (if v_773 then (if v_775 then (if v_789 then (hs_66,message_buffer_9) else fail-any) else fail-any) else fail-any) in
        {2326}event SendMsg(me_3,them_3,stagepack_d(sid_4),msg_d(me_3,them_3,sid_4));
        {2327}insert statestore(me_3,them_3,sid_4,statepack_e(hs_67,cs1_18,handshakestategetcs(hs_67)));
        {2328}out(pub, message_d_3)
    ) | (
        {2330}!
        {2396}get statestore(=me_3,=them_3,=sid_4,statepack_e(hs_68: handshakestate,cs1_19: cipherstate,cs2_19: cipherstate)) in
        {2331}let hs_69: handshakestate = handshakestatesetcs(hs_68,cs1_19) in
        {2332}in(pub, message_e_3: bitstring);
        {2333}let v_790: bitstring = catch-fail(handshakestateunpack(hs_69)) in
        {2334}let v_791: bool = (not-caught-fail(v_790) && success?(1-proj-9-tuple(v_790))) in
        {2335}let initiator_20: bool = (if v_791 then 9-proj-9-tuple(v_790) else caught-fail) in
        {2336}let psk_23: key = (if v_791 then 8-proj-9-tuple(v_790) else caught-fail) in
        {2337}let re_27: key = (if v_791 then 7-proj-9-tuple(v_790) else caught-fail) in
        {2338}let rm_27: key = (if v_791 then 6-proj-9-tuple(v_790) else caught-fail) in
        {2339}let rs_25: key = (if v_791 then 5-proj-9-tuple(v_790) else caught-fail) in
        {2340}let e_43: keypair = (if v_791 then 4-proj-9-tuple(v_790) else caught-fail) in
        {2341}let m_27: keypair = (if v_791 then 3-proj-9-tuple(v_790) else caught-fail) in
        {2342}let s_25: keypair = (if v_791 then 2-proj-9-tuple(v_790) else caught-fail) in
        {2343}let ss_113: symmetricstate = (if v_791 then 1-proj-9-tuple(v_790) else caught-fail) in
        {2344}let v_792: bitstring = (if v_791 then catch-fail(deconcat3(message_e_3)) else caught-fail) in
        {2345}let v_793: bool = (not-caught-fail(v_792) && success?(1-proj-3-tuple(v_792))) in
        {2346}let ciphertext_45: bitstring = (if v_793 then 3-proj-3-tuple(v_792) else caught-fail) in
        {2347}let ns_19: bitstring = (if v_793 then 2-proj-3-tuple(v_792) else caught-fail) in
        {2348}let ne_27: bitstring = (if v_793 then 1-proj-3-tuple(v_792) else caught-fail) in
        {2350}let v_794: bitstring = (if v_793 then catch-fail(symmetricstateunpack(ss_113)) else caught-fail) in
        {2351}let v_795: bool = (not-caught-fail(v_794) && success?(1-proj-3-tuple(v_794))) in
        {2352}let h_98: bitstring = (if v_795 then 3-proj-3-tuple(v_794) else caught-fail) in
        {2353}let ck_114: key = (if v_795 then 2-proj-3-tuple(v_794) else caught-fail) in
        {2354}let cs_98: cipherstate = (if v_795 then 1-proj-3-tuple(v_794) else caught-fail) in
        {2355}let v_796: bitstring = (if v_795 then catch-fail(cipherstateunpack(cs_98)) else caught-fail) in
        {2356}let v_797: bool = (not-caught-fail(v_796) && success?(1-proj-2-tuple(v_796))) in
        {2357}let n_62: nonce = (if v_797 then 2-proj-2-tuple(v_796) else caught-fail) in
        {2358}let k_66: key = (if v_797 then 1-proj-2-tuple(v_796) else caught-fail) in
        {2359}let d_15: aead = (if v_797 then catch-fail(decrypt(k_66,n_62,h_98,ciphertext_45)) else caught-fail) in
        {2360}let v_798: bool = not-caught-fail(d_15) in
        {2361}let v_799: bitstring = (if v_798 then catch-fail(aeadunpack(d_15)) else caught-fail) in
        {2362}let v_800: bool = (not-caught-fail(v_799) && success?(1-proj-3-tuple(v_799))) in
        {2363}let plaintext_45: bitstring = (if v_800 then 3-proj-3-tuple(v_799) else caught-fail) in
        {2364}let adi_15: bitstring = (if v_800 then 2-proj-3-tuple(v_799) else caught-fail) in
        {2365}let valid_39: bool = (if v_800 then 1-proj-3-tuple(v_799) else caught-fail) in
        {2367}let v_801: bitstring = (if v_800 then catch-fail(cipherstateunpack(cs_98)) else caught-fail) in
        {2368}let v_802: bool = (not-caught-fail(v_801) && success?(1-proj-2-tuple(v_801))) in
        {2369}let o_31: nonce = (if v_802 then 2-proj-2-tuple(v_801) else caught-fail) in
        {2370}let k_67: key = (if v_802 then 1-proj-2-tuple(v_801) else caught-fail) in
        {2366}let n_63: nonce = (if v_800 then increment_nonce(n_62) else caught-fail) in
        {2371}let csi_62: cipherstate = (if v_800 then catch-fail((if v_802 then cipherstatepack(k_67,n_63) else fail-any)) else caught-fail) in
        {2372}let v_803: bool = not-caught-fail(csi_62) in
        {2373}let v_804: bitstring = (if v_795 then catch-fail((if v_797 then (if v_798 then (if v_800 then (if v_803 then (csi_62,plaintext_45,valid_39) else fail-any) else fail-any) else fail-any) else fail-any)) else caught-fail) in
        {2374}let v_805: bool = (not-caught-fail(v_804) && success?(1-proj-3-tuple(v_804))) in
        {2375}let valid_40: bool = (if v_805 then 3-proj-3-tuple(v_804) else caught-fail) in
        {2376}let plaintext_46: bitstring = (if v_805 then 2-proj-3-tuple(v_804) else caught-fail) in
        {2377}let csi_63: cipherstate = (if v_805 then 1-proj-3-tuple(v_804) else caught-fail) in
        {2378}let ss_114: symmetricstate = (if v_805 then symmetricstatepack(csi_63,ck_114,h_98) else caught-fail) in
        {2379}let v_806: bitstring = (if v_805 then catch-fail(symmetricstateunpack(ss_114)) else caught-fail) in
        {2380}let v_807: bool = (not-caught-fail(v_806) && success?(1-proj-3-tuple(v_806))) in
        {2381}let h_99: bitstring = (if v_807 then 3-proj-3-tuple(v_806) else caught-fail) in
        {2382}let ck_115: key = (if v_807 then 2-proj-3-tuple(v_806) else caught-fail) in
        {2383}let cs_99: cipherstate = (if v_807 then 1-proj-3-tuple(v_806) else caught-fail) in
        {2384}let ssi_35: symmetricstate = (if v_805 then catch-fail((if v_807 then symmetricstatepack(cs_99,ck_115,hash(h_99,ciphertext_45)) else fail-any)) else caught-fail) in
        {2385}let v_808: bool = not-caught-fail(ssi_35) in
        {2386}let v_809: bitstring = (if v_793 then catch-fail((if v_795 then (if v_805 then (if v_808 then (ssi_35,plaintext_46,valid_40) else fail-any) else fail-any) else fail-any)) else caught-fail) in
        {2387}let v_810: bool = (not-caught-fail(v_809) && success?(1-proj-3-tuple(v_809))) in
        {2388}let valid2_9: bool = (if v_810 then 3-proj-3-tuple(v_809) else caught-fail) in
        {2389}let plaintext_47: bitstring = (if v_810 then 2-proj-3-tuple(v_809) else caught-fail) in
        {2390}let ss_115: symmetricstate = (if v_810 then 1-proj-3-tuple(v_809) else caught-fail) in
        {2349}let valid1_11: bool = (if v_793 then true else caught-fail) in
        {2391}let v_811: bool = (if v_810 then catch-fail((valid1_11 && valid2_9)) else caught-fail) in
        {2392}let hs_70: handshakestate = (if v_811 then handshakestatepack(ss_115,s_25,m_27,e_43,rs_25,rm_27,re_27,psk_23,initiator_20) else caught-fail) in
        {2393}let (hs_71: handshakestate,plaintext_e_1: bitstring,valid_41: bool) = (if v_791 then (if v_793 then (if v_810 then (if undo-catch-fail(v_811) then (hs_70,plaintext_47,true) else fail-any) else fail-any) else fail-any) else fail-any) in
        {2394}event RecvMsg(me_3,them_3,stagepack_e(sid_4),plaintext_e_1);
        {2395}event RecvEnd(valid_41)
    ) | (
        {2397}event LeakS(phase0,me_3);
        {2398}event LeakM(phase0,me_3);
        {2399}out(pub, (key_s(me_3),key_m(me_3)))
    ) | (
        {2400}phase 1;
        {2401}event LeakS(phase1,me_3);
        {2402}event LeakM(phase1,me_3);
        {2403}out(pub, (key_s(me_3),key_m(me_3)))
    )
)

-- Query event(RecvMsg(bob,alice,stagepack_a(sid_b),m_28)) ==> event(SendMsg(alice,bob,stagepack_a(sid_a),m_28)); event(RecvMsg(bob,alice,stagepack_a(sid_b),m_28)) ==> event(SendMsg(alice,c,stagepack_a(sid_a),m_28)) || (event(LeakS(phase0,alice)) && event(LeakM(phase0,alice))) || (event(LeakS(phase0,bob)) && event(LeakM(phase0,bob))); event(RecvMsg(bob,alice,stagepack_a(sid_b),m_28)) ==> event(SendMsg(alice,c,stagepack_a(sid_a),m_28)) || (event(LeakS(phase0,alice)) && event(LeakM(phase0,alice))); event(RecvMsg(bob,alice,stagepack_a(sid_b),m_28)) ==> event(SendMsg(alice,bob,stagepack_a(sid_a),m_28)) || (event(LeakS(phase0,alice)) && event(LeakM(phase0,alice))) || (event(LeakS(phase0,bob)) && event(LeakM(phase0,bob))); event(RecvMsg(bob,alice,stagepack_a(sid_b),m_28)) ==> event(SendMsg(alice,bob,stagepack_a(sid_a),m_28)) || (event(LeakS(phase0,alice)) && event(LeakM(phase0,alice))); not attacker_p1(msg_a(alice,bob,sid_a)); attacker_p1(msg_a(alice,bob,sid_a)) ==> event(LeakS(px,bob)) && event(LeakM(px,bob)); attacker_p1(msg_a(alice,bob,sid_a)) ==> event(LeakS(phase0,bob)) || (event(LeakS(px,bob)) && event(LeakM(px,bob)) && event(LeakS(pz,alice)) && event(LeakM(pz,alice))); attacker_p1(msg_a(alice,bob,sid_a)) ==> event(LeakS(phase0,bob)) && event(LeakM(phase0,bob)); event(RecvMsg(alice,bob,stagepack_b(sid_a),m_28)) ==> event(SendMsg(bob,alice,stagepack_b(sid_b),m_28)); event(RecvMsg(alice,bob,stagepack_b(sid_a),m_28)) ==> event(SendMsg(bob,c,stagepack_b(sid_b),m_28)) || (event(LeakS(phase0,bob)) && event(LeakM(phase0,bob))) || (event(LeakS(phase0,alice)) && event(LeakM(phase0,alice))); event(RecvMsg(alice,bob,stagepack_b(sid_a),m_28)) ==> event(SendMsg(bob,c,stagepack_b(sid_b),m_28)) || (event(LeakS(phase0,bob)) && event(LeakM(phase0,bob))); event(RecvMsg(alice,bob,stagepack_b(sid_a),m_28)) ==> event(SendMsg(bob,alice,stagepack_b(sid_b),m_28)) || (event(LeakS(phase0,bob)) && event(LeakM(phase0,bob))) || (event(LeakS(phase0,alice)) && event(LeakM(phase0,alice))); event(RecvMsg(alice,bob,stagepack_b(sid_a),m_28)) ==> event(SendMsg(bob,alice,stagepack_b(sid_b),m_28)) || (event(LeakS(phase0,bob)) && event(LeakM(phase0,bob))); not attacker_p1(msg_b(bob,alice,sid_b)); attacker_p1(msg_b(bob,alice,sid_b)) ==> event(LeakS(px,alice)) && event(LeakM(px,alice)); attacker_p1(msg_b(bob,alice,sid_b)) ==> (event(LeakS(phase0,alice)) && event(LeakM(phase0,alice))) || (event(LeakS(px,alice)) && event(LeakM(px,alice)) && event(LeakS(pz,bob)) && event(LeakM(pz,bob))); attacker_p1(msg_b(bob,alice,sid_b)) ==> event(LeakS(phase0,alice)) && event(LeakM(phase0,alice)); event(RecvMsg(bob,alice,stagepack_c(sid_b),m_28)) ==> event(SendMsg(alice,bob,stagepack_c(sid_a),m_28)); event(RecvMsg(bob,alice,stagepack_c(sid_b),m_28)) ==> event(SendMsg(alice,c,stagepack_c(sid_a),m_28)) || (event(LeakS(phase0,alice)) && event(LeakM(phase0,alice))) || (event(LeakS(phase0,bob)) && event(LeakM(phase0,bob))); event(RecvMsg(bob,alice,stagepack_c(sid_b),m_28)) ==> event(SendMsg(alice,c,stagepack_c(sid_a),m_28)) || (event(LeakS(phase0,alice)) && event(LeakM(phase0,alice))); event(RecvMsg(bob,alice,stagepack_c(sid_b),m_28)) ==> event(SendMsg(alice,bob,stagepack_c(sid_a),m_28)) || (event(LeakS(phase0,alice)) && event(LeakM(phase0,alice))) || (event(LeakS(phase0,bob)) && event(LeakM(phase0,bob))); event(RecvMsg(bob,alice,stagepack_c(sid_b),m_28)) ==> event(SendMsg(alice,bob,stagepack_c(sid_a),m_28)) || (event(LeakS(phase0,alice)) && event(LeakM(phase0,alice))); not attacker_p1(msg_c(alice,bob,sid_a)); attacker_p1(msg_c(alice,bob,sid_a)) ==> event(LeakS(px,bob)) && event(LeakM(px,bob)); attacker_p1(msg_c(alice,bob,sid_a)) ==> event(LeakS(phase0,bob)) || (event(LeakS(px,bob)) && event(LeakM(px,bob)) && event(LeakS(pz,alice)) && event(LeakM(pz,alice))); attacker_p1(msg_c(alice,bob,sid_a)) ==> event(LeakS(phase0,bob)) && event(LeakM(phase0,bob)); event(RecvMsg(alice,bob,stagepack_d(sid_a),m_28)) ==> event(SendMsg(bob,alice,stagepack_d(sid_b),m_28)); event(RecvMsg(alice,bob,stagepack_d(sid_a),m_28)) ==> event(SendMsg(bob,c,stagepack_d(sid_b),m_28)) || (event(LeakS(phase0,bob)) && event(LeakM(phase0,bob))) || (event(LeakS(phase0,alice)) && event(LeakM(phase0,alice))); event(RecvMsg(alice,bob,stagepack_d(sid_a),m_28)) ==> event(SendMsg(bob,c,stagepack_d(sid_b),m_28)) || (event(LeakS(phase0,bob)) && event(LeakM(phase0,bob))); event(RecvMsg(alice,bob,stagepack_d(sid_a),m_28)) ==> event(SendMsg(bob,alice,stagepack_d(sid_b),m_28)) || (event(LeakS(phase0,bob)) && event(LeakM(phase0,bob))) || (event(LeakS(phase0,alice)) && event(LeakM(phase0,alice))); event(RecvMsg(alice,bob,stagepack_d(sid_a),m_28)) ==> event(SendMsg(bob,alice,stagepack_d(sid_b),m_28)) || (event(LeakS(phase0,bob)) && event(LeakM(phase0,bob))); not attacker_p1(msg_d(bob,alice,sid_b)); attacker_p1(msg_d(bob,alice,sid_b)) ==> event(LeakS(px,alice)) && event(LeakM(px,alice)); attacker_p1(msg_d(bob,alice,sid_b)) ==> (event(LeakS(phase0,alice)) && event(LeakM(phase0,alice))) || (event(LeakS(px,alice)) && event(LeakM(px,alice)) && event(LeakS(pz,bob)) && event(LeakM(pz,bob))); attacker_p1(msg_d(bob,alice,sid_b)) ==> event(LeakS(phase0,alice)) && event(LeakM(phase0,alice)); event(RecvMsg(bob,alice,stagepack_e(sid_b),m_28)) ==> event(SendMsg(alice,bob,stagepack_e(sid_a),m_28)); event(RecvMsg(bob,alice,stagepack_e(sid_b),m_28)) ==> event(SendMsg(alice,c,stagepack_e(sid_a),m_28)) || (event(LeakS(phase0,alice)) && event(LeakM(phase0,alice))) || (event(LeakS(phase0,bob)) && event(LeakM(phase0,bob))); event(RecvMsg(bob,alice,stagepack_e(sid_b),m_28)) ==> event(SendMsg(alice,c,stagepack_e(sid_a),m_28)) || (event(LeakS(phase0,alice)) && event(LeakM(phase0,alice))); event(RecvMsg(bob,alice,stagepack_e(sid_b),m_28)) ==> event(SendMsg(alice,bob,stagepack_e(sid_a),m_28)) || (event(LeakS(phase0,alice)) && event(LeakM(phase0,alice))) || (event(LeakS(phase0,bob)) && event(LeakM(phase0,bob))); event(RecvMsg(bob,alice,stagepack_e(sid_b),m_28)) ==> event(SendMsg(alice,bob,stagepack_e(sid_a),m_28)) || (event(LeakS(phase0,alice)) && event(LeakM(phase0,alice))); not attacker_p1(msg_e(alice,bob,sid_a)); attacker_p1(msg_e(alice,bob,sid_a)) ==> event(LeakS(px,bob)) && event(LeakM(px,bob)); attacker_p1(msg_e(alice,bob,sid_a)) ==> (event(LeakS(phase0,bob)) && event(LeakM(phase0,bob))) || (event(LeakS(px,bob)) && event(LeakM(px,bob)) && event(LeakS(pz,alice)) && event(LeakM(pz,alice))); attacker_p1(msg_e(alice,bob,sid_a)) ==> event(LeakS(phase0,bob)) && event(LeakM(phase0,bob)); not event(RecvEnd(true)) in process 1.
Translating the process into Horn clauses...
Completing...
200 rules inserted. Base: 200 rules (87 with conclusion selected). Queue: 176 rules.
400 rules inserted. Base: 398 rules (126 with conclusion selected). Queue: 15 rules.
600 rules inserted. Base: 593 rules (284 with conclusion selected). Queue: 140 rules.
800 rules inserted. Base: 777 rules (359 with conclusion selected). Queue: 258 rules.
1000 rules inserted. Base: 941 rules (424 with conclusion selected). Queue: 378 rules.
1200 rules inserted. Base: 1052 rules (464 with conclusion selected). Queue: 335 rules.
1400 rules inserted. Base: 1164 rules (499 with conclusion selected). Queue: 306 rules.
1600 rules inserted. Base: 1293 rules (499 with conclusion selected). Queue: 373 rules.
1800 rules inserted. Base: 1404 rules (499 with conclusion selected). Queue: 435 rules.
2000 rules inserted. Base: 1511 rules (499 with conclusion selected). Queue: 495 rules.
2200 rules inserted. Base: 1563 rules (499 with conclusion selected). Queue: 522 rules.
2400 rules inserted. Base: 1607 rules (499 with conclusion selected). Queue: 544 rules.
2600 rules inserted. Base: 1664 rules (499 with conclusion selected). Queue: 570 rules.
2800 rules inserted. Base: 1750 rules (499 with conclusion selected). Queue: 644 rules.
3000 rules inserted. Base: 1839 rules (499 with conclusion selected). Queue: 713 rules.
3200 rules inserted. Base: 1920 rules (499 with conclusion selected). Queue: 784 rules.
3400 rules inserted. Base: 1997 rules (499 with conclusion selected). Queue: 837 rules.
3600 rules inserted. Base: 2070 rules (499 with conclusion selected). Queue: 898 rules.
3800 rules inserted. Base: 2147 rules (499 with conclusion selected). Queue: 950 rules.
4000 rules inserted. Base: 2201 rules (499 with conclusion selected). Queue: 1003 rules.
4200 rules inserted. Base: 2226 rules (499 with conclusion selected). Queue: 1056 rules.
4400 rules inserted. Base: 2278 rules (499 with conclusion selected). Queue: 1122 rules.
4600 rules inserted. Base: 2310 rules (499 with conclusion selected). Queue: 1163 rules.
4800 rules inserted. Base: 2347 rules (499 with conclusion selected). Queue: 1226 rules.
5000 rules inserted. Base: 2398 rules (499 with conclusion selected). Queue: 1284 rules.
5200 rules inserted. Base: 2456 rules (499 with conclusion selected). Queue: 1342 rules.
5400 rules inserted. Base: 2505 rules (499 with conclusion selected). Queue: 1402 rules.
5600 rules inserted. Base: 2561 rules (499 with conclusion selected). Queue: 1452 rules.
5800 rules inserted. Base: 2620 rules (499 with conclusion selected). Queue: 1510 rules.
6000 rules inserted. Base: 2667 rules (499 with conclusion selected). Queue: 1569 rules.
6200 rules inserted. Base: 2720 rules (499 with conclusion selected). Queue: 1604 rules.
6400 rules inserted. Base: 2767 rules (499 with conclusion selected). Queue: 1662 rules.
6600 rules inserted. Base: 2816 rules (499 with conclusion selected). Queue: 1715 rules.
6800 rules inserted. Base: 2858 rules (499 with conclusion selected). Queue: 1758 rules.
7000 rules inserted. Base: 2904 rules (499 with conclusion selected). Queue: 1794 rules.
7200 rules inserted. Base: 2949 rules (499 with conclusion selected). Queue: 1853 rules.
7400 rules inserted. Base: 2999 rules (499 with conclusion selected). Queue: 1906 rules.
7600 rules inserted. Base: 3043 rules (499 with conclusion selected). Queue: 1949 rules.
7800 rules inserted. Base: 3082 rules (499 with conclusion selected). Queue: 1996 rules.
8000 rules inserted. Base: 3105 rules (499 with conclusion selected). Queue: 2052 rules.
8200 rules inserted. Base: 3126 rules (499 with conclusion selected). Queue: 2102 rules.
8400 rules inserted. Base: 3154 rules (499 with conclusion selected). Queue: 2132 rules.
8600 rules inserted. Base: 3189 rules (499 with conclusion selected). Queue: 2166 rules.
8800 rules inserted. Base: 3218 rules (499 with conclusion selected). Queue: 2189 rules.
9000 rules inserted. Base: 3244 rules (499 with conclusion selected). Queue: 2246 rules.
9200 rules inserted. Base: 3263 rules (499 with conclusion selected). Queue: 2295 rules.
9400 rules inserted. Base: 3293 rules (499 with conclusion selected). Queue: 2326 rules.
9600 rules inserted. Base: 3332 rules (499 with conclusion selected). Queue: 2359 rules.
9800 rules inserted. Base: 3372 rules (499 with conclusion selected). Queue: 2406 rules.
10000 rules inserted. Base: 3406 rules (499 with conclusion selected). Queue: 2449 rules.
10200 rules inserted. Base: 3441 rules (499 with conclusion selected). Queue: 2484 rules.
10400 rules inserted. Base: 3463 rules (499 with conclusion selected). Queue: 2501 rules.
10600 rules inserted. Base: 3489 rules (499 with conclusion selected). Queue: 2506 rules.
10800 rules inserted. Base: 3519 rules (499 with conclusion selected). Queue: 2494 rules.
11000 rules inserted. Base: 3541 rules (499 with conclusion selected). Queue: 2488 rules.
11200 rules inserted. Base: 3567 rules (499 with conclusion selected). Queue: 2523 rules.
11400 rules inserted. Base: 3595 rules (499 with conclusion selected). Queue: 2556 rules.
11600 rules inserted. Base: 3628 rules (499 with conclusion selected). Queue: 2592 rules.
11800 rules inserted. Base: 3655 rules (499 with conclusion selected). Queue: 2598 rules.
12000 rules inserted. Base: 3673 rules (499 with conclusion selected). Queue: 2568 rules.
12200 rules inserted. Base: 3707 rules (499 with conclusion selected). Queue: 2602 rules.
12400 rules inserted. Base: 3743 rules (499 with conclusion selected). Queue: 2638 rules.
12600 rules inserted. Base: 3790 rules (499 with conclusion selected). Queue: 2674 rules.
12800 rules inserted. Base: 3831 rules (499 with conclusion selected). Queue: 2678 rules.
13000 rules inserted. Base: 3871 rules (499 with conclusion selected). Queue: 2718 rules.
13200 rules inserted. Base: 3926 rules (499 with conclusion selected). Queue: 2688 rules.
13400 rules inserted. Base: 3976 rules (499 with conclusion selected). Queue: 2611 rules.
13600 rules inserted. Base: 4023 rules (499 with conclusion selected). Queue: 2673 rules.
13800 rules inserted. Base: 4062 rules (499 with conclusion selected). Queue: 2710 rules.
14000 rules inserted. Base: 4101 rules (499 with conclusion selected). Queue: 2734 rules.
14200 rules inserted. Base: 4145 rules (499 with conclusion selected). Queue: 2739 rules.
14400 rules inserted. Base: 4196 rules (499 with conclusion selected). Queue: 2743 rules.
14600 rules inserted. Base: 4257 rules (499 with conclusion selected). Queue: 2693 rules.
14800 rules inserted. Base: 4294 rules (499 with conclusion selected). Queue: 2714 rules.
15000 rules inserted. Base: 4331 rules (499 with conclusion selected). Queue: 2791 rules.
15200 rules inserted. Base: 4369 rules (499 with conclusion selected). Queue: 2844 rules.
15400 rules inserted. Base: 4400 rules (499 with conclusion selected). Queue: 2888 rules.
15600 rules inserted. Base: 4435 rules (499 with conclusion selected). Queue: 2942 rules.
15800 rules inserted. Base: 4496 rules (499 with conclusion selected). Queue: 3025 rules.
16000 rules inserted. Base: 4559 rules (499 with conclusion selected). Queue: 3027 rules.
16200 rules inserted. Base: 4597 rules (499 with conclusion selected). Queue: 3126 rules.
16400 rules inserted. Base: 4641 rules (499 with conclusion selected). Queue: 3178 rules.
16600 rules inserted. Base: 4674 rules (499 with conclusion selected). Queue: 3226 rules.
16800 rules inserted. Base: 4702 rules (499 with conclusion selected). Queue: 3278 rules.
17000 rules inserted. Base: 4743 rules (499 with conclusion selected). Queue: 3349 rules.
17200 rules inserted. Base: 4833 rules (499 with conclusion selected). Queue: 3356 rules.
17400 rules inserted. Base: 4861 rules (499 with conclusion selected). Queue: 3421 rules.
17600 rules inserted. Base: 4901 rules (499 with conclusion selected). Queue: 3469 rules.
17800 rules inserted. Base: 4936 rules (499 with conclusion selected). Queue: 3468 rules.
18000 rules inserted. Base: 4967 rules (499 with conclusion selected). Queue: 3490 rules.
18200 rules inserted. Base: 4993 rules (499 with conclusion selected). Queue: 3534 rules.
18400 rules inserted. Base: 5027 rules (499 with conclusion selected). Queue: 3567 rules.
18600 rules inserted. Base: 5062 rules (499 with conclusion selected). Queue: 3621 rules.
18800 rules inserted. Base: 5142 rules (499 with conclusion selected). Queue: 3558 rules.
19000 rules inserted. Base: 5175 rules (499 with conclusion selected). Queue: 3619 rules.
19200 rules inserted. Base: 5208 rules (499 with conclusion selected). Queue: 3651 rules.
19400 rules inserted. Base: 5244 rules (499 with conclusion selected). Queue: 3670 rules.
19600 rules inserted. Base: 5269 rules (499 with conclusion selected). Queue: 3694 rules.
19800 rules inserted. Base: 5300 rules (499 with conclusion selected). Queue: 3734 rules.
20000 rules inserted. Base: 5335 rules (499 with conclusion selected). Queue: 3770 rules.
20200 rules inserted. Base: 5379 rules (499 with conclusion selected). Queue: 3818 rules.
20400 rules inserted. Base: 5442 rules (499 with conclusion selected). Queue: 3754 rules.
20600 rules inserted. Base: 5491 rules (499 with conclusion selected). Queue: 3776 rules.
20800 rules inserted. Base: 5512 rules (499 with conclusion selected). Queue: 3761 rules.
21000 rules inserted. Base: 5556 rules (499 with conclusion selected). Queue: 3745 rules.
21200 rules inserted. Base: 5592 rules (499 with conclusion selected). Queue: 3736 rules.
21400 rules inserted. Base: 5630 rules (499 with conclusion selected). Queue: 3735 rules.
21600 rules inserted. Base: 5655 rules (499 with conclusion selected). Queue: 3754 rules.
21800 rules inserted. Base: 5675 rules (499 with conclusion selected). Queue: 3770 rules.
22000 rules inserted. Base: 5715 rules (499 with conclusion selected). Queue: 3799 rules.
22200 rules inserted. Base: 5764 rules (499 with conclusion selected). Queue: 3711 rules.
22400 rules inserted. Base: 5811 rules (499 with conclusion selected). Queue: 3685 rules.
22600 rules inserted. Base: 5854 rules (499 with conclusion selected). Queue: 3665 rules.
22800 rules inserted. Base: 5893 rules (499 with conclusion selected). Queue: 3640 rules.
23000 rules inserted. Base: 5933 rules (499 with conclusion selected). Queue: 3631 rules.
23200 rules inserted. Base: 5969 rules (499 with conclusion selected). Queue: 3631 rules.
23400 rules inserted. Base: 5994 rules (499 with conclusion selected). Queue: 3659 rules.
23600 rules inserted. Base: 6020 rules (499 with conclusion selected). Queue: 3689 rules.
23800 rules inserted. Base: 6044 rules (499 with conclusion selected). Queue: 3706 rules.
24000 rules inserted. Base: 6092 rules (499 with conclusion selected). Queue: 3658 rules.
24200 rules inserted. Base: 6147 rules (499 with conclusion selected). Queue: 3583 rules.
24400 rules inserted. Base: 6200 rules (499 with conclusion selected). Queue: 3526 rules.
24600 rules inserted. Base: 6230 rules (499 with conclusion selected). Queue: 3513 rules.
24800 rules inserted. Base: 6270 rules (499 with conclusion selected). Queue: 3500 rules.
25000 rules inserted. Base: 6291 rules (499 with conclusion selected). Queue: 3489 rules.
25200 rules inserted. Base: 6319 rules (499 with conclusion selected). Queue: 3486 rules.
25400 rules inserted. Base: 6343 rules (499 with conclusion selected). Queue: 3489 rules.
25600 rules inserted. Base: 6364 rules (499 with conclusion selected). Queue: 3490 rules.
25800 rules inserted. Base: 6386 rules (499 with conclusion selected). Queue: 3489 rules.
26000 rules inserted. Base: 6460 rules (499 with conclusion selected). Queue: 3388 rules.
26200 rules inserted. Base: 6510 rules (499 with conclusion selected). Queue: 3329 rules.
26400 rules inserted. Base: 6551 rules (499 with conclusion selected). Queue: 3296 rules.
26600 rules inserted. Base: 6581 rules (499 with conclusion selected). Queue: 3288 rules.
26800 rules inserted. Base: 6611 rules (499 with conclusion selected). Queue: 3287 rules.
27000 rules inserted. Base: 6629 rules (499 with conclusion selected). Queue: 3289 rules.
27200 rules inserted. Base: 6655 rules (499 with conclusion selected). Queue: 3291 rules.
27400 rules inserted. Base: 6664 rules (499 with conclusion selected). Queue: 3275 rules.
27600 rules inserted. Base: 6704 rules (499 with conclusion selected). Queue: 3285 rules.
27800 rules inserted. Base: 6770 rules (499 with conclusion selected). Queue: 3186 rules.
28000 rules inserted. Base: 6803 rules (499 with conclusion selected). Queue: 3162 rules.
28200 rules inserted. Base: 6827 rules (499 with conclusion selected). Queue: 3168 rules.
28400 rules inserted. Base: 6845 rules (499 with conclusion selected). Queue: 3183 rules.
28600 rules inserted. Base: 6863 rules (499 with conclusion selected). Queue: 3181 rules.
28800 rules inserted. Base: 6868 rules (499 with conclusion selected). Queue: 3175 rules.
29000 rules inserted. Base: 6887 rules (499 with conclusion selected). Queue: 3173 rules.
29200 rules inserted. Base: 6900 rules (499 with conclusion selected). Queue: 3172 rules.
29400 rules inserted. Base: 6943 rules (499 with conclusion selected). Queue: 3150 rules.
29600 rules inserted. Base: 6982 rules (499 with conclusion selected). Queue: 3128 rules.
29800 rules inserted. Base: 7001 rules (499 with conclusion selected). Queue: 3134 rules.
30000 rules inserted. Base: 7026 rules (499 with conclusion selected). Queue: 3148 rules.
30200 rules inserted. Base: 7031 rules (499 with conclusion selected). Queue: 3142 rules.
30400 rules inserted. Base: 7050 rules (499 with conclusion selected). Queue: 3140 rules.
30600 rules inserted. Base: 7063 rules (499 with conclusion selected). Queue: 3139 rules.
30800 rules inserted. Base: 7083 rules (499 with conclusion selected). Queue: 3139 rules.
31000 rules inserted. Base: 7135 rules (499 with conclusion selected). Queue: 3145 rules.
31200 rules inserted. Base: 7176 rules (499 with conclusion selected). Queue: 3191 rules.
31400 rules inserted. Base: 7213 rules (499 with conclusion selected). Queue: 3216 rules.
31600 rules inserted. Base: 7250 rules (499 with conclusion selected). Queue: 3237 rules.
31800 rules inserted. Base: 7283 rules (499 with conclusion selected). Queue: 3255 rules.
32000 rules inserted. Base: 7319 rules (499 with conclusion selected). Queue: 3272 rules.
32200 rules inserted. Base: 7350 rules (499 with conclusion selected). Queue: 3284 rules.
32400 rules inserted. Base: 7384 rules (499 with conclusion selected). Queue: 3319 rules.
32600 rules inserted. Base: 7423 rules (499 with conclusion selected). Queue: 3363 rules.
32800 rules inserted. Base: 7460 rules (499 with conclusion selected). Queue: 3401 rules.
33000 rules inserted. Base: 7497 rules (499 with conclusion selected). Queue: 3424 rules.
33200 rules inserted. Base: 7537 rules (499 with conclusion selected). Queue: 3449 rules.
33400 rules inserted. Base: 7569 rules (499 with conclusion selected). Queue: 3455 rules.
33600 rules inserted. Base: 7595 rules (499 with conclusion selected). Queue: 3445 rules.
33800 rules inserted. Base: 7631 rules (499 with conclusion selected). Queue: 3461 rules.
34000 rules inserted. Base: 7656 rules (499 with conclusion selected). Queue: 3538 rules.
34200 rules inserted. Base: 7710 rules (499 with conclusion selected). Queue: 3570 rules.
34400 rules inserted. Base: 7735 rules (499 with conclusion selected). Queue: 3608 rules.
34600 rules inserted. Base: 7771 rules (499 with conclusion selected). Queue: 3621 rules.
34800 rules inserted. Base: 7805 rules (499 with conclusion selected). Queue: 3623 rules.
35000 rules inserted. Base: 7841 rules (499 with conclusion selected). Queue: 3643 rules.
35200 rules inserted. Base: 7879 rules (499 with conclusion selected). Queue: 3666 rules.
35400 rules inserted. Base: 7919 rules (499 with conclusion selected). Queue: 3680 rules.
35600 rules inserted. Base: 7960 rules (499 with conclusion selected). Queue: 3722 rules.
35800 rules inserted. Base: 7985 rules (499 with conclusion selected). Queue: 3783 rules.
36000 rules inserted. Base: 8025 rules (499 with conclusion selected). Queue: 3815 rules.
36200 rules inserted. Base: 8057 rules (499 with conclusion selected). Queue: 3829 rules.
36400 rules inserted. Base: 8093 rules (499 with conclusion selected). Queue: 3831 rules.
36600 rules inserted. Base: 8129 rules (499 with conclusion selected). Queue: 3852 rules.
36800 rules inserted. Base: 8170 rules (499 with conclusion selected). Queue: 3877 rules.
37000 rules inserted. Base: 8205 rules (499 with conclusion selected). Queue: 3896 rules.
37200 rules inserted. Base: 8239 rules (499 with conclusion selected). Queue: 3918 rules.
37400 rules inserted. Base: 8255 rules (499 with conclusion selected). Queue: 3963 rules.
37600 rules inserted. Base: 8281 rules (499 with conclusion selected). Queue: 3895 rules.
37800 rules inserted. Base: 8312 rules (499 with conclusion selected). Queue: 3862 rules.
38000 rules inserted. Base: 8342 rules (499 with conclusion selected). Queue: 3829 rules.
38200 rules inserted. Base: 8376 rules (499 with conclusion selected). Queue: 3826 rules.
38400 rules inserted. Base: 8392 rules (499 with conclusion selected). Queue: 3801 rules.
38600 rules inserted. Base: 8416 rules (499 with conclusion selected). Queue: 3801 rules.
38800 rules inserted. Base: 8454 rules (499 with conclusion selected). Queue: 3783 rules.
39000 rules inserted. Base: 8482 rules (499 with conclusion selected). Queue: 3775 rules.
39200 rules inserted. Base: 8507 rules (499 with conclusion selected). Queue: 3766 rules.
39400 rules inserted. Base: 8520 rules (499 with conclusion selected). Queue: 3722 rules.
39600 rules inserted. Base: 8565 rules (499 with conclusion selected). Queue: 3730 rules.
39800 rules inserted. Base: 8577 rules (499 with conclusion selected). Queue: 3712 rules.
40000 rules inserted. Base: 8595 rules (499 with conclusion selected). Queue: 3668 rules.
40200 rules inserted. Base: 8629 rules (499 with conclusion selected). Queue: 3630 rules.
40400 rules inserted. Base: 8657 rules (499 with conclusion selected). Queue: 3643 rules.
40600 rules inserted. Base: 8681 rules (499 with conclusion selected). Queue: 3634 rules.
40800 rules inserted. Base: 8708 rules (499 with conclusion selected). Queue: 3623 rules.
41000 rules inserted. Base: 8736 rules (499 with conclusion selected). Queue: 3616 rules.
41200 rules inserted. Base: 8764 rules (499 with conclusion selected). Queue: 3584 rules.
41400 rules inserted. Base: 8812 rules (499 with conclusion selected). Queue: 3544 rules.
41600 rules inserted. Base: 8857 rules (499 with conclusion selected). Queue: 3486 rules.
41800 rules inserted. Base: 8897 rules (499 with conclusion selected). Queue: 3448 rules.
42000 rules inserted. Base: 8933 rules (499 with conclusion selected). Queue: 3406 rules.
42200 rules inserted. Base: 8952 rules (499 with conclusion selected). Queue: 3357 rules.
42400 rules inserted. Base: 8954 rules (499 with conclusion selected). Queue: 3307 rules.
42600 rules inserted. Base: 8950 rules (499 with conclusion selected). Queue: 3260 rules.
42800 rules inserted. Base: 8946 rules (499 with conclusion selected). Queue: 3212 rules.
43000 rules inserted. Base: 8959 rules (499 with conclusion selected). Queue: 3170 rules.
43200 rules inserted. Base: 9007 rules (499 with conclusion selected). Queue: 3121 rules.
43400 rules inserted. Base: 9051 rules (499 with conclusion selected). Queue: 3062 rules.
43600 rules inserted. Base: 9091 rules (499 with conclusion selected). Queue: 3025 rules.
43800 rules inserted. Base: 9127 rules (499 with conclusion selected). Queue: 2981 rules.
44000 rules inserted. Base: 9146 rules (499 with conclusion selected). Queue: 2933 rules.
44200 rules inserted. Base: 9150 rules (499 with conclusion selected). Queue: 2884 rules.
44400 rules inserted. Base: 9148 rules (499 with conclusion selected). Queue: 2839 rules.
44600 rules inserted. Base: 9142 rules (499 with conclusion selected). Queue: 2789 rules.
44800 rules inserted. Base: 9195 rules (499 with conclusion selected). Queue: 2758 rules.
45000 rules inserted. Base: 9274 rules (499 with conclusion selected). Queue: 2738 rules.
45200 rules inserted. Base: 9335 rules (499 with conclusion selected). Queue: 2728 rules.
45400 rules inserted. Base: 9367 rules (499 with conclusion selected). Queue: 2759 rules.
45600 rules inserted. Base: 9399 rules (499 with conclusion selected). Queue: 2704 rules.
45800 rules inserted. Base: 9433 rules (499 with conclusion selected). Queue: 2622 rules.
46000 rules inserted. Base: 9462 rules (499 with conclusion selected). Queue: 2543 rules.
46200 rules inserted. Base: 9536 rules (499 with conclusion selected). Queue: 2505 rules.
46400 rules inserted. Base: 9612 rules (499 with conclusion selected). Queue: 2521 rules.
46600 rules inserted. Base: 9673 rules (499 with conclusion selected). Queue: 2508 rules.
46800 rules inserted. Base: 9717 rules (499 with conclusion selected). Queue: 2529 rules.
47000 rules inserted. Base: 9750 rules (499 with conclusion selected). Queue: 2468 rules.
47200 rules inserted. Base: 9775 rules (499 with conclusion selected). Queue: 2379 rules.
47400 rules inserted. Base: 9803 rules (499 with conclusion selected). Queue: 2268 rules.
47600 rules inserted. Base: 9857 rules (499 with conclusion selected). Queue: 2395 rules.
47800 rules inserted. Base: 9914 rules (499 with conclusion selected). Queue: 2463 rules.
48000 rules inserted. Base: 9947 rules (499 with conclusion selected). Queue: 2491 rules.
48200 rules inserted. Base: 9974 rules (499 with conclusion selected). Queue: 2505 rules.
48400 rules inserted. Base: 10054 rules (499 with conclusion selected). Queue: 2460 rules.
48600 rules inserted. Base: 10116 rules (499 with conclusion selected). Queue: 2585 rules.
48800 rules inserted. Base: 10160 rules (499 with conclusion selected). Queue: 2651 rules.
49000 rules inserted. Base: 10211 rules (499 with conclusion selected). Queue: 2684 rules.
49200 rules inserted. Base: 10231 rules (499 with conclusion selected). Queue: 2702 rules.
49400 rules inserted. Base: 10305 rules (499 with conclusion selected). Queue: 2646 rules.
49600 rules inserted. Base: 10350 rules (499 with conclusion selected). Queue: 2844 rules.
49800 rules inserted. Base: 10385 rules (499 with conclusion selected). Queue: 2734 rules.
50000 rules inserted. Base: 10423 rules (499 with conclusion selected). Queue: 2805 rules.
50200 rules inserted. Base: 10442 rules (499 with conclusion selected). Queue: 2771 rules.
50400 rules inserted. Base: 10489 rules (499 with conclusion selected). Queue: 2695 rules.
50600 rules inserted. Base: 10598 rules (499 with conclusion selected). Queue: 2580 rules.
50800 rules inserted. Base: 10598 rules (499 with conclusion selected). Queue: 2735 rules.
51000 rules inserted. Base: 10643 rules (499 with conclusion selected). Queue: 2639 rules.
51200 rules inserted. Base: 10670 rules (499 with conclusion selected). Queue: 2677 rules.
51400 rules inserted. Base: 10709 rules (499 with conclusion selected). Queue: 2661 rules.
51600 rules inserted. Base: 10757 rules (499 with conclusion selected). Queue: 2572 rules.
51800 rules inserted. Base: 10863 rules (499 with conclusion selected). Queue: 2523 rules.
52000 rules inserted. Base: 10906 rules (499 with conclusion selected). Queue: 2567 rules.
52200 rules inserted. Base: 10991 rules (499 with conclusion selected). Queue: 2385 rules.
52400 rules inserted. Base: 11033 rules (499 with conclusion selected). Queue: 2366 rules.
52600 rules inserted. Base: 11102 rules (499 with conclusion selected). Queue: 2285 rules.
52800 rules inserted. Base: 11212 rules (499 with conclusion selected). Queue: 2173 rules.
53000 rules inserted. Base: 11331 rules (499 with conclusion selected). Queue: 2138 rules.
53200 rules inserted. Base: 11356 rules (499 with conclusion selected). Queue: 2165 rules.
53400 rules inserted. Base: 11414 rules (499 with conclusion selected). Queue: 2030 rules.
53600 rules inserted. Base: 11484 rules (499 with conclusion selected). Queue: 1989 rules.
53800 rules inserted. Base: 11566 rules (499 with conclusion selected). Queue: 1909 rules.
54000 rules inserted. Base: 11675 rules (499 with conclusion selected). Queue: 1777 rules.
54200 rules inserted. Base: 11793 rules (499 with conclusion selected). Queue: 1678 rules.
54400 rules inserted. Base: 11904 rules (499 with conclusion selected). Queue: 1548 rules.
54600 rules inserted. Base: 12009 rules (499 with conclusion selected). Queue: 1457 rules.
54800 rules inserted. Base: 12119 rules (499 with conclusion selected). Queue: 1328 rules.
55000 rules inserted. Base: 12237 rules (499 with conclusion selected). Queue: 1217 rules.
55200 rules inserted. Base: 12337 rules (499 with conclusion selected). Queue: 1107 rules.
55400 rules inserted. Base: 12445 rules (499 with conclusion selected). Queue: 1012 rules.
55600 rules inserted. Base: 12553 rules (499 with conclusion selected). Queue: 886 rules.
55800 rules inserted. Base: 12696 rules (499 with conclusion selected). Queue: 731 rules.
56000 rules inserted. Base: 12821 rules (499 with conclusion selected). Queue: 603 rules.
56200 rules inserted. Base: 12976 rules (499 with conclusion selected). Queue: 439 rules.
56400 rules inserted. Base: 13105 rules (499 with conclusion selected). Queue: 308 rules.
56600 rules inserted. Base: 13257 rules (499 with conclusion selected). Queue: 140 rules.
Starting query event(RecvMsg(bob,alice,stagepack_a(sid_b),m_28)) ==> event(SendMsg(alice,bob,stagepack_a(sid_a),m_28))
goal reachable: begin(SendMsg(alice,charlie,stagepack_a(sid_5),msg_a(alice,charlie,sid_5))) -> end(RecvMsg(bob,alice,stagepack_a(sid_6),msg_a(alice,charlie,sid_5)))
Abbreviations:
sid_6 = sid[!1 = @sid]
sid_5 = sid[!1 = @sid_1]

Derivation:
Abbreviations:
sid_5 = sid[!1 = @sid]
sid_6 = sid[!1 = @sid_1]

1. The entry statestore(bob,alice,sid_5,statepack_a(handshakestatepack(symmetricstatepack(cipherstatepack(empty,minnonce),hash(somename,empty),hash(hash(somename,empty),empty)),keypairpack(empty,empty),keypairpack(empty,empty),keypairpack(empty,empty),empty,empty,empty,empty,false))) may be inserted in a table at insert {1224}.
table(statestore(bob,alice,sid_5,statepack_a(handshakestatepack(symmetricstatepack(cipherstatepack(empty,minnonce),hash(somename,empty),hash(hash(somename,empty),empty)),keypairpack(empty,empty),keypairpack(empty,empty),keypairpack(empty,empty),empty,empty,empty,empty,false)))).

2. The entry statestore(alice,charlie,sid_6,statepack_a(handshakestatepack(symmetricstatepack(cipherstatepack(empty,minnonce),hash(somename,empty),hash(hash(somename,empty),empty)),keypairpack(empty,empty),keypairpack(empty,empty),keypairpack(empty,empty),empty,empty,empty,empty,true))) may be inserted in a table at insert {627}.
table(statestore(alice,charlie,sid_6,statepack_a(handshakestatepack(symmetricstatepack(cipherstatepack(empty,minnonce),hash(somename,empty),hash(hash(somename,empty),empty)),keypairpack(empty,empty),keypairpack(empty,empty),keypairpack(empty,empty),empty,empty,empty,empty,true)))).

3. The entry statestore(alice,charlie,sid_6,statepack_a(handshakestatepack(symmetricstatepack(cipherstatepack(empty,minnonce),hash(somename,empty),hash(hash(somename,empty),empty)),keypairpack(empty,empty),keypairpack(empty,empty),keypairpack(empty,empty),empty,empty,empty,empty,true))) that may be in a table by 2 may be read at get {698}.
The event SendMsg(alice,charlie,stagepack_a(sid_6),msg_a(alice,charlie,sid_6)) may be executed at {695}.
So the message concat3(validkey(dhexp_real(key_e(alice,charlie,sid_6),g)),empty,encrypt(empty,minnonce,hash(hash(hash(somename,empty),empty),validkey(dhexp_real(key_e(alice,charlie,sid_6),g))),msg_a(alice,charlie,sid_6))) may be sent on channel pub at output {697}.
mess(pub,concat3(validkey(dhexp_real(key_e(alice,charlie,sid_6),g)),empty,encrypt(empty,minnonce,hash(hash(hash(somename,empty),empty),validkey(dhexp_real(key_e(alice,charlie,sid_6),g))),msg_a(alice,charlie,sid_6)))).

4. The entry statestore(bob,alice,sid_5,statepack_a(handshakestatepack(symmetricstatepack(cipherstatepack(empty,minnonce),hash(somename,empty),hash(hash(somename,empty),empty)),keypairpack(empty,empty),keypairpack(empty,empty),keypairpack(empty,empty),empty,empty,empty,empty,false))) that may be in a table by 1 may be read at get {1297}.
The message concat3(validkey(dhexp_real(key_e(alice,charlie,sid_6),g)),empty,encrypt(empty,minnonce,hash(hash(hash(somename,empty),empty),validkey(dhexp_real(key_e(alice,charlie,sid_6),g))),msg_a(alice,charlie,sid_6))) that may be sent on channel pub by 3 may be received at input {1225}.
So event RecvMsg(bob,alice,stagepack_a(sid_5),msg_a(alice,charlie,sid_6)) may be executed at {1295}.
end(RecvMsg(bob,alice,stagepack_a(sid_5),msg_a(alice,charlie,sid_6))).

5. By 4, end(RecvMsg(bob,alice,stagepack_a(sid_5),msg_a(alice,charlie,sid_6))).
The goal is reached, represented in the following fact:
end(RecvMsg(bob,alice,stagepack_a(sid_5),msg_a(alice,charlie,sid_6))).


RESULT event(RecvMsg(bob,alice,stagepack_a(sid_b),m_28)) ==> event(SendMsg(alice,bob,stagepack_a(sid_a),m_28)) cannot be proved.
Starting query event(RecvMsg(bob,alice,stagepack_a(sid_b),m_28)) ==> event(SendMsg(alice,c,stagepack_a(sid_a),m_28)) || (event(LeakS(phase0,alice)) && event(LeakM(phase0,alice))) || (event(LeakS(phase0,bob)) && event(LeakM(phase0,bob)))
goal reachable: begin(SendMsg(alice,bob,stagepack_a(sid_5),msg_a(alice,bob,sid_5))) -> end(RecvMsg(bob,alice,stagepack_a(sid_6),msg_a(alice,bob,sid_5)))
Abbreviations:
sid_6 = sid[!1 = @sid]
sid_5 = sid[!1 = @sid_1]
goal reachable: begin(SendMsg(alice,charlie,stagepack_a(sid_5),msg_a(alice,charlie,sid_5))) -> end(RecvMsg(bob,alice,stagepack_a(sid_6),msg_a(alice,charlie,sid_5)))
Abbreviations:
sid_6 = sid[!1 = @sid]
sid_5 = sid[!1 = @sid_1]
RESULT event(RecvMsg(bob,alice,stagepack_a(sid_b),m_28)) ==> event(SendMsg(alice,c,stagepack_a(sid_a),m_28)) || (event(LeakS(phase0,alice)) && event(LeakM(phase0,alice))) || (event(LeakS(phase0,bob)) && event(LeakM(phase0,bob))) is true.
Starting query event(RecvMsg(bob,alice,stagepack_a(sid_b),m_28)) ==> event(SendMsg(alice,c,stagepack_a(sid_a),m_28)) || (event(LeakS(phase0,alice)) && event(LeakM(phase0,alice)))
goal reachable: begin(SendMsg(alice,bob,stagepack_a(sid_5),msg_a(alice,bob,sid_5))) -> end(RecvMsg(bob,alice,stagepack_a(sid_6),msg_a(alice,bob,sid_5)))
Abbreviations:
sid_6 = sid[!1 = @sid]
sid_5 = sid[!1 = @sid_1]
goal reachable: begin(SendMsg(alice,charlie,stagepack_a(sid_5),msg_a(alice,charlie,sid_5))) -> end(RecvMsg(bob,alice,stagepack_a(sid_6),msg_a(alice,charlie,sid_5)))
Abbreviations:
sid_6 = sid[!1 = @sid]
sid_5 = sid[!1 = @sid_1]
RESULT event(RecvMsg(bob,alice,stagepack_a(sid_b),m_28)) ==> event(SendMsg(alice,c,stagepack_a(sid_a),m_28)) || (event(LeakS(phase0,alice)) && event(LeakM(phase0,alice))) is true.
Starting query event(RecvMsg(bob,alice,stagepack_a(sid_b),m_28)) ==> event(SendMsg(alice,bob,stagepack_a(sid_a),m_28)) || (event(LeakS(phase0,alice)) && event(LeakM(phase0,alice))) || (event(LeakS(phase0,bob)) && event(LeakM(phase0,bob)))
goal reachable: begin(SendMsg(alice,charlie,stagepack_a(sid_5),msg_a(alice,charlie,sid_5))) -> end(RecvMsg(bob,alice,stagepack_a(sid_6),msg_a(alice,charlie,sid_5)))
Abbreviations:
sid_6 = sid[!1 = @sid]
sid_5 = sid[!1 = @sid_1]

Derivation:
Abbreviations:
sid_5 = sid[!1 = @sid]
sid_6 = sid[!1 = @sid_1]

1. The entry statestore(bob,alice,sid_5,statepack_a(handshakestatepack(symmetricstatepack(cipherstatepack(empty,minnonce),hash(somename,empty),hash(hash(somename,empty),empty)),keypairpack(empty,empty),keypairpack(empty,empty),keypairpack(empty,empty),empty,empty,empty,empty,false))) may be inserted in a table at insert {1224}.
table(statestore(bob,alice,sid_5,statepack_a(handshakestatepack(symmetricstatepack(cipherstatepack(empty,minnonce),hash(somename,empty),hash(hash(somename,empty),empty)),keypairpack(empty,empty),keypairpack(empty,empty),keypairpack(empty,empty),empty,empty,empty,empty,false)))).

2. The entry statestore(alice,charlie,sid_6,statepack_a(handshakestatepack(symmetricstatepack(cipherstatepack(empty,minnonce),hash(somename,empty),hash(hash(somename,empty),empty)),keypairpack(empty,empty),keypairpack(empty,empty),keypairpack(empty,empty),empty,empty,empty,empty,true))) may be inserted in a table at insert {627}.
table(statestore(alice,charlie,sid_6,statepack_a(handshakestatepack(symmetricstatepack(cipherstatepack(empty,minnonce),hash(somename,empty),hash(hash(somename,empty),empty)),keypairpack(empty,empty),keypairpack(empty,empty),keypairpack(empty,empty),empty,empty,empty,empty,true)))).

3. The entry statestore(alice,charlie,sid_6,statepack_a(handshakestatepack(symmetricstatepack(cipherstatepack(empty,minnonce),hash(somename,empty),hash(hash(somename,empty),empty)),keypairpack(empty,empty),keypairpack(empty,empty),keypairpack(empty,empty),empty,empty,empty,empty,true))) that may be in a table by 2 may be read at get {698}.
The event SendMsg(alice,charlie,stagepack_a(sid_6),msg_a(alice,charlie,sid_6)) may be executed at {695}.
So the message concat3(validkey(dhexp_real(key_e(alice,charlie,sid_6),g)),empty,encrypt(empty,minnonce,hash(hash(hash(somename,empty),empty),validkey(dhexp_real(key_e(alice,charlie,sid_6),g))),msg_a(alice,charlie,sid_6))) may be sent on channel pub at output {697}.
mess(pub,concat3(validkey(dhexp_real(key_e(alice,charlie,sid_6),g)),empty,encrypt(empty,minnonce,hash(hash(hash(somename,empty),empty),validkey(dhexp_real(key_e(alice,charlie,sid_6),g))),msg_a(alice,charlie,sid_6)))).

4. The entry statestore(bob,alice,sid_5,statepack_a(handshakestatepack(symmetricstatepack(cipherstatepack(empty,minnonce),hash(somename,empty),hash(hash(somename,empty),empty)),keypairpack(empty,empty),keypairpack(empty,empty),keypairpack(empty,empty),empty,empty,empty,empty,false))) that may be in a table by 1 may be read at get {1297}.
The message concat3(validkey(dhexp_real(key_e(alice,charlie,sid_6),g)),empty,encrypt(empty,minnonce,hash(hash(hash(somename,empty),empty),validkey(dhexp_real(key_e(alice,charlie,sid_6),g))),msg_a(alice,charlie,sid_6))) that may be sent on channel pub by 3 may be received at input {1225}.
So event RecvMsg(bob,alice,stagepack_a(sid_5),msg_a(alice,charlie,sid_6)) may be executed at {1295}.
end(RecvMsg(bob,alice,stagepack_a(sid_5),msg_a(alice,charlie,sid_6))).

5. By 4, end(RecvMsg(bob,alice,stagepack_a(sid_5),msg_a(alice,charlie,sid_6))).
The goal is reached, represented in the following fact:
end(RecvMsg(bob,alice,stagepack_a(sid_5),msg_a(alice,charlie,sid_6))).


RESULT event(RecvMsg(bob,alice,stagepack_a(sid_b),m_28)) ==> event(SendMsg(alice,bob,stagepack_a(sid_a),m_28)) || (event(LeakS(phase0,alice)) && event(LeakM(phase0,alice))) || (event(LeakS(phase0,bob)) && event(LeakM(phase0,bob))) cannot be proved.
Starting query event(RecvMsg(bob,alice,stagepack_a(sid_b),m_28)) ==> event(SendMsg(alice,bob,stagepack_a(sid_a),m_28)) || (event(LeakS(phase0,alice)) && event(LeakM(phase0,alice)))
goal reachable: begin(SendMsg(alice,charlie,stagepack_a(sid_5),msg_a(alice,charlie,sid_5))) -> end(RecvMsg(bob,alice,stagepack_a(sid_6),msg_a(alice,charlie,sid_5)))
Abbreviations:
sid_6 = sid[!1 = @sid]
sid_5 = sid[!1 = @sid_1]

Derivation:
Abbreviations:
sid_5 = sid[!1 = @sid]
sid_6 = sid[!1 = @sid_1]

1. The entry statestore(bob,alice,sid_5,statepack_a(handshakestatepack(symmetricstatepack(cipherstatepack(empty,minnonce),hash(somename,empty),hash(hash(somename,empty),empty)),keypairpack(empty,empty),keypairpack(empty,empty),keypairpack(empty,empty),empty,empty,empty,empty,false))) may be inserted in a table at insert {1224}.
table(statestore(bob,alice,sid_5,statepack_a(handshakestatepack(symmetricstatepack(cipherstatepack(empty,minnonce),hash(somename,empty),hash(hash(somename,empty),empty)),keypairpack(empty,empty),keypairpack(empty,empty),keypairpack(empty,empty),empty,empty,empty,empty,false)))).

2. The entry statestore(alice,charlie,sid_6,statepack_a(handshakestatepack(symmetricstatepack(cipherstatepack(empty,minnonce),hash(somename,empty),hash(hash(somename,empty),empty)),keypairpack(empty,empty),keypairpack(empty,empty),keypairpack(empty,empty),empty,empty,empty,empty,true))) may be inserted in a table at insert {627}.
table(statestore(alice,charlie,sid_6,statepack_a(handshakestatepack(symmetricstatepack(cipherstatepack(empty,minnonce),hash(somename,empty),hash(hash(somename,empty),empty)),keypairpack(empty,empty),keypairpack(empty,empty),keypairpack(empty,empty),empty,empty,empty,empty,true)))).

3. The entry statestore(alice,charlie,sid_6,statepack_a(handshakestatepack(symmetricstatepack(cipherstatepack(empty,minnonce),hash(somename,empty),hash(hash(somename,empty),empty)),keypairpack(empty,empty),keypairpack(empty,empty),keypairpack(empty,empty),empty,empty,empty,empty,true))) that may be in a table by 2 may be read at get {698}.
The event SendMsg(alice,charlie,stagepack_a(sid_6),msg_a(alice,charlie,sid_6)) may be executed at {695}.
So the message concat3(validkey(dhexp_real(key_e(alice,charlie,sid_6),g)),empty,encrypt(empty,minnonce,hash(hash(hash(somename,empty),empty),validkey(dhexp_real(key_e(alice,charlie,sid_6),g))),msg_a(alice,charlie,sid_6))) may be sent on channel pub at output {697}.
mess(pub,concat3(validkey(dhexp_real(key_e(alice,charlie,sid_6),g)),empty,encrypt(empty,minnonce,hash(hash(hash(somename,empty),empty),validkey(dhexp_real(key_e(alice,charlie,sid_6),g))),msg_a(alice,charlie,sid_6)))).

4. The entry statestore(bob,alice,sid_5,statepack_a(handshakestatepack(symmetricstatepack(cipherstatepack(empty,minnonce),hash(somename,empty),hash(hash(somename,empty),empty)),keypairpack(empty,empty),keypairpack(empty,empty),keypairpack(empty,empty),empty,empty,empty,empty,false))) that may be in a table by 1 may be read at get {1297}.
The message concat3(validkey(dhexp_real(key_e(alice,charlie,sid_6),g)),empty,encrypt(empty,minnonce,hash(hash(hash(somename,empty),empty),validkey(dhexp_real(key_e(alice,charlie,sid_6),g))),msg_a(alice,charlie,sid_6))) that may be sent on channel pub by 3 may be received at input {1225}.
So event RecvMsg(bob,alice,stagepack_a(sid_5),msg_a(alice,charlie,sid_6)) may be executed at {1295}.
end(RecvMsg(bob,alice,stagepack_a(sid_5),msg_a(alice,charlie,sid_6))).

5. By 4, end(RecvMsg(bob,alice,stagepack_a(sid_5),msg_a(alice,charlie,sid_6))).
The goal is reached, represented in the following fact:
end(RecvMsg(bob,alice,stagepack_a(sid_5),msg_a(alice,charlie,sid_6))).


RESULT event(RecvMsg(bob,alice,stagepack_a(sid_b),m_28)) ==> event(SendMsg(alice,bob,stagepack_a(sid_a),m_28)) || (event(LeakS(phase0,alice)) && event(LeakM(phase0,alice))) cannot be proved.
Starting query not attacker_p1(msg_a(alice,bob,sid_a))
goal reachable: begin(SendMsg(alice,bob,stagepack_a(sid_5),msg_a(alice,bob,sid_5))) -> attacker_p1(msg_a(alice,bob,sid_5))
Abbreviations:
sid_5 = sid[!1 = @sid]

Derivation:
Abbreviations:
sid_5 = sid[!1 = @sid]

1. Using the function pub the attacker may obtain pub.
attacker(pub).

2. The entry statestore(alice,bob,sid_5,statepack_a(handshakestatepack(symmetricstatepack(cipherstatepack(empty,minnonce),hash(somename,empty),hash(hash(somename,empty),empty)),keypairpack(empty,empty),keypairpack(empty,empty),keypairpack(empty,empty),empty,empty,empty,empty,true))) may be inserted in a table at insert {30}.
table(statestore(alice,bob,sid_5,statepack_a(handshakestatepack(symmetricstatepack(cipherstatepack(empty,minnonce),hash(somename,empty),hash(hash(somename,empty),empty)),keypairpack(empty,empty),keypairpack(empty,empty),keypairpack(empty,empty),empty,empty,empty,empty,true)))).

3. The entry statestore(alice,bob,sid_5,statepack_a(handshakestatepack(symmetricstatepack(cipherstatepack(empty,minnonce),hash(somename,empty),hash(hash(somename,empty),empty)),keypairpack(empty,empty),keypairpack(empty,empty),keypairpack(empty,empty),empty,empty,empty,empty,true))) that may be in a table by 2 may be read at get {101}.
The event SendMsg(alice,bob,stagepack_a(sid_5),msg_a(alice,bob,sid_5)) may be executed at {98}.
So the message concat3(validkey(dhexp_real(key_e(alice,bob,sid_5),g)),empty,encrypt(empty,minnonce,hash(hash(hash(somename,empty),empty),validkey(dhexp_real(key_e(alice,bob,sid_5),g))),msg_a(alice,bob,sid_5))) may be sent on channel pub at output {100}.
mess(pub,concat3(validkey(dhexp_real(key_e(alice,bob,sid_5),g)),empty,encrypt(empty,minnonce,hash(hash(hash(somename,empty),empty),validkey(dhexp_real(key_e(alice,bob,sid_5),g))),msg_a(alice,bob,sid_5)))).

4. By 1, the attacker may have the channel pub.
By 3, the message concat3(validkey(dhexp_real(key_e(alice,bob,sid_5),g)),empty,encrypt(empty,minnonce,hash(hash(hash(somename,empty),empty),validkey(dhexp_real(key_e(alice,bob,sid_5),g))),msg_a(alice,bob,sid_5))) may be sent on this channel.
So the attacker may obtain the message concat3(validkey(dhexp_real(key_e(alice,bob,sid_5),g)),empty,encrypt(empty,minnonce,hash(hash(hash(somename,empty),empty),validkey(dhexp_real(key_e(alice,bob,sid_5),g))),msg_a(alice,bob,sid_5))) by listening on this channel.
attacker(concat3(validkey(dhexp_real(key_e(alice,bob,sid_5),g)),empty,encrypt(empty,minnonce,hash(hash(hash(somename,empty),empty),validkey(dhexp_real(key_e(alice,bob,sid_5),g))),msg_a(alice,bob,sid_5)))).

5. By 4, the attacker may know concat3(validkey(dhexp_real(key_e(alice,bob,sid_5),g)),empty,encrypt(empty,minnonce,hash(hash(hash(somename,empty),empty),validkey(dhexp_real(key_e(alice,bob,sid_5),g))),msg_a(alice,bob,sid_5))).
Using the function 3-proj-concat3 the attacker may obtain encrypt(empty,minnonce,hash(hash(hash(somename,empty),empty),validkey(dhexp_real(key_e(alice,bob,sid_5),g))),msg_a(alice,bob,sid_5)).
attacker(encrypt(empty,minnonce,hash(hash(hash(somename,empty),empty),validkey(dhexp_real(key_e(alice,bob,sid_5),g))),msg_a(alice,bob,sid_5))).

6. By 4, the attacker may know concat3(validkey(dhexp_real(key_e(alice,bob,sid_5),g)),empty,encrypt(empty,minnonce,hash(hash(hash(somename,empty),empty),validkey(dhexp_real(key_e(alice,bob,sid_5),g))),msg_a(alice,bob,sid_5))).
Using the function 1-proj-concat3 the attacker may obtain validkey(dhexp_real(key_e(alice,bob,sid_5),g)).
attacker(validkey(dhexp_real(key_e(alice,bob,sid_5),g))).

7. Using the function empty the attacker may obtain empty.
attacker(empty).

8. Using the function somename the attacker may obtain somename.
attacker(somename).

9. By 8, the attacker may know somename.
By 7, the attacker may know empty.
Using the function hash the attacker may obtain hash(somename,empty).
attacker(hash(somename,empty)).

10. By 9, the attacker may know hash(somename,empty).
By 7, the attacker may know empty.
Using the function hash the attacker may obtain hash(hash(somename,empty),empty).
attacker(hash(hash(somename,empty),empty)).

11. By 10, the attacker may know hash(hash(somename,empty),empty).
By 6, the attacker may know validkey(dhexp_real(key_e(alice,bob,sid_5),g)).
Using the function hash the attacker may obtain hash(hash(hash(somename,empty),empty),validkey(dhexp_real(key_e(alice,bob,sid_5),g))).
attacker(hash(hash(hash(somename,empty),empty),validkey(dhexp_real(key_e(alice,bob,sid_5),g)))).

12. Using the function minnonce the attacker may obtain minnonce.
attacker(minnonce).

13. By 7, the attacker may know empty.
By 12, the attacker may know minnonce.
By 11, the attacker may know hash(hash(hash(somename,empty),empty),validkey(dhexp_real(key_e(alice,bob,sid_5),g))).
By 5, the attacker may know encrypt(empty,minnonce,hash(hash(hash(somename,empty),empty),validkey(dhexp_real(key_e(alice,bob,sid_5),g))),msg_a(alice,bob,sid_5)).
Using the function decrypt the attacker may obtain aeadpack(true,hash(hash(hash(somename,empty),empty),validkey(dhexp_real(key_e(alice,bob,sid_5),g))),msg_a(alice,bob,sid_5)).
attacker(aeadpack(true,hash(hash(hash(somename,empty),empty),validkey(dhexp_real(key_e(alice,bob,sid_5),g))),msg_a(alice,bob,sid_5))).

14. By 13, the attacker may know aeadpack(true,hash(hash(hash(somename,empty),empty),validkey(dhexp_real(key_e(alice,bob,sid_5),g))),msg_a(alice,bob,sid_5)).
Using the function 3-proj-aeadpack the attacker may obtain msg_a(alice,bob,sid_5).
attacker(msg_a(alice,bob,sid_5)).

15. By 14, the attacker may know msg_a(alice,bob,sid_5).
So the attacker may know msg_a(alice,bob,sid_5) in phase 1.
attacker_p1(msg_a(alice,bob,sid_5)).

16. By 15, attacker_p1(msg_a(alice,bob,sid_5)).
The goal is reached, represented in the following fact:
attacker_p1(msg_a(alice,bob,sid_5)).


RESULT not attacker_p1(msg_a(alice,bob,sid_a)) cannot be proved.
Starting query attacker_p1(msg_a(alice,bob,sid_a)) ==> event(LeakS(px,bob)) && event(LeakM(px,bob))
goal reachable: begin(SendMsg(alice,bob,stagepack_a(sid_5),msg_a(alice,bob,sid_5))) -> attacker_p1(msg_a(alice,bob,sid_5))
Abbreviations:
sid_5 = sid[!1 = @sid]

Derivation:
Abbreviations:
sid_5 = sid[!1 = @sid]

1. Using the function pub the attacker may obtain pub.
attacker(pub).

2. The entry statestore(alice,bob,sid_5,statepack_a(handshakestatepack(symmetricstatepack(cipherstatepack(empty,minnonce),hash(somename,empty),hash(hash(somename,empty),empty)),keypairpack(empty,empty),keypairpack(empty,empty),keypairpack(empty,empty),empty,empty,empty,empty,true))) may be inserted in a table at insert {30}.
table(statestore(alice,bob,sid_5,statepack_a(handshakestatepack(symmetricstatepack(cipherstatepack(empty,minnonce),hash(somename,empty),hash(hash(somename,empty),empty)),keypairpack(empty,empty),keypairpack(empty,empty),keypairpack(empty,empty),empty,empty,empty,empty,true)))).

3. The entry statestore(alice,bob,sid_5,statepack_a(handshakestatepack(symmetricstatepack(cipherstatepack(empty,minnonce),hash(somename,empty),hash(hash(somename,empty),empty)),keypairpack(empty,empty),keypairpack(empty,empty),keypairpack(empty,empty),empty,empty,empty,empty,true))) that may be in a table by 2 may be read at get {101}.
The event SendMsg(alice,bob,stagepack_a(sid_5),msg_a(alice,bob,sid_5)) may be executed at {98}.
So the message concat3(validkey(dhexp_real(key_e(alice,bob,sid_5),g)),empty,encrypt(empty,minnonce,hash(hash(hash(somename,empty),empty),validkey(dhexp_real(key_e(alice,bob,sid_5),g))),msg_a(alice,bob,sid_5))) may be sent on channel pub at output {100}.
mess(pub,concat3(validkey(dhexp_real(key_e(alice,bob,sid_5),g)),empty,encrypt(empty,minnonce,hash(hash(hash(somename,empty),empty),validkey(dhexp_real(key_e(alice,bob,sid_5),g))),msg_a(alice,bob,sid_5)))).

4. By 1, the attacker may have the channel pub.
By 3, the message concat3(validkey(dhexp_real(key_e(alice,bob,sid_5),g)),empty,encrypt(empty,minnonce,hash(hash(hash(somename,empty),empty),validkey(dhexp_real(key_e(alice,bob,sid_5),g))),msg_a(alice,bob,sid_5))) may be sent on this channel.
So the attacker may obtain the message concat3(validkey(dhexp_real(key_e(alice,bob,sid_5),g)),empty,encrypt(empty,minnonce,hash(hash(hash(somename,empty),empty),validkey(dhexp_real(key_e(alice,bob,sid_5),g))),msg_a(alice,bob,sid_5))) by listening on this channel.
attacker(concat3(validkey(dhexp_real(key_e(alice,bob,sid_5),g)),empty,encrypt(empty,minnonce,hash(hash(hash(somename,empty),empty),validkey(dhexp_real(key_e(alice,bob,sid_5),g))),msg_a(alice,bob,sid_5)))).

5. By 4, the attacker may know concat3(validkey(dhexp_real(key_e(alice,bob,sid_5),g)),empty,encrypt(empty,minnonce,hash(hash(hash(somename,empty),empty),validkey(dhexp_real(key_e(alice,bob,sid_5),g))),msg_a(alice,bob,sid_5))).
Using the function 3-proj-concat3 the attacker may obtain encrypt(empty,minnonce,hash(hash(hash(somename,empty),empty),validkey(dhexp_real(key_e(alice,bob,sid_5),g))),msg_a(alice,bob,sid_5)).
attacker(encrypt(empty,minnonce,hash(hash(hash(somename,empty),empty),validkey(dhexp_real(key_e(alice,bob,sid_5),g))),msg_a(alice,bob,sid_5))).

6. By 4, the attacker may know concat3(validkey(dhexp_real(key_e(alice,bob,sid_5),g)),empty,encrypt(empty,minnonce,hash(hash(hash(somename,empty),empty),validkey(dhexp_real(key_e(alice,bob,sid_5),g))),msg_a(alice,bob,sid_5))).
Using the function 1-proj-concat3 the attacker may obtain validkey(dhexp_real(key_e(alice,bob,sid_5),g)).
attacker(validkey(dhexp_real(key_e(alice,bob,sid_5),g))).

7. Using the function empty the attacker may obtain empty.
attacker(empty).

8. Using the function somename the attacker may obtain somename.
attacker(somename).

9. By 8, the attacker may know somename.
By 7, the attacker may know empty.
Using the function hash the attacker may obtain hash(somename,empty).
attacker(hash(somename,empty)).

10. By 9, the attacker may know hash(somename,empty).
By 7, the attacker may know empty.
Using the function hash the attacker may obtain hash(hash(somename,empty),empty).
attacker(hash(hash(somename,empty),empty)).

11. By 10, the attacker may know hash(hash(somename,empty),empty).
By 6, the attacker may know validkey(dhexp_real(key_e(alice,bob,sid_5),g)).
Using the function hash the attacker may obtain hash(hash(hash(somename,empty),empty),validkey(dhexp_real(key_e(alice,bob,sid_5),g))).
attacker(hash(hash(hash(somename,empty),empty),validkey(dhexp_real(key_e(alice,bob,sid_5),g)))).

12. Using the function minnonce the attacker may obtain minnonce.
attacker(minnonce).

13. By 7, the attacker may know empty.
By 12, the attacker may know minnonce.
By 11, the attacker may know hash(hash(hash(somename,empty),empty),validkey(dhexp_real(key_e(alice,bob,sid_5),g))).
By 5, the attacker may know encrypt(empty,minnonce,hash(hash(hash(somename,empty),empty),validkey(dhexp_real(key_e(alice,bob,sid_5),g))),msg_a(alice,bob,sid_5)).
Using the function decrypt the attacker may obtain aeadpack(true,hash(hash(hash(somename,empty),empty),validkey(dhexp_real(key_e(alice,bob,sid_5),g))),msg_a(alice,bob,sid_5)).
attacker(aeadpack(true,hash(hash(hash(somename,empty),empty),validkey(dhexp_real(key_e(alice,bob,sid_5),g))),msg_a(alice,bob,sid_5))).

14. By 13, the attacker may know aeadpack(true,hash(hash(hash(somename,empty),empty),validkey(dhexp_real(key_e(alice,bob,sid_5),g))),msg_a(alice,bob,sid_5)).
Using the function 3-proj-aeadpack the attacker may obtain msg_a(alice,bob,sid_5).
attacker(msg_a(alice,bob,sid_5)).

15. By 14, the attacker may know msg_a(alice,bob,sid_5).
So the attacker may know msg_a(alice,bob,sid_5) in phase 1.
attacker_p1(msg_a(alice,bob,sid_5)).

16. By 15, attacker_p1(msg_a(alice,bob,sid_5)).
The goal is reached, represented in the following fact:
attacker_p1(msg_a(alice,bob,sid_5)).


RESULT attacker_p1(msg_a(alice,bob,sid_a)) ==> event(LeakS(px,bob)) && event(LeakM(px,bob)) cannot be proved.
Starting query attacker_p1(msg_a(alice,bob,sid_a)) ==> event(LeakS(phase0,bob)) || (event(LeakS(px,bob)) && event(LeakM(px,bob)) && event(LeakS(pz,alice)) && event(LeakM(pz,alice)))
goal reachable: begin(SendMsg(alice,bob,stagepack_a(sid_5),msg_a(alice,bob,sid_5))) -> attacker_p1(msg_a(alice,bob,sid_5))
Abbreviations:
sid_5 = sid[!1 = @sid]

Derivation:
Abbreviations:
sid_5 = sid[!1 = @sid]

1. Using the function pub the attacker may obtain pub.
attacker(pub).

2. The entry statestore(alice,bob,sid_5,statepack_a(handshakestatepack(symmetricstatepack(cipherstatepack(empty,minnonce),hash(somename,empty),hash(hash(somename,empty),empty)),keypairpack(empty,empty),keypairpack(empty,empty),keypairpack(empty,empty),empty,empty,empty,empty,true))) may be inserted in a table at insert {30}.
table(statestore(alice,bob,sid_5,statepack_a(handshakestatepack(symmetricstatepack(cipherstatepack(empty,minnonce),hash(somename,empty),hash(hash(somename,empty),empty)),keypairpack(empty,empty),keypairpack(empty,empty),keypairpack(empty,empty),empty,empty,empty,empty,true)))).

3. The entry statestore(alice,bob,sid_5,statepack_a(handshakestatepack(symmetricstatepack(cipherstatepack(empty,minnonce),hash(somename,empty),hash(hash(somename,empty),empty)),keypairpack(empty,empty),keypairpack(empty,empty),keypairpack(empty,empty),empty,empty,empty,empty,true))) that may be in a table by 2 may be read at get {101}.
The event SendMsg(alice,bob,stagepack_a(sid_5),msg_a(alice,bob,sid_5)) may be executed at {98}.
So the message concat3(validkey(dhexp_real(key_e(alice,bob,sid_5),g)),empty,encrypt(empty,minnonce,hash(hash(hash(somename,empty),empty),validkey(dhexp_real(key_e(alice,bob,sid_5),g))),msg_a(alice,bob,sid_5))) may be sent on channel pub at output {100}.
mess(pub,concat3(validkey(dhexp_real(key_e(alice,bob,sid_5),g)),empty,encrypt(empty,minnonce,hash(hash(hash(somename,empty),empty),validkey(dhexp_real(key_e(alice,bob,sid_5),g))),msg_a(alice,bob,sid_5)))).

4. By 1, the attacker may have the channel pub.
By 3, the message concat3(validkey(dhexp_real(key_e(alice,bob,sid_5),g)),empty,encrypt(empty,minnonce,hash(hash(hash(somename,empty),empty),validkey(dhexp_real(key_e(alice,bob,sid_5),g))),msg_a(alice,bob,sid_5))) may be sent on this channel.
So the attacker may obtain the message concat3(validkey(dhexp_real(key_e(alice,bob,sid_5),g)),empty,encrypt(empty,minnonce,hash(hash(hash(somename,empty),empty),validkey(dhexp_real(key_e(alice,bob,sid_5),g))),msg_a(alice,bob,sid_5))) by listening on this channel.
attacker(concat3(validkey(dhexp_real(key_e(alice,bob,sid_5),g)),empty,encrypt(empty,minnonce,hash(hash(hash(somename,empty),empty),validkey(dhexp_real(key_e(alice,bob,sid_5),g))),msg_a(alice,bob,sid_5)))).

5. By 4, the attacker may know concat3(validkey(dhexp_real(key_e(alice,bob,sid_5),g)),empty,encrypt(empty,minnonce,hash(hash(hash(somename,empty),empty),validkey(dhexp_real(key_e(alice,bob,sid_5),g))),msg_a(alice,bob,sid_5))).
Using the function 3-proj-concat3 the attacker may obtain encrypt(empty,minnonce,hash(hash(hash(somename,empty),empty),validkey(dhexp_real(key_e(alice,bob,sid_5),g))),msg_a(alice,bob,sid_5)).
attacker(encrypt(empty,minnonce,hash(hash(hash(somename,empty),empty),validkey(dhexp_real(key_e(alice,bob,sid_5),g))),msg_a(alice,bob,sid_5))).

6. By 4, the attacker may know concat3(validkey(dhexp_real(key_e(alice,bob,sid_5),g)),empty,encrypt(empty,minnonce,hash(hash(hash(somename,empty),empty),validkey(dhexp_real(key_e(alice,bob,sid_5),g))),msg_a(alice,bob,sid_5))).
Using the function 1-proj-concat3 the attacker may obtain validkey(dhexp_real(key_e(alice,bob,sid_5),g)).
attacker(validkey(dhexp_real(key_e(alice,bob,sid_5),g))).

7. Using the function empty the attacker may obtain empty.
attacker(empty).

8. Using the function somename the attacker may obtain somename.
attacker(somename).

9. By 8, the attacker may know somename.
By 7, the attacker may know empty.
Using the function hash the attacker may obtain hash(somename,empty).
attacker(hash(somename,empty)).

10. By 9, the attacker may know hash(somename,empty).
By 7, the attacker may know empty.
Using the function hash the attacker may obtain hash(hash(somename,empty),empty).
attacker(hash(hash(somename,empty),empty)).

11. By 10, the attacker may know hash(hash(somename,empty),empty).
By 6, the attacker may know validkey(dhexp_real(key_e(alice,bob,sid_5),g)).
Using the function hash the attacker may obtain hash(hash(hash(somename,empty),empty),validkey(dhexp_real(key_e(alice,bob,sid_5),g))).
attacker(hash(hash(hash(somename,empty),empty),validkey(dhexp_real(key_e(alice,bob,sid_5),g)))).

12. Using the function minnonce the attacker may obtain minnonce.
attacker(minnonce).

13. By 7, the attacker may know empty.
By 12, the attacker may know minnonce.
By 11, the attacker may know hash(hash(hash(somename,empty),empty),validkey(dhexp_real(key_e(alice,bob,sid_5),g))).
By 5, the attacker may know encrypt(empty,minnonce,hash(hash(hash(somename,empty),empty),validkey(dhexp_real(key_e(alice,bob,sid_5),g))),msg_a(alice,bob,sid_5)).
Using the function decrypt the attacker may obtain aeadpack(true,hash(hash(hash(somename,empty),empty),validkey(dhexp_real(key_e(alice,bob,sid_5),g))),msg_a(alice,bob,sid_5)).
attacker(aeadpack(true,hash(hash(hash(somename,empty),empty),validkey(dhexp_real(key_e(alice,bob,sid_5),g))),msg_a(alice,bob,sid_5))).

14. By 13, the attacker may know aeadpack(true,hash(hash(hash(somename,empty),empty),validkey(dhexp_real(key_e(alice,bob,sid_5),g))),msg_a(alice,bob,sid_5)).
Using the function 3-proj-aeadpack the attacker may obtain msg_a(alice,bob,sid_5).
attacker(msg_a(alice,bob,sid_5)).

15. By 14, the attacker may know msg_a(alice,bob,sid_5).
So the attacker may know msg_a(alice,bob,sid_5) in phase 1.
attacker_p1(msg_a(alice,bob,sid_5)).

16. By 15, attacker_p1(msg_a(alice,bob,sid_5)).
The goal is reached, represented in the following fact:
attacker_p1(msg_a(alice,bob,sid_5)).


RESULT attacker_p1(msg_a(alice,bob,sid_a)) ==> event(LeakS(phase0,bob)) || (event(LeakS(px,bob)) && event(LeakM(px,bob)) && event(LeakS(pz,alice)) && event(LeakM(pz,alice))) cannot be proved.
Starting query attacker_p1(msg_a(alice,bob,sid_a)) ==> event(LeakS(phase0,bob)) && event(LeakM(phase0,bob))
goal reachable: begin(SendMsg(alice,bob,stagepack_a(sid_5),msg_a(alice,bob,sid_5))) -> attacker_p1(msg_a(alice,bob,sid_5))
Abbreviations:
sid_5 = sid[!1 = @sid]

Derivation:
Abbreviations:
sid_5 = sid[!1 = @sid]

1. Using the function pub the attacker may obtain pub.
attacker(pub).

2. The entry statestore(alice,bob,sid_5,statepack_a(handshakestatepack(symmetricstatepack(cipherstatepack(empty,minnonce),hash(somename,empty),hash(hash(somename,empty),empty)),keypairpack(empty,empty),keypairpack(empty,empty),keypairpack(empty,empty),empty,empty,empty,empty,true))) may be inserted in a table at insert {30}.
table(statestore(alice,bob,sid_5,statepack_a(handshakestatepack(symmetricstatepack(cipherstatepack(empty,minnonce),hash(somename,empty),hash(hash(somename,empty),empty)),keypairpack(empty,empty),keypairpack(empty,empty),keypairpack(empty,empty),empty,empty,empty,empty,true)))).

3. The entry statestore(alice,bob,sid_5,statepack_a(handshakestatepack(symmetricstatepack(cipherstatepack(empty,minnonce),hash(somename,empty),hash(hash(somename,empty),empty)),keypairpack(empty,empty),keypairpack(empty,empty),keypairpack(empty,empty),empty,empty,empty,empty,true))) that may be in a table by 2 may be read at get {101}.
The event SendMsg(alice,bob,stagepack_a(sid_5),msg_a(alice,bob,sid_5)) may be executed at {98}.
So the message concat3(validkey(dhexp_real(key_e(alice,bob,sid_5),g)),empty,encrypt(empty,minnonce,hash(hash(hash(somename,empty),empty),validkey(dhexp_real(key_e(alice,bob,sid_5),g))),msg_a(alice,bob,sid_5))) may be sent on channel pub at output {100}.
mess(pub,concat3(validkey(dhexp_real(key_e(alice,bob,sid_5),g)),empty,encrypt(empty,minnonce,hash(hash(hash(somename,empty),empty),validkey(dhexp_real(key_e(alice,bob,sid_5),g))),msg_a(alice,bob,sid_5)))).

4. By 1, the attacker may have the channel pub.
By 3, the message concat3(validkey(dhexp_real(key_e(alice,bob,sid_5),g)),empty,encrypt(empty,minnonce,hash(hash(hash(somename,empty),empty),validkey(dhexp_real(key_e(alice,bob,sid_5),g))),msg_a(alice,bob,sid_5))) may be sent on this channel.
So the attacker may obtain the message concat3(validkey(dhexp_real(key_e(alice,bob,sid_5),g)),empty,encrypt(empty,minnonce,hash(hash(hash(somename,empty),empty),validkey(dhexp_real(key_e(alice,bob,sid_5),g))),msg_a(alice,bob,sid_5))) by listening on this channel.
attacker(concat3(validkey(dhexp_real(key_e(alice,bob,sid_5),g)),empty,encrypt(empty,minnonce,hash(hash(hash(somename,empty),empty),validkey(dhexp_real(key_e(alice,bob,sid_5),g))),msg_a(alice,bob,sid_5)))).

5. By 4, the attacker may know concat3(validkey(dhexp_real(key_e(alice,bob,sid_5),g)),empty,encrypt(empty,minnonce,hash(hash(hash(somename,empty),empty),validkey(dhexp_real(key_e(alice,bob,sid_5),g))),msg_a(alice,bob,sid_5))).
Using the function 3-proj-concat3 the attacker may obtain encrypt(empty,minnonce,hash(hash(hash(somename,empty),empty),validkey(dhexp_real(key_e(alice,bob,sid_5),g))),msg_a(alice,bob,sid_5)).
attacker(encrypt(empty,minnonce,hash(hash(hash(somename,empty),empty),validkey(dhexp_real(key_e(alice,bob,sid_5),g))),msg_a(alice,bob,sid_5))).

6. By 4, the attacker may know concat3(validkey(dhexp_real(key_e(alice,bob,sid_5),g)),empty,encrypt(empty,minnonce,hash(hash(hash(somename,empty),empty),validkey(dhexp_real(key_e(alice,bob,sid_5),g))),msg_a(alice,bob,sid_5))).
Using the function 1-proj-concat3 the attacker may obtain validkey(dhexp_real(key_e(alice,bob,sid_5),g)).
attacker(validkey(dhexp_real(key_e(alice,bob,sid_5),g))).

7. Using the function empty the attacker may obtain empty.
attacker(empty).

8. Using the function somename the attacker may obtain somename.
attacker(somename).

9. By 8, the attacker may know somename.
By 7, the attacker may know empty.
Using the function hash the attacker may obtain hash(somename,empty).
attacker(hash(somename,empty)).

10. By 9, the attacker may know hash(somename,empty).
By 7, the attacker may know empty.
Using the function hash the attacker may obtain hash(hash(somename,empty),empty).
attacker(hash(hash(somename,empty),empty)).

11. By 10, the attacker may know hash(hash(somename,empty),empty).
By 6, the attacker may know validkey(dhexp_real(key_e(alice,bob,sid_5),g)).
Using the function hash the attacker may obtain hash(hash(hash(somename,empty),empty),validkey(dhexp_real(key_e(alice,bob,sid_5),g))).
attacker(hash(hash(hash(somename,empty),empty),validkey(dhexp_real(key_e(alice,bob,sid_5),g)))).

12. Using the function minnonce the attacker may obtain minnonce.
attacker(minnonce).

13. By 7, the attacker may know empty.
By 12, the attacker may know minnonce.
By 11, the attacker may know hash(hash(hash(somename,empty),empty),validkey(dhexp_real(key_e(alice,bob,sid_5),g))).
By 5, the attacker may know encrypt(empty,minnonce,hash(hash(hash(somename,empty),empty),validkey(dhexp_real(key_e(alice,bob,sid_5),g))),msg_a(alice,bob,sid_5)).
Using the function decrypt the attacker may obtain aeadpack(true,hash(hash(hash(somename,empty),empty),validkey(dhexp_real(key_e(alice,bob,sid_5),g))),msg_a(alice,bob,sid_5)).
attacker(aeadpack(true,hash(hash(hash(somename,empty),empty),validkey(dhexp_real(key_e(alice,bob,sid_5),g))),msg_a(alice,bob,sid_5))).

14. By 13, the attacker may know aeadpack(true,hash(hash(hash(somename,empty),empty),validkey(dhexp_real(key_e(alice,bob,sid_5),g))),msg_a(alice,bob,sid_5)).
Using the function 3-proj-aeadpack the attacker may obtain msg_a(alice,bob,sid_5).
attacker(msg_a(alice,bob,sid_5)).

15. By 14, the attacker may know msg_a(alice,bob,sid_5).
So the attacker may know msg_a(alice,bob,sid_5) in phase 1.
attacker_p1(msg_a(alice,bob,sid_5)).

16. By 15, attacker_p1(msg_a(alice,bob,sid_5)).
The goal is reached, represented in the following fact:
attacker_p1(msg_a(alice,bob,sid_5)).


RESULT attacker_p1(msg_a(alice,bob,sid_a)) ==> event(LeakS(phase0,bob)) && event(LeakM(phase0,bob)) cannot be proved.
Starting query event(RecvMsg(alice,bob,stagepack_b(sid_a),m_28)) ==> event(SendMsg(bob,alice,stagepack_b(sid_b),m_28))
goal reachable: begin(SendMsg(bob,charlie,stagepack_b(sid_5),msg_b(bob,charlie,sid_5))) && begin(SendMsg(alice,bob,stagepack_a(sid_6),msg_a(alice,bob,sid_6))) -> end(RecvMsg(alice,bob,stagepack_b(sid_6),msg_b(bob,charlie,sid_5)))
Abbreviations:
sid_6 = sid[!1 = @sid]
sid_5 = sid[!1 = @sid_1]

Derivation:
Abbreviations:
sid_5 = sid[!1 = @sid]
sid_6 = sid[!1 = @sid_1]

1. The entry statestore(alice,bob,sid_5,statepack_a(handshakestatepack(symmetricstatepack(cipherstatepack(empty,minnonce),hash(somename,empty),hash(hash(somename,empty),empty)),keypairpack(empty,empty),keypairpack(empty,empty),keypairpack(empty,empty),empty,empty,empty,empty,true))) may be inserted in a table at insert {30}.
table(statestore(alice,bob,sid_5,statepack_a(handshakestatepack(symmetricstatepack(cipherstatepack(empty,minnonce),hash(somename,empty),hash(hash(somename,empty),empty)),keypairpack(empty,empty),keypairpack(empty,empty),keypairpack(empty,empty),empty,empty,empty,empty,true)))).

2. The entry statestore(alice,bob,sid_5,statepack_a(handshakestatepack(symmetricstatepack(cipherstatepack(empty,minnonce),hash(somename,empty),hash(hash(somename,empty),empty)),keypairpack(empty,empty),keypairpack(empty,empty),keypairpack(empty,empty),empty,empty,empty,empty,true))) that may be in a table by 1 may be read at get {101}.
The event SendMsg(alice,bob,stagepack_a(sid_5),msg_a(alice,bob,sid_5)) may be executed at {98}.
So the entry statestore(alice,bob,sid_5,statepack_b(handshakestatepack(symmetricstatepack(cipherstatepack(empty,increment_nonce(minnonce)),hash(somename,empty),hash(hash(hash(hash(somename,empty),empty),validkey(dhexp_real(key_e(alice,bob,sid_5),g))),encrypt(empty,minnonce,hash(hash(hash(somename,empty),empty),validkey(dhexp_real(key_e(alice,bob,sid_5),g))),msg_a(alice,bob,sid_5)))),keypairpack(empty,empty),keypairpack(empty,empty),keypairpack(validkey(dhexp_real(key_e(alice,bob,sid_5),g)),key_e(alice,bob,sid_5)),empty,empty,empty,empty,true))) may be inserted in a table at insert {99}.
table(statestore(alice,bob,sid_5,statepack_b(handshakestatepack(symmetricstatepack(cipherstatepack(empty,increment_nonce(minnonce)),hash(somename,empty),hash(hash(hash(hash(somename,empty),empty),validkey(dhexp_real(key_e(alice,bob,sid_5),g))),encrypt(empty,minnonce,hash(hash(hash(somename,empty),empty),validkey(dhexp_real(key_e(alice,bob,sid_5),g))),msg_a(alice,bob,sid_5)))),keypairpack(empty,empty),keypairpack(empty,empty),keypairpack(validkey(dhexp_real(key_e(alice,bob,sid_5),g)),key_e(alice,bob,sid_5)),empty,empty,empty,empty,true)))).

3. The entry statestore(bob,charlie,sid_6,statepack_a(handshakestatepack(symmetricstatepack(cipherstatepack(empty,minnonce),hash(somename,empty),hash(hash(somename,empty),empty)),keypairpack(empty,empty),keypairpack(empty,empty),keypairpack(empty,empty),empty,empty,empty,empty,false))) may be inserted in a table at insert {1827}.
table(statestore(bob,charlie,sid_6,statepack_a(handshakestatepack(symmetricstatepack(cipherstatepack(empty,minnonce),hash(somename,empty),hash(hash(somename,empty),empty)),keypairpack(empty,empty),keypairpack(empty,empty),keypairpack(empty,empty),empty,empty,empty,empty,false)))).

4. The entry statestore(alice,bob,sid_5,statepack_a(handshakestatepack(symmetricstatepack(cipherstatepack(empty,minnonce),hash(somename,empty),hash(hash(somename,empty),empty)),keypairpack(empty,empty),keypairpack(empty,empty),keypairpack(empty,empty),empty,empty,empty,empty,true))) that may be in a table by 1 may be read at get {101}.
The event SendMsg(alice,bob,stagepack_a(sid_5),msg_a(alice,bob,sid_5)) may be executed at {98}.
So the message concat3(validkey(dhexp_real(key_e(alice,bob,sid_5),g)),empty,encrypt(empty,minnonce,hash(hash(hash(somename,empty),empty),validkey(dhexp_real(key_e(alice,bob,sid_5),g))),msg_a(alice,bob,sid_5))) may be sent on channel pub at output {100}.
mess(pub,concat3(validkey(dhexp_real(key_e(alice,bob,sid_5),g)),empty,encrypt(empty,minnonce,hash(hash(hash(somename,empty),empty),validkey(dhexp_real(key_e(alice,bob,sid_5),g))),msg_a(alice,bob,sid_5)))).

5. The entry statestore(bob,charlie,sid_6,statepack_a(handshakestatepack(symmetricstatepack(cipherstatepack(empty,minnonce),hash(somename,empty),hash(hash(somename,empty),empty)),keypairpack(empty,empty),keypairpack(empty,empty),keypairpack(empty,empty),empty,empty,empty,empty,false))) that may be in a table by 3 may be read at get {1900}.
The message concat3(validkey(dhexp_real(key_e(alice,bob,sid_5),g)),empty,encrypt(empty,minnonce,hash(hash(hash(somename,empty),empty),validkey(dhexp_real(key_e(alice,bob,sid_5),g))),msg_a(alice,bob,sid_5))) that may be sent on channel pub by 4 may be received at input {1828}.
So the entry statestore(bob,charlie,sid_6,statepack_b(handshakestatepack(symmetricstatepack(cipherstatepack(empty,increment_nonce(minnonce)),hash(somename,empty),hash(hash(hash(hash(somename,empty),empty),validkey(dhexp_real(key_e(alice,bob,sid_5),g))),encrypt(empty,minnonce,hash(hash(hash(somename,empty),empty),validkey(dhexp_real(key_e(alice,bob,sid_5),g))),msg_a(alice,bob,sid_5)))),keypairpack(empty,empty),keypairpack(empty,empty),keypairpack(empty,empty),empty,empty,validkey(dhexp_real(key_e(alice,bob,sid_5),g)),empty,false))) may be inserted in a table at insert {1899}.
table(statestore(bob,charlie,sid_6,statepack_b(handshakestatepack(symmetricstatepack(cipherstatepack(empty,increment_nonce(minnonce)),hash(somename,empty),hash(hash(hash(hash(somename,empty),empty),validkey(dhexp_real(key_e(alice,bob,sid_5),g))),encrypt(empty,minnonce,hash(hash(hash(somename,empty),empty),validkey(dhexp_real(key_e(alice,bob,sid_5),g))),msg_a(alice,bob,sid_5)))),keypairpack(empty,empty),keypairpack(empty,empty),keypairpack(empty,empty),empty,empty,validkey(dhexp_real(key_e(alice,bob,sid_5),g)),empty,false)))).

6. The entry statestore(bob,charlie,sid_6,statepack_b(handshakestatepack(symmetricstatepack(cipherstatepack(empty,increment_nonce(minnonce)),hash(somename,empty),hash(hash(hash(hash(somename,empty),empty),validkey(dhexp_real(key_e(alice,bob,sid_5),g))),encrypt(empty,minnonce,hash(hash(hash(somename,empty),empty),validkey(dhexp_real(key_e(alice,bob,sid_5),g))),msg_a(alice,bob,sid_5)))),keypairpack(empty,empty),keypairpack(empty,empty),keypairpack(empty,empty),empty,empty,validkey(dhexp_real(key_e(alice,bob,sid_5),g)),empty,false))) that may be in a table by 5 may be read at get {2115}.
The event SendMsg(bob,charlie,stagepack_b(sid_6),msg_b(bob,charlie,sid_6)) may be executed at {2112}.
So the message concat4(validkey(dhexp_real(key_e(bob,charlie,sid_6),g)),encrypt(hmac_hash2(hash(somename,empty),dhexp_real(key_e(alice,bob,sid_5),dhexp_real(key_e(bob,charlie,sid_6),g))),minnonce,hash(hash(hash(hash(hash(somename,empty),empty),validkey(dhexp_real(key_e(alice,bob,sid_5),g))),encrypt(empty,minnonce,hash(hash(hash(somename,empty),empty),validkey(dhexp_real(key_e(alice,bob,sid_5),g))),msg_a(alice,bob,sid_5))),validkey(dhexp_real(key_e(bob,charlie,sid_6),g))),validkey(dhexp_real(key_s(bob),g))),encrypt(hmac_hash2(hash(somename,empty),dhexp_real(key_e(alice,bob,sid_5),dhexp_real(key_e(bob,charlie,sid_6),g))),increment_nonce(minnonce),hash(hash(hash(hash(hash(hash(somename,empty),empty),validkey(dhexp_real(key_e(alice,bob,sid_5),g))),encrypt(empty,minnonce,hash(hash(hash(somename,empty),empty),validkey(dhexp_real(key_e(alice,bob,sid_5),g))),msg_a(alice,bob,sid_5))),validkey(dhexp_real(key_e(bob,charlie,sid_6),g))),encrypt(hmac_hash2(hash(somename,empty),dhexp_real(key_e(alice,bob,sid_5),dhexp_real(key_e(bob,charlie,sid_6),g))),minnonce,hash(hash(hash(hash(hash(somename,empty),empty),validkey(dhexp_real(key_e(alice,bob,sid_5),g))),encrypt(empty,minnonce,hash(hash(hash(somename,empty),empty),validkey(dhexp_real(key_e(alice,bob,sid_5),g))),msg_a(alice,bob,sid_5))),validkey(dhexp_real(key_e(bob,charlie,sid_6),g))),validkey(dhexp_real(key_s(bob),g)))),validkey(dhexp_real(key_m(bob),g))),encrypt(hmac_hash2(hmac_hash1(hmac_hash1(hash(somename,empty),dhexp_real(key_e(alice,bob,sid_5),dhexp_real(key_e(bob,charlie,sid_6),g))),dhexp_real(key_e(alice,bob,sid_5),dhexp_real(key_s(bob),g))),dhexp_real(key_e(alice,bob,sid_5),dhexp_real(key_m(bob),g))),minnonce,hash(hash(hash(hash(hash(hash(hash(somename,empty),empty),validkey(dhexp_real(key_e(alice,bob,sid_5),g))),encrypt(empty,minnonce,hash(hash(hash(somename,empty),empty),validkey(dhexp_real(key_e(alice,bob,sid_5),g))),msg_a(alice,bob,sid_5))),validkey(dhexp_real(key_e(bob,charlie,sid_6),g))),encrypt(hmac_hash2(hash(somename,empty),dhexp_real(key_e(alice,bob,sid_5),dhexp_real(key_e(bob,charlie,sid_6),g))),minnonce,hash(hash(hash(hash(hash(somename,empty),empty),validkey(dhexp_real(key_e(alice,bob,sid_5),g))),encrypt(empty,minnonce,hash(hash(hash(somename,empty),empty),validkey(dhexp_real(key_e(alice,bob,sid_5),g))),msg_a(alice,bob,sid_5))),validkey(dhexp_real(key_e(bob,charlie,sid_6),g))),validkey(dhexp_real(key_s(bob),g)))),encrypt(hmac_hash2(hash(somename,empty),dhexp_real(key_e(alice,bob,sid_5),dhexp_real(key_e(bob,charlie,sid_6),g))),increment_nonce(minnonce),hash(hash(hash(hash(hash(hash(somename,empty),empty),validkey(dhexp_real(key_e(alice,bob,sid_5),g))),encrypt(empty,minnonce,hash(hash(hash(somename,empty),empty),validkey(dhexp_real(key_e(alice,bob,sid_5),g))),msg_a(alice,bob,sid_5))),validkey(dhexp_real(key_e(bob,charlie,sid_6),g))),encrypt(hmac_hash2(hash(somename,empty),dhexp_real(key_e(alice,bob,sid_5),dhexp_real(key_e(bob,charlie,sid_6),g))),minnonce,hash(hash(hash(hash(hash(somename,empty),empty),validkey(dhexp_real(key_e(alice,bob,sid_5),g))),encrypt(empty,minnonce,hash(hash(hash(somename,empty),empty),validkey(dhexp_real(key_e(alice,bob,sid_5),g))),msg_a(alice,bob,sid_5))),validkey(dhexp_real(key_e(bob,charlie,sid_6),g))),validkey(dhexp_real(key_s(bob),g)))),validkey(dhexp_real(key_m(bob),g)))),msg_b(bob,charlie,sid_6))) may be sent on channel pub at output {2114}.
mess(pub,concat4(validkey(dhexp_real(key_e(bob,charlie,sid_6),g)),encrypt(hmac_hash2(hash(somename,empty),dhexp_real(key_e(alice,bob,sid_5),dhexp_real(key_e(bob,charlie,sid_6),g))),minnonce,hash(hash(hash(hash(hash(somename,empty),empty),validkey(dhexp_real(key_e(alice,bob,sid_5),g))),encrypt(empty,minnonce,hash(hash(hash(somename,empty),empty),validkey(dhexp_real(key_e(alice,bob,sid_5),g))),msg_a(alice,bob,sid_5))),validkey(dhexp_real(key_e(bob,charlie,sid_6),g))),validkey(dhexp_real(key_s(bob),g))),encrypt(hmac_hash2(hash(somename,empty),dhexp_real(key_e(alice,bob,sid_5),dhexp_real(key_e(bob,charlie,sid_6),g))),increment_nonce(minnonce),hash(hash(hash(hash(hash(hash(somename,empty),empty),validkey(dhexp_real(key_e(alice,bob,sid_5),g))),encrypt(empty,minnonce,hash(hash(hash(somename,empty),empty),validkey(dhexp_real(key_e(alice,bob,sid_5),g))),msg_a(alice,bob,sid_5))),validkey(dhexp_real(key_e(bob,charlie,sid_6),g))),encrypt(hmac_hash2(hash(somename,empty),dhexp_real(key_e(alice,bob,sid_5),dhexp_real(key_e(bob,charlie,sid_6),g))),minnonce,hash(hash(hash(hash(hash(somename,empty),empty),validkey(dhexp_real(key_e(alice,bob,sid_5),g))),encrypt(empty,minnonce,hash(hash(hash(somename,empty),empty),validkey(dhexp_real(key_e(alice,bob,sid_5),g))),msg_a(alice,bob,sid_5))),validkey(dhexp_real(key_e(bob,charlie,sid_6),g))),validkey(dhexp_real(key_s(bob),g)))),validkey(dhexp_real(key_m(bob),g))),encrypt(hmac_hash2(hmac_hash1(hmac_hash1(hash(somename,empty),dhexp_real(key_e(alice,bob,sid_5),dhexp_real(key_e(bob,charlie,sid_6),g))),dhexp_real(key_e(alice,bob,sid_5),dhexp_real(key_s(bob),g))),dhexp_real(key_e(alice,bob,sid_5),dhexp_real(key_m(bob),g))),minnonce,hash(hash(hash(hash(hash(hash(hash(somename,empty),empty),validkey(dhexp_real(key_e(alice,bob,sid_5),g))),encrypt(empty,minnonce,hash(hash(hash(somename,empty),empty),validkey(dhexp_real(key_e(alice,bob,sid_5),g))),msg_a(alice,bob,sid_5))),validkey(dhexp_real(key_e(bob,charlie,sid_6),g))),encrypt(hmac_hash2(hash(somename,empty),dhexp_real(key_e(alice,bob,sid_5),dhexp_real(key_e(bob,charlie,sid_6),g))),minnonce,hash(hash(hash(hash(hash(somename,empty),empty),validkey(dhexp_real(key_e(alice,bob,sid_5),g))),encrypt(empty,minnonce,hash(hash(hash(somename,empty),empty),validkey(dhexp_real(key_e(alice,bob,sid_5),g))),msg_a(alice,bob,sid_5))),validkey(dhexp_real(key_e(bob,charlie,sid_6),g))),validkey(dhexp_real(key_s(bob),g)))),encrypt(hmac_hash2(hash(somename,empty),dhexp_real(key_e(alice,bob,sid_5),dhexp_real(key_e(bob,charlie,sid_6),g))),increment_nonce(minnonce),hash(hash(hash(hash(hash(hash(somename,empty),empty),validkey(dhexp_real(key_e(alice,bob,sid_5),g))),encrypt(empty,minnonce,hash(hash(hash(somename,empty),empty),validkey(dhexp_real(key_e(alice,bob,sid_5),g))),msg_a(alice,bob,sid_5))),validkey(dhexp_real(key_e(bob,charlie,sid_6),g))),encrypt(hmac_hash2(hash(somename,empty),dhexp_real(key_e(alice,bob,sid_5),dhexp_real(key_e(bob,charlie,sid_6),g))),minnonce,hash(hash(hash(hash(hash(somename,empty),empty),validkey(dhexp_real(key_e(alice,bob,sid_5),g))),encrypt(empty,minnonce,hash(hash(hash(somename,empty),empty),validkey(dhexp_real(key_e(alice,bob,sid_5),g))),msg_a(alice,bob,sid_5))),validkey(dhexp_real(key_e(bob,charlie,sid_6),g))),validkey(dhexp_real(key_s(bob),g)))),validkey(dhexp_real(key_m(bob),g)))),msg_b(bob,charlie,sid_6)))).

7. The entry statestore(alice,bob,sid_5,statepack_b(handshakestatepack(symmetricstatepack(cipherstatepack(empty,increment_nonce(minnonce)),hash(somename,empty),hash(hash(hash(hash(somename,empty),empty),validkey(dhexp_real(key_e(alice,bob,sid_5),g))),encrypt(empty,minnonce,hash(hash(hash(somename,empty),empty),validkey(dhexp_real(key_e(alice,bob,sid_5),g))),msg_a(alice,bob,sid_5)))),keypairpack(empty,empty),keypairpack(empty,empty),keypairpack(validkey(dhexp_real(key_e(alice,bob,sid_5),g)),key_e(alice,bob,sid_5)),empty,empty,empty,empty,true))) that may be in a table by 2 may be read at get {328}.
The message concat4(validkey(dhexp_real(key_e(bob,charlie,sid_6),g)),encrypt(hmac_hash2(hash(somename,empty),dhexp_real(key_e(alice,bob,sid_5),dhexp_real(key_e(bob,charlie,sid_6),g))),minnonce,hash(hash(hash(hash(hash(somename,empty),empty),validkey(dhexp_real(key_e(alice,bob,sid_5),g))),encrypt(empty,minnonce,hash(hash(hash(somename,empty),empty),validkey(dhexp_real(key_e(alice,bob,sid_5),g))),msg_a(alice,bob,sid_5))),validkey(dhexp_real(key_e(bob,charlie,sid_6),g))),validkey(dhexp_real(key_s(bob),g))),encrypt(hmac_hash2(hash(somename,empty),dhexp_real(key_e(alice,bob,sid_5),dhexp_real(key_e(bob,charlie,sid_6),g))),increment_nonce(minnonce),hash(hash(hash(hash(hash(hash(somename,empty),empty),validkey(dhexp_real(key_e(alice,bob,sid_5),g))),encrypt(empty,minnonce,hash(hash(hash(somename,empty),empty),validkey(dhexp_real(key_e(alice,bob,sid_5),g))),msg_a(alice,bob,sid_5))),validkey(dhexp_real(key_e(bob,charlie,sid_6),g))),encrypt(hmac_hash2(hash(somename,empty),dhexp_real(key_e(alice,bob,sid_5),dhexp_real(key_e(bob,charlie,sid_6),g))),minnonce,hash(hash(hash(hash(hash(somename,empty),empty),validkey(dhexp_real(key_e(alice,bob,sid_5),g))),encrypt(empty,minnonce,hash(hash(hash(somename,empty),empty),validkey(dhexp_real(key_e(alice,bob,sid_5),g))),msg_a(alice,bob,sid_5))),validkey(dhexp_real(key_e(bob,charlie,sid_6),g))),validkey(dhexp_real(key_s(bob),g)))),validkey(dhexp_real(key_m(bob),g))),encrypt(hmac_hash2(hmac_hash1(hmac_hash1(hash(somename,empty),dhexp_real(key_e(alice,bob,sid_5),dhexp_real(key_e(bob,charlie,sid_6),g))),dhexp_real(key_e(alice,bob,sid_5),dhexp_real(key_s(bob),g))),dhexp_real(key_e(alice,bob,sid_5),dhexp_real(key_m(bob),g))),minnonce,hash(hash(hash(hash(hash(hash(hash(somename,empty),empty),validkey(dhexp_real(key_e(alice,bob,sid_5),g))),encrypt(empty,minnonce,hash(hash(hash(somename,empty),empty),validkey(dhexp_real(key_e(alice,bob,sid_5),g))),msg_a(alice,bob,sid_5))),validkey(dhexp_real(key_e(bob,charlie,sid_6),g))),encrypt(hmac_hash2(hash(somename,empty),dhexp_real(key_e(alice,bob,sid_5),dhexp_real(key_e(bob,charlie,sid_6),g))),minnonce,hash(hash(hash(hash(hash(somename,empty),empty),validkey(dhexp_real(key_e(alice,bob,sid_5),g))),encrypt(empty,minnonce,hash(hash(hash(somename,empty),empty),validkey(dhexp_real(key_e(alice,bob,sid_5),g))),msg_a(alice,bob,sid_5))),validkey(dhexp_real(key_e(bob,charlie,sid_6),g))),validkey(dhexp_real(key_s(bob),g)))),encrypt(hmac_hash2(hash(somename,empty),dhexp_real(key_e(alice,bob,sid_5),dhexp_real(key_e(bob,charlie,sid_6),g))),increment_nonce(minnonce),hash(hash(hash(hash(hash(hash(somename,empty),empty),validkey(dhexp_real(key_e(alice,bob,sid_5),g))),encrypt(empty,minnonce,hash(hash(hash(somename,empty),empty),validkey(dhexp_real(key_e(alice,bob,sid_5),g))),msg_a(alice,bob,sid_5))),validkey(dhexp_real(key_e(bob,charlie,sid_6),g))),encrypt(hmac_hash2(hash(somename,empty),dhexp_real(key_e(alice,bob,sid_5),dhexp_real(key_e(bob,charlie,sid_6),g))),minnonce,hash(hash(hash(hash(hash(somename,empty),empty),validkey(dhexp_real(key_e(alice,bob,sid_5),g))),encrypt(empty,minnonce,hash(hash(hash(somename,empty),empty),validkey(dhexp_real(key_e(alice,bob,sid_5),g))),msg_a(alice,bob,sid_5))),validkey(dhexp_real(key_e(bob,charlie,sid_6),g))),validkey(dhexp_real(key_s(bob),g)))),validkey(dhexp_real(key_m(bob),g)))),msg_b(bob,charlie,sid_6))) that may be sent on channel pub by 6 may be received at input {102}.
So event RecvMsg(alice,bob,stagepack_b(sid_5),msg_b(bob,charlie,sid_6)) may be executed at {326}.
end(RecvMsg(alice,bob,stagepack_b(sid_5),msg_b(bob,charlie,sid_6))).

8. By 7, end(RecvMsg(alice,bob,stagepack_b(sid_5),msg_b(bob,charlie,sid_6))).
The goal is reached, represented in the following fact:
end(RecvMsg(alice,bob,stagepack_b(sid_5),msg_b(bob,charlie,sid_6))).


RESULT event(RecvMsg(alice,bob,stagepack_b(sid_a),m_28)) ==> event(SendMsg(bob,alice,stagepack_b(sid_b),m_28)) cannot be proved.
Starting query event(RecvMsg(alice,bob,stagepack_b(sid_a),m_28)) ==> event(SendMsg(bob,c,stagepack_b(sid_b),m_28)) || (event(LeakS(phase0,bob)) && event(LeakM(phase0,bob))) || (event(LeakS(phase0,alice)) && event(LeakM(phase0,alice)))
goal reachable: begin(SendMsg(bob,alice,stagepack_b(sid_5),msg_b(bob,alice,sid_5))) && begin(SendMsg(alice,bob,stagepack_a(sid_6),msg_a(alice,bob,sid_6))) -> end(RecvMsg(alice,bob,stagepack_b(sid_6),msg_b(bob,alice,sid_5)))
Abbreviations:
sid_6 = sid[!1 = @sid]
sid_5 = sid[!1 = @sid_1]
goal reachable: begin(SendMsg(bob,charlie,stagepack_b(sid_5),msg_b(bob,charlie,sid_5))) && begin(SendMsg(alice,bob,stagepack_a(sid_6),msg_a(alice,bob,sid_6))) -> end(RecvMsg(alice,bob,stagepack_b(sid_6),msg_b(bob,charlie,sid_5)))
Abbreviations:
sid_6 = sid[!1 = @sid]
sid_5 = sid[!1 = @sid_1]
RESULT event(RecvMsg(alice,bob,stagepack_b(sid_a),m_28)) ==> event(SendMsg(bob,c,stagepack_b(sid_b),m_28)) || (event(LeakS(phase0,bob)) && event(LeakM(phase0,bob))) || (event(LeakS(phase0,alice)) && event(LeakM(phase0,alice))) is true.
Starting query event(RecvMsg(alice,bob,stagepack_b(sid_a),m_28)) ==> event(SendMsg(bob,c,stagepack_b(sid_b),m_28)) || (event(LeakS(phase0,bob)) && event(LeakM(phase0,bob)))
goal reachable: begin(SendMsg(bob,alice,stagepack_b(sid_5),msg_b(bob,alice,sid_5))) && begin(SendMsg(alice,bob,stagepack_a(sid_6),msg_a(alice,bob,sid_6))) -> end(RecvMsg(alice,bob,stagepack_b(sid_6),msg_b(bob,alice,sid_5)))
Abbreviations:
sid_6 = sid[!1 = @sid]
sid_5 = sid[!1 = @sid_1]
goal reachable: begin(SendMsg(bob,charlie,stagepack_b(sid_5),msg_b(bob,charlie,sid_5))) && begin(SendMsg(alice,bob,stagepack_a(sid_6),msg_a(alice,bob,sid_6))) -> end(RecvMsg(alice,bob,stagepack_b(sid_6),msg_b(bob,charlie,sid_5)))
Abbreviations:
sid_6 = sid[!1 = @sid]
sid_5 = sid[!1 = @sid_1]
RESULT event(RecvMsg(alice,bob,stagepack_b(sid_a),m_28)) ==> event(SendMsg(bob,c,stagepack_b(sid_b),m_28)) || (event(LeakS(phase0,bob)) && event(LeakM(phase0,bob))) is true.
Starting query event(RecvMsg(alice,bob,stagepack_b(sid_a),m_28)) ==> event(SendMsg(bob,alice,stagepack_b(sid_b),m_28)) || (event(LeakS(phase0,bob)) && event(LeakM(phase0,bob))) || (event(LeakS(phase0,alice)) && event(LeakM(phase0,alice)))
goal reachable: begin(SendMsg(bob,charlie,stagepack_b(sid_5),msg_b(bob,charlie,sid_5))) && begin(SendMsg(alice,bob,stagepack_a(sid_6),msg_a(alice,bob,sid_6))) -> end(RecvMsg(alice,bob,stagepack_b(sid_6),msg_b(bob,charlie,sid_5)))
Abbreviations:
sid_6 = sid[!1 = @sid]
sid_5 = sid[!1 = @sid_1]

Derivation:
Abbreviations:
sid_5 = sid[!1 = @sid]
sid_6 = sid[!1 = @sid_1]

1. The entry statestore(alice,bob,sid_5,statepack_a(handshakestatepack(symmetricstatepack(cipherstatepack(empty,minnonce),hash(somename,empty),hash(hash(somename,empty),empty)),keypairpack(empty,empty),keypairpack(empty,empty),keypairpack(empty,empty),empty,empty,empty,empty,true))) may be inserted in a table at insert {30}.
table(statestore(alice,bob,sid_5,statepack_a(handshakestatepack(symmetricstatepack(cipherstatepack(empty,minnonce),hash(somename,empty),hash(hash(somename,empty),empty)),keypairpack(empty,empty),keypairpack(empty,empty),keypairpack(empty,empty),empty,empty,empty,empty,true)))).

2. The entry statestore(alice,bob,sid_5,statepack_a(handshakestatepack(symmetricstatepack(cipherstatepack(empty,minnonce),hash(somename,empty),hash(hash(somename,empty),empty)),keypairpack(empty,empty),keypairpack(empty,empty),keypairpack(empty,empty),empty,empty,empty,empty,true))) that may be in a table by 1 may be read at get {101}.
The event SendMsg(alice,bob,stagepack_a(sid_5),msg_a(alice,bob,sid_5)) may be executed at {98}.
So the entry statestore(alice,bob,sid_5,statepack_b(handshakestatepack(symmetricstatepack(cipherstatepack(empty,increment_nonce(minnonce)),hash(somename,empty),hash(hash(hash(hash(somename,empty),empty),validkey(dhexp_real(key_e(alice,bob,sid_5),g))),encrypt(empty,minnonce,hash(hash(hash(somename,empty),empty),validkey(dhexp_real(key_e(alice,bob,sid_5),g))),msg_a(alice,bob,sid_5)))),keypairpack(empty,empty),keypairpack(empty,empty),keypairpack(validkey(dhexp_real(key_e(alice,bob,sid_5),g)),key_e(alice,bob,sid_5)),empty,empty,empty,empty,true))) may be inserted in a table at insert {99}.
table(statestore(alice,bob,sid_5,statepack_b(handshakestatepack(symmetricstatepack(cipherstatepack(empty,increment_nonce(minnonce)),hash(somename,empty),hash(hash(hash(hash(somename,empty),empty),validkey(dhexp_real(key_e(alice,bob,sid_5),g))),encrypt(empty,minnonce,hash(hash(hash(somename,empty),empty),validkey(dhexp_real(key_e(alice,bob,sid_5),g))),msg_a(alice,bob,sid_5)))),keypairpack(empty,empty),keypairpack(empty,empty),keypairpack(validkey(dhexp_real(key_e(alice,bob,sid_5),g)),key_e(alice,bob,sid_5)),empty,empty,empty,empty,true)))).

3. The entry statestore(bob,charlie,sid_6,statepack_a(handshakestatepack(symmetricstatepack(cipherstatepack(empty,minnonce),hash(somename,empty),hash(hash(somename,empty),empty)),keypairpack(empty,empty),keypairpack(empty,empty),keypairpack(empty,empty),empty,empty,empty,empty,false))) may be inserted in a table at insert {1827}.
table(statestore(bob,charlie,sid_6,statepack_a(handshakestatepack(symmetricstatepack(cipherstatepack(empty,minnonce),hash(somename,empty),hash(hash(somename,empty),empty)),keypairpack(empty,empty),keypairpack(empty,empty),keypairpack(empty,empty),empty,empty,empty,empty,false)))).

4. The entry statestore(alice,bob,sid_5,statepack_a(handshakestatepack(symmetricstatepack(cipherstatepack(empty,minnonce),hash(somename,empty),hash(hash(somename,empty),empty)),keypairpack(empty,empty),keypairpack(empty,empty),keypairpack(empty,empty),empty,empty,empty,empty,true))) that may be in a table by 1 may be read at get {101}.
The event SendMsg(alice,bob,stagepack_a(sid_5),msg_a(alice,bob,sid_5)) may be executed at {98}.
So the message concat3(validkey(dhexp_real(key_e(alice,bob,sid_5),g)),empty,encrypt(empty,minnonce,hash(hash(hash(somename,empty),empty),validkey(dhexp_real(key_e(alice,bob,sid_5),g))),msg_a(alice,bob,sid_5))) may be sent on channel pub at output {100}.
mess(pub,concat3(validkey(dhexp_real(key_e(alice,bob,sid_5),g)),empty,encrypt(empty,minnonce,hash(hash(hash(somename,empty),empty),validkey(dhexp_real(key_e(alice,bob,sid_5),g))),msg_a(alice,bob,sid_5)))).

5. The entry statestore(bob,charlie,sid_6,statepack_a(handshakestatepack(symmetricstatepack(cipherstatepack(empty,minnonce),hash(somename,empty),hash(hash(somename,empty),empty)),keypairpack(empty,empty),keypairpack(empty,empty),keypairpack(empty,empty),empty,empty,empty,empty,false))) that may be in a table by 3 may be read at get {1900}.
The message concat3(validkey(dhexp_real(key_e(alice,bob,sid_5),g)),empty,encrypt(empty,minnonce,hash(hash(hash(somename,empty),empty),validkey(dhexp_real(key_e(alice,bob,sid_5),g))),msg_a(alice,bob,sid_5))) that may be sent on channel pub by 4 may be received at input {1828}.
So the entry statestore(bob,charlie,sid_6,statepack_b(handshakestatepack(symmetricstatepack(cipherstatepack(empty,increment_nonce(minnonce)),hash(somename,empty),hash(hash(hash(hash(somename,empty),empty),validkey(dhexp_real(key_e(alice,bob,sid_5),g))),encrypt(empty,minnonce,hash(hash(hash(somename,empty),empty),validkey(dhexp_real(key_e(alice,bob,sid_5),g))),msg_a(alice,bob,sid_5)))),keypairpack(empty,empty),keypairpack(empty,empty),keypairpack(empty,empty),empty,empty,validkey(dhexp_real(key_e(alice,bob,sid_5),g)),empty,false))) may be inserted in a table at insert {1899}.
table(statestore(bob,charlie,sid_6,statepack_b(handshakestatepack(symmetricstatepack(cipherstatepack(empty,increment_nonce(minnonce)),hash(somename,empty),hash(hash(hash(hash(somename,empty),empty),validkey(dhexp_real(key_e(alice,bob,sid_5),g))),encrypt(empty,minnonce,hash(hash(hash(somename,empty),empty),validkey(dhexp_real(key_e(alice,bob,sid_5),g))),msg_a(alice,bob,sid_5)))),keypairpack(empty,empty),keypairpack(empty,empty),keypairpack(empty,empty),empty,empty,validkey(dhexp_real(key_e(alice,bob,sid_5),g)),empty,false)))).

6. The entry statestore(bob,charlie,sid_6,statepack_b(handshakestatepack(symmetricstatepack(cipherstatepack(empty,increment_nonce(minnonce)),hash(somename,empty),hash(hash(hash(hash(somename,empty),empty),validkey(dhexp_real(key_e(alice,bob,sid_5),g))),encrypt(empty,minnonce,hash(hash(hash(somename,empty),empty),validkey(dhexp_real(key_e(alice,bob,sid_5),g))),msg_a(alice,bob,sid_5)))),keypairpack(empty,empty),keypairpack(empty,empty),keypairpack(empty,empty),empty,empty,validkey(dhexp_real(key_e(alice,bob,sid_5),g)),empty,false))) that may be in a table by 5 may be read at get {2115}.
The event SendMsg(bob,charlie,stagepack_b(sid_6),msg_b(bob,charlie,sid_6)) may be executed at {2112}.
So the message concat4(validkey(dhexp_real(key_e(bob,charlie,sid_6),g)),encrypt(hmac_hash2(hash(somename,empty),dhexp_real(key_e(alice,bob,sid_5),dhexp_real(key_e(bob,charlie,sid_6),g))),minnonce,hash(hash(hash(hash(hash(somename,empty),empty),validkey(dhexp_real(key_e(alice,bob,sid_5),g))),encrypt(empty,minnonce,hash(hash(hash(somename,empty),empty),validkey(dhexp_real(key_e(alice,bob,sid_5),g))),msg_a(alice,bob,sid_5))),validkey(dhexp_real(key_e(bob,charlie,sid_6),g))),validkey(dhexp_real(key_s(bob),g))),encrypt(hmac_hash2(hash(somename,empty),dhexp_real(key_e(alice,bob,sid_5),dhexp_real(key_e(bob,charlie,sid_6),g))),increment_nonce(minnonce),hash(hash(hash(hash(hash(hash(somename,empty),empty),validkey(dhexp_real(key_e(alice,bob,sid_5),g))),encrypt(empty,minnonce,hash(hash(hash(somename,empty),empty),validkey(dhexp_real(key_e(alice,bob,sid_5),g))),msg_a(alice,bob,sid_5))),validkey(dhexp_real(key_e(bob,charlie,sid_6),g))),encrypt(hmac_hash2(hash(somename,empty),dhexp_real(key_e(alice,bob,sid_5),dhexp_real(key_e(bob,charlie,sid_6),g))),minnonce,hash(hash(hash(hash(hash(somename,empty),empty),validkey(dhexp_real(key_e(alice,bob,sid_5),g))),encrypt(empty,minnonce,hash(hash(hash(somename,empty),empty),validkey(dhexp_real(key_e(alice,bob,sid_5),g))),msg_a(alice,bob,sid_5))),validkey(dhexp_real(key_e(bob,charlie,sid_6),g))),validkey(dhexp_real(key_s(bob),g)))),validkey(dhexp_real(key_m(bob),g))),encrypt(hmac_hash2(hmac_hash1(hmac_hash1(hash(somename,empty),dhexp_real(key_e(alice,bob,sid_5),dhexp_real(key_e(bob,charlie,sid_6),g))),dhexp_real(key_e(alice,bob,sid_5),dhexp_real(key_s(bob),g))),dhexp_real(key_e(alice,bob,sid_5),dhexp_real(key_m(bob),g))),minnonce,hash(hash(hash(hash(hash(hash(hash(somename,empty),empty),validkey(dhexp_real(key_e(alice,bob,sid_5),g))),encrypt(empty,minnonce,hash(hash(hash(somename,empty),empty),validkey(dhexp_real(key_e(alice,bob,sid_5),g))),msg_a(alice,bob,sid_5))),validkey(dhexp_real(key_e(bob,charlie,sid_6),g))),encrypt(hmac_hash2(hash(somename,empty),dhexp_real(key_e(alice,bob,sid_5),dhexp_real(key_e(bob,charlie,sid_6),g))),minnonce,hash(hash(hash(hash(hash(somename,empty),empty),validkey(dhexp_real(key_e(alice,bob,sid_5),g))),encrypt(empty,minnonce,hash(hash(hash(somename,empty),empty),validkey(dhexp_real(key_e(alice,bob,sid_5),g))),msg_a(alice,bob,sid_5))),validkey(dhexp_real(key_e(bob,charlie,sid_6),g))),validkey(dhexp_real(key_s(bob),g)))),encrypt(hmac_hash2(hash(somename,empty),dhexp_real(key_e(alice,bob,sid_5),dhexp_real(key_e(bob,charlie,sid_6),g))),increment_nonce(minnonce),hash(hash(hash(hash(hash(hash(somename,empty),empty),validkey(dhexp_real(key_e(alice,bob,sid_5),g))),encrypt(empty,minnonce,hash(hash(hash(somename,empty),empty),validkey(dhexp_real(key_e(alice,bob,sid_5),g))),msg_a(alice,bob,sid_5))),validkey(dhexp_real(key_e(bob,charlie,sid_6),g))),encrypt(hmac_hash2(hash(somename,empty),dhexp_real(key_e(alice,bob,sid_5),dhexp_real(key_e(bob,charlie,sid_6),g))),minnonce,hash(hash(hash(hash(hash(somename,empty),empty),validkey(dhexp_real(key_e(alice,bob,sid_5),g))),encrypt(empty,minnonce,hash(hash(hash(somename,empty),empty),validkey(dhexp_real(key_e(alice,bob,sid_5),g))),msg_a(alice,bob,sid_5))),validkey(dhexp_real(key_e(bob,charlie,sid_6),g))),validkey(dhexp_real(key_s(bob),g)))),validkey(dhexp_real(key_m(bob),g)))),msg_b(bob,charlie,sid_6))) may be sent on channel pub at output {2114}.
mess(pub,concat4(validkey(dhexp_real(key_e(bob,charlie,sid_6),g)),encrypt(hmac_hash2(hash(somename,empty),dhexp_real(key_e(alice,bob,sid_5),dhexp_real(key_e(bob,charlie,sid_6),g))),minnonce,hash(hash(hash(hash(hash(somename,empty),empty),validkey(dhexp_real(key_e(alice,bob,sid_5),g))),encrypt(empty,minnonce,hash(hash(hash(somename,empty),empty),validkey(dhexp_real(key_e(alice,bob,sid_5),g))),msg_a(alice,bob,sid_5))),validkey(dhexp_real(key_e(bob,charlie,sid_6),g))),validkey(dhexp_real(key_s(bob),g))),encrypt(hmac_hash2(hash(somename,empty),dhexp_real(key_e(alice,bob,sid_5),dhexp_real(key_e(bob,charlie,sid_6),g))),increment_nonce(minnonce),hash(hash(hash(hash(hash(hash(somename,empty),empty),validkey(dhexp_real(key_e(alice,bob,sid_5),g))),encrypt(empty,minnonce,hash(hash(hash(somename,empty),empty),validkey(dhexp_real(key_e(alice,bob,sid_5),g))),msg_a(alice,bob,sid_5))),validkey(dhexp_real(key_e(bob,charlie,sid_6),g))),encrypt(hmac_hash2(hash(somename,empty),dhexp_real(key_e(alice,bob,sid_5),dhexp_real(key_e(bob,charlie,sid_6),g))),minnonce,hash(hash(hash(hash(hash(somename,empty),empty),validkey(dhexp_real(key_e(alice,bob,sid_5),g))),encrypt(empty,minnonce,hash(hash(hash(somename,empty),empty),validkey(dhexp_real(key_e(alice,bob,sid_5),g))),msg_a(alice,bob,sid_5))),validkey(dhexp_real(key_e(bob,charlie,sid_6),g))),validkey(dhexp_real(key_s(bob),g)))),validkey(dhexp_real(key_m(bob),g))),encrypt(hmac_hash2(hmac_hash1(hmac_hash1(hash(somename,empty),dhexp_real(key_e(alice,bob,sid_5),dhexp_real(key_e(bob,charlie,sid_6),g))),dhexp_real(key_e(alice,bob,sid_5),dhexp_real(key_s(bob),g))),dhexp_real(key_e(alice,bob,sid_5),dhexp_real(key_m(bob),g))),minnonce,hash(hash(hash(hash(hash(hash(hash(somename,empty),empty),validkey(dhexp_real(key_e(alice,bob,sid_5),g))),encrypt(empty,minnonce,hash(hash(hash(somename,empty),empty),validkey(dhexp_real(key_e(alice,bob,sid_5),g))),msg_a(alice,bob,sid_5))),validkey(dhexp_real(key_e(bob,charlie,sid_6),g))),encrypt(hmac_hash2(hash(somename,empty),dhexp_real(key_e(alice,bob,sid_5),dhexp_real(key_e(bob,charlie,sid_6),g))),minnonce,hash(hash(hash(hash(hash(somename,empty),empty),validkey(dhexp_real(key_e(alice,bob,sid_5),g))),encrypt(empty,minnonce,hash(hash(hash(somename,empty),empty),validkey(dhexp_real(key_e(alice,bob,sid_5),g))),msg_a(alice,bob,sid_5))),validkey(dhexp_real(key_e(bob,charlie,sid_6),g))),validkey(dhexp_real(key_s(bob),g)))),encrypt(hmac_hash2(hash(somename,empty),dhexp_real(key_e(alice,bob,sid_5),dhexp_real(key_e(bob,charlie,sid_6),g))),increment_nonce(minnonce),hash(hash(hash(hash(hash(hash(somename,empty),empty),validkey(dhexp_real(key_e(alice,bob,sid_5),g))),encrypt(empty,minnonce,hash(hash(hash(somename,empty),empty),validkey(dhexp_real(key_e(alice,bob,sid_5),g))),msg_a(alice,bob,sid_5))),validkey(dhexp_real(key_e(bob,charlie,sid_6),g))),encrypt(hmac_hash2(hash(somename,empty),dhexp_real(key_e(alice,bob,sid_5),dhexp_real(key_e(bob,charlie,sid_6),g))),minnonce,hash(hash(hash(hash(hash(somename,empty),empty),validkey(dhexp_real(key_e(alice,bob,sid_5),g))),encrypt(empty,minnonce,hash(hash(hash(somename,empty),empty),validkey(dhexp_real(key_e(alice,bob,sid_5),g))),msg_a(alice,bob,sid_5))),validkey(dhexp_real(key_e(bob,charlie,sid_6),g))),validkey(dhexp_real(key_s(bob),g)))),validkey(dhexp_real(key_m(bob),g)))),msg_b(bob,charlie,sid_6)))).

7. The entry statestore(alice,bob,sid_5,statepack_b(handshakestatepack(symmetricstatepack(cipherstatepack(empty,increment_nonce(minnonce)),hash(somename,empty),hash(hash(hash(hash(somename,empty),empty),validkey(dhexp_real(key_e(alice,bob,sid_5),g))),encrypt(empty,minnonce,hash(hash(hash(somename,empty),empty),validkey(dhexp_real(key_e(alice,bob,sid_5),g))),msg_a(alice,bob,sid_5)))),keypairpack(empty,empty),keypairpack(empty,empty),keypairpack(validkey(dhexp_real(key_e(alice,bob,sid_5),g)),key_e(alice,bob,sid_5)),empty,empty,empty,empty,true))) that may be in a table by 2 may be read at get {328}.
The message concat4(validkey(dhexp_real(key_e(bob,charlie,sid_6),g)),encrypt(hmac_hash2(hash(somename,empty),dhexp_real(key_e(alice,bob,sid_5),dhexp_real(key_e(bob,charlie,sid_6),g))),minnonce,hash(hash(hash(hash(hash(somename,empty),empty),validkey(dhexp_real(key_e(alice,bob,sid_5),g))),encrypt(empty,minnonce,hash(hash(hash(somename,empty),empty),validkey(dhexp_real(key_e(alice,bob,sid_5),g))),msg_a(alice,bob,sid_5))),validkey(dhexp_real(key_e(bob,charlie,sid_6),g))),validkey(dhexp_real(key_s(bob),g))),encrypt(hmac_hash2(hash(somename,empty),dhexp_real(key_e(alice,bob,sid_5),dhexp_real(key_e(bob,charlie,sid_6),g))),increment_nonce(minnonce),hash(hash(hash(hash(hash(hash(somename,empty),empty),validkey(dhexp_real(key_e(alice,bob,sid_5),g))),encrypt(empty,minnonce,hash(hash(hash(somename,empty),empty),validkey(dhexp_real(key_e(alice,bob,sid_5),g))),msg_a(alice,bob,sid_5))),validkey(dhexp_real(key_e(bob,charlie,sid_6),g))),encrypt(hmac_hash2(hash(somename,empty),dhexp_real(key_e(alice,bob,sid_5),dhexp_real(key_e(bob,charlie,sid_6),g))),minnonce,hash(hash(hash(hash(hash(somename,empty),empty),validkey(dhexp_real(key_e(alice,bob,sid_5),g))),encrypt(empty,minnonce,hash(hash(hash(somename,empty),empty),validkey(dhexp_real(key_e(alice,bob,sid_5),g))),msg_a(alice,bob,sid_5))),validkey(dhexp_real(key_e(bob,charlie,sid_6),g))),validkey(dhexp_real(key_s(bob),g)))),validkey(dhexp_real(key_m(bob),g))),encrypt(hmac_hash2(hmac_hash1(hmac_hash1(hash(somename,empty),dhexp_real(key_e(alice,bob,sid_5),dhexp_real(key_e(bob,charlie,sid_6),g))),dhexp_real(key_e(alice,bob,sid_5),dhexp_real(key_s(bob),g))),dhexp_real(key_e(alice,bob,sid_5),dhexp_real(key_m(bob),g))),minnonce,hash(hash(hash(hash(hash(hash(hash(somename,empty),empty),validkey(dhexp_real(key_e(alice,bob,sid_5),g))),encrypt(empty,minnonce,hash(hash(hash(somename,empty),empty),validkey(dhexp_real(key_e(alice,bob,sid_5),g))),msg_a(alice,bob,sid_5))),validkey(dhexp_real(key_e(bob,charlie,sid_6),g))),encrypt(hmac_hash2(hash(somename,empty),dhexp_real(key_e(alice,bob,sid_5),dhexp_real(key_e(bob,charlie,sid_6),g))),minnonce,hash(hash(hash(hash(hash(somename,empty),empty),validkey(dhexp_real(key_e(alice,bob,sid_5),g))),encrypt(empty,minnonce,hash(hash(hash(somename,empty),empty),validkey(dhexp_real(key_e(alice,bob,sid_5),g))),msg_a(alice,bob,sid_5))),validkey(dhexp_real(key_e(bob,charlie,sid_6),g))),validkey(dhexp_real(key_s(bob),g)))),encrypt(hmac_hash2(hash(somename,empty),dhexp_real(key_e(alice,bob,sid_5),dhexp_real(key_e(bob,charlie,sid_6),g))),increment_nonce(minnonce),hash(hash(hash(hash(hash(hash(somename,empty),empty),validkey(dhexp_real(key_e(alice,bob,sid_5),g))),encrypt(empty,minnonce,hash(hash(hash(somename,empty),empty),validkey(dhexp_real(key_e(alice,bob,sid_5),g))),msg_a(alice,bob,sid_5))),validkey(dhexp_real(key_e(bob,charlie,sid_6),g))),encrypt(hmac_hash2(hash(somename,empty),dhexp_real(key_e(alice,bob,sid_5),dhexp_real(key_e(bob,charlie,sid_6),g))),minnonce,hash(hash(hash(hash(hash(somename,empty),empty),validkey(dhexp_real(key_e(alice,bob,sid_5),g))),encrypt(empty,minnonce,hash(hash(hash(somename,empty),empty),validkey(dhexp_real(key_e(alice,bob,sid_5),g))),msg_a(alice,bob,sid_5))),validkey(dhexp_real(key_e(bob,charlie,sid_6),g))),validkey(dhexp_real(key_s(bob),g)))),validkey(dhexp_real(key_m(bob),g)))),msg_b(bob,charlie,sid_6))) that may be sent on channel pub by 6 may be received at input {102}.
So event RecvMsg(alice,bob,stagepack_b(sid_5),msg_b(bob,charlie,sid_6)) may be executed at {326}.
end(RecvMsg(alice,bob,stagepack_b(sid_5),msg_b(bob,charlie,sid_6))).

8. By 7, end(RecvMsg(alice,bob,stagepack_b(sid_5),msg_b(bob,charlie,sid_6))).
The goal is reached, represented in the following fact:
end(RecvMsg(alice,bob,stagepack_b(sid_5),msg_b(bob,charlie,sid_6))).


RESULT event(RecvMsg(alice,bob,stagepack_b(sid_a),m_28)) ==> event(SendMsg(bob,alice,stagepack_b(sid_b),m_28)) || (event(LeakS(phase0,bob)) && event(LeakM(phase0,bob))) || (event(LeakS(phase0,alice)) && event(LeakM(phase0,alice))) cannot be proved.
Starting query event(RecvMsg(alice,bob,stagepack_b(sid_a),m_28)) ==> event(SendMsg(bob,alice,stagepack_b(sid_b),m_28)) || (event(LeakS(phase0,bob)) && event(LeakM(phase0,bob)))
goal reachable: begin(SendMsg(bob,charlie,stagepack_b(sid_5),msg_b(bob,charlie,sid_5))) && begin(SendMsg(alice,bob,stagepack_a(sid_6),msg_a(alice,bob,sid_6))) -> end(RecvMsg(alice,bob,stagepack_b(sid_6),msg_b(bob,charlie,sid_5)))
Abbreviations:
sid_6 = sid[!1 = @sid]
sid_5 = sid[!1 = @sid_1]

Derivation:
Abbreviations:
sid_5 = sid[!1 = @sid]
sid_6 = sid[!1 = @sid_1]

1. The entry statestore(alice,bob,sid_5,statepack_a(handshakestatepack(symmetricstatepack(cipherstatepack(empty,minnonce),hash(somename,empty),hash(hash(somename,empty),empty)),keypairpack(empty,empty),keypairpack(empty,empty),keypairpack(empty,empty),empty,empty,empty,empty,true))) may be inserted in a table at insert {30}.
table(statestore(alice,bob,sid_5,statepack_a(handshakestatepack(symmetricstatepack(cipherstatepack(empty,minnonce),hash(somename,empty),hash(hash(somename,empty),empty)),keypairpack(empty,empty),keypairpack(empty,empty),keypairpack(empty,empty),empty,empty,empty,empty,true)))).

2. The entry statestore(alice,bob,sid_5,statepack_a(handshakestatepack(symmetricstatepack(cipherstatepack(empty,minnonce),hash(somename,empty),hash(hash(somename,empty),empty)),keypairpack(empty,empty),keypairpack(empty,empty),keypairpack(empty,empty),empty,empty,empty,empty,true))) that may be in a table by 1 may be read at get {101}.
The event SendMsg(alice,bob,stagepack_a(sid_5),msg_a(alice,bob,sid_5)) may be executed at {98}.
So the entry statestore(alice,bob,sid_5,statepack_b(handshakestatepack(symmetricstatepack(cipherstatepack(empty,increment_nonce(minnonce)),hash(somename,empty),hash(hash(hash(hash(somename,empty),empty),validkey(dhexp_real(key_e(alice,bob,sid_5),g))),encrypt(empty,minnonce,hash(hash(hash(somename,empty),empty),validkey(dhexp_real(key_e(alice,bob,sid_5),g))),msg_a(alice,bob,sid_5)))),keypairpack(empty,empty),keypairpack(empty,empty),keypairpack(validkey(dhexp_real(key_e(alice,bob,sid_5),g)),key_e(alice,bob,sid_5)),empty,empty,empty,empty,true))) may be inserted in a table at insert {99}.
table(statestore(alice,bob,sid_5,statepack_b(handshakestatepack(symmetricstatepack(cipherstatepack(empty,increment_nonce(minnonce)),hash(somename,empty),hash(hash(hash(hash(somename,empty),empty),validkey(dhexp_real(key_e(alice,bob,sid_5),g))),encrypt(empty,minnonce,hash(hash(hash(somename,empty),empty),validkey(dhexp_real(key_e(alice,bob,sid_5),g))),msg_a(alice,bob,sid_5)))),keypairpack(empty,empty),keypairpack(empty,empty),keypairpack(validkey(dhexp_real(key_e(alice,bob,sid_5),g)),key_e(alice,bob,sid_5)),empty,empty,empty,empty,true)))).

3. The entry statestore(bob,charlie,sid_6,statepack_a(handshakestatepack(symmetricstatepack(cipherstatepack(empty,minnonce),hash(somename,empty),hash(hash(somename,empty),empty)),keypairpack(empty,empty),keypairpack(empty,empty),keypairpack(empty,empty),empty,empty,empty,empty,false))) may be inserted in a table at insert {1827}.
table(statestore(bob,charlie,sid_6,statepack_a(handshakestatepack(symmetricstatepack(cipherstatepack(empty,minnonce),hash(somename,empty),hash(hash(somename,empty),empty)),keypairpack(empty,empty),keypairpack(empty,empty),keypairpack(empty,empty),empty,empty,empty,empty,false)))).

4. The entry statestore(alice,bob,sid_5,statepack_a(handshakestatepack(symmetricstatepack(cipherstatepack(empty,minnonce),hash(somename,empty),hash(hash(somename,empty),empty)),keypairpack(empty,empty),keypairpack(empty,empty),keypairpack(empty,empty),empty,empty,empty,empty,true))) that may be in a table by 1 may be read at get {101}.
The event SendMsg(alice,bob,stagepack_a(sid_5),msg_a(alice,bob,sid_5)) may be executed at {98}.
So the message concat3(validkey(dhexp_real(key_e(alice,bob,sid_5),g)),empty,encrypt(empty,minnonce,hash(hash(hash(somename,empty),empty),validkey(dhexp_real(key_e(alice,bob,sid_5),g))),msg_a(alice,bob,sid_5))) may be sent on channel pub at output {100}.
mess(pub,concat3(validkey(dhexp_real(key_e(alice,bob,sid_5),g)),empty,encrypt(empty,minnonce,hash(hash(hash(somename,empty),empty),validkey(dhexp_real(key_e(alice,bob,sid_5),g))),msg_a(alice,bob,sid_5)))).

5. The entry statestore(bob,charlie,sid_6,statepack_a(handshakestatepack(symmetricstatepack(cipherstatepack(empty,minnonce),hash(somename,empty),hash(hash(somename,empty),empty)),keypairpack(empty,empty),keypairpack(empty,empty),keypairpack(empty,empty),empty,empty,empty,empty,false))) that may be in a table by 3 may be read at get {1900}.
The message concat3(validkey(dhexp_real(key_e(alice,bob,sid_5),g)),empty,encrypt(empty,minnonce,hash(hash(hash(somename,empty),empty),validkey(dhexp_real(key_e(alice,bob,sid_5),g))),msg_a(alice,bob,sid_5))) that may be sent on channel pub by 4 may be received at input {1828}.
So the entry statestore(bob,charlie,sid_6,statepack_b(handshakestatepack(symmetricstatepack(cipherstatepack(empty,increment_nonce(minnonce)),hash(somename,empty),hash(hash(hash(hash(somename,empty),empty),validkey(dhexp_real(key_e(alice,bob,sid_5),g))),encrypt(empty,minnonce,hash(hash(hash(somename,empty),empty),validkey(dhexp_real(key_e(alice,bob,sid_5),g))),msg_a(alice,bob,sid_5)))),keypairpack(empty,empty),keypairpack(empty,empty),keypairpack(empty,empty),empty,empty,validkey(dhexp_real(key_e(alice,bob,sid_5),g)),empty,false))) may be inserted in a table at insert {1899}.
table(statestore(bob,charlie,sid_6,statepack_b(handshakestatepack(symmetricstatepack(cipherstatepack(empty,increment_nonce(minnonce)),hash(somename,empty),hash(hash(hash(hash(somename,empty),empty),validkey(dhexp_real(key_e(alice,bob,sid_5),g))),encrypt(empty,minnonce,hash(hash(hash(somename,empty),empty),validkey(dhexp_real(key_e(alice,bob,sid_5),g))),msg_a(alice,bob,sid_5)))),keypairpack(empty,empty),keypairpack(empty,empty),keypairpack(empty,empty),empty,empty,validkey(dhexp_real(key_e(alice,bob,sid_5),g)),empty,false)))).

6. The entry statestore(bob,charlie,sid_6,statepack_b(handshakestatepack(symmetricstatepack(cipherstatepack(empty,increment_nonce(minnonce)),hash(somename,empty),hash(hash(hash(hash(somename,empty),empty),validkey(dhexp_real(key_e(alice,bob,sid_5),g))),encrypt(empty,minnonce,hash(hash(hash(somename,empty),empty),validkey(dhexp_real(key_e(alice,bob,sid_5),g))),msg_a(alice,bob,sid_5)))),keypairpack(empty,empty),keypairpack(empty,empty),keypairpack(empty,empty),empty,empty,validkey(dhexp_real(key_e(alice,bob,sid_5),g)),empty,false))) that may be in a table by 5 may be read at get {2115}.
The event SendMsg(bob,charlie,stagepack_b(sid_6),msg_b(bob,charlie,sid_6)) may be executed at {2112}.
So the message concat4(validkey(dhexp_real(key_e(bob,charlie,sid_6),g)),encrypt(hmac_hash2(hash(somename,empty),dhexp_real(key_e(alice,bob,sid_5),dhexp_real(key_e(bob,charlie,sid_6),g))),minnonce,hash(hash(hash(hash(hash(somename,empty),empty),validkey(dhexp_real(key_e(alice,bob,sid_5),g))),encrypt(empty,minnonce,hash(hash(hash(somename,empty),empty),validkey(dhexp_real(key_e(alice,bob,sid_5),g))),msg_a(alice,bob,sid_5))),validkey(dhexp_real(key_e(bob,charlie,sid_6),g))),validkey(dhexp_real(key_s(bob),g))),encrypt(hmac_hash2(hash(somename,empty),dhexp_real(key_e(alice,bob,sid_5),dhexp_real(key_e(bob,charlie,sid_6),g))),increment_nonce(minnonce),hash(hash(hash(hash(hash(hash(somename,empty),empty),validkey(dhexp_real(key_e(alice,bob,sid_5),g))),encrypt(empty,minnonce,hash(hash(hash(somename,empty),empty),validkey(dhexp_real(key_e(alice,bob,sid_5),g))),msg_a(alice,bob,sid_5))),validkey(dhexp_real(key_e(bob,charlie,sid_6),g))),encrypt(hmac_hash2(hash(somename,empty),dhexp_real(key_e(alice,bob,sid_5),dhexp_real(key_e(bob,charlie,sid_6),g))),minnonce,hash(hash(hash(hash(hash(somename,empty),empty),validkey(dhexp_real(key_e(alice,bob,sid_5),g))),encrypt(empty,minnonce,hash(hash(hash(somename,empty),empty),validkey(dhexp_real(key_e(alice,bob,sid_5),g))),msg_a(alice,bob,sid_5))),validkey(dhexp_real(key_e(bob,charlie,sid_6),g))),validkey(dhexp_real(key_s(bob),g)))),validkey(dhexp_real(key_m(bob),g))),encrypt(hmac_hash2(hmac_hash1(hmac_hash1(hash(somename,empty),dhexp_real(key_e(alice,bob,sid_5),dhexp_real(key_e(bob,charlie,sid_6),g))),dhexp_real(key_e(alice,bob,sid_5),dhexp_real(key_s(bob),g))),dhexp_real(key_e(alice,bob,sid_5),dhexp_real(key_m(bob),g))),minnonce,hash(hash(hash(hash(hash(hash(hash(somename,empty),empty),validkey(dhexp_real(key_e(alice,bob,sid_5),g))),encrypt(empty,minnonce,hash(hash(hash(somename,empty),empty),validkey(dhexp_real(key_e(alice,bob,sid_5),g))),msg_a(alice,bob,sid_5))),validkey(dhexp_real(key_e(bob,charlie,sid_6),g))),encrypt(hmac_hash2(hash(somename,empty),dhexp_real(key_e(alice,bob,sid_5),dhexp_real(key_e(bob,charlie,sid_6),g))),minnonce,hash(hash(hash(hash(hash(somename,empty),empty),validkey(dhexp_real(key_e(alice,bob,sid_5),g))),encrypt(empty,minnonce,hash(hash(hash(somename,empty),empty),validkey(dhexp_real(key_e(alice,bob,sid_5),g))),msg_a(alice,bob,sid_5))),validkey(dhexp_real(key_e(bob,charlie,sid_6),g))),validkey(dhexp_real(key_s(bob),g)))),encrypt(hmac_hash2(hash(somename,empty),dhexp_real(key_e(alice,bob,sid_5),dhexp_real(key_e(bob,charlie,sid_6),g))),increment_nonce(minnonce),hash(hash(hash(hash(hash(hash(somename,empty),empty),validkey(dhexp_real(key_e(alice,bob,sid_5),g))),encrypt(empty,minnonce,hash(hash(hash(somename,empty),empty),validkey(dhexp_real(key_e(alice,bob,sid_5),g))),msg_a(alice,bob,sid_5))),validkey(dhexp_real(key_e(bob,charlie,sid_6),g))),encrypt(hmac_hash2(hash(somename,empty),dhexp_real(key_e(alice,bob,sid_5),dhexp_real(key_e(bob,charlie,sid_6),g))),minnonce,hash(hash(hash(hash(hash(somename,empty),empty),validkey(dhexp_real(key_e(alice,bob,sid_5),g))),encrypt(empty,minnonce,hash(hash(hash(somename,empty),empty),validkey(dhexp_real(key_e(alice,bob,sid_5),g))),msg_a(alice,bob,sid_5))),validkey(dhexp_real(key_e(bob,charlie,sid_6),g))),validkey(dhexp_real(key_s(bob),g)))),validkey(dhexp_real(key_m(bob),g)))),msg_b(bob,charlie,sid_6))) may be sent on channel pub at output {2114}.
mess(pub,concat4(validkey(dhexp_real(key_e(bob,charlie,sid_6),g)),encrypt(hmac_hash2(hash(somename,empty),dhexp_real(key_e(alice,bob,sid_5),dhexp_real(key_e(bob,charlie,sid_6),g))),minnonce,hash(hash(hash(hash(hash(somename,empty),empty),validkey(dhexp_real(key_e(alice,bob,sid_5),g))),encrypt(empty,minnonce,hash(hash(hash(somename,empty),empty),validkey(dhexp_real(key_e(alice,bob,sid_5),g))),msg_a(alice,bob,sid_5))),validkey(dhexp_real(key_e(bob,charlie,sid_6),g))),validkey(dhexp_real(key_s(bob),g))),encrypt(hmac_hash2(hash(somename,empty),dhexp_real(key_e(alice,bob,sid_5),dhexp_real(key_e(bob,charlie,sid_6),g))),increment_nonce(minnonce),hash(hash(hash(hash(hash(hash(somename,empty),empty),validkey(dhexp_real(key_e(alice,bob,sid_5),g))),encrypt(empty,minnonce,hash(hash(hash(somename,empty),empty),validkey(dhexp_real(key_e(alice,bob,sid_5),g))),msg_a(alice,bob,sid_5))),validkey(dhexp_real(key_e(bob,charlie,sid_6),g))),encrypt(hmac_hash2(hash(somename,empty),dhexp_real(key_e(alice,bob,sid_5),dhexp_real(key_e(bob,charlie,sid_6),g))),minnonce,hash(hash(hash(hash(hash(somename,empty),empty),validkey(dhexp_real(key_e(alice,bob,sid_5),g))),encrypt(empty,minnonce,hash(hash(hash(somename,empty),empty),validkey(dhexp_real(key_e(alice,bob,sid_5),g))),msg_a(alice,bob,sid_5))),validkey(dhexp_real(key_e(bob,charlie,sid_6),g))),validkey(dhexp_real(key_s(bob),g)))),validkey(dhexp_real(key_m(bob),g))),encrypt(hmac_hash2(hmac_hash1(hmac_hash1(hash(somename,empty),dhexp_real(key_e(alice,bob,sid_5),dhexp_real(key_e(bob,charlie,sid_6),g))),dhexp_real(key_e(alice,bob,sid_5),dhexp_real(key_s(bob),g))),dhexp_real(key_e(alice,bob,sid_5),dhexp_real(key_m(bob),g))),minnonce,hash(hash(hash(hash(hash(hash(hash(somename,empty),empty),validkey(dhexp_real(key_e(alice,bob,sid_5),g))),encrypt(empty,minnonce,hash(hash(hash(somename,empty),empty),validkey(dhexp_real(key_e(alice,bob,sid_5),g))),msg_a(alice,bob,sid_5))),validkey(dhexp_real(key_e(bob,charlie,sid_6),g))),encrypt(hmac_hash2(hash(somename,empty),dhexp_real(key_e(alice,bob,sid_5),dhexp_real(key_e(bob,charlie,sid_6),g))),minnonce,hash(hash(hash(hash(hash(somename,empty),empty),validkey(dhexp_real(key_e(alice,bob,sid_5),g))),encrypt(empty,minnonce,hash(hash(hash(somename,empty),empty),validkey(dhexp_real(key_e(alice,bob,sid_5),g))),msg_a(alice,bob,sid_5))),validkey(dhexp_real(key_e(bob,charlie,sid_6),g))),validkey(dhexp_real(key_s(bob),g)))),encrypt(hmac_hash2(hash(somename,empty),dhexp_real(key_e(alice,bob,sid_5),dhexp_real(key_e(bob,charlie,sid_6),g))),increment_nonce(minnonce),hash(hash(hash(hash(hash(hash(somename,empty),empty),validkey(dhexp_real(key_e(alice,bob,sid_5),g))),encrypt(empty,minnonce,hash(hash(hash(somename,empty),empty),validkey(dhexp_real(key_e(alice,bob,sid_5),g))),msg_a(alice,bob,sid_5))),validkey(dhexp_real(key_e(bob,charlie,sid_6),g))),encrypt(hmac_hash2(hash(somename,empty),dhexp_real(key_e(alice,bob,sid_5),dhexp_real(key_e(bob,charlie,sid_6),g))),minnonce,hash(hash(hash(hash(hash(somename,empty),empty),validkey(dhexp_real(key_e(alice,bob,sid_5),g))),encrypt(empty,minnonce,hash(hash(hash(somename,empty),empty),validkey(dhexp_real(key_e(alice,bob,sid_5),g))),msg_a(alice,bob,sid_5))),validkey(dhexp_real(key_e(bob,charlie,sid_6),g))),validkey(dhexp_real(key_s(bob),g)))),validkey(dhexp_real(key_m(bob),g)))),msg_b(bob,charlie,sid_6)))).

7. The entry statestore(alice,bob,sid_5,statepack_b(handshakestatepack(symmetricstatepack(cipherstatepack(empty,increment_nonce(minnonce)),hash(somename,empty),hash(hash(hash(hash(somename,empty),empty),validkey(dhexp_real(key_e(alice,bob,sid_5),g))),encrypt(empty,minnonce,hash(hash(hash(somename,empty),empty),validkey(dhexp_real(key_e(alice,bob,sid_5),g))),msg_a(alice,bob,sid_5)))),keypairpack(empty,empty),keypairpack(empty,empty),keypairpack(validkey(dhexp_real(key_e(alice,bob,sid_5),g)),key_e(alice,bob,sid_5)),empty,empty,empty,empty,true))) that may be in a table by 2 may be read at get {328}.
The message concat4(validkey(dhexp_real(key_e(bob,charlie,sid_6),g)),encrypt(hmac_hash2(hash(somename,empty),dhexp_real(key_e(alice,bob,sid_5),dhexp_real(key_e(bob,charlie,sid_6),g))),minnonce,hash(hash(hash(hash(hash(somename,empty),empty),validkey(dhexp_real(key_e(alice,bob,sid_5),g))),encrypt(empty,minnonce,hash(hash(hash(somename,empty),empty),validkey(dhexp_real(key_e(alice,bob,sid_5),g))),msg_a(alice,bob,sid_5))),validkey(dhexp_real(key_e(bob,charlie,sid_6),g))),validkey(dhexp_real(key_s(bob),g))),encrypt(hmac_hash2(hash(somename,empty),dhexp_real(key_e(alice,bob,sid_5),dhexp_real(key_e(bob,charlie,sid_6),g))),increment_nonce(minnonce),hash(hash(hash(hash(hash(hash(somename,empty),empty),validkey(dhexp_real(key_e(alice,bob,sid_5),g))),encrypt(empty,minnonce,hash(hash(hash(somename,empty),empty),validkey(dhexp_real(key_e(alice,bob,sid_5),g))),msg_a(alice,bob,sid_5))),validkey(dhexp_real(key_e(bob,charlie,sid_6),g))),encrypt(hmac_hash2(hash(somename,empty),dhexp_real(key_e(alice,bob,sid_5),dhexp_real(key_e(bob,charlie,sid_6),g))),minnonce,hash(hash(hash(hash(hash(somename,empty),empty),validkey(dhexp_real(key_e(alice,bob,sid_5),g))),encrypt(empty,minnonce,hash(hash(hash(somename,empty),empty),validkey(dhexp_real(key_e(alice,bob,sid_5),g))),msg_a(alice,bob,sid_5))),validkey(dhexp_real(key_e(bob,charlie,sid_6),g))),validkey(dhexp_real(key_s(bob),g)))),validkey(dhexp_real(key_m(bob),g))),encrypt(hmac_hash2(hmac_hash1(hmac_hash1(hash(somename,empty),dhexp_real(key_e(alice,bob,sid_5),dhexp_real(key_e(bob,charlie,sid_6),g))),dhexp_real(key_e(alice,bob,sid_5),dhexp_real(key_s(bob),g))),dhexp_real(key_e(alice,bob,sid_5),dhexp_real(key_m(bob),g))),minnonce,hash(hash(hash(hash(hash(hash(hash(somename,empty),empty),validkey(dhexp_real(key_e(alice,bob,sid_5),g))),encrypt(empty,minnonce,hash(hash(hash(somename,empty),empty),validkey(dhexp_real(key_e(alice,bob,sid_5),g))),msg_a(alice,bob,sid_5))),validkey(dhexp_real(key_e(bob,charlie,sid_6),g))),encrypt(hmac_hash2(hash(somename,empty),dhexp_real(key_e(alice,bob,sid_5),dhexp_real(key_e(bob,charlie,sid_6),g))),minnonce,hash(hash(hash(hash(hash(somename,empty),empty),validkey(dhexp_real(key_e(alice,bob,sid_5),g))),encrypt(empty,minnonce,hash(hash(hash(somename,empty),empty),validkey(dhexp_real(key_e(alice,bob,sid_5),g))),msg_a(alice,bob,sid_5))),validkey(dhexp_real(key_e(bob,charlie,sid_6),g))),validkey(dhexp_real(key_s(bob),g)))),encrypt(hmac_hash2(hash(somename,empty),dhexp_real(key_e(alice,bob,sid_5),dhexp_real(key_e(bob,charlie,sid_6),g))),increment_nonce(minnonce),hash(hash(hash(hash(hash(hash(somename,empty),empty),validkey(dhexp_real(key_e(alice,bob,sid_5),g))),encrypt(empty,minnonce,hash(hash(hash(somename,empty),empty),validkey(dhexp_real(key_e(alice,bob,sid_5),g))),msg_a(alice,bob,sid_5))),validkey(dhexp_real(key_e(bob,charlie,sid_6),g))),encrypt(hmac_hash2(hash(somename,empty),dhexp_real(key_e(alice,bob,sid_5),dhexp_real(key_e(bob,charlie,sid_6),g))),minnonce,hash(hash(hash(hash(hash(somename,empty),empty),validkey(dhexp_real(key_e(alice,bob,sid_5),g))),encrypt(empty,minnonce,hash(hash(hash(somename,empty),empty),validkey(dhexp_real(key_e(alice,bob,sid_5),g))),msg_a(alice,bob,sid_5))),validkey(dhexp_real(key_e(bob,charlie,sid_6),g))),validkey(dhexp_real(key_s(bob),g)))),validkey(dhexp_real(key_m(bob),g)))),msg_b(bob,charlie,sid_6))) that may be sent on channel pub by 6 may be received at input {102}.
So event RecvMsg(alice,bob,stagepack_b(sid_5),msg_b(bob,charlie,sid_6)) may be executed at {326}.
end(RecvMsg(alice,bob,stagepack_b(sid_5),msg_b(bob,charlie,sid_6))).

8. By 7, end(RecvMsg(alice,bob,stagepack_b(sid_5),msg_b(bob,charlie,sid_6))).
The goal is reached, represented in the following fact:
end(RecvMsg(alice,bob,stagepack_b(sid_5),msg_b(bob,charlie,sid_6))).


RESULT event(RecvMsg(alice,bob,stagepack_b(sid_a),m_28)) ==> event(SendMsg(bob,alice,stagepack_b(sid_b),m_28)) || (event(LeakS(phase0,bob)) && event(LeakM(phase0,bob))) cannot be proved.
Starting query not attacker_p1(msg_b(bob,alice,sid_b))
RESULT not attacker_p1(msg_b(bob,alice,sid_b)) is true.
Starting query attacker_p1(msg_b(bob,alice,sid_b)) ==> event(LeakS(px,alice)) && event(LeakM(px,alice))
RESULT attacker_p1(msg_b(bob,alice,sid_b)) ==> event(LeakS(px,alice)) && event(LeakM(px,alice)) is true.
Starting query attacker_p1(msg_b(bob,alice,sid_b)) ==> (event(LeakS(phase0,alice)) && event(LeakM(phase0,alice))) || (event(LeakS(px,alice)) && event(LeakM(px,alice)) && event(LeakS(pz,bob)) && event(LeakM(pz,bob)))
RESULT attacker_p1(msg_b(bob,alice,sid_b)) ==> (event(LeakS(phase0,alice)) && event(LeakM(phase0,alice))) || (event(LeakS(px,alice)) && event(LeakM(px,alice)) && event(LeakS(pz,bob)) && event(LeakM(pz,bob))) is true.
Starting query attacker_p1(msg_b(bob,alice,sid_b)) ==> event(LeakS(phase0,alice)) && event(LeakM(phase0,alice))
RESULT attacker_p1(msg_b(bob,alice,sid_b)) ==> event(LeakS(phase0,alice)) && event(LeakM(phase0,alice)) is true.
Starting query event(RecvMsg(bob,alice,stagepack_c(sid_b),m_28)) ==> event(SendMsg(alice,bob,stagepack_c(sid_a),m_28))
RESULT event(RecvMsg(bob,alice,stagepack_c(sid_b),m_28)) ==> event(SendMsg(alice,bob,stagepack_c(sid_a),m_28)) is true.
Starting query event(RecvMsg(bob,alice,stagepack_c(sid_b),m_28)) ==> event(SendMsg(alice,c,stagepack_c(sid_a),m_28)) || (event(LeakS(phase0,alice)) && event(LeakM(phase0,alice))) || (event(LeakS(phase0,bob)) && event(LeakM(phase0,bob)))
RESULT event(RecvMsg(bob,alice,stagepack_c(sid_b),m_28)) ==> event(SendMsg(alice,c,stagepack_c(sid_a),m_28)) || (event(LeakS(phase0,alice)) && event(LeakM(phase0,alice))) || (event(LeakS(phase0,bob)) && event(LeakM(phase0,bob))) is true.
Starting query event(RecvMsg(bob,alice,stagepack_c(sid_b),m_28)) ==> event(SendMsg(alice,c,stagepack_c(sid_a),m_28)) || (event(LeakS(phase0,alice)) && event(LeakM(phase0,alice)))
RESULT event(RecvMsg(bob,alice,stagepack_c(sid_b),m_28)) ==> event(SendMsg(alice,c,stagepack_c(sid_a),m_28)) || (event(LeakS(phase0,alice)) && event(LeakM(phase0,alice))) is true.
Starting query event(RecvMsg(bob,alice,stagepack_c(sid_b),m_28)) ==> event(SendMsg(alice,bob,stagepack_c(sid_a),m_28)) || (event(LeakS(phase0,alice)) && event(LeakM(phase0,alice))) || (event(LeakS(phase0,bob)) && event(LeakM(phase0,bob)))
RESULT event(RecvMsg(bob,alice,stagepack_c(sid_b),m_28)) ==> event(SendMsg(alice,bob,stagepack_c(sid_a),m_28)) || (event(LeakS(phase0,alice)) && event(LeakM(phase0,alice))) || (event(LeakS(phase0,bob)) && event(LeakM(phase0,bob))) is true.
Starting query event(RecvMsg(bob,alice,stagepack_c(sid_b),m_28)) ==> event(SendMsg(alice,bob,stagepack_c(sid_a),m_28)) || (event(LeakS(phase0,alice)) && event(LeakM(phase0,alice)))
RESULT event(RecvMsg(bob,alice,stagepack_c(sid_b),m_28)) ==> event(SendMsg(alice,bob,stagepack_c(sid_a),m_28)) || (event(LeakS(phase0,alice)) && event(LeakM(phase0,alice))) is true.
Starting query not attacker_p1(msg_c(alice,bob,sid_a))
RESULT not attacker_p1(msg_c(alice,bob,sid_a)) is true.
Starting query attacker_p1(msg_c(alice,bob,sid_a)) ==> event(LeakS(px,bob)) && event(LeakM(px,bob))
RESULT attacker_p1(msg_c(alice,bob,sid_a)) ==> event(LeakS(px,bob)) && event(LeakM(px,bob)) is true.
Starting query attacker_p1(msg_c(alice,bob,sid_a)) ==> event(LeakS(phase0,bob)) || (event(LeakS(px,bob)) && event(LeakM(px,bob)) && event(LeakS(pz,alice)) && event(LeakM(pz,alice)))
RESULT attacker_p1(msg_c(alice,bob,sid_a)) ==> event(LeakS(phase0,bob)) || (event(LeakS(px,bob)) && event(LeakM(px,bob)) && event(LeakS(pz,alice)) && event(LeakM(pz,alice))) is true.
Starting query attacker_p1(msg_c(alice,bob,sid_a)) ==> event(LeakS(phase0,bob)) && event(LeakM(phase0,bob))
RESULT attacker_p1(msg_c(alice,bob,sid_a)) ==> event(LeakS(phase0,bob)) && event(LeakM(phase0,bob)) is true.
Starting query event(RecvMsg(alice,bob,stagepack_d(sid_a),m_28)) ==> event(SendMsg(bob,alice,stagepack_d(sid_b),m_28))
RESULT event(RecvMsg(alice,bob,stagepack_d(sid_a),m_28)) ==> event(SendMsg(bob,alice,stagepack_d(sid_b),m_28)) is true.
Starting query event(RecvMsg(alice,bob,stagepack_d(sid_a),m_28)) ==> event(SendMsg(bob,c,stagepack_d(sid_b),m_28)) || (event(LeakS(phase0,bob)) && event(LeakM(phase0,bob))) || (event(LeakS(phase0,alice)) && event(LeakM(phase0,alice)))
RESULT event(RecvMsg(alice,bob,stagepack_d(sid_a),m_28)) ==> event(SendMsg(bob,c,stagepack_d(sid_b),m_28)) || (event(LeakS(phase0,bob)) && event(LeakM(phase0,bob))) || (event(LeakS(phase0,alice)) && event(LeakM(phase0,alice))) is true.
Starting query event(RecvMsg(alice,bob,stagepack_d(sid_a),m_28)) ==> event(SendMsg(bob,c,stagepack_d(sid_b),m_28)) || (event(LeakS(phase0,bob)) && event(LeakM(phase0,bob)))
RESULT event(RecvMsg(alice,bob,stagepack_d(sid_a),m_28)) ==> event(SendMsg(bob,c,stagepack_d(sid_b),m_28)) || (event(LeakS(phase0,bob)) && event(LeakM(phase0,bob))) is true.
Starting query event(RecvMsg(alice,bob,stagepack_d(sid_a),m_28)) ==> event(SendMsg(bob,alice,stagepack_d(sid_b),m_28)) || (event(LeakS(phase0,bob)) && event(LeakM(phase0,bob))) || (event(LeakS(phase0,alice)) && event(LeakM(phase0,alice)))
RESULT event(RecvMsg(alice,bob,stagepack_d(sid_a),m_28)) ==> event(SendMsg(bob,alice,stagepack_d(sid_b),m_28)) || (event(LeakS(phase0,bob)) && event(LeakM(phase0,bob))) || (event(LeakS(phase0,alice)) && event(LeakM(phase0,alice))) is true.
Starting query event(RecvMsg(alice,bob,stagepack_d(sid_a),m_28)) ==> event(SendMsg(bob,alice,stagepack_d(sid_b),m_28)) || (event(LeakS(phase0,bob)) && event(LeakM(phase0,bob)))
RESULT event(RecvMsg(alice,bob,stagepack_d(sid_a),m_28)) ==> event(SendMsg(bob,alice,stagepack_d(sid_b),m_28)) || (event(LeakS(phase0,bob)) && event(LeakM(phase0,bob))) is true.
Starting query not attacker_p1(msg_d(bob,alice,sid_b))
RESULT not attacker_p1(msg_d(bob,alice,sid_b)) is true.
Starting query attacker_p1(msg_d(bob,alice,sid_b)) ==> event(LeakS(px,alice)) && event(LeakM(px,alice))
RESULT attacker_p1(msg_d(bob,alice,sid_b)) ==> event(LeakS(px,alice)) && event(LeakM(px,alice)) is true.
Starting query attacker_p1(msg_d(bob,alice,sid_b)) ==> (event(LeakS(phase0,alice)) && event(LeakM(phase0,alice))) || (event(LeakS(px,alice)) && event(LeakM(px,alice)) && event(LeakS(pz,bob)) && event(LeakM(pz,bob)))
RESULT attacker_p1(msg_d(bob,alice,sid_b)) ==> (event(LeakS(phase0,alice)) && event(LeakM(phase0,alice))) || (event(LeakS(px,alice)) && event(LeakM(px,alice)) && event(LeakS(pz,bob)) && event(LeakM(pz,bob))) is true.
Starting query attacker_p1(msg_d(bob,alice,sid_b)) ==> event(LeakS(phase0,alice)) && event(LeakM(phase0,alice))
RESULT attacker_p1(msg_d(bob,alice,sid_b)) ==> event(LeakS(phase0,alice)) && event(LeakM(phase0,alice)) is true.
Starting query event(RecvMsg(bob,alice,stagepack_e(sid_b),m_28)) ==> event(SendMsg(alice,bob,stagepack_e(sid_a),m_28))
RESULT event(RecvMsg(bob,alice,stagepack_e(sid_b),m_28)) ==> event(SendMsg(alice,bob,stagepack_e(sid_a),m_28)) is true.
Starting query event(RecvMsg(bob,alice,stagepack_e(sid_b),m_28)) ==> event(SendMsg(alice,c,stagepack_e(sid_a),m_28)) || (event(LeakS(phase0,alice)) && event(LeakM(phase0,alice))) || (event(LeakS(phase0,bob)) && event(LeakM(phase0,bob)))
RESULT event(RecvMsg(bob,alice,stagepack_e(sid_b),m_28)) ==> event(SendMsg(alice,c,stagepack_e(sid_a),m_28)) || (event(LeakS(phase0,alice)) && event(LeakM(phase0,alice))) || (event(LeakS(phase0,bob)) && event(LeakM(phase0,bob))) is true.
Starting query event(RecvMsg(bob,alice,stagepack_e(sid_b),m_28)) ==> event(SendMsg(alice,c,stagepack_e(sid_a),m_28)) || (event(LeakS(phase0,alice)) && event(LeakM(phase0,alice)))
RESULT event(RecvMsg(bob,alice,stagepack_e(sid_b),m_28)) ==> event(SendMsg(alice,c,stagepack_e(sid_a),m_28)) || (event(LeakS(phase0,alice)) && event(LeakM(phase0,alice))) is true.
Starting query event(RecvMsg(bob,alice,stagepack_e(sid_b),m_28)) ==> event(SendMsg(alice,bob,stagepack_e(sid_a),m_28)) || (event(LeakS(phase0,alice)) && event(LeakM(phase0,alice))) || (event(LeakS(phase0,bob)) && event(LeakM(phase0,bob)))
RESULT event(RecvMsg(bob,alice,stagepack_e(sid_b),m_28)) ==> event(SendMsg(alice,bob,stagepack_e(sid_a),m_28)) || (event(LeakS(phase0,alice)) && event(LeakM(phase0,alice))) || (event(LeakS(phase0,bob)) && event(LeakM(phase0,bob))) is true.
Starting query event(RecvMsg(bob,alice,stagepack_e(sid_b),m_28)) ==> event(SendMsg(alice,bob,stagepack_e(sid_a),m_28)) || (event(LeakS(phase0,alice)) && event(LeakM(phase0,alice)))
RESULT event(RecvMsg(bob,alice,stagepack_e(sid_b),m_28)) ==> event(SendMsg(alice,bob,stagepack_e(sid_a),m_28)) || (event(LeakS(phase0,alice)) && event(LeakM(phase0,alice))) is true.
Starting query not attacker_p1(msg_e(alice,bob,sid_a))
RESULT not attacker_p1(msg_e(alice,bob,sid_a)) is true.
Starting query attacker_p1(msg_e(alice,bob,sid_a)) ==> event(LeakS(px,bob)) && event(LeakM(px,bob))
RESULT attacker_p1(msg_e(alice,bob,sid_a)) ==> event(LeakS(px,bob)) && event(LeakM(px,bob)) is true.
Starting query attacker_p1(msg_e(alice,bob,sid_a)) ==> (event(LeakS(phase0,bob)) && event(LeakM(phase0,bob))) || (event(LeakS(px,bob)) && event(LeakM(px,bob)) && event(LeakS(pz,alice)) && event(LeakM(pz,alice)))
RESULT attacker_p1(msg_e(alice,bob,sid_a)) ==> (event(LeakS(phase0,bob)) && event(LeakM(phase0,bob))) || (event(LeakS(px,bob)) && event(LeakM(px,bob)) && event(LeakS(pz,alice)) && event(LeakM(pz,alice))) is true.
Starting query attacker_p1(msg_e(alice,bob,sid_a)) ==> event(LeakS(phase0,bob)) && event(LeakM(phase0,bob))
RESULT attacker_p1(msg_e(alice,bob,sid_a)) ==> event(LeakS(phase0,bob)) && event(LeakM(phase0,bob)) is true.
Starting query not event(RecvEnd(true))
RESULT not event(RecvEnd(true)) is true.

--------------------------------------------------------------
Verification summary:

Query event(RecvMsg(bob,alice,stagepack_a(sid_b),m_28)) ==> event(SendMsg(alice,bob,stagepack_a(sid_a),m_28)) cannot be proved.

Query event(RecvMsg(bob,alice,stagepack_a(sid_b),m_28)) ==> event(SendMsg(alice,c,stagepack_a(sid_a),m_28)) || (event(LeakS(phase0,alice)) && event(LeakM(phase0,alice))) || (event(LeakS(phase0,bob)) && event(LeakM(phase0,bob))) is true.

Query event(RecvMsg(bob,alice,stagepack_a(sid_b),m_28)) ==> event(SendMsg(alice,c,stagepack_a(sid_a),m_28)) || (event(LeakS(phase0,alice)) && event(LeakM(phase0,alice))) is true.

Query event(RecvMsg(bob,alice,stagepack_a(sid_b),m_28)) ==> event(SendMsg(alice,bob,stagepack_a(sid_a),m_28)) || (event(LeakS(phase0,alice)) && event(LeakM(phase0,alice))) || (event(LeakS(phase0,bob)) && event(LeakM(phase0,bob))) cannot be proved.

Query event(RecvMsg(bob,alice,stagepack_a(sid_b),m_28)) ==> event(SendMsg(alice,bob,stagepack_a(sid_a),m_28)) || (event(LeakS(phase0,alice)) && event(LeakM(phase0,alice))) cannot be proved.

Query not attacker_p1(msg_a(alice,bob,sid_a)) cannot be proved.

Query attacker_p1(msg_a(alice,bob,sid_a)) ==> event(LeakS(px,bob)) && event(LeakM(px,bob)) cannot be proved.

Query attacker_p1(msg_a(alice,bob,sid_a)) ==> event(LeakS(phase0,bob)) || (event(LeakS(px,bob)) && event(LeakM(px,bob)) && event(LeakS(pz,alice)) && event(LeakM(pz,alice))) cannot be proved.

Query attacker_p1(msg_a(alice,bob,sid_a)) ==> event(LeakS(phase0,bob)) && event(LeakM(phase0,bob)) cannot be proved.

Query event(RecvMsg(alice,bob,stagepack_b(sid_a),m_28)) ==> event(SendMsg(bob,alice,stagepack_b(sid_b),m_28)) cannot be proved.

Query event(RecvMsg(alice,bob,stagepack_b(sid_a),m_28)) ==> event(SendMsg(bob,c,stagepack_b(sid_b),m_28)) || (event(LeakS(phase0,bob)) && event(LeakM(phase0,bob))) || (event(LeakS(phase0,alice)) && event(LeakM(phase0,alice))) is true.

Query event(RecvMsg(alice,bob,stagepack_b(sid_a),m_28)) ==> event(SendMsg(bob,c,stagepack_b(sid_b),m_28)) || (event(LeakS(phase0,bob)) && event(LeakM(phase0,bob))) is true.

Query event(RecvMsg(alice,bob,stagepack_b(sid_a),m_28)) ==> event(SendMsg(bob,alice,stagepack_b(sid_b),m_28)) || (event(LeakS(phase0,bob)) && event(LeakM(phase0,bob))) || (event(LeakS(phase0,alice)) && event(LeakM(phase0,alice))) cannot be proved.

Query event(RecvMsg(alice,bob,stagepack_b(sid_a),m_28)) ==> event(SendMsg(bob,alice,stagepack_b(sid_b),m_28)) || (event(LeakS(phase0,bob)) && event(LeakM(phase0,bob))) cannot be proved.

Query not attacker_p1(msg_b(bob,alice,sid_b)) is true.

Query attacker_p1(msg_b(bob,alice,sid_b)) ==> event(LeakS(px,alice)) && event(LeakM(px,alice)) is true.

Query attacker_p1(msg_b(bob,alice,sid_b)) ==> (event(LeakS(phase0,alice)) && event(LeakM(phase0,alice))) || (event(LeakS(px,alice)) && event(LeakM(px,alice)) && event(LeakS(pz,bob)) && event(LeakM(pz,bob))) is true.

Query attacker_p1(msg_b(bob,alice,sid_b)) ==> event(LeakS(phase0,alice)) && event(LeakM(phase0,alice)) is true.

Query event(RecvMsg(bob,alice,stagepack_c(sid_b),m_28)) ==> event(SendMsg(alice,bob,stagepack_c(sid_a),m_28)) is true.

Query event(RecvMsg(bob,alice,stagepack_c(sid_b),m_28)) ==> event(SendMsg(alice,c,stagepack_c(sid_a),m_28)) || (event(LeakS(phase0,alice)) && event(LeakM(phase0,alice))) || (event(LeakS(phase0,bob)) && event(LeakM(phase0,bob))) is true.

Query event(RecvMsg(bob,alice,stagepack_c(sid_b),m_28)) ==> event(SendMsg(alice,c,stagepack_c(sid_a),m_28)) || (event(LeakS(phase0,alice)) && event(LeakM(phase0,alice))) is true.

Query event(RecvMsg(bob,alice,stagepack_c(sid_b),m_28)) ==> event(SendMsg(alice,bob,stagepack_c(sid_a),m_28)) || (event(LeakS(phase0,alice)) && event(LeakM(phase0,alice))) || (event(LeakS(phase0,bob)) && event(LeakM(phase0,bob))) is true.

Query event(RecvMsg(bob,alice,stagepack_c(sid_b),m_28)) ==> event(SendMsg(alice,bob,stagepack_c(sid_a),m_28)) || (event(LeakS(phase0,alice)) && event(LeakM(phase0,alice))) is true.

Query not attacker_p1(msg_c(alice,bob,sid_a)) is true.

Query attacker_p1(msg_c(alice,bob,sid_a)) ==> event(LeakS(px,bob)) && event(LeakM(px,bob)) is true.

Query attacker_p1(msg_c(alice,bob,sid_a)) ==> event(LeakS(phase0,bob)) || (event(LeakS(px,bob)) && event(LeakM(px,bob)) && event(LeakS(pz,alice)) && event(LeakM(pz,alice))) is true.

Query attacker_p1(msg_c(alice,bob,sid_a)) ==> event(LeakS(phase0,bob)) && event(LeakM(phase0,bob)) is true.

Query event(RecvMsg(alice,bob,stagepack_d(sid_a),m_28)) ==> event(SendMsg(bob,alice,stagepack_d(sid_b),m_28)) is true.

Query event(RecvMsg(alice,bob,stagepack_d(sid_a),m_28)) ==> event(SendMsg(bob,c,stagepack_d(sid_b),m_28)) || (event(LeakS(phase0,bob)) && event(LeakM(phase0,bob))) || (event(LeakS(phase0,alice)) && event(LeakM(phase0,alice))) is true.

Query event(RecvMsg(alice,bob,stagepack_d(sid_a),m_28)) ==> event(SendMsg(bob,c,stagepack_d(sid_b),m_28)) || (event(LeakS(phase0,bob)) && event(LeakM(phase0,bob))) is true.

Query event(RecvMsg(alice,bob,stagepack_d(sid_a),m_28)) ==> event(SendMsg(bob,alice,stagepack_d(sid_b),m_28)) || (event(LeakS(phase0,bob)) && event(LeakM(phase0,bob))) || (event(LeakS(phase0,alice)) && event(LeakM(phase0,alice))) is true.

Query event(RecvMsg(alice,bob,stagepack_d(sid_a),m_28)) ==> event(SendMsg(bob,alice,stagepack_d(sid_b),m_28)) || (event(LeakS(phase0,bob)) && event(LeakM(phase0,bob))) is true.

Query not attacker_p1(msg_d(bob,alice,sid_b)) is true.

Query attacker_p1(msg_d(bob,alice,sid_b)) ==> event(LeakS(px,alice)) && event(LeakM(px,alice)) is true.

Query attacker_p1(msg_d(bob,alice,sid_b)) ==> (event(LeakS(phase0,alice)) && event(LeakM(phase0,alice))) || (event(LeakS(px,alice)) && event(LeakM(px,alice)) && event(LeakS(pz,bob)) && event(LeakM(pz,bob))) is true.

Query attacker_p1(msg_d(bob,alice,sid_b)) ==> event(LeakS(phase0,alice)) && event(LeakM(phase0,alice)) is true.

Query event(RecvMsg(bob,alice,stagepack_e(sid_b),m_28)) ==> event(SendMsg(alice,bob,stagepack_e(sid_a),m_28)) is true.

Query event(RecvMsg(bob,alice,stagepack_e(sid_b),m_28)) ==> event(SendMsg(alice,c,stagepack_e(sid_a),m_28)) || (event(LeakS(phase0,alice)) && event(LeakM(phase0,alice))) || (event(LeakS(phase0,bob)) && event(LeakM(phase0,bob))) is true.

Query event(RecvMsg(bob,alice,stagepack_e(sid_b),m_28)) ==> event(SendMsg(alice,c,stagepack_e(sid_a),m_28)) || (event(LeakS(phase0,alice)) && event(LeakM(phase0,alice))) is true.

Query event(RecvMsg(bob,alice,stagepack_e(sid_b),m_28)) ==> event(SendMsg(alice,bob,stagepack_e(sid_a),m_28)) || (event(LeakS(phase0,alice)) && event(LeakM(phase0,alice))) || (event(LeakS(phase0,bob)) && event(LeakM(phase0,bob))) is true.

Query event(RecvMsg(bob,alice,stagepack_e(sid_b),m_28)) ==> event(SendMsg(alice,bob,stagepack_e(sid_a),m_28)) || (event(LeakS(phase0,alice)) && event(LeakM(phase0,alice))) is true.

Query not attacker_p1(msg_e(alice,bob,sid_a)) is true.

Query attacker_p1(msg_e(alice,bob,sid_a)) ==> event(LeakS(px,bob)) && event(LeakM(px,bob)) is true.

Query attacker_p1(msg_e(alice,bob,sid_a)) ==> (event(LeakS(phase0,bob)) && event(LeakM(phase0,bob))) || (event(LeakS(px,bob)) && event(LeakM(px,bob)) && event(LeakS(pz,alice)) && event(LeakM(pz,alice))) is true.

Query attacker_p1(msg_e(alice,bob,sid_a)) ==> event(LeakS(phase0,bob)) && event(LeakM(phase0,bob)) is true.

Query not event(RecvEnd(true)) is true.

--------------------------------------------------------------


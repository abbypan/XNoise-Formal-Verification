File "pv/IX-I'X'.xnoise.passive.pv", line 5, characters 5-24:
Warning: Setting expandIfTermsToTerms is deprecated.
File "pv/IX-I'X'.xnoise.passive.pv", line 223, characters 7-8:
Warning: identifier ck rebound.
File "pv/IX-I'X'.xnoise.passive.pv", line 232, characters 7-8:
Warning: identifier ck rebound.
File "pv/IX-I'X'.xnoise.passive.pv", line 233, characters 7-8:
Warning: identifier cs rebound.
File "pv/IX-I'X'.xnoise.passive.pv", line 233, character 36:
Warning: identifier h rebound.
File "pv/IX-I'X'.xnoise.passive.pv", line 272, character 6:
Warning: identifier e rebound.
File "pv/IX-I'X'.xnoise.passive.pv", line 273, characters 6-7:
Warning: identifier ne rebound.
File "pv/IX-I'X'.xnoise.passive.pv", line 274, characters 6-7:
Warning: identifier ss rebound.
File "pv/IX-I'X'.xnoise.passive.pv", line 277, character 6:
Warning: identifier s rebound.
File "pv/IX-I'X'.xnoise.passive.pv", line 278, characters 7-8:
Warning: identifier ss rebound.
File "pv/IX-I'X'.xnoise.passive.pv", line 278, characters 26-27:
Warning: identifier ns rebound.
File "pv/IX-I'X'.xnoise.passive.pv", line 280, character 6:
Warning: identifier m rebound.
File "pv/IX-I'X'.xnoise.passive.pv", line 281, characters 7-8:
Warning: identifier ss rebound.
File "pv/IX-I'X'.xnoise.passive.pv", line 281, characters 26-27:
Warning: identifier nm rebound.
File "pv/IX-I'X'.xnoise.passive.pv", line 283, characters 7-8:
Warning: identifier ss rebound.
File "pv/IX-I'X'.xnoise.passive.pv", line 283, characters 26-35:
Warning: identifier ciphertext rebound.
File "pv/IX-I'X'.xnoise.passive.pv", line 284, characters 6-7:
Warning: identifier hs rebound.
File "pv/IX-I'X'.xnoise.passive.pv", line 291, character 6:
Warning: identifier e rebound.
File "pv/IX-I'X'.xnoise.passive.pv", line 292, characters 6-7:
Warning: identifier ne rebound.
File "pv/IX-I'X'.xnoise.passive.pv", line 293, characters 6-7:
Warning: identifier ss rebound.
File "pv/IX-I'X'.xnoise.passive.pv", line 295, characters 6-7:
Warning: identifier ss rebound.
File "pv/IX-I'X'.xnoise.passive.pv", line 296, characters 6-7:
Warning: identifier ss rebound.
File "pv/IX-I'X'.xnoise.passive.pv", line 297, characters 6-7:
Warning: identifier ss rebound.
File "pv/IX-I'X'.xnoise.passive.pv", line 299, character 6:
Warning: identifier s rebound.
File "pv/IX-I'X'.xnoise.passive.pv", line 300, characters 7-8:
Warning: identifier ss rebound.
File "pv/IX-I'X'.xnoise.passive.pv", line 300, characters 26-27:
Warning: identifier ns rebound.
File "pv/IX-I'X'.xnoise.passive.pv", line 301, character 6:
Warning: identifier m rebound.
File "pv/IX-I'X'.xnoise.passive.pv", line 302, characters 7-8:
Warning: identifier ss rebound.
File "pv/IX-I'X'.xnoise.passive.pv", line 302, characters 26-27:
Warning: identifier nm rebound.
File "pv/IX-I'X'.xnoise.passive.pv", line 304, characters 6-7:
Warning: identifier ss rebound.
File "pv/IX-I'X'.xnoise.passive.pv", line 305, characters 7-8:
Warning: identifier ss rebound.
File "pv/IX-I'X'.xnoise.passive.pv", line 305, characters 26-35:
Warning: identifier ciphertext rebound.
File "pv/IX-I'X'.xnoise.passive.pv", line 306, characters 6-7:
Warning: identifier ss rebound.
File "pv/IX-I'X'.xnoise.passive.pv", line 307, characters 7-8:
Warning: identifier ss rebound.
File "pv/IX-I'X'.xnoise.passive.pv", line 307, characters 26-35:
Warning: identifier ciphertext rebound.
File "pv/IX-I'X'.xnoise.passive.pv", line 309, characters 6-7:
Warning: identifier hs rebound.
File "pv/IX-I'X'.xnoise.passive.pv", line 317, characters 7-8:
Warning: identifier ss rebound.
File "pv/IX-I'X'.xnoise.passive.pv", line 317, characters 26-35:
Warning: identifier ciphertext rebound.
File "pv/IX-I'X'.xnoise.passive.pv", line 318, characters 6-7:
Warning: identifier hs rebound.
File "pv/IX-I'X'.xnoise.passive.pv", line 325, characters 7-8:
Warning: identifier ss rebound.
File "pv/IX-I'X'.xnoise.passive.pv", line 325, characters 26-35:
Warning: identifier ciphertext rebound.
File "pv/IX-I'X'.xnoise.passive.pv", line 326, characters 6-7:
Warning: identifier hs rebound.
File "pv/IX-I'X'.xnoise.passive.pv", line 335, characters 6-7:
Warning: identifier re rebound.
File "pv/IX-I'X'.xnoise.passive.pv", line 336, characters 6-7:
Warning: identifier ss rebound.
File "pv/IX-I'X'.xnoise.passive.pv", line 339, characters 7-8:
Warning: identifier ss rebound.
File "pv/IX-I'X'.xnoise.passive.pv", line 339, characters 26-27:
Warning: identifier ne rebound.
File "pv/IX-I'X'.xnoise.passive.pv", line 339, characters 40-45:
Warning: identifier valid1 rebound.
File "pv/IX-I'X'.xnoise.passive.pv", line 340, characters 6-7:
Warning: identifier rs rebound.
File "pv/IX-I'X'.xnoise.passive.pv", line 341, characters 7-8:
Warning: identifier ss rebound.
File "pv/IX-I'X'.xnoise.passive.pv", line 341, characters 26-27:
Warning: identifier ne rebound.
File "pv/IX-I'X'.xnoise.passive.pv", line 341, characters 40-45:
Warning: identifier valid2 rebound.
File "pv/IX-I'X'.xnoise.passive.pv", line 342, characters 6-7:
Warning: identifier rm rebound.
File "pv/IX-I'X'.xnoise.passive.pv", line 344, characters 7-8:
Warning: identifier ss rebound.
File "pv/IX-I'X'.xnoise.passive.pv", line 350, characters 7-8:
Warning: identifier hs rebound.
File "pv/IX-I'X'.xnoise.passive.pv", line 359, characters 6-7:
Warning: identifier re rebound.
File "pv/IX-I'X'.xnoise.passive.pv", line 360, characters 6-7:
Warning: identifier ss rebound.
File "pv/IX-I'X'.xnoise.passive.pv", line 362, characters 6-7:
Warning: identifier ss rebound.
File "pv/IX-I'X'.xnoise.passive.pv", line 363, characters 6-7:
Warning: identifier ss rebound.
File "pv/IX-I'X'.xnoise.passive.pv", line 364, characters 6-7:
Warning: identifier ss rebound.
File "pv/IX-I'X'.xnoise.passive.pv", line 366, characters 7-8:
Warning: identifier ss rebound.
File "pv/IX-I'X'.xnoise.passive.pv", line 366, characters 26-27:
Warning: identifier ne rebound.
File "pv/IX-I'X'.xnoise.passive.pv", line 366, characters 40-45:
Warning: identifier valid1 rebound.
File "pv/IX-I'X'.xnoise.passive.pv", line 367, characters 6-7:
Warning: identifier rs rebound.
File "pv/IX-I'X'.xnoise.passive.pv", line 368, characters 7-8:
Warning: identifier ss rebound.
File "pv/IX-I'X'.xnoise.passive.pv", line 368, characters 26-27:
Warning: identifier ne rebound.
File "pv/IX-I'X'.xnoise.passive.pv", line 368, characters 40-45:
Warning: identifier valid2 rebound.
File "pv/IX-I'X'.xnoise.passive.pv", line 369, characters 6-7:
Warning: identifier rm rebound.
File "pv/IX-I'X'.xnoise.passive.pv", line 371, characters 6-7:
Warning: identifier ss rebound.
File "pv/IX-I'X'.xnoise.passive.pv", line 372, characters 6-7:
Warning: identifier ss rebound.
File "pv/IX-I'X'.xnoise.passive.pv", line 373, characters 7-8:
Warning: identifier ss rebound.
File "pv/IX-I'X'.xnoise.passive.pv", line 379, characters 7-8:
Warning: identifier hs rebound.
File "pv/IX-I'X'.xnoise.passive.pv", line 388, characters 7-8:
Warning: identifier ss rebound.
File "pv/IX-I'X'.xnoise.passive.pv", line 390, characters 7-8:
Warning: identifier hs rebound.
File "pv/IX-I'X'.xnoise.passive.pv", line 398, characters 7-8:
Warning: identifier ss rebound.
File "pv/IX-I'X'.xnoise.passive.pv", line 400, characters 7-8:
Warning: identifier hs rebound.
File "pv/IX-I'X'.xnoise.passive.pv", line 557, characters 7-8:
Warning: identifier hs rebound.
File "pv/IX-I'X'.xnoise.passive.pv", line 559, characters 8-9:
Warning: identifier hs rebound.
File "pv/IX-I'X'.xnoise.passive.pv", line 550, characters 7-8:
Warning: identifier hs rebound.
File "pv/IX-I'X'.xnoise.passive.pv", line 551, characters 8-9:
Warning: identifier hs rebound.
File "pv/IX-I'X'.xnoise.passive.pv", line 544, characters 8-9:
Warning: identifier hs rebound.
File "pv/IX-I'X'.xnoise.passive.pv", line 537, characters 8-9:
Warning: identifier hs rebound.
File "pv/IX-I'X'.xnoise.passive.pv", line 608, characters 7-8:
Warning: identifier hs rebound.
File "pv/IX-I'X'.xnoise.passive.pv", line 609, characters 8-9:
Warning: identifier hs rebound.
File "pv/IX-I'X'.xnoise.passive.pv", line 600, characters 7-8:
Warning: identifier hs rebound.
File "pv/IX-I'X'.xnoise.passive.pv", line 602, characters 8-9:
Warning: identifier hs rebound.
File "pv/IX-I'X'.xnoise.passive.pv", line 594, characters 8-9:
Warning: identifier hs rebound.
File "pv/IX-I'X'.xnoise.passive.pv", line 588, characters 8-9:
Warning: identifier hs rebound.
Linear part:
dhexp_real(b,dhexp_real(a,g)) = dhexp_real(a,dhexp_real(b,g))
Completing equations...
Completed equations:
dhexp_real(b,dhexp_real(a,g)) = dhexp_real(a,dhexp_real(b,g))
Convergent part: No equation.
Process 0 (that is, the initial process):
{1}out(pub, (key_s(charlie),key_m(charlie)));
{2}!
{3}new sid: sessionid;
(
    {4}let me: principal = alice in
    {5}let them: principal = bob in
    {6}let sid_1: sessionid = sid in
    {7}let s: keypair = keypairpack(empty,empty) in
    {8}let m: keypair = keypairpack(empty,empty) in
    {9}out(pub, (getpublickey(s),getpublickey(m)));
    (
        {10}let e: keypair = keypairpack(empty,empty) in
        {11}let rs: key = empty in
        {12}let rm: key = empty in
        {13}let re: key = empty in
        {14}let prologue: bitstring = empty in
        {15}let psk: key = empty in
        {16}let protocol_name: bitstring = somename in
        {17}let h: bitstring = hash(protocol_name,empty) in
        {18}let ck: key = h in
        {19}let k: key = empty in
        {20}let cs: cipherstate = cipherstatepack(k,minnonce) in
        {21}let ss: symmetricstate = symmetricstatepack(cs,ck,h) in
        {22}let v: bitstring = catch-fail(symmetricstateunpack(ss)) in
        {23}let v_1: bool = (not-caught-fail(v) && success?(1-proj-3-tuple(v))) in
        {24}let h_1: bitstring = (if v_1 then 3-proj-3-tuple(v) else caught-fail) in
        {25}let ck_1: key = (if v_1 then 2-proj-3-tuple(v) else caught-fail) in
        {26}let cs_1: cipherstate = (if v_1 then 1-proj-3-tuple(v) else caught-fail) in
        {27}let ss_1: symmetricstate = catch-fail((if v_1 then symmetricstatepack(cs_1,ck_1,hash(h_1,prologue)) else fail-any)) in
        {28}let v_2: bool = not-caught-fail(ss_1) in
        {29}let hs: handshakestate = (if v_2 then handshakestatepack(ss_1,s,m,e,rs,rm,re,psk,true) else fail-any) in
        {30}insert statestore(me,them,sid_1,statepack_a(hs))
    ) | (
        {182}get statestore(=me,=them,=sid_1,statepack_a(hs_1: handshakestate)) in
        {31}let payload: bitstring = msg_a(me,them,sid_1) in
        {32}let v_3: bitstring = catch-fail(handshakestateunpack(hs_1)) in
        {33}let v_4: bool = (not-caught-fail(v_3) && success?(1-proj-9-tuple(v_3))) in
        {34}let initiator_1: bool = (if v_4 then 9-proj-9-tuple(v_3) else caught-fail) in
        {35}let psk_1: key = (if v_4 then 8-proj-9-tuple(v_3) else caught-fail) in
        {36}let re_1: key = (if v_4 then 7-proj-9-tuple(v_3) else caught-fail) in
        {37}let rm_1: key = (if v_4 then 6-proj-9-tuple(v_3) else caught-fail) in
        {38}let rs_1: key = (if v_4 then 5-proj-9-tuple(v_3) else caught-fail) in
        {39}let e_1: keypair = (if v_4 then 4-proj-9-tuple(v_3) else caught-fail) in
        {40}let m_1: keypair = (if v_4 then 3-proj-9-tuple(v_3) else caught-fail) in
        {41}let s_1: keypair = (if v_4 then 2-proj-9-tuple(v_3) else caught-fail) in
        {42}let ss_2: symmetricstate = (if v_4 then 1-proj-9-tuple(v_3) else caught-fail) in
        {43}let v_5: bitstring = (if v_4 then catch-fail((empty,empty,empty,empty)) else caught-fail) in
        {44}let v_6: bool = (not-caught-fail(v_5) && success?(1-proj-4-tuple(v_5))) in
        {45}let ciphertext: bitstring = (if v_6 then 4-proj-4-tuple(v_5) else caught-fail) in
        {46}let nm: bitstring = (if v_6 then 3-proj-4-tuple(v_5) else caught-fail) in
        {47}let ns: bitstring = (if v_6 then 2-proj-4-tuple(v_5) else caught-fail) in
        {48}let ne: bitstring = (if v_6 then 1-proj-4-tuple(v_5) else caught-fail) in
        {49}let basis: key = (if v_6 then key_e(me,them,sid_1) else caught-fail) in
        {50}let public_key: key = (if v_6 then catch-fail(dhexp(basis,validkey(g))) else caught-fail) in
        {51}let v_7: bool = not-caught-fail(public_key) in
        {52}let e_2: keypair = (if v_6 then catch-fail((if v_7 then keypairpack(validkey(public_key),basis) else fail-any)) else caught-fail) in
        {53}let v_8: bool = not-caught-fail(e_2) in
        {54}let ne_1: bitstring = (if v_8 then catch-fail(getpublickey(e_2)) else caught-fail) in
        {55}let v_9: bool = not-caught-fail(ne_1) in
        {56}let v_10: bitstring = (if v_9 then catch-fail(symmetricstateunpack(ss_2)) else caught-fail) in
        {57}let v_11: bool = (not-caught-fail(v_10) && success?(1-proj-3-tuple(v_10))) in
        {58}let h_2: bitstring = (if v_11 then 3-proj-3-tuple(v_10) else caught-fail) in
        {59}let ck_2: key = (if v_11 then 2-proj-3-tuple(v_10) else caught-fail) in
        {60}let cs_2: cipherstate = (if v_11 then 1-proj-3-tuple(v_10) else caught-fail) in
        {61}let ss_3: symmetricstate = (if v_9 then catch-fail((if v_11 then symmetricstatepack(cs_2,ck_2,hash(h_2,ne_1)) else fail-any)) else caught-fail) in
        {62}let v_12: bool = not-caught-fail(ss_3) in
        {63}let basis_1: key = (if v_12 then key_s(me) else caught-fail) in
        {64}let public_key_1: key = (if v_12 then catch-fail(dhexp(basis_1,validkey(g))) else caught-fail) in
        {65}let v_13: bool = not-caught-fail(public_key_1) in
        {66}let s_2: keypair = (if v_12 then catch-fail((if v_13 then keypairpack(validkey(public_key_1),basis_1) else fail-any)) else caught-fail) in
        {67}let v_14: bool = not-caught-fail(s_2) in
        {68}let plaintext: bitstring = (if v_14 then catch-fail(getpublickey(s_2)) else caught-fail) in
        {69}let v_15: bool = not-caught-fail(plaintext) in
        {70}let v_16: bitstring = (if v_15 then catch-fail(symmetricstateunpack(ss_3)) else caught-fail) in
        {71}let v_17: bool = (not-caught-fail(v_16) && success?(1-proj-3-tuple(v_16))) in
        {72}let h_3: bitstring = (if v_17 then 3-proj-3-tuple(v_16) else caught-fail) in
        {73}let ck_3: key = (if v_17 then 2-proj-3-tuple(v_16) else caught-fail) in
        {74}let cs_3: cipherstate = (if v_17 then 1-proj-3-tuple(v_16) else caught-fail) in
        {75}let v_18: bitstring = (if v_17 then catch-fail(cipherstateunpack(cs_3)) else caught-fail) in
        {76}let v_19: bool = (not-caught-fail(v_18) && success?(1-proj-2-tuple(v_18))) in
        {77}let n: nonce = (if v_19 then 2-proj-2-tuple(v_18) else caught-fail) in
        {78}let k_1: key = (if v_19 then 1-proj-2-tuple(v_18) else caught-fail) in
        {79}let e_3: bitstring = (if v_19 then encrypt(k_1,n,h_3,plaintext) else caught-fail) in
        {80}let n_1: nonce = (if v_19 then increment_nonce(n) else caught-fail) in
        {81}let v_20: bitstring = (if v_19 then catch-fail(cipherstateunpack(cs_3)) else caught-fail) in
        {82}let v_21: bool = (not-caught-fail(v_20) && success?(1-proj-2-tuple(v_20))) in
        {83}let o: nonce = (if v_21 then 2-proj-2-tuple(v_20) else caught-fail) in
        {84}let k_2: key = (if v_21 then 1-proj-2-tuple(v_20) else caught-fail) in
        {85}let csi: cipherstate = (if v_19 then catch-fail((if v_21 then cipherstatepack(k_2,n_1) else fail-any)) else caught-fail) in
        {86}let v_22: bool = not-caught-fail(csi) in
        {87}let v_23: bitstring = (if v_17 then catch-fail((if v_19 then (if v_22 then (csi,e_3) else fail-any) else fail-any)) else caught-fail) in
        {88}let v_24: bool = (not-caught-fail(v_23) && success?(1-proj-2-tuple(v_23))) in
        {89}let ciphertext_1: bitstring = (if v_24 then 2-proj-2-tuple(v_23) else caught-fail) in
        {90}let csi_1: cipherstate = (if v_24 then 1-proj-2-tuple(v_23) else caught-fail) in
        {91}let ss_4: symmetricstate = (if v_24 then symmetricstatepack(csi_1,ck_3,h_3) else caught-fail) in
        {92}let v_25: bitstring = (if v_24 then catch-fail(symmetricstateunpack(ss_4)) else caught-fail) in
        {93}let v_26: bool = (not-caught-fail(v_25) && success?(1-proj-3-tuple(v_25))) in
        {94}let h_4: bitstring = (if v_26 then 3-proj-3-tuple(v_25) else caught-fail) in
        {95}let ck_4: key = (if v_26 then 2-proj-3-tuple(v_25) else caught-fail) in
        {96}let cs_4: cipherstate = (if v_26 then 1-proj-3-tuple(v_25) else caught-fail) in
        {97}let ssi: symmetricstate = (if v_24 then catch-fail((if v_26 then symmetricstatepack(cs_4,ck_4,hash(h_4,ciphertext_1)) else fail-any)) else caught-fail) in
        {98}let v_27: bool = not-caught-fail(ssi) in
        {99}let v_28: bitstring = (if v_14 then catch-fail((if v_15 then (if v_17 then (if v_24 then (if v_27 then (ssi,ciphertext_1) else fail-any) else fail-any) else fail-any) else fail-any)) else caught-fail) in
        {100}let v_29: bool = (not-caught-fail(v_28) && success?(1-proj-2-tuple(v_28))) in
        {101}let ns_1: bitstring = (if v_29 then 2-proj-2-tuple(v_28) else caught-fail) in
        {102}let ss_5: symmetricstate = (if v_29 then 1-proj-2-tuple(v_28) else caught-fail) in
        {103}let basis_2: key = (if v_29 then key_m(me) else caught-fail) in
        {104}let public_key_2: key = (if v_29 then catch-fail(dhexp(basis_2,validkey(g))) else caught-fail) in
        {105}let v_30: bool = not-caught-fail(public_key_2) in
        {106}let m_2: keypair = (if v_29 then catch-fail((if v_30 then keypairpack(validkey(public_key_2),basis_2) else fail-any)) else caught-fail) in
        {107}let v_31: bool = not-caught-fail(m_2) in
        {108}let plaintext_1: bitstring = (if v_31 then catch-fail(getpublickey(m_2)) else caught-fail) in
        {109}let v_32: bool = not-caught-fail(plaintext_1) in
        {110}let v_33: bitstring = (if v_32 then catch-fail(symmetricstateunpack(ss_5)) else caught-fail) in
        {111}let v_34: bool = (not-caught-fail(v_33) && success?(1-proj-3-tuple(v_33))) in
        {112}let h_5: bitstring = (if v_34 then 3-proj-3-tuple(v_33) else caught-fail) in
        {113}let ck_5: key = (if v_34 then 2-proj-3-tuple(v_33) else caught-fail) in
        {114}let cs_5: cipherstate = (if v_34 then 1-proj-3-tuple(v_33) else caught-fail) in
        {115}let v_35: bitstring = (if v_34 then catch-fail(cipherstateunpack(cs_5)) else caught-fail) in
        {116}let v_36: bool = (not-caught-fail(v_35) && success?(1-proj-2-tuple(v_35))) in
        {117}let n_2: nonce = (if v_36 then 2-proj-2-tuple(v_35) else caught-fail) in
        {118}let k_3: key = (if v_36 then 1-proj-2-tuple(v_35) else caught-fail) in
        {119}let e_4: bitstring = (if v_36 then encrypt(k_3,n_2,h_5,plaintext_1) else caught-fail) in
        {120}let n_3: nonce = (if v_36 then increment_nonce(n_2) else caught-fail) in
        {121}let v_37: bitstring = (if v_36 then catch-fail(cipherstateunpack(cs_5)) else caught-fail) in
        {122}let v_38: bool = (not-caught-fail(v_37) && success?(1-proj-2-tuple(v_37))) in
        {123}let o_1: nonce = (if v_38 then 2-proj-2-tuple(v_37) else caught-fail) in
        {124}let k_4: key = (if v_38 then 1-proj-2-tuple(v_37) else caught-fail) in
        {125}let csi_2: cipherstate = (if v_36 then catch-fail((if v_38 then cipherstatepack(k_4,n_3) else fail-any)) else caught-fail) in
        {126}let v_39: bool = not-caught-fail(csi_2) in
        {127}let v_40: bitstring = (if v_34 then catch-fail((if v_36 then (if v_39 then (csi_2,e_4) else fail-any) else fail-any)) else caught-fail) in
        {128}let v_41: bool = (not-caught-fail(v_40) && success?(1-proj-2-tuple(v_40))) in
        {129}let ciphertext_2: bitstring = (if v_41 then 2-proj-2-tuple(v_40) else caught-fail) in
        {130}let csi_3: cipherstate = (if v_41 then 1-proj-2-tuple(v_40) else caught-fail) in
        {131}let ss_6: symmetricstate = (if v_41 then symmetricstatepack(csi_3,ck_5,h_5) else caught-fail) in
        {132}let v_42: bitstring = (if v_41 then catch-fail(symmetricstateunpack(ss_6)) else caught-fail) in
        {133}let v_43: bool = (not-caught-fail(v_42) && success?(1-proj-3-tuple(v_42))) in
        {134}let h_6: bitstring = (if v_43 then 3-proj-3-tuple(v_42) else caught-fail) in
        {135}let ck_6: key = (if v_43 then 2-proj-3-tuple(v_42) else caught-fail) in
        {136}let cs_6: cipherstate = (if v_43 then 1-proj-3-tuple(v_42) else caught-fail) in
        {137}let ssi_1: symmetricstate = (if v_41 then catch-fail((if v_43 then symmetricstatepack(cs_6,ck_6,hash(h_6,ciphertext_2)) else fail-any)) else caught-fail) in
        {138}let v_44: bool = not-caught-fail(ssi_1) in
        {139}let v_45: bitstring = (if v_31 then catch-fail((if v_32 then (if v_34 then (if v_41 then (if v_44 then (ssi_1,ciphertext_2) else fail-any) else fail-any) else fail-any) else fail-any)) else caught-fail) in
        {140}let v_46: bool = (not-caught-fail(v_45) && success?(1-proj-2-tuple(v_45))) in
        {141}let nm_1: bitstring = (if v_46 then 2-proj-2-tuple(v_45) else caught-fail) in
        {142}let ss_7: symmetricstate = (if v_46 then 1-proj-2-tuple(v_45) else caught-fail) in
        {143}let v_47: bitstring = (if v_46 then catch-fail(symmetricstateunpack(ss_7)) else caught-fail) in
        {144}let v_48: bool = (not-caught-fail(v_47) && success?(1-proj-3-tuple(v_47))) in
        {145}let h_7: bitstring = (if v_48 then 3-proj-3-tuple(v_47) else caught-fail) in
        {146}let ck_7: key = (if v_48 then 2-proj-3-tuple(v_47) else caught-fail) in
        {147}let cs_7: cipherstate = (if v_48 then 1-proj-3-tuple(v_47) else caught-fail) in
        {148}let v_49: bitstring = (if v_48 then catch-fail(cipherstateunpack(cs_7)) else caught-fail) in
        {149}let v_50: bool = (not-caught-fail(v_49) && success?(1-proj-2-tuple(v_49))) in
        {150}let n_4: nonce = (if v_50 then 2-proj-2-tuple(v_49) else caught-fail) in
        {151}let k_5: key = (if v_50 then 1-proj-2-tuple(v_49) else caught-fail) in
        {152}let e_5: bitstring = (if v_50 then encrypt(k_5,n_4,h_7,payload) else caught-fail) in
        {153}let n_5: nonce = (if v_50 then increment_nonce(n_4) else caught-fail) in
        {154}let v_51: bitstring = (if v_50 then catch-fail(cipherstateunpack(cs_7)) else caught-fail) in
        {155}let v_52: bool = (not-caught-fail(v_51) && success?(1-proj-2-tuple(v_51))) in
        {156}let o_2: nonce = (if v_52 then 2-proj-2-tuple(v_51) else caught-fail) in
        {157}let k_6: key = (if v_52 then 1-proj-2-tuple(v_51) else caught-fail) in
        {158}let csi_4: cipherstate = (if v_50 then catch-fail((if v_52 then cipherstatepack(k_6,n_5) else fail-any)) else caught-fail) in
        {159}let v_53: bool = not-caught-fail(csi_4) in
        {160}let v_54: bitstring = (if v_48 then catch-fail((if v_50 then (if v_53 then (csi_4,e_5) else fail-any) else fail-any)) else caught-fail) in
        {161}let v_55: bool = (not-caught-fail(v_54) && success?(1-proj-2-tuple(v_54))) in
        {162}let ciphertext_3: bitstring = (if v_55 then 2-proj-2-tuple(v_54) else caught-fail) in
        {163}let csi_5: cipherstate = (if v_55 then 1-proj-2-tuple(v_54) else caught-fail) in
        {164}let ss_8: symmetricstate = (if v_55 then symmetricstatepack(csi_5,ck_7,h_7) else caught-fail) in
        {165}let v_56: bitstring = (if v_55 then catch-fail(symmetricstateunpack(ss_8)) else caught-fail) in
        {166}let v_57: bool = (not-caught-fail(v_56) && success?(1-proj-3-tuple(v_56))) in
        {167}let h_8: bitstring = (if v_57 then 3-proj-3-tuple(v_56) else caught-fail) in
        {168}let ck_8: key = (if v_57 then 2-proj-3-tuple(v_56) else caught-fail) in
        {169}let cs_8: cipherstate = (if v_57 then 1-proj-3-tuple(v_56) else caught-fail) in
        {170}let ssi_2: symmetricstate = (if v_55 then catch-fail((if v_57 then symmetricstatepack(cs_8,ck_8,hash(h_8,ciphertext_3)) else fail-any)) else caught-fail) in
        {171}let v_58: bool = not-caught-fail(ssi_2) in
        {172}let v_59: bitstring = (if v_46 then catch-fail((if v_48 then (if v_55 then (if v_58 then (ssi_2,ciphertext_3) else fail-any) else fail-any) else fail-any)) else caught-fail) in
        {173}let v_60: bool = (not-caught-fail(v_59) && success?(1-proj-2-tuple(v_59))) in
        {174}let ciphertext_4: bitstring = (if v_60 then 2-proj-2-tuple(v_59) else caught-fail) in
        {175}let ss_9: symmetricstate = (if v_60 then 1-proj-2-tuple(v_59) else caught-fail) in
        {176}let hs_2: handshakestate = (if v_60 then handshakestatepack(ss_9,s_2,m_2,e_2,rs_1,rm_1,re_1,psk_1,initiator_1) else caught-fail) in
        {177}let message_buffer: bitstring = (if v_60 then concat4(ne_1,ns_1,nm_1,ciphertext_4) else caught-fail) in
        {178}let (hs_3: handshakestate,message_a: bitstring) = (if v_4 then (if v_6 then (if v_8 then (if v_9 then (if v_12 then (if v_14 then (if v_29 then (if v_31 then (if v_46 then (if v_60 then (hs_2,message_buffer) else fail-any) else fail-any) else fail-any) else fail-any) else fail-any) else fail-any) else fail-any) else fail-any) else fail-any) else fail-any) in
        {179}event SendMsg(me,them,stagepack_a(sid_1),msg_a(me,them,sid_1));
        {180}insert statestore(me,them,sid_1,statepack_b(hs_3));
        {181}out(pub, message_a)
    ) | (
        {473}get statestore(=me,=them,=sid_1,statepack_b(hs_4: handshakestate)) in
        {183}in(pub, message_b: bitstring);
        {184}let v_61: bitstring = catch-fail(handshakestateunpack(hs_4)) in
        {185}let v_62: bool = (not-caught-fail(v_61) && success?(1-proj-9-tuple(v_61))) in
        {186}let initiator_2: bool = (if v_62 then 9-proj-9-tuple(v_61) else caught-fail) in
        {187}let psk_2: key = (if v_62 then 8-proj-9-tuple(v_61) else caught-fail) in
        {188}let re_2: key = (if v_62 then 7-proj-9-tuple(v_61) else caught-fail) in
        {189}let rm_2: key = (if v_62 then 6-proj-9-tuple(v_61) else caught-fail) in
        {190}let rs_2: key = (if v_62 then 5-proj-9-tuple(v_61) else caught-fail) in
        {191}let e_6: keypair = (if v_62 then 4-proj-9-tuple(v_61) else caught-fail) in
        {192}let m_3: keypair = (if v_62 then 3-proj-9-tuple(v_61) else caught-fail) in
        {193}let s_3: keypair = (if v_62 then 2-proj-9-tuple(v_61) else caught-fail) in
        {194}let ss_10: symmetricstate = (if v_62 then 1-proj-9-tuple(v_61) else caught-fail) in
        {195}let v_63: bitstring = (if v_62 then catch-fail(deconcat4(message_b)) else caught-fail) in
        {196}let v_64: bool = (not-caught-fail(v_63) && success?(1-proj-4-tuple(v_63))) in
        {197}let ciphertext_5: bitstring = (if v_64 then 4-proj-4-tuple(v_63) else caught-fail) in
        {198}let nm_2: bitstring = (if v_64 then 3-proj-4-tuple(v_63) else caught-fail) in
        {199}let ns_2: bitstring = (if v_64 then 2-proj-4-tuple(v_63) else caught-fail) in
        {200}let ne_2: bitstring = (if v_64 then 1-proj-4-tuple(v_63) else caught-fail) in
        {201}let valid1: bool = (if v_64 then true else caught-fail) in
        {202}let valid2: bool = (if v_64 then true else caught-fail) in
        {203}let re_3: key = (if v_64 then ne_2 else caught-fail) in
        {204}let v_65: bitstring = (if v_64 then catch-fail(symmetricstateunpack(ss_10)) else caught-fail) in
        {205}let v_66: bool = (not-caught-fail(v_65) && success?(1-proj-3-tuple(v_65))) in
        {206}let h_9: bitstring = (if v_66 then 3-proj-3-tuple(v_65) else caught-fail) in
        {207}let ck_9: key = (if v_66 then 2-proj-3-tuple(v_65) else caught-fail) in
        {208}let cs_9: cipherstate = (if v_66 then 1-proj-3-tuple(v_65) else caught-fail) in
        {209}let ss_11: symmetricstate = (if v_64 then catch-fail((if v_66 then symmetricstatepack(cs_9,ck_9,hash(h_9,re_3)) else fail-any)) else caught-fail) in
        {210}let v_67: bool = not-caught-fail(ss_11) in
        {211}let v_68: bitstring = (if v_67 then catch-fail(keypairunpack(e_6)) else caught-fail) in
        {212}let v_69: bool = (not-caught-fail(v_68) && success?(1-proj-2-tuple(v_68))) in
        {213}let my_private_key: key = (if v_69 then 2-proj-2-tuple(v_68) else caught-fail) in
        {214}let my_public_key: key = (if v_69 then 1-proj-2-tuple(v_68) else caught-fail) in
        {215}let input_key_material: key = (if v_67 then catch-fail((if v_69 then dhexp(my_private_key,re_3) else fail-any)) else caught-fail) in
        {216}let v_70: bool = not-caught-fail(input_key_material) in
        {217}let v_71: bitstring = (if v_70 then catch-fail(symmetricstateunpack(ss_11)) else caught-fail) in
        {218}let v_72: bool = (not-caught-fail(v_71) && success?(1-proj-3-tuple(v_71))) in
        {219}let h_10: bitstring = (if v_72 then 3-proj-3-tuple(v_71) else caught-fail) in
        {220}let ck_10: key = (if v_72 then 2-proj-3-tuple(v_71) else caught-fail) in
        {221}let cs_10: cipherstate = (if v_72 then 1-proj-3-tuple(v_71) else caught-fail) in
        {222}let output1: key = (if v_72 then hmac_hash1(ck_10,input_key_material) else caught-fail) in
        {223}let output2: key = (if v_72 then hmac_hash2(ck_10,input_key_material) else caught-fail) in
        {224}let output3: key = (if v_72 then hmac_hash3(ck_10,input_key_material) else caught-fail) in
        {225}let v_73: bitstring = (if v_72 then catch-fail((output1,output2,output3)) else caught-fail) in
        {226}let v_74: bool = (not-caught-fail(v_73) && success?(1-proj-3-tuple(v_73))) in
        {227}let output_3: key = (if v_74 then 3-proj-3-tuple(v_73) else caught-fail) in
        {228}let temp_k: key = (if v_74 then 2-proj-3-tuple(v_73) else caught-fail) in
        {229}let ck_11: key = (if v_74 then 1-proj-3-tuple(v_73) else caught-fail) in
        {230}let ss_12: symmetricstate = (if v_67 then catch-fail((if v_70 then (if v_72 then (if v_74 then symmetricstatepack(cipherstatepack(temp_k,minnonce),ck_11,h_10) else fail-any) else fail-any) else fail-any)) else caught-fail) in
        {231}let v_75: bool = not-caught-fail(ss_12) in
        {232}let v_76: bitstring = (if v_75 then catch-fail(keypairunpack(s_3)) else caught-fail) in
        {233}let v_77: bool = (not-caught-fail(v_76) && success?(1-proj-2-tuple(v_76))) in
        {234}let my_private_key_1: key = (if v_77 then 2-proj-2-tuple(v_76) else caught-fail) in
        {235}let my_public_key_1: key = (if v_77 then 1-proj-2-tuple(v_76) else caught-fail) in
        {236}let input_key_material_1: key = (if v_75 then catch-fail((if v_77 then dhexp(my_private_key_1,re_3) else fail-any)) else caught-fail) in
        {237}let v_78: bool = not-caught-fail(input_key_material_1) in
        {238}let v_79: bitstring = (if v_78 then catch-fail(symmetricstateunpack(ss_12)) else caught-fail) in
        {239}let v_80: bool = (not-caught-fail(v_79) && success?(1-proj-3-tuple(v_79))) in
        {240}let h_11: bitstring = (if v_80 then 3-proj-3-tuple(v_79) else caught-fail) in
        {241}let ck_12: key = (if v_80 then 2-proj-3-tuple(v_79) else caught-fail) in
        {242}let cs_11: cipherstate = (if v_80 then 1-proj-3-tuple(v_79) else caught-fail) in
        {243}let output1_1: key = (if v_80 then hmac_hash1(ck_12,input_key_material_1) else caught-fail) in
        {244}let output2_1: key = (if v_80 then hmac_hash2(ck_12,input_key_material_1) else caught-fail) in
        {245}let output3_1: key = (if v_80 then hmac_hash3(ck_12,input_key_material_1) else caught-fail) in
        {246}let v_81: bitstring = (if v_80 then catch-fail((output1_1,output2_1,output3_1)) else caught-fail) in
        {247}let v_82: bool = (not-caught-fail(v_81) && success?(1-proj-3-tuple(v_81))) in
        {248}let output: key = (if v_82 then 3-proj-3-tuple(v_81) else caught-fail) in
        {249}let temp_k_1: key = (if v_82 then 2-proj-3-tuple(v_81) else caught-fail) in
        {250}let ck_13: key = (if v_82 then 1-proj-3-tuple(v_81) else caught-fail) in
        {251}let ss_13: symmetricstate = (if v_75 then catch-fail((if v_78 then (if v_80 then (if v_82 then symmetricstatepack(cipherstatepack(temp_k_1,minnonce),ck_13,h_11) else fail-any) else fail-any) else fail-any)) else caught-fail) in
        {252}let v_83: bool = not-caught-fail(ss_13) in
        {253}let v_84: bitstring = (if v_83 then catch-fail(keypairunpack(m_3)) else caught-fail) in
        {254}let v_85: bool = (not-caught-fail(v_84) && success?(1-proj-2-tuple(v_84))) in
        {255}let my_private_key_2: key = (if v_85 then 2-proj-2-tuple(v_84) else caught-fail) in
        {256}let my_public_key_2: key = (if v_85 then 1-proj-2-tuple(v_84) else caught-fail) in
        {257}let input_key_material_2: key = (if v_83 then catch-fail((if v_85 then dhexp(my_private_key_2,re_3) else fail-any)) else caught-fail) in
        {258}let v_86: bool = not-caught-fail(input_key_material_2) in
        {259}let v_87: bitstring = (if v_86 then catch-fail(symmetricstateunpack(ss_13)) else caught-fail) in
        {260}let v_88: bool = (not-caught-fail(v_87) && success?(1-proj-3-tuple(v_87))) in
        {261}let h_12: bitstring = (if v_88 then 3-proj-3-tuple(v_87) else caught-fail) in
        {262}let ck_14: key = (if v_88 then 2-proj-3-tuple(v_87) else caught-fail) in
        {263}let cs_12: cipherstate = (if v_88 then 1-proj-3-tuple(v_87) else caught-fail) in
        {264}let output1_2: key = (if v_88 then hmac_hash1(ck_14,input_key_material_2) else caught-fail) in
        {265}let output2_2: key = (if v_88 then hmac_hash2(ck_14,input_key_material_2) else caught-fail) in
        {266}let output3_2: key = (if v_88 then hmac_hash3(ck_14,input_key_material_2) else caught-fail) in
        {267}let v_89: bitstring = (if v_88 then catch-fail((output1_2,output2_2,output3_2)) else caught-fail) in
        {268}let v_90: bool = (not-caught-fail(v_89) && success?(1-proj-3-tuple(v_89))) in
        {269}let output_1: key = (if v_90 then 3-proj-3-tuple(v_89) else caught-fail) in
        {270}let temp_k_2: key = (if v_90 then 2-proj-3-tuple(v_89) else caught-fail) in
        {271}let ck_15: key = (if v_90 then 1-proj-3-tuple(v_89) else caught-fail) in
        {272}let ss_14: symmetricstate = (if v_83 then catch-fail((if v_86 then (if v_88 then (if v_90 then symmetricstatepack(cipherstatepack(temp_k_2,minnonce),ck_15,h_12) else fail-any) else fail-any) else fail-any)) else caught-fail) in
        {273}let v_91: bool = not-caught-fail(ss_14) in
        {274}let v_92: bitstring = (if v_91 then catch-fail(symmetricstateunpack(ss_14)) else caught-fail) in
        {275}let v_93: bool = (not-caught-fail(v_92) && success?(1-proj-3-tuple(v_92))) in
        {276}let h_13: bitstring = (if v_93 then 3-proj-3-tuple(v_92) else caught-fail) in
        {277}let ck_16: key = (if v_93 then 2-proj-3-tuple(v_92) else caught-fail) in
        {278}let cs_13: cipherstate = (if v_93 then 1-proj-3-tuple(v_92) else caught-fail) in
        {279}let v_94: bitstring = (if v_93 then catch-fail(cipherstateunpack(cs_13)) else caught-fail) in
        {280}let v_95: bool = (not-caught-fail(v_94) && success?(1-proj-2-tuple(v_94))) in
        {281}let n_6: nonce = (if v_95 then 2-proj-2-tuple(v_94) else caught-fail) in
        {282}let k_7: key = (if v_95 then 1-proj-2-tuple(v_94) else caught-fail) in
        {283}let d: aead = (if v_95 then catch-fail(decrypt(k_7,n_6,h_13,ns_2)) else caught-fail) in
        {284}let v_96: bool = not-caught-fail(d) in
        {285}let v_97: bitstring = (if v_96 then catch-fail(aeadunpack(d)) else caught-fail) in
        {286}let v_98: bool = (not-caught-fail(v_97) && success?(1-proj-3-tuple(v_97))) in
        {287}let plaintext_2: bitstring = (if v_98 then 3-proj-3-tuple(v_97) else caught-fail) in
        {288}let adi: bitstring = (if v_98 then 2-proj-3-tuple(v_97) else caught-fail) in
        {289}let valid: bool = (if v_98 then 1-proj-3-tuple(v_97) else caught-fail) in
        {290}let n_7: nonce = (if v_98 then increment_nonce(n_6) else caught-fail) in
        {291}let v_99: bitstring = (if v_98 then catch-fail(cipherstateunpack(cs_13)) else caught-fail) in
        {292}let v_100: bool = (not-caught-fail(v_99) && success?(1-proj-2-tuple(v_99))) in
        {293}let o_3: nonce = (if v_100 then 2-proj-2-tuple(v_99) else caught-fail) in
        {294}let k_8: key = (if v_100 then 1-proj-2-tuple(v_99) else caught-fail) in
        {295}let csi_6: cipherstate = (if v_98 then catch-fail((if v_100 then cipherstatepack(k_8,n_7) else fail-any)) else caught-fail) in
        {296}let v_101: bool = not-caught-fail(csi_6) in
        {297}let v_102: bitstring = (if v_93 then catch-fail((if v_95 then (if v_96 then (if v_98 then (if v_101 then (csi_6,plaintext_2,valid) else fail-any) else fail-any) else fail-any) else fail-any)) else caught-fail) in
        {298}let v_103: bool = (not-caught-fail(v_102) && success?(1-proj-3-tuple(v_102))) in
        {299}let valid_1: bool = (if v_103 then 3-proj-3-tuple(v_102) else caught-fail) in
        {300}let plaintext_3: bitstring = (if v_103 then 2-proj-3-tuple(v_102) else caught-fail) in
        {301}let csi_7: cipherstate = (if v_103 then 1-proj-3-tuple(v_102) else caught-fail) in
        {302}let ss_15: symmetricstate = (if v_103 then symmetricstatepack(csi_7,ck_16,h_13) else caught-fail) in
        {303}let v_104: bitstring = (if v_103 then catch-fail(symmetricstateunpack(ss_15)) else caught-fail) in
        {304}let v_105: bool = (not-caught-fail(v_104) && success?(1-proj-3-tuple(v_104))) in
        {305}let h_14: bitstring = (if v_105 then 3-proj-3-tuple(v_104) else caught-fail) in
        {306}let ck_17: key = (if v_105 then 2-proj-3-tuple(v_104) else caught-fail) in
        {307}let cs_14: cipherstate = (if v_105 then 1-proj-3-tuple(v_104) else caught-fail) in
        {308}let ssi_3: symmetricstate = (if v_103 then catch-fail((if v_105 then symmetricstatepack(cs_14,ck_17,hash(h_14,ns_2)) else fail-any)) else caught-fail) in
        {309}let v_106: bool = not-caught-fail(ssi_3) in
        {310}let v_107: bitstring = (if v_91 then catch-fail((if v_93 then (if v_103 then (if v_106 then (ssi_3,plaintext_3,valid_1) else fail-any) else fail-any) else fail-any)) else caught-fail) in
        {311}let v_108: bool = (not-caught-fail(v_107) && success?(1-proj-3-tuple(v_107))) in
        {312}let valid1_1: bool = (if v_108 then 3-proj-3-tuple(v_107) else caught-fail) in
        {313}let ne_3: bitstring = (if v_108 then 2-proj-3-tuple(v_107) else caught-fail) in
        {314}let ss_16: symmetricstate = (if v_108 then 1-proj-3-tuple(v_107) else caught-fail) in
        {315}let rs_3: key = (if v_108 then ne_3 else caught-fail) in
        {316}let v_109: bitstring = (if v_108 then catch-fail(symmetricstateunpack(ss_16)) else caught-fail) in
        {317}let v_110: bool = (not-caught-fail(v_109) && success?(1-proj-3-tuple(v_109))) in
        {318}let h_15: bitstring = (if v_110 then 3-proj-3-tuple(v_109) else caught-fail) in
        {319}let ck_18: key = (if v_110 then 2-proj-3-tuple(v_109) else caught-fail) in
        {320}let cs_15: cipherstate = (if v_110 then 1-proj-3-tuple(v_109) else caught-fail) in
        {321}let v_111: bitstring = (if v_110 then catch-fail(cipherstateunpack(cs_15)) else caught-fail) in
        {322}let v_112: bool = (not-caught-fail(v_111) && success?(1-proj-2-tuple(v_111))) in
        {323}let n_8: nonce = (if v_112 then 2-proj-2-tuple(v_111) else caught-fail) in
        {324}let k_9: key = (if v_112 then 1-proj-2-tuple(v_111) else caught-fail) in
        {325}let d_1: aead = (if v_112 then catch-fail(decrypt(k_9,n_8,h_15,nm_2)) else caught-fail) in
        {326}let v_113: bool = not-caught-fail(d_1) in
        {327}let v_114: bitstring = (if v_113 then catch-fail(aeadunpack(d_1)) else caught-fail) in
        {328}let v_115: bool = (not-caught-fail(v_114) && success?(1-proj-3-tuple(v_114))) in
        {329}let plaintext_4: bitstring = (if v_115 then 3-proj-3-tuple(v_114) else caught-fail) in
        {330}let adi_1: bitstring = (if v_115 then 2-proj-3-tuple(v_114) else caught-fail) in
        {331}let valid_2: bool = (if v_115 then 1-proj-3-tuple(v_114) else caught-fail) in
        {332}let n_9: nonce = (if v_115 then increment_nonce(n_8) else caught-fail) in
        {333}let v_116: bitstring = (if v_115 then catch-fail(cipherstateunpack(cs_15)) else caught-fail) in
        {334}let v_117: bool = (not-caught-fail(v_116) && success?(1-proj-2-tuple(v_116))) in
        {335}let o_4: nonce = (if v_117 then 2-proj-2-tuple(v_116) else caught-fail) in
        {336}let k_10: key = (if v_117 then 1-proj-2-tuple(v_116) else caught-fail) in
        {337}let csi_8: cipherstate = (if v_115 then catch-fail((if v_117 then cipherstatepack(k_10,n_9) else fail-any)) else caught-fail) in
        {338}let v_118: bool = not-caught-fail(csi_8) in
        {339}let v_119: bitstring = (if v_110 then catch-fail((if v_112 then (if v_113 then (if v_115 then (if v_118 then (csi_8,plaintext_4,valid_2) else fail-any) else fail-any) else fail-any) else fail-any)) else caught-fail) in
        {340}let v_120: bool = (not-caught-fail(v_119) && success?(1-proj-3-tuple(v_119))) in
        {341}let valid_3: bool = (if v_120 then 3-proj-3-tuple(v_119) else caught-fail) in
        {342}let plaintext_5: bitstring = (if v_120 then 2-proj-3-tuple(v_119) else caught-fail) in
        {343}let csi_9: cipherstate = (if v_120 then 1-proj-3-tuple(v_119) else caught-fail) in
        {344}let ss_17: symmetricstate = (if v_120 then symmetricstatepack(csi_9,ck_18,h_15) else caught-fail) in
        {345}let v_121: bitstring = (if v_120 then catch-fail(symmetricstateunpack(ss_17)) else caught-fail) in
        {346}let v_122: bool = (not-caught-fail(v_121) && success?(1-proj-3-tuple(v_121))) in
        {347}let h_16: bitstring = (if v_122 then 3-proj-3-tuple(v_121) else caught-fail) in
        {348}let ck_19: key = (if v_122 then 2-proj-3-tuple(v_121) else caught-fail) in
        {349}let cs_16: cipherstate = (if v_122 then 1-proj-3-tuple(v_121) else caught-fail) in
        {350}let ssi_4: symmetricstate = (if v_120 then catch-fail((if v_122 then symmetricstatepack(cs_16,ck_19,hash(h_16,nm_2)) else fail-any)) else caught-fail) in
        {351}let v_123: bool = not-caught-fail(ssi_4) in
        {352}let v_124: bitstring = (if v_108 then catch-fail((if v_110 then (if v_120 then (if v_123 then (ssi_4,plaintext_5,valid_3) else fail-any) else fail-any) else fail-any)) else caught-fail) in
        {353}let v_125: bool = (not-caught-fail(v_124) && success?(1-proj-3-tuple(v_124))) in
        {354}let valid2_1: bool = (if v_125 then 3-proj-3-tuple(v_124) else caught-fail) in
        {355}let ne_4: bitstring = (if v_125 then 2-proj-3-tuple(v_124) else caught-fail) in
        {356}let ss_18: symmetricstate = (if v_125 then 1-proj-3-tuple(v_124) else caught-fail) in
        {357}let rm_3: key = (if v_125 then ne_4 else caught-fail) in
        {358}let v_126: bitstring = (if v_125 then catch-fail(keypairunpack(e_6)) else caught-fail) in
        {359}let v_127: bool = (not-caught-fail(v_126) && success?(1-proj-2-tuple(v_126))) in
        {360}let my_private_key_3: key = (if v_127 then 2-proj-2-tuple(v_126) else caught-fail) in
        {361}let my_public_key_3: key = (if v_127 then 1-proj-2-tuple(v_126) else caught-fail) in
        {362}let input_key_material_3: key = (if v_125 then catch-fail((if v_127 then dhexp(my_private_key_3,rs_3) else fail-any)) else caught-fail) in
        {363}let v_128: bool = not-caught-fail(input_key_material_3) in
        {364}let v_129: bitstring = (if v_128 then catch-fail(symmetricstateunpack(ss_18)) else caught-fail) in
        {365}let v_130: bool = (not-caught-fail(v_129) && success?(1-proj-3-tuple(v_129))) in
        {366}let h_17: bitstring = (if v_130 then 3-proj-3-tuple(v_129) else caught-fail) in
        {367}let ck_20: key = (if v_130 then 2-proj-3-tuple(v_129) else caught-fail) in
        {368}let cs_17: cipherstate = (if v_130 then 1-proj-3-tuple(v_129) else caught-fail) in
        {369}let output1_3: key = (if v_130 then hmac_hash1(ck_20,input_key_material_3) else caught-fail) in
        {370}let output2_3: key = (if v_130 then hmac_hash2(ck_20,input_key_material_3) else caught-fail) in
        {371}let output3_3: key = (if v_130 then hmac_hash3(ck_20,input_key_material_3) else caught-fail) in
        {372}let v_131: bitstring = (if v_130 then catch-fail((output1_3,output2_3,output3_3)) else caught-fail) in
        {373}let v_132: bool = (not-caught-fail(v_131) && success?(1-proj-3-tuple(v_131))) in
        {374}let output_2: key = (if v_132 then 3-proj-3-tuple(v_131) else caught-fail) in
        {375}let temp_k_3: key = (if v_132 then 2-proj-3-tuple(v_131) else caught-fail) in
        {376}let ck_21: key = (if v_132 then 1-proj-3-tuple(v_131) else caught-fail) in
        {377}let ss_19: symmetricstate = (if v_125 then catch-fail((if v_128 then (if v_130 then (if v_132 then symmetricstatepack(cipherstatepack(temp_k_3,minnonce),ck_21,h_17) else fail-any) else fail-any) else fail-any)) else caught-fail) in
        {378}let v_133: bool = not-caught-fail(ss_19) in
        {379}let v_134: bitstring = (if v_133 then catch-fail(keypairunpack(e_6)) else caught-fail) in
        {380}let v_135: bool = (not-caught-fail(v_134) && success?(1-proj-2-tuple(v_134))) in
        {381}let my_private_key_4: key = (if v_135 then 2-proj-2-tuple(v_134) else caught-fail) in
        {382}let my_public_key_4: key = (if v_135 then 1-proj-2-tuple(v_134) else caught-fail) in
        {383}let input_key_material_4: key = (if v_133 then catch-fail((if v_135 then dhexp(my_private_key_4,rm_3) else fail-any)) else caught-fail) in
        {384}let v_136: bool = not-caught-fail(input_key_material_4) in
        {385}let v_137: bitstring = (if v_136 then catch-fail(symmetricstateunpack(ss_19)) else caught-fail) in
        {386}let v_138: bool = (not-caught-fail(v_137) && success?(1-proj-3-tuple(v_137))) in
        {387}let h_18: bitstring = (if v_138 then 3-proj-3-tuple(v_137) else caught-fail) in
        {388}let ck_22: key = (if v_138 then 2-proj-3-tuple(v_137) else caught-fail) in
        {389}let cs_18: cipherstate = (if v_138 then 1-proj-3-tuple(v_137) else caught-fail) in
        {390}let output1_4: key = (if v_138 then hmac_hash1(ck_22,input_key_material_4) else caught-fail) in
        {391}let output2_4: key = (if v_138 then hmac_hash2(ck_22,input_key_material_4) else caught-fail) in
        {392}let output3_4: key = (if v_138 then hmac_hash3(ck_22,input_key_material_4) else caught-fail) in
        {393}let v_139: bitstring = (if v_138 then catch-fail((output1_4,output2_4,output3_4)) else caught-fail) in
        {394}let v_140: bool = (not-caught-fail(v_139) && success?(1-proj-3-tuple(v_139))) in
        {395}let output_4: key = (if v_140 then 3-proj-3-tuple(v_139) else caught-fail) in
        {396}let temp_k_4: key = (if v_140 then 2-proj-3-tuple(v_139) else caught-fail) in
        {397}let ck_23: key = (if v_140 then 1-proj-3-tuple(v_139) else caught-fail) in
        {398}let ss_20: symmetricstate = (if v_133 then catch-fail((if v_136 then (if v_138 then (if v_140 then symmetricstatepack(cipherstatepack(temp_k_4,minnonce),ck_23,h_18) else fail-any) else fail-any) else fail-any)) else caught-fail) in
        {399}let v_141: bool = not-caught-fail(ss_20) in
        {400}let v_142: bitstring = (if v_141 then catch-fail(symmetricstateunpack(ss_20)) else caught-fail) in
        {401}let v_143: bool = (not-caught-fail(v_142) && success?(1-proj-3-tuple(v_142))) in
        {402}let h_19: bitstring = (if v_143 then 3-proj-3-tuple(v_142) else caught-fail) in
        {403}let ck_24: key = (if v_143 then 2-proj-3-tuple(v_142) else caught-fail) in
        {404}let cs_19: cipherstate = (if v_143 then 1-proj-3-tuple(v_142) else caught-fail) in
        {405}let v_144: bitstring = (if v_143 then catch-fail(cipherstateunpack(cs_19)) else caught-fail) in
        {406}let v_145: bool = (not-caught-fail(v_144) && success?(1-proj-2-tuple(v_144))) in
        {407}let n_10: nonce = (if v_145 then 2-proj-2-tuple(v_144) else caught-fail) in
        {408}let k_11: key = (if v_145 then 1-proj-2-tuple(v_144) else caught-fail) in
        {409}let d_2: aead = (if v_145 then catch-fail(decrypt(k_11,n_10,h_19,ciphertext_5)) else caught-fail) in
        {410}let v_146: bool = not-caught-fail(d_2) in
        {411}let v_147: bitstring = (if v_146 then catch-fail(aeadunpack(d_2)) else caught-fail) in
        {412}let v_148: bool = (not-caught-fail(v_147) && success?(1-proj-3-tuple(v_147))) in
        {413}let plaintext_6: bitstring = (if v_148 then 3-proj-3-tuple(v_147) else caught-fail) in
        {414}let adi_2: bitstring = (if v_148 then 2-proj-3-tuple(v_147) else caught-fail) in
        {415}let valid_4: bool = (if v_148 then 1-proj-3-tuple(v_147) else caught-fail) in
        {416}let n_11: nonce = (if v_148 then increment_nonce(n_10) else caught-fail) in
        {417}let v_149: bitstring = (if v_148 then catch-fail(cipherstateunpack(cs_19)) else caught-fail) in
        {418}let v_150: bool = (not-caught-fail(v_149) && success?(1-proj-2-tuple(v_149))) in
        {419}let o_5: nonce = (if v_150 then 2-proj-2-tuple(v_149) else caught-fail) in
        {420}let k_12: key = (if v_150 then 1-proj-2-tuple(v_149) else caught-fail) in
        {421}let csi_10: cipherstate = (if v_148 then catch-fail((if v_150 then cipherstatepack(k_12,n_11) else fail-any)) else caught-fail) in
        {422}let v_151: bool = not-caught-fail(csi_10) in
        {423}let v_152: bitstring = (if v_143 then catch-fail((if v_145 then (if v_146 then (if v_148 then (if v_151 then (csi_10,plaintext_6,valid_4) else fail-any) else fail-any) else fail-any) else fail-any)) else caught-fail) in
        {424}let v_153: bool = (not-caught-fail(v_152) && success?(1-proj-3-tuple(v_152))) in
        {425}let valid_5: bool = (if v_153 then 3-proj-3-tuple(v_152) else caught-fail) in
        {426}let plaintext_7: bitstring = (if v_153 then 2-proj-3-tuple(v_152) else caught-fail) in
        {427}let csi_11: cipherstate = (if v_153 then 1-proj-3-tuple(v_152) else caught-fail) in
        {428}let ss_21: symmetricstate = (if v_153 then symmetricstatepack(csi_11,ck_24,h_19) else caught-fail) in
        {429}let v_154: bitstring = (if v_153 then catch-fail(symmetricstateunpack(ss_21)) else caught-fail) in
        {430}let v_155: bool = (not-caught-fail(v_154) && success?(1-proj-3-tuple(v_154))) in
        {431}let h_20: bitstring = (if v_155 then 3-proj-3-tuple(v_154) else caught-fail) in
        {432}let ck_25: key = (if v_155 then 2-proj-3-tuple(v_154) else caught-fail) in
        {433}let cs_20: cipherstate = (if v_155 then 1-proj-3-tuple(v_154) else caught-fail) in
        {434}let ssi_5: symmetricstate = (if v_153 then catch-fail((if v_155 then symmetricstatepack(cs_20,ck_25,hash(h_20,ciphertext_5)) else fail-any)) else caught-fail) in
        {435}let v_156: bool = not-caught-fail(ssi_5) in
        {436}let v_157: bitstring = (if v_141 then catch-fail((if v_143 then (if v_153 then (if v_156 then (ssi_5,plaintext_7,valid_5) else fail-any) else fail-any) else fail-any)) else caught-fail) in
        {437}let v_158: bool = (not-caught-fail(v_157) && success?(1-proj-3-tuple(v_157))) in
        {438}let valid3: bool = (if v_158 then 3-proj-3-tuple(v_157) else caught-fail) in
        {439}let plaintext_8: bitstring = (if v_158 then 2-proj-3-tuple(v_157) else caught-fail) in
        {440}let ss_22: symmetricstate = (if v_158 then 1-proj-3-tuple(v_157) else caught-fail) in
        {441}let basis_3: key = (if v_158 then key_s(them) else caught-fail) in
        {442}let public_key_3: key = (if v_158 then catch-fail(dhexp(basis_3,validkey(g))) else caught-fail) in
        {443}let v_159: bool = not-caught-fail(public_key_3) in
        {444}let basis_4: key = (if v_158 then key_m(them) else caught-fail) in
        {445}let public_key_4: key = (if v_158 then catch-fail(dhexp(basis_4,validkey(g))) else caught-fail) in
        {446}let v_160: bool = not-caught-fail(public_key_4) in
        {447}let v_161: bool = (if v_158 then catch-fail(((valid1_1 && (valid2_1 && valid3)) && ((rs_3 = getpublickey((if v_159 then keypairpack(validkey(public_key_3),basis_3) else fail-any))) && (rm_3 = getpublickey((if v_160 then keypairpack(validkey(public_key_4),basis_4) else fail-any)))))) else caught-fail) in
        {448}let hs_5: handshakestate = (if v_161 then handshakestatepack(ss_22,s_3,m_3,e_6,rs_3,rm_3,re_3,psk_2,initiator_2) else caught-fail) in
        {449}let v_162: bitstring = (if v_161 then catch-fail(symmetricstateunpack(ss_22)) else caught-fail) in
        {450}let v_163: bool = (not-caught-fail(v_162) && success?(1-proj-3-tuple(v_162))) in
        {451}let h_21: bitstring = (if v_163 then 3-proj-3-tuple(v_162) else caught-fail) in
        {452}let ck_26: key = (if v_163 then 2-proj-3-tuple(v_162) else caught-fail) in
        {453}let cs_21: cipherstate = (if v_163 then 1-proj-3-tuple(v_162) else caught-fail) in
        {454}let input_key_material_5: key = (if v_163 then zero else caught-fail) in
        {455}let output1_5: key = (if v_163 then hmac_hash1(ck_26,input_key_material_5) else caught-fail) in
        {456}let output2_5: key = (if v_163 then hmac_hash2(ck_26,input_key_material_5) else caught-fail) in
        {457}let output3_5: key = (if v_163 then hmac_hash3(ck_26,input_key_material_5) else caught-fail) in
        {458}let v_164: bitstring = (if v_163 then catch-fail((output1_5,output2_5,output3_5)) else caught-fail) in
        {459}let v_165: bool = (not-caught-fail(v_164) && success?(1-proj-3-tuple(v_164))) in
        {460}let temp_k3: key = (if v_165 then 3-proj-3-tuple(v_164) else caught-fail) in
        {461}let temp_k2: key = (if v_165 then 2-proj-3-tuple(v_164) else caught-fail) in
        {462}let temp_k1: key = (if v_165 then 1-proj-3-tuple(v_164) else caught-fail) in
        {463}let cs1: cipherstate = (if v_165 then cipherstatepack(temp_k1,minnonce) else caught-fail) in
        {464}let cs2: cipherstate = (if v_165 then cipherstatepack(temp_k2,minnonce) else caught-fail) in
        {465}let v_166: bitstring = (if v_161 then catch-fail((if v_163 then (if v_165 then (ss_22,cs1,cs2) else fail-any) else fail-any)) else caught-fail) in
        {466}let v_167: bool = (not-caught-fail(v_166) && success?(1-proj-3-tuple(v_166))) in
        {467}let cs2_1: cipherstate = (if v_167 then 3-proj-3-tuple(v_166) else caught-fail) in
        {468}let cs1_1: cipherstate = (if v_167 then 2-proj-3-tuple(v_166) else caught-fail) in
        {469}let ssi_6: symmetricstate = (if v_167 then 1-proj-3-tuple(v_166) else caught-fail) in
        {470}let (hs_6: handshakestate,plaintext_b: bitstring,valid_6: bool,cs1_2: cipherstate,cs2_2: cipherstate) = (if v_62 then (if v_64 then (if v_67 then (if v_75 then (if v_83 then (if v_91 then (if v_108 then (if v_125 then (if v_133 then (if v_141 then (if v_158 then (if undo-catch-fail(v_161) then (if v_167 then (hs_5,plaintext_8,true,cs1_1,cs2_1) else fail-any) else fail-any) else fail-any) else fail-any) else fail-any) else fail-any) else fail-any) else fail-any) else fail-any) else fail-any) else fail-any) else fail-any) else fail-any) in
        {471}event RecvMsg(me,them,stagepack_b(sid_1),plaintext_b);
        {472}insert statestore(me,them,sid_1,statepack_c(hs_6,cs1_2,cs2_2))
    ) | (
        {474}!
        {533}get statestore(=me,=them,=sid_1,statepack_c(hs_7: handshakestate,cs1_3: cipherstate,cs2_3: cipherstate)) in
        {475}let hs_8: handshakestate = handshakestatesetcs(hs_7,cs1_3) in
        {476}let payload_1: bitstring = msg_c(me,them,sid_1) in
        {477}let v_168: bitstring = catch-fail(handshakestateunpack(hs_8)) in
        {478}let v_169: bool = (not-caught-fail(v_168) && success?(1-proj-9-tuple(v_168))) in
        {479}let initiator_3: bool = (if v_169 then 9-proj-9-tuple(v_168) else caught-fail) in
        {480}let psk_3: key = (if v_169 then 8-proj-9-tuple(v_168) else caught-fail) in
        {481}let re_4: key = (if v_169 then 7-proj-9-tuple(v_168) else caught-fail) in
        {482}let rm_4: key = (if v_169 then 6-proj-9-tuple(v_168) else caught-fail) in
        {483}let rs_4: key = (if v_169 then 5-proj-9-tuple(v_168) else caught-fail) in
        {484}let e_7: keypair = (if v_169 then 4-proj-9-tuple(v_168) else caught-fail) in
        {485}let m_4: keypair = (if v_169 then 3-proj-9-tuple(v_168) else caught-fail) in
        {486}let s_4: keypair = (if v_169 then 2-proj-9-tuple(v_168) else caught-fail) in
        {487}let ss_23: symmetricstate = (if v_169 then 1-proj-9-tuple(v_168) else caught-fail) in
        {488}let v_170: bitstring = (if v_169 then catch-fail((empty,empty,empty,empty)) else caught-fail) in
        {489}let v_171: bool = (not-caught-fail(v_170) && success?(1-proj-4-tuple(v_170))) in
        {490}let ciphertext_6: bitstring = (if v_171 then 4-proj-4-tuple(v_170) else caught-fail) in
        {491}let nm_3: bitstring = (if v_171 then 3-proj-4-tuple(v_170) else caught-fail) in
        {492}let ns_3: bitstring = (if v_171 then 2-proj-4-tuple(v_170) else caught-fail) in
        {493}let ne_5: bitstring = (if v_171 then 1-proj-4-tuple(v_170) else caught-fail) in
        {494}let v_172: bitstring = (if v_171 then catch-fail(symmetricstateunpack(ss_23)) else caught-fail) in
        {495}let v_173: bool = (not-caught-fail(v_172) && success?(1-proj-3-tuple(v_172))) in
        {496}let h_22: bitstring = (if v_173 then 3-proj-3-tuple(v_172) else caught-fail) in
        {497}let ck_27: key = (if v_173 then 2-proj-3-tuple(v_172) else caught-fail) in
        {498}let cs_22: cipherstate = (if v_173 then 1-proj-3-tuple(v_172) else caught-fail) in
        {499}let v_174: bitstring = (if v_173 then catch-fail(cipherstateunpack(cs_22)) else caught-fail) in
        {500}let v_175: bool = (not-caught-fail(v_174) && success?(1-proj-2-tuple(v_174))) in
        {501}let n_12: nonce = (if v_175 then 2-proj-2-tuple(v_174) else caught-fail) in
        {502}let k_13: key = (if v_175 then 1-proj-2-tuple(v_174) else caught-fail) in
        {503}let e_8: bitstring = (if v_175 then encrypt(k_13,n_12,h_22,payload_1) else caught-fail) in
        {504}let n_13: nonce = (if v_175 then increment_nonce(n_12) else caught-fail) in
        {505}let v_176: bitstring = (if v_175 then catch-fail(cipherstateunpack(cs_22)) else caught-fail) in
        {506}let v_177: bool = (not-caught-fail(v_176) && success?(1-proj-2-tuple(v_176))) in
        {507}let o_6: nonce = (if v_177 then 2-proj-2-tuple(v_176) else caught-fail) in
        {508}let k_14: key = (if v_177 then 1-proj-2-tuple(v_176) else caught-fail) in
        {509}let csi_12: cipherstate = (if v_175 then catch-fail((if v_177 then cipherstatepack(k_14,n_13) else fail-any)) else caught-fail) in
        {510}let v_178: bool = not-caught-fail(csi_12) in
        {511}let v_179: bitstring = (if v_173 then catch-fail((if v_175 then (if v_178 then (csi_12,e_8) else fail-any) else fail-any)) else caught-fail) in
        {512}let v_180: bool = (not-caught-fail(v_179) && success?(1-proj-2-tuple(v_179))) in
        {513}let ciphertext_7: bitstring = (if v_180 then 2-proj-2-tuple(v_179) else caught-fail) in
        {514}let csi_13: cipherstate = (if v_180 then 1-proj-2-tuple(v_179) else caught-fail) in
        {515}let ss_24: symmetricstate = (if v_180 then symmetricstatepack(csi_13,ck_27,h_22) else caught-fail) in
        {516}let v_181: bitstring = (if v_180 then catch-fail(symmetricstateunpack(ss_24)) else caught-fail) in
        {517}let v_182: bool = (not-caught-fail(v_181) && success?(1-proj-3-tuple(v_181))) in
        {518}let h_23: bitstring = (if v_182 then 3-proj-3-tuple(v_181) else caught-fail) in
        {519}let ck_28: key = (if v_182 then 2-proj-3-tuple(v_181) else caught-fail) in
        {520}let cs_23: cipherstate = (if v_182 then 1-proj-3-tuple(v_181) else caught-fail) in
        {521}let ssi_7: symmetricstate = (if v_180 then catch-fail((if v_182 then symmetricstatepack(cs_23,ck_28,hash(h_23,ciphertext_7)) else fail-any)) else caught-fail) in
        {522}let v_183: bool = not-caught-fail(ssi_7) in
        {523}let v_184: bitstring = (if v_171 then catch-fail((if v_173 then (if v_180 then (if v_183 then (ssi_7,ciphertext_7) else fail-any) else fail-any) else fail-any)) else caught-fail) in
        {524}let v_185: bool = (not-caught-fail(v_184) && success?(1-proj-2-tuple(v_184))) in
        {525}let ciphertext_8: bitstring = (if v_185 then 2-proj-2-tuple(v_184) else caught-fail) in
        {526}let ss_25: symmetricstate = (if v_185 then 1-proj-2-tuple(v_184) else caught-fail) in
        {527}let hs_9: handshakestate = (if v_185 then handshakestatepack(ss_25,s_4,m_4,e_7,rs_4,rm_4,re_4,psk_3,initiator_3) else caught-fail) in
        {528}let message_buffer_1: bitstring = (if v_185 then concat4(ne_5,ns_3,nm_3,ciphertext_8) else caught-fail) in
        {529}let (hs_10: handshakestate,message_c: bitstring) = (if v_169 then (if v_171 then (if v_185 then (hs_9,message_buffer_1) else fail-any) else fail-any) else fail-any) in
        {530}event SendMsg(me,them,stagepack_c(sid_1),msg_c(me,them,sid_1));
        {531}insert statestore(me,them,sid_1,statepack_d(hs_10,handshakestategetcs(hs_10),cs2_3));
        {532}out(pub, message_c)
    ) | (
        {534}!
        {601}get statestore(=me,=them,=sid_1,statepack_d(hs_11: handshakestate,cs1_4: cipherstate,cs2_4: cipherstate)) in
        {535}let hs_12: handshakestate = handshakestatesetcs(hs_11,cs2_4) in
        {536}in(pub, message_d: bitstring);
        {537}let v_186: bitstring = catch-fail(handshakestateunpack(hs_12)) in
        {538}let v_187: bool = (not-caught-fail(v_186) && success?(1-proj-9-tuple(v_186))) in
        {539}let initiator_4: bool = (if v_187 then 9-proj-9-tuple(v_186) else caught-fail) in
        {540}let psk_4: key = (if v_187 then 8-proj-9-tuple(v_186) else caught-fail) in
        {541}let re_5: key = (if v_187 then 7-proj-9-tuple(v_186) else caught-fail) in
        {542}let rm_5: key = (if v_187 then 6-proj-9-tuple(v_186) else caught-fail) in
        {543}let rs_5: key = (if v_187 then 5-proj-9-tuple(v_186) else caught-fail) in
        {544}let e_9: keypair = (if v_187 then 4-proj-9-tuple(v_186) else caught-fail) in
        {545}let m_5: keypair = (if v_187 then 3-proj-9-tuple(v_186) else caught-fail) in
        {546}let s_5: keypair = (if v_187 then 2-proj-9-tuple(v_186) else caught-fail) in
        {547}let ss_26: symmetricstate = (if v_187 then 1-proj-9-tuple(v_186) else caught-fail) in
        {548}let v_188: bitstring = (if v_187 then catch-fail(deconcat4(message_d)) else caught-fail) in
        {549}let v_189: bool = (not-caught-fail(v_188) && success?(1-proj-4-tuple(v_188))) in
        {550}let ciphertext_9: bitstring = (if v_189 then 4-proj-4-tuple(v_188) else caught-fail) in
        {551}let nm_4: bitstring = (if v_189 then 3-proj-4-tuple(v_188) else caught-fail) in
        {552}let ns_4: bitstring = (if v_189 then 2-proj-4-tuple(v_188) else caught-fail) in
        {553}let ne_6: bitstring = (if v_189 then 1-proj-4-tuple(v_188) else caught-fail) in
        {554}let valid1_2: bool = (if v_189 then true else caught-fail) in
        {555}let v_190: bitstring = (if v_189 then catch-fail(symmetricstateunpack(ss_26)) else caught-fail) in
        {556}let v_191: bool = (not-caught-fail(v_190) && success?(1-proj-3-tuple(v_190))) in
        {557}let h_24: bitstring = (if v_191 then 3-proj-3-tuple(v_190) else caught-fail) in
        {558}let ck_29: key = (if v_191 then 2-proj-3-tuple(v_190) else caught-fail) in
        {559}let cs_24: cipherstate = (if v_191 then 1-proj-3-tuple(v_190) else caught-fail) in
        {560}let v_192: bitstring = (if v_191 then catch-fail(cipherstateunpack(cs_24)) else caught-fail) in
        {561}let v_193: bool = (not-caught-fail(v_192) && success?(1-proj-2-tuple(v_192))) in
        {562}let n_14: nonce = (if v_193 then 2-proj-2-tuple(v_192) else caught-fail) in
        {563}let k_15: key = (if v_193 then 1-proj-2-tuple(v_192) else caught-fail) in
        {564}let d_3: aead = (if v_193 then catch-fail(decrypt(k_15,n_14,h_24,ciphertext_9)) else caught-fail) in
        {565}let v_194: bool = not-caught-fail(d_3) in
        {566}let v_195: bitstring = (if v_194 then catch-fail(aeadunpack(d_3)) else caught-fail) in
        {567}let v_196: bool = (not-caught-fail(v_195) && success?(1-proj-3-tuple(v_195))) in
        {568}let plaintext_9: bitstring = (if v_196 then 3-proj-3-tuple(v_195) else caught-fail) in
        {569}let adi_3: bitstring = (if v_196 then 2-proj-3-tuple(v_195) else caught-fail) in
        {570}let valid_7: bool = (if v_196 then 1-proj-3-tuple(v_195) else caught-fail) in
        {571}let n_15: nonce = (if v_196 then increment_nonce(n_14) else caught-fail) in
        {572}let v_197: bitstring = (if v_196 then catch-fail(cipherstateunpack(cs_24)) else caught-fail) in
        {573}let v_198: bool = (not-caught-fail(v_197) && success?(1-proj-2-tuple(v_197))) in
        {574}let o_7: nonce = (if v_198 then 2-proj-2-tuple(v_197) else caught-fail) in
        {575}let k_16: key = (if v_198 then 1-proj-2-tuple(v_197) else caught-fail) in
        {576}let csi_14: cipherstate = (if v_196 then catch-fail((if v_198 then cipherstatepack(k_16,n_15) else fail-any)) else caught-fail) in
        {577}let v_199: bool = not-caught-fail(csi_14) in
        {578}let v_200: bitstring = (if v_191 then catch-fail((if v_193 then (if v_194 then (if v_196 then (if v_199 then (csi_14,plaintext_9,valid_7) else fail-any) else fail-any) else fail-any) else fail-any)) else caught-fail) in
        {579}let v_201: bool = (not-caught-fail(v_200) && success?(1-proj-3-tuple(v_200))) in
        {580}let valid_8: bool = (if v_201 then 3-proj-3-tuple(v_200) else caught-fail) in
        {581}let plaintext_10: bitstring = (if v_201 then 2-proj-3-tuple(v_200) else caught-fail) in
        {582}let csi_15: cipherstate = (if v_201 then 1-proj-3-tuple(v_200) else caught-fail) in
        {583}let ss_27: symmetricstate = (if v_201 then symmetricstatepack(csi_15,ck_29,h_24) else caught-fail) in
        {584}let v_202: bitstring = (if v_201 then catch-fail(symmetricstateunpack(ss_27)) else caught-fail) in
        {585}let v_203: bool = (not-caught-fail(v_202) && success?(1-proj-3-tuple(v_202))) in
        {586}let h_25: bitstring = (if v_203 then 3-proj-3-tuple(v_202) else caught-fail) in
        {587}let ck_30: key = (if v_203 then 2-proj-3-tuple(v_202) else caught-fail) in
        {588}let cs_25: cipherstate = (if v_203 then 1-proj-3-tuple(v_202) else caught-fail) in
        {589}let ssi_8: symmetricstate = (if v_201 then catch-fail((if v_203 then symmetricstatepack(cs_25,ck_30,hash(h_25,ciphertext_9)) else fail-any)) else caught-fail) in
        {590}let v_204: bool = not-caught-fail(ssi_8) in
        {591}let v_205: bitstring = (if v_189 then catch-fail((if v_191 then (if v_201 then (if v_204 then (ssi_8,plaintext_10,valid_8) else fail-any) else fail-any) else fail-any)) else caught-fail) in
        {592}let v_206: bool = (not-caught-fail(v_205) && success?(1-proj-3-tuple(v_205))) in
        {593}let valid2_2: bool = (if v_206 then 3-proj-3-tuple(v_205) else caught-fail) in
        {594}let plaintext_11: bitstring = (if v_206 then 2-proj-3-tuple(v_205) else caught-fail) in
        {595}let ss_28: symmetricstate = (if v_206 then 1-proj-3-tuple(v_205) else caught-fail) in
        {596}let v_207: bool = (if v_206 then catch-fail((valid1_2 && valid2_2)) else caught-fail) in
        {597}let hs_13: handshakestate = (if v_207 then handshakestatepack(ss_28,s_5,m_5,e_9,rs_5,rm_5,re_5,psk_4,initiator_4) else caught-fail) in
        {598}let (hs_14: handshakestate,plaintext_d: bitstring,valid_9: bool) = (if v_187 then (if v_189 then (if v_206 then (if undo-catch-fail(v_207) then (hs_13,plaintext_11,true) else fail-any) else fail-any) else fail-any) else fail-any) in
        {599}event RecvMsg(me,them,stagepack_d(sid_1),plaintext_d);
        {600}event RecvEnd(valid_9)
    ) | (
        {602}event LeakS(phase0,me);
        {603}event LeakM(phase0,me);
        {604}out(pub, (key_s(me),key_m(me)))
    ) | (
        {605}phase 1;
        {606}event LeakS(phase1,me);
        {607}event LeakM(phase1,me);
        {608}out(pub, (key_s(me),key_m(me)))
    )
) | (
    {609}let me_1: principal = alice in
    {610}let them_1: principal = charlie in
    {611}let sid_2: sessionid = sid in
    {612}let s_6: keypair = keypairpack(empty,empty) in
    {613}let m_6: keypair = keypairpack(empty,empty) in
    {614}out(pub, (getpublickey(s_6),getpublickey(m_6)));
    (
        {615}let e_10: keypair = keypairpack(empty,empty) in
        {616}let rs_6: key = empty in
        {617}let rm_6: key = empty in
        {618}let re_6: key = empty in
        {619}let prologue_1: bitstring = empty in
        {620}let psk_5: key = empty in
        {621}let protocol_name_1: bitstring = somename in
        {622}let h_26: bitstring = hash(protocol_name_1,empty) in
        {623}let ck_31: key = h_26 in
        {624}let k_17: key = empty in
        {625}let cs_26: cipherstate = cipherstatepack(k_17,minnonce) in
        {626}let ss_29: symmetricstate = symmetricstatepack(cs_26,ck_31,h_26) in
        {627}let v_208: bitstring = catch-fail(symmetricstateunpack(ss_29)) in
        {628}let v_209: bool = (not-caught-fail(v_208) && success?(1-proj-3-tuple(v_208))) in
        {629}let h_27: bitstring = (if v_209 then 3-proj-3-tuple(v_208) else caught-fail) in
        {630}let ck_32: key = (if v_209 then 2-proj-3-tuple(v_208) else caught-fail) in
        {631}let cs_27: cipherstate = (if v_209 then 1-proj-3-tuple(v_208) else caught-fail) in
        {632}let ss_30: symmetricstate = catch-fail((if v_209 then symmetricstatepack(cs_27,ck_32,hash(h_27,prologue_1)) else fail-any)) in
        {633}let v_210: bool = not-caught-fail(ss_30) in
        {634}let hs_15: handshakestate = (if v_210 then handshakestatepack(ss_30,s_6,m_6,e_10,rs_6,rm_6,re_6,psk_5,true) else fail-any) in
        {635}insert statestore(me_1,them_1,sid_2,statepack_a(hs_15))
    ) | (
        {787}get statestore(=me_1,=them_1,=sid_2,statepack_a(hs_16: handshakestate)) in
        {636}let payload_2: bitstring = msg_a(me_1,them_1,sid_2) in
        {637}let v_211: bitstring = catch-fail(handshakestateunpack(hs_16)) in
        {638}let v_212: bool = (not-caught-fail(v_211) && success?(1-proj-9-tuple(v_211))) in
        {639}let initiator_5: bool = (if v_212 then 9-proj-9-tuple(v_211) else caught-fail) in
        {640}let psk_6: key = (if v_212 then 8-proj-9-tuple(v_211) else caught-fail) in
        {641}let re_7: key = (if v_212 then 7-proj-9-tuple(v_211) else caught-fail) in
        {642}let rm_7: key = (if v_212 then 6-proj-9-tuple(v_211) else caught-fail) in
        {643}let rs_7: key = (if v_212 then 5-proj-9-tuple(v_211) else caught-fail) in
        {644}let e_11: keypair = (if v_212 then 4-proj-9-tuple(v_211) else caught-fail) in
        {645}let m_7: keypair = (if v_212 then 3-proj-9-tuple(v_211) else caught-fail) in
        {646}let s_7: keypair = (if v_212 then 2-proj-9-tuple(v_211) else caught-fail) in
        {647}let ss_31: symmetricstate = (if v_212 then 1-proj-9-tuple(v_211) else caught-fail) in
        {648}let v_213: bitstring = (if v_212 then catch-fail((empty,empty,empty,empty)) else caught-fail) in
        {649}let v_214: bool = (not-caught-fail(v_213) && success?(1-proj-4-tuple(v_213))) in
        {650}let ciphertext_10: bitstring = (if v_214 then 4-proj-4-tuple(v_213) else caught-fail) in
        {651}let nm_5: bitstring = (if v_214 then 3-proj-4-tuple(v_213) else caught-fail) in
        {652}let ns_5: bitstring = (if v_214 then 2-proj-4-tuple(v_213) else caught-fail) in
        {653}let ne_7: bitstring = (if v_214 then 1-proj-4-tuple(v_213) else caught-fail) in
        {654}let basis_5: key = (if v_214 then key_e(me_1,them_1,sid_2) else caught-fail) in
        {655}let public_key_5: key = (if v_214 then catch-fail(dhexp(basis_5,validkey(g))) else caught-fail) in
        {656}let v_215: bool = not-caught-fail(public_key_5) in
        {657}let e_12: keypair = (if v_214 then catch-fail((if v_215 then keypairpack(validkey(public_key_5),basis_5) else fail-any)) else caught-fail) in
        {658}let v_216: bool = not-caught-fail(e_12) in
        {659}let ne_8: bitstring = (if v_216 then catch-fail(getpublickey(e_12)) else caught-fail) in
        {660}let v_217: bool = not-caught-fail(ne_8) in
        {661}let v_218: bitstring = (if v_217 then catch-fail(symmetricstateunpack(ss_31)) else caught-fail) in
        {662}let v_219: bool = (not-caught-fail(v_218) && success?(1-proj-3-tuple(v_218))) in
        {663}let h_28: bitstring = (if v_219 then 3-proj-3-tuple(v_218) else caught-fail) in
        {664}let ck_33: key = (if v_219 then 2-proj-3-tuple(v_218) else caught-fail) in
        {665}let cs_28: cipherstate = (if v_219 then 1-proj-3-tuple(v_218) else caught-fail) in
        {666}let ss_32: symmetricstate = (if v_217 then catch-fail((if v_219 then symmetricstatepack(cs_28,ck_33,hash(h_28,ne_8)) else fail-any)) else caught-fail) in
        {667}let v_220: bool = not-caught-fail(ss_32) in
        {668}let basis_6: key = (if v_220 then key_s(me_1) else caught-fail) in
        {669}let public_key_6: key = (if v_220 then catch-fail(dhexp(basis_6,validkey(g))) else caught-fail) in
        {670}let v_221: bool = not-caught-fail(public_key_6) in
        {671}let s_8: keypair = (if v_220 then catch-fail((if v_221 then keypairpack(validkey(public_key_6),basis_6) else fail-any)) else caught-fail) in
        {672}let v_222: bool = not-caught-fail(s_8) in
        {673}let plaintext_12: bitstring = (if v_222 then catch-fail(getpublickey(s_8)) else caught-fail) in
        {674}let v_223: bool = not-caught-fail(plaintext_12) in
        {675}let v_224: bitstring = (if v_223 then catch-fail(symmetricstateunpack(ss_32)) else caught-fail) in
        {676}let v_225: bool = (not-caught-fail(v_224) && success?(1-proj-3-tuple(v_224))) in
        {677}let h_29: bitstring = (if v_225 then 3-proj-3-tuple(v_224) else caught-fail) in
        {678}let ck_34: key = (if v_225 then 2-proj-3-tuple(v_224) else caught-fail) in
        {679}let cs_29: cipherstate = (if v_225 then 1-proj-3-tuple(v_224) else caught-fail) in
        {680}let v_226: bitstring = (if v_225 then catch-fail(cipherstateunpack(cs_29)) else caught-fail) in
        {681}let v_227: bool = (not-caught-fail(v_226) && success?(1-proj-2-tuple(v_226))) in
        {682}let n_16: nonce = (if v_227 then 2-proj-2-tuple(v_226) else caught-fail) in
        {683}let k_18: key = (if v_227 then 1-proj-2-tuple(v_226) else caught-fail) in
        {684}let e_13: bitstring = (if v_227 then encrypt(k_18,n_16,h_29,plaintext_12) else caught-fail) in
        {685}let n_17: nonce = (if v_227 then increment_nonce(n_16) else caught-fail) in
        {686}let v_228: bitstring = (if v_227 then catch-fail(cipherstateunpack(cs_29)) else caught-fail) in
        {687}let v_229: bool = (not-caught-fail(v_228) && success?(1-proj-2-tuple(v_228))) in
        {688}let o_8: nonce = (if v_229 then 2-proj-2-tuple(v_228) else caught-fail) in
        {689}let k_19: key = (if v_229 then 1-proj-2-tuple(v_228) else caught-fail) in
        {690}let csi_16: cipherstate = (if v_227 then catch-fail((if v_229 then cipherstatepack(k_19,n_17) else fail-any)) else caught-fail) in
        {691}let v_230: bool = not-caught-fail(csi_16) in
        {692}let v_231: bitstring = (if v_225 then catch-fail((if v_227 then (if v_230 then (csi_16,e_13) else fail-any) else fail-any)) else caught-fail) in
        {693}let v_232: bool = (not-caught-fail(v_231) && success?(1-proj-2-tuple(v_231))) in
        {694}let ciphertext_11: bitstring = (if v_232 then 2-proj-2-tuple(v_231) else caught-fail) in
        {695}let csi_17: cipherstate = (if v_232 then 1-proj-2-tuple(v_231) else caught-fail) in
        {696}let ss_33: symmetricstate = (if v_232 then symmetricstatepack(csi_17,ck_34,h_29) else caught-fail) in
        {697}let v_233: bitstring = (if v_232 then catch-fail(symmetricstateunpack(ss_33)) else caught-fail) in
        {698}let v_234: bool = (not-caught-fail(v_233) && success?(1-proj-3-tuple(v_233))) in
        {699}let h_30: bitstring = (if v_234 then 3-proj-3-tuple(v_233) else caught-fail) in
        {700}let ck_35: key = (if v_234 then 2-proj-3-tuple(v_233) else caught-fail) in
        {701}let cs_30: cipherstate = (if v_234 then 1-proj-3-tuple(v_233) else caught-fail) in
        {702}let ssi_9: symmetricstate = (if v_232 then catch-fail((if v_234 then symmetricstatepack(cs_30,ck_35,hash(h_30,ciphertext_11)) else fail-any)) else caught-fail) in
        {703}let v_235: bool = not-caught-fail(ssi_9) in
        {704}let v_236: bitstring = (if v_222 then catch-fail((if v_223 then (if v_225 then (if v_232 then (if v_235 then (ssi_9,ciphertext_11) else fail-any) else fail-any) else fail-any) else fail-any)) else caught-fail) in
        {705}let v_237: bool = (not-caught-fail(v_236) && success?(1-proj-2-tuple(v_236))) in
        {706}let ns_6: bitstring = (if v_237 then 2-proj-2-tuple(v_236) else caught-fail) in
        {707}let ss_34: symmetricstate = (if v_237 then 1-proj-2-tuple(v_236) else caught-fail) in
        {708}let basis_7: key = (if v_237 then key_m(me_1) else caught-fail) in
        {709}let public_key_7: key = (if v_237 then catch-fail(dhexp(basis_7,validkey(g))) else caught-fail) in
        {710}let v_238: bool = not-caught-fail(public_key_7) in
        {711}let m_8: keypair = (if v_237 then catch-fail((if v_238 then keypairpack(validkey(public_key_7),basis_7) else fail-any)) else caught-fail) in
        {712}let v_239: bool = not-caught-fail(m_8) in
        {713}let plaintext_13: bitstring = (if v_239 then catch-fail(getpublickey(m_8)) else caught-fail) in
        {714}let v_240: bool = not-caught-fail(plaintext_13) in
        {715}let v_241: bitstring = (if v_240 then catch-fail(symmetricstateunpack(ss_34)) else caught-fail) in
        {716}let v_242: bool = (not-caught-fail(v_241) && success?(1-proj-3-tuple(v_241))) in
        {717}let h_31: bitstring = (if v_242 then 3-proj-3-tuple(v_241) else caught-fail) in
        {718}let ck_36: key = (if v_242 then 2-proj-3-tuple(v_241) else caught-fail) in
        {719}let cs_31: cipherstate = (if v_242 then 1-proj-3-tuple(v_241) else caught-fail) in
        {720}let v_243: bitstring = (if v_242 then catch-fail(cipherstateunpack(cs_31)) else caught-fail) in
        {721}let v_244: bool = (not-caught-fail(v_243) && success?(1-proj-2-tuple(v_243))) in
        {722}let n_18: nonce = (if v_244 then 2-proj-2-tuple(v_243) else caught-fail) in
        {723}let k_20: key = (if v_244 then 1-proj-2-tuple(v_243) else caught-fail) in
        {724}let e_14: bitstring = (if v_244 then encrypt(k_20,n_18,h_31,plaintext_13) else caught-fail) in
        {725}let n_19: nonce = (if v_244 then increment_nonce(n_18) else caught-fail) in
        {726}let v_245: bitstring = (if v_244 then catch-fail(cipherstateunpack(cs_31)) else caught-fail) in
        {727}let v_246: bool = (not-caught-fail(v_245) && success?(1-proj-2-tuple(v_245))) in
        {728}let o_9: nonce = (if v_246 then 2-proj-2-tuple(v_245) else caught-fail) in
        {729}let k_21: key = (if v_246 then 1-proj-2-tuple(v_245) else caught-fail) in
        {730}let csi_18: cipherstate = (if v_244 then catch-fail((if v_246 then cipherstatepack(k_21,n_19) else fail-any)) else caught-fail) in
        {731}let v_247: bool = not-caught-fail(csi_18) in
        {732}let v_248: bitstring = (if v_242 then catch-fail((if v_244 then (if v_247 then (csi_18,e_14) else fail-any) else fail-any)) else caught-fail) in
        {733}let v_249: bool = (not-caught-fail(v_248) && success?(1-proj-2-tuple(v_248))) in
        {734}let ciphertext_12: bitstring = (if v_249 then 2-proj-2-tuple(v_248) else caught-fail) in
        {735}let csi_19: cipherstate = (if v_249 then 1-proj-2-tuple(v_248) else caught-fail) in
        {736}let ss_35: symmetricstate = (if v_249 then symmetricstatepack(csi_19,ck_36,h_31) else caught-fail) in
        {737}let v_250: bitstring = (if v_249 then catch-fail(symmetricstateunpack(ss_35)) else caught-fail) in
        {738}let v_251: bool = (not-caught-fail(v_250) && success?(1-proj-3-tuple(v_250))) in
        {739}let h_32: bitstring = (if v_251 then 3-proj-3-tuple(v_250) else caught-fail) in
        {740}let ck_37: key = (if v_251 then 2-proj-3-tuple(v_250) else caught-fail) in
        {741}let cs_32: cipherstate = (if v_251 then 1-proj-3-tuple(v_250) else caught-fail) in
        {742}let ssi_10: symmetricstate = (if v_249 then catch-fail((if v_251 then symmetricstatepack(cs_32,ck_37,hash(h_32,ciphertext_12)) else fail-any)) else caught-fail) in
        {743}let v_252: bool = not-caught-fail(ssi_10) in
        {744}let v_253: bitstring = (if v_239 then catch-fail((if v_240 then (if v_242 then (if v_249 then (if v_252 then (ssi_10,ciphertext_12) else fail-any) else fail-any) else fail-any) else fail-any)) else caught-fail) in
        {745}let v_254: bool = (not-caught-fail(v_253) && success?(1-proj-2-tuple(v_253))) in
        {746}let nm_6: bitstring = (if v_254 then 2-proj-2-tuple(v_253) else caught-fail) in
        {747}let ss_36: symmetricstate = (if v_254 then 1-proj-2-tuple(v_253) else caught-fail) in
        {748}let v_255: bitstring = (if v_254 then catch-fail(symmetricstateunpack(ss_36)) else caught-fail) in
        {749}let v_256: bool = (not-caught-fail(v_255) && success?(1-proj-3-tuple(v_255))) in
        {750}let h_33: bitstring = (if v_256 then 3-proj-3-tuple(v_255) else caught-fail) in
        {751}let ck_38: key = (if v_256 then 2-proj-3-tuple(v_255) else caught-fail) in
        {752}let cs_33: cipherstate = (if v_256 then 1-proj-3-tuple(v_255) else caught-fail) in
        {753}let v_257: bitstring = (if v_256 then catch-fail(cipherstateunpack(cs_33)) else caught-fail) in
        {754}let v_258: bool = (not-caught-fail(v_257) && success?(1-proj-2-tuple(v_257))) in
        {755}let n_20: nonce = (if v_258 then 2-proj-2-tuple(v_257) else caught-fail) in
        {756}let k_22: key = (if v_258 then 1-proj-2-tuple(v_257) else caught-fail) in
        {757}let e_15: bitstring = (if v_258 then encrypt(k_22,n_20,h_33,payload_2) else caught-fail) in
        {758}let n_21: nonce = (if v_258 then increment_nonce(n_20) else caught-fail) in
        {759}let v_259: bitstring = (if v_258 then catch-fail(cipherstateunpack(cs_33)) else caught-fail) in
        {760}let v_260: bool = (not-caught-fail(v_259) && success?(1-proj-2-tuple(v_259))) in
        {761}let o_10: nonce = (if v_260 then 2-proj-2-tuple(v_259) else caught-fail) in
        {762}let k_23: key = (if v_260 then 1-proj-2-tuple(v_259) else caught-fail) in
        {763}let csi_20: cipherstate = (if v_258 then catch-fail((if v_260 then cipherstatepack(k_23,n_21) else fail-any)) else caught-fail) in
        {764}let v_261: bool = not-caught-fail(csi_20) in
        {765}let v_262: bitstring = (if v_256 then catch-fail((if v_258 then (if v_261 then (csi_20,e_15) else fail-any) else fail-any)) else caught-fail) in
        {766}let v_263: bool = (not-caught-fail(v_262) && success?(1-proj-2-tuple(v_262))) in
        {767}let ciphertext_13: bitstring = (if v_263 then 2-proj-2-tuple(v_262) else caught-fail) in
        {768}let csi_21: cipherstate = (if v_263 then 1-proj-2-tuple(v_262) else caught-fail) in
        {769}let ss_37: symmetricstate = (if v_263 then symmetricstatepack(csi_21,ck_38,h_33) else caught-fail) in
        {770}let v_264: bitstring = (if v_263 then catch-fail(symmetricstateunpack(ss_37)) else caught-fail) in
        {771}let v_265: bool = (not-caught-fail(v_264) && success?(1-proj-3-tuple(v_264))) in
        {772}let h_34: bitstring = (if v_265 then 3-proj-3-tuple(v_264) else caught-fail) in
        {773}let ck_39: key = (if v_265 then 2-proj-3-tuple(v_264) else caught-fail) in
        {774}let cs_34: cipherstate = (if v_265 then 1-proj-3-tuple(v_264) else caught-fail) in
        {775}let ssi_11: symmetricstate = (if v_263 then catch-fail((if v_265 then symmetricstatepack(cs_34,ck_39,hash(h_34,ciphertext_13)) else fail-any)) else caught-fail) in
        {776}let v_266: bool = not-caught-fail(ssi_11) in
        {777}let v_267: bitstring = (if v_254 then catch-fail((if v_256 then (if v_263 then (if v_266 then (ssi_11,ciphertext_13) else fail-any) else fail-any) else fail-any)) else caught-fail) in
        {778}let v_268: bool = (not-caught-fail(v_267) && success?(1-proj-2-tuple(v_267))) in
        {779}let ciphertext_14: bitstring = (if v_268 then 2-proj-2-tuple(v_267) else caught-fail) in
        {780}let ss_38: symmetricstate = (if v_268 then 1-proj-2-tuple(v_267) else caught-fail) in
        {781}let hs_17: handshakestate = (if v_268 then handshakestatepack(ss_38,s_8,m_8,e_12,rs_7,rm_7,re_7,psk_6,initiator_5) else caught-fail) in
        {782}let message_buffer_2: bitstring = (if v_268 then concat4(ne_8,ns_6,nm_6,ciphertext_14) else caught-fail) in
        {783}let (hs_18: handshakestate,message_a_1: bitstring) = (if v_212 then (if v_214 then (if v_216 then (if v_217 then (if v_220 then (if v_222 then (if v_237 then (if v_239 then (if v_254 then (if v_268 then (hs_17,message_buffer_2) else fail-any) else fail-any) else fail-any) else fail-any) else fail-any) else fail-any) else fail-any) else fail-any) else fail-any) else fail-any) in
        {784}event SendMsg(me_1,them_1,stagepack_a(sid_2),msg_a(me_1,them_1,sid_2));
        {785}insert statestore(me_1,them_1,sid_2,statepack_b(hs_18));
        {786}out(pub, message_a_1)
    ) | (
        {1078}get statestore(=me_1,=them_1,=sid_2,statepack_b(hs_19: handshakestate)) in
        {788}in(pub, message_b_1: bitstring);
        {789}let v_269: bitstring = catch-fail(handshakestateunpack(hs_19)) in
        {790}let v_270: bool = (not-caught-fail(v_269) && success?(1-proj-9-tuple(v_269))) in
        {791}let initiator_6: bool = (if v_270 then 9-proj-9-tuple(v_269) else caught-fail) in
        {792}let psk_7: key = (if v_270 then 8-proj-9-tuple(v_269) else caught-fail) in
        {793}let re_8: key = (if v_270 then 7-proj-9-tuple(v_269) else caught-fail) in
        {794}let rm_8: key = (if v_270 then 6-proj-9-tuple(v_269) else caught-fail) in
        {795}let rs_8: key = (if v_270 then 5-proj-9-tuple(v_269) else caught-fail) in
        {796}let e_16: keypair = (if v_270 then 4-proj-9-tuple(v_269) else caught-fail) in
        {797}let m_9: keypair = (if v_270 then 3-proj-9-tuple(v_269) else caught-fail) in
        {798}let s_9: keypair = (if v_270 then 2-proj-9-tuple(v_269) else caught-fail) in
        {799}let ss_39: symmetricstate = (if v_270 then 1-proj-9-tuple(v_269) else caught-fail) in
        {800}let v_271: bitstring = (if v_270 then catch-fail(deconcat4(message_b_1)) else caught-fail) in
        {801}let v_272: bool = (not-caught-fail(v_271) && success?(1-proj-4-tuple(v_271))) in
        {802}let ciphertext_15: bitstring = (if v_272 then 4-proj-4-tuple(v_271) else caught-fail) in
        {803}let nm_7: bitstring = (if v_272 then 3-proj-4-tuple(v_271) else caught-fail) in
        {804}let ns_7: bitstring = (if v_272 then 2-proj-4-tuple(v_271) else caught-fail) in
        {805}let ne_9: bitstring = (if v_272 then 1-proj-4-tuple(v_271) else caught-fail) in
        {806}let valid1_3: bool = (if v_272 then true else caught-fail) in
        {807}let valid2_3: bool = (if v_272 then true else caught-fail) in
        {808}let re_9: key = (if v_272 then ne_9 else caught-fail) in
        {809}let v_273: bitstring = (if v_272 then catch-fail(symmetricstateunpack(ss_39)) else caught-fail) in
        {810}let v_274: bool = (not-caught-fail(v_273) && success?(1-proj-3-tuple(v_273))) in
        {811}let h_35: bitstring = (if v_274 then 3-proj-3-tuple(v_273) else caught-fail) in
        {812}let ck_40: key = (if v_274 then 2-proj-3-tuple(v_273) else caught-fail) in
        {813}let cs_35: cipherstate = (if v_274 then 1-proj-3-tuple(v_273) else caught-fail) in
        {814}let ss_40: symmetricstate = (if v_272 then catch-fail((if v_274 then symmetricstatepack(cs_35,ck_40,hash(h_35,re_9)) else fail-any)) else caught-fail) in
        {815}let v_275: bool = not-caught-fail(ss_40) in
        {816}let v_276: bitstring = (if v_275 then catch-fail(keypairunpack(e_16)) else caught-fail) in
        {817}let v_277: bool = (not-caught-fail(v_276) && success?(1-proj-2-tuple(v_276))) in
        {818}let my_private_key_5: key = (if v_277 then 2-proj-2-tuple(v_276) else caught-fail) in
        {819}let my_public_key_5: key = (if v_277 then 1-proj-2-tuple(v_276) else caught-fail) in
        {820}let input_key_material_6: key = (if v_275 then catch-fail((if v_277 then dhexp(my_private_key_5,re_9) else fail-any)) else caught-fail) in
        {821}let v_278: bool = not-caught-fail(input_key_material_6) in
        {822}let v_279: bitstring = (if v_278 then catch-fail(symmetricstateunpack(ss_40)) else caught-fail) in
        {823}let v_280: bool = (not-caught-fail(v_279) && success?(1-proj-3-tuple(v_279))) in
        {824}let h_36: bitstring = (if v_280 then 3-proj-3-tuple(v_279) else caught-fail) in
        {825}let ck_41: key = (if v_280 then 2-proj-3-tuple(v_279) else caught-fail) in
        {826}let cs_36: cipherstate = (if v_280 then 1-proj-3-tuple(v_279) else caught-fail) in
        {827}let output1_6: key = (if v_280 then hmac_hash1(ck_41,input_key_material_6) else caught-fail) in
        {828}let output2_6: key = (if v_280 then hmac_hash2(ck_41,input_key_material_6) else caught-fail) in
        {829}let output3_6: key = (if v_280 then hmac_hash3(ck_41,input_key_material_6) else caught-fail) in
        {830}let v_281: bitstring = (if v_280 then catch-fail((output1_6,output2_6,output3_6)) else caught-fail) in
        {831}let v_282: bool = (not-caught-fail(v_281) && success?(1-proj-3-tuple(v_281))) in
        {832}let output_5: key = (if v_282 then 3-proj-3-tuple(v_281) else caught-fail) in
        {833}let temp_k_5: key = (if v_282 then 2-proj-3-tuple(v_281) else caught-fail) in
        {834}let ck_42: key = (if v_282 then 1-proj-3-tuple(v_281) else caught-fail) in
        {835}let ss_41: symmetricstate = (if v_275 then catch-fail((if v_278 then (if v_280 then (if v_282 then symmetricstatepack(cipherstatepack(temp_k_5,minnonce),ck_42,h_36) else fail-any) else fail-any) else fail-any)) else caught-fail) in
        {836}let v_283: bool = not-caught-fail(ss_41) in
        {837}let v_284: bitstring = (if v_283 then catch-fail(keypairunpack(s_9)) else caught-fail) in
        {838}let v_285: bool = (not-caught-fail(v_284) && success?(1-proj-2-tuple(v_284))) in
        {839}let my_private_key_6: key = (if v_285 then 2-proj-2-tuple(v_284) else caught-fail) in
        {840}let my_public_key_6: key = (if v_285 then 1-proj-2-tuple(v_284) else caught-fail) in
        {841}let input_key_material_7: key = (if v_283 then catch-fail((if v_285 then dhexp(my_private_key_6,re_9) else fail-any)) else caught-fail) in
        {842}let v_286: bool = not-caught-fail(input_key_material_7) in
        {843}let v_287: bitstring = (if v_286 then catch-fail(symmetricstateunpack(ss_41)) else caught-fail) in
        {844}let v_288: bool = (not-caught-fail(v_287) && success?(1-proj-3-tuple(v_287))) in
        {845}let h_37: bitstring = (if v_288 then 3-proj-3-tuple(v_287) else caught-fail) in
        {846}let ck_43: key = (if v_288 then 2-proj-3-tuple(v_287) else caught-fail) in
        {847}let cs_37: cipherstate = (if v_288 then 1-proj-3-tuple(v_287) else caught-fail) in
        {848}let output1_7: key = (if v_288 then hmac_hash1(ck_43,input_key_material_7) else caught-fail) in
        {849}let output2_7: key = (if v_288 then hmac_hash2(ck_43,input_key_material_7) else caught-fail) in
        {850}let output3_7: key = (if v_288 then hmac_hash3(ck_43,input_key_material_7) else caught-fail) in
        {851}let v_289: bitstring = (if v_288 then catch-fail((output1_7,output2_7,output3_7)) else caught-fail) in
        {852}let v_290: bool = (not-caught-fail(v_289) && success?(1-proj-3-tuple(v_289))) in
        {853}let output_6: key = (if v_290 then 3-proj-3-tuple(v_289) else caught-fail) in
        {854}let temp_k_6: key = (if v_290 then 2-proj-3-tuple(v_289) else caught-fail) in
        {855}let ck_44: key = (if v_290 then 1-proj-3-tuple(v_289) else caught-fail) in
        {856}let ss_42: symmetricstate = (if v_283 then catch-fail((if v_286 then (if v_288 then (if v_290 then symmetricstatepack(cipherstatepack(temp_k_6,minnonce),ck_44,h_37) else fail-any) else fail-any) else fail-any)) else caught-fail) in
        {857}let v_291: bool = not-caught-fail(ss_42) in
        {858}let v_292: bitstring = (if v_291 then catch-fail(keypairunpack(m_9)) else caught-fail) in
        {859}let v_293: bool = (not-caught-fail(v_292) && success?(1-proj-2-tuple(v_292))) in
        {860}let my_private_key_7: key = (if v_293 then 2-proj-2-tuple(v_292) else caught-fail) in
        {861}let my_public_key_7: key = (if v_293 then 1-proj-2-tuple(v_292) else caught-fail) in
        {862}let input_key_material_8: key = (if v_291 then catch-fail((if v_293 then dhexp(my_private_key_7,re_9) else fail-any)) else caught-fail) in
        {863}let v_294: bool = not-caught-fail(input_key_material_8) in
        {864}let v_295: bitstring = (if v_294 then catch-fail(symmetricstateunpack(ss_42)) else caught-fail) in
        {865}let v_296: bool = (not-caught-fail(v_295) && success?(1-proj-3-tuple(v_295))) in
        {866}let h_38: bitstring = (if v_296 then 3-proj-3-tuple(v_295) else caught-fail) in
        {867}let ck_45: key = (if v_296 then 2-proj-3-tuple(v_295) else caught-fail) in
        {868}let cs_38: cipherstate = (if v_296 then 1-proj-3-tuple(v_295) else caught-fail) in
        {869}let output1_8: key = (if v_296 then hmac_hash1(ck_45,input_key_material_8) else caught-fail) in
        {870}let output2_8: key = (if v_296 then hmac_hash2(ck_45,input_key_material_8) else caught-fail) in
        {871}let output3_8: key = (if v_296 then hmac_hash3(ck_45,input_key_material_8) else caught-fail) in
        {872}let v_297: bitstring = (if v_296 then catch-fail((output1_8,output2_8,output3_8)) else caught-fail) in
        {873}let v_298: bool = (not-caught-fail(v_297) && success?(1-proj-3-tuple(v_297))) in
        {874}let output_7: key = (if v_298 then 3-proj-3-tuple(v_297) else caught-fail) in
        {875}let temp_k_7: key = (if v_298 then 2-proj-3-tuple(v_297) else caught-fail) in
        {876}let ck_46: key = (if v_298 then 1-proj-3-tuple(v_297) else caught-fail) in
        {877}let ss_43: symmetricstate = (if v_291 then catch-fail((if v_294 then (if v_296 then (if v_298 then symmetricstatepack(cipherstatepack(temp_k_7,minnonce),ck_46,h_38) else fail-any) else fail-any) else fail-any)) else caught-fail) in
        {878}let v_299: bool = not-caught-fail(ss_43) in
        {879}let v_300: bitstring = (if v_299 then catch-fail(symmetricstateunpack(ss_43)) else caught-fail) in
        {880}let v_301: bool = (not-caught-fail(v_300) && success?(1-proj-3-tuple(v_300))) in
        {881}let h_39: bitstring = (if v_301 then 3-proj-3-tuple(v_300) else caught-fail) in
        {882}let ck_47: key = (if v_301 then 2-proj-3-tuple(v_300) else caught-fail) in
        {883}let cs_39: cipherstate = (if v_301 then 1-proj-3-tuple(v_300) else caught-fail) in
        {884}let v_302: bitstring = (if v_301 then catch-fail(cipherstateunpack(cs_39)) else caught-fail) in
        {885}let v_303: bool = (not-caught-fail(v_302) && success?(1-proj-2-tuple(v_302))) in
        {886}let n_22: nonce = (if v_303 then 2-proj-2-tuple(v_302) else caught-fail) in
        {887}let k_24: key = (if v_303 then 1-proj-2-tuple(v_302) else caught-fail) in
        {888}let d_4: aead = (if v_303 then catch-fail(decrypt(k_24,n_22,h_39,ns_7)) else caught-fail) in
        {889}let v_304: bool = not-caught-fail(d_4) in
        {890}let v_305: bitstring = (if v_304 then catch-fail(aeadunpack(d_4)) else caught-fail) in
        {891}let v_306: bool = (not-caught-fail(v_305) && success?(1-proj-3-tuple(v_305))) in
        {892}let plaintext_14: bitstring = (if v_306 then 3-proj-3-tuple(v_305) else caught-fail) in
        {893}let adi_4: bitstring = (if v_306 then 2-proj-3-tuple(v_305) else caught-fail) in
        {894}let valid_10: bool = (if v_306 then 1-proj-3-tuple(v_305) else caught-fail) in
        {895}let n_23: nonce = (if v_306 then increment_nonce(n_22) else caught-fail) in
        {896}let v_307: bitstring = (if v_306 then catch-fail(cipherstateunpack(cs_39)) else caught-fail) in
        {897}let v_308: bool = (not-caught-fail(v_307) && success?(1-proj-2-tuple(v_307))) in
        {898}let o_11: nonce = (if v_308 then 2-proj-2-tuple(v_307) else caught-fail) in
        {899}let k_25: key = (if v_308 then 1-proj-2-tuple(v_307) else caught-fail) in
        {900}let csi_22: cipherstate = (if v_306 then catch-fail((if v_308 then cipherstatepack(k_25,n_23) else fail-any)) else caught-fail) in
        {901}let v_309: bool = not-caught-fail(csi_22) in
        {902}let v_310: bitstring = (if v_301 then catch-fail((if v_303 then (if v_304 then (if v_306 then (if v_309 then (csi_22,plaintext_14,valid_10) else fail-any) else fail-any) else fail-any) else fail-any)) else caught-fail) in
        {903}let v_311: bool = (not-caught-fail(v_310) && success?(1-proj-3-tuple(v_310))) in
        {904}let valid_11: bool = (if v_311 then 3-proj-3-tuple(v_310) else caught-fail) in
        {905}let plaintext_15: bitstring = (if v_311 then 2-proj-3-tuple(v_310) else caught-fail) in
        {906}let csi_23: cipherstate = (if v_311 then 1-proj-3-tuple(v_310) else caught-fail) in
        {907}let ss_44: symmetricstate = (if v_311 then symmetricstatepack(csi_23,ck_47,h_39) else caught-fail) in
        {908}let v_312: bitstring = (if v_311 then catch-fail(symmetricstateunpack(ss_44)) else caught-fail) in
        {909}let v_313: bool = (not-caught-fail(v_312) && success?(1-proj-3-tuple(v_312))) in
        {910}let h_40: bitstring = (if v_313 then 3-proj-3-tuple(v_312) else caught-fail) in
        {911}let ck_48: key = (if v_313 then 2-proj-3-tuple(v_312) else caught-fail) in
        {912}let cs_40: cipherstate = (if v_313 then 1-proj-3-tuple(v_312) else caught-fail) in
        {913}let ssi_12: symmetricstate = (if v_311 then catch-fail((if v_313 then symmetricstatepack(cs_40,ck_48,hash(h_40,ns_7)) else fail-any)) else caught-fail) in
        {914}let v_314: bool = not-caught-fail(ssi_12) in
        {915}let v_315: bitstring = (if v_299 then catch-fail((if v_301 then (if v_311 then (if v_314 then (ssi_12,plaintext_15,valid_11) else fail-any) else fail-any) else fail-any)) else caught-fail) in
        {916}let v_316: bool = (not-caught-fail(v_315) && success?(1-proj-3-tuple(v_315))) in
        {917}let valid1_4: bool = (if v_316 then 3-proj-3-tuple(v_315) else caught-fail) in
        {918}let ne_10: bitstring = (if v_316 then 2-proj-3-tuple(v_315) else caught-fail) in
        {919}let ss_45: symmetricstate = (if v_316 then 1-proj-3-tuple(v_315) else caught-fail) in
        {920}let rs_9: key = (if v_316 then ne_10 else caught-fail) in
        {921}let v_317: bitstring = (if v_316 then catch-fail(symmetricstateunpack(ss_45)) else caught-fail) in
        {922}let v_318: bool = (not-caught-fail(v_317) && success?(1-proj-3-tuple(v_317))) in
        {923}let h_41: bitstring = (if v_318 then 3-proj-3-tuple(v_317) else caught-fail) in
        {924}let ck_49: key = (if v_318 then 2-proj-3-tuple(v_317) else caught-fail) in
        {925}let cs_41: cipherstate = (if v_318 then 1-proj-3-tuple(v_317) else caught-fail) in
        {926}let v_319: bitstring = (if v_318 then catch-fail(cipherstateunpack(cs_41)) else caught-fail) in
        {927}let v_320: bool = (not-caught-fail(v_319) && success?(1-proj-2-tuple(v_319))) in
        {928}let n_24: nonce = (if v_320 then 2-proj-2-tuple(v_319) else caught-fail) in
        {929}let k_26: key = (if v_320 then 1-proj-2-tuple(v_319) else caught-fail) in
        {930}let d_5: aead = (if v_320 then catch-fail(decrypt(k_26,n_24,h_41,nm_7)) else caught-fail) in
        {931}let v_321: bool = not-caught-fail(d_5) in
        {932}let v_322: bitstring = (if v_321 then catch-fail(aeadunpack(d_5)) else caught-fail) in
        {933}let v_323: bool = (not-caught-fail(v_322) && success?(1-proj-3-tuple(v_322))) in
        {934}let plaintext_16: bitstring = (if v_323 then 3-proj-3-tuple(v_322) else caught-fail) in
        {935}let adi_5: bitstring = (if v_323 then 2-proj-3-tuple(v_322) else caught-fail) in
        {936}let valid_12: bool = (if v_323 then 1-proj-3-tuple(v_322) else caught-fail) in
        {937}let n_25: nonce = (if v_323 then increment_nonce(n_24) else caught-fail) in
        {938}let v_324: bitstring = (if v_323 then catch-fail(cipherstateunpack(cs_41)) else caught-fail) in
        {939}let v_325: bool = (not-caught-fail(v_324) && success?(1-proj-2-tuple(v_324))) in
        {940}let o_12: nonce = (if v_325 then 2-proj-2-tuple(v_324) else caught-fail) in
        {941}let k_27: key = (if v_325 then 1-proj-2-tuple(v_324) else caught-fail) in
        {942}let csi_24: cipherstate = (if v_323 then catch-fail((if v_325 then cipherstatepack(k_27,n_25) else fail-any)) else caught-fail) in
        {943}let v_326: bool = not-caught-fail(csi_24) in
        {944}let v_327: bitstring = (if v_318 then catch-fail((if v_320 then (if v_321 then (if v_323 then (if v_326 then (csi_24,plaintext_16,valid_12) else fail-any) else fail-any) else fail-any) else fail-any)) else caught-fail) in
        {945}let v_328: bool = (not-caught-fail(v_327) && success?(1-proj-3-tuple(v_327))) in
        {946}let valid_13: bool = (if v_328 then 3-proj-3-tuple(v_327) else caught-fail) in
        {947}let plaintext_17: bitstring = (if v_328 then 2-proj-3-tuple(v_327) else caught-fail) in
        {948}let csi_25: cipherstate = (if v_328 then 1-proj-3-tuple(v_327) else caught-fail) in
        {949}let ss_46: symmetricstate = (if v_328 then symmetricstatepack(csi_25,ck_49,h_41) else caught-fail) in
        {950}let v_329: bitstring = (if v_328 then catch-fail(symmetricstateunpack(ss_46)) else caught-fail) in
        {951}let v_330: bool = (not-caught-fail(v_329) && success?(1-proj-3-tuple(v_329))) in
        {952}let h_42: bitstring = (if v_330 then 3-proj-3-tuple(v_329) else caught-fail) in
        {953}let ck_50: key = (if v_330 then 2-proj-3-tuple(v_329) else caught-fail) in
        {954}let cs_42: cipherstate = (if v_330 then 1-proj-3-tuple(v_329) else caught-fail) in
        {955}let ssi_13: symmetricstate = (if v_328 then catch-fail((if v_330 then symmetricstatepack(cs_42,ck_50,hash(h_42,nm_7)) else fail-any)) else caught-fail) in
        {956}let v_331: bool = not-caught-fail(ssi_13) in
        {957}let v_332: bitstring = (if v_316 then catch-fail((if v_318 then (if v_328 then (if v_331 then (ssi_13,plaintext_17,valid_13) else fail-any) else fail-any) else fail-any)) else caught-fail) in
        {958}let v_333: bool = (not-caught-fail(v_332) && success?(1-proj-3-tuple(v_332))) in
        {959}let valid2_4: bool = (if v_333 then 3-proj-3-tuple(v_332) else caught-fail) in
        {960}let ne_11: bitstring = (if v_333 then 2-proj-3-tuple(v_332) else caught-fail) in
        {961}let ss_47: symmetricstate = (if v_333 then 1-proj-3-tuple(v_332) else caught-fail) in
        {962}let rm_9: key = (if v_333 then ne_11 else caught-fail) in
        {963}let v_334: bitstring = (if v_333 then catch-fail(keypairunpack(e_16)) else caught-fail) in
        {964}let v_335: bool = (not-caught-fail(v_334) && success?(1-proj-2-tuple(v_334))) in
        {965}let my_private_key_8: key = (if v_335 then 2-proj-2-tuple(v_334) else caught-fail) in
        {966}let my_public_key_8: key = (if v_335 then 1-proj-2-tuple(v_334) else caught-fail) in
        {967}let input_key_material_9: key = (if v_333 then catch-fail((if v_335 then dhexp(my_private_key_8,rs_9) else fail-any)) else caught-fail) in
        {968}let v_336: bool = not-caught-fail(input_key_material_9) in
        {969}let v_337: bitstring = (if v_336 then catch-fail(symmetricstateunpack(ss_47)) else caught-fail) in
        {970}let v_338: bool = (not-caught-fail(v_337) && success?(1-proj-3-tuple(v_337))) in
        {971}let h_43: bitstring = (if v_338 then 3-proj-3-tuple(v_337) else caught-fail) in
        {972}let ck_51: key = (if v_338 then 2-proj-3-tuple(v_337) else caught-fail) in
        {973}let cs_43: cipherstate = (if v_338 then 1-proj-3-tuple(v_337) else caught-fail) in
        {974}let output1_9: key = (if v_338 then hmac_hash1(ck_51,input_key_material_9) else caught-fail) in
        {975}let output2_9: key = (if v_338 then hmac_hash2(ck_51,input_key_material_9) else caught-fail) in
        {976}let output3_9: key = (if v_338 then hmac_hash3(ck_51,input_key_material_9) else caught-fail) in
        {977}let v_339: bitstring = (if v_338 then catch-fail((output1_9,output2_9,output3_9)) else caught-fail) in
        {978}let v_340: bool = (not-caught-fail(v_339) && success?(1-proj-3-tuple(v_339))) in
        {979}let output_8: key = (if v_340 then 3-proj-3-tuple(v_339) else caught-fail) in
        {980}let temp_k_8: key = (if v_340 then 2-proj-3-tuple(v_339) else caught-fail) in
        {981}let ck_52: key = (if v_340 then 1-proj-3-tuple(v_339) else caught-fail) in
        {982}let ss_48: symmetricstate = (if v_333 then catch-fail((if v_336 then (if v_338 then (if v_340 then symmetricstatepack(cipherstatepack(temp_k_8,minnonce),ck_52,h_43) else fail-any) else fail-any) else fail-any)) else caught-fail) in
        {983}let v_341: bool = not-caught-fail(ss_48) in
        {984}let v_342: bitstring = (if v_341 then catch-fail(keypairunpack(e_16)) else caught-fail) in
        {985}let v_343: bool = (not-caught-fail(v_342) && success?(1-proj-2-tuple(v_342))) in
        {986}let my_private_key_9: key = (if v_343 then 2-proj-2-tuple(v_342) else caught-fail) in
        {987}let my_public_key_9: key = (if v_343 then 1-proj-2-tuple(v_342) else caught-fail) in
        {988}let input_key_material_10: key = (if v_341 then catch-fail((if v_343 then dhexp(my_private_key_9,rm_9) else fail-any)) else caught-fail) in
        {989}let v_344: bool = not-caught-fail(input_key_material_10) in
        {990}let v_345: bitstring = (if v_344 then catch-fail(symmetricstateunpack(ss_48)) else caught-fail) in
        {991}let v_346: bool = (not-caught-fail(v_345) && success?(1-proj-3-tuple(v_345))) in
        {992}let h_44: bitstring = (if v_346 then 3-proj-3-tuple(v_345) else caught-fail) in
        {993}let ck_53: key = (if v_346 then 2-proj-3-tuple(v_345) else caught-fail) in
        {994}let cs_44: cipherstate = (if v_346 then 1-proj-3-tuple(v_345) else caught-fail) in
        {995}let output1_10: key = (if v_346 then hmac_hash1(ck_53,input_key_material_10) else caught-fail) in
        {996}let output2_10: key = (if v_346 then hmac_hash2(ck_53,input_key_material_10) else caught-fail) in
        {997}let output3_10: key = (if v_346 then hmac_hash3(ck_53,input_key_material_10) else caught-fail) in
        {998}let v_347: bitstring = (if v_346 then catch-fail((output1_10,output2_10,output3_10)) else caught-fail) in
        {999}let v_348: bool = (not-caught-fail(v_347) && success?(1-proj-3-tuple(v_347))) in
        {1000}let output_9: key = (if v_348 then 3-proj-3-tuple(v_347) else caught-fail) in
        {1001}let temp_k_9: key = (if v_348 then 2-proj-3-tuple(v_347) else caught-fail) in
        {1002}let ck_54: key = (if v_348 then 1-proj-3-tuple(v_347) else caught-fail) in
        {1003}let ss_49: symmetricstate = (if v_341 then catch-fail((if v_344 then (if v_346 then (if v_348 then symmetricstatepack(cipherstatepack(temp_k_9,minnonce),ck_54,h_44) else fail-any) else fail-any) else fail-any)) else caught-fail) in
        {1004}let v_349: bool = not-caught-fail(ss_49) in
        {1005}let v_350: bitstring = (if v_349 then catch-fail(symmetricstateunpack(ss_49)) else caught-fail) in
        {1006}let v_351: bool = (not-caught-fail(v_350) && success?(1-proj-3-tuple(v_350))) in
        {1007}let h_45: bitstring = (if v_351 then 3-proj-3-tuple(v_350) else caught-fail) in
        {1008}let ck_55: key = (if v_351 then 2-proj-3-tuple(v_350) else caught-fail) in
        {1009}let cs_45: cipherstate = (if v_351 then 1-proj-3-tuple(v_350) else caught-fail) in
        {1010}let v_352: bitstring = (if v_351 then catch-fail(cipherstateunpack(cs_45)) else caught-fail) in
        {1011}let v_353: bool = (not-caught-fail(v_352) && success?(1-proj-2-tuple(v_352))) in
        {1012}let n_26: nonce = (if v_353 then 2-proj-2-tuple(v_352) else caught-fail) in
        {1013}let k_28: key = (if v_353 then 1-proj-2-tuple(v_352) else caught-fail) in
        {1014}let d_6: aead = (if v_353 then catch-fail(decrypt(k_28,n_26,h_45,ciphertext_15)) else caught-fail) in
        {1015}let v_354: bool = not-caught-fail(d_6) in
        {1016}let v_355: bitstring = (if v_354 then catch-fail(aeadunpack(d_6)) else caught-fail) in
        {1017}let v_356: bool = (not-caught-fail(v_355) && success?(1-proj-3-tuple(v_355))) in
        {1018}let plaintext_18: bitstring = (if v_356 then 3-proj-3-tuple(v_355) else caught-fail) in
        {1019}let adi_6: bitstring = (if v_356 then 2-proj-3-tuple(v_355) else caught-fail) in
        {1020}let valid_14: bool = (if v_356 then 1-proj-3-tuple(v_355) else caught-fail) in
        {1021}let n_27: nonce = (if v_356 then increment_nonce(n_26) else caught-fail) in
        {1022}let v_357: bitstring = (if v_356 then catch-fail(cipherstateunpack(cs_45)) else caught-fail) in
        {1023}let v_358: bool = (not-caught-fail(v_357) && success?(1-proj-2-tuple(v_357))) in
        {1024}let o_13: nonce = (if v_358 then 2-proj-2-tuple(v_357) else caught-fail) in
        {1025}let k_29: key = (if v_358 then 1-proj-2-tuple(v_357) else caught-fail) in
        {1026}let csi_26: cipherstate = (if v_356 then catch-fail((if v_358 then cipherstatepack(k_29,n_27) else fail-any)) else caught-fail) in
        {1027}let v_359: bool = not-caught-fail(csi_26) in
        {1028}let v_360: bitstring = (if v_351 then catch-fail((if v_353 then (if v_354 then (if v_356 then (if v_359 then (csi_26,plaintext_18,valid_14) else fail-any) else fail-any) else fail-any) else fail-any)) else caught-fail) in
        {1029}let v_361: bool = (not-caught-fail(v_360) && success?(1-proj-3-tuple(v_360))) in
        {1030}let valid_15: bool = (if v_361 then 3-proj-3-tuple(v_360) else caught-fail) in
        {1031}let plaintext_19: bitstring = (if v_361 then 2-proj-3-tuple(v_360) else caught-fail) in
        {1032}let csi_27: cipherstate = (if v_361 then 1-proj-3-tuple(v_360) else caught-fail) in
        {1033}let ss_50: symmetricstate = (if v_361 then symmetricstatepack(csi_27,ck_55,h_45) else caught-fail) in
        {1034}let v_362: bitstring = (if v_361 then catch-fail(symmetricstateunpack(ss_50)) else caught-fail) in
        {1035}let v_363: bool = (not-caught-fail(v_362) && success?(1-proj-3-tuple(v_362))) in
        {1036}let h_46: bitstring = (if v_363 then 3-proj-3-tuple(v_362) else caught-fail) in
        {1037}let ck_56: key = (if v_363 then 2-proj-3-tuple(v_362) else caught-fail) in
        {1038}let cs_46: cipherstate = (if v_363 then 1-proj-3-tuple(v_362) else caught-fail) in
        {1039}let ssi_14: symmetricstate = (if v_361 then catch-fail((if v_363 then symmetricstatepack(cs_46,ck_56,hash(h_46,ciphertext_15)) else fail-any)) else caught-fail) in
        {1040}let v_364: bool = not-caught-fail(ssi_14) in
        {1041}let v_365: bitstring = (if v_349 then catch-fail((if v_351 then (if v_361 then (if v_364 then (ssi_14,plaintext_19,valid_15) else fail-any) else fail-any) else fail-any)) else caught-fail) in
        {1042}let v_366: bool = (not-caught-fail(v_365) && success?(1-proj-3-tuple(v_365))) in
        {1043}let valid3_1: bool = (if v_366 then 3-proj-3-tuple(v_365) else caught-fail) in
        {1044}let plaintext_20: bitstring = (if v_366 then 2-proj-3-tuple(v_365) else caught-fail) in
        {1045}let ss_51: symmetricstate = (if v_366 then 1-proj-3-tuple(v_365) else caught-fail) in
        {1046}let basis_8: key = (if v_366 then key_s(them_1) else caught-fail) in
        {1047}let public_key_8: key = (if v_366 then catch-fail(dhexp(basis_8,validkey(g))) else caught-fail) in
        {1048}let v_367: bool = not-caught-fail(public_key_8) in
        {1049}let basis_9: key = (if v_366 then key_m(them_1) else caught-fail) in
        {1050}let public_key_9: key = (if v_366 then catch-fail(dhexp(basis_9,validkey(g))) else caught-fail) in
        {1051}let v_368: bool = not-caught-fail(public_key_9) in
        {1052}let v_369: bool = (if v_366 then catch-fail(((valid1_4 && (valid2_4 && valid3_1)) && ((rs_9 = getpublickey((if v_367 then keypairpack(validkey(public_key_8),basis_8) else fail-any))) && (rm_9 = getpublickey((if v_368 then keypairpack(validkey(public_key_9),basis_9) else fail-any)))))) else caught-fail) in
        {1053}let hs_20: handshakestate = (if v_369 then handshakestatepack(ss_51,s_9,m_9,e_16,rs_9,rm_9,re_9,psk_7,initiator_6) else caught-fail) in
        {1054}let v_370: bitstring = (if v_369 then catch-fail(symmetricstateunpack(ss_51)) else caught-fail) in
        {1055}let v_371: bool = (not-caught-fail(v_370) && success?(1-proj-3-tuple(v_370))) in
        {1056}let h_47: bitstring = (if v_371 then 3-proj-3-tuple(v_370) else caught-fail) in
        {1057}let ck_57: key = (if v_371 then 2-proj-3-tuple(v_370) else caught-fail) in
        {1058}let cs_47: cipherstate = (if v_371 then 1-proj-3-tuple(v_370) else caught-fail) in
        {1059}let input_key_material_11: key = (if v_371 then zero else caught-fail) in
        {1060}let output1_11: key = (if v_371 then hmac_hash1(ck_57,input_key_material_11) else caught-fail) in
        {1061}let output2_11: key = (if v_371 then hmac_hash2(ck_57,input_key_material_11) else caught-fail) in
        {1062}let output3_11: key = (if v_371 then hmac_hash3(ck_57,input_key_material_11) else caught-fail) in
        {1063}let v_372: bitstring = (if v_371 then catch-fail((output1_11,output2_11,output3_11)) else caught-fail) in
        {1064}let v_373: bool = (not-caught-fail(v_372) && success?(1-proj-3-tuple(v_372))) in
        {1065}let temp_k3_1: key = (if v_373 then 3-proj-3-tuple(v_372) else caught-fail) in
        {1066}let temp_k2_1: key = (if v_373 then 2-proj-3-tuple(v_372) else caught-fail) in
        {1067}let temp_k1_1: key = (if v_373 then 1-proj-3-tuple(v_372) else caught-fail) in
        {1068}let cs1_5: cipherstate = (if v_373 then cipherstatepack(temp_k1_1,minnonce) else caught-fail) in
        {1069}let cs2_5: cipherstate = (if v_373 then cipherstatepack(temp_k2_1,minnonce) else caught-fail) in
        {1070}let v_374: bitstring = (if v_369 then catch-fail((if v_371 then (if v_373 then (ss_51,cs1_5,cs2_5) else fail-any) else fail-any)) else caught-fail) in
        {1071}let v_375: bool = (not-caught-fail(v_374) && success?(1-proj-3-tuple(v_374))) in
        {1072}let cs2_6: cipherstate = (if v_375 then 3-proj-3-tuple(v_374) else caught-fail) in
        {1073}let cs1_6: cipherstate = (if v_375 then 2-proj-3-tuple(v_374) else caught-fail) in
        {1074}let ssi_15: symmetricstate = (if v_375 then 1-proj-3-tuple(v_374) else caught-fail) in
        {1075}let (hs_21: handshakestate,plaintext_b_1: bitstring,valid_16: bool,cs1_7: cipherstate,cs2_7: cipherstate) = (if v_270 then (if v_272 then (if v_275 then (if v_283 then (if v_291 then (if v_299 then (if v_316 then (if v_333 then (if v_341 then (if v_349 then (if v_366 then (if undo-catch-fail(v_369) then (if v_375 then (hs_20,plaintext_20,true,cs1_6,cs2_6) else fail-any) else fail-any) else fail-any) else fail-any) else fail-any) else fail-any) else fail-any) else fail-any) else fail-any) else fail-any) else fail-any) else fail-any) else fail-any) in
        {1076}event RecvMsg(me_1,them_1,stagepack_b(sid_2),plaintext_b_1);
        {1077}insert statestore(me_1,them_1,sid_2,statepack_c(hs_21,cs1_7,cs2_7))
    ) | (
        {1079}!
        {1138}get statestore(=me_1,=them_1,=sid_2,statepack_c(hs_22: handshakestate,cs1_8: cipherstate,cs2_8: cipherstate)) in
        {1080}let hs_23: handshakestate = handshakestatesetcs(hs_22,cs1_8) in
        {1081}let payload_3: bitstring = msg_c(me_1,them_1,sid_2) in
        {1082}let v_376: bitstring = catch-fail(handshakestateunpack(hs_23)) in
        {1083}let v_377: bool = (not-caught-fail(v_376) && success?(1-proj-9-tuple(v_376))) in
        {1084}let initiator_7: bool = (if v_377 then 9-proj-9-tuple(v_376) else caught-fail) in
        {1085}let psk_8: key = (if v_377 then 8-proj-9-tuple(v_376) else caught-fail) in
        {1086}let re_10: key = (if v_377 then 7-proj-9-tuple(v_376) else caught-fail) in
        {1087}let rm_10: key = (if v_377 then 6-proj-9-tuple(v_376) else caught-fail) in
        {1088}let rs_10: key = (if v_377 then 5-proj-9-tuple(v_376) else caught-fail) in
        {1089}let e_17: keypair = (if v_377 then 4-proj-9-tuple(v_376) else caught-fail) in
        {1090}let m_10: keypair = (if v_377 then 3-proj-9-tuple(v_376) else caught-fail) in
        {1091}let s_10: keypair = (if v_377 then 2-proj-9-tuple(v_376) else caught-fail) in
        {1092}let ss_52: symmetricstate = (if v_377 then 1-proj-9-tuple(v_376) else caught-fail) in
        {1093}let v_378: bitstring = (if v_377 then catch-fail((empty,empty,empty,empty)) else caught-fail) in
        {1094}let v_379: bool = (not-caught-fail(v_378) && success?(1-proj-4-tuple(v_378))) in
        {1095}let ciphertext_16: bitstring = (if v_379 then 4-proj-4-tuple(v_378) else caught-fail) in
        {1096}let nm_8: bitstring = (if v_379 then 3-proj-4-tuple(v_378) else caught-fail) in
        {1097}let ns_8: bitstring = (if v_379 then 2-proj-4-tuple(v_378) else caught-fail) in
        {1098}let ne_12: bitstring = (if v_379 then 1-proj-4-tuple(v_378) else caught-fail) in
        {1099}let v_380: bitstring = (if v_379 then catch-fail(symmetricstateunpack(ss_52)) else caught-fail) in
        {1100}let v_381: bool = (not-caught-fail(v_380) && success?(1-proj-3-tuple(v_380))) in
        {1101}let h_48: bitstring = (if v_381 then 3-proj-3-tuple(v_380) else caught-fail) in
        {1102}let ck_58: key = (if v_381 then 2-proj-3-tuple(v_380) else caught-fail) in
        {1103}let cs_48: cipherstate = (if v_381 then 1-proj-3-tuple(v_380) else caught-fail) in
        {1104}let v_382: bitstring = (if v_381 then catch-fail(cipherstateunpack(cs_48)) else caught-fail) in
        {1105}let v_383: bool = (not-caught-fail(v_382) && success?(1-proj-2-tuple(v_382))) in
        {1106}let n_28: nonce = (if v_383 then 2-proj-2-tuple(v_382) else caught-fail) in
        {1107}let k_30: key = (if v_383 then 1-proj-2-tuple(v_382) else caught-fail) in
        {1108}let e_18: bitstring = (if v_383 then encrypt(k_30,n_28,h_48,payload_3) else caught-fail) in
        {1109}let n_29: nonce = (if v_383 then increment_nonce(n_28) else caught-fail) in
        {1110}let v_384: bitstring = (if v_383 then catch-fail(cipherstateunpack(cs_48)) else caught-fail) in
        {1111}let v_385: bool = (not-caught-fail(v_384) && success?(1-proj-2-tuple(v_384))) in
        {1112}let o_14: nonce = (if v_385 then 2-proj-2-tuple(v_384) else caught-fail) in
        {1113}let k_31: key = (if v_385 then 1-proj-2-tuple(v_384) else caught-fail) in
        {1114}let csi_28: cipherstate = (if v_383 then catch-fail((if v_385 then cipherstatepack(k_31,n_29) else fail-any)) else caught-fail) in
        {1115}let v_386: bool = not-caught-fail(csi_28) in
        {1116}let v_387: bitstring = (if v_381 then catch-fail((if v_383 then (if v_386 then (csi_28,e_18) else fail-any) else fail-any)) else caught-fail) in
        {1117}let v_388: bool = (not-caught-fail(v_387) && success?(1-proj-2-tuple(v_387))) in
        {1118}let ciphertext_17: bitstring = (if v_388 then 2-proj-2-tuple(v_387) else caught-fail) in
        {1119}let csi_29: cipherstate = (if v_388 then 1-proj-2-tuple(v_387) else caught-fail) in
        {1120}let ss_53: symmetricstate = (if v_388 then symmetricstatepack(csi_29,ck_58,h_48) else caught-fail) in
        {1121}let v_389: bitstring = (if v_388 then catch-fail(symmetricstateunpack(ss_53)) else caught-fail) in
        {1122}let v_390: bool = (not-caught-fail(v_389) && success?(1-proj-3-tuple(v_389))) in
        {1123}let h_49: bitstring = (if v_390 then 3-proj-3-tuple(v_389) else caught-fail) in
        {1124}let ck_59: key = (if v_390 then 2-proj-3-tuple(v_389) else caught-fail) in
        {1125}let cs_49: cipherstate = (if v_390 then 1-proj-3-tuple(v_389) else caught-fail) in
        {1126}let ssi_16: symmetricstate = (if v_388 then catch-fail((if v_390 then symmetricstatepack(cs_49,ck_59,hash(h_49,ciphertext_17)) else fail-any)) else caught-fail) in
        {1127}let v_391: bool = not-caught-fail(ssi_16) in
        {1128}let v_392: bitstring = (if v_379 then catch-fail((if v_381 then (if v_388 then (if v_391 then (ssi_16,ciphertext_17) else fail-any) else fail-any) else fail-any)) else caught-fail) in
        {1129}let v_393: bool = (not-caught-fail(v_392) && success?(1-proj-2-tuple(v_392))) in
        {1130}let ciphertext_18: bitstring = (if v_393 then 2-proj-2-tuple(v_392) else caught-fail) in
        {1131}let ss_54: symmetricstate = (if v_393 then 1-proj-2-tuple(v_392) else caught-fail) in
        {1132}let hs_24: handshakestate = (if v_393 then handshakestatepack(ss_54,s_10,m_10,e_17,rs_10,rm_10,re_10,psk_8,initiator_7) else caught-fail) in
        {1133}let message_buffer_3: bitstring = (if v_393 then concat4(ne_12,ns_8,nm_8,ciphertext_18) else caught-fail) in
        {1134}let (hs_25: handshakestate,message_c_1: bitstring) = (if v_377 then (if v_379 then (if v_393 then (hs_24,message_buffer_3) else fail-any) else fail-any) else fail-any) in
        {1135}event SendMsg(me_1,them_1,stagepack_c(sid_2),msg_c(me_1,them_1,sid_2));
        {1136}insert statestore(me_1,them_1,sid_2,statepack_d(hs_25,handshakestategetcs(hs_25),cs2_8));
        {1137}out(pub, message_c_1)
    ) | (
        {1139}!
        {1206}get statestore(=me_1,=them_1,=sid_2,statepack_d(hs_26: handshakestate,cs1_9: cipherstate,cs2_9: cipherstate)) in
        {1140}let hs_27: handshakestate = handshakestatesetcs(hs_26,cs2_9) in
        {1141}in(pub, message_d_1: bitstring);
        {1142}let v_394: bitstring = catch-fail(handshakestateunpack(hs_27)) in
        {1143}let v_395: bool = (not-caught-fail(v_394) && success?(1-proj-9-tuple(v_394))) in
        {1144}let initiator_8: bool = (if v_395 then 9-proj-9-tuple(v_394) else caught-fail) in
        {1145}let psk_9: key = (if v_395 then 8-proj-9-tuple(v_394) else caught-fail) in
        {1146}let re_11: key = (if v_395 then 7-proj-9-tuple(v_394) else caught-fail) in
        {1147}let rm_11: key = (if v_395 then 6-proj-9-tuple(v_394) else caught-fail) in
        {1148}let rs_11: key = (if v_395 then 5-proj-9-tuple(v_394) else caught-fail) in
        {1149}let e_19: keypair = (if v_395 then 4-proj-9-tuple(v_394) else caught-fail) in
        {1150}let m_11: keypair = (if v_395 then 3-proj-9-tuple(v_394) else caught-fail) in
        {1151}let s_11: keypair = (if v_395 then 2-proj-9-tuple(v_394) else caught-fail) in
        {1152}let ss_55: symmetricstate = (if v_395 then 1-proj-9-tuple(v_394) else caught-fail) in
        {1153}let v_396: bitstring = (if v_395 then catch-fail(deconcat4(message_d_1)) else caught-fail) in
        {1154}let v_397: bool = (not-caught-fail(v_396) && success?(1-proj-4-tuple(v_396))) in
        {1155}let ciphertext_19: bitstring = (if v_397 then 4-proj-4-tuple(v_396) else caught-fail) in
        {1156}let nm_9: bitstring = (if v_397 then 3-proj-4-tuple(v_396) else caught-fail) in
        {1157}let ns_9: bitstring = (if v_397 then 2-proj-4-tuple(v_396) else caught-fail) in
        {1158}let ne_13: bitstring = (if v_397 then 1-proj-4-tuple(v_396) else caught-fail) in
        {1159}let valid1_5: bool = (if v_397 then true else caught-fail) in
        {1160}let v_398: bitstring = (if v_397 then catch-fail(symmetricstateunpack(ss_55)) else caught-fail) in
        {1161}let v_399: bool = (not-caught-fail(v_398) && success?(1-proj-3-tuple(v_398))) in
        {1162}let h_50: bitstring = (if v_399 then 3-proj-3-tuple(v_398) else caught-fail) in
        {1163}let ck_60: key = (if v_399 then 2-proj-3-tuple(v_398) else caught-fail) in
        {1164}let cs_50: cipherstate = (if v_399 then 1-proj-3-tuple(v_398) else caught-fail) in
        {1165}let v_400: bitstring = (if v_399 then catch-fail(cipherstateunpack(cs_50)) else caught-fail) in
        {1166}let v_401: bool = (not-caught-fail(v_400) && success?(1-proj-2-tuple(v_400))) in
        {1167}let n_30: nonce = (if v_401 then 2-proj-2-tuple(v_400) else caught-fail) in
        {1168}let k_32: key = (if v_401 then 1-proj-2-tuple(v_400) else caught-fail) in
        {1169}let d_7: aead = (if v_401 then catch-fail(decrypt(k_32,n_30,h_50,ciphertext_19)) else caught-fail) in
        {1170}let v_402: bool = not-caught-fail(d_7) in
        {1171}let v_403: bitstring = (if v_402 then catch-fail(aeadunpack(d_7)) else caught-fail) in
        {1172}let v_404: bool = (not-caught-fail(v_403) && success?(1-proj-3-tuple(v_403))) in
        {1173}let plaintext_21: bitstring = (if v_404 then 3-proj-3-tuple(v_403) else caught-fail) in
        {1174}let adi_7: bitstring = (if v_404 then 2-proj-3-tuple(v_403) else caught-fail) in
        {1175}let valid_17: bool = (if v_404 then 1-proj-3-tuple(v_403) else caught-fail) in
        {1176}let n_31: nonce = (if v_404 then increment_nonce(n_30) else caught-fail) in
        {1177}let v_405: bitstring = (if v_404 then catch-fail(cipherstateunpack(cs_50)) else caught-fail) in
        {1178}let v_406: bool = (not-caught-fail(v_405) && success?(1-proj-2-tuple(v_405))) in
        {1179}let o_15: nonce = (if v_406 then 2-proj-2-tuple(v_405) else caught-fail) in
        {1180}let k_33: key = (if v_406 then 1-proj-2-tuple(v_405) else caught-fail) in
        {1181}let csi_30: cipherstate = (if v_404 then catch-fail((if v_406 then cipherstatepack(k_33,n_31) else fail-any)) else caught-fail) in
        {1182}let v_407: bool = not-caught-fail(csi_30) in
        {1183}let v_408: bitstring = (if v_399 then catch-fail((if v_401 then (if v_402 then (if v_404 then (if v_407 then (csi_30,plaintext_21,valid_17) else fail-any) else fail-any) else fail-any) else fail-any)) else caught-fail) in
        {1184}let v_409: bool = (not-caught-fail(v_408) && success?(1-proj-3-tuple(v_408))) in
        {1185}let valid_18: bool = (if v_409 then 3-proj-3-tuple(v_408) else caught-fail) in
        {1186}let plaintext_22: bitstring = (if v_409 then 2-proj-3-tuple(v_408) else caught-fail) in
        {1187}let csi_31: cipherstate = (if v_409 then 1-proj-3-tuple(v_408) else caught-fail) in
        {1188}let ss_56: symmetricstate = (if v_409 then symmetricstatepack(csi_31,ck_60,h_50) else caught-fail) in
        {1189}let v_410: bitstring = (if v_409 then catch-fail(symmetricstateunpack(ss_56)) else caught-fail) in
        {1190}let v_411: bool = (not-caught-fail(v_410) && success?(1-proj-3-tuple(v_410))) in
        {1191}let h_51: bitstring = (if v_411 then 3-proj-3-tuple(v_410) else caught-fail) in
        {1192}let ck_61: key = (if v_411 then 2-proj-3-tuple(v_410) else caught-fail) in
        {1193}let cs_51: cipherstate = (if v_411 then 1-proj-3-tuple(v_410) else caught-fail) in
        {1194}let ssi_17: symmetricstate = (if v_409 then catch-fail((if v_411 then symmetricstatepack(cs_51,ck_61,hash(h_51,ciphertext_19)) else fail-any)) else caught-fail) in
        {1195}let v_412: bool = not-caught-fail(ssi_17) in
        {1196}let v_413: bitstring = (if v_397 then catch-fail((if v_399 then (if v_409 then (if v_412 then (ssi_17,plaintext_22,valid_18) else fail-any) else fail-any) else fail-any)) else caught-fail) in
        {1197}let v_414: bool = (not-caught-fail(v_413) && success?(1-proj-3-tuple(v_413))) in
        {1198}let valid2_5: bool = (if v_414 then 3-proj-3-tuple(v_413) else caught-fail) in
        {1199}let plaintext_23: bitstring = (if v_414 then 2-proj-3-tuple(v_413) else caught-fail) in
        {1200}let ss_57: symmetricstate = (if v_414 then 1-proj-3-tuple(v_413) else caught-fail) in
        {1201}let v_415: bool = (if v_414 then catch-fail((valid1_5 && valid2_5)) else caught-fail) in
        {1202}let hs_28: handshakestate = (if v_415 then handshakestatepack(ss_57,s_11,m_11,e_19,rs_11,rm_11,re_11,psk_9,initiator_8) else caught-fail) in
        {1203}let (hs_29: handshakestate,plaintext_d_1: bitstring,valid_19: bool) = (if v_395 then (if v_397 then (if v_414 then (if undo-catch-fail(v_415) then (hs_28,plaintext_23,true) else fail-any) else fail-any) else fail-any) else fail-any) in
        {1204}event RecvMsg(me_1,them_1,stagepack_d(sid_2),plaintext_d_1);
        {1205}event RecvEnd(valid_19)
    ) | (
        {1207}event LeakS(phase0,me_1);
        {1208}event LeakM(phase0,me_1);
        {1209}out(pub, (key_s(me_1),key_m(me_1)))
    ) | (
        {1210}phase 1;
        {1211}event LeakS(phase1,me_1);
        {1212}event LeakM(phase1,me_1);
        {1213}out(pub, (key_s(me_1),key_m(me_1)))
    )
) | (
    {1214}let me_2: principal = bob in
    {1215}let them_2: principal = alice in
    {1216}let sid_3: sessionid = sid in
    {1217}let s_12: keypair = keypairpack(empty,empty) in
    {1218}let basis_10: key = key_m(me_2) in
    {1219}let public_key_10: key = catch-fail(dhexp(basis_10,validkey(g))) in
    {1220}let v_416: bool = not-caught-fail(public_key_10) in
    {1221}let m_12: keypair = (if v_416 then keypairpack(validkey(public_key_10),basis_10) else fail-any) in
    {1222}out(pub, (getpublickey(s_12),getpublickey(m_12)));
    (
        {1223}let e_20: keypair = keypairpack(empty,empty) in
        {1224}let rs_12: key = empty in
        {1225}let rm_12: key = empty in
        {1226}let re_12: key = empty in
        {1227}let prologue_2: bitstring = empty in
        {1228}let psk_10: key = empty in
        {1229}let protocol_name_2: bitstring = somename in
        {1230}let h_52: bitstring = hash(protocol_name_2,empty) in
        {1231}let ck_62: key = h_52 in
        {1232}let k_34: key = empty in
        {1233}let cs_52: cipherstate = cipherstatepack(k_34,minnonce) in
        {1234}let ss_58: symmetricstate = symmetricstatepack(cs_52,ck_62,h_52) in
        {1235}let v_417: bitstring = catch-fail(symmetricstateunpack(ss_58)) in
        {1236}let v_418: bool = (not-caught-fail(v_417) && success?(1-proj-3-tuple(v_417))) in
        {1237}let h_53: bitstring = (if v_418 then 3-proj-3-tuple(v_417) else caught-fail) in
        {1238}let ck_63: key = (if v_418 then 2-proj-3-tuple(v_417) else caught-fail) in
        {1239}let cs_53: cipherstate = (if v_418 then 1-proj-3-tuple(v_417) else caught-fail) in
        {1240}let ss_59: symmetricstate = catch-fail((if v_418 then symmetricstatepack(cs_53,ck_63,hash(h_53,prologue_2)) else fail-any)) in
        {1241}let v_419: bool = not-caught-fail(ss_59) in
        {1242}let hs_30: handshakestate = (if v_419 then handshakestatepack(ss_59,s_12,m_12,e_20,rs_12,rm_12,re_12,psk_10,false) else fail-any) in
        {1243}insert statestore(me_2,them_2,sid_3,statepack_a(hs_30))
    ) | (
        {1408}get statestore(=me_2,=them_2,=sid_3,statepack_a(hs_31: handshakestate)) in
        {1244}in(pub, message_a_2: bitstring);
        {1245}let v_420: bitstring = catch-fail(handshakestateunpack(hs_31)) in
        {1246}let v_421: bool = (not-caught-fail(v_420) && success?(1-proj-9-tuple(v_420))) in
        {1247}let initiator_9: bool = (if v_421 then 9-proj-9-tuple(v_420) else caught-fail) in
        {1248}let psk_11: key = (if v_421 then 8-proj-9-tuple(v_420) else caught-fail) in
        {1249}let re_13: key = (if v_421 then 7-proj-9-tuple(v_420) else caught-fail) in
        {1250}let rm_13: key = (if v_421 then 6-proj-9-tuple(v_420) else caught-fail) in
        {1251}let rs_13: key = (if v_421 then 5-proj-9-tuple(v_420) else caught-fail) in
        {1252}let e_21: keypair = (if v_421 then 4-proj-9-tuple(v_420) else caught-fail) in
        {1253}let m_13: keypair = (if v_421 then 3-proj-9-tuple(v_420) else caught-fail) in
        {1254}let s_13: keypair = (if v_421 then 2-proj-9-tuple(v_420) else caught-fail) in
        {1255}let ss_60: symmetricstate = (if v_421 then 1-proj-9-tuple(v_420) else caught-fail) in
        {1256}let v_422: bitstring = (if v_421 then catch-fail(deconcat4(message_a_2)) else caught-fail) in
        {1257}let v_423: bool = (not-caught-fail(v_422) && success?(1-proj-4-tuple(v_422))) in
        {1258}let ciphertext_20: bitstring = (if v_423 then 4-proj-4-tuple(v_422) else caught-fail) in
        {1259}let nm_10: bitstring = (if v_423 then 3-proj-4-tuple(v_422) else caught-fail) in
        {1260}let ns_10: bitstring = (if v_423 then 2-proj-4-tuple(v_422) else caught-fail) in
        {1261}let ne_14: bitstring = (if v_423 then 1-proj-4-tuple(v_422) else caught-fail) in
        {1262}let valid1_6: bool = (if v_423 then true else caught-fail) in
        {1263}let valid2_6: bool = (if v_423 then true else caught-fail) in
        {1264}let re_14: key = (if v_423 then ne_14 else caught-fail) in
        {1265}let v_424: bitstring = (if v_423 then catch-fail(symmetricstateunpack(ss_60)) else caught-fail) in
        {1266}let v_425: bool = (not-caught-fail(v_424) && success?(1-proj-3-tuple(v_424))) in
        {1267}let h_54: bitstring = (if v_425 then 3-proj-3-tuple(v_424) else caught-fail) in
        {1268}let ck_64: key = (if v_425 then 2-proj-3-tuple(v_424) else caught-fail) in
        {1269}let cs_54: cipherstate = (if v_425 then 1-proj-3-tuple(v_424) else caught-fail) in
        {1270}let ss_61: symmetricstate = (if v_423 then catch-fail((if v_425 then symmetricstatepack(cs_54,ck_64,hash(h_54,re_14)) else fail-any)) else caught-fail) in
        {1271}let v_426: bool = not-caught-fail(ss_61) in
        {1272}let v_427: bitstring = (if v_426 then catch-fail(symmetricstateunpack(ss_61)) else caught-fail) in
        {1273}let v_428: bool = (not-caught-fail(v_427) && success?(1-proj-3-tuple(v_427))) in
        {1274}let h_55: bitstring = (if v_428 then 3-proj-3-tuple(v_427) else caught-fail) in
        {1275}let ck_65: key = (if v_428 then 2-proj-3-tuple(v_427) else caught-fail) in
        {1276}let cs_55: cipherstate = (if v_428 then 1-proj-3-tuple(v_427) else caught-fail) in
        {1277}let v_429: bitstring = (if v_428 then catch-fail(cipherstateunpack(cs_55)) else caught-fail) in
        {1278}let v_430: bool = (not-caught-fail(v_429) && success?(1-proj-2-tuple(v_429))) in
        {1279}let n_32: nonce = (if v_430 then 2-proj-2-tuple(v_429) else caught-fail) in
        {1280}let k_35: key = (if v_430 then 1-proj-2-tuple(v_429) else caught-fail) in
        {1281}let d_8: aead = (if v_430 then catch-fail(decrypt(k_35,n_32,h_55,ns_10)) else caught-fail) in
        {1282}let v_431: bool = not-caught-fail(d_8) in
        {1283}let v_432: bitstring = (if v_431 then catch-fail(aeadunpack(d_8)) else caught-fail) in
        {1284}let v_433: bool = (not-caught-fail(v_432) && success?(1-proj-3-tuple(v_432))) in
        {1285}let plaintext_24: bitstring = (if v_433 then 3-proj-3-tuple(v_432) else caught-fail) in
        {1286}let adi_8: bitstring = (if v_433 then 2-proj-3-tuple(v_432) else caught-fail) in
        {1287}let valid_20: bool = (if v_433 then 1-proj-3-tuple(v_432) else caught-fail) in
        {1288}let n_33: nonce = (if v_433 then increment_nonce(n_32) else caught-fail) in
        {1289}let v_434: bitstring = (if v_433 then catch-fail(cipherstateunpack(cs_55)) else caught-fail) in
        {1290}let v_435: bool = (not-caught-fail(v_434) && success?(1-proj-2-tuple(v_434))) in
        {1291}let o_16: nonce = (if v_435 then 2-proj-2-tuple(v_434) else caught-fail) in
        {1292}let k_36: key = (if v_435 then 1-proj-2-tuple(v_434) else caught-fail) in
        {1293}let csi_32: cipherstate = (if v_433 then catch-fail((if v_435 then cipherstatepack(k_36,n_33) else fail-any)) else caught-fail) in
        {1294}let v_436: bool = not-caught-fail(csi_32) in
        {1295}let v_437: bitstring = (if v_428 then catch-fail((if v_430 then (if v_431 then (if v_433 then (if v_436 then (csi_32,plaintext_24,valid_20) else fail-any) else fail-any) else fail-any) else fail-any)) else caught-fail) in
        {1296}let v_438: bool = (not-caught-fail(v_437) && success?(1-proj-3-tuple(v_437))) in
        {1297}let valid_21: bool = (if v_438 then 3-proj-3-tuple(v_437) else caught-fail) in
        {1298}let plaintext_25: bitstring = (if v_438 then 2-proj-3-tuple(v_437) else caught-fail) in
        {1299}let csi_33: cipherstate = (if v_438 then 1-proj-3-tuple(v_437) else caught-fail) in
        {1300}let ss_62: symmetricstate = (if v_438 then symmetricstatepack(csi_33,ck_65,h_55) else caught-fail) in
        {1301}let v_439: bitstring = (if v_438 then catch-fail(symmetricstateunpack(ss_62)) else caught-fail) in
        {1302}let v_440: bool = (not-caught-fail(v_439) && success?(1-proj-3-tuple(v_439))) in
        {1303}let h_56: bitstring = (if v_440 then 3-proj-3-tuple(v_439) else caught-fail) in
        {1304}let ck_66: key = (if v_440 then 2-proj-3-tuple(v_439) else caught-fail) in
        {1305}let cs_56: cipherstate = (if v_440 then 1-proj-3-tuple(v_439) else caught-fail) in
        {1306}let ssi_18: symmetricstate = (if v_438 then catch-fail((if v_440 then symmetricstatepack(cs_56,ck_66,hash(h_56,ns_10)) else fail-any)) else caught-fail) in
        {1307}let v_441: bool = not-caught-fail(ssi_18) in
        {1308}let v_442: bitstring = (if v_426 then catch-fail((if v_428 then (if v_438 then (if v_441 then (ssi_18,plaintext_25,valid_21) else fail-any) else fail-any) else fail-any)) else caught-fail) in
        {1309}let v_443: bool = (not-caught-fail(v_442) && success?(1-proj-3-tuple(v_442))) in
        {1310}let valid1_7: bool = (if v_443 then 3-proj-3-tuple(v_442) else caught-fail) in
        {1311}let ne_15: bitstring = (if v_443 then 2-proj-3-tuple(v_442) else caught-fail) in
        {1312}let ss_63: symmetricstate = (if v_443 then 1-proj-3-tuple(v_442) else caught-fail) in
        {1313}let rs_14: key = (if v_443 then ne_15 else caught-fail) in
        {1314}let v_444: bitstring = (if v_443 then catch-fail(symmetricstateunpack(ss_63)) else caught-fail) in
        {1315}let v_445: bool = (not-caught-fail(v_444) && success?(1-proj-3-tuple(v_444))) in
        {1316}let h_57: bitstring = (if v_445 then 3-proj-3-tuple(v_444) else caught-fail) in
        {1317}let ck_67: key = (if v_445 then 2-proj-3-tuple(v_444) else caught-fail) in
        {1318}let cs_57: cipherstate = (if v_445 then 1-proj-3-tuple(v_444) else caught-fail) in
        {1319}let v_446: bitstring = (if v_445 then catch-fail(cipherstateunpack(cs_57)) else caught-fail) in
        {1320}let v_447: bool = (not-caught-fail(v_446) && success?(1-proj-2-tuple(v_446))) in
        {1321}let n_34: nonce = (if v_447 then 2-proj-2-tuple(v_446) else caught-fail) in
        {1322}let k_37: key = (if v_447 then 1-proj-2-tuple(v_446) else caught-fail) in
        {1323}let d_9: aead = (if v_447 then catch-fail(decrypt(k_37,n_34,h_57,nm_10)) else caught-fail) in
        {1324}let v_448: bool = not-caught-fail(d_9) in
        {1325}let v_449: bitstring = (if v_448 then catch-fail(aeadunpack(d_9)) else caught-fail) in
        {1326}let v_450: bool = (not-caught-fail(v_449) && success?(1-proj-3-tuple(v_449))) in
        {1327}let plaintext_26: bitstring = (if v_450 then 3-proj-3-tuple(v_449) else caught-fail) in
        {1328}let adi_9: bitstring = (if v_450 then 2-proj-3-tuple(v_449) else caught-fail) in
        {1329}let valid_22: bool = (if v_450 then 1-proj-3-tuple(v_449) else caught-fail) in
        {1330}let n_35: nonce = (if v_450 then increment_nonce(n_34) else caught-fail) in
        {1331}let v_451: bitstring = (if v_450 then catch-fail(cipherstateunpack(cs_57)) else caught-fail) in
        {1332}let v_452: bool = (not-caught-fail(v_451) && success?(1-proj-2-tuple(v_451))) in
        {1333}let o_17: nonce = (if v_452 then 2-proj-2-tuple(v_451) else caught-fail) in
        {1334}let k_38: key = (if v_452 then 1-proj-2-tuple(v_451) else caught-fail) in
        {1335}let csi_34: cipherstate = (if v_450 then catch-fail((if v_452 then cipherstatepack(k_38,n_35) else fail-any)) else caught-fail) in
        {1336}let v_453: bool = not-caught-fail(csi_34) in
        {1337}let v_454: bitstring = (if v_445 then catch-fail((if v_447 then (if v_448 then (if v_450 then (if v_453 then (csi_34,plaintext_26,valid_22) else fail-any) else fail-any) else fail-any) else fail-any)) else caught-fail) in
        {1338}let v_455: bool = (not-caught-fail(v_454) && success?(1-proj-3-tuple(v_454))) in
        {1339}let valid_23: bool = (if v_455 then 3-proj-3-tuple(v_454) else caught-fail) in
        {1340}let plaintext_27: bitstring = (if v_455 then 2-proj-3-tuple(v_454) else caught-fail) in
        {1341}let csi_35: cipherstate = (if v_455 then 1-proj-3-tuple(v_454) else caught-fail) in
        {1342}let ss_64: symmetricstate = (if v_455 then symmetricstatepack(csi_35,ck_67,h_57) else caught-fail) in
        {1343}let v_456: bitstring = (if v_455 then catch-fail(symmetricstateunpack(ss_64)) else caught-fail) in
        {1344}let v_457: bool = (not-caught-fail(v_456) && success?(1-proj-3-tuple(v_456))) in
        {1345}let h_58: bitstring = (if v_457 then 3-proj-3-tuple(v_456) else caught-fail) in
        {1346}let ck_68: key = (if v_457 then 2-proj-3-tuple(v_456) else caught-fail) in
        {1347}let cs_58: cipherstate = (if v_457 then 1-proj-3-tuple(v_456) else caught-fail) in
        {1348}let ssi_19: symmetricstate = (if v_455 then catch-fail((if v_457 then symmetricstatepack(cs_58,ck_68,hash(h_58,nm_10)) else fail-any)) else caught-fail) in
        {1349}let v_458: bool = not-caught-fail(ssi_19) in
        {1350}let v_459: bitstring = (if v_443 then catch-fail((if v_445 then (if v_455 then (if v_458 then (ssi_19,plaintext_27,valid_23) else fail-any) else fail-any) else fail-any)) else caught-fail) in
        {1351}let v_460: bool = (not-caught-fail(v_459) && success?(1-proj-3-tuple(v_459))) in
        {1352}let valid2_7: bool = (if v_460 then 3-proj-3-tuple(v_459) else caught-fail) in
        {1353}let ne_16: bitstring = (if v_460 then 2-proj-3-tuple(v_459) else caught-fail) in
        {1354}let ss_65: symmetricstate = (if v_460 then 1-proj-3-tuple(v_459) else caught-fail) in
        {1355}let rm_14: key = (if v_460 then ne_16 else caught-fail) in
        {1356}let v_461: bitstring = (if v_460 then catch-fail(symmetricstateunpack(ss_65)) else caught-fail) in
        {1357}let v_462: bool = (not-caught-fail(v_461) && success?(1-proj-3-tuple(v_461))) in
        {1358}let h_59: bitstring = (if v_462 then 3-proj-3-tuple(v_461) else caught-fail) in
        {1359}let ck_69: key = (if v_462 then 2-proj-3-tuple(v_461) else caught-fail) in
        {1360}let cs_59: cipherstate = (if v_462 then 1-proj-3-tuple(v_461) else caught-fail) in
        {1361}let v_463: bitstring = (if v_462 then catch-fail(cipherstateunpack(cs_59)) else caught-fail) in
        {1362}let v_464: bool = (not-caught-fail(v_463) && success?(1-proj-2-tuple(v_463))) in
        {1363}let n_36: nonce = (if v_464 then 2-proj-2-tuple(v_463) else caught-fail) in
        {1364}let k_39: key = (if v_464 then 1-proj-2-tuple(v_463) else caught-fail) in
        {1365}let d_10: aead = (if v_464 then catch-fail(decrypt(k_39,n_36,h_59,ciphertext_20)) else caught-fail) in
        {1366}let v_465: bool = not-caught-fail(d_10) in
        {1367}let v_466: bitstring = (if v_465 then catch-fail(aeadunpack(d_10)) else caught-fail) in
        {1368}let v_467: bool = (not-caught-fail(v_466) && success?(1-proj-3-tuple(v_466))) in
        {1369}let plaintext_28: bitstring = (if v_467 then 3-proj-3-tuple(v_466) else caught-fail) in
        {1370}let adi_10: bitstring = (if v_467 then 2-proj-3-tuple(v_466) else caught-fail) in
        {1371}let valid_24: bool = (if v_467 then 1-proj-3-tuple(v_466) else caught-fail) in
        {1372}let n_37: nonce = (if v_467 then increment_nonce(n_36) else caught-fail) in
        {1373}let v_468: bitstring = (if v_467 then catch-fail(cipherstateunpack(cs_59)) else caught-fail) in
        {1374}let v_469: bool = (not-caught-fail(v_468) && success?(1-proj-2-tuple(v_468))) in
        {1375}let o_18: nonce = (if v_469 then 2-proj-2-tuple(v_468) else caught-fail) in
        {1376}let k_40: key = (if v_469 then 1-proj-2-tuple(v_468) else caught-fail) in
        {1377}let csi_36: cipherstate = (if v_467 then catch-fail((if v_469 then cipherstatepack(k_40,n_37) else fail-any)) else caught-fail) in
        {1378}let v_470: bool = not-caught-fail(csi_36) in
        {1379}let v_471: bitstring = (if v_462 then catch-fail((if v_464 then (if v_465 then (if v_467 then (if v_470 then (csi_36,plaintext_28,valid_24) else fail-any) else fail-any) else fail-any) else fail-any)) else caught-fail) in
        {1380}let v_472: bool = (not-caught-fail(v_471) && success?(1-proj-3-tuple(v_471))) in
        {1381}let valid_25: bool = (if v_472 then 3-proj-3-tuple(v_471) else caught-fail) in
        {1382}let plaintext_29: bitstring = (if v_472 then 2-proj-3-tuple(v_471) else caught-fail) in
        {1383}let csi_37: cipherstate = (if v_472 then 1-proj-3-tuple(v_471) else caught-fail) in
        {1384}let ss_66: symmetricstate = (if v_472 then symmetricstatepack(csi_37,ck_69,h_59) else caught-fail) in
        {1385}let v_473: bitstring = (if v_472 then catch-fail(symmetricstateunpack(ss_66)) else caught-fail) in
        {1386}let v_474: bool = (not-caught-fail(v_473) && success?(1-proj-3-tuple(v_473))) in
        {1387}let h_60: bitstring = (if v_474 then 3-proj-3-tuple(v_473) else caught-fail) in
        {1388}let ck_70: key = (if v_474 then 2-proj-3-tuple(v_473) else caught-fail) in
        {1389}let cs_60: cipherstate = (if v_474 then 1-proj-3-tuple(v_473) else caught-fail) in
        {1390}let ssi_20: symmetricstate = (if v_472 then catch-fail((if v_474 then symmetricstatepack(cs_60,ck_70,hash(h_60,ciphertext_20)) else fail-any)) else caught-fail) in
        {1391}let v_475: bool = not-caught-fail(ssi_20) in
        {1392}let v_476: bitstring = (if v_460 then catch-fail((if v_462 then (if v_472 then (if v_475 then (ssi_20,plaintext_29,valid_25) else fail-any) else fail-any) else fail-any)) else caught-fail) in
        {1393}let v_477: bool = (not-caught-fail(v_476) && success?(1-proj-3-tuple(v_476))) in
        {1394}let valid3_2: bool = (if v_477 then 3-proj-3-tuple(v_476) else caught-fail) in
        {1395}let plaintext_30: bitstring = (if v_477 then 2-proj-3-tuple(v_476) else caught-fail) in
        {1396}let ss_67: symmetricstate = (if v_477 then 1-proj-3-tuple(v_476) else caught-fail) in
        {1397}let basis_11: key = (if v_477 then key_s(them_2) else caught-fail) in
        {1398}let public_key_11: key = (if v_477 then catch-fail(dhexp(basis_11,validkey(g))) else caught-fail) in
        {1399}let v_478: bool = not-caught-fail(public_key_11) in
        {1400}let basis_12: key = (if v_477 then key_m(them_2) else caught-fail) in
        {1401}let public_key_12: key = (if v_477 then catch-fail(dhexp(basis_12,validkey(g))) else caught-fail) in
        {1402}let v_479: bool = not-caught-fail(public_key_12) in
        {1403}let v_480: bool = (if v_477 then catch-fail(((valid1_7 && (valid2_7 && valid3_2)) && ((rs_14 = getpublickey((if v_478 then keypairpack(validkey(public_key_11),basis_11) else fail-any))) && (rm_14 = getpublickey((if v_479 then keypairpack(validkey(public_key_12),basis_12) else fail-any)))))) else caught-fail) in
        {1404}let hs_32: handshakestate = (if v_480 then handshakestatepack(ss_67,s_13,m_13,e_21,rs_14,rm_14,re_14,psk_11,initiator_9) else caught-fail) in
        {1405}let (hs_33: handshakestate,plaintext_a: bitstring,valid_26: bool) = (if v_421 then (if v_423 then (if v_426 then (if v_443 then (if v_460 then (if v_477 then (if undo-catch-fail(v_480) then (hs_32,plaintext_30,true) else fail-any) else fail-any) else fail-any) else fail-any) else fail-any) else fail-any) else fail-any) in
        {1406}event RecvMsg(me_2,them_2,stagepack_a(sid_3),plaintext_a);
        {1407}insert statestore(me_2,them_2,sid_3,statepack_b(hs_33))
    ) | (
        {1719}get statestore(=me_2,=them_2,=sid_3,statepack_b(hs_34: handshakestate)) in
        {1409}let payload_4: bitstring = msg_b(me_2,them_2,sid_3) in
        {1410}let v_481: bitstring = catch-fail(handshakestateunpack(hs_34)) in
        {1411}let v_482: bool = (not-caught-fail(v_481) && success?(1-proj-9-tuple(v_481))) in
        {1412}let initiator_10: bool = (if v_482 then 9-proj-9-tuple(v_481) else caught-fail) in
        {1413}let psk_12: key = (if v_482 then 8-proj-9-tuple(v_481) else caught-fail) in
        {1414}let re_15: key = (if v_482 then 7-proj-9-tuple(v_481) else caught-fail) in
        {1415}let rm_15: key = (if v_482 then 6-proj-9-tuple(v_481) else caught-fail) in
        {1416}let rs_15: key = (if v_482 then 5-proj-9-tuple(v_481) else caught-fail) in
        {1417}let e_22: keypair = (if v_482 then 4-proj-9-tuple(v_481) else caught-fail) in
        {1418}let m_14: keypair = (if v_482 then 3-proj-9-tuple(v_481) else caught-fail) in
        {1419}let s_14: keypair = (if v_482 then 2-proj-9-tuple(v_481) else caught-fail) in
        {1420}let ss_68: symmetricstate = (if v_482 then 1-proj-9-tuple(v_481) else caught-fail) in
        {1421}let v_483: bitstring = (if v_482 then catch-fail((empty,empty,empty,empty)) else caught-fail) in
        {1422}let v_484: bool = (not-caught-fail(v_483) && success?(1-proj-4-tuple(v_483))) in
        {1423}let ciphertext_21: bitstring = (if v_484 then 4-proj-4-tuple(v_483) else caught-fail) in
        {1424}let nm_11: bitstring = (if v_484 then 3-proj-4-tuple(v_483) else caught-fail) in
        {1425}let ns_11: bitstring = (if v_484 then 2-proj-4-tuple(v_483) else caught-fail) in
        {1426}let ne_17: bitstring = (if v_484 then 1-proj-4-tuple(v_483) else caught-fail) in
        {1427}let basis_13: key = (if v_484 then key_e(me_2,them_2,sid_3) else caught-fail) in
        {1428}let public_key_13: key = (if v_484 then catch-fail(dhexp(basis_13,validkey(g))) else caught-fail) in
        {1429}let v_485: bool = not-caught-fail(public_key_13) in
        {1430}let e_23: keypair = (if v_484 then catch-fail((if v_485 then keypairpack(validkey(public_key_13),basis_13) else fail-any)) else caught-fail) in
        {1431}let v_486: bool = not-caught-fail(e_23) in
        {1432}let ne_18: bitstring = (if v_486 then catch-fail(getpublickey(e_23)) else caught-fail) in
        {1433}let v_487: bool = not-caught-fail(ne_18) in
        {1434}let v_488: bitstring = (if v_487 then catch-fail(symmetricstateunpack(ss_68)) else caught-fail) in
        {1435}let v_489: bool = (not-caught-fail(v_488) && success?(1-proj-3-tuple(v_488))) in
        {1436}let h_61: bitstring = (if v_489 then 3-proj-3-tuple(v_488) else caught-fail) in
        {1437}let ck_71: key = (if v_489 then 2-proj-3-tuple(v_488) else caught-fail) in
        {1438}let cs_61: cipherstate = (if v_489 then 1-proj-3-tuple(v_488) else caught-fail) in
        {1439}let ss_69: symmetricstate = (if v_487 then catch-fail((if v_489 then symmetricstatepack(cs_61,ck_71,hash(h_61,ne_18)) else fail-any)) else caught-fail) in
        {1440}let v_490: bool = not-caught-fail(ss_69) in
        {1441}let v_491: bitstring = (if v_490 then catch-fail(keypairunpack(e_23)) else caught-fail) in
        {1442}let v_492: bool = (not-caught-fail(v_491) && success?(1-proj-2-tuple(v_491))) in
        {1443}let my_private_key_10: key = (if v_492 then 2-proj-2-tuple(v_491) else caught-fail) in
        {1444}let my_public_key_10: key = (if v_492 then 1-proj-2-tuple(v_491) else caught-fail) in
        {1445}let input_key_material_12: key = (if v_490 then catch-fail((if v_492 then dhexp(my_private_key_10,re_15) else fail-any)) else caught-fail) in
        {1446}let v_493: bool = not-caught-fail(input_key_material_12) in
        {1447}let v_494: bitstring = (if v_493 then catch-fail(symmetricstateunpack(ss_69)) else caught-fail) in
        {1448}let v_495: bool = (not-caught-fail(v_494) && success?(1-proj-3-tuple(v_494))) in
        {1449}let h_62: bitstring = (if v_495 then 3-proj-3-tuple(v_494) else caught-fail) in
        {1450}let ck_72: key = (if v_495 then 2-proj-3-tuple(v_494) else caught-fail) in
        {1451}let cs_62: cipherstate = (if v_495 then 1-proj-3-tuple(v_494) else caught-fail) in
        {1452}let output1_12: key = (if v_495 then hmac_hash1(ck_72,input_key_material_12) else caught-fail) in
        {1453}let output2_12: key = (if v_495 then hmac_hash2(ck_72,input_key_material_12) else caught-fail) in
        {1454}let output3_12: key = (if v_495 then hmac_hash3(ck_72,input_key_material_12) else caught-fail) in
        {1455}let v_496: bitstring = (if v_495 then catch-fail((output1_12,output2_12,output3_12)) else caught-fail) in
        {1456}let v_497: bool = (not-caught-fail(v_496) && success?(1-proj-3-tuple(v_496))) in
        {1457}let output_10: key = (if v_497 then 3-proj-3-tuple(v_496) else caught-fail) in
        {1458}let temp_k_10: key = (if v_497 then 2-proj-3-tuple(v_496) else caught-fail) in
        {1459}let ck_73: key = (if v_497 then 1-proj-3-tuple(v_496) else caught-fail) in
        {1460}let ss_70: symmetricstate = (if v_490 then catch-fail((if v_493 then (if v_495 then (if v_497 then symmetricstatepack(cipherstatepack(temp_k_10,minnonce),ck_73,h_62) else fail-any) else fail-any) else fail-any)) else caught-fail) in
        {1461}let v_498: bool = not-caught-fail(ss_70) in
        {1462}let v_499: bitstring = (if v_498 then catch-fail(keypairunpack(e_23)) else caught-fail) in
        {1463}let v_500: bool = (not-caught-fail(v_499) && success?(1-proj-2-tuple(v_499))) in
        {1464}let my_private_key_11: key = (if v_500 then 2-proj-2-tuple(v_499) else caught-fail) in
        {1465}let my_public_key_11: key = (if v_500 then 1-proj-2-tuple(v_499) else caught-fail) in
        {1466}let input_key_material_13: key = (if v_498 then catch-fail((if v_500 then dhexp(my_private_key_11,rs_15) else fail-any)) else caught-fail) in
        {1467}let v_501: bool = not-caught-fail(input_key_material_13) in
        {1468}let v_502: bitstring = (if v_501 then catch-fail(symmetricstateunpack(ss_70)) else caught-fail) in
        {1469}let v_503: bool = (not-caught-fail(v_502) && success?(1-proj-3-tuple(v_502))) in
        {1470}let h_63: bitstring = (if v_503 then 3-proj-3-tuple(v_502) else caught-fail) in
        {1471}let ck_74: key = (if v_503 then 2-proj-3-tuple(v_502) else caught-fail) in
        {1472}let cs_63: cipherstate = (if v_503 then 1-proj-3-tuple(v_502) else caught-fail) in
        {1473}let output1_13: key = (if v_503 then hmac_hash1(ck_74,input_key_material_13) else caught-fail) in
        {1474}let output2_13: key = (if v_503 then hmac_hash2(ck_74,input_key_material_13) else caught-fail) in
        {1475}let output3_13: key = (if v_503 then hmac_hash3(ck_74,input_key_material_13) else caught-fail) in
        {1476}let v_504: bitstring = (if v_503 then catch-fail((output1_13,output2_13,output3_13)) else caught-fail) in
        {1477}let v_505: bool = (not-caught-fail(v_504) && success?(1-proj-3-tuple(v_504))) in
        {1478}let output_11: key = (if v_505 then 3-proj-3-tuple(v_504) else caught-fail) in
        {1479}let temp_k_11: key = (if v_505 then 2-proj-3-tuple(v_504) else caught-fail) in
        {1480}let ck_75: key = (if v_505 then 1-proj-3-tuple(v_504) else caught-fail) in
        {1481}let ss_71: symmetricstate = (if v_498 then catch-fail((if v_501 then (if v_503 then (if v_505 then symmetricstatepack(cipherstatepack(temp_k_11,minnonce),ck_75,h_63) else fail-any) else fail-any) else fail-any)) else caught-fail) in
        {1482}let v_506: bool = not-caught-fail(ss_71) in
        {1483}let v_507: bitstring = (if v_506 then catch-fail(keypairunpack(e_23)) else caught-fail) in
        {1484}let v_508: bool = (not-caught-fail(v_507) && success?(1-proj-2-tuple(v_507))) in
        {1485}let my_private_key_12: key = (if v_508 then 2-proj-2-tuple(v_507) else caught-fail) in
        {1486}let my_public_key_12: key = (if v_508 then 1-proj-2-tuple(v_507) else caught-fail) in
        {1487}let input_key_material_14: key = (if v_506 then catch-fail((if v_508 then dhexp(my_private_key_12,rm_15) else fail-any)) else caught-fail) in
        {1488}let v_509: bool = not-caught-fail(input_key_material_14) in
        {1489}let v_510: bitstring = (if v_509 then catch-fail(symmetricstateunpack(ss_71)) else caught-fail) in
        {1490}let v_511: bool = (not-caught-fail(v_510) && success?(1-proj-3-tuple(v_510))) in
        {1491}let h_64: bitstring = (if v_511 then 3-proj-3-tuple(v_510) else caught-fail) in
        {1492}let ck_76: key = (if v_511 then 2-proj-3-tuple(v_510) else caught-fail) in
        {1493}let cs_64: cipherstate = (if v_511 then 1-proj-3-tuple(v_510) else caught-fail) in
        {1494}let output1_14: key = (if v_511 then hmac_hash1(ck_76,input_key_material_14) else caught-fail) in
        {1495}let output2_14: key = (if v_511 then hmac_hash2(ck_76,input_key_material_14) else caught-fail) in
        {1496}let output3_14: key = (if v_511 then hmac_hash3(ck_76,input_key_material_14) else caught-fail) in
        {1497}let v_512: bitstring = (if v_511 then catch-fail((output1_14,output2_14,output3_14)) else caught-fail) in
        {1498}let v_513: bool = (not-caught-fail(v_512) && success?(1-proj-3-tuple(v_512))) in
        {1499}let output_12: key = (if v_513 then 3-proj-3-tuple(v_512) else caught-fail) in
        {1500}let temp_k_12: key = (if v_513 then 2-proj-3-tuple(v_512) else caught-fail) in
        {1501}let ck_77: key = (if v_513 then 1-proj-3-tuple(v_512) else caught-fail) in
        {1502}let ss_72: symmetricstate = (if v_506 then catch-fail((if v_509 then (if v_511 then (if v_513 then symmetricstatepack(cipherstatepack(temp_k_12,minnonce),ck_77,h_64) else fail-any) else fail-any) else fail-any)) else caught-fail) in
        {1503}let v_514: bool = not-caught-fail(ss_72) in
        {1504}let basis_14: key = (if v_514 then key_s(me_2) else caught-fail) in
        {1505}let public_key_14: key = (if v_514 then catch-fail(dhexp(basis_14,validkey(g))) else caught-fail) in
        {1506}let v_515: bool = not-caught-fail(public_key_14) in
        {1507}let s_15: keypair = (if v_514 then catch-fail((if v_515 then keypairpack(validkey(public_key_14),basis_14) else fail-any)) else caught-fail) in
        {1508}let v_516: bool = not-caught-fail(s_15) in
        {1509}let plaintext_31: bitstring = (if v_516 then catch-fail(getpublickey(s_15)) else caught-fail) in
        {1510}let v_517: bool = not-caught-fail(plaintext_31) in
        {1511}let v_518: bitstring = (if v_517 then catch-fail(symmetricstateunpack(ss_72)) else caught-fail) in
        {1512}let v_519: bool = (not-caught-fail(v_518) && success?(1-proj-3-tuple(v_518))) in
        {1513}let h_65: bitstring = (if v_519 then 3-proj-3-tuple(v_518) else caught-fail) in
        {1514}let ck_78: key = (if v_519 then 2-proj-3-tuple(v_518) else caught-fail) in
        {1515}let cs_65: cipherstate = (if v_519 then 1-proj-3-tuple(v_518) else caught-fail) in
        {1516}let v_520: bitstring = (if v_519 then catch-fail(cipherstateunpack(cs_65)) else caught-fail) in
        {1517}let v_521: bool = (not-caught-fail(v_520) && success?(1-proj-2-tuple(v_520))) in
        {1518}let n_38: nonce = (if v_521 then 2-proj-2-tuple(v_520) else caught-fail) in
        {1519}let k_41: key = (if v_521 then 1-proj-2-tuple(v_520) else caught-fail) in
        {1520}let e_24: bitstring = (if v_521 then encrypt(k_41,n_38,h_65,plaintext_31) else caught-fail) in
        {1521}let n_39: nonce = (if v_521 then increment_nonce(n_38) else caught-fail) in
        {1522}let v_522: bitstring = (if v_521 then catch-fail(cipherstateunpack(cs_65)) else caught-fail) in
        {1523}let v_523: bool = (not-caught-fail(v_522) && success?(1-proj-2-tuple(v_522))) in
        {1524}let o_19: nonce = (if v_523 then 2-proj-2-tuple(v_522) else caught-fail) in
        {1525}let k_42: key = (if v_523 then 1-proj-2-tuple(v_522) else caught-fail) in
        {1526}let csi_38: cipherstate = (if v_521 then catch-fail((if v_523 then cipherstatepack(k_42,n_39) else fail-any)) else caught-fail) in
        {1527}let v_524: bool = not-caught-fail(csi_38) in
        {1528}let v_525: bitstring = (if v_519 then catch-fail((if v_521 then (if v_524 then (csi_38,e_24) else fail-any) else fail-any)) else caught-fail) in
        {1529}let v_526: bool = (not-caught-fail(v_525) && success?(1-proj-2-tuple(v_525))) in
        {1530}let ciphertext_22: bitstring = (if v_526 then 2-proj-2-tuple(v_525) else caught-fail) in
        {1531}let csi_39: cipherstate = (if v_526 then 1-proj-2-tuple(v_525) else caught-fail) in
        {1532}let ss_73: symmetricstate = (if v_526 then symmetricstatepack(csi_39,ck_78,h_65) else caught-fail) in
        {1533}let v_527: bitstring = (if v_526 then catch-fail(symmetricstateunpack(ss_73)) else caught-fail) in
        {1534}let v_528: bool = (not-caught-fail(v_527) && success?(1-proj-3-tuple(v_527))) in
        {1535}let h_66: bitstring = (if v_528 then 3-proj-3-tuple(v_527) else caught-fail) in
        {1536}let ck_79: key = (if v_528 then 2-proj-3-tuple(v_527) else caught-fail) in
        {1537}let cs_66: cipherstate = (if v_528 then 1-proj-3-tuple(v_527) else caught-fail) in
        {1538}let ssi_21: symmetricstate = (if v_526 then catch-fail((if v_528 then symmetricstatepack(cs_66,ck_79,hash(h_66,ciphertext_22)) else fail-any)) else caught-fail) in
        {1539}let v_529: bool = not-caught-fail(ssi_21) in
        {1540}let v_530: bitstring = (if v_516 then catch-fail((if v_517 then (if v_519 then (if v_526 then (if v_529 then (ssi_21,ciphertext_22) else fail-any) else fail-any) else fail-any) else fail-any)) else caught-fail) in
        {1541}let v_531: bool = (not-caught-fail(v_530) && success?(1-proj-2-tuple(v_530))) in
        {1542}let ns_12: bitstring = (if v_531 then 2-proj-2-tuple(v_530) else caught-fail) in
        {1543}let ss_74: symmetricstate = (if v_531 then 1-proj-2-tuple(v_530) else caught-fail) in
        {1544}let basis_15: key = (if v_531 then key_m(me_2) else caught-fail) in
        {1545}let public_key_15: key = (if v_531 then catch-fail(dhexp(basis_15,validkey(g))) else caught-fail) in
        {1546}let v_532: bool = not-caught-fail(public_key_15) in
        {1547}let m_15: keypair = (if v_531 then catch-fail((if v_532 then keypairpack(validkey(public_key_15),basis_15) else fail-any)) else caught-fail) in
        {1548}let v_533: bool = not-caught-fail(m_15) in
        {1549}let plaintext_32: bitstring = (if v_533 then catch-fail(getpublickey(m_15)) else caught-fail) in
        {1550}let v_534: bool = not-caught-fail(plaintext_32) in
        {1551}let v_535: bitstring = (if v_534 then catch-fail(symmetricstateunpack(ss_74)) else caught-fail) in
        {1552}let v_536: bool = (not-caught-fail(v_535) && success?(1-proj-3-tuple(v_535))) in
        {1553}let h_67: bitstring = (if v_536 then 3-proj-3-tuple(v_535) else caught-fail) in
        {1554}let ck_80: key = (if v_536 then 2-proj-3-tuple(v_535) else caught-fail) in
        {1555}let cs_67: cipherstate = (if v_536 then 1-proj-3-tuple(v_535) else caught-fail) in
        {1556}let v_537: bitstring = (if v_536 then catch-fail(cipherstateunpack(cs_67)) else caught-fail) in
        {1557}let v_538: bool = (not-caught-fail(v_537) && success?(1-proj-2-tuple(v_537))) in
        {1558}let n_40: nonce = (if v_538 then 2-proj-2-tuple(v_537) else caught-fail) in
        {1559}let k_43: key = (if v_538 then 1-proj-2-tuple(v_537) else caught-fail) in
        {1560}let e_25: bitstring = (if v_538 then encrypt(k_43,n_40,h_67,plaintext_32) else caught-fail) in
        {1561}let n_41: nonce = (if v_538 then increment_nonce(n_40) else caught-fail) in
        {1562}let v_539: bitstring = (if v_538 then catch-fail(cipherstateunpack(cs_67)) else caught-fail) in
        {1563}let v_540: bool = (not-caught-fail(v_539) && success?(1-proj-2-tuple(v_539))) in
        {1564}let o_20: nonce = (if v_540 then 2-proj-2-tuple(v_539) else caught-fail) in
        {1565}let k_44: key = (if v_540 then 1-proj-2-tuple(v_539) else caught-fail) in
        {1566}let csi_40: cipherstate = (if v_538 then catch-fail((if v_540 then cipherstatepack(k_44,n_41) else fail-any)) else caught-fail) in
        {1567}let v_541: bool = not-caught-fail(csi_40) in
        {1568}let v_542: bitstring = (if v_536 then catch-fail((if v_538 then (if v_541 then (csi_40,e_25) else fail-any) else fail-any)) else caught-fail) in
        {1569}let v_543: bool = (not-caught-fail(v_542) && success?(1-proj-2-tuple(v_542))) in
        {1570}let ciphertext_23: bitstring = (if v_543 then 2-proj-2-tuple(v_542) else caught-fail) in
        {1571}let csi_41: cipherstate = (if v_543 then 1-proj-2-tuple(v_542) else caught-fail) in
        {1572}let ss_75: symmetricstate = (if v_543 then symmetricstatepack(csi_41,ck_80,h_67) else caught-fail) in
        {1573}let v_544: bitstring = (if v_543 then catch-fail(symmetricstateunpack(ss_75)) else caught-fail) in
        {1574}let v_545: bool = (not-caught-fail(v_544) && success?(1-proj-3-tuple(v_544))) in
        {1575}let h_68: bitstring = (if v_545 then 3-proj-3-tuple(v_544) else caught-fail) in
        {1576}let ck_81: key = (if v_545 then 2-proj-3-tuple(v_544) else caught-fail) in
        {1577}let cs_68: cipherstate = (if v_545 then 1-proj-3-tuple(v_544) else caught-fail) in
        {1578}let ssi_22: symmetricstate = (if v_543 then catch-fail((if v_545 then symmetricstatepack(cs_68,ck_81,hash(h_68,ciphertext_23)) else fail-any)) else caught-fail) in
        {1579}let v_546: bool = not-caught-fail(ssi_22) in
        {1580}let v_547: bitstring = (if v_533 then catch-fail((if v_534 then (if v_536 then (if v_543 then (if v_546 then (ssi_22,ciphertext_23) else fail-any) else fail-any) else fail-any) else fail-any)) else caught-fail) in
        {1581}let v_548: bool = (not-caught-fail(v_547) && success?(1-proj-2-tuple(v_547))) in
        {1582}let nm_12: bitstring = (if v_548 then 2-proj-2-tuple(v_547) else caught-fail) in
        {1583}let ss_76: symmetricstate = (if v_548 then 1-proj-2-tuple(v_547) else caught-fail) in
        {1584}let v_549: bitstring = (if v_548 then catch-fail(keypairunpack(s_15)) else caught-fail) in
        {1585}let v_550: bool = (not-caught-fail(v_549) && success?(1-proj-2-tuple(v_549))) in
        {1586}let my_private_key_13: key = (if v_550 then 2-proj-2-tuple(v_549) else caught-fail) in
        {1587}let my_public_key_13: key = (if v_550 then 1-proj-2-tuple(v_549) else caught-fail) in
        {1588}let input_key_material_15: key = (if v_548 then catch-fail((if v_550 then dhexp(my_private_key_13,re_15) else fail-any)) else caught-fail) in
        {1589}let v_551: bool = not-caught-fail(input_key_material_15) in
        {1590}let v_552: bitstring = (if v_551 then catch-fail(symmetricstateunpack(ss_76)) else caught-fail) in
        {1591}let v_553: bool = (not-caught-fail(v_552) && success?(1-proj-3-tuple(v_552))) in
        {1592}let h_69: bitstring = (if v_553 then 3-proj-3-tuple(v_552) else caught-fail) in
        {1593}let ck_82: key = (if v_553 then 2-proj-3-tuple(v_552) else caught-fail) in
        {1594}let cs_69: cipherstate = (if v_553 then 1-proj-3-tuple(v_552) else caught-fail) in
        {1595}let output1_15: key = (if v_553 then hmac_hash1(ck_82,input_key_material_15) else caught-fail) in
        {1596}let output2_15: key = (if v_553 then hmac_hash2(ck_82,input_key_material_15) else caught-fail) in
        {1597}let output3_15: key = (if v_553 then hmac_hash3(ck_82,input_key_material_15) else caught-fail) in
        {1598}let v_554: bitstring = (if v_553 then catch-fail((output1_15,output2_15,output3_15)) else caught-fail) in
        {1599}let v_555: bool = (not-caught-fail(v_554) && success?(1-proj-3-tuple(v_554))) in
        {1600}let output_13: key = (if v_555 then 3-proj-3-tuple(v_554) else caught-fail) in
        {1601}let temp_k_13: key = (if v_555 then 2-proj-3-tuple(v_554) else caught-fail) in
        {1602}let ck_83: key = (if v_555 then 1-proj-3-tuple(v_554) else caught-fail) in
        {1603}let ss_77: symmetricstate = (if v_548 then catch-fail((if v_551 then (if v_553 then (if v_555 then symmetricstatepack(cipherstatepack(temp_k_13,minnonce),ck_83,h_69) else fail-any) else fail-any) else fail-any)) else caught-fail) in
        {1604}let v_556: bool = not-caught-fail(ss_77) in
        {1605}let v_557: bitstring = (if v_556 then catch-fail(symmetricstateunpack(ss_77)) else caught-fail) in
        {1606}let v_558: bool = (not-caught-fail(v_557) && success?(1-proj-3-tuple(v_557))) in
        {1607}let h_70: bitstring = (if v_558 then 3-proj-3-tuple(v_557) else caught-fail) in
        {1608}let ck_84: key = (if v_558 then 2-proj-3-tuple(v_557) else caught-fail) in
        {1609}let cs_70: cipherstate = (if v_558 then 1-proj-3-tuple(v_557) else caught-fail) in
        {1610}let v_559: bitstring = (if v_558 then catch-fail(cipherstateunpack(cs_70)) else caught-fail) in
        {1611}let v_560: bool = (not-caught-fail(v_559) && success?(1-proj-2-tuple(v_559))) in
        {1612}let n_42: nonce = (if v_560 then 2-proj-2-tuple(v_559) else caught-fail) in
        {1613}let k_45: key = (if v_560 then 1-proj-2-tuple(v_559) else caught-fail) in
        {1614}let e_26: bitstring = (if v_560 then encrypt(k_45,n_42,h_70,payload_4) else caught-fail) in
        {1615}let n_43: nonce = (if v_560 then increment_nonce(n_42) else caught-fail) in
        {1616}let v_561: bitstring = (if v_560 then catch-fail(cipherstateunpack(cs_70)) else caught-fail) in
        {1617}let v_562: bool = (not-caught-fail(v_561) && success?(1-proj-2-tuple(v_561))) in
        {1618}let o_21: nonce = (if v_562 then 2-proj-2-tuple(v_561) else caught-fail) in
        {1619}let k_46: key = (if v_562 then 1-proj-2-tuple(v_561) else caught-fail) in
        {1620}let csi_42: cipherstate = (if v_560 then catch-fail((if v_562 then cipherstatepack(k_46,n_43) else fail-any)) else caught-fail) in
        {1621}let v_563: bool = not-caught-fail(csi_42) in
        {1622}let v_564: bitstring = (if v_558 then catch-fail((if v_560 then (if v_563 then (csi_42,e_26) else fail-any) else fail-any)) else caught-fail) in
        {1623}let v_565: bool = (not-caught-fail(v_564) && success?(1-proj-2-tuple(v_564))) in
        {1624}let ciphertext_24: bitstring = (if v_565 then 2-proj-2-tuple(v_564) else caught-fail) in
        {1625}let csi_43: cipherstate = (if v_565 then 1-proj-2-tuple(v_564) else caught-fail) in
        {1626}let ss_78: symmetricstate = (if v_565 then symmetricstatepack(csi_43,ck_84,h_70) else caught-fail) in
        {1627}let v_566: bitstring = (if v_565 then catch-fail(symmetricstateunpack(ss_78)) else caught-fail) in
        {1628}let v_567: bool = (not-caught-fail(v_566) && success?(1-proj-3-tuple(v_566))) in
        {1629}let h_71: bitstring = (if v_567 then 3-proj-3-tuple(v_566) else caught-fail) in
        {1630}let ck_85: key = (if v_567 then 2-proj-3-tuple(v_566) else caught-fail) in
        {1631}let cs_71: cipherstate = (if v_567 then 1-proj-3-tuple(v_566) else caught-fail) in
        {1632}let ssi_23: symmetricstate = (if v_565 then catch-fail((if v_567 then symmetricstatepack(cs_71,ck_85,hash(h_71,ciphertext_24)) else fail-any)) else caught-fail) in
        {1633}let v_568: bool = not-caught-fail(ssi_23) in
        {1634}let v_569: bitstring = (if v_556 then catch-fail((if v_558 then (if v_565 then (if v_568 then (ssi_23,ciphertext_24) else fail-any) else fail-any) else fail-any)) else caught-fail) in
        {1635}let v_570: bool = (not-caught-fail(v_569) && success?(1-proj-2-tuple(v_569))) in
        {1636}let ciphertext_25: bitstring = (if v_570 then 2-proj-2-tuple(v_569) else caught-fail) in
        {1637}let ss_79: symmetricstate = (if v_570 then 1-proj-2-tuple(v_569) else caught-fail) in
        {1638}let v_571: bitstring = (if v_570 then catch-fail(keypairunpack(m_15)) else caught-fail) in
        {1639}let v_572: bool = (not-caught-fail(v_571) && success?(1-proj-2-tuple(v_571))) in
        {1640}let my_private_key_14: key = (if v_572 then 2-proj-2-tuple(v_571) else caught-fail) in
        {1641}let my_public_key_14: key = (if v_572 then 1-proj-2-tuple(v_571) else caught-fail) in
        {1642}let input_key_material_16: key = (if v_570 then catch-fail((if v_572 then dhexp(my_private_key_14,re_15) else fail-any)) else caught-fail) in
        {1643}let v_573: bool = not-caught-fail(input_key_material_16) in
        {1644}let v_574: bitstring = (if v_573 then catch-fail(symmetricstateunpack(ss_79)) else caught-fail) in
        {1645}let v_575: bool = (not-caught-fail(v_574) && success?(1-proj-3-tuple(v_574))) in
        {1646}let h_72: bitstring = (if v_575 then 3-proj-3-tuple(v_574) else caught-fail) in
        {1647}let ck_86: key = (if v_575 then 2-proj-3-tuple(v_574) else caught-fail) in
        {1648}let cs_72: cipherstate = (if v_575 then 1-proj-3-tuple(v_574) else caught-fail) in
        {1649}let output1_16: key = (if v_575 then hmac_hash1(ck_86,input_key_material_16) else caught-fail) in
        {1650}let output2_16: key = (if v_575 then hmac_hash2(ck_86,input_key_material_16) else caught-fail) in
        {1651}let output3_16: key = (if v_575 then hmac_hash3(ck_86,input_key_material_16) else caught-fail) in
        {1652}let v_576: bitstring = (if v_575 then catch-fail((output1_16,output2_16,output3_16)) else caught-fail) in
        {1653}let v_577: bool = (not-caught-fail(v_576) && success?(1-proj-3-tuple(v_576))) in
        {1654}let output_14: key = (if v_577 then 3-proj-3-tuple(v_576) else caught-fail) in
        {1655}let temp_k_14: key = (if v_577 then 2-proj-3-tuple(v_576) else caught-fail) in
        {1656}let ck_87: key = (if v_577 then 1-proj-3-tuple(v_576) else caught-fail) in
        {1657}let ss_80: symmetricstate = (if v_570 then catch-fail((if v_573 then (if v_575 then (if v_577 then symmetricstatepack(cipherstatepack(temp_k_14,minnonce),ck_87,h_72) else fail-any) else fail-any) else fail-any)) else caught-fail) in
        {1658}let v_578: bool = not-caught-fail(ss_80) in
        {1659}let v_579: bitstring = (if v_578 then catch-fail(symmetricstateunpack(ss_80)) else caught-fail) in
        {1660}let v_580: bool = (not-caught-fail(v_579) && success?(1-proj-3-tuple(v_579))) in
        {1661}let h_73: bitstring = (if v_580 then 3-proj-3-tuple(v_579) else caught-fail) in
        {1662}let ck_88: key = (if v_580 then 2-proj-3-tuple(v_579) else caught-fail) in
        {1663}let cs_73: cipherstate = (if v_580 then 1-proj-3-tuple(v_579) else caught-fail) in
        {1664}let v_581: bitstring = (if v_580 then catch-fail(cipherstateunpack(cs_73)) else caught-fail) in
        {1665}let v_582: bool = (not-caught-fail(v_581) && success?(1-proj-2-tuple(v_581))) in
        {1666}let n_44: nonce = (if v_582 then 2-proj-2-tuple(v_581) else caught-fail) in
        {1667}let k_47: key = (if v_582 then 1-proj-2-tuple(v_581) else caught-fail) in
        {1668}let e_27: bitstring = (if v_582 then encrypt(k_47,n_44,h_73,payload_4) else caught-fail) in
        {1669}let n_45: nonce = (if v_582 then increment_nonce(n_44) else caught-fail) in
        {1670}let v_583: bitstring = (if v_582 then catch-fail(cipherstateunpack(cs_73)) else caught-fail) in
        {1671}let v_584: bool = (not-caught-fail(v_583) && success?(1-proj-2-tuple(v_583))) in
        {1672}let o_22: nonce = (if v_584 then 2-proj-2-tuple(v_583) else caught-fail) in
        {1673}let k_48: key = (if v_584 then 1-proj-2-tuple(v_583) else caught-fail) in
        {1674}let csi_44: cipherstate = (if v_582 then catch-fail((if v_584 then cipherstatepack(k_48,n_45) else fail-any)) else caught-fail) in
        {1675}let v_585: bool = not-caught-fail(csi_44) in
        {1676}let v_586: bitstring = (if v_580 then catch-fail((if v_582 then (if v_585 then (csi_44,e_27) else fail-any) else fail-any)) else caught-fail) in
        {1677}let v_587: bool = (not-caught-fail(v_586) && success?(1-proj-2-tuple(v_586))) in
        {1678}let ciphertext_26: bitstring = (if v_587 then 2-proj-2-tuple(v_586) else caught-fail) in
        {1679}let csi_45: cipherstate = (if v_587 then 1-proj-2-tuple(v_586) else caught-fail) in
        {1680}let ss_81: symmetricstate = (if v_587 then symmetricstatepack(csi_45,ck_88,h_73) else caught-fail) in
        {1681}let v_588: bitstring = (if v_587 then catch-fail(symmetricstateunpack(ss_81)) else caught-fail) in
        {1682}let v_589: bool = (not-caught-fail(v_588) && success?(1-proj-3-tuple(v_588))) in
        {1683}let h_74: bitstring = (if v_589 then 3-proj-3-tuple(v_588) else caught-fail) in
        {1684}let ck_89: key = (if v_589 then 2-proj-3-tuple(v_588) else caught-fail) in
        {1685}let cs_74: cipherstate = (if v_589 then 1-proj-3-tuple(v_588) else caught-fail) in
        {1686}let ssi_24: symmetricstate = (if v_587 then catch-fail((if v_589 then symmetricstatepack(cs_74,ck_89,hash(h_74,ciphertext_26)) else fail-any)) else caught-fail) in
        {1687}let v_590: bool = not-caught-fail(ssi_24) in
        {1688}let v_591: bitstring = (if v_578 then catch-fail((if v_580 then (if v_587 then (if v_590 then (ssi_24,ciphertext_26) else fail-any) else fail-any) else fail-any)) else caught-fail) in
        {1689}let v_592: bool = (not-caught-fail(v_591) && success?(1-proj-2-tuple(v_591))) in
        {1690}let ciphertext_27: bitstring = (if v_592 then 2-proj-2-tuple(v_591) else caught-fail) in
        {1691}let ss_82: symmetricstate = (if v_592 then 1-proj-2-tuple(v_591) else caught-fail) in
        {1692}let hs_35: handshakestate = (if v_592 then handshakestatepack(ss_82,s_15,m_15,e_23,rs_15,rm_15,re_15,psk_12,initiator_10) else caught-fail) in
        {1693}let message_buffer_4: bitstring = (if v_592 then concat4(ne_18,ns_12,nm_12,ciphertext_27) else caught-fail) in
        {1694}let v_593: bitstring = (if v_592 then catch-fail(symmetricstateunpack(ss_82)) else caught-fail) in
        {1695}let v_594: bool = (not-caught-fail(v_593) && success?(1-proj-3-tuple(v_593))) in
        {1696}let h_75: bitstring = (if v_594 then 3-proj-3-tuple(v_593) else caught-fail) in
        {1697}let ck_90: key = (if v_594 then 2-proj-3-tuple(v_593) else caught-fail) in
        {1698}let cs_75: cipherstate = (if v_594 then 1-proj-3-tuple(v_593) else caught-fail) in
        {1699}let input_key_material_17: key = (if v_594 then zero else caught-fail) in
        {1700}let output1_17: key = (if v_594 then hmac_hash1(ck_90,input_key_material_17) else caught-fail) in
        {1701}let output2_17: key = (if v_594 then hmac_hash2(ck_90,input_key_material_17) else caught-fail) in
        {1702}let output3_17: key = (if v_594 then hmac_hash3(ck_90,input_key_material_17) else caught-fail) in
        {1703}let v_595: bitstring = (if v_594 then catch-fail((output1_17,output2_17,output3_17)) else caught-fail) in
        {1704}let v_596: bool = (not-caught-fail(v_595) && success?(1-proj-3-tuple(v_595))) in
        {1705}let temp_k3_2: key = (if v_596 then 3-proj-3-tuple(v_595) else caught-fail) in
        {1706}let temp_k2_2: key = (if v_596 then 2-proj-3-tuple(v_595) else caught-fail) in
        {1707}let temp_k1_2: key = (if v_596 then 1-proj-3-tuple(v_595) else caught-fail) in
        {1708}let cs1_10: cipherstate = (if v_596 then cipherstatepack(temp_k1_2,minnonce) else caught-fail) in
        {1709}let cs2_10: cipherstate = (if v_596 then cipherstatepack(temp_k2_2,minnonce) else caught-fail) in
        {1710}let v_597: bitstring = (if v_592 then catch-fail((if v_594 then (if v_596 then (ss_82,cs1_10,cs2_10) else fail-any) else fail-any)) else caught-fail) in
        {1711}let v_598: bool = (not-caught-fail(v_597) && success?(1-proj-3-tuple(v_597))) in
        {1712}let cs2_11: cipherstate = (if v_598 then 3-proj-3-tuple(v_597) else caught-fail) in
        {1713}let cs1_11: cipherstate = (if v_598 then 2-proj-3-tuple(v_597) else caught-fail) in
        {1714}let ssi_25: symmetricstate = (if v_598 then 1-proj-3-tuple(v_597) else caught-fail) in
        {1715}let (hs_36: handshakestate,message_b_2: bitstring,cs1_12: cipherstate,cs2_12: cipherstate) = (if v_482 then (if v_484 then (if v_486 then (if v_487 then (if v_490 then (if v_498 then (if v_506 then (if v_514 then (if v_516 then (if v_531 then (if v_533 then (if v_548 then (if v_556 then (if v_570 then (if v_578 then (if v_592 then (if v_598 then (hs_35,message_buffer_4,cs1_11,cs2_11) else fail-any) else fail-any) else fail-any) else fail-any) else fail-any) else fail-any) else fail-any) else fail-any) else fail-any) else fail-any) else fail-any) else fail-any) else fail-any) else fail-any) else fail-any) else fail-any) else fail-any) in
        {1716}event SendMsg(me_2,them_2,stagepack_b(sid_3),msg_b(me_2,them_2,sid_3));
        {1717}insert statestore(me_2,them_2,sid_3,statepack_c(hs_36,cs1_12,cs2_12));
        {1718}out(pub, message_b_2)
    ) | (
        {1720}!
        {1787}get statestore(=me_2,=them_2,=sid_3,statepack_c(hs_37: handshakestate,cs1_13: cipherstate,cs2_13: cipherstate)) in
        {1721}let hs_38: handshakestate = handshakestatesetcs(hs_37,cs1_13) in
        {1722}in(pub, message_c_2: bitstring);
        {1723}let v_599: bitstring = catch-fail(handshakestateunpack(hs_38)) in
        {1724}let v_600: bool = (not-caught-fail(v_599) && success?(1-proj-9-tuple(v_599))) in
        {1725}let initiator_11: bool = (if v_600 then 9-proj-9-tuple(v_599) else caught-fail) in
        {1726}let psk_13: key = (if v_600 then 8-proj-9-tuple(v_599) else caught-fail) in
        {1727}let re_16: key = (if v_600 then 7-proj-9-tuple(v_599) else caught-fail) in
        {1728}let rm_16: key = (if v_600 then 6-proj-9-tuple(v_599) else caught-fail) in
        {1729}let rs_16: key = (if v_600 then 5-proj-9-tuple(v_599) else caught-fail) in
        {1730}let e_28: keypair = (if v_600 then 4-proj-9-tuple(v_599) else caught-fail) in
        {1731}let m_16: keypair = (if v_600 then 3-proj-9-tuple(v_599) else caught-fail) in
        {1732}let s_16: keypair = (if v_600 then 2-proj-9-tuple(v_599) else caught-fail) in
        {1733}let ss_83: symmetricstate = (if v_600 then 1-proj-9-tuple(v_599) else caught-fail) in
        {1734}let v_601: bitstring = (if v_600 then catch-fail(deconcat4(message_c_2)) else caught-fail) in
        {1735}let v_602: bool = (not-caught-fail(v_601) && success?(1-proj-4-tuple(v_601))) in
        {1736}let ciphertext_28: bitstring = (if v_602 then 4-proj-4-tuple(v_601) else caught-fail) in
        {1737}let nm_13: bitstring = (if v_602 then 3-proj-4-tuple(v_601) else caught-fail) in
        {1738}let ns_13: bitstring = (if v_602 then 2-proj-4-tuple(v_601) else caught-fail) in
        {1739}let ne_19: bitstring = (if v_602 then 1-proj-4-tuple(v_601) else caught-fail) in
        {1740}let valid1_8: bool = (if v_602 then true else caught-fail) in
        {1741}let v_603: bitstring = (if v_602 then catch-fail(symmetricstateunpack(ss_83)) else caught-fail) in
        {1742}let v_604: bool = (not-caught-fail(v_603) && success?(1-proj-3-tuple(v_603))) in
        {1743}let h_76: bitstring = (if v_604 then 3-proj-3-tuple(v_603) else caught-fail) in
        {1744}let ck_91: key = (if v_604 then 2-proj-3-tuple(v_603) else caught-fail) in
        {1745}let cs_76: cipherstate = (if v_604 then 1-proj-3-tuple(v_603) else caught-fail) in
        {1746}let v_605: bitstring = (if v_604 then catch-fail(cipherstateunpack(cs_76)) else caught-fail) in
        {1747}let v_606: bool = (not-caught-fail(v_605) && success?(1-proj-2-tuple(v_605))) in
        {1748}let n_46: nonce = (if v_606 then 2-proj-2-tuple(v_605) else caught-fail) in
        {1749}let k_49: key = (if v_606 then 1-proj-2-tuple(v_605) else caught-fail) in
        {1750}let d_11: aead = (if v_606 then catch-fail(decrypt(k_49,n_46,h_76,ciphertext_28)) else caught-fail) in
        {1751}let v_607: bool = not-caught-fail(d_11) in
        {1752}let v_608: bitstring = (if v_607 then catch-fail(aeadunpack(d_11)) else caught-fail) in
        {1753}let v_609: bool = (not-caught-fail(v_608) && success?(1-proj-3-tuple(v_608))) in
        {1754}let plaintext_33: bitstring = (if v_609 then 3-proj-3-tuple(v_608) else caught-fail) in
        {1755}let adi_11: bitstring = (if v_609 then 2-proj-3-tuple(v_608) else caught-fail) in
        {1756}let valid_27: bool = (if v_609 then 1-proj-3-tuple(v_608) else caught-fail) in
        {1757}let n_47: nonce = (if v_609 then increment_nonce(n_46) else caught-fail) in
        {1758}let v_610: bitstring = (if v_609 then catch-fail(cipherstateunpack(cs_76)) else caught-fail) in
        {1759}let v_611: bool = (not-caught-fail(v_610) && success?(1-proj-2-tuple(v_610))) in
        {1760}let o_23: nonce = (if v_611 then 2-proj-2-tuple(v_610) else caught-fail) in
        {1761}let k_50: key = (if v_611 then 1-proj-2-tuple(v_610) else caught-fail) in
        {1762}let csi_46: cipherstate = (if v_609 then catch-fail((if v_611 then cipherstatepack(k_50,n_47) else fail-any)) else caught-fail) in
        {1763}let v_612: bool = not-caught-fail(csi_46) in
        {1764}let v_613: bitstring = (if v_604 then catch-fail((if v_606 then (if v_607 then (if v_609 then (if v_612 then (csi_46,plaintext_33,valid_27) else fail-any) else fail-any) else fail-any) else fail-any)) else caught-fail) in
        {1765}let v_614: bool = (not-caught-fail(v_613) && success?(1-proj-3-tuple(v_613))) in
        {1766}let valid_28: bool = (if v_614 then 3-proj-3-tuple(v_613) else caught-fail) in
        {1767}let plaintext_34: bitstring = (if v_614 then 2-proj-3-tuple(v_613) else caught-fail) in
        {1768}let csi_47: cipherstate = (if v_614 then 1-proj-3-tuple(v_613) else caught-fail) in
        {1769}let ss_84: symmetricstate = (if v_614 then symmetricstatepack(csi_47,ck_91,h_76) else caught-fail) in
        {1770}let v_615: bitstring = (if v_614 then catch-fail(symmetricstateunpack(ss_84)) else caught-fail) in
        {1771}let v_616: bool = (not-caught-fail(v_615) && success?(1-proj-3-tuple(v_615))) in
        {1772}let h_77: bitstring = (if v_616 then 3-proj-3-tuple(v_615) else caught-fail) in
        {1773}let ck_92: key = (if v_616 then 2-proj-3-tuple(v_615) else caught-fail) in
        {1774}let cs_77: cipherstate = (if v_616 then 1-proj-3-tuple(v_615) else caught-fail) in
        {1775}let ssi_26: symmetricstate = (if v_614 then catch-fail((if v_616 then symmetricstatepack(cs_77,ck_92,hash(h_77,ciphertext_28)) else fail-any)) else caught-fail) in
        {1776}let v_617: bool = not-caught-fail(ssi_26) in
        {1777}let v_618: bitstring = (if v_602 then catch-fail((if v_604 then (if v_614 then (if v_617 then (ssi_26,plaintext_34,valid_28) else fail-any) else fail-any) else fail-any)) else caught-fail) in
        {1778}let v_619: bool = (not-caught-fail(v_618) && success?(1-proj-3-tuple(v_618))) in
        {1779}let valid2_8: bool = (if v_619 then 3-proj-3-tuple(v_618) else caught-fail) in
        {1780}let plaintext_35: bitstring = (if v_619 then 2-proj-3-tuple(v_618) else caught-fail) in
        {1781}let ss_85: symmetricstate = (if v_619 then 1-proj-3-tuple(v_618) else caught-fail) in
        {1782}let v_620: bool = (if v_619 then catch-fail((valid1_8 && valid2_8)) else caught-fail) in
        {1783}let hs_39: handshakestate = (if v_620 then handshakestatepack(ss_85,s_16,m_16,e_28,rs_16,rm_16,re_16,psk_13,initiator_11) else caught-fail) in
        {1784}let (hs_40: handshakestate,plaintext_c: bitstring,valid_29: bool) = (if v_600 then (if v_602 then (if v_619 then (if undo-catch-fail(v_620) then (hs_39,plaintext_35,true) else fail-any) else fail-any) else fail-any) else fail-any) in
        {1785}event RecvMsg(me_2,them_2,stagepack_c(sid_3),plaintext_c);
        {1786}insert statestore(me_2,them_2,sid_3,statepack_d(hs_40,handshakestategetcs(hs_40),cs2_13))
    ) | (
        {1788}!
        {1846}get statestore(=me_2,=them_2,=sid_3,statepack_d(hs_41: handshakestate,cs1_14: cipherstate,cs2_14: cipherstate)) in
        {1789}let hs_42: handshakestate = handshakestatesetcs(hs_41,cs2_14) in
        {1790}let payload_5: bitstring = msg_d(me_2,them_2,sid_3) in
        {1791}let v_621: bitstring = catch-fail(handshakestateunpack(hs_42)) in
        {1792}let v_622: bool = (not-caught-fail(v_621) && success?(1-proj-9-tuple(v_621))) in
        {1793}let initiator_12: bool = (if v_622 then 9-proj-9-tuple(v_621) else caught-fail) in
        {1794}let psk_14: key = (if v_622 then 8-proj-9-tuple(v_621) else caught-fail) in
        {1795}let re_17: key = (if v_622 then 7-proj-9-tuple(v_621) else caught-fail) in
        {1796}let rm_17: key = (if v_622 then 6-proj-9-tuple(v_621) else caught-fail) in
        {1797}let rs_17: key = (if v_622 then 5-proj-9-tuple(v_621) else caught-fail) in
        {1798}let e_29: keypair = (if v_622 then 4-proj-9-tuple(v_621) else caught-fail) in
        {1799}let m_17: keypair = (if v_622 then 3-proj-9-tuple(v_621) else caught-fail) in
        {1800}let s_17: keypair = (if v_622 then 2-proj-9-tuple(v_621) else caught-fail) in
        {1801}let ss_86: symmetricstate = (if v_622 then 1-proj-9-tuple(v_621) else caught-fail) in
        {1802}let v_623: bitstring = (if v_622 then catch-fail((empty,empty,empty,empty)) else caught-fail) in
        {1803}let v_624: bool = (not-caught-fail(v_623) && success?(1-proj-4-tuple(v_623))) in
        {1804}let ciphertext_29: bitstring = (if v_624 then 4-proj-4-tuple(v_623) else caught-fail) in
        {1805}let nm_14: bitstring = (if v_624 then 3-proj-4-tuple(v_623) else caught-fail) in
        {1806}let ns_14: bitstring = (if v_624 then 2-proj-4-tuple(v_623) else caught-fail) in
        {1807}let ne_20: bitstring = (if v_624 then 1-proj-4-tuple(v_623) else caught-fail) in
        {1808}let v_625: bitstring = (if v_624 then catch-fail(symmetricstateunpack(ss_86)) else caught-fail) in
        {1809}let v_626: bool = (not-caught-fail(v_625) && success?(1-proj-3-tuple(v_625))) in
        {1810}let h_78: bitstring = (if v_626 then 3-proj-3-tuple(v_625) else caught-fail) in
        {1811}let ck_93: key = (if v_626 then 2-proj-3-tuple(v_625) else caught-fail) in
        {1812}let cs_78: cipherstate = (if v_626 then 1-proj-3-tuple(v_625) else caught-fail) in
        {1813}let v_627: bitstring = (if v_626 then catch-fail(cipherstateunpack(cs_78)) else caught-fail) in
        {1814}let v_628: bool = (not-caught-fail(v_627) && success?(1-proj-2-tuple(v_627))) in
        {1815}let n_48: nonce = (if v_628 then 2-proj-2-tuple(v_627) else caught-fail) in
        {1816}let k_51: key = (if v_628 then 1-proj-2-tuple(v_627) else caught-fail) in
        {1817}let e_30: bitstring = (if v_628 then encrypt(k_51,n_48,h_78,payload_5) else caught-fail) in
        {1818}let n_49: nonce = (if v_628 then increment_nonce(n_48) else caught-fail) in
        {1819}let v_629: bitstring = (if v_628 then catch-fail(cipherstateunpack(cs_78)) else caught-fail) in
        {1820}let v_630: bool = (not-caught-fail(v_629) && success?(1-proj-2-tuple(v_629))) in
        {1821}let o_24: nonce = (if v_630 then 2-proj-2-tuple(v_629) else caught-fail) in
        {1822}let k_52: key = (if v_630 then 1-proj-2-tuple(v_629) else caught-fail) in
        {1823}let csi_48: cipherstate = (if v_628 then catch-fail((if v_630 then cipherstatepack(k_52,n_49) else fail-any)) else caught-fail) in
        {1824}let v_631: bool = not-caught-fail(csi_48) in
        {1825}let v_632: bitstring = (if v_626 then catch-fail((if v_628 then (if v_631 then (csi_48,e_30) else fail-any) else fail-any)) else caught-fail) in
        {1826}let v_633: bool = (not-caught-fail(v_632) && success?(1-proj-2-tuple(v_632))) in
        {1827}let ciphertext_30: bitstring = (if v_633 then 2-proj-2-tuple(v_632) else caught-fail) in
        {1828}let csi_49: cipherstate = (if v_633 then 1-proj-2-tuple(v_632) else caught-fail) in
        {1829}let ss_87: symmetricstate = (if v_633 then symmetricstatepack(csi_49,ck_93,h_78) else caught-fail) in
        {1830}let v_634: bitstring = (if v_633 then catch-fail(symmetricstateunpack(ss_87)) else caught-fail) in
        {1831}let v_635: bool = (not-caught-fail(v_634) && success?(1-proj-3-tuple(v_634))) in
        {1832}let h_79: bitstring = (if v_635 then 3-proj-3-tuple(v_634) else caught-fail) in
        {1833}let ck_94: key = (if v_635 then 2-proj-3-tuple(v_634) else caught-fail) in
        {1834}let cs_79: cipherstate = (if v_635 then 1-proj-3-tuple(v_634) else caught-fail) in
        {1835}let ssi_27: symmetricstate = (if v_633 then catch-fail((if v_635 then symmetricstatepack(cs_79,ck_94,hash(h_79,ciphertext_30)) else fail-any)) else caught-fail) in
        {1836}let v_636: bool = not-caught-fail(ssi_27) in
        {1837}let v_637: bitstring = (if v_624 then catch-fail((if v_626 then (if v_633 then (if v_636 then (ssi_27,ciphertext_30) else fail-any) else fail-any) else fail-any)) else caught-fail) in
        {1838}let v_638: bool = (not-caught-fail(v_637) && success?(1-proj-2-tuple(v_637))) in
        {1839}let ciphertext_31: bitstring = (if v_638 then 2-proj-2-tuple(v_637) else caught-fail) in
        {1840}let ss_88: symmetricstate = (if v_638 then 1-proj-2-tuple(v_637) else caught-fail) in
        {1841}let hs_43: handshakestate = (if v_638 then handshakestatepack(ss_88,s_17,m_17,e_29,rs_17,rm_17,re_17,psk_14,initiator_12) else caught-fail) in
        {1842}let message_buffer_5: bitstring = (if v_638 then concat4(ne_20,ns_14,nm_14,ciphertext_31) else caught-fail) in
        {1843}let (hs_44: handshakestate,message_d_2: bitstring) = (if v_622 then (if v_624 then (if v_638 then (hs_43,message_buffer_5) else fail-any) else fail-any) else fail-any) in
        {1844}event SendMsg(me_2,them_2,stagepack_d(sid_3),msg_d(me_2,them_2,sid_3));
        {1845}out(pub, message_d_2)
    ) | (
        {1847}event LeakS(phase0,me_2);
        {1848}event LeakM(phase0,me_2);
        {1849}out(pub, (key_s(me_2),key_m(me_2)))
    ) | (
        {1850}phase 1;
        {1851}event LeakS(phase1,me_2);
        {1852}event LeakM(phase1,me_2);
        {1853}out(pub, (key_s(me_2),key_m(me_2)))
    )
) | (
    {1854}let me_3: principal = bob in
    {1855}let them_3: principal = charlie in
    {1856}let sid_4: sessionid = sid in
    {1857}let s_18: keypair = keypairpack(empty,empty) in
    {1858}let basis_16: key = key_m(me_3) in
    {1859}let public_key_16: key = catch-fail(dhexp(basis_16,validkey(g))) in
    {1860}let v_639: bool = not-caught-fail(public_key_16) in
    {1861}let m_18: keypair = (if v_639 then keypairpack(validkey(public_key_16),basis_16) else fail-any) in
    {1862}out(pub, (getpublickey(s_18),getpublickey(m_18)));
    (
        {1863}let e_31: keypair = keypairpack(empty,empty) in
        {1864}let rs_18: key = empty in
        {1865}let rm_18: key = empty in
        {1866}let re_18: key = empty in
        {1867}let prologue_3: bitstring = empty in
        {1868}let psk_15: key = empty in
        {1869}let protocol_name_3: bitstring = somename in
        {1870}let h_80: bitstring = hash(protocol_name_3,empty) in
        {1871}let ck_95: key = h_80 in
        {1872}let k_53: key = empty in
        {1873}let cs_80: cipherstate = cipherstatepack(k_53,minnonce) in
        {1874}let ss_89: symmetricstate = symmetricstatepack(cs_80,ck_95,h_80) in
        {1875}let v_640: bitstring = catch-fail(symmetricstateunpack(ss_89)) in
        {1876}let v_641: bool = (not-caught-fail(v_640) && success?(1-proj-3-tuple(v_640))) in
        {1877}let h_81: bitstring = (if v_641 then 3-proj-3-tuple(v_640) else caught-fail) in
        {1878}let ck_96: key = (if v_641 then 2-proj-3-tuple(v_640) else caught-fail) in
        {1879}let cs_81: cipherstate = (if v_641 then 1-proj-3-tuple(v_640) else caught-fail) in
        {1880}let ss_90: symmetricstate = catch-fail((if v_641 then symmetricstatepack(cs_81,ck_96,hash(h_81,prologue_3)) else fail-any)) in
        {1881}let v_642: bool = not-caught-fail(ss_90) in
        {1882}let hs_45: handshakestate = (if v_642 then handshakestatepack(ss_90,s_18,m_18,e_31,rs_18,rm_18,re_18,psk_15,false) else fail-any) in
        {1883}insert statestore(me_3,them_3,sid_4,statepack_a(hs_45))
    ) | (
        {2048}get statestore(=me_3,=them_3,=sid_4,statepack_a(hs_46: handshakestate)) in
        {1884}in(pub, message_a_3: bitstring);
        {1885}let v_643: bitstring = catch-fail(handshakestateunpack(hs_46)) in
        {1886}let v_644: bool = (not-caught-fail(v_643) && success?(1-proj-9-tuple(v_643))) in
        {1887}let initiator_13: bool = (if v_644 then 9-proj-9-tuple(v_643) else caught-fail) in
        {1888}let psk_16: key = (if v_644 then 8-proj-9-tuple(v_643) else caught-fail) in
        {1889}let re_19: key = (if v_644 then 7-proj-9-tuple(v_643) else caught-fail) in
        {1890}let rm_19: key = (if v_644 then 6-proj-9-tuple(v_643) else caught-fail) in
        {1891}let rs_19: key = (if v_644 then 5-proj-9-tuple(v_643) else caught-fail) in
        {1892}let e_32: keypair = (if v_644 then 4-proj-9-tuple(v_643) else caught-fail) in
        {1893}let m_19: keypair = (if v_644 then 3-proj-9-tuple(v_643) else caught-fail) in
        {1894}let s_19: keypair = (if v_644 then 2-proj-9-tuple(v_643) else caught-fail) in
        {1895}let ss_91: symmetricstate = (if v_644 then 1-proj-9-tuple(v_643) else caught-fail) in
        {1896}let v_645: bitstring = (if v_644 then catch-fail(deconcat4(message_a_3)) else caught-fail) in
        {1897}let v_646: bool = (not-caught-fail(v_645) && success?(1-proj-4-tuple(v_645))) in
        {1898}let ciphertext_32: bitstring = (if v_646 then 4-proj-4-tuple(v_645) else caught-fail) in
        {1899}let nm_15: bitstring = (if v_646 then 3-proj-4-tuple(v_645) else caught-fail) in
        {1900}let ns_15: bitstring = (if v_646 then 2-proj-4-tuple(v_645) else caught-fail) in
        {1901}let ne_21: bitstring = (if v_646 then 1-proj-4-tuple(v_645) else caught-fail) in
        {1902}let valid1_9: bool = (if v_646 then true else caught-fail) in
        {1903}let valid2_9: bool = (if v_646 then true else caught-fail) in
        {1904}let re_20: key = (if v_646 then ne_21 else caught-fail) in
        {1905}let v_647: bitstring = (if v_646 then catch-fail(symmetricstateunpack(ss_91)) else caught-fail) in
        {1906}let v_648: bool = (not-caught-fail(v_647) && success?(1-proj-3-tuple(v_647))) in
        {1907}let h_82: bitstring = (if v_648 then 3-proj-3-tuple(v_647) else caught-fail) in
        {1908}let ck_97: key = (if v_648 then 2-proj-3-tuple(v_647) else caught-fail) in
        {1909}let cs_82: cipherstate = (if v_648 then 1-proj-3-tuple(v_647) else caught-fail) in
        {1910}let ss_92: symmetricstate = (if v_646 then catch-fail((if v_648 then symmetricstatepack(cs_82,ck_97,hash(h_82,re_20)) else fail-any)) else caught-fail) in
        {1911}let v_649: bool = not-caught-fail(ss_92) in
        {1912}let v_650: bitstring = (if v_649 then catch-fail(symmetricstateunpack(ss_92)) else caught-fail) in
        {1913}let v_651: bool = (not-caught-fail(v_650) && success?(1-proj-3-tuple(v_650))) in
        {1914}let h_83: bitstring = (if v_651 then 3-proj-3-tuple(v_650) else caught-fail) in
        {1915}let ck_98: key = (if v_651 then 2-proj-3-tuple(v_650) else caught-fail) in
        {1916}let cs_83: cipherstate = (if v_651 then 1-proj-3-tuple(v_650) else caught-fail) in
        {1917}let v_652: bitstring = (if v_651 then catch-fail(cipherstateunpack(cs_83)) else caught-fail) in
        {1918}let v_653: bool = (not-caught-fail(v_652) && success?(1-proj-2-tuple(v_652))) in
        {1919}let n_50: nonce = (if v_653 then 2-proj-2-tuple(v_652) else caught-fail) in
        {1920}let k_54: key = (if v_653 then 1-proj-2-tuple(v_652) else caught-fail) in
        {1921}let d_12: aead = (if v_653 then catch-fail(decrypt(k_54,n_50,h_83,ns_15)) else caught-fail) in
        {1922}let v_654: bool = not-caught-fail(d_12) in
        {1923}let v_655: bitstring = (if v_654 then catch-fail(aeadunpack(d_12)) else caught-fail) in
        {1924}let v_656: bool = (not-caught-fail(v_655) && success?(1-proj-3-tuple(v_655))) in
        {1925}let plaintext_36: bitstring = (if v_656 then 3-proj-3-tuple(v_655) else caught-fail) in
        {1926}let adi_12: bitstring = (if v_656 then 2-proj-3-tuple(v_655) else caught-fail) in
        {1927}let valid_30: bool = (if v_656 then 1-proj-3-tuple(v_655) else caught-fail) in
        {1928}let n_51: nonce = (if v_656 then increment_nonce(n_50) else caught-fail) in
        {1929}let v_657: bitstring = (if v_656 then catch-fail(cipherstateunpack(cs_83)) else caught-fail) in
        {1930}let v_658: bool = (not-caught-fail(v_657) && success?(1-proj-2-tuple(v_657))) in
        {1931}let o_25: nonce = (if v_658 then 2-proj-2-tuple(v_657) else caught-fail) in
        {1932}let k_55: key = (if v_658 then 1-proj-2-tuple(v_657) else caught-fail) in
        {1933}let csi_50: cipherstate = (if v_656 then catch-fail((if v_658 then cipherstatepack(k_55,n_51) else fail-any)) else caught-fail) in
        {1934}let v_659: bool = not-caught-fail(csi_50) in
        {1935}let v_660: bitstring = (if v_651 then catch-fail((if v_653 then (if v_654 then (if v_656 then (if v_659 then (csi_50,plaintext_36,valid_30) else fail-any) else fail-any) else fail-any) else fail-any)) else caught-fail) in
        {1936}let v_661: bool = (not-caught-fail(v_660) && success?(1-proj-3-tuple(v_660))) in
        {1937}let valid_31: bool = (if v_661 then 3-proj-3-tuple(v_660) else caught-fail) in
        {1938}let plaintext_37: bitstring = (if v_661 then 2-proj-3-tuple(v_660) else caught-fail) in
        {1939}let csi_51: cipherstate = (if v_661 then 1-proj-3-tuple(v_660) else caught-fail) in
        {1940}let ss_93: symmetricstate = (if v_661 then symmetricstatepack(csi_51,ck_98,h_83) else caught-fail) in
        {1941}let v_662: bitstring = (if v_661 then catch-fail(symmetricstateunpack(ss_93)) else caught-fail) in
        {1942}let v_663: bool = (not-caught-fail(v_662) && success?(1-proj-3-tuple(v_662))) in
        {1943}let h_84: bitstring = (if v_663 then 3-proj-3-tuple(v_662) else caught-fail) in
        {1944}let ck_99: key = (if v_663 then 2-proj-3-tuple(v_662) else caught-fail) in
        {1945}let cs_84: cipherstate = (if v_663 then 1-proj-3-tuple(v_662) else caught-fail) in
        {1946}let ssi_28: symmetricstate = (if v_661 then catch-fail((if v_663 then symmetricstatepack(cs_84,ck_99,hash(h_84,ns_15)) else fail-any)) else caught-fail) in
        {1947}let v_664: bool = not-caught-fail(ssi_28) in
        {1948}let v_665: bitstring = (if v_649 then catch-fail((if v_651 then (if v_661 then (if v_664 then (ssi_28,plaintext_37,valid_31) else fail-any) else fail-any) else fail-any)) else caught-fail) in
        {1949}let v_666: bool = (not-caught-fail(v_665) && success?(1-proj-3-tuple(v_665))) in
        {1950}let valid1_10: bool = (if v_666 then 3-proj-3-tuple(v_665) else caught-fail) in
        {1951}let ne_22: bitstring = (if v_666 then 2-proj-3-tuple(v_665) else caught-fail) in
        {1952}let ss_94: symmetricstate = (if v_666 then 1-proj-3-tuple(v_665) else caught-fail) in
        {1953}let rs_20: key = (if v_666 then ne_22 else caught-fail) in
        {1954}let v_667: bitstring = (if v_666 then catch-fail(symmetricstateunpack(ss_94)) else caught-fail) in
        {1955}let v_668: bool = (not-caught-fail(v_667) && success?(1-proj-3-tuple(v_667))) in
        {1956}let h_85: bitstring = (if v_668 then 3-proj-3-tuple(v_667) else caught-fail) in
        {1957}let ck_100: key = (if v_668 then 2-proj-3-tuple(v_667) else caught-fail) in
        {1958}let cs_85: cipherstate = (if v_668 then 1-proj-3-tuple(v_667) else caught-fail) in
        {1959}let v_669: bitstring = (if v_668 then catch-fail(cipherstateunpack(cs_85)) else caught-fail) in
        {1960}let v_670: bool = (not-caught-fail(v_669) && success?(1-proj-2-tuple(v_669))) in
        {1961}let n_52: nonce = (if v_670 then 2-proj-2-tuple(v_669) else caught-fail) in
        {1962}let k_56: key = (if v_670 then 1-proj-2-tuple(v_669) else caught-fail) in
        {1963}let d_13: aead = (if v_670 then catch-fail(decrypt(k_56,n_52,h_85,nm_15)) else caught-fail) in
        {1964}let v_671: bool = not-caught-fail(d_13) in
        {1965}let v_672: bitstring = (if v_671 then catch-fail(aeadunpack(d_13)) else caught-fail) in
        {1966}let v_673: bool = (not-caught-fail(v_672) && success?(1-proj-3-tuple(v_672))) in
        {1967}let plaintext_38: bitstring = (if v_673 then 3-proj-3-tuple(v_672) else caught-fail) in
        {1968}let adi_13: bitstring = (if v_673 then 2-proj-3-tuple(v_672) else caught-fail) in
        {1969}let valid_32: bool = (if v_673 then 1-proj-3-tuple(v_672) else caught-fail) in
        {1970}let n_53: nonce = (if v_673 then increment_nonce(n_52) else caught-fail) in
        {1971}let v_674: bitstring = (if v_673 then catch-fail(cipherstateunpack(cs_85)) else caught-fail) in
        {1972}let v_675: bool = (not-caught-fail(v_674) && success?(1-proj-2-tuple(v_674))) in
        {1973}let o_26: nonce = (if v_675 then 2-proj-2-tuple(v_674) else caught-fail) in
        {1974}let k_57: key = (if v_675 then 1-proj-2-tuple(v_674) else caught-fail) in
        {1975}let csi_52: cipherstate = (if v_673 then catch-fail((if v_675 then cipherstatepack(k_57,n_53) else fail-any)) else caught-fail) in
        {1976}let v_676: bool = not-caught-fail(csi_52) in
        {1977}let v_677: bitstring = (if v_668 then catch-fail((if v_670 then (if v_671 then (if v_673 then (if v_676 then (csi_52,plaintext_38,valid_32) else fail-any) else fail-any) else fail-any) else fail-any)) else caught-fail) in
        {1978}let v_678: bool = (not-caught-fail(v_677) && success?(1-proj-3-tuple(v_677))) in
        {1979}let valid_33: bool = (if v_678 then 3-proj-3-tuple(v_677) else caught-fail) in
        {1980}let plaintext_39: bitstring = (if v_678 then 2-proj-3-tuple(v_677) else caught-fail) in
        {1981}let csi_53: cipherstate = (if v_678 then 1-proj-3-tuple(v_677) else caught-fail) in
        {1982}let ss_95: symmetricstate = (if v_678 then symmetricstatepack(csi_53,ck_100,h_85) else caught-fail) in
        {1983}let v_679: bitstring = (if v_678 then catch-fail(symmetricstateunpack(ss_95)) else caught-fail) in
        {1984}let v_680: bool = (not-caught-fail(v_679) && success?(1-proj-3-tuple(v_679))) in
        {1985}let h_86: bitstring = (if v_680 then 3-proj-3-tuple(v_679) else caught-fail) in
        {1986}let ck_101: key = (if v_680 then 2-proj-3-tuple(v_679) else caught-fail) in
        {1987}let cs_86: cipherstate = (if v_680 then 1-proj-3-tuple(v_679) else caught-fail) in
        {1988}let ssi_29: symmetricstate = (if v_678 then catch-fail((if v_680 then symmetricstatepack(cs_86,ck_101,hash(h_86,nm_15)) else fail-any)) else caught-fail) in
        {1989}let v_681: bool = not-caught-fail(ssi_29) in
        {1990}let v_682: bitstring = (if v_666 then catch-fail((if v_668 then (if v_678 then (if v_681 then (ssi_29,plaintext_39,valid_33) else fail-any) else fail-any) else fail-any)) else caught-fail) in
        {1991}let v_683: bool = (not-caught-fail(v_682) && success?(1-proj-3-tuple(v_682))) in
        {1992}let valid2_10: bool = (if v_683 then 3-proj-3-tuple(v_682) else caught-fail) in
        {1993}let ne_23: bitstring = (if v_683 then 2-proj-3-tuple(v_682) else caught-fail) in
        {1994}let ss_96: symmetricstate = (if v_683 then 1-proj-3-tuple(v_682) else caught-fail) in
        {1995}let rm_20: key = (if v_683 then ne_23 else caught-fail) in
        {1996}let v_684: bitstring = (if v_683 then catch-fail(symmetricstateunpack(ss_96)) else caught-fail) in
        {1997}let v_685: bool = (not-caught-fail(v_684) && success?(1-proj-3-tuple(v_684))) in
        {1998}let h_87: bitstring = (if v_685 then 3-proj-3-tuple(v_684) else caught-fail) in
        {1999}let ck_102: key = (if v_685 then 2-proj-3-tuple(v_684) else caught-fail) in
        {2000}let cs_87: cipherstate = (if v_685 then 1-proj-3-tuple(v_684) else caught-fail) in
        {2001}let v_686: bitstring = (if v_685 then catch-fail(cipherstateunpack(cs_87)) else caught-fail) in
        {2002}let v_687: bool = (not-caught-fail(v_686) && success?(1-proj-2-tuple(v_686))) in
        {2003}let n_54: nonce = (if v_687 then 2-proj-2-tuple(v_686) else caught-fail) in
        {2004}let k_58: key = (if v_687 then 1-proj-2-tuple(v_686) else caught-fail) in
        {2005}let d_14: aead = (if v_687 then catch-fail(decrypt(k_58,n_54,h_87,ciphertext_32)) else caught-fail) in
        {2006}let v_688: bool = not-caught-fail(d_14) in
        {2007}let v_689: bitstring = (if v_688 then catch-fail(aeadunpack(d_14)) else caught-fail) in
        {2008}let v_690: bool = (not-caught-fail(v_689) && success?(1-proj-3-tuple(v_689))) in
        {2009}let plaintext_40: bitstring = (if v_690 then 3-proj-3-tuple(v_689) else caught-fail) in
        {2010}let adi_14: bitstring = (if v_690 then 2-proj-3-tuple(v_689) else caught-fail) in
        {2011}let valid_34: bool = (if v_690 then 1-proj-3-tuple(v_689) else caught-fail) in
        {2012}let n_55: nonce = (if v_690 then increment_nonce(n_54) else caught-fail) in
        {2013}let v_691: bitstring = (if v_690 then catch-fail(cipherstateunpack(cs_87)) else caught-fail) in
        {2014}let v_692: bool = (not-caught-fail(v_691) && success?(1-proj-2-tuple(v_691))) in
        {2015}let o_27: nonce = (if v_692 then 2-proj-2-tuple(v_691) else caught-fail) in
        {2016}let k_59: key = (if v_692 then 1-proj-2-tuple(v_691) else caught-fail) in
        {2017}let csi_54: cipherstate = (if v_690 then catch-fail((if v_692 then cipherstatepack(k_59,n_55) else fail-any)) else caught-fail) in
        {2018}let v_693: bool = not-caught-fail(csi_54) in
        {2019}let v_694: bitstring = (if v_685 then catch-fail((if v_687 then (if v_688 then (if v_690 then (if v_693 then (csi_54,plaintext_40,valid_34) else fail-any) else fail-any) else fail-any) else fail-any)) else caught-fail) in
        {2020}let v_695: bool = (not-caught-fail(v_694) && success?(1-proj-3-tuple(v_694))) in
        {2021}let valid_35: bool = (if v_695 then 3-proj-3-tuple(v_694) else caught-fail) in
        {2022}let plaintext_41: bitstring = (if v_695 then 2-proj-3-tuple(v_694) else caught-fail) in
        {2023}let csi_55: cipherstate = (if v_695 then 1-proj-3-tuple(v_694) else caught-fail) in
        {2024}let ss_97: symmetricstate = (if v_695 then symmetricstatepack(csi_55,ck_102,h_87) else caught-fail) in
        {2025}let v_696: bitstring = (if v_695 then catch-fail(symmetricstateunpack(ss_97)) else caught-fail) in
        {2026}let v_697: bool = (not-caught-fail(v_696) && success?(1-proj-3-tuple(v_696))) in
        {2027}let h_88: bitstring = (if v_697 then 3-proj-3-tuple(v_696) else caught-fail) in
        {2028}let ck_103: key = (if v_697 then 2-proj-3-tuple(v_696) else caught-fail) in
        {2029}let cs_88: cipherstate = (if v_697 then 1-proj-3-tuple(v_696) else caught-fail) in
        {2030}let ssi_30: symmetricstate = (if v_695 then catch-fail((if v_697 then symmetricstatepack(cs_88,ck_103,hash(h_88,ciphertext_32)) else fail-any)) else caught-fail) in
        {2031}let v_698: bool = not-caught-fail(ssi_30) in
        {2032}let v_699: bitstring = (if v_683 then catch-fail((if v_685 then (if v_695 then (if v_698 then (ssi_30,plaintext_41,valid_35) else fail-any) else fail-any) else fail-any)) else caught-fail) in
        {2033}let v_700: bool = (not-caught-fail(v_699) && success?(1-proj-3-tuple(v_699))) in
        {2034}let valid3_3: bool = (if v_700 then 3-proj-3-tuple(v_699) else caught-fail) in
        {2035}let plaintext_42: bitstring = (if v_700 then 2-proj-3-tuple(v_699) else caught-fail) in
        {2036}let ss_98: symmetricstate = (if v_700 then 1-proj-3-tuple(v_699) else caught-fail) in
        {2037}let basis_17: key = (if v_700 then key_s(them_3) else caught-fail) in
        {2038}let public_key_17: key = (if v_700 then catch-fail(dhexp(basis_17,validkey(g))) else caught-fail) in
        {2039}let v_701: bool = not-caught-fail(public_key_17) in
        {2040}let basis_18: key = (if v_700 then key_m(them_3) else caught-fail) in
        {2041}let public_key_18: key = (if v_700 then catch-fail(dhexp(basis_18,validkey(g))) else caught-fail) in
        {2042}let v_702: bool = not-caught-fail(public_key_18) in
        {2043}let v_703: bool = (if v_700 then catch-fail(((valid1_10 && (valid2_10 && valid3_3)) && ((rs_20 = getpublickey((if v_701 then keypairpack(validkey(public_key_17),basis_17) else fail-any))) && (rm_20 = getpublickey((if v_702 then keypairpack(validkey(public_key_18),basis_18) else fail-any)))))) else caught-fail) in
        {2044}let hs_47: handshakestate = (if v_703 then handshakestatepack(ss_98,s_19,m_19,e_32,rs_20,rm_20,re_20,psk_16,initiator_13) else caught-fail) in
        {2045}let (hs_48: handshakestate,plaintext_a_1: bitstring,valid_36: bool) = (if v_644 then (if v_646 then (if v_649 then (if v_666 then (if v_683 then (if v_700 then (if undo-catch-fail(v_703) then (hs_47,plaintext_42,true) else fail-any) else fail-any) else fail-any) else fail-any) else fail-any) else fail-any) else fail-any) in
        {2046}event RecvMsg(me_3,them_3,stagepack_a(sid_4),plaintext_a_1);
        {2047}insert statestore(me_3,them_3,sid_4,statepack_b(hs_48))
    ) | (
        {2359}get statestore(=me_3,=them_3,=sid_4,statepack_b(hs_49: handshakestate)) in
        {2049}let payload_6: bitstring = msg_b(me_3,them_3,sid_4) in
        {2050}let v_704: bitstring = catch-fail(handshakestateunpack(hs_49)) in
        {2051}let v_705: bool = (not-caught-fail(v_704) && success?(1-proj-9-tuple(v_704))) in
        {2052}let initiator_14: bool = (if v_705 then 9-proj-9-tuple(v_704) else caught-fail) in
        {2053}let psk_17: key = (if v_705 then 8-proj-9-tuple(v_704) else caught-fail) in
        {2054}let re_21: key = (if v_705 then 7-proj-9-tuple(v_704) else caught-fail) in
        {2055}let rm_21: key = (if v_705 then 6-proj-9-tuple(v_704) else caught-fail) in
        {2056}let rs_21: key = (if v_705 then 5-proj-9-tuple(v_704) else caught-fail) in
        {2057}let e_33: keypair = (if v_705 then 4-proj-9-tuple(v_704) else caught-fail) in
        {2058}let m_20: keypair = (if v_705 then 3-proj-9-tuple(v_704) else caught-fail) in
        {2059}let s_20: keypair = (if v_705 then 2-proj-9-tuple(v_704) else caught-fail) in
        {2060}let ss_99: symmetricstate = (if v_705 then 1-proj-9-tuple(v_704) else caught-fail) in
        {2061}let v_706: bitstring = (if v_705 then catch-fail((empty,empty,empty,empty)) else caught-fail) in
        {2062}let v_707: bool = (not-caught-fail(v_706) && success?(1-proj-4-tuple(v_706))) in
        {2063}let ciphertext_33: bitstring = (if v_707 then 4-proj-4-tuple(v_706) else caught-fail) in
        {2064}let nm_16: bitstring = (if v_707 then 3-proj-4-tuple(v_706) else caught-fail) in
        {2065}let ns_16: bitstring = (if v_707 then 2-proj-4-tuple(v_706) else caught-fail) in
        {2066}let ne_24: bitstring = (if v_707 then 1-proj-4-tuple(v_706) else caught-fail) in
        {2067}let basis_19: key = (if v_707 then key_e(me_3,them_3,sid_4) else caught-fail) in
        {2068}let public_key_19: key = (if v_707 then catch-fail(dhexp(basis_19,validkey(g))) else caught-fail) in
        {2069}let v_708: bool = not-caught-fail(public_key_19) in
        {2070}let e_34: keypair = (if v_707 then catch-fail((if v_708 then keypairpack(validkey(public_key_19),basis_19) else fail-any)) else caught-fail) in
        {2071}let v_709: bool = not-caught-fail(e_34) in
        {2072}let ne_25: bitstring = (if v_709 then catch-fail(getpublickey(e_34)) else caught-fail) in
        {2073}let v_710: bool = not-caught-fail(ne_25) in
        {2074}let v_711: bitstring = (if v_710 then catch-fail(symmetricstateunpack(ss_99)) else caught-fail) in
        {2075}let v_712: bool = (not-caught-fail(v_711) && success?(1-proj-3-tuple(v_711))) in
        {2076}let h_89: bitstring = (if v_712 then 3-proj-3-tuple(v_711) else caught-fail) in
        {2077}let ck_104: key = (if v_712 then 2-proj-3-tuple(v_711) else caught-fail) in
        {2078}let cs_89: cipherstate = (if v_712 then 1-proj-3-tuple(v_711) else caught-fail) in
        {2079}let ss_100: symmetricstate = (if v_710 then catch-fail((if v_712 then symmetricstatepack(cs_89,ck_104,hash(h_89,ne_25)) else fail-any)) else caught-fail) in
        {2080}let v_713: bool = not-caught-fail(ss_100) in
        {2081}let v_714: bitstring = (if v_713 then catch-fail(keypairunpack(e_34)) else caught-fail) in
        {2082}let v_715: bool = (not-caught-fail(v_714) && success?(1-proj-2-tuple(v_714))) in
        {2083}let my_private_key_15: key = (if v_715 then 2-proj-2-tuple(v_714) else caught-fail) in
        {2084}let my_public_key_15: key = (if v_715 then 1-proj-2-tuple(v_714) else caught-fail) in
        {2085}let input_key_material_18: key = (if v_713 then catch-fail((if v_715 then dhexp(my_private_key_15,re_21) else fail-any)) else caught-fail) in
        {2086}let v_716: bool = not-caught-fail(input_key_material_18) in
        {2087}let v_717: bitstring = (if v_716 then catch-fail(symmetricstateunpack(ss_100)) else caught-fail) in
        {2088}let v_718: bool = (not-caught-fail(v_717) && success?(1-proj-3-tuple(v_717))) in
        {2089}let h_90: bitstring = (if v_718 then 3-proj-3-tuple(v_717) else caught-fail) in
        {2090}let ck_105: key = (if v_718 then 2-proj-3-tuple(v_717) else caught-fail) in
        {2091}let cs_90: cipherstate = (if v_718 then 1-proj-3-tuple(v_717) else caught-fail) in
        {2092}let output1_18: key = (if v_718 then hmac_hash1(ck_105,input_key_material_18) else caught-fail) in
        {2093}let output2_18: key = (if v_718 then hmac_hash2(ck_105,input_key_material_18) else caught-fail) in
        {2094}let output3_18: key = (if v_718 then hmac_hash3(ck_105,input_key_material_18) else caught-fail) in
        {2095}let v_719: bitstring = (if v_718 then catch-fail((output1_18,output2_18,output3_18)) else caught-fail) in
        {2096}let v_720: bool = (not-caught-fail(v_719) && success?(1-proj-3-tuple(v_719))) in
        {2097}let output_15: key = (if v_720 then 3-proj-3-tuple(v_719) else caught-fail) in
        {2098}let temp_k_15: key = (if v_720 then 2-proj-3-tuple(v_719) else caught-fail) in
        {2099}let ck_106: key = (if v_720 then 1-proj-3-tuple(v_719) else caught-fail) in
        {2100}let ss_101: symmetricstate = (if v_713 then catch-fail((if v_716 then (if v_718 then (if v_720 then symmetricstatepack(cipherstatepack(temp_k_15,minnonce),ck_106,h_90) else fail-any) else fail-any) else fail-any)) else caught-fail) in
        {2101}let v_721: bool = not-caught-fail(ss_101) in
        {2102}let v_722: bitstring = (if v_721 then catch-fail(keypairunpack(e_34)) else caught-fail) in
        {2103}let v_723: bool = (not-caught-fail(v_722) && success?(1-proj-2-tuple(v_722))) in
        {2104}let my_private_key_16: key = (if v_723 then 2-proj-2-tuple(v_722) else caught-fail) in
        {2105}let my_public_key_16: key = (if v_723 then 1-proj-2-tuple(v_722) else caught-fail) in
        {2106}let input_key_material_19: key = (if v_721 then catch-fail((if v_723 then dhexp(my_private_key_16,rs_21) else fail-any)) else caught-fail) in
        {2107}let v_724: bool = not-caught-fail(input_key_material_19) in
        {2108}let v_725: bitstring = (if v_724 then catch-fail(symmetricstateunpack(ss_101)) else caught-fail) in
        {2109}let v_726: bool = (not-caught-fail(v_725) && success?(1-proj-3-tuple(v_725))) in
        {2110}let h_91: bitstring = (if v_726 then 3-proj-3-tuple(v_725) else caught-fail) in
        {2111}let ck_107: key = (if v_726 then 2-proj-3-tuple(v_725) else caught-fail) in
        {2112}let cs_91: cipherstate = (if v_726 then 1-proj-3-tuple(v_725) else caught-fail) in
        {2113}let output1_19: key = (if v_726 then hmac_hash1(ck_107,input_key_material_19) else caught-fail) in
        {2114}let output2_19: key = (if v_726 then hmac_hash2(ck_107,input_key_material_19) else caught-fail) in
        {2115}let output3_19: key = (if v_726 then hmac_hash3(ck_107,input_key_material_19) else caught-fail) in
        {2116}let v_727: bitstring = (if v_726 then catch-fail((output1_19,output2_19,output3_19)) else caught-fail) in
        {2117}let v_728: bool = (not-caught-fail(v_727) && success?(1-proj-3-tuple(v_727))) in
        {2118}let output_16: key = (if v_728 then 3-proj-3-tuple(v_727) else caught-fail) in
        {2119}let temp_k_16: key = (if v_728 then 2-proj-3-tuple(v_727) else caught-fail) in
        {2120}let ck_108: key = (if v_728 then 1-proj-3-tuple(v_727) else caught-fail) in
        {2121}let ss_102: symmetricstate = (if v_721 then catch-fail((if v_724 then (if v_726 then (if v_728 then symmetricstatepack(cipherstatepack(temp_k_16,minnonce),ck_108,h_91) else fail-any) else fail-any) else fail-any)) else caught-fail) in
        {2122}let v_729: bool = not-caught-fail(ss_102) in
        {2123}let v_730: bitstring = (if v_729 then catch-fail(keypairunpack(e_34)) else caught-fail) in
        {2124}let v_731: bool = (not-caught-fail(v_730) && success?(1-proj-2-tuple(v_730))) in
        {2125}let my_private_key_17: key = (if v_731 then 2-proj-2-tuple(v_730) else caught-fail) in
        {2126}let my_public_key_17: key = (if v_731 then 1-proj-2-tuple(v_730) else caught-fail) in
        {2127}let input_key_material_20: key = (if v_729 then catch-fail((if v_731 then dhexp(my_private_key_17,rm_21) else fail-any)) else caught-fail) in
        {2128}let v_732: bool = not-caught-fail(input_key_material_20) in
        {2129}let v_733: bitstring = (if v_732 then catch-fail(symmetricstateunpack(ss_102)) else caught-fail) in
        {2130}let v_734: bool = (not-caught-fail(v_733) && success?(1-proj-3-tuple(v_733))) in
        {2131}let h_92: bitstring = (if v_734 then 3-proj-3-tuple(v_733) else caught-fail) in
        {2132}let ck_109: key = (if v_734 then 2-proj-3-tuple(v_733) else caught-fail) in
        {2133}let cs_92: cipherstate = (if v_734 then 1-proj-3-tuple(v_733) else caught-fail) in
        {2134}let output1_20: key = (if v_734 then hmac_hash1(ck_109,input_key_material_20) else caught-fail) in
        {2135}let output2_20: key = (if v_734 then hmac_hash2(ck_109,input_key_material_20) else caught-fail) in
        {2136}let output3_20: key = (if v_734 then hmac_hash3(ck_109,input_key_material_20) else caught-fail) in
        {2137}let v_735: bitstring = (if v_734 then catch-fail((output1_20,output2_20,output3_20)) else caught-fail) in
        {2138}let v_736: bool = (not-caught-fail(v_735) && success?(1-proj-3-tuple(v_735))) in
        {2139}let output_17: key = (if v_736 then 3-proj-3-tuple(v_735) else caught-fail) in
        {2140}let temp_k_17: key = (if v_736 then 2-proj-3-tuple(v_735) else caught-fail) in
        {2141}let ck_110: key = (if v_736 then 1-proj-3-tuple(v_735) else caught-fail) in
        {2142}let ss_103: symmetricstate = (if v_729 then catch-fail((if v_732 then (if v_734 then (if v_736 then symmetricstatepack(cipherstatepack(temp_k_17,minnonce),ck_110,h_92) else fail-any) else fail-any) else fail-any)) else caught-fail) in
        {2143}let v_737: bool = not-caught-fail(ss_103) in
        {2144}let basis_20: key = (if v_737 then key_s(me_3) else caught-fail) in
        {2145}let public_key_20: key = (if v_737 then catch-fail(dhexp(basis_20,validkey(g))) else caught-fail) in
        {2146}let v_738: bool = not-caught-fail(public_key_20) in
        {2147}let s_21: keypair = (if v_737 then catch-fail((if v_738 then keypairpack(validkey(public_key_20),basis_20) else fail-any)) else caught-fail) in
        {2148}let v_739: bool = not-caught-fail(s_21) in
        {2149}let plaintext_43: bitstring = (if v_739 then catch-fail(getpublickey(s_21)) else caught-fail) in
        {2150}let v_740: bool = not-caught-fail(plaintext_43) in
        {2151}let v_741: bitstring = (if v_740 then catch-fail(symmetricstateunpack(ss_103)) else caught-fail) in
        {2152}let v_742: bool = (not-caught-fail(v_741) && success?(1-proj-3-tuple(v_741))) in
        {2153}let h_93: bitstring = (if v_742 then 3-proj-3-tuple(v_741) else caught-fail) in
        {2154}let ck_111: key = (if v_742 then 2-proj-3-tuple(v_741) else caught-fail) in
        {2155}let cs_93: cipherstate = (if v_742 then 1-proj-3-tuple(v_741) else caught-fail) in
        {2156}let v_743: bitstring = (if v_742 then catch-fail(cipherstateunpack(cs_93)) else caught-fail) in
        {2157}let v_744: bool = (not-caught-fail(v_743) && success?(1-proj-2-tuple(v_743))) in
        {2158}let n_56: nonce = (if v_744 then 2-proj-2-tuple(v_743) else caught-fail) in
        {2159}let k_60: key = (if v_744 then 1-proj-2-tuple(v_743) else caught-fail) in
        {2160}let e_35: bitstring = (if v_744 then encrypt(k_60,n_56,h_93,plaintext_43) else caught-fail) in
        {2161}let n_57: nonce = (if v_744 then increment_nonce(n_56) else caught-fail) in
        {2162}let v_745: bitstring = (if v_744 then catch-fail(cipherstateunpack(cs_93)) else caught-fail) in
        {2163}let v_746: bool = (not-caught-fail(v_745) && success?(1-proj-2-tuple(v_745))) in
        {2164}let o_28: nonce = (if v_746 then 2-proj-2-tuple(v_745) else caught-fail) in
        {2165}let k_61: key = (if v_746 then 1-proj-2-tuple(v_745) else caught-fail) in
        {2166}let csi_56: cipherstate = (if v_744 then catch-fail((if v_746 then cipherstatepack(k_61,n_57) else fail-any)) else caught-fail) in
        {2167}let v_747: bool = not-caught-fail(csi_56) in
        {2168}let v_748: bitstring = (if v_742 then catch-fail((if v_744 then (if v_747 then (csi_56,e_35) else fail-any) else fail-any)) else caught-fail) in
        {2169}let v_749: bool = (not-caught-fail(v_748) && success?(1-proj-2-tuple(v_748))) in
        {2170}let ciphertext_34: bitstring = (if v_749 then 2-proj-2-tuple(v_748) else caught-fail) in
        {2171}let csi_57: cipherstate = (if v_749 then 1-proj-2-tuple(v_748) else caught-fail) in
        {2172}let ss_104: symmetricstate = (if v_749 then symmetricstatepack(csi_57,ck_111,h_93) else caught-fail) in
        {2173}let v_750: bitstring = (if v_749 then catch-fail(symmetricstateunpack(ss_104)) else caught-fail) in
        {2174}let v_751: bool = (not-caught-fail(v_750) && success?(1-proj-3-tuple(v_750))) in
        {2175}let h_94: bitstring = (if v_751 then 3-proj-3-tuple(v_750) else caught-fail) in
        {2176}let ck_112: key = (if v_751 then 2-proj-3-tuple(v_750) else caught-fail) in
        {2177}let cs_94: cipherstate = (if v_751 then 1-proj-3-tuple(v_750) else caught-fail) in
        {2178}let ssi_31: symmetricstate = (if v_749 then catch-fail((if v_751 then symmetricstatepack(cs_94,ck_112,hash(h_94,ciphertext_34)) else fail-any)) else caught-fail) in
        {2179}let v_752: bool = not-caught-fail(ssi_31) in
        {2180}let v_753: bitstring = (if v_739 then catch-fail((if v_740 then (if v_742 then (if v_749 then (if v_752 then (ssi_31,ciphertext_34) else fail-any) else fail-any) else fail-any) else fail-any)) else caught-fail) in
        {2181}let v_754: bool = (not-caught-fail(v_753) && success?(1-proj-2-tuple(v_753))) in
        {2182}let ns_17: bitstring = (if v_754 then 2-proj-2-tuple(v_753) else caught-fail) in
        {2183}let ss_105: symmetricstate = (if v_754 then 1-proj-2-tuple(v_753) else caught-fail) in
        {2184}let basis_21: key = (if v_754 then key_m(me_3) else caught-fail) in
        {2185}let public_key_21: key = (if v_754 then catch-fail(dhexp(basis_21,validkey(g))) else caught-fail) in
        {2186}let v_755: bool = not-caught-fail(public_key_21) in
        {2187}let m_21: keypair = (if v_754 then catch-fail((if v_755 then keypairpack(validkey(public_key_21),basis_21) else fail-any)) else caught-fail) in
        {2188}let v_756: bool = not-caught-fail(m_21) in
        {2189}let plaintext_44: bitstring = (if v_756 then catch-fail(getpublickey(m_21)) else caught-fail) in
        {2190}let v_757: bool = not-caught-fail(plaintext_44) in
        {2191}let v_758: bitstring = (if v_757 then catch-fail(symmetricstateunpack(ss_105)) else caught-fail) in
        {2192}let v_759: bool = (not-caught-fail(v_758) && success?(1-proj-3-tuple(v_758))) in
        {2193}let h_95: bitstring = (if v_759 then 3-proj-3-tuple(v_758) else caught-fail) in
        {2194}let ck_113: key = (if v_759 then 2-proj-3-tuple(v_758) else caught-fail) in
        {2195}let cs_95: cipherstate = (if v_759 then 1-proj-3-tuple(v_758) else caught-fail) in
        {2196}let v_760: bitstring = (if v_759 then catch-fail(cipherstateunpack(cs_95)) else caught-fail) in
        {2197}let v_761: bool = (not-caught-fail(v_760) && success?(1-proj-2-tuple(v_760))) in
        {2198}let n_58: nonce = (if v_761 then 2-proj-2-tuple(v_760) else caught-fail) in
        {2199}let k_62: key = (if v_761 then 1-proj-2-tuple(v_760) else caught-fail) in
        {2200}let e_36: bitstring = (if v_761 then encrypt(k_62,n_58,h_95,plaintext_44) else caught-fail) in
        {2201}let n_59: nonce = (if v_761 then increment_nonce(n_58) else caught-fail) in
        {2202}let v_762: bitstring = (if v_761 then catch-fail(cipherstateunpack(cs_95)) else caught-fail) in
        {2203}let v_763: bool = (not-caught-fail(v_762) && success?(1-proj-2-tuple(v_762))) in
        {2204}let o_29: nonce = (if v_763 then 2-proj-2-tuple(v_762) else caught-fail) in
        {2205}let k_63: key = (if v_763 then 1-proj-2-tuple(v_762) else caught-fail) in
        {2206}let csi_58: cipherstate = (if v_761 then catch-fail((if v_763 then cipherstatepack(k_63,n_59) else fail-any)) else caught-fail) in
        {2207}let v_764: bool = not-caught-fail(csi_58) in
        {2208}let v_765: bitstring = (if v_759 then catch-fail((if v_761 then (if v_764 then (csi_58,e_36) else fail-any) else fail-any)) else caught-fail) in
        {2209}let v_766: bool = (not-caught-fail(v_765) && success?(1-proj-2-tuple(v_765))) in
        {2210}let ciphertext_35: bitstring = (if v_766 then 2-proj-2-tuple(v_765) else caught-fail) in
        {2211}let csi_59: cipherstate = (if v_766 then 1-proj-2-tuple(v_765) else caught-fail) in
        {2212}let ss_106: symmetricstate = (if v_766 then symmetricstatepack(csi_59,ck_113,h_95) else caught-fail) in
        {2213}let v_767: bitstring = (if v_766 then catch-fail(symmetricstateunpack(ss_106)) else caught-fail) in
        {2214}let v_768: bool = (not-caught-fail(v_767) && success?(1-proj-3-tuple(v_767))) in
        {2215}let h_96: bitstring = (if v_768 then 3-proj-3-tuple(v_767) else caught-fail) in
        {2216}let ck_114: key = (if v_768 then 2-proj-3-tuple(v_767) else caught-fail) in
        {2217}let cs_96: cipherstate = (if v_768 then 1-proj-3-tuple(v_767) else caught-fail) in
        {2218}let ssi_32: symmetricstate = (if v_766 then catch-fail((if v_768 then symmetricstatepack(cs_96,ck_114,hash(h_96,ciphertext_35)) else fail-any)) else caught-fail) in
        {2219}let v_769: bool = not-caught-fail(ssi_32) in
        {2220}let v_770: bitstring = (if v_756 then catch-fail((if v_757 then (if v_759 then (if v_766 then (if v_769 then (ssi_32,ciphertext_35) else fail-any) else fail-any) else fail-any) else fail-any)) else caught-fail) in
        {2221}let v_771: bool = (not-caught-fail(v_770) && success?(1-proj-2-tuple(v_770))) in
        {2222}let nm_17: bitstring = (if v_771 then 2-proj-2-tuple(v_770) else caught-fail) in
        {2223}let ss_107: symmetricstate = (if v_771 then 1-proj-2-tuple(v_770) else caught-fail) in
        {2224}let v_772: bitstring = (if v_771 then catch-fail(keypairunpack(s_21)) else caught-fail) in
        {2225}let v_773: bool = (not-caught-fail(v_772) && success?(1-proj-2-tuple(v_772))) in
        {2226}let my_private_key_18: key = (if v_773 then 2-proj-2-tuple(v_772) else caught-fail) in
        {2227}let my_public_key_18: key = (if v_773 then 1-proj-2-tuple(v_772) else caught-fail) in
        {2228}let input_key_material_21: key = (if v_771 then catch-fail((if v_773 then dhexp(my_private_key_18,re_21) else fail-any)) else caught-fail) in
        {2229}let v_774: bool = not-caught-fail(input_key_material_21) in
        {2230}let v_775: bitstring = (if v_774 then catch-fail(symmetricstateunpack(ss_107)) else caught-fail) in
        {2231}let v_776: bool = (not-caught-fail(v_775) && success?(1-proj-3-tuple(v_775))) in
        {2232}let h_97: bitstring = (if v_776 then 3-proj-3-tuple(v_775) else caught-fail) in
        {2233}let ck_115: key = (if v_776 then 2-proj-3-tuple(v_775) else caught-fail) in
        {2234}let cs_97: cipherstate = (if v_776 then 1-proj-3-tuple(v_775) else caught-fail) in
        {2235}let output1_21: key = (if v_776 then hmac_hash1(ck_115,input_key_material_21) else caught-fail) in
        {2236}let output2_21: key = (if v_776 then hmac_hash2(ck_115,input_key_material_21) else caught-fail) in
        {2237}let output3_21: key = (if v_776 then hmac_hash3(ck_115,input_key_material_21) else caught-fail) in
        {2238}let v_777: bitstring = (if v_776 then catch-fail((output1_21,output2_21,output3_21)) else caught-fail) in
        {2239}let v_778: bool = (not-caught-fail(v_777) && success?(1-proj-3-tuple(v_777))) in
        {2240}let output_18: key = (if v_778 then 3-proj-3-tuple(v_777) else caught-fail) in
        {2241}let temp_k_18: key = (if v_778 then 2-proj-3-tuple(v_777) else caught-fail) in
        {2242}let ck_116: key = (if v_778 then 1-proj-3-tuple(v_777) else caught-fail) in
        {2243}let ss_108: symmetricstate = (if v_771 then catch-fail((if v_774 then (if v_776 then (if v_778 then symmetricstatepack(cipherstatepack(temp_k_18,minnonce),ck_116,h_97) else fail-any) else fail-any) else fail-any)) else caught-fail) in
        {2244}let v_779: bool = not-caught-fail(ss_108) in
        {2245}let v_780: bitstring = (if v_779 then catch-fail(symmetricstateunpack(ss_108)) else caught-fail) in
        {2246}let v_781: bool = (not-caught-fail(v_780) && success?(1-proj-3-tuple(v_780))) in
        {2247}let h_98: bitstring = (if v_781 then 3-proj-3-tuple(v_780) else caught-fail) in
        {2248}let ck_117: key = (if v_781 then 2-proj-3-tuple(v_780) else caught-fail) in
        {2249}let cs_98: cipherstate = (if v_781 then 1-proj-3-tuple(v_780) else caught-fail) in
        {2250}let v_782: bitstring = (if v_781 then catch-fail(cipherstateunpack(cs_98)) else caught-fail) in
        {2251}let v_783: bool = (not-caught-fail(v_782) && success?(1-proj-2-tuple(v_782))) in
        {2252}let n_60: nonce = (if v_783 then 2-proj-2-tuple(v_782) else caught-fail) in
        {2253}let k_64: key = (if v_783 then 1-proj-2-tuple(v_782) else caught-fail) in
        {2254}let e_37: bitstring = (if v_783 then encrypt(k_64,n_60,h_98,payload_6) else caught-fail) in
        {2255}let n_61: nonce = (if v_783 then increment_nonce(n_60) else caught-fail) in
        {2256}let v_784: bitstring = (if v_783 then catch-fail(cipherstateunpack(cs_98)) else caught-fail) in
        {2257}let v_785: bool = (not-caught-fail(v_784) && success?(1-proj-2-tuple(v_784))) in
        {2258}let o_30: nonce = (if v_785 then 2-proj-2-tuple(v_784) else caught-fail) in
        {2259}let k_65: key = (if v_785 then 1-proj-2-tuple(v_784) else caught-fail) in
        {2260}let csi_60: cipherstate = (if v_783 then catch-fail((if v_785 then cipherstatepack(k_65,n_61) else fail-any)) else caught-fail) in
        {2261}let v_786: bool = not-caught-fail(csi_60) in
        {2262}let v_787: bitstring = (if v_781 then catch-fail((if v_783 then (if v_786 then (csi_60,e_37) else fail-any) else fail-any)) else caught-fail) in
        {2263}let v_788: bool = (not-caught-fail(v_787) && success?(1-proj-2-tuple(v_787))) in
        {2264}let ciphertext_36: bitstring = (if v_788 then 2-proj-2-tuple(v_787) else caught-fail) in
        {2265}let csi_61: cipherstate = (if v_788 then 1-proj-2-tuple(v_787) else caught-fail) in
        {2266}let ss_109: symmetricstate = (if v_788 then symmetricstatepack(csi_61,ck_117,h_98) else caught-fail) in
        {2267}let v_789: bitstring = (if v_788 then catch-fail(symmetricstateunpack(ss_109)) else caught-fail) in
        {2268}let v_790: bool = (not-caught-fail(v_789) && success?(1-proj-3-tuple(v_789))) in
        {2269}let h_99: bitstring = (if v_790 then 3-proj-3-tuple(v_789) else caught-fail) in
        {2270}let ck_118: key = (if v_790 then 2-proj-3-tuple(v_789) else caught-fail) in
        {2271}let cs_99: cipherstate = (if v_790 then 1-proj-3-tuple(v_789) else caught-fail) in
        {2272}let ssi_33: symmetricstate = (if v_788 then catch-fail((if v_790 then symmetricstatepack(cs_99,ck_118,hash(h_99,ciphertext_36)) else fail-any)) else caught-fail) in
        {2273}let v_791: bool = not-caught-fail(ssi_33) in
        {2274}let v_792: bitstring = (if v_779 then catch-fail((if v_781 then (if v_788 then (if v_791 then (ssi_33,ciphertext_36) else fail-any) else fail-any) else fail-any)) else caught-fail) in
        {2275}let v_793: bool = (not-caught-fail(v_792) && success?(1-proj-2-tuple(v_792))) in
        {2276}let ciphertext_37: bitstring = (if v_793 then 2-proj-2-tuple(v_792) else caught-fail) in
        {2277}let ss_110: symmetricstate = (if v_793 then 1-proj-2-tuple(v_792) else caught-fail) in
        {2278}let v_794: bitstring = (if v_793 then catch-fail(keypairunpack(m_21)) else caught-fail) in
        {2279}let v_795: bool = (not-caught-fail(v_794) && success?(1-proj-2-tuple(v_794))) in
        {2280}let my_private_key_19: key = (if v_795 then 2-proj-2-tuple(v_794) else caught-fail) in
        {2281}let my_public_key_19: key = (if v_795 then 1-proj-2-tuple(v_794) else caught-fail) in
        {2282}let input_key_material_22: key = (if v_793 then catch-fail((if v_795 then dhexp(my_private_key_19,re_21) else fail-any)) else caught-fail) in
        {2283}let v_796: bool = not-caught-fail(input_key_material_22) in
        {2284}let v_797: bitstring = (if v_796 then catch-fail(symmetricstateunpack(ss_110)) else caught-fail) in
        {2285}let v_798: bool = (not-caught-fail(v_797) && success?(1-proj-3-tuple(v_797))) in
        {2286}let h_100: bitstring = (if v_798 then 3-proj-3-tuple(v_797) else caught-fail) in
        {2287}let ck_119: key = (if v_798 then 2-proj-3-tuple(v_797) else caught-fail) in
        {2288}let cs_100: cipherstate = (if v_798 then 1-proj-3-tuple(v_797) else caught-fail) in
        {2289}let output1_22: key = (if v_798 then hmac_hash1(ck_119,input_key_material_22) else caught-fail) in
        {2290}let output2_22: key = (if v_798 then hmac_hash2(ck_119,input_key_material_22) else caught-fail) in
        {2291}let output3_22: key = (if v_798 then hmac_hash3(ck_119,input_key_material_22) else caught-fail) in
        {2292}let v_799: bitstring = (if v_798 then catch-fail((output1_22,output2_22,output3_22)) else caught-fail) in
        {2293}let v_800: bool = (not-caught-fail(v_799) && success?(1-proj-3-tuple(v_799))) in
        {2294}let output_19: key = (if v_800 then 3-proj-3-tuple(v_799) else caught-fail) in
        {2295}let temp_k_19: key = (if v_800 then 2-proj-3-tuple(v_799) else caught-fail) in
        {2296}let ck_120: key = (if v_800 then 1-proj-3-tuple(v_799) else caught-fail) in
        {2297}let ss_111: symmetricstate = (if v_793 then catch-fail((if v_796 then (if v_798 then (if v_800 then symmetricstatepack(cipherstatepack(temp_k_19,minnonce),ck_120,h_100) else fail-any) else fail-any) else fail-any)) else caught-fail) in
        {2298}let v_801: bool = not-caught-fail(ss_111) in
        {2299}let v_802: bitstring = (if v_801 then catch-fail(symmetricstateunpack(ss_111)) else caught-fail) in
        {2300}let v_803: bool = (not-caught-fail(v_802) && success?(1-proj-3-tuple(v_802))) in
        {2301}let h_101: bitstring = (if v_803 then 3-proj-3-tuple(v_802) else caught-fail) in
        {2302}let ck_121: key = (if v_803 then 2-proj-3-tuple(v_802) else caught-fail) in
        {2303}let cs_101: cipherstate = (if v_803 then 1-proj-3-tuple(v_802) else caught-fail) in
        {2304}let v_804: bitstring = (if v_803 then catch-fail(cipherstateunpack(cs_101)) else caught-fail) in
        {2305}let v_805: bool = (not-caught-fail(v_804) && success?(1-proj-2-tuple(v_804))) in
        {2306}let n_62: nonce = (if v_805 then 2-proj-2-tuple(v_804) else caught-fail) in
        {2307}let k_66: key = (if v_805 then 1-proj-2-tuple(v_804) else caught-fail) in
        {2308}let e_38: bitstring = (if v_805 then encrypt(k_66,n_62,h_101,payload_6) else caught-fail) in
        {2309}let n_63: nonce = (if v_805 then increment_nonce(n_62) else caught-fail) in
        {2310}let v_806: bitstring = (if v_805 then catch-fail(cipherstateunpack(cs_101)) else caught-fail) in
        {2311}let v_807: bool = (not-caught-fail(v_806) && success?(1-proj-2-tuple(v_806))) in
        {2312}let o_31: nonce = (if v_807 then 2-proj-2-tuple(v_806) else caught-fail) in
        {2313}let k_67: key = (if v_807 then 1-proj-2-tuple(v_806) else caught-fail) in
        {2314}let csi_62: cipherstate = (if v_805 then catch-fail((if v_807 then cipherstatepack(k_67,n_63) else fail-any)) else caught-fail) in
        {2315}let v_808: bool = not-caught-fail(csi_62) in
        {2316}let v_809: bitstring = (if v_803 then catch-fail((if v_805 then (if v_808 then (csi_62,e_38) else fail-any) else fail-any)) else caught-fail) in
        {2317}let v_810: bool = (not-caught-fail(v_809) && success?(1-proj-2-tuple(v_809))) in
        {2318}let ciphertext_38: bitstring = (if v_810 then 2-proj-2-tuple(v_809) else caught-fail) in
        {2319}let csi_63: cipherstate = (if v_810 then 1-proj-2-tuple(v_809) else caught-fail) in
        {2320}let ss_112: symmetricstate = (if v_810 then symmetricstatepack(csi_63,ck_121,h_101) else caught-fail) in
        {2321}let v_811: bitstring = (if v_810 then catch-fail(symmetricstateunpack(ss_112)) else caught-fail) in
        {2322}let v_812: bool = (not-caught-fail(v_811) && success?(1-proj-3-tuple(v_811))) in
        {2323}let h_102: bitstring = (if v_812 then 3-proj-3-tuple(v_811) else caught-fail) in
        {2324}let ck_122: key = (if v_812 then 2-proj-3-tuple(v_811) else caught-fail) in
        {2325}let cs_102: cipherstate = (if v_812 then 1-proj-3-tuple(v_811) else caught-fail) in
        {2326}let ssi_34: symmetricstate = (if v_810 then catch-fail((if v_812 then symmetricstatepack(cs_102,ck_122,hash(h_102,ciphertext_38)) else fail-any)) else caught-fail) in
        {2327}let v_813: bool = not-caught-fail(ssi_34) in
        {2328}let v_814: bitstring = (if v_801 then catch-fail((if v_803 then (if v_810 then (if v_813 then (ssi_34,ciphertext_38) else fail-any) else fail-any) else fail-any)) else caught-fail) in
        {2329}let v_815: bool = (not-caught-fail(v_814) && success?(1-proj-2-tuple(v_814))) in
        {2330}let ciphertext_39: bitstring = (if v_815 then 2-proj-2-tuple(v_814) else caught-fail) in
        {2331}let ss_113: symmetricstate = (if v_815 then 1-proj-2-tuple(v_814) else caught-fail) in
        {2332}let hs_50: handshakestate = (if v_815 then handshakestatepack(ss_113,s_21,m_21,e_34,rs_21,rm_21,re_21,psk_17,initiator_14) else caught-fail) in
        {2333}let message_buffer_6: bitstring = (if v_815 then concat4(ne_25,ns_17,nm_17,ciphertext_39) else caught-fail) in
        {2334}let v_816: bitstring = (if v_815 then catch-fail(symmetricstateunpack(ss_113)) else caught-fail) in
        {2335}let v_817: bool = (not-caught-fail(v_816) && success?(1-proj-3-tuple(v_816))) in
        {2336}let h_103: bitstring = (if v_817 then 3-proj-3-tuple(v_816) else caught-fail) in
        {2337}let ck_123: key = (if v_817 then 2-proj-3-tuple(v_816) else caught-fail) in
        {2338}let cs_103: cipherstate = (if v_817 then 1-proj-3-tuple(v_816) else caught-fail) in
        {2339}let input_key_material_23: key = (if v_817 then zero else caught-fail) in
        {2340}let output1_23: key = (if v_817 then hmac_hash1(ck_123,input_key_material_23) else caught-fail) in
        {2341}let output2_23: key = (if v_817 then hmac_hash2(ck_123,input_key_material_23) else caught-fail) in
        {2342}let output3_23: key = (if v_817 then hmac_hash3(ck_123,input_key_material_23) else caught-fail) in
        {2343}let v_818: bitstring = (if v_817 then catch-fail((output1_23,output2_23,output3_23)) else caught-fail) in
        {2344}let v_819: bool = (not-caught-fail(v_818) && success?(1-proj-3-tuple(v_818))) in
        {2345}let temp_k3_3: key = (if v_819 then 3-proj-3-tuple(v_818) else caught-fail) in
        {2346}let temp_k2_3: key = (if v_819 then 2-proj-3-tuple(v_818) else caught-fail) in
        {2347}let temp_k1_3: key = (if v_819 then 1-proj-3-tuple(v_818) else caught-fail) in
        {2348}let cs1_15: cipherstate = (if v_819 then cipherstatepack(temp_k1_3,minnonce) else caught-fail) in
        {2349}let cs2_15: cipherstate = (if v_819 then cipherstatepack(temp_k2_3,minnonce) else caught-fail) in
        {2350}let v_820: bitstring = (if v_815 then catch-fail((if v_817 then (if v_819 then (ss_113,cs1_15,cs2_15) else fail-any) else fail-any)) else caught-fail) in
        {2351}let v_821: bool = (not-caught-fail(v_820) && success?(1-proj-3-tuple(v_820))) in
        {2352}let cs2_16: cipherstate = (if v_821 then 3-proj-3-tuple(v_820) else caught-fail) in
        {2353}let cs1_16: cipherstate = (if v_821 then 2-proj-3-tuple(v_820) else caught-fail) in
        {2354}let ssi_35: symmetricstate = (if v_821 then 1-proj-3-tuple(v_820) else caught-fail) in
        {2355}let (hs_51: handshakestate,message_b_3: bitstring,cs1_17: cipherstate,cs2_17: cipherstate) = (if v_705 then (if v_707 then (if v_709 then (if v_710 then (if v_713 then (if v_721 then (if v_729 then (if v_737 then (if v_739 then (if v_754 then (if v_756 then (if v_771 then (if v_779 then (if v_793 then (if v_801 then (if v_815 then (if v_821 then (hs_50,message_buffer_6,cs1_16,cs2_16) else fail-any) else fail-any) else fail-any) else fail-any) else fail-any) else fail-any) else fail-any) else fail-any) else fail-any) else fail-any) else fail-any) else fail-any) else fail-any) else fail-any) else fail-any) else fail-any) else fail-any) in
        {2356}event SendMsg(me_3,them_3,stagepack_b(sid_4),msg_b(me_3,them_3,sid_4));
        {2357}insert statestore(me_3,them_3,sid_4,statepack_c(hs_51,cs1_17,cs2_17));
        {2358}out(pub, message_b_3)
    ) | (
        {2360}!
        {2427}get statestore(=me_3,=them_3,=sid_4,statepack_c(hs_52: handshakestate,cs1_18: cipherstate,cs2_18: cipherstate)) in
        {2361}let hs_53: handshakestate = handshakestatesetcs(hs_52,cs1_18) in
        {2362}in(pub, message_c_3: bitstring);
        {2363}let v_822: bitstring = catch-fail(handshakestateunpack(hs_53)) in
        {2364}let v_823: bool = (not-caught-fail(v_822) && success?(1-proj-9-tuple(v_822))) in
        {2365}let initiator_15: bool = (if v_823 then 9-proj-9-tuple(v_822) else caught-fail) in
        {2366}let psk_18: key = (if v_823 then 8-proj-9-tuple(v_822) else caught-fail) in
        {2367}let re_22: key = (if v_823 then 7-proj-9-tuple(v_822) else caught-fail) in
        {2368}let rm_22: key = (if v_823 then 6-proj-9-tuple(v_822) else caught-fail) in
        {2369}let rs_22: key = (if v_823 then 5-proj-9-tuple(v_822) else caught-fail) in
        {2370}let e_39: keypair = (if v_823 then 4-proj-9-tuple(v_822) else caught-fail) in
        {2371}let m_22: keypair = (if v_823 then 3-proj-9-tuple(v_822) else caught-fail) in
        {2372}let s_22: keypair = (if v_823 then 2-proj-9-tuple(v_822) else caught-fail) in
        {2373}let ss_114: symmetricstate = (if v_823 then 1-proj-9-tuple(v_822) else caught-fail) in
        {2374}let v_824: bitstring = (if v_823 then catch-fail(deconcat4(message_c_3)) else caught-fail) in
        {2375}let v_825: bool = (not-caught-fail(v_824) && success?(1-proj-4-tuple(v_824))) in
        {2376}let ciphertext_40: bitstring = (if v_825 then 4-proj-4-tuple(v_824) else caught-fail) in
        {2377}let nm_18: bitstring = (if v_825 then 3-proj-4-tuple(v_824) else caught-fail) in
        {2378}let ns_18: bitstring = (if v_825 then 2-proj-4-tuple(v_824) else caught-fail) in
        {2379}let ne_26: bitstring = (if v_825 then 1-proj-4-tuple(v_824) else caught-fail) in
        {2380}let valid1_11: bool = (if v_825 then true else caught-fail) in
        {2381}let v_826: bitstring = (if v_825 then catch-fail(symmetricstateunpack(ss_114)) else caught-fail) in
        {2382}let v_827: bool = (not-caught-fail(v_826) && success?(1-proj-3-tuple(v_826))) in
        {2383}let h_104: bitstring = (if v_827 then 3-proj-3-tuple(v_826) else caught-fail) in
        {2384}let ck_124: key = (if v_827 then 2-proj-3-tuple(v_826) else caught-fail) in
        {2385}let cs_104: cipherstate = (if v_827 then 1-proj-3-tuple(v_826) else caught-fail) in
        {2386}let v_828: bitstring = (if v_827 then catch-fail(cipherstateunpack(cs_104)) else caught-fail) in
        {2387}let v_829: bool = (not-caught-fail(v_828) && success?(1-proj-2-tuple(v_828))) in
        {2388}let n_64: nonce = (if v_829 then 2-proj-2-tuple(v_828) else caught-fail) in
        {2389}let k_68: key = (if v_829 then 1-proj-2-tuple(v_828) else caught-fail) in
        {2390}let d_15: aead = (if v_829 then catch-fail(decrypt(k_68,n_64,h_104,ciphertext_40)) else caught-fail) in
        {2391}let v_830: bool = not-caught-fail(d_15) in
        {2392}let v_831: bitstring = (if v_830 then catch-fail(aeadunpack(d_15)) else caught-fail) in
        {2393}let v_832: bool = (not-caught-fail(v_831) && success?(1-proj-3-tuple(v_831))) in
        {2394}let plaintext_45: bitstring = (if v_832 then 3-proj-3-tuple(v_831) else caught-fail) in
        {2395}let adi_15: bitstring = (if v_832 then 2-proj-3-tuple(v_831) else caught-fail) in
        {2396}let valid_37: bool = (if v_832 then 1-proj-3-tuple(v_831) else caught-fail) in
        {2397}let n_65: nonce = (if v_832 then increment_nonce(n_64) else caught-fail) in
        {2398}let v_833: bitstring = (if v_832 then catch-fail(cipherstateunpack(cs_104)) else caught-fail) in
        {2399}let v_834: bool = (not-caught-fail(v_833) && success?(1-proj-2-tuple(v_833))) in
        {2400}let o_32: nonce = (if v_834 then 2-proj-2-tuple(v_833) else caught-fail) in
        {2401}let k_69: key = (if v_834 then 1-proj-2-tuple(v_833) else caught-fail) in
        {2402}let csi_64: cipherstate = (if v_832 then catch-fail((if v_834 then cipherstatepack(k_69,n_65) else fail-any)) else caught-fail) in
        {2403}let v_835: bool = not-caught-fail(csi_64) in
        {2404}let v_836: bitstring = (if v_827 then catch-fail((if v_829 then (if v_830 then (if v_832 then (if v_835 then (csi_64,plaintext_45,valid_37) else fail-any) else fail-any) else fail-any) else fail-any)) else caught-fail) in
        {2405}let v_837: bool = (not-caught-fail(v_836) && success?(1-proj-3-tuple(v_836))) in
        {2406}let valid_38: bool = (if v_837 then 3-proj-3-tuple(v_836) else caught-fail) in
        {2407}let plaintext_46: bitstring = (if v_837 then 2-proj-3-tuple(v_836) else caught-fail) in
        {2408}let csi_65: cipherstate = (if v_837 then 1-proj-3-tuple(v_836) else caught-fail) in
        {2409}let ss_115: symmetricstate = (if v_837 then symmetricstatepack(csi_65,ck_124,h_104) else caught-fail) in
        {2410}let v_838: bitstring = (if v_837 then catch-fail(symmetricstateunpack(ss_115)) else caught-fail) in
        {2411}let v_839: bool = (not-caught-fail(v_838) && success?(1-proj-3-tuple(v_838))) in
        {2412}let h_105: bitstring = (if v_839 then 3-proj-3-tuple(v_838) else caught-fail) in
        {2413}let ck_125: key = (if v_839 then 2-proj-3-tuple(v_838) else caught-fail) in
        {2414}let cs_105: cipherstate = (if v_839 then 1-proj-3-tuple(v_838) else caught-fail) in
        {2415}let ssi_36: symmetricstate = (if v_837 then catch-fail((if v_839 then symmetricstatepack(cs_105,ck_125,hash(h_105,ciphertext_40)) else fail-any)) else caught-fail) in
        {2416}let v_840: bool = not-caught-fail(ssi_36) in
        {2417}let v_841: bitstring = (if v_825 then catch-fail((if v_827 then (if v_837 then (if v_840 then (ssi_36,plaintext_46,valid_38) else fail-any) else fail-any) else fail-any)) else caught-fail) in
        {2418}let v_842: bool = (not-caught-fail(v_841) && success?(1-proj-3-tuple(v_841))) in
        {2419}let valid2_11: bool = (if v_842 then 3-proj-3-tuple(v_841) else caught-fail) in
        {2420}let plaintext_47: bitstring = (if v_842 then 2-proj-3-tuple(v_841) else caught-fail) in
        {2421}let ss_116: symmetricstate = (if v_842 then 1-proj-3-tuple(v_841) else caught-fail) in
        {2422}let v_843: bool = (if v_842 then catch-fail((valid1_11 && valid2_11)) else caught-fail) in
        {2423}let hs_54: handshakestate = (if v_843 then handshakestatepack(ss_116,s_22,m_22,e_39,rs_22,rm_22,re_22,psk_18,initiator_15) else caught-fail) in
        {2424}let (hs_55: handshakestate,plaintext_c_1: bitstring,valid_39: bool) = (if v_823 then (if v_825 then (if v_842 then (if undo-catch-fail(v_843) then (hs_54,plaintext_47,true) else fail-any) else fail-any) else fail-any) else fail-any) in
        {2425}event RecvMsg(me_3,them_3,stagepack_c(sid_4),plaintext_c_1);
        {2426}insert statestore(me_3,them_3,sid_4,statepack_d(hs_55,handshakestategetcs(hs_55),cs2_18))
    ) | (
        {2428}!
        {2486}get statestore(=me_3,=them_3,=sid_4,statepack_d(hs_56: handshakestate,cs1_19: cipherstate,cs2_19: cipherstate)) in
        {2429}let hs_57: handshakestate = handshakestatesetcs(hs_56,cs2_19) in
        {2430}let payload_7: bitstring = msg_d(me_3,them_3,sid_4) in
        {2431}let v_844: bitstring = catch-fail(handshakestateunpack(hs_57)) in
        {2432}let v_845: bool = (not-caught-fail(v_844) && success?(1-proj-9-tuple(v_844))) in
        {2433}let initiator_16: bool = (if v_845 then 9-proj-9-tuple(v_844) else caught-fail) in
        {2434}let psk_19: key = (if v_845 then 8-proj-9-tuple(v_844) else caught-fail) in
        {2435}let re_23: key = (if v_845 then 7-proj-9-tuple(v_844) else caught-fail) in
        {2436}let rm_23: key = (if v_845 then 6-proj-9-tuple(v_844) else caught-fail) in
        {2437}let rs_23: key = (if v_845 then 5-proj-9-tuple(v_844) else caught-fail) in
        {2438}let e_40: keypair = (if v_845 then 4-proj-9-tuple(v_844) else caught-fail) in
        {2439}let m_23: keypair = (if v_845 then 3-proj-9-tuple(v_844) else caught-fail) in
        {2440}let s_23: keypair = (if v_845 then 2-proj-9-tuple(v_844) else caught-fail) in
        {2441}let ss_117: symmetricstate = (if v_845 then 1-proj-9-tuple(v_844) else caught-fail) in
        {2442}let v_846: bitstring = (if v_845 then catch-fail((empty,empty,empty,empty)) else caught-fail) in
        {2443}let v_847: bool = (not-caught-fail(v_846) && success?(1-proj-4-tuple(v_846))) in
        {2444}let ciphertext_41: bitstring = (if v_847 then 4-proj-4-tuple(v_846) else caught-fail) in
        {2445}let nm_19: bitstring = (if v_847 then 3-proj-4-tuple(v_846) else caught-fail) in
        {2446}let ns_19: bitstring = (if v_847 then 2-proj-4-tuple(v_846) else caught-fail) in
        {2447}let ne_27: bitstring = (if v_847 then 1-proj-4-tuple(v_846) else caught-fail) in
        {2448}let v_848: bitstring = (if v_847 then catch-fail(symmetricstateunpack(ss_117)) else caught-fail) in
        {2449}let v_849: bool = (not-caught-fail(v_848) && success?(1-proj-3-tuple(v_848))) in
        {2450}let h_106: bitstring = (if v_849 then 3-proj-3-tuple(v_848) else caught-fail) in
        {2451}let ck_126: key = (if v_849 then 2-proj-3-tuple(v_848) else caught-fail) in
        {2452}let cs_106: cipherstate = (if v_849 then 1-proj-3-tuple(v_848) else caught-fail) in
        {2453}let v_850: bitstring = (if v_849 then catch-fail(cipherstateunpack(cs_106)) else caught-fail) in
        {2454}let v_851: bool = (not-caught-fail(v_850) && success?(1-proj-2-tuple(v_850))) in
        {2455}let n_66: nonce = (if v_851 then 2-proj-2-tuple(v_850) else caught-fail) in
        {2456}let k_70: key = (if v_851 then 1-proj-2-tuple(v_850) else caught-fail) in
        {2457}let e_41: bitstring = (if v_851 then encrypt(k_70,n_66,h_106,payload_7) else caught-fail) in
        {2458}let n_67: nonce = (if v_851 then increment_nonce(n_66) else caught-fail) in
        {2459}let v_852: bitstring = (if v_851 then catch-fail(cipherstateunpack(cs_106)) else caught-fail) in
        {2460}let v_853: bool = (not-caught-fail(v_852) && success?(1-proj-2-tuple(v_852))) in
        {2461}let o_33: nonce = (if v_853 then 2-proj-2-tuple(v_852) else caught-fail) in
        {2462}let k_71: key = (if v_853 then 1-proj-2-tuple(v_852) else caught-fail) in
        {2463}let csi_66: cipherstate = (if v_851 then catch-fail((if v_853 then cipherstatepack(k_71,n_67) else fail-any)) else caught-fail) in
        {2464}let v_854: bool = not-caught-fail(csi_66) in
        {2465}let v_855: bitstring = (if v_849 then catch-fail((if v_851 then (if v_854 then (csi_66,e_41) else fail-any) else fail-any)) else caught-fail) in
        {2466}let v_856: bool = (not-caught-fail(v_855) && success?(1-proj-2-tuple(v_855))) in
        {2467}let ciphertext_42: bitstring = (if v_856 then 2-proj-2-tuple(v_855) else caught-fail) in
        {2468}let csi_67: cipherstate = (if v_856 then 1-proj-2-tuple(v_855) else caught-fail) in
        {2469}let ss_118: symmetricstate = (if v_856 then symmetricstatepack(csi_67,ck_126,h_106) else caught-fail) in
        {2470}let v_857: bitstring = (if v_856 then catch-fail(symmetricstateunpack(ss_118)) else caught-fail) in
        {2471}let v_858: bool = (not-caught-fail(v_857) && success?(1-proj-3-tuple(v_857))) in
        {2472}let h_107: bitstring = (if v_858 then 3-proj-3-tuple(v_857) else caught-fail) in
        {2473}let ck_127: key = (if v_858 then 2-proj-3-tuple(v_857) else caught-fail) in
        {2474}let cs_107: cipherstate = (if v_858 then 1-proj-3-tuple(v_857) else caught-fail) in
        {2475}let ssi_37: symmetricstate = (if v_856 then catch-fail((if v_858 then symmetricstatepack(cs_107,ck_127,hash(h_107,ciphertext_42)) else fail-any)) else caught-fail) in
        {2476}let v_859: bool = not-caught-fail(ssi_37) in
        {2477}let v_860: bitstring = (if v_847 then catch-fail((if v_849 then (if v_856 then (if v_859 then (ssi_37,ciphertext_42) else fail-any) else fail-any) else fail-any)) else caught-fail) in
        {2478}let v_861: bool = (not-caught-fail(v_860) && success?(1-proj-2-tuple(v_860))) in
        {2479}let ciphertext_43: bitstring = (if v_861 then 2-proj-2-tuple(v_860) else caught-fail) in
        {2480}let ss_119: symmetricstate = (if v_861 then 1-proj-2-tuple(v_860) else caught-fail) in
        {2481}let hs_58: handshakestate = (if v_861 then handshakestatepack(ss_119,s_23,m_23,e_40,rs_23,rm_23,re_23,psk_19,initiator_16) else caught-fail) in
        {2482}let message_buffer_7: bitstring = (if v_861 then concat4(ne_27,ns_19,nm_19,ciphertext_43) else caught-fail) in
        {2483}let (hs_59: handshakestate,message_d_3: bitstring) = (if v_845 then (if v_847 then (if v_861 then (hs_58,message_buffer_7) else fail-any) else fail-any) else fail-any) in
        {2484}event SendMsg(me_3,them_3,stagepack_d(sid_4),msg_d(me_3,them_3,sid_4));
        {2485}out(pub, message_d_3)
    ) | (
        {2487}event LeakS(phase0,me_3);
        {2488}event LeakM(phase0,me_3);
        {2489}out(pub, (key_s(me_3),key_m(me_3)))
    ) | (
        {2490}phase 1;
        {2491}event LeakS(phase1,me_3);
        {2492}event LeakM(phase1,me_3);
        {2493}out(pub, (key_s(me_3),key_m(me_3)))
    )
)

--  Process 1 (that is, process 0, with let moved downwards):
{1}out(pub, (key_s(charlie),key_m(charlie)));
{2}!
{3}new sid: sessionid;
(
    {8}let m: keypair = keypairpack(empty,empty) in
    {7}let s: keypair = keypairpack(empty,empty) in
    {9}out(pub, (getpublickey(s),getpublickey(m)));
    {6}let sid_1: sessionid = sid in
    {5}let them: principal = bob in
    {4}let me: principal = alice in
    (
        {19}let k: key = empty in
        {20}let cs: cipherstate = cipherstatepack(k,minnonce) in
        {16}let protocol_name: bitstring = somename in
        {17}let h: bitstring = hash(protocol_name,empty) in
        {18}let ck: key = h in
        {21}let ss: symmetricstate = symmetricstatepack(cs,ck,h) in
        {22}let v: bitstring = catch-fail(symmetricstateunpack(ss)) in
        {23}let v_1: bool = (not-caught-fail(v) && success?(1-proj-3-tuple(v))) in
        {24}let h_1: bitstring = (if v_1 then 3-proj-3-tuple(v) else caught-fail) in
        {25}let ck_1: key = (if v_1 then 2-proj-3-tuple(v) else caught-fail) in
        {26}let cs_1: cipherstate = (if v_1 then 1-proj-3-tuple(v) else caught-fail) in
        {14}let prologue: bitstring = empty in
        {27}let ss_1: symmetricstate = catch-fail((if v_1 then symmetricstatepack(cs_1,ck_1,hash(h_1,prologue)) else fail-any)) in
        {28}let v_2: bool = not-caught-fail(ss_1) in
        {15}let psk: key = empty in
        {13}let re: key = empty in
        {12}let rm: key = empty in
        {11}let rs: key = empty in
        {10}let e: keypair = keypairpack(empty,empty) in
        {29}let hs: handshakestate = (if v_2 then handshakestatepack(ss_1,s,m,e,rs,rm,re,psk,true) else fail-any) in
        {30}insert statestore(me,them,sid_1,statepack_a(hs))
    ) | (
        {182}get statestore(=me,=them,=sid_1,statepack_a(hs_1: handshakestate)) in
        {32}let v_3: bitstring = catch-fail(handshakestateunpack(hs_1)) in
        {33}let v_4: bool = (not-caught-fail(v_3) && success?(1-proj-9-tuple(v_3))) in
        {34}let initiator_1: bool = (if v_4 then 9-proj-9-tuple(v_3) else caught-fail) in
        {35}let psk_1: key = (if v_4 then 8-proj-9-tuple(v_3) else caught-fail) in
        {36}let re_1: key = (if v_4 then 7-proj-9-tuple(v_3) else caught-fail) in
        {37}let rm_1: key = (if v_4 then 6-proj-9-tuple(v_3) else caught-fail) in
        {38}let rs_1: key = (if v_4 then 5-proj-9-tuple(v_3) else caught-fail) in
        {39}let e_1: keypair = (if v_4 then 4-proj-9-tuple(v_3) else caught-fail) in
        {40}let m_1: keypair = (if v_4 then 3-proj-9-tuple(v_3) else caught-fail) in
        {41}let s_1: keypair = (if v_4 then 2-proj-9-tuple(v_3) else caught-fail) in
        {42}let ss_2: symmetricstate = (if v_4 then 1-proj-9-tuple(v_3) else caught-fail) in
        {43}let v_5: bitstring = (if v_4 then catch-fail((empty,empty,empty,empty)) else caught-fail) in
        {44}let v_6: bool = (not-caught-fail(v_5) && success?(1-proj-4-tuple(v_5))) in
        {45}let ciphertext: bitstring = (if v_6 then 4-proj-4-tuple(v_5) else caught-fail) in
        {46}let nm: bitstring = (if v_6 then 3-proj-4-tuple(v_5) else caught-fail) in
        {47}let ns: bitstring = (if v_6 then 2-proj-4-tuple(v_5) else caught-fail) in
        {48}let ne: bitstring = (if v_6 then 1-proj-4-tuple(v_5) else caught-fail) in
        {49}let basis: key = (if v_6 then key_e(me,them,sid_1) else caught-fail) in
        {50}let public_key: key = (if v_6 then catch-fail(dhexp(basis,validkey(g))) else caught-fail) in
        {51}let v_7: bool = not-caught-fail(public_key) in
        {52}let e_2: keypair = (if v_6 then catch-fail((if v_7 then keypairpack(validkey(public_key),basis) else fail-any)) else caught-fail) in
        {53}let v_8: bool = not-caught-fail(e_2) in
        {54}let ne_1: bitstring = (if v_8 then catch-fail(getpublickey(e_2)) else caught-fail) in
        {55}let v_9: bool = not-caught-fail(ne_1) in
        {56}let v_10: bitstring = (if v_9 then catch-fail(symmetricstateunpack(ss_2)) else caught-fail) in
        {57}let v_11: bool = (not-caught-fail(v_10) && success?(1-proj-3-tuple(v_10))) in
        {58}let h_2: bitstring = (if v_11 then 3-proj-3-tuple(v_10) else caught-fail) in
        {59}let ck_2: key = (if v_11 then 2-proj-3-tuple(v_10) else caught-fail) in
        {60}let cs_2: cipherstate = (if v_11 then 1-proj-3-tuple(v_10) else caught-fail) in
        {61}let ss_3: symmetricstate = (if v_9 then catch-fail((if v_11 then symmetricstatepack(cs_2,ck_2,hash(h_2,ne_1)) else fail-any)) else caught-fail) in
        {62}let v_12: bool = not-caught-fail(ss_3) in
        {63}let basis_1: key = (if v_12 then key_s(me) else caught-fail) in
        {64}let public_key_1: key = (if v_12 then catch-fail(dhexp(basis_1,validkey(g))) else caught-fail) in
        {65}let v_13: bool = not-caught-fail(public_key_1) in
        {66}let s_2: keypair = (if v_12 then catch-fail((if v_13 then keypairpack(validkey(public_key_1),basis_1) else fail-any)) else caught-fail) in
        {67}let v_14: bool = not-caught-fail(s_2) in
        {68}let plaintext: bitstring = (if v_14 then catch-fail(getpublickey(s_2)) else caught-fail) in
        {69}let v_15: bool = not-caught-fail(plaintext) in
        {70}let v_16: bitstring = (if v_15 then catch-fail(symmetricstateunpack(ss_3)) else caught-fail) in
        {71}let v_17: bool = (not-caught-fail(v_16) && success?(1-proj-3-tuple(v_16))) in
        {72}let h_3: bitstring = (if v_17 then 3-proj-3-tuple(v_16) else caught-fail) in
        {73}let ck_3: key = (if v_17 then 2-proj-3-tuple(v_16) else caught-fail) in
        {74}let cs_3: cipherstate = (if v_17 then 1-proj-3-tuple(v_16) else caught-fail) in
        {75}let v_18: bitstring = (if v_17 then catch-fail(cipherstateunpack(cs_3)) else caught-fail) in
        {76}let v_19: bool = (not-caught-fail(v_18) && success?(1-proj-2-tuple(v_18))) in
        {77}let n: nonce = (if v_19 then 2-proj-2-tuple(v_18) else caught-fail) in
        {78}let k_1: key = (if v_19 then 1-proj-2-tuple(v_18) else caught-fail) in
        {81}let v_20: bitstring = (if v_19 then catch-fail(cipherstateunpack(cs_3)) else caught-fail) in
        {82}let v_21: bool = (not-caught-fail(v_20) && success?(1-proj-2-tuple(v_20))) in
        {83}let o: nonce = (if v_21 then 2-proj-2-tuple(v_20) else caught-fail) in
        {84}let k_2: key = (if v_21 then 1-proj-2-tuple(v_20) else caught-fail) in
        {80}let n_1: nonce = (if v_19 then increment_nonce(n) else caught-fail) in
        {85}let csi: cipherstate = (if v_19 then catch-fail((if v_21 then cipherstatepack(k_2,n_1) else fail-any)) else caught-fail) in
        {86}let v_22: bool = not-caught-fail(csi) in
        {79}let e_3: bitstring = (if v_19 then encrypt(k_1,n,h_3,plaintext) else caught-fail) in
        {87}let v_23: bitstring = (if v_17 then catch-fail((if v_19 then (if v_22 then (csi,e_3) else fail-any) else fail-any)) else caught-fail) in
        {88}let v_24: bool = (not-caught-fail(v_23) && success?(1-proj-2-tuple(v_23))) in
        {89}let ciphertext_1: bitstring = (if v_24 then 2-proj-2-tuple(v_23) else caught-fail) in
        {90}let csi_1: cipherstate = (if v_24 then 1-proj-2-tuple(v_23) else caught-fail) in
        {91}let ss_4: symmetricstate = (if v_24 then symmetricstatepack(csi_1,ck_3,h_3) else caught-fail) in
        {92}let v_25: bitstring = (if v_24 then catch-fail(symmetricstateunpack(ss_4)) else caught-fail) in
        {93}let v_26: bool = (not-caught-fail(v_25) && success?(1-proj-3-tuple(v_25))) in
        {94}let h_4: bitstring = (if v_26 then 3-proj-3-tuple(v_25) else caught-fail) in
        {95}let ck_4: key = (if v_26 then 2-proj-3-tuple(v_25) else caught-fail) in
        {96}let cs_4: cipherstate = (if v_26 then 1-proj-3-tuple(v_25) else caught-fail) in
        {97}let ssi: symmetricstate = (if v_24 then catch-fail((if v_26 then symmetricstatepack(cs_4,ck_4,hash(h_4,ciphertext_1)) else fail-any)) else caught-fail) in
        {98}let v_27: bool = not-caught-fail(ssi) in
        {99}let v_28: bitstring = (if v_14 then catch-fail((if v_15 then (if v_17 then (if v_24 then (if v_27 then (ssi,ciphertext_1) else fail-any) else fail-any) else fail-any) else fail-any)) else caught-fail) in
        {100}let v_29: bool = (not-caught-fail(v_28) && success?(1-proj-2-tuple(v_28))) in
        {101}let ns_1: bitstring = (if v_29 then 2-proj-2-tuple(v_28) else caught-fail) in
        {102}let ss_5: symmetricstate = (if v_29 then 1-proj-2-tuple(v_28) else caught-fail) in
        {103}let basis_2: key = (if v_29 then key_m(me) else caught-fail) in
        {104}let public_key_2: key = (if v_29 then catch-fail(dhexp(basis_2,validkey(g))) else caught-fail) in
        {105}let v_30: bool = not-caught-fail(public_key_2) in
        {106}let m_2: keypair = (if v_29 then catch-fail((if v_30 then keypairpack(validkey(public_key_2),basis_2) else fail-any)) else caught-fail) in
        {107}let v_31: bool = not-caught-fail(m_2) in
        {108}let plaintext_1: bitstring = (if v_31 then catch-fail(getpublickey(m_2)) else caught-fail) in
        {109}let v_32: bool = not-caught-fail(plaintext_1) in
        {110}let v_33: bitstring = (if v_32 then catch-fail(symmetricstateunpack(ss_5)) else caught-fail) in
        {111}let v_34: bool = (not-caught-fail(v_33) && success?(1-proj-3-tuple(v_33))) in
        {112}let h_5: bitstring = (if v_34 then 3-proj-3-tuple(v_33) else caught-fail) in
        {113}let ck_5: key = (if v_34 then 2-proj-3-tuple(v_33) else caught-fail) in
        {114}let cs_5: cipherstate = (if v_34 then 1-proj-3-tuple(v_33) else caught-fail) in
        {115}let v_35: bitstring = (if v_34 then catch-fail(cipherstateunpack(cs_5)) else caught-fail) in
        {116}let v_36: bool = (not-caught-fail(v_35) && success?(1-proj-2-tuple(v_35))) in
        {117}let n_2: nonce = (if v_36 then 2-proj-2-tuple(v_35) else caught-fail) in
        {118}let k_3: key = (if v_36 then 1-proj-2-tuple(v_35) else caught-fail) in
        {121}let v_37: bitstring = (if v_36 then catch-fail(cipherstateunpack(cs_5)) else caught-fail) in
        {122}let v_38: bool = (not-caught-fail(v_37) && success?(1-proj-2-tuple(v_37))) in
        {123}let o_1: nonce = (if v_38 then 2-proj-2-tuple(v_37) else caught-fail) in
        {124}let k_4: key = (if v_38 then 1-proj-2-tuple(v_37) else caught-fail) in
        {120}let n_3: nonce = (if v_36 then increment_nonce(n_2) else caught-fail) in
        {125}let csi_2: cipherstate = (if v_36 then catch-fail((if v_38 then cipherstatepack(k_4,n_3) else fail-any)) else caught-fail) in
        {126}let v_39: bool = not-caught-fail(csi_2) in
        {119}let e_4: bitstring = (if v_36 then encrypt(k_3,n_2,h_5,plaintext_1) else caught-fail) in
        {127}let v_40: bitstring = (if v_34 then catch-fail((if v_36 then (if v_39 then (csi_2,e_4) else fail-any) else fail-any)) else caught-fail) in
        {128}let v_41: bool = (not-caught-fail(v_40) && success?(1-proj-2-tuple(v_40))) in
        {129}let ciphertext_2: bitstring = (if v_41 then 2-proj-2-tuple(v_40) else caught-fail) in
        {130}let csi_3: cipherstate = (if v_41 then 1-proj-2-tuple(v_40) else caught-fail) in
        {131}let ss_6: symmetricstate = (if v_41 then symmetricstatepack(csi_3,ck_5,h_5) else caught-fail) in
        {132}let v_42: bitstring = (if v_41 then catch-fail(symmetricstateunpack(ss_6)) else caught-fail) in
        {133}let v_43: bool = (not-caught-fail(v_42) && success?(1-proj-3-tuple(v_42))) in
        {134}let h_6: bitstring = (if v_43 then 3-proj-3-tuple(v_42) else caught-fail) in
        {135}let ck_6: key = (if v_43 then 2-proj-3-tuple(v_42) else caught-fail) in
        {136}let cs_6: cipherstate = (if v_43 then 1-proj-3-tuple(v_42) else caught-fail) in
        {137}let ssi_1: symmetricstate = (if v_41 then catch-fail((if v_43 then symmetricstatepack(cs_6,ck_6,hash(h_6,ciphertext_2)) else fail-any)) else caught-fail) in
        {138}let v_44: bool = not-caught-fail(ssi_1) in
        {139}let v_45: bitstring = (if v_31 then catch-fail((if v_32 then (if v_34 then (if v_41 then (if v_44 then (ssi_1,ciphertext_2) else fail-any) else fail-any) else fail-any) else fail-any)) else caught-fail) in
        {140}let v_46: bool = (not-caught-fail(v_45) && success?(1-proj-2-tuple(v_45))) in
        {141}let nm_1: bitstring = (if v_46 then 2-proj-2-tuple(v_45) else caught-fail) in
        {142}let ss_7: symmetricstate = (if v_46 then 1-proj-2-tuple(v_45) else caught-fail) in
        {143}let v_47: bitstring = (if v_46 then catch-fail(symmetricstateunpack(ss_7)) else caught-fail) in
        {144}let v_48: bool = (not-caught-fail(v_47) && success?(1-proj-3-tuple(v_47))) in
        {145}let h_7: bitstring = (if v_48 then 3-proj-3-tuple(v_47) else caught-fail) in
        {146}let ck_7: key = (if v_48 then 2-proj-3-tuple(v_47) else caught-fail) in
        {147}let cs_7: cipherstate = (if v_48 then 1-proj-3-tuple(v_47) else caught-fail) in
        {148}let v_49: bitstring = (if v_48 then catch-fail(cipherstateunpack(cs_7)) else caught-fail) in
        {149}let v_50: bool = (not-caught-fail(v_49) && success?(1-proj-2-tuple(v_49))) in
        {150}let n_4: nonce = (if v_50 then 2-proj-2-tuple(v_49) else caught-fail) in
        {151}let k_5: key = (if v_50 then 1-proj-2-tuple(v_49) else caught-fail) in
        {154}let v_51: bitstring = (if v_50 then catch-fail(cipherstateunpack(cs_7)) else caught-fail) in
        {155}let v_52: bool = (not-caught-fail(v_51) && success?(1-proj-2-tuple(v_51))) in
        {156}let o_2: nonce = (if v_52 then 2-proj-2-tuple(v_51) else caught-fail) in
        {157}let k_6: key = (if v_52 then 1-proj-2-tuple(v_51) else caught-fail) in
        {153}let n_5: nonce = (if v_50 then increment_nonce(n_4) else caught-fail) in
        {158}let csi_4: cipherstate = (if v_50 then catch-fail((if v_52 then cipherstatepack(k_6,n_5) else fail-any)) else caught-fail) in
        {159}let v_53: bool = not-caught-fail(csi_4) in
        {31}let payload: bitstring = msg_a(me,them,sid_1) in
        {152}let e_5: bitstring = (if v_50 then encrypt(k_5,n_4,h_7,payload) else caught-fail) in
        {160}let v_54: bitstring = (if v_48 then catch-fail((if v_50 then (if v_53 then (csi_4,e_5) else fail-any) else fail-any)) else caught-fail) in
        {161}let v_55: bool = (not-caught-fail(v_54) && success?(1-proj-2-tuple(v_54))) in
        {162}let ciphertext_3: bitstring = (if v_55 then 2-proj-2-tuple(v_54) else caught-fail) in
        {163}let csi_5: cipherstate = (if v_55 then 1-proj-2-tuple(v_54) else caught-fail) in
        {164}let ss_8: symmetricstate = (if v_55 then symmetricstatepack(csi_5,ck_7,h_7) else caught-fail) in
        {165}let v_56: bitstring = (if v_55 then catch-fail(symmetricstateunpack(ss_8)) else caught-fail) in
        {166}let v_57: bool = (not-caught-fail(v_56) && success?(1-proj-3-tuple(v_56))) in
        {167}let h_8: bitstring = (if v_57 then 3-proj-3-tuple(v_56) else caught-fail) in
        {168}let ck_8: key = (if v_57 then 2-proj-3-tuple(v_56) else caught-fail) in
        {169}let cs_8: cipherstate = (if v_57 then 1-proj-3-tuple(v_56) else caught-fail) in
        {170}let ssi_2: symmetricstate = (if v_55 then catch-fail((if v_57 then symmetricstatepack(cs_8,ck_8,hash(h_8,ciphertext_3)) else fail-any)) else caught-fail) in
        {171}let v_58: bool = not-caught-fail(ssi_2) in
        {172}let v_59: bitstring = (if v_46 then catch-fail((if v_48 then (if v_55 then (if v_58 then (ssi_2,ciphertext_3) else fail-any) else fail-any) else fail-any)) else caught-fail) in
        {173}let v_60: bool = (not-caught-fail(v_59) && success?(1-proj-2-tuple(v_59))) in
        {174}let ciphertext_4: bitstring = (if v_60 then 2-proj-2-tuple(v_59) else caught-fail) in
        {175}let ss_9: symmetricstate = (if v_60 then 1-proj-2-tuple(v_59) else caught-fail) in
        {177}let message_buffer: bitstring = (if v_60 then concat4(ne_1,ns_1,nm_1,ciphertext_4) else caught-fail) in
        {176}let hs_2: handshakestate = (if v_60 then handshakestatepack(ss_9,s_2,m_2,e_2,rs_1,rm_1,re_1,psk_1,initiator_1) else caught-fail) in
        {178}let (hs_3: handshakestate,message_a: bitstring) = (if v_4 then (if v_6 then (if v_8 then (if v_9 then (if v_12 then (if v_14 then (if v_29 then (if v_31 then (if v_46 then (if v_60 then (hs_2,message_buffer) else fail-any) else fail-any) else fail-any) else fail-any) else fail-any) else fail-any) else fail-any) else fail-any) else fail-any) else fail-any) in
        {179}event SendMsg(me,them,stagepack_a(sid_1),msg_a(me,them,sid_1));
        {180}insert statestore(me,them,sid_1,statepack_b(hs_3));
        {181}out(pub, message_a)
    ) | (
        {473}get statestore(=me,=them,=sid_1,statepack_b(hs_4: handshakestate)) in
        {183}in(pub, message_b: bitstring);
        {184}let v_61: bitstring = catch-fail(handshakestateunpack(hs_4)) in
        {185}let v_62: bool = (not-caught-fail(v_61) && success?(1-proj-9-tuple(v_61))) in
        {186}let initiator_2: bool = (if v_62 then 9-proj-9-tuple(v_61) else caught-fail) in
        {187}let psk_2: key = (if v_62 then 8-proj-9-tuple(v_61) else caught-fail) in
        {188}let re_2: key = (if v_62 then 7-proj-9-tuple(v_61) else caught-fail) in
        {189}let rm_2: key = (if v_62 then 6-proj-9-tuple(v_61) else caught-fail) in
        {190}let rs_2: key = (if v_62 then 5-proj-9-tuple(v_61) else caught-fail) in
        {191}let e_6: keypair = (if v_62 then 4-proj-9-tuple(v_61) else caught-fail) in
        {192}let m_3: keypair = (if v_62 then 3-proj-9-tuple(v_61) else caught-fail) in
        {193}let s_3: keypair = (if v_62 then 2-proj-9-tuple(v_61) else caught-fail) in
        {194}let ss_10: symmetricstate = (if v_62 then 1-proj-9-tuple(v_61) else caught-fail) in
        {195}let v_63: bitstring = (if v_62 then catch-fail(deconcat4(message_b)) else caught-fail) in
        {196}let v_64: bool = (not-caught-fail(v_63) && success?(1-proj-4-tuple(v_63))) in
        {197}let ciphertext_5: bitstring = (if v_64 then 4-proj-4-tuple(v_63) else caught-fail) in
        {198}let nm_2: bitstring = (if v_64 then 3-proj-4-tuple(v_63) else caught-fail) in
        {199}let ns_2: bitstring = (if v_64 then 2-proj-4-tuple(v_63) else caught-fail) in
        {200}let ne_2: bitstring = (if v_64 then 1-proj-4-tuple(v_63) else caught-fail) in
        {204}let v_65: bitstring = (if v_64 then catch-fail(symmetricstateunpack(ss_10)) else caught-fail) in
        {205}let v_66: bool = (not-caught-fail(v_65) && success?(1-proj-3-tuple(v_65))) in
        {206}let h_9: bitstring = (if v_66 then 3-proj-3-tuple(v_65) else caught-fail) in
        {207}let ck_9: key = (if v_66 then 2-proj-3-tuple(v_65) else caught-fail) in
        {208}let cs_9: cipherstate = (if v_66 then 1-proj-3-tuple(v_65) else caught-fail) in
        {203}let re_3: key = (if v_64 then ne_2 else caught-fail) in
        {209}let ss_11: symmetricstate = (if v_64 then catch-fail((if v_66 then symmetricstatepack(cs_9,ck_9,hash(h_9,re_3)) else fail-any)) else caught-fail) in
        {210}let v_67: bool = not-caught-fail(ss_11) in
        {211}let v_68: bitstring = (if v_67 then catch-fail(keypairunpack(e_6)) else caught-fail) in
        {212}let v_69: bool = (not-caught-fail(v_68) && success?(1-proj-2-tuple(v_68))) in
        {213}let my_private_key: key = (if v_69 then 2-proj-2-tuple(v_68) else caught-fail) in
        {214}let my_public_key: key = (if v_69 then 1-proj-2-tuple(v_68) else caught-fail) in
        {215}let input_key_material: key = (if v_67 then catch-fail((if v_69 then dhexp(my_private_key,re_3) else fail-any)) else caught-fail) in
        {216}let v_70: bool = not-caught-fail(input_key_material) in
        {217}let v_71: bitstring = (if v_70 then catch-fail(symmetricstateunpack(ss_11)) else caught-fail) in
        {218}let v_72: bool = (not-caught-fail(v_71) && success?(1-proj-3-tuple(v_71))) in
        {219}let h_10: bitstring = (if v_72 then 3-proj-3-tuple(v_71) else caught-fail) in
        {220}let ck_10: key = (if v_72 then 2-proj-3-tuple(v_71) else caught-fail) in
        {221}let cs_10: cipherstate = (if v_72 then 1-proj-3-tuple(v_71) else caught-fail) in
        {224}let output3: key = (if v_72 then hmac_hash3(ck_10,input_key_material) else caught-fail) in
        {223}let output2: key = (if v_72 then hmac_hash2(ck_10,input_key_material) else caught-fail) in
        {222}let output1: key = (if v_72 then hmac_hash1(ck_10,input_key_material) else caught-fail) in
        {225}let v_73: bitstring = (if v_72 then catch-fail((output1,output2,output3)) else caught-fail) in
        {226}let v_74: bool = (not-caught-fail(v_73) && success?(1-proj-3-tuple(v_73))) in
        {227}let output_3: key = (if v_74 then 3-proj-3-tuple(v_73) else caught-fail) in
        {228}let temp_k: key = (if v_74 then 2-proj-3-tuple(v_73) else caught-fail) in
        {229}let ck_11: key = (if v_74 then 1-proj-3-tuple(v_73) else caught-fail) in
        {230}let ss_12: symmetricstate = (if v_67 then catch-fail((if v_70 then (if v_72 then (if v_74 then symmetricstatepack(cipherstatepack(temp_k,minnonce),ck_11,h_10) else fail-any) else fail-any) else fail-any)) else caught-fail) in
        {231}let v_75: bool = not-caught-fail(ss_12) in
        {232}let v_76: bitstring = (if v_75 then catch-fail(keypairunpack(s_3)) else caught-fail) in
        {233}let v_77: bool = (not-caught-fail(v_76) && success?(1-proj-2-tuple(v_76))) in
        {234}let my_private_key_1: key = (if v_77 then 2-proj-2-tuple(v_76) else caught-fail) in
        {235}let my_public_key_1: key = (if v_77 then 1-proj-2-tuple(v_76) else caught-fail) in
        {236}let input_key_material_1: key = (if v_75 then catch-fail((if v_77 then dhexp(my_private_key_1,re_3) else fail-any)) else caught-fail) in
        {237}let v_78: bool = not-caught-fail(input_key_material_1) in
        {238}let v_79: bitstring = (if v_78 then catch-fail(symmetricstateunpack(ss_12)) else caught-fail) in
        {239}let v_80: bool = (not-caught-fail(v_79) && success?(1-proj-3-tuple(v_79))) in
        {240}let h_11: bitstring = (if v_80 then 3-proj-3-tuple(v_79) else caught-fail) in
        {241}let ck_12: key = (if v_80 then 2-proj-3-tuple(v_79) else caught-fail) in
        {242}let cs_11: cipherstate = (if v_80 then 1-proj-3-tuple(v_79) else caught-fail) in
        {245}let output3_1: key = (if v_80 then hmac_hash3(ck_12,input_key_material_1) else caught-fail) in
        {244}let output2_1: key = (if v_80 then hmac_hash2(ck_12,input_key_material_1) else caught-fail) in
        {243}let output1_1: key = (if v_80 then hmac_hash1(ck_12,input_key_material_1) else caught-fail) in
        {246}let v_81: bitstring = (if v_80 then catch-fail((output1_1,output2_1,output3_1)) else caught-fail) in
        {247}let v_82: bool = (not-caught-fail(v_81) && success?(1-proj-3-tuple(v_81))) in
        {248}let output: key = (if v_82 then 3-proj-3-tuple(v_81) else caught-fail) in
        {249}let temp_k_1: key = (if v_82 then 2-proj-3-tuple(v_81) else caught-fail) in
        {250}let ck_13: key = (if v_82 then 1-proj-3-tuple(v_81) else caught-fail) in
        {251}let ss_13: symmetricstate = (if v_75 then catch-fail((if v_78 then (if v_80 then (if v_82 then symmetricstatepack(cipherstatepack(temp_k_1,minnonce),ck_13,h_11) else fail-any) else fail-any) else fail-any)) else caught-fail) in
        {252}let v_83: bool = not-caught-fail(ss_13) in
        {253}let v_84: bitstring = (if v_83 then catch-fail(keypairunpack(m_3)) else caught-fail) in
        {254}let v_85: bool = (not-caught-fail(v_84) && success?(1-proj-2-tuple(v_84))) in
        {255}let my_private_key_2: key = (if v_85 then 2-proj-2-tuple(v_84) else caught-fail) in
        {256}let my_public_key_2: key = (if v_85 then 1-proj-2-tuple(v_84) else caught-fail) in
        {257}let input_key_material_2: key = (if v_83 then catch-fail((if v_85 then dhexp(my_private_key_2,re_3) else fail-any)) else caught-fail) in
        {258}let v_86: bool = not-caught-fail(input_key_material_2) in
        {259}let v_87: bitstring = (if v_86 then catch-fail(symmetricstateunpack(ss_13)) else caught-fail) in
        {260}let v_88: bool = (not-caught-fail(v_87) && success?(1-proj-3-tuple(v_87))) in
        {261}let h_12: bitstring = (if v_88 then 3-proj-3-tuple(v_87) else caught-fail) in
        {262}let ck_14: key = (if v_88 then 2-proj-3-tuple(v_87) else caught-fail) in
        {263}let cs_12: cipherstate = (if v_88 then 1-proj-3-tuple(v_87) else caught-fail) in
        {266}let output3_2: key = (if v_88 then hmac_hash3(ck_14,input_key_material_2) else caught-fail) in
        {265}let output2_2: key = (if v_88 then hmac_hash2(ck_14,input_key_material_2) else caught-fail) in
        {264}let output1_2: key = (if v_88 then hmac_hash1(ck_14,input_key_material_2) else caught-fail) in
        {267}let v_89: bitstring = (if v_88 then catch-fail((output1_2,output2_2,output3_2)) else caught-fail) in
        {268}let v_90: bool = (not-caught-fail(v_89) && success?(1-proj-3-tuple(v_89))) in
        {269}let output_1: key = (if v_90 then 3-proj-3-tuple(v_89) else caught-fail) in
        {270}let temp_k_2: key = (if v_90 then 2-proj-3-tuple(v_89) else caught-fail) in
        {271}let ck_15: key = (if v_90 then 1-proj-3-tuple(v_89) else caught-fail) in
        {272}let ss_14: symmetricstate = (if v_83 then catch-fail((if v_86 then (if v_88 then (if v_90 then symmetricstatepack(cipherstatepack(temp_k_2,minnonce),ck_15,h_12) else fail-any) else fail-any) else fail-any)) else caught-fail) in
        {273}let v_91: bool = not-caught-fail(ss_14) in
        {274}let v_92: bitstring = (if v_91 then catch-fail(symmetricstateunpack(ss_14)) else caught-fail) in
        {275}let v_93: bool = (not-caught-fail(v_92) && success?(1-proj-3-tuple(v_92))) in
        {276}let h_13: bitstring = (if v_93 then 3-proj-3-tuple(v_92) else caught-fail) in
        {277}let ck_16: key = (if v_93 then 2-proj-3-tuple(v_92) else caught-fail) in
        {278}let cs_13: cipherstate = (if v_93 then 1-proj-3-tuple(v_92) else caught-fail) in
        {279}let v_94: bitstring = (if v_93 then catch-fail(cipherstateunpack(cs_13)) else caught-fail) in
        {280}let v_95: bool = (not-caught-fail(v_94) && success?(1-proj-2-tuple(v_94))) in
        {281}let n_6: nonce = (if v_95 then 2-proj-2-tuple(v_94) else caught-fail) in
        {282}let k_7: key = (if v_95 then 1-proj-2-tuple(v_94) else caught-fail) in
        {283}let d: aead = (if v_95 then catch-fail(decrypt(k_7,n_6,h_13,ns_2)) else caught-fail) in
        {284}let v_96: bool = not-caught-fail(d) in
        {285}let v_97: bitstring = (if v_96 then catch-fail(aeadunpack(d)) else caught-fail) in
        {286}let v_98: bool = (not-caught-fail(v_97) && success?(1-proj-3-tuple(v_97))) in
        {287}let plaintext_2: bitstring = (if v_98 then 3-proj-3-tuple(v_97) else caught-fail) in
        {288}let adi: bitstring = (if v_98 then 2-proj-3-tuple(v_97) else caught-fail) in
        {289}let valid: bool = (if v_98 then 1-proj-3-tuple(v_97) else caught-fail) in
        {291}let v_99: bitstring = (if v_98 then catch-fail(cipherstateunpack(cs_13)) else caught-fail) in
        {292}let v_100: bool = (not-caught-fail(v_99) && success?(1-proj-2-tuple(v_99))) in
        {293}let o_3: nonce = (if v_100 then 2-proj-2-tuple(v_99) else caught-fail) in
        {294}let k_8: key = (if v_100 then 1-proj-2-tuple(v_99) else caught-fail) in
        {290}let n_7: nonce = (if v_98 then increment_nonce(n_6) else caught-fail) in
        {295}let csi_6: cipherstate = (if v_98 then catch-fail((if v_100 then cipherstatepack(k_8,n_7) else fail-any)) else caught-fail) in
        {296}let v_101: bool = not-caught-fail(csi_6) in
        {297}let v_102: bitstring = (if v_93 then catch-fail((if v_95 then (if v_96 then (if v_98 then (if v_101 then (csi_6,plaintext_2,valid) else fail-any) else fail-any) else fail-any) else fail-any)) else caught-fail) in
        {298}let v_103: bool = (not-caught-fail(v_102) && success?(1-proj-3-tuple(v_102))) in
        {299}let valid_1: bool = (if v_103 then 3-proj-3-tuple(v_102) else caught-fail) in
        {300}let plaintext_3: bitstring = (if v_103 then 2-proj-3-tuple(v_102) else caught-fail) in
        {301}let csi_7: cipherstate = (if v_103 then 1-proj-3-tuple(v_102) else caught-fail) in
        {302}let ss_15: symmetricstate = (if v_103 then symmetricstatepack(csi_7,ck_16,h_13) else caught-fail) in
        {303}let v_104: bitstring = (if v_103 then catch-fail(symmetricstateunpack(ss_15)) else caught-fail) in
        {304}let v_105: bool = (not-caught-fail(v_104) && success?(1-proj-3-tuple(v_104))) in
        {305}let h_14: bitstring = (if v_105 then 3-proj-3-tuple(v_104) else caught-fail) in
        {306}let ck_17: key = (if v_105 then 2-proj-3-tuple(v_104) else caught-fail) in
        {307}let cs_14: cipherstate = (if v_105 then 1-proj-3-tuple(v_104) else caught-fail) in
        {308}let ssi_3: symmetricstate = (if v_103 then catch-fail((if v_105 then symmetricstatepack(cs_14,ck_17,hash(h_14,ns_2)) else fail-any)) else caught-fail) in
        {309}let v_106: bool = not-caught-fail(ssi_3) in
        {310}let v_107: bitstring = (if v_91 then catch-fail((if v_93 then (if v_103 then (if v_106 then (ssi_3,plaintext_3,valid_1) else fail-any) else fail-any) else fail-any)) else caught-fail) in
        {311}let v_108: bool = (not-caught-fail(v_107) && success?(1-proj-3-tuple(v_107))) in
        {312}let valid1_1: bool = (if v_108 then 3-proj-3-tuple(v_107) else caught-fail) in
        {313}let ne_3: bitstring = (if v_108 then 2-proj-3-tuple(v_107) else caught-fail) in
        {314}let ss_16: symmetricstate = (if v_108 then 1-proj-3-tuple(v_107) else caught-fail) in
        {316}let v_109: bitstring = (if v_108 then catch-fail(symmetricstateunpack(ss_16)) else caught-fail) in
        {317}let v_110: bool = (not-caught-fail(v_109) && success?(1-proj-3-tuple(v_109))) in
        {318}let h_15: bitstring = (if v_110 then 3-proj-3-tuple(v_109) else caught-fail) in
        {319}let ck_18: key = (if v_110 then 2-proj-3-tuple(v_109) else caught-fail) in
        {320}let cs_15: cipherstate = (if v_110 then 1-proj-3-tuple(v_109) else caught-fail) in
        {321}let v_111: bitstring = (if v_110 then catch-fail(cipherstateunpack(cs_15)) else caught-fail) in
        {322}let v_112: bool = (not-caught-fail(v_111) && success?(1-proj-2-tuple(v_111))) in
        {323}let n_8: nonce = (if v_112 then 2-proj-2-tuple(v_111) else caught-fail) in
        {324}let k_9: key = (if v_112 then 1-proj-2-tuple(v_111) else caught-fail) in
        {325}let d_1: aead = (if v_112 then catch-fail(decrypt(k_9,n_8,h_15,nm_2)) else caught-fail) in
        {326}let v_113: bool = not-caught-fail(d_1) in
        {327}let v_114: bitstring = (if v_113 then catch-fail(aeadunpack(d_1)) else caught-fail) in
        {328}let v_115: bool = (not-caught-fail(v_114) && success?(1-proj-3-tuple(v_114))) in
        {329}let plaintext_4: bitstring = (if v_115 then 3-proj-3-tuple(v_114) else caught-fail) in
        {330}let adi_1: bitstring = (if v_115 then 2-proj-3-tuple(v_114) else caught-fail) in
        {331}let valid_2: bool = (if v_115 then 1-proj-3-tuple(v_114) else caught-fail) in
        {333}let v_116: bitstring = (if v_115 then catch-fail(cipherstateunpack(cs_15)) else caught-fail) in
        {334}let v_117: bool = (not-caught-fail(v_116) && success?(1-proj-2-tuple(v_116))) in
        {335}let o_4: nonce = (if v_117 then 2-proj-2-tuple(v_116) else caught-fail) in
        {336}let k_10: key = (if v_117 then 1-proj-2-tuple(v_116) else caught-fail) in
        {332}let n_9: nonce = (if v_115 then increment_nonce(n_8) else caught-fail) in
        {337}let csi_8: cipherstate = (if v_115 then catch-fail((if v_117 then cipherstatepack(k_10,n_9) else fail-any)) else caught-fail) in
        {338}let v_118: bool = not-caught-fail(csi_8) in
        {339}let v_119: bitstring = (if v_110 then catch-fail((if v_112 then (if v_113 then (if v_115 then (if v_118 then (csi_8,plaintext_4,valid_2) else fail-any) else fail-any) else fail-any) else fail-any)) else caught-fail) in
        {340}let v_120: bool = (not-caught-fail(v_119) && success?(1-proj-3-tuple(v_119))) in
        {341}let valid_3: bool = (if v_120 then 3-proj-3-tuple(v_119) else caught-fail) in
        {342}let plaintext_5: bitstring = (if v_120 then 2-proj-3-tuple(v_119) else caught-fail) in
        {343}let csi_9: cipherstate = (if v_120 then 1-proj-3-tuple(v_119) else caught-fail) in
        {344}let ss_17: symmetricstate = (if v_120 then symmetricstatepack(csi_9,ck_18,h_15) else caught-fail) in
        {345}let v_121: bitstring = (if v_120 then catch-fail(symmetricstateunpack(ss_17)) else caught-fail) in
        {346}let v_122: bool = (not-caught-fail(v_121) && success?(1-proj-3-tuple(v_121))) in
        {347}let h_16: bitstring = (if v_122 then 3-proj-3-tuple(v_121) else caught-fail) in
        {348}let ck_19: key = (if v_122 then 2-proj-3-tuple(v_121) else caught-fail) in
        {349}let cs_16: cipherstate = (if v_122 then 1-proj-3-tuple(v_121) else caught-fail) in
        {350}let ssi_4: symmetricstate = (if v_120 then catch-fail((if v_122 then symmetricstatepack(cs_16,ck_19,hash(h_16,nm_2)) else fail-any)) else caught-fail) in
        {351}let v_123: bool = not-caught-fail(ssi_4) in
        {352}let v_124: bitstring = (if v_108 then catch-fail((if v_110 then (if v_120 then (if v_123 then (ssi_4,plaintext_5,valid_3) else fail-any) else fail-any) else fail-any)) else caught-fail) in
        {353}let v_125: bool = (not-caught-fail(v_124) && success?(1-proj-3-tuple(v_124))) in
        {354}let valid2_1: bool = (if v_125 then 3-proj-3-tuple(v_124) else caught-fail) in
        {355}let ne_4: bitstring = (if v_125 then 2-proj-3-tuple(v_124) else caught-fail) in
        {356}let ss_18: symmetricstate = (if v_125 then 1-proj-3-tuple(v_124) else caught-fail) in
        {358}let v_126: bitstring = (if v_125 then catch-fail(keypairunpack(e_6)) else caught-fail) in
        {359}let v_127: bool = (not-caught-fail(v_126) && success?(1-proj-2-tuple(v_126))) in
        {360}let my_private_key_3: key = (if v_127 then 2-proj-2-tuple(v_126) else caught-fail) in
        {361}let my_public_key_3: key = (if v_127 then 1-proj-2-tuple(v_126) else caught-fail) in
        {315}let rs_3: key = (if v_108 then ne_3 else caught-fail) in
        {362}let input_key_material_3: key = (if v_125 then catch-fail((if v_127 then dhexp(my_private_key_3,rs_3) else fail-any)) else caught-fail) in
        {363}let v_128: bool = not-caught-fail(input_key_material_3) in
        {364}let v_129: bitstring = (if v_128 then catch-fail(symmetricstateunpack(ss_18)) else caught-fail) in
        {365}let v_130: bool = (not-caught-fail(v_129) && success?(1-proj-3-tuple(v_129))) in
        {366}let h_17: bitstring = (if v_130 then 3-proj-3-tuple(v_129) else caught-fail) in
        {367}let ck_20: key = (if v_130 then 2-proj-3-tuple(v_129) else caught-fail) in
        {368}let cs_17: cipherstate = (if v_130 then 1-proj-3-tuple(v_129) else caught-fail) in
        {371}let output3_3: key = (if v_130 then hmac_hash3(ck_20,input_key_material_3) else caught-fail) in
        {370}let output2_3: key = (if v_130 then hmac_hash2(ck_20,input_key_material_3) else caught-fail) in
        {369}let output1_3: key = (if v_130 then hmac_hash1(ck_20,input_key_material_3) else caught-fail) in
        {372}let v_131: bitstring = (if v_130 then catch-fail((output1_3,output2_3,output3_3)) else caught-fail) in
        {373}let v_132: bool = (not-caught-fail(v_131) && success?(1-proj-3-tuple(v_131))) in
        {374}let output_2: key = (if v_132 then 3-proj-3-tuple(v_131) else caught-fail) in
        {375}let temp_k_3: key = (if v_132 then 2-proj-3-tuple(v_131) else caught-fail) in
        {376}let ck_21: key = (if v_132 then 1-proj-3-tuple(v_131) else caught-fail) in
        {377}let ss_19: symmetricstate = (if v_125 then catch-fail((if v_128 then (if v_130 then (if v_132 then symmetricstatepack(cipherstatepack(temp_k_3,minnonce),ck_21,h_17) else fail-any) else fail-any) else fail-any)) else caught-fail) in
        {378}let v_133: bool = not-caught-fail(ss_19) in
        {379}let v_134: bitstring = (if v_133 then catch-fail(keypairunpack(e_6)) else caught-fail) in
        {380}let v_135: bool = (not-caught-fail(v_134) && success?(1-proj-2-tuple(v_134))) in
        {381}let my_private_key_4: key = (if v_135 then 2-proj-2-tuple(v_134) else caught-fail) in
        {382}let my_public_key_4: key = (if v_135 then 1-proj-2-tuple(v_134) else caught-fail) in
        {357}let rm_3: key = (if v_125 then ne_4 else caught-fail) in
        {383}let input_key_material_4: key = (if v_133 then catch-fail((if v_135 then dhexp(my_private_key_4,rm_3) else fail-any)) else caught-fail) in
        {384}let v_136: bool = not-caught-fail(input_key_material_4) in
        {385}let v_137: bitstring = (if v_136 then catch-fail(symmetricstateunpack(ss_19)) else caught-fail) in
        {386}let v_138: bool = (not-caught-fail(v_137) && success?(1-proj-3-tuple(v_137))) in
        {387}let h_18: bitstring = (if v_138 then 3-proj-3-tuple(v_137) else caught-fail) in
        {388}let ck_22: key = (if v_138 then 2-proj-3-tuple(v_137) else caught-fail) in
        {389}let cs_18: cipherstate = (if v_138 then 1-proj-3-tuple(v_137) else caught-fail) in
        {392}let output3_4: key = (if v_138 then hmac_hash3(ck_22,input_key_material_4) else caught-fail) in
        {391}let output2_4: key = (if v_138 then hmac_hash2(ck_22,input_key_material_4) else caught-fail) in
        {390}let output1_4: key = (if v_138 then hmac_hash1(ck_22,input_key_material_4) else caught-fail) in
        {393}let v_139: bitstring = (if v_138 then catch-fail((output1_4,output2_4,output3_4)) else caught-fail) in
        {394}let v_140: bool = (not-caught-fail(v_139) && success?(1-proj-3-tuple(v_139))) in
        {395}let output_4: key = (if v_140 then 3-proj-3-tuple(v_139) else caught-fail) in
        {396}let temp_k_4: key = (if v_140 then 2-proj-3-tuple(v_139) else caught-fail) in
        {397}let ck_23: key = (if v_140 then 1-proj-3-tuple(v_139) else caught-fail) in
        {398}let ss_20: symmetricstate = (if v_133 then catch-fail((if v_136 then (if v_138 then (if v_140 then symmetricstatepack(cipherstatepack(temp_k_4,minnonce),ck_23,h_18) else fail-any) else fail-any) else fail-any)) else caught-fail) in
        {399}let v_141: bool = not-caught-fail(ss_20) in
        {400}let v_142: bitstring = (if v_141 then catch-fail(symmetricstateunpack(ss_20)) else caught-fail) in
        {401}let v_143: bool = (not-caught-fail(v_142) && success?(1-proj-3-tuple(v_142))) in
        {402}let h_19: bitstring = (if v_143 then 3-proj-3-tuple(v_142) else caught-fail) in
        {403}let ck_24: key = (if v_143 then 2-proj-3-tuple(v_142) else caught-fail) in
        {404}let cs_19: cipherstate = (if v_143 then 1-proj-3-tuple(v_142) else caught-fail) in
        {405}let v_144: bitstring = (if v_143 then catch-fail(cipherstateunpack(cs_19)) else caught-fail) in
        {406}let v_145: bool = (not-caught-fail(v_144) && success?(1-proj-2-tuple(v_144))) in
        {407}let n_10: nonce = (if v_145 then 2-proj-2-tuple(v_144) else caught-fail) in
        {408}let k_11: key = (if v_145 then 1-proj-2-tuple(v_144) else caught-fail) in
        {409}let d_2: aead = (if v_145 then catch-fail(decrypt(k_11,n_10,h_19,ciphertext_5)) else caught-fail) in
        {410}let v_146: bool = not-caught-fail(d_2) in
        {411}let v_147: bitstring = (if v_146 then catch-fail(aeadunpack(d_2)) else caught-fail) in
        {412}let v_148: bool = (not-caught-fail(v_147) && success?(1-proj-3-tuple(v_147))) in
        {413}let plaintext_6: bitstring = (if v_148 then 3-proj-3-tuple(v_147) else caught-fail) in
        {414}let adi_2: bitstring = (if v_148 then 2-proj-3-tuple(v_147) else caught-fail) in
        {415}let valid_4: bool = (if v_148 then 1-proj-3-tuple(v_147) else caught-fail) in
        {417}let v_149: bitstring = (if v_148 then catch-fail(cipherstateunpack(cs_19)) else caught-fail) in
        {418}let v_150: bool = (not-caught-fail(v_149) && success?(1-proj-2-tuple(v_149))) in
        {419}let o_5: nonce = (if v_150 then 2-proj-2-tuple(v_149) else caught-fail) in
        {420}let k_12: key = (if v_150 then 1-proj-2-tuple(v_149) else caught-fail) in
        {416}let n_11: nonce = (if v_148 then increment_nonce(n_10) else caught-fail) in
        {421}let csi_10: cipherstate = (if v_148 then catch-fail((if v_150 then cipherstatepack(k_12,n_11) else fail-any)) else caught-fail) in
        {422}let v_151: bool = not-caught-fail(csi_10) in
        {423}let v_152: bitstring = (if v_143 then catch-fail((if v_145 then (if v_146 then (if v_148 then (if v_151 then (csi_10,plaintext_6,valid_4) else fail-any) else fail-any) else fail-any) else fail-any)) else caught-fail) in
        {424}let v_153: bool = (not-caught-fail(v_152) && success?(1-proj-3-tuple(v_152))) in
        {425}let valid_5: bool = (if v_153 then 3-proj-3-tuple(v_152) else caught-fail) in
        {426}let plaintext_7: bitstring = (if v_153 then 2-proj-3-tuple(v_152) else caught-fail) in
        {427}let csi_11: cipherstate = (if v_153 then 1-proj-3-tuple(v_152) else caught-fail) in
        {428}let ss_21: symmetricstate = (if v_153 then symmetricstatepack(csi_11,ck_24,h_19) else caught-fail) in
        {429}let v_154: bitstring = (if v_153 then catch-fail(symmetricstateunpack(ss_21)) else caught-fail) in
        {430}let v_155: bool = (not-caught-fail(v_154) && success?(1-proj-3-tuple(v_154))) in
        {431}let h_20: bitstring = (if v_155 then 3-proj-3-tuple(v_154) else caught-fail) in
        {432}let ck_25: key = (if v_155 then 2-proj-3-tuple(v_154) else caught-fail) in
        {433}let cs_20: cipherstate = (if v_155 then 1-proj-3-tuple(v_154) else caught-fail) in
        {434}let ssi_5: symmetricstate = (if v_153 then catch-fail((if v_155 then symmetricstatepack(cs_20,ck_25,hash(h_20,ciphertext_5)) else fail-any)) else caught-fail) in
        {435}let v_156: bool = not-caught-fail(ssi_5) in
        {436}let v_157: bitstring = (if v_141 then catch-fail((if v_143 then (if v_153 then (if v_156 then (ssi_5,plaintext_7,valid_5) else fail-any) else fail-any) else fail-any)) else caught-fail) in
        {437}let v_158: bool = (not-caught-fail(v_157) && success?(1-proj-3-tuple(v_157))) in
        {438}let valid3: bool = (if v_158 then 3-proj-3-tuple(v_157) else caught-fail) in
        {439}let plaintext_8: bitstring = (if v_158 then 2-proj-3-tuple(v_157) else caught-fail) in
        {440}let ss_22: symmetricstate = (if v_158 then 1-proj-3-tuple(v_157) else caught-fail) in
        {444}let basis_4: key = (if v_158 then key_m(them) else caught-fail) in
        {445}let public_key_4: key = (if v_158 then catch-fail(dhexp(basis_4,validkey(g))) else caught-fail) in
        {446}let v_160: bool = not-caught-fail(public_key_4) in
        {441}let basis_3: key = (if v_158 then key_s(them) else caught-fail) in
        {442}let public_key_3: key = (if v_158 then catch-fail(dhexp(basis_3,validkey(g))) else caught-fail) in
        {443}let v_159: bool = not-caught-fail(public_key_3) in
        {447}let v_161: bool = (if v_158 then catch-fail(((valid1_1 && (valid2_1 && valid3)) && ((rs_3 = getpublickey((if v_159 then keypairpack(validkey(public_key_3),basis_3) else fail-any))) && (rm_3 = getpublickey((if v_160 then keypairpack(validkey(public_key_4),basis_4) else fail-any)))))) else caught-fail) in
        {449}let v_162: bitstring = (if v_161 then catch-fail(symmetricstateunpack(ss_22)) else caught-fail) in
        {450}let v_163: bool = (not-caught-fail(v_162) && success?(1-proj-3-tuple(v_162))) in
        {451}let h_21: bitstring = (if v_163 then 3-proj-3-tuple(v_162) else caught-fail) in
        {452}let ck_26: key = (if v_163 then 2-proj-3-tuple(v_162) else caught-fail) in
        {453}let cs_21: cipherstate = (if v_163 then 1-proj-3-tuple(v_162) else caught-fail) in
        {454}let input_key_material_5: key = (if v_163 then zero else caught-fail) in
        {457}let output3_5: key = (if v_163 then hmac_hash3(ck_26,input_key_material_5) else caught-fail) in
        {456}let output2_5: key = (if v_163 then hmac_hash2(ck_26,input_key_material_5) else caught-fail) in
        {455}let output1_5: key = (if v_163 then hmac_hash1(ck_26,input_key_material_5) else caught-fail) in
        {458}let v_164: bitstring = (if v_163 then catch-fail((output1_5,output2_5,output3_5)) else caught-fail) in
        {459}let v_165: bool = (not-caught-fail(v_164) && success?(1-proj-3-tuple(v_164))) in
        {460}let temp_k3: key = (if v_165 then 3-proj-3-tuple(v_164) else caught-fail) in
        {461}let temp_k2: key = (if v_165 then 2-proj-3-tuple(v_164) else caught-fail) in
        {462}let temp_k1: key = (if v_165 then 1-proj-3-tuple(v_164) else caught-fail) in
        {464}let cs2: cipherstate = (if v_165 then cipherstatepack(temp_k2,minnonce) else caught-fail) in
        {463}let cs1: cipherstate = (if v_165 then cipherstatepack(temp_k1,minnonce) else caught-fail) in
        {465}let v_166: bitstring = (if v_161 then catch-fail((if v_163 then (if v_165 then (ss_22,cs1,cs2) else fail-any) else fail-any)) else caught-fail) in
        {466}let v_167: bool = (not-caught-fail(v_166) && success?(1-proj-3-tuple(v_166))) in
        {467}let cs2_1: cipherstate = (if v_167 then 3-proj-3-tuple(v_166) else caught-fail) in
        {468}let cs1_1: cipherstate = (if v_167 then 2-proj-3-tuple(v_166) else caught-fail) in
        {469}let ssi_6: symmetricstate = (if v_167 then 1-proj-3-tuple(v_166) else caught-fail) in
        {448}let hs_5: handshakestate = (if v_161 then handshakestatepack(ss_22,s_3,m_3,e_6,rs_3,rm_3,re_3,psk_2,initiator_2) else caught-fail) in
        {470}let (hs_6: handshakestate,plaintext_b: bitstring,valid_6: bool,cs1_2: cipherstate,cs2_2: cipherstate) = (if v_62 then (if v_64 then (if v_67 then (if v_75 then (if v_83 then (if v_91 then (if v_108 then (if v_125 then (if v_133 then (if v_141 then (if v_158 then (if undo-catch-fail(v_161) then (if v_167 then (hs_5,plaintext_8,true,cs1_1,cs2_1) else fail-any) else fail-any) else fail-any) else fail-any) else fail-any) else fail-any) else fail-any) else fail-any) else fail-any) else fail-any) else fail-any) else fail-any) else fail-any) in
        {471}event RecvMsg(me,them,stagepack_b(sid_1),plaintext_b);
        {472}insert statestore(me,them,sid_1,statepack_c(hs_6,cs1_2,cs2_2))
    ) | (
        {474}!
        {533}get statestore(=me,=them,=sid_1,statepack_c(hs_7: handshakestate,cs1_3: cipherstate,cs2_3: cipherstate)) in
        {475}let hs_8: handshakestate = handshakestatesetcs(hs_7,cs1_3) in
        {477}let v_168: bitstring = catch-fail(handshakestateunpack(hs_8)) in
        {478}let v_169: bool = (not-caught-fail(v_168) && success?(1-proj-9-tuple(v_168))) in
        {479}let initiator_3: bool = (if v_169 then 9-proj-9-tuple(v_168) else caught-fail) in
        {480}let psk_3: key = (if v_169 then 8-proj-9-tuple(v_168) else caught-fail) in
        {481}let re_4: key = (if v_169 then 7-proj-9-tuple(v_168) else caught-fail) in
        {482}let rm_4: key = (if v_169 then 6-proj-9-tuple(v_168) else caught-fail) in
        {483}let rs_4: key = (if v_169 then 5-proj-9-tuple(v_168) else caught-fail) in
        {484}let e_7: keypair = (if v_169 then 4-proj-9-tuple(v_168) else caught-fail) in
        {485}let m_4: keypair = (if v_169 then 3-proj-9-tuple(v_168) else caught-fail) in
        {486}let s_4: keypair = (if v_169 then 2-proj-9-tuple(v_168) else caught-fail) in
        {487}let ss_23: symmetricstate = (if v_169 then 1-proj-9-tuple(v_168) else caught-fail) in
        {488}let v_170: bitstring = (if v_169 then catch-fail((empty,empty,empty,empty)) else caught-fail) in
        {489}let v_171: bool = (not-caught-fail(v_170) && success?(1-proj-4-tuple(v_170))) in
        {490}let ciphertext_6: bitstring = (if v_171 then 4-proj-4-tuple(v_170) else caught-fail) in
        {491}let nm_3: bitstring = (if v_171 then 3-proj-4-tuple(v_170) else caught-fail) in
        {492}let ns_3: bitstring = (if v_171 then 2-proj-4-tuple(v_170) else caught-fail) in
        {493}let ne_5: bitstring = (if v_171 then 1-proj-4-tuple(v_170) else caught-fail) in
        {494}let v_172: bitstring = (if v_171 then catch-fail(symmetricstateunpack(ss_23)) else caught-fail) in
        {495}let v_173: bool = (not-caught-fail(v_172) && success?(1-proj-3-tuple(v_172))) in
        {496}let h_22: bitstring = (if v_173 then 3-proj-3-tuple(v_172) else caught-fail) in
        {497}let ck_27: key = (if v_173 then 2-proj-3-tuple(v_172) else caught-fail) in
        {498}let cs_22: cipherstate = (if v_173 then 1-proj-3-tuple(v_172) else caught-fail) in
        {499}let v_174: bitstring = (if v_173 then catch-fail(cipherstateunpack(cs_22)) else caught-fail) in
        {500}let v_175: bool = (not-caught-fail(v_174) && success?(1-proj-2-tuple(v_174))) in
        {501}let n_12: nonce = (if v_175 then 2-proj-2-tuple(v_174) else caught-fail) in
        {502}let k_13: key = (if v_175 then 1-proj-2-tuple(v_174) else caught-fail) in
        {505}let v_176: bitstring = (if v_175 then catch-fail(cipherstateunpack(cs_22)) else caught-fail) in
        {506}let v_177: bool = (not-caught-fail(v_176) && success?(1-proj-2-tuple(v_176))) in
        {507}let o_6: nonce = (if v_177 then 2-proj-2-tuple(v_176) else caught-fail) in
        {508}let k_14: key = (if v_177 then 1-proj-2-tuple(v_176) else caught-fail) in
        {504}let n_13: nonce = (if v_175 then increment_nonce(n_12) else caught-fail) in
        {509}let csi_12: cipherstate = (if v_175 then catch-fail((if v_177 then cipherstatepack(k_14,n_13) else fail-any)) else caught-fail) in
        {510}let v_178: bool = not-caught-fail(csi_12) in
        {476}let payload_1: bitstring = msg_c(me,them,sid_1) in
        {503}let e_8: bitstring = (if v_175 then encrypt(k_13,n_12,h_22,payload_1) else caught-fail) in
        {511}let v_179: bitstring = (if v_173 then catch-fail((if v_175 then (if v_178 then (csi_12,e_8) else fail-any) else fail-any)) else caught-fail) in
        {512}let v_180: bool = (not-caught-fail(v_179) && success?(1-proj-2-tuple(v_179))) in
        {513}let ciphertext_7: bitstring = (if v_180 then 2-proj-2-tuple(v_179) else caught-fail) in
        {514}let csi_13: cipherstate = (if v_180 then 1-proj-2-tuple(v_179) else caught-fail) in
        {515}let ss_24: symmetricstate = (if v_180 then symmetricstatepack(csi_13,ck_27,h_22) else caught-fail) in
        {516}let v_181: bitstring = (if v_180 then catch-fail(symmetricstateunpack(ss_24)) else caught-fail) in
        {517}let v_182: bool = (not-caught-fail(v_181) && success?(1-proj-3-tuple(v_181))) in
        {518}let h_23: bitstring = (if v_182 then 3-proj-3-tuple(v_181) else caught-fail) in
        {519}let ck_28: key = (if v_182 then 2-proj-3-tuple(v_181) else caught-fail) in
        {520}let cs_23: cipherstate = (if v_182 then 1-proj-3-tuple(v_181) else caught-fail) in
        {521}let ssi_7: symmetricstate = (if v_180 then catch-fail((if v_182 then symmetricstatepack(cs_23,ck_28,hash(h_23,ciphertext_7)) else fail-any)) else caught-fail) in
        {522}let v_183: bool = not-caught-fail(ssi_7) in
        {523}let v_184: bitstring = (if v_171 then catch-fail((if v_173 then (if v_180 then (if v_183 then (ssi_7,ciphertext_7) else fail-any) else fail-any) else fail-any)) else caught-fail) in
        {524}let v_185: bool = (not-caught-fail(v_184) && success?(1-proj-2-tuple(v_184))) in
        {525}let ciphertext_8: bitstring = (if v_185 then 2-proj-2-tuple(v_184) else caught-fail) in
        {526}let ss_25: symmetricstate = (if v_185 then 1-proj-2-tuple(v_184) else caught-fail) in
        {528}let message_buffer_1: bitstring = (if v_185 then concat4(ne_5,ns_3,nm_3,ciphertext_8) else caught-fail) in
        {527}let hs_9: handshakestate = (if v_185 then handshakestatepack(ss_25,s_4,m_4,e_7,rs_4,rm_4,re_4,psk_3,initiator_3) else caught-fail) in
        {529}let (hs_10: handshakestate,message_c: bitstring) = (if v_169 then (if v_171 then (if v_185 then (hs_9,message_buffer_1) else fail-any) else fail-any) else fail-any) in
        {530}event SendMsg(me,them,stagepack_c(sid_1),msg_c(me,them,sid_1));
        {531}insert statestore(me,them,sid_1,statepack_d(hs_10,handshakestategetcs(hs_10),cs2_3));
        {532}out(pub, message_c)
    ) | (
        {534}!
        {601}get statestore(=me,=them,=sid_1,statepack_d(hs_11: handshakestate,cs1_4: cipherstate,cs2_4: cipherstate)) in
        {535}let hs_12: handshakestate = handshakestatesetcs(hs_11,cs2_4) in
        {536}in(pub, message_d: bitstring);
        {537}let v_186: bitstring = catch-fail(handshakestateunpack(hs_12)) in
        {538}let v_187: bool = (not-caught-fail(v_186) && success?(1-proj-9-tuple(v_186))) in
        {539}let initiator_4: bool = (if v_187 then 9-proj-9-tuple(v_186) else caught-fail) in
        {540}let psk_4: key = (if v_187 then 8-proj-9-tuple(v_186) else caught-fail) in
        {541}let re_5: key = (if v_187 then 7-proj-9-tuple(v_186) else caught-fail) in
        {542}let rm_5: key = (if v_187 then 6-proj-9-tuple(v_186) else caught-fail) in
        {543}let rs_5: key = (if v_187 then 5-proj-9-tuple(v_186) else caught-fail) in
        {544}let e_9: keypair = (if v_187 then 4-proj-9-tuple(v_186) else caught-fail) in
        {545}let m_5: keypair = (if v_187 then 3-proj-9-tuple(v_186) else caught-fail) in
        {546}let s_5: keypair = (if v_187 then 2-proj-9-tuple(v_186) else caught-fail) in
        {547}let ss_26: symmetricstate = (if v_187 then 1-proj-9-tuple(v_186) else caught-fail) in
        {548}let v_188: bitstring = (if v_187 then catch-fail(deconcat4(message_d)) else caught-fail) in
        {549}let v_189: bool = (not-caught-fail(v_188) && success?(1-proj-4-tuple(v_188))) in
        {550}let ciphertext_9: bitstring = (if v_189 then 4-proj-4-tuple(v_188) else caught-fail) in
        {551}let nm_4: bitstring = (if v_189 then 3-proj-4-tuple(v_188) else caught-fail) in
        {552}let ns_4: bitstring = (if v_189 then 2-proj-4-tuple(v_188) else caught-fail) in
        {553}let ne_6: bitstring = (if v_189 then 1-proj-4-tuple(v_188) else caught-fail) in
        {555}let v_190: bitstring = (if v_189 then catch-fail(symmetricstateunpack(ss_26)) else caught-fail) in
        {556}let v_191: bool = (not-caught-fail(v_190) && success?(1-proj-3-tuple(v_190))) in
        {557}let h_24: bitstring = (if v_191 then 3-proj-3-tuple(v_190) else caught-fail) in
        {558}let ck_29: key = (if v_191 then 2-proj-3-tuple(v_190) else caught-fail) in
        {559}let cs_24: cipherstate = (if v_191 then 1-proj-3-tuple(v_190) else caught-fail) in
        {560}let v_192: bitstring = (if v_191 then catch-fail(cipherstateunpack(cs_24)) else caught-fail) in
        {561}let v_193: bool = (not-caught-fail(v_192) && success?(1-proj-2-tuple(v_192))) in
        {562}let n_14: nonce = (if v_193 then 2-proj-2-tuple(v_192) else caught-fail) in
        {563}let k_15: key = (if v_193 then 1-proj-2-tuple(v_192) else caught-fail) in
        {564}let d_3: aead = (if v_193 then catch-fail(decrypt(k_15,n_14,h_24,ciphertext_9)) else caught-fail) in
        {565}let v_194: bool = not-caught-fail(d_3) in
        {566}let v_195: bitstring = (if v_194 then catch-fail(aeadunpack(d_3)) else caught-fail) in
        {567}let v_196: bool = (not-caught-fail(v_195) && success?(1-proj-3-tuple(v_195))) in
        {568}let plaintext_9: bitstring = (if v_196 then 3-proj-3-tuple(v_195) else caught-fail) in
        {569}let adi_3: bitstring = (if v_196 then 2-proj-3-tuple(v_195) else caught-fail) in
        {570}let valid_7: bool = (if v_196 then 1-proj-3-tuple(v_195) else caught-fail) in
        {572}let v_197: bitstring = (if v_196 then catch-fail(cipherstateunpack(cs_24)) else caught-fail) in
        {573}let v_198: bool = (not-caught-fail(v_197) && success?(1-proj-2-tuple(v_197))) in
        {574}let o_7: nonce = (if v_198 then 2-proj-2-tuple(v_197) else caught-fail) in
        {575}let k_16: key = (if v_198 then 1-proj-2-tuple(v_197) else caught-fail) in
        {571}let n_15: nonce = (if v_196 then increment_nonce(n_14) else caught-fail) in
        {576}let csi_14: cipherstate = (if v_196 then catch-fail((if v_198 then cipherstatepack(k_16,n_15) else fail-any)) else caught-fail) in
        {577}let v_199: bool = not-caught-fail(csi_14) in
        {578}let v_200: bitstring = (if v_191 then catch-fail((if v_193 then (if v_194 then (if v_196 then (if v_199 then (csi_14,plaintext_9,valid_7) else fail-any) else fail-any) else fail-any) else fail-any)) else caught-fail) in
        {579}let v_201: bool = (not-caught-fail(v_200) && success?(1-proj-3-tuple(v_200))) in
        {580}let valid_8: bool = (if v_201 then 3-proj-3-tuple(v_200) else caught-fail) in
        {581}let plaintext_10: bitstring = (if v_201 then 2-proj-3-tuple(v_200) else caught-fail) in
        {582}let csi_15: cipherstate = (if v_201 then 1-proj-3-tuple(v_200) else caught-fail) in
        {583}let ss_27: symmetricstate = (if v_201 then symmetricstatepack(csi_15,ck_29,h_24) else caught-fail) in
        {584}let v_202: bitstring = (if v_201 then catch-fail(symmetricstateunpack(ss_27)) else caught-fail) in
        {585}let v_203: bool = (not-caught-fail(v_202) && success?(1-proj-3-tuple(v_202))) in
        {586}let h_25: bitstring = (if v_203 then 3-proj-3-tuple(v_202) else caught-fail) in
        {587}let ck_30: key = (if v_203 then 2-proj-3-tuple(v_202) else caught-fail) in
        {588}let cs_25: cipherstate = (if v_203 then 1-proj-3-tuple(v_202) else caught-fail) in
        {589}let ssi_8: symmetricstate = (if v_201 then catch-fail((if v_203 then symmetricstatepack(cs_25,ck_30,hash(h_25,ciphertext_9)) else fail-any)) else caught-fail) in
        {590}let v_204: bool = not-caught-fail(ssi_8) in
        {591}let v_205: bitstring = (if v_189 then catch-fail((if v_191 then (if v_201 then (if v_204 then (ssi_8,plaintext_10,valid_8) else fail-any) else fail-any) else fail-any)) else caught-fail) in
        {592}let v_206: bool = (not-caught-fail(v_205) && success?(1-proj-3-tuple(v_205))) in
        {593}let valid2_2: bool = (if v_206 then 3-proj-3-tuple(v_205) else caught-fail) in
        {594}let plaintext_11: bitstring = (if v_206 then 2-proj-3-tuple(v_205) else caught-fail) in
        {595}let ss_28: symmetricstate = (if v_206 then 1-proj-3-tuple(v_205) else caught-fail) in
        {554}let valid1_2: bool = (if v_189 then true else caught-fail) in
        {596}let v_207: bool = (if v_206 then catch-fail((valid1_2 && valid2_2)) else caught-fail) in
        {597}let hs_13: handshakestate = (if v_207 then handshakestatepack(ss_28,s_5,m_5,e_9,rs_5,rm_5,re_5,psk_4,initiator_4) else caught-fail) in
        {598}let (hs_14: handshakestate,plaintext_d: bitstring,valid_9: bool) = (if v_187 then (if v_189 then (if v_206 then (if undo-catch-fail(v_207) then (hs_13,plaintext_11,true) else fail-any) else fail-any) else fail-any) else fail-any) in
        {599}event RecvMsg(me,them,stagepack_d(sid_1),plaintext_d);
        {600}event RecvEnd(valid_9)
    ) | (
        {602}event LeakS(phase0,me);
        {603}event LeakM(phase0,me);
        {604}out(pub, (key_s(me),key_m(me)))
    ) | (
        {605}phase 1;
        {606}event LeakS(phase1,me);
        {607}event LeakM(phase1,me);
        {608}out(pub, (key_s(me),key_m(me)))
    )
) | (
    {613}let m_6: keypair = keypairpack(empty,empty) in
    {612}let s_6: keypair = keypairpack(empty,empty) in
    {614}out(pub, (getpublickey(s_6),getpublickey(m_6)));
    {611}let sid_2: sessionid = sid in
    {610}let them_1: principal = charlie in
    {609}let me_1: principal = alice in
    (
        {624}let k_17: key = empty in
        {625}let cs_26: cipherstate = cipherstatepack(k_17,minnonce) in
        {621}let protocol_name_1: bitstring = somename in
        {622}let h_26: bitstring = hash(protocol_name_1,empty) in
        {623}let ck_31: key = h_26 in
        {626}let ss_29: symmetricstate = symmetricstatepack(cs_26,ck_31,h_26) in
        {627}let v_208: bitstring = catch-fail(symmetricstateunpack(ss_29)) in
        {628}let v_209: bool = (not-caught-fail(v_208) && success?(1-proj-3-tuple(v_208))) in
        {629}let h_27: bitstring = (if v_209 then 3-proj-3-tuple(v_208) else caught-fail) in
        {630}let ck_32: key = (if v_209 then 2-proj-3-tuple(v_208) else caught-fail) in
        {631}let cs_27: cipherstate = (if v_209 then 1-proj-3-tuple(v_208) else caught-fail) in
        {619}let prologue_1: bitstring = empty in
        {632}let ss_30: symmetricstate = catch-fail((if v_209 then symmetricstatepack(cs_27,ck_32,hash(h_27,prologue_1)) else fail-any)) in
        {633}let v_210: bool = not-caught-fail(ss_30) in
        {620}let psk_5: key = empty in
        {618}let re_6: key = empty in
        {617}let rm_6: key = empty in
        {616}let rs_6: key = empty in
        {615}let e_10: keypair = keypairpack(empty,empty) in
        {634}let hs_15: handshakestate = (if v_210 then handshakestatepack(ss_30,s_6,m_6,e_10,rs_6,rm_6,re_6,psk_5,true) else fail-any) in
        {635}insert statestore(me_1,them_1,sid_2,statepack_a(hs_15))
    ) | (
        {787}get statestore(=me_1,=them_1,=sid_2,statepack_a(hs_16: handshakestate)) in
        {637}let v_211: bitstring = catch-fail(handshakestateunpack(hs_16)) in
        {638}let v_212: bool = (not-caught-fail(v_211) && success?(1-proj-9-tuple(v_211))) in
        {639}let initiator_5: bool = (if v_212 then 9-proj-9-tuple(v_211) else caught-fail) in
        {640}let psk_6: key = (if v_212 then 8-proj-9-tuple(v_211) else caught-fail) in
        {641}let re_7: key = (if v_212 then 7-proj-9-tuple(v_211) else caught-fail) in
        {642}let rm_7: key = (if v_212 then 6-proj-9-tuple(v_211) else caught-fail) in
        {643}let rs_7: key = (if v_212 then 5-proj-9-tuple(v_211) else caught-fail) in
        {644}let e_11: keypair = (if v_212 then 4-proj-9-tuple(v_211) else caught-fail) in
        {645}let m_7: keypair = (if v_212 then 3-proj-9-tuple(v_211) else caught-fail) in
        {646}let s_7: keypair = (if v_212 then 2-proj-9-tuple(v_211) else caught-fail) in
        {647}let ss_31: symmetricstate = (if v_212 then 1-proj-9-tuple(v_211) else caught-fail) in
        {648}let v_213: bitstring = (if v_212 then catch-fail((empty,empty,empty,empty)) else caught-fail) in
        {649}let v_214: bool = (not-caught-fail(v_213) && success?(1-proj-4-tuple(v_213))) in
        {650}let ciphertext_10: bitstring = (if v_214 then 4-proj-4-tuple(v_213) else caught-fail) in
        {651}let nm_5: bitstring = (if v_214 then 3-proj-4-tuple(v_213) else caught-fail) in
        {652}let ns_5: bitstring = (if v_214 then 2-proj-4-tuple(v_213) else caught-fail) in
        {653}let ne_7: bitstring = (if v_214 then 1-proj-4-tuple(v_213) else caught-fail) in
        {654}let basis_5: key = (if v_214 then key_e(me_1,them_1,sid_2) else caught-fail) in
        {655}let public_key_5: key = (if v_214 then catch-fail(dhexp(basis_5,validkey(g))) else caught-fail) in
        {656}let v_215: bool = not-caught-fail(public_key_5) in
        {657}let e_12: keypair = (if v_214 then catch-fail((if v_215 then keypairpack(validkey(public_key_5),basis_5) else fail-any)) else caught-fail) in
        {658}let v_216: bool = not-caught-fail(e_12) in
        {659}let ne_8: bitstring = (if v_216 then catch-fail(getpublickey(e_12)) else caught-fail) in
        {660}let v_217: bool = not-caught-fail(ne_8) in
        {661}let v_218: bitstring = (if v_217 then catch-fail(symmetricstateunpack(ss_31)) else caught-fail) in
        {662}let v_219: bool = (not-caught-fail(v_218) && success?(1-proj-3-tuple(v_218))) in
        {663}let h_28: bitstring = (if v_219 then 3-proj-3-tuple(v_218) else caught-fail) in
        {664}let ck_33: key = (if v_219 then 2-proj-3-tuple(v_218) else caught-fail) in
        {665}let cs_28: cipherstate = (if v_219 then 1-proj-3-tuple(v_218) else caught-fail) in
        {666}let ss_32: symmetricstate = (if v_217 then catch-fail((if v_219 then symmetricstatepack(cs_28,ck_33,hash(h_28,ne_8)) else fail-any)) else caught-fail) in
        {667}let v_220: bool = not-caught-fail(ss_32) in
        {668}let basis_6: key = (if v_220 then key_s(me_1) else caught-fail) in
        {669}let public_key_6: key = (if v_220 then catch-fail(dhexp(basis_6,validkey(g))) else caught-fail) in
        {670}let v_221: bool = not-caught-fail(public_key_6) in
        {671}let s_8: keypair = (if v_220 then catch-fail((if v_221 then keypairpack(validkey(public_key_6),basis_6) else fail-any)) else caught-fail) in
        {672}let v_222: bool = not-caught-fail(s_8) in
        {673}let plaintext_12: bitstring = (if v_222 then catch-fail(getpublickey(s_8)) else caught-fail) in
        {674}let v_223: bool = not-caught-fail(plaintext_12) in
        {675}let v_224: bitstring = (if v_223 then catch-fail(symmetricstateunpack(ss_32)) else caught-fail) in
        {676}let v_225: bool = (not-caught-fail(v_224) && success?(1-proj-3-tuple(v_224))) in
        {677}let h_29: bitstring = (if v_225 then 3-proj-3-tuple(v_224) else caught-fail) in
        {678}let ck_34: key = (if v_225 then 2-proj-3-tuple(v_224) else caught-fail) in
        {679}let cs_29: cipherstate = (if v_225 then 1-proj-3-tuple(v_224) else caught-fail) in
        {680}let v_226: bitstring = (if v_225 then catch-fail(cipherstateunpack(cs_29)) else caught-fail) in
        {681}let v_227: bool = (not-caught-fail(v_226) && success?(1-proj-2-tuple(v_226))) in
        {682}let n_16: nonce = (if v_227 then 2-proj-2-tuple(v_226) else caught-fail) in
        {683}let k_18: key = (if v_227 then 1-proj-2-tuple(v_226) else caught-fail) in
        {686}let v_228: bitstring = (if v_227 then catch-fail(cipherstateunpack(cs_29)) else caught-fail) in
        {687}let v_229: bool = (not-caught-fail(v_228) && success?(1-proj-2-tuple(v_228))) in
        {688}let o_8: nonce = (if v_229 then 2-proj-2-tuple(v_228) else caught-fail) in
        {689}let k_19: key = (if v_229 then 1-proj-2-tuple(v_228) else caught-fail) in
        {685}let n_17: nonce = (if v_227 then increment_nonce(n_16) else caught-fail) in
        {690}let csi_16: cipherstate = (if v_227 then catch-fail((if v_229 then cipherstatepack(k_19,n_17) else fail-any)) else caught-fail) in
        {691}let v_230: bool = not-caught-fail(csi_16) in
        {684}let e_13: bitstring = (if v_227 then encrypt(k_18,n_16,h_29,plaintext_12) else caught-fail) in
        {692}let v_231: bitstring = (if v_225 then catch-fail((if v_227 then (if v_230 then (csi_16,e_13) else fail-any) else fail-any)) else caught-fail) in
        {693}let v_232: bool = (not-caught-fail(v_231) && success?(1-proj-2-tuple(v_231))) in
        {694}let ciphertext_11: bitstring = (if v_232 then 2-proj-2-tuple(v_231) else caught-fail) in
        {695}let csi_17: cipherstate = (if v_232 then 1-proj-2-tuple(v_231) else caught-fail) in
        {696}let ss_33: symmetricstate = (if v_232 then symmetricstatepack(csi_17,ck_34,h_29) else caught-fail) in
        {697}let v_233: bitstring = (if v_232 then catch-fail(symmetricstateunpack(ss_33)) else caught-fail) in
        {698}let v_234: bool = (not-caught-fail(v_233) && success?(1-proj-3-tuple(v_233))) in
        {699}let h_30: bitstring = (if v_234 then 3-proj-3-tuple(v_233) else caught-fail) in
        {700}let ck_35: key = (if v_234 then 2-proj-3-tuple(v_233) else caught-fail) in
        {701}let cs_30: cipherstate = (if v_234 then 1-proj-3-tuple(v_233) else caught-fail) in
        {702}let ssi_9: symmetricstate = (if v_232 then catch-fail((if v_234 then symmetricstatepack(cs_30,ck_35,hash(h_30,ciphertext_11)) else fail-any)) else caught-fail) in
        {703}let v_235: bool = not-caught-fail(ssi_9) in
        {704}let v_236: bitstring = (if v_222 then catch-fail((if v_223 then (if v_225 then (if v_232 then (if v_235 then (ssi_9,ciphertext_11) else fail-any) else fail-any) else fail-any) else fail-any)) else caught-fail) in
        {705}let v_237: bool = (not-caught-fail(v_236) && success?(1-proj-2-tuple(v_236))) in
        {706}let ns_6: bitstring = (if v_237 then 2-proj-2-tuple(v_236) else caught-fail) in
        {707}let ss_34: symmetricstate = (if v_237 then 1-proj-2-tuple(v_236) else caught-fail) in
        {708}let basis_7: key = (if v_237 then key_m(me_1) else caught-fail) in
        {709}let public_key_7: key = (if v_237 then catch-fail(dhexp(basis_7,validkey(g))) else caught-fail) in
        {710}let v_238: bool = not-caught-fail(public_key_7) in
        {711}let m_8: keypair = (if v_237 then catch-fail((if v_238 then keypairpack(validkey(public_key_7),basis_7) else fail-any)) else caught-fail) in
        {712}let v_239: bool = not-caught-fail(m_8) in
        {713}let plaintext_13: bitstring = (if v_239 then catch-fail(getpublickey(m_8)) else caught-fail) in
        {714}let v_240: bool = not-caught-fail(plaintext_13) in
        {715}let v_241: bitstring = (if v_240 then catch-fail(symmetricstateunpack(ss_34)) else caught-fail) in
        {716}let v_242: bool = (not-caught-fail(v_241) && success?(1-proj-3-tuple(v_241))) in
        {717}let h_31: bitstring = (if v_242 then 3-proj-3-tuple(v_241) else caught-fail) in
        {718}let ck_36: key = (if v_242 then 2-proj-3-tuple(v_241) else caught-fail) in
        {719}let cs_31: cipherstate = (if v_242 then 1-proj-3-tuple(v_241) else caught-fail) in
        {720}let v_243: bitstring = (if v_242 then catch-fail(cipherstateunpack(cs_31)) else caught-fail) in
        {721}let v_244: bool = (not-caught-fail(v_243) && success?(1-proj-2-tuple(v_243))) in
        {722}let n_18: nonce = (if v_244 then 2-proj-2-tuple(v_243) else caught-fail) in
        {723}let k_20: key = (if v_244 then 1-proj-2-tuple(v_243) else caught-fail) in
        {726}let v_245: bitstring = (if v_244 then catch-fail(cipherstateunpack(cs_31)) else caught-fail) in
        {727}let v_246: bool = (not-caught-fail(v_245) && success?(1-proj-2-tuple(v_245))) in
        {728}let o_9: nonce = (if v_246 then 2-proj-2-tuple(v_245) else caught-fail) in
        {729}let k_21: key = (if v_246 then 1-proj-2-tuple(v_245) else caught-fail) in
        {725}let n_19: nonce = (if v_244 then increment_nonce(n_18) else caught-fail) in
        {730}let csi_18: cipherstate = (if v_244 then catch-fail((if v_246 then cipherstatepack(k_21,n_19) else fail-any)) else caught-fail) in
        {731}let v_247: bool = not-caught-fail(csi_18) in
        {724}let e_14: bitstring = (if v_244 then encrypt(k_20,n_18,h_31,plaintext_13) else caught-fail) in
        {732}let v_248: bitstring = (if v_242 then catch-fail((if v_244 then (if v_247 then (csi_18,e_14) else fail-any) else fail-any)) else caught-fail) in
        {733}let v_249: bool = (not-caught-fail(v_248) && success?(1-proj-2-tuple(v_248))) in
        {734}let ciphertext_12: bitstring = (if v_249 then 2-proj-2-tuple(v_248) else caught-fail) in
        {735}let csi_19: cipherstate = (if v_249 then 1-proj-2-tuple(v_248) else caught-fail) in
        {736}let ss_35: symmetricstate = (if v_249 then symmetricstatepack(csi_19,ck_36,h_31) else caught-fail) in
        {737}let v_250: bitstring = (if v_249 then catch-fail(symmetricstateunpack(ss_35)) else caught-fail) in
        {738}let v_251: bool = (not-caught-fail(v_250) && success?(1-proj-3-tuple(v_250))) in
        {739}let h_32: bitstring = (if v_251 then 3-proj-3-tuple(v_250) else caught-fail) in
        {740}let ck_37: key = (if v_251 then 2-proj-3-tuple(v_250) else caught-fail) in
        {741}let cs_32: cipherstate = (if v_251 then 1-proj-3-tuple(v_250) else caught-fail) in
        {742}let ssi_10: symmetricstate = (if v_249 then catch-fail((if v_251 then symmetricstatepack(cs_32,ck_37,hash(h_32,ciphertext_12)) else fail-any)) else caught-fail) in
        {743}let v_252: bool = not-caught-fail(ssi_10) in
        {744}let v_253: bitstring = (if v_239 then catch-fail((if v_240 then (if v_242 then (if v_249 then (if v_252 then (ssi_10,ciphertext_12) else fail-any) else fail-any) else fail-any) else fail-any)) else caught-fail) in
        {745}let v_254: bool = (not-caught-fail(v_253) && success?(1-proj-2-tuple(v_253))) in
        {746}let nm_6: bitstring = (if v_254 then 2-proj-2-tuple(v_253) else caught-fail) in
        {747}let ss_36: symmetricstate = (if v_254 then 1-proj-2-tuple(v_253) else caught-fail) in
        {748}let v_255: bitstring = (if v_254 then catch-fail(symmetricstateunpack(ss_36)) else caught-fail) in
        {749}let v_256: bool = (not-caught-fail(v_255) && success?(1-proj-3-tuple(v_255))) in
        {750}let h_33: bitstring = (if v_256 then 3-proj-3-tuple(v_255) else caught-fail) in
        {751}let ck_38: key = (if v_256 then 2-proj-3-tuple(v_255) else caught-fail) in
        {752}let cs_33: cipherstate = (if v_256 then 1-proj-3-tuple(v_255) else caught-fail) in
        {753}let v_257: bitstring = (if v_256 then catch-fail(cipherstateunpack(cs_33)) else caught-fail) in
        {754}let v_258: bool = (not-caught-fail(v_257) && success?(1-proj-2-tuple(v_257))) in
        {755}let n_20: nonce = (if v_258 then 2-proj-2-tuple(v_257) else caught-fail) in
        {756}let k_22: key = (if v_258 then 1-proj-2-tuple(v_257) else caught-fail) in
        {759}let v_259: bitstring = (if v_258 then catch-fail(cipherstateunpack(cs_33)) else caught-fail) in
        {760}let v_260: bool = (not-caught-fail(v_259) && success?(1-proj-2-tuple(v_259))) in
        {761}let o_10: nonce = (if v_260 then 2-proj-2-tuple(v_259) else caught-fail) in
        {762}let k_23: key = (if v_260 then 1-proj-2-tuple(v_259) else caught-fail) in
        {758}let n_21: nonce = (if v_258 then increment_nonce(n_20) else caught-fail) in
        {763}let csi_20: cipherstate = (if v_258 then catch-fail((if v_260 then cipherstatepack(k_23,n_21) else fail-any)) else caught-fail) in
        {764}let v_261: bool = not-caught-fail(csi_20) in
        {636}let payload_2: bitstring = msg_a(me_1,them_1,sid_2) in
        {757}let e_15: bitstring = (if v_258 then encrypt(k_22,n_20,h_33,payload_2) else caught-fail) in
        {765}let v_262: bitstring = (if v_256 then catch-fail((if v_258 then (if v_261 then (csi_20,e_15) else fail-any) else fail-any)) else caught-fail) in
        {766}let v_263: bool = (not-caught-fail(v_262) && success?(1-proj-2-tuple(v_262))) in
        {767}let ciphertext_13: bitstring = (if v_263 then 2-proj-2-tuple(v_262) else caught-fail) in
        {768}let csi_21: cipherstate = (if v_263 then 1-proj-2-tuple(v_262) else caught-fail) in
        {769}let ss_37: symmetricstate = (if v_263 then symmetricstatepack(csi_21,ck_38,h_33) else caught-fail) in
        {770}let v_264: bitstring = (if v_263 then catch-fail(symmetricstateunpack(ss_37)) else caught-fail) in
        {771}let v_265: bool = (not-caught-fail(v_264) && success?(1-proj-3-tuple(v_264))) in
        {772}let h_34: bitstring = (if v_265 then 3-proj-3-tuple(v_264) else caught-fail) in
        {773}let ck_39: key = (if v_265 then 2-proj-3-tuple(v_264) else caught-fail) in
        {774}let cs_34: cipherstate = (if v_265 then 1-proj-3-tuple(v_264) else caught-fail) in
        {775}let ssi_11: symmetricstate = (if v_263 then catch-fail((if v_265 then symmetricstatepack(cs_34,ck_39,hash(h_34,ciphertext_13)) else fail-any)) else caught-fail) in
        {776}let v_266: bool = not-caught-fail(ssi_11) in
        {777}let v_267: bitstring = (if v_254 then catch-fail((if v_256 then (if v_263 then (if v_266 then (ssi_11,ciphertext_13) else fail-any) else fail-any) else fail-any)) else caught-fail) in
        {778}let v_268: bool = (not-caught-fail(v_267) && success?(1-proj-2-tuple(v_267))) in
        {779}let ciphertext_14: bitstring = (if v_268 then 2-proj-2-tuple(v_267) else caught-fail) in
        {780}let ss_38: symmetricstate = (if v_268 then 1-proj-2-tuple(v_267) else caught-fail) in
        {782}let message_buffer_2: bitstring = (if v_268 then concat4(ne_8,ns_6,nm_6,ciphertext_14) else caught-fail) in
        {781}let hs_17: handshakestate = (if v_268 then handshakestatepack(ss_38,s_8,m_8,e_12,rs_7,rm_7,re_7,psk_6,initiator_5) else caught-fail) in
        {783}let (hs_18: handshakestate,message_a_1: bitstring) = (if v_212 then (if v_214 then (if v_216 then (if v_217 then (if v_220 then (if v_222 then (if v_237 then (if v_239 then (if v_254 then (if v_268 then (hs_17,message_buffer_2) else fail-any) else fail-any) else fail-any) else fail-any) else fail-any) else fail-any) else fail-any) else fail-any) else fail-any) else fail-any) in
        {784}event SendMsg(me_1,them_1,stagepack_a(sid_2),msg_a(me_1,them_1,sid_2));
        {785}insert statestore(me_1,them_1,sid_2,statepack_b(hs_18));
        {786}out(pub, message_a_1)
    ) | (
        {1078}get statestore(=me_1,=them_1,=sid_2,statepack_b(hs_19: handshakestate)) in
        {788}in(pub, message_b_1: bitstring);
        {789}let v_269: bitstring = catch-fail(handshakestateunpack(hs_19)) in
        {790}let v_270: bool = (not-caught-fail(v_269) && success?(1-proj-9-tuple(v_269))) in
        {791}let initiator_6: bool = (if v_270 then 9-proj-9-tuple(v_269) else caught-fail) in
        {792}let psk_7: key = (if v_270 then 8-proj-9-tuple(v_269) else caught-fail) in
        {793}let re_8: key = (if v_270 then 7-proj-9-tuple(v_269) else caught-fail) in
        {794}let rm_8: key = (if v_270 then 6-proj-9-tuple(v_269) else caught-fail) in
        {795}let rs_8: key = (if v_270 then 5-proj-9-tuple(v_269) else caught-fail) in
        {796}let e_16: keypair = (if v_270 then 4-proj-9-tuple(v_269) else caught-fail) in
        {797}let m_9: keypair = (if v_270 then 3-proj-9-tuple(v_269) else caught-fail) in
        {798}let s_9: keypair = (if v_270 then 2-proj-9-tuple(v_269) else caught-fail) in
        {799}let ss_39: symmetricstate = (if v_270 then 1-proj-9-tuple(v_269) else caught-fail) in
        {800}let v_271: bitstring = (if v_270 then catch-fail(deconcat4(message_b_1)) else caught-fail) in
        {801}let v_272: bool = (not-caught-fail(v_271) && success?(1-proj-4-tuple(v_271))) in
        {802}let ciphertext_15: bitstring = (if v_272 then 4-proj-4-tuple(v_271) else caught-fail) in
        {803}let nm_7: bitstring = (if v_272 then 3-proj-4-tuple(v_271) else caught-fail) in
        {804}let ns_7: bitstring = (if v_272 then 2-proj-4-tuple(v_271) else caught-fail) in
        {805}let ne_9: bitstring = (if v_272 then 1-proj-4-tuple(v_271) else caught-fail) in
        {809}let v_273: bitstring = (if v_272 then catch-fail(symmetricstateunpack(ss_39)) else caught-fail) in
        {810}let v_274: bool = (not-caught-fail(v_273) && success?(1-proj-3-tuple(v_273))) in
        {811}let h_35: bitstring = (if v_274 then 3-proj-3-tuple(v_273) else caught-fail) in
        {812}let ck_40: key = (if v_274 then 2-proj-3-tuple(v_273) else caught-fail) in
        {813}let cs_35: cipherstate = (if v_274 then 1-proj-3-tuple(v_273) else caught-fail) in
        {808}let re_9: key = (if v_272 then ne_9 else caught-fail) in
        {814}let ss_40: symmetricstate = (if v_272 then catch-fail((if v_274 then symmetricstatepack(cs_35,ck_40,hash(h_35,re_9)) else fail-any)) else caught-fail) in
        {815}let v_275: bool = not-caught-fail(ss_40) in
        {816}let v_276: bitstring = (if v_275 then catch-fail(keypairunpack(e_16)) else caught-fail) in
        {817}let v_277: bool = (not-caught-fail(v_276) && success?(1-proj-2-tuple(v_276))) in
        {818}let my_private_key_5: key = (if v_277 then 2-proj-2-tuple(v_276) else caught-fail) in
        {819}let my_public_key_5: key = (if v_277 then 1-proj-2-tuple(v_276) else caught-fail) in
        {820}let input_key_material_6: key = (if v_275 then catch-fail((if v_277 then dhexp(my_private_key_5,re_9) else fail-any)) else caught-fail) in
        {821}let v_278: bool = not-caught-fail(input_key_material_6) in
        {822}let v_279: bitstring = (if v_278 then catch-fail(symmetricstateunpack(ss_40)) else caught-fail) in
        {823}let v_280: bool = (not-caught-fail(v_279) && success?(1-proj-3-tuple(v_279))) in
        {824}let h_36: bitstring = (if v_280 then 3-proj-3-tuple(v_279) else caught-fail) in
        {825}let ck_41: key = (if v_280 then 2-proj-3-tuple(v_279) else caught-fail) in
        {826}let cs_36: cipherstate = (if v_280 then 1-proj-3-tuple(v_279) else caught-fail) in
        {829}let output3_6: key = (if v_280 then hmac_hash3(ck_41,input_key_material_6) else caught-fail) in
        {828}let output2_6: key = (if v_280 then hmac_hash2(ck_41,input_key_material_6) else caught-fail) in
        {827}let output1_6: key = (if v_280 then hmac_hash1(ck_41,input_key_material_6) else caught-fail) in
        {830}let v_281: bitstring = (if v_280 then catch-fail((output1_6,output2_6,output3_6)) else caught-fail) in
        {831}let v_282: bool = (not-caught-fail(v_281) && success?(1-proj-3-tuple(v_281))) in
        {832}let output_5: key = (if v_282 then 3-proj-3-tuple(v_281) else caught-fail) in
        {833}let temp_k_5: key = (if v_282 then 2-proj-3-tuple(v_281) else caught-fail) in
        {834}let ck_42: key = (if v_282 then 1-proj-3-tuple(v_281) else caught-fail) in
        {835}let ss_41: symmetricstate = (if v_275 then catch-fail((if v_278 then (if v_280 then (if v_282 then symmetricstatepack(cipherstatepack(temp_k_5,minnonce),ck_42,h_36) else fail-any) else fail-any) else fail-any)) else caught-fail) in
        {836}let v_283: bool = not-caught-fail(ss_41) in
        {837}let v_284: bitstring = (if v_283 then catch-fail(keypairunpack(s_9)) else caught-fail) in
        {838}let v_285: bool = (not-caught-fail(v_284) && success?(1-proj-2-tuple(v_284))) in
        {839}let my_private_key_6: key = (if v_285 then 2-proj-2-tuple(v_284) else caught-fail) in
        {840}let my_public_key_6: key = (if v_285 then 1-proj-2-tuple(v_284) else caught-fail) in
        {841}let input_key_material_7: key = (if v_283 then catch-fail((if v_285 then dhexp(my_private_key_6,re_9) else fail-any)) else caught-fail) in
        {842}let v_286: bool = not-caught-fail(input_key_material_7) in
        {843}let v_287: bitstring = (if v_286 then catch-fail(symmetricstateunpack(ss_41)) else caught-fail) in
        {844}let v_288: bool = (not-caught-fail(v_287) && success?(1-proj-3-tuple(v_287))) in
        {845}let h_37: bitstring = (if v_288 then 3-proj-3-tuple(v_287) else caught-fail) in
        {846}let ck_43: key = (if v_288 then 2-proj-3-tuple(v_287) else caught-fail) in
        {847}let cs_37: cipherstate = (if v_288 then 1-proj-3-tuple(v_287) else caught-fail) in
        {850}let output3_7: key = (if v_288 then hmac_hash3(ck_43,input_key_material_7) else caught-fail) in
        {849}let output2_7: key = (if v_288 then hmac_hash2(ck_43,input_key_material_7) else caught-fail) in
        {848}let output1_7: key = (if v_288 then hmac_hash1(ck_43,input_key_material_7) else caught-fail) in
        {851}let v_289: bitstring = (if v_288 then catch-fail((output1_7,output2_7,output3_7)) else caught-fail) in
        {852}let v_290: bool = (not-caught-fail(v_289) && success?(1-proj-3-tuple(v_289))) in
        {853}let output_6: key = (if v_290 then 3-proj-3-tuple(v_289) else caught-fail) in
        {854}let temp_k_6: key = (if v_290 then 2-proj-3-tuple(v_289) else caught-fail) in
        {855}let ck_44: key = (if v_290 then 1-proj-3-tuple(v_289) else caught-fail) in
        {856}let ss_42: symmetricstate = (if v_283 then catch-fail((if v_286 then (if v_288 then (if v_290 then symmetricstatepack(cipherstatepack(temp_k_6,minnonce),ck_44,h_37) else fail-any) else fail-any) else fail-any)) else caught-fail) in
        {857}let v_291: bool = not-caught-fail(ss_42) in
        {858}let v_292: bitstring = (if v_291 then catch-fail(keypairunpack(m_9)) else caught-fail) in
        {859}let v_293: bool = (not-caught-fail(v_292) && success?(1-proj-2-tuple(v_292))) in
        {860}let my_private_key_7: key = (if v_293 then 2-proj-2-tuple(v_292) else caught-fail) in
        {861}let my_public_key_7: key = (if v_293 then 1-proj-2-tuple(v_292) else caught-fail) in
        {862}let input_key_material_8: key = (if v_291 then catch-fail((if v_293 then dhexp(my_private_key_7,re_9) else fail-any)) else caught-fail) in
        {863}let v_294: bool = not-caught-fail(input_key_material_8) in
        {864}let v_295: bitstring = (if v_294 then catch-fail(symmetricstateunpack(ss_42)) else caught-fail) in
        {865}let v_296: bool = (not-caught-fail(v_295) && success?(1-proj-3-tuple(v_295))) in
        {866}let h_38: bitstring = (if v_296 then 3-proj-3-tuple(v_295) else caught-fail) in
        {867}let ck_45: key = (if v_296 then 2-proj-3-tuple(v_295) else caught-fail) in
        {868}let cs_38: cipherstate = (if v_296 then 1-proj-3-tuple(v_295) else caught-fail) in
        {871}let output3_8: key = (if v_296 then hmac_hash3(ck_45,input_key_material_8) else caught-fail) in
        {870}let output2_8: key = (if v_296 then hmac_hash2(ck_45,input_key_material_8) else caught-fail) in
        {869}let output1_8: key = (if v_296 then hmac_hash1(ck_45,input_key_material_8) else caught-fail) in
        {872}let v_297: bitstring = (if v_296 then catch-fail((output1_8,output2_8,output3_8)) else caught-fail) in
        {873}let v_298: bool = (not-caught-fail(v_297) && success?(1-proj-3-tuple(v_297))) in
        {874}let output_7: key = (if v_298 then 3-proj-3-tuple(v_297) else caught-fail) in
        {875}let temp_k_7: key = (if v_298 then 2-proj-3-tuple(v_297) else caught-fail) in
        {876}let ck_46: key = (if v_298 then 1-proj-3-tuple(v_297) else caught-fail) in
        {877}let ss_43: symmetricstate = (if v_291 then catch-fail((if v_294 then (if v_296 then (if v_298 then symmetricstatepack(cipherstatepack(temp_k_7,minnonce),ck_46,h_38) else fail-any) else fail-any) else fail-any)) else caught-fail) in
        {878}let v_299: bool = not-caught-fail(ss_43) in
        {879}let v_300: bitstring = (if v_299 then catch-fail(symmetricstateunpack(ss_43)) else caught-fail) in
        {880}let v_301: bool = (not-caught-fail(v_300) && success?(1-proj-3-tuple(v_300))) in
        {881}let h_39: bitstring = (if v_301 then 3-proj-3-tuple(v_300) else caught-fail) in
        {882}let ck_47: key = (if v_301 then 2-proj-3-tuple(v_300) else caught-fail) in
        {883}let cs_39: cipherstate = (if v_301 then 1-proj-3-tuple(v_300) else caught-fail) in
        {884}let v_302: bitstring = (if v_301 then catch-fail(cipherstateunpack(cs_39)) else caught-fail) in
        {885}let v_303: bool = (not-caught-fail(v_302) && success?(1-proj-2-tuple(v_302))) in
        {886}let n_22: nonce = (if v_303 then 2-proj-2-tuple(v_302) else caught-fail) in
        {887}let k_24: key = (if v_303 then 1-proj-2-tuple(v_302) else caught-fail) in
        {888}let d_4: aead = (if v_303 then catch-fail(decrypt(k_24,n_22,h_39,ns_7)) else caught-fail) in
        {889}let v_304: bool = not-caught-fail(d_4) in
        {890}let v_305: bitstring = (if v_304 then catch-fail(aeadunpack(d_4)) else caught-fail) in
        {891}let v_306: bool = (not-caught-fail(v_305) && success?(1-proj-3-tuple(v_305))) in
        {892}let plaintext_14: bitstring = (if v_306 then 3-proj-3-tuple(v_305) else caught-fail) in
        {893}let adi_4: bitstring = (if v_306 then 2-proj-3-tuple(v_305) else caught-fail) in
        {894}let valid_10: bool = (if v_306 then 1-proj-3-tuple(v_305) else caught-fail) in
        {896}let v_307: bitstring = (if v_306 then catch-fail(cipherstateunpack(cs_39)) else caught-fail) in
        {897}let v_308: bool = (not-caught-fail(v_307) && success?(1-proj-2-tuple(v_307))) in
        {898}let o_11: nonce = (if v_308 then 2-proj-2-tuple(v_307) else caught-fail) in
        {899}let k_25: key = (if v_308 then 1-proj-2-tuple(v_307) else caught-fail) in
        {895}let n_23: nonce = (if v_306 then increment_nonce(n_22) else caught-fail) in
        {900}let csi_22: cipherstate = (if v_306 then catch-fail((if v_308 then cipherstatepack(k_25,n_23) else fail-any)) else caught-fail) in
        {901}let v_309: bool = not-caught-fail(csi_22) in
        {902}let v_310: bitstring = (if v_301 then catch-fail((if v_303 then (if v_304 then (if v_306 then (if v_309 then (csi_22,plaintext_14,valid_10) else fail-any) else fail-any) else fail-any) else fail-any)) else caught-fail) in
        {903}let v_311: bool = (not-caught-fail(v_310) && success?(1-proj-3-tuple(v_310))) in
        {904}let valid_11: bool = (if v_311 then 3-proj-3-tuple(v_310) else caught-fail) in
        {905}let plaintext_15: bitstring = (if v_311 then 2-proj-3-tuple(v_310) else caught-fail) in
        {906}let csi_23: cipherstate = (if v_311 then 1-proj-3-tuple(v_310) else caught-fail) in
        {907}let ss_44: symmetricstate = (if v_311 then symmetricstatepack(csi_23,ck_47,h_39) else caught-fail) in
        {908}let v_312: bitstring = (if v_311 then catch-fail(symmetricstateunpack(ss_44)) else caught-fail) in
        {909}let v_313: bool = (not-caught-fail(v_312) && success?(1-proj-3-tuple(v_312))) in
        {910}let h_40: bitstring = (if v_313 then 3-proj-3-tuple(v_312) else caught-fail) in
        {911}let ck_48: key = (if v_313 then 2-proj-3-tuple(v_312) else caught-fail) in
        {912}let cs_40: cipherstate = (if v_313 then 1-proj-3-tuple(v_312) else caught-fail) in
        {913}let ssi_12: symmetricstate = (if v_311 then catch-fail((if v_313 then symmetricstatepack(cs_40,ck_48,hash(h_40,ns_7)) else fail-any)) else caught-fail) in
        {914}let v_314: bool = not-caught-fail(ssi_12) in
        {915}let v_315: bitstring = (if v_299 then catch-fail((if v_301 then (if v_311 then (if v_314 then (ssi_12,plaintext_15,valid_11) else fail-any) else fail-any) else fail-any)) else caught-fail) in
        {916}let v_316: bool = (not-caught-fail(v_315) && success?(1-proj-3-tuple(v_315))) in
        {917}let valid1_4: bool = (if v_316 then 3-proj-3-tuple(v_315) else caught-fail) in
        {918}let ne_10: bitstring = (if v_316 then 2-proj-3-tuple(v_315) else caught-fail) in
        {919}let ss_45: symmetricstate = (if v_316 then 1-proj-3-tuple(v_315) else caught-fail) in
        {921}let v_317: bitstring = (if v_316 then catch-fail(symmetricstateunpack(ss_45)) else caught-fail) in
        {922}let v_318: bool = (not-caught-fail(v_317) && success?(1-proj-3-tuple(v_317))) in
        {923}let h_41: bitstring = (if v_318 then 3-proj-3-tuple(v_317) else caught-fail) in
        {924}let ck_49: key = (if v_318 then 2-proj-3-tuple(v_317) else caught-fail) in
        {925}let cs_41: cipherstate = (if v_318 then 1-proj-3-tuple(v_317) else caught-fail) in
        {926}let v_319: bitstring = (if v_318 then catch-fail(cipherstateunpack(cs_41)) else caught-fail) in
        {927}let v_320: bool = (not-caught-fail(v_319) && success?(1-proj-2-tuple(v_319))) in
        {928}let n_24: nonce = (if v_320 then 2-proj-2-tuple(v_319) else caught-fail) in
        {929}let k_26: key = (if v_320 then 1-proj-2-tuple(v_319) else caught-fail) in
        {930}let d_5: aead = (if v_320 then catch-fail(decrypt(k_26,n_24,h_41,nm_7)) else caught-fail) in
        {931}let v_321: bool = not-caught-fail(d_5) in
        {932}let v_322: bitstring = (if v_321 then catch-fail(aeadunpack(d_5)) else caught-fail) in
        {933}let v_323: bool = (not-caught-fail(v_322) && success?(1-proj-3-tuple(v_322))) in
        {934}let plaintext_16: bitstring = (if v_323 then 3-proj-3-tuple(v_322) else caught-fail) in
        {935}let adi_5: bitstring = (if v_323 then 2-proj-3-tuple(v_322) else caught-fail) in
        {936}let valid_12: bool = (if v_323 then 1-proj-3-tuple(v_322) else caught-fail) in
        {938}let v_324: bitstring = (if v_323 then catch-fail(cipherstateunpack(cs_41)) else caught-fail) in
        {939}let v_325: bool = (not-caught-fail(v_324) && success?(1-proj-2-tuple(v_324))) in
        {940}let o_12: nonce = (if v_325 then 2-proj-2-tuple(v_324) else caught-fail) in
        {941}let k_27: key = (if v_325 then 1-proj-2-tuple(v_324) else caught-fail) in
        {937}let n_25: nonce = (if v_323 then increment_nonce(n_24) else caught-fail) in
        {942}let csi_24: cipherstate = (if v_323 then catch-fail((if v_325 then cipherstatepack(k_27,n_25) else fail-any)) else caught-fail) in
        {943}let v_326: bool = not-caught-fail(csi_24) in
        {944}let v_327: bitstring = (if v_318 then catch-fail((if v_320 then (if v_321 then (if v_323 then (if v_326 then (csi_24,plaintext_16,valid_12) else fail-any) else fail-any) else fail-any) else fail-any)) else caught-fail) in
        {945}let v_328: bool = (not-caught-fail(v_327) && success?(1-proj-3-tuple(v_327))) in
        {946}let valid_13: bool = (if v_328 then 3-proj-3-tuple(v_327) else caught-fail) in
        {947}let plaintext_17: bitstring = (if v_328 then 2-proj-3-tuple(v_327) else caught-fail) in
        {948}let csi_25: cipherstate = (if v_328 then 1-proj-3-tuple(v_327) else caught-fail) in
        {949}let ss_46: symmetricstate = (if v_328 then symmetricstatepack(csi_25,ck_49,h_41) else caught-fail) in
        {950}let v_329: bitstring = (if v_328 then catch-fail(symmetricstateunpack(ss_46)) else caught-fail) in
        {951}let v_330: bool = (not-caught-fail(v_329) && success?(1-proj-3-tuple(v_329))) in
        {952}let h_42: bitstring = (if v_330 then 3-proj-3-tuple(v_329) else caught-fail) in
        {953}let ck_50: key = (if v_330 then 2-proj-3-tuple(v_329) else caught-fail) in
        {954}let cs_42: cipherstate = (if v_330 then 1-proj-3-tuple(v_329) else caught-fail) in
        {955}let ssi_13: symmetricstate = (if v_328 then catch-fail((if v_330 then symmetricstatepack(cs_42,ck_50,hash(h_42,nm_7)) else fail-any)) else caught-fail) in
        {956}let v_331: bool = not-caught-fail(ssi_13) in
        {957}let v_332: bitstring = (if v_316 then catch-fail((if v_318 then (if v_328 then (if v_331 then (ssi_13,plaintext_17,valid_13) else fail-any) else fail-any) else fail-any)) else caught-fail) in
        {958}let v_333: bool = (not-caught-fail(v_332) && success?(1-proj-3-tuple(v_332))) in
        {959}let valid2_4: bool = (if v_333 then 3-proj-3-tuple(v_332) else caught-fail) in
        {960}let ne_11: bitstring = (if v_333 then 2-proj-3-tuple(v_332) else caught-fail) in
        {961}let ss_47: symmetricstate = (if v_333 then 1-proj-3-tuple(v_332) else caught-fail) in
        {963}let v_334: bitstring = (if v_333 then catch-fail(keypairunpack(e_16)) else caught-fail) in
        {964}let v_335: bool = (not-caught-fail(v_334) && success?(1-proj-2-tuple(v_334))) in
        {965}let my_private_key_8: key = (if v_335 then 2-proj-2-tuple(v_334) else caught-fail) in
        {966}let my_public_key_8: key = (if v_335 then 1-proj-2-tuple(v_334) else caught-fail) in
        {920}let rs_9: key = (if v_316 then ne_10 else caught-fail) in
        {967}let input_key_material_9: key = (if v_333 then catch-fail((if v_335 then dhexp(my_private_key_8,rs_9) else fail-any)) else caught-fail) in
        {968}let v_336: bool = not-caught-fail(input_key_material_9) in
        {969}let v_337: bitstring = (if v_336 then catch-fail(symmetricstateunpack(ss_47)) else caught-fail) in
        {970}let v_338: bool = (not-caught-fail(v_337) && success?(1-proj-3-tuple(v_337))) in
        {971}let h_43: bitstring = (if v_338 then 3-proj-3-tuple(v_337) else caught-fail) in
        {972}let ck_51: key = (if v_338 then 2-proj-3-tuple(v_337) else caught-fail) in
        {973}let cs_43: cipherstate = (if v_338 then 1-proj-3-tuple(v_337) else caught-fail) in
        {976}let output3_9: key = (if v_338 then hmac_hash3(ck_51,input_key_material_9) else caught-fail) in
        {975}let output2_9: key = (if v_338 then hmac_hash2(ck_51,input_key_material_9) else caught-fail) in
        {974}let output1_9: key = (if v_338 then hmac_hash1(ck_51,input_key_material_9) else caught-fail) in
        {977}let v_339: bitstring = (if v_338 then catch-fail((output1_9,output2_9,output3_9)) else caught-fail) in
        {978}let v_340: bool = (not-caught-fail(v_339) && success?(1-proj-3-tuple(v_339))) in
        {979}let output_8: key = (if v_340 then 3-proj-3-tuple(v_339) else caught-fail) in
        {980}let temp_k_8: key = (if v_340 then 2-proj-3-tuple(v_339) else caught-fail) in
        {981}let ck_52: key = (if v_340 then 1-proj-3-tuple(v_339) else caught-fail) in
        {982}let ss_48: symmetricstate = (if v_333 then catch-fail((if v_336 then (if v_338 then (if v_340 then symmetricstatepack(cipherstatepack(temp_k_8,minnonce),ck_52,h_43) else fail-any) else fail-any) else fail-any)) else caught-fail) in
        {983}let v_341: bool = not-caught-fail(ss_48) in
        {984}let v_342: bitstring = (if v_341 then catch-fail(keypairunpack(e_16)) else caught-fail) in
        {985}let v_343: bool = (not-caught-fail(v_342) && success?(1-proj-2-tuple(v_342))) in
        {986}let my_private_key_9: key = (if v_343 then 2-proj-2-tuple(v_342) else caught-fail) in
        {987}let my_public_key_9: key = (if v_343 then 1-proj-2-tuple(v_342) else caught-fail) in
        {962}let rm_9: key = (if v_333 then ne_11 else caught-fail) in
        {988}let input_key_material_10: key = (if v_341 then catch-fail((if v_343 then dhexp(my_private_key_9,rm_9) else fail-any)) else caught-fail) in
        {989}let v_344: bool = not-caught-fail(input_key_material_10) in
        {990}let v_345: bitstring = (if v_344 then catch-fail(symmetricstateunpack(ss_48)) else caught-fail) in
        {991}let v_346: bool = (not-caught-fail(v_345) && success?(1-proj-3-tuple(v_345))) in
        {992}let h_44: bitstring = (if v_346 then 3-proj-3-tuple(v_345) else caught-fail) in
        {993}let ck_53: key = (if v_346 then 2-proj-3-tuple(v_345) else caught-fail) in
        {994}let cs_44: cipherstate = (if v_346 then 1-proj-3-tuple(v_345) else caught-fail) in
        {997}let output3_10: key = (if v_346 then hmac_hash3(ck_53,input_key_material_10) else caught-fail) in
        {996}let output2_10: key = (if v_346 then hmac_hash2(ck_53,input_key_material_10) else caught-fail) in
        {995}let output1_10: key = (if v_346 then hmac_hash1(ck_53,input_key_material_10) else caught-fail) in
        {998}let v_347: bitstring = (if v_346 then catch-fail((output1_10,output2_10,output3_10)) else caught-fail) in
        {999}let v_348: bool = (not-caught-fail(v_347) && success?(1-proj-3-tuple(v_347))) in
        {1000}let output_9: key = (if v_348 then 3-proj-3-tuple(v_347) else caught-fail) in
        {1001}let temp_k_9: key = (if v_348 then 2-proj-3-tuple(v_347) else caught-fail) in
        {1002}let ck_54: key = (if v_348 then 1-proj-3-tuple(v_347) else caught-fail) in
        {1003}let ss_49: symmetricstate = (if v_341 then catch-fail((if v_344 then (if v_346 then (if v_348 then symmetricstatepack(cipherstatepack(temp_k_9,minnonce),ck_54,h_44) else fail-any) else fail-any) else fail-any)) else caught-fail) in
        {1004}let v_349: bool = not-caught-fail(ss_49) in
        {1005}let v_350: bitstring = (if v_349 then catch-fail(symmetricstateunpack(ss_49)) else caught-fail) in
        {1006}let v_351: bool = (not-caught-fail(v_350) && success?(1-proj-3-tuple(v_350))) in
        {1007}let h_45: bitstring = (if v_351 then 3-proj-3-tuple(v_350) else caught-fail) in
        {1008}let ck_55: key = (if v_351 then 2-proj-3-tuple(v_350) else caught-fail) in
        {1009}let cs_45: cipherstate = (if v_351 then 1-proj-3-tuple(v_350) else caught-fail) in
        {1010}let v_352: bitstring = (if v_351 then catch-fail(cipherstateunpack(cs_45)) else caught-fail) in
        {1011}let v_353: bool = (not-caught-fail(v_352) && success?(1-proj-2-tuple(v_352))) in
        {1012}let n_26: nonce = (if v_353 then 2-proj-2-tuple(v_352) else caught-fail) in
        {1013}let k_28: key = (if v_353 then 1-proj-2-tuple(v_352) else caught-fail) in
        {1014}let d_6: aead = (if v_353 then catch-fail(decrypt(k_28,n_26,h_45,ciphertext_15)) else caught-fail) in
        {1015}let v_354: bool = not-caught-fail(d_6) in
        {1016}let v_355: bitstring = (if v_354 then catch-fail(aeadunpack(d_6)) else caught-fail) in
        {1017}let v_356: bool = (not-caught-fail(v_355) && success?(1-proj-3-tuple(v_355))) in
        {1018}let plaintext_18: bitstring = (if v_356 then 3-proj-3-tuple(v_355) else caught-fail) in
        {1019}let adi_6: bitstring = (if v_356 then 2-proj-3-tuple(v_355) else caught-fail) in
        {1020}let valid_14: bool = (if v_356 then 1-proj-3-tuple(v_355) else caught-fail) in
        {1022}let v_357: bitstring = (if v_356 then catch-fail(cipherstateunpack(cs_45)) else caught-fail) in
        {1023}let v_358: bool = (not-caught-fail(v_357) && success?(1-proj-2-tuple(v_357))) in
        {1024}let o_13: nonce = (if v_358 then 2-proj-2-tuple(v_357) else caught-fail) in
        {1025}let k_29: key = (if v_358 then 1-proj-2-tuple(v_357) else caught-fail) in
        {1021}let n_27: nonce = (if v_356 then increment_nonce(n_26) else caught-fail) in
        {1026}let csi_26: cipherstate = (if v_356 then catch-fail((if v_358 then cipherstatepack(k_29,n_27) else fail-any)) else caught-fail) in
        {1027}let v_359: bool = not-caught-fail(csi_26) in
        {1028}let v_360: bitstring = (if v_351 then catch-fail((if v_353 then (if v_354 then (if v_356 then (if v_359 then (csi_26,plaintext_18,valid_14) else fail-any) else fail-any) else fail-any) else fail-any)) else caught-fail) in
        {1029}let v_361: bool = (not-caught-fail(v_360) && success?(1-proj-3-tuple(v_360))) in
        {1030}let valid_15: bool = (if v_361 then 3-proj-3-tuple(v_360) else caught-fail) in
        {1031}let plaintext_19: bitstring = (if v_361 then 2-proj-3-tuple(v_360) else caught-fail) in
        {1032}let csi_27: cipherstate = (if v_361 then 1-proj-3-tuple(v_360) else caught-fail) in
        {1033}let ss_50: symmetricstate = (if v_361 then symmetricstatepack(csi_27,ck_55,h_45) else caught-fail) in
        {1034}let v_362: bitstring = (if v_361 then catch-fail(symmetricstateunpack(ss_50)) else caught-fail) in
        {1035}let v_363: bool = (not-caught-fail(v_362) && success?(1-proj-3-tuple(v_362))) in
        {1036}let h_46: bitstring = (if v_363 then 3-proj-3-tuple(v_362) else caught-fail) in
        {1037}let ck_56: key = (if v_363 then 2-proj-3-tuple(v_362) else caught-fail) in
        {1038}let cs_46: cipherstate = (if v_363 then 1-proj-3-tuple(v_362) else caught-fail) in
        {1039}let ssi_14: symmetricstate = (if v_361 then catch-fail((if v_363 then symmetricstatepack(cs_46,ck_56,hash(h_46,ciphertext_15)) else fail-any)) else caught-fail) in
        {1040}let v_364: bool = not-caught-fail(ssi_14) in
        {1041}let v_365: bitstring = (if v_349 then catch-fail((if v_351 then (if v_361 then (if v_364 then (ssi_14,plaintext_19,valid_15) else fail-any) else fail-any) else fail-any)) else caught-fail) in
        {1042}let v_366: bool = (not-caught-fail(v_365) && success?(1-proj-3-tuple(v_365))) in
        {1043}let valid3_1: bool = (if v_366 then 3-proj-3-tuple(v_365) else caught-fail) in
        {1044}let plaintext_20: bitstring = (if v_366 then 2-proj-3-tuple(v_365) else caught-fail) in
        {1045}let ss_51: symmetricstate = (if v_366 then 1-proj-3-tuple(v_365) else caught-fail) in
        {1049}let basis_9: key = (if v_366 then key_m(them_1) else caught-fail) in
        {1050}let public_key_9: key = (if v_366 then catch-fail(dhexp(basis_9,validkey(g))) else caught-fail) in
        {1051}let v_368: bool = not-caught-fail(public_key_9) in
        {1046}let basis_8: key = (if v_366 then key_s(them_1) else caught-fail) in
        {1047}let public_key_8: key = (if v_366 then catch-fail(dhexp(basis_8,validkey(g))) else caught-fail) in
        {1048}let v_367: bool = not-caught-fail(public_key_8) in
        {1052}let v_369: bool = (if v_366 then catch-fail(((valid1_4 && (valid2_4 && valid3_1)) && ((rs_9 = getpublickey((if v_367 then keypairpack(validkey(public_key_8),basis_8) else fail-any))) && (rm_9 = getpublickey((if v_368 then keypairpack(validkey(public_key_9),basis_9) else fail-any)))))) else caught-fail) in
        {1054}let v_370: bitstring = (if v_369 then catch-fail(symmetricstateunpack(ss_51)) else caught-fail) in
        {1055}let v_371: bool = (not-caught-fail(v_370) && success?(1-proj-3-tuple(v_370))) in
        {1056}let h_47: bitstring = (if v_371 then 3-proj-3-tuple(v_370) else caught-fail) in
        {1057}let ck_57: key = (if v_371 then 2-proj-3-tuple(v_370) else caught-fail) in
        {1058}let cs_47: cipherstate = (if v_371 then 1-proj-3-tuple(v_370) else caught-fail) in
        {1059}let input_key_material_11: key = (if v_371 then zero else caught-fail) in
        {1062}let output3_11: key = (if v_371 then hmac_hash3(ck_57,input_key_material_11) else caught-fail) in
        {1061}let output2_11: key = (if v_371 then hmac_hash2(ck_57,input_key_material_11) else caught-fail) in
        {1060}let output1_11: key = (if v_371 then hmac_hash1(ck_57,input_key_material_11) else caught-fail) in
        {1063}let v_372: bitstring = (if v_371 then catch-fail((output1_11,output2_11,output3_11)) else caught-fail) in
        {1064}let v_373: bool = (not-caught-fail(v_372) && success?(1-proj-3-tuple(v_372))) in
        {1065}let temp_k3_1: key = (if v_373 then 3-proj-3-tuple(v_372) else caught-fail) in
        {1066}let temp_k2_1: key = (if v_373 then 2-proj-3-tuple(v_372) else caught-fail) in
        {1067}let temp_k1_1: key = (if v_373 then 1-proj-3-tuple(v_372) else caught-fail) in
        {1069}let cs2_5: cipherstate = (if v_373 then cipherstatepack(temp_k2_1,minnonce) else caught-fail) in
        {1068}let cs1_5: cipherstate = (if v_373 then cipherstatepack(temp_k1_1,minnonce) else caught-fail) in
        {1070}let v_374: bitstring = (if v_369 then catch-fail((if v_371 then (if v_373 then (ss_51,cs1_5,cs2_5) else fail-any) else fail-any)) else caught-fail) in
        {1071}let v_375: bool = (not-caught-fail(v_374) && success?(1-proj-3-tuple(v_374))) in
        {1072}let cs2_6: cipherstate = (if v_375 then 3-proj-3-tuple(v_374) else caught-fail) in
        {1073}let cs1_6: cipherstate = (if v_375 then 2-proj-3-tuple(v_374) else caught-fail) in
        {1074}let ssi_15: symmetricstate = (if v_375 then 1-proj-3-tuple(v_374) else caught-fail) in
        {1053}let hs_20: handshakestate = (if v_369 then handshakestatepack(ss_51,s_9,m_9,e_16,rs_9,rm_9,re_9,psk_7,initiator_6) else caught-fail) in
        {1075}let (hs_21: handshakestate,plaintext_b_1: bitstring,valid_16: bool,cs1_7: cipherstate,cs2_7: cipherstate) = (if v_270 then (if v_272 then (if v_275 then (if v_283 then (if v_291 then (if v_299 then (if v_316 then (if v_333 then (if v_341 then (if v_349 then (if v_366 then (if undo-catch-fail(v_369) then (if v_375 then (hs_20,plaintext_20,true,cs1_6,cs2_6) else fail-any) else fail-any) else fail-any) else fail-any) else fail-any) else fail-any) else fail-any) else fail-any) else fail-any) else fail-any) else fail-any) else fail-any) else fail-any) in
        {1076}event RecvMsg(me_1,them_1,stagepack_b(sid_2),plaintext_b_1);
        {1077}insert statestore(me_1,them_1,sid_2,statepack_c(hs_21,cs1_7,cs2_7))
    ) | (
        {1079}!
        {1138}get statestore(=me_1,=them_1,=sid_2,statepack_c(hs_22: handshakestate,cs1_8: cipherstate,cs2_8: cipherstate)) in
        {1080}let hs_23: handshakestate = handshakestatesetcs(hs_22,cs1_8) in
        {1082}let v_376: bitstring = catch-fail(handshakestateunpack(hs_23)) in
        {1083}let v_377: bool = (not-caught-fail(v_376) && success?(1-proj-9-tuple(v_376))) in
        {1084}let initiator_7: bool = (if v_377 then 9-proj-9-tuple(v_376) else caught-fail) in
        {1085}let psk_8: key = (if v_377 then 8-proj-9-tuple(v_376) else caught-fail) in
        {1086}let re_10: key = (if v_377 then 7-proj-9-tuple(v_376) else caught-fail) in
        {1087}let rm_10: key = (if v_377 then 6-proj-9-tuple(v_376) else caught-fail) in
        {1088}let rs_10: key = (if v_377 then 5-proj-9-tuple(v_376) else caught-fail) in
        {1089}let e_17: keypair = (if v_377 then 4-proj-9-tuple(v_376) else caught-fail) in
        {1090}let m_10: keypair = (if v_377 then 3-proj-9-tuple(v_376) else caught-fail) in
        {1091}let s_10: keypair = (if v_377 then 2-proj-9-tuple(v_376) else caught-fail) in
        {1092}let ss_52: symmetricstate = (if v_377 then 1-proj-9-tuple(v_376) else caught-fail) in
        {1093}let v_378: bitstring = (if v_377 then catch-fail((empty,empty,empty,empty)) else caught-fail) in
        {1094}let v_379: bool = (not-caught-fail(v_378) && success?(1-proj-4-tuple(v_378))) in
        {1095}let ciphertext_16: bitstring = (if v_379 then 4-proj-4-tuple(v_378) else caught-fail) in
        {1096}let nm_8: bitstring = (if v_379 then 3-proj-4-tuple(v_378) else caught-fail) in
        {1097}let ns_8: bitstring = (if v_379 then 2-proj-4-tuple(v_378) else caught-fail) in
        {1098}let ne_12: bitstring = (if v_379 then 1-proj-4-tuple(v_378) else caught-fail) in
        {1099}let v_380: bitstring = (if v_379 then catch-fail(symmetricstateunpack(ss_52)) else caught-fail) in
        {1100}let v_381: bool = (not-caught-fail(v_380) && success?(1-proj-3-tuple(v_380))) in
        {1101}let h_48: bitstring = (if v_381 then 3-proj-3-tuple(v_380) else caught-fail) in
        {1102}let ck_58: key = (if v_381 then 2-proj-3-tuple(v_380) else caught-fail) in
        {1103}let cs_48: cipherstate = (if v_381 then 1-proj-3-tuple(v_380) else caught-fail) in
        {1104}let v_382: bitstring = (if v_381 then catch-fail(cipherstateunpack(cs_48)) else caught-fail) in
        {1105}let v_383: bool = (not-caught-fail(v_382) && success?(1-proj-2-tuple(v_382))) in
        {1106}let n_28: nonce = (if v_383 then 2-proj-2-tuple(v_382) else caught-fail) in
        {1107}let k_30: key = (if v_383 then 1-proj-2-tuple(v_382) else caught-fail) in
        {1110}let v_384: bitstring = (if v_383 then catch-fail(cipherstateunpack(cs_48)) else caught-fail) in
        {1111}let v_385: bool = (not-caught-fail(v_384) && success?(1-proj-2-tuple(v_384))) in
        {1112}let o_14: nonce = (if v_385 then 2-proj-2-tuple(v_384) else caught-fail) in
        {1113}let k_31: key = (if v_385 then 1-proj-2-tuple(v_384) else caught-fail) in
        {1109}let n_29: nonce = (if v_383 then increment_nonce(n_28) else caught-fail) in
        {1114}let csi_28: cipherstate = (if v_383 then catch-fail((if v_385 then cipherstatepack(k_31,n_29) else fail-any)) else caught-fail) in
        {1115}let v_386: bool = not-caught-fail(csi_28) in
        {1081}let payload_3: bitstring = msg_c(me_1,them_1,sid_2) in
        {1108}let e_18: bitstring = (if v_383 then encrypt(k_30,n_28,h_48,payload_3) else caught-fail) in
        {1116}let v_387: bitstring = (if v_381 then catch-fail((if v_383 then (if v_386 then (csi_28,e_18) else fail-any) else fail-any)) else caught-fail) in
        {1117}let v_388: bool = (not-caught-fail(v_387) && success?(1-proj-2-tuple(v_387))) in
        {1118}let ciphertext_17: bitstring = (if v_388 then 2-proj-2-tuple(v_387) else caught-fail) in
        {1119}let csi_29: cipherstate = (if v_388 then 1-proj-2-tuple(v_387) else caught-fail) in
        {1120}let ss_53: symmetricstate = (if v_388 then symmetricstatepack(csi_29,ck_58,h_48) else caught-fail) in
        {1121}let v_389: bitstring = (if v_388 then catch-fail(symmetricstateunpack(ss_53)) else caught-fail) in
        {1122}let v_390: bool = (not-caught-fail(v_389) && success?(1-proj-3-tuple(v_389))) in
        {1123}let h_49: bitstring = (if v_390 then 3-proj-3-tuple(v_389) else caught-fail) in
        {1124}let ck_59: key = (if v_390 then 2-proj-3-tuple(v_389) else caught-fail) in
        {1125}let cs_49: cipherstate = (if v_390 then 1-proj-3-tuple(v_389) else caught-fail) in
        {1126}let ssi_16: symmetricstate = (if v_388 then catch-fail((if v_390 then symmetricstatepack(cs_49,ck_59,hash(h_49,ciphertext_17)) else fail-any)) else caught-fail) in
        {1127}let v_391: bool = not-caught-fail(ssi_16) in
        {1128}let v_392: bitstring = (if v_379 then catch-fail((if v_381 then (if v_388 then (if v_391 then (ssi_16,ciphertext_17) else fail-any) else fail-any) else fail-any)) else caught-fail) in
        {1129}let v_393: bool = (not-caught-fail(v_392) && success?(1-proj-2-tuple(v_392))) in
        {1130}let ciphertext_18: bitstring = (if v_393 then 2-proj-2-tuple(v_392) else caught-fail) in
        {1131}let ss_54: symmetricstate = (if v_393 then 1-proj-2-tuple(v_392) else caught-fail) in
        {1133}let message_buffer_3: bitstring = (if v_393 then concat4(ne_12,ns_8,nm_8,ciphertext_18) else caught-fail) in
        {1132}let hs_24: handshakestate = (if v_393 then handshakestatepack(ss_54,s_10,m_10,e_17,rs_10,rm_10,re_10,psk_8,initiator_7) else caught-fail) in
        {1134}let (hs_25: handshakestate,message_c_1: bitstring) = (if v_377 then (if v_379 then (if v_393 then (hs_24,message_buffer_3) else fail-any) else fail-any) else fail-any) in
        {1135}event SendMsg(me_1,them_1,stagepack_c(sid_2),msg_c(me_1,them_1,sid_2));
        {1136}insert statestore(me_1,them_1,sid_2,statepack_d(hs_25,handshakestategetcs(hs_25),cs2_8));
        {1137}out(pub, message_c_1)
    ) | (
        {1139}!
        {1206}get statestore(=me_1,=them_1,=sid_2,statepack_d(hs_26: handshakestate,cs1_9: cipherstate,cs2_9: cipherstate)) in
        {1140}let hs_27: handshakestate = handshakestatesetcs(hs_26,cs2_9) in
        {1141}in(pub, message_d_1: bitstring);
        {1142}let v_394: bitstring = catch-fail(handshakestateunpack(hs_27)) in
        {1143}let v_395: bool = (not-caught-fail(v_394) && success?(1-proj-9-tuple(v_394))) in
        {1144}let initiator_8: bool = (if v_395 then 9-proj-9-tuple(v_394) else caught-fail) in
        {1145}let psk_9: key = (if v_395 then 8-proj-9-tuple(v_394) else caught-fail) in
        {1146}let re_11: key = (if v_395 then 7-proj-9-tuple(v_394) else caught-fail) in
        {1147}let rm_11: key = (if v_395 then 6-proj-9-tuple(v_394) else caught-fail) in
        {1148}let rs_11: key = (if v_395 then 5-proj-9-tuple(v_394) else caught-fail) in
        {1149}let e_19: keypair = (if v_395 then 4-proj-9-tuple(v_394) else caught-fail) in
        {1150}let m_11: keypair = (if v_395 then 3-proj-9-tuple(v_394) else caught-fail) in
        {1151}let s_11: keypair = (if v_395 then 2-proj-9-tuple(v_394) else caught-fail) in
        {1152}let ss_55: symmetricstate = (if v_395 then 1-proj-9-tuple(v_394) else caught-fail) in
        {1153}let v_396: bitstring = (if v_395 then catch-fail(deconcat4(message_d_1)) else caught-fail) in
        {1154}let v_397: bool = (not-caught-fail(v_396) && success?(1-proj-4-tuple(v_396))) in
        {1155}let ciphertext_19: bitstring = (if v_397 then 4-proj-4-tuple(v_396) else caught-fail) in
        {1156}let nm_9: bitstring = (if v_397 then 3-proj-4-tuple(v_396) else caught-fail) in
        {1157}let ns_9: bitstring = (if v_397 then 2-proj-4-tuple(v_396) else caught-fail) in
        {1158}let ne_13: bitstring = (if v_397 then 1-proj-4-tuple(v_396) else caught-fail) in
        {1160}let v_398: bitstring = (if v_397 then catch-fail(symmetricstateunpack(ss_55)) else caught-fail) in
        {1161}let v_399: bool = (not-caught-fail(v_398) && success?(1-proj-3-tuple(v_398))) in
        {1162}let h_50: bitstring = (if v_399 then 3-proj-3-tuple(v_398) else caught-fail) in
        {1163}let ck_60: key = (if v_399 then 2-proj-3-tuple(v_398) else caught-fail) in
        {1164}let cs_50: cipherstate = (if v_399 then 1-proj-3-tuple(v_398) else caught-fail) in
        {1165}let v_400: bitstring = (if v_399 then catch-fail(cipherstateunpack(cs_50)) else caught-fail) in
        {1166}let v_401: bool = (not-caught-fail(v_400) && success?(1-proj-2-tuple(v_400))) in
        {1167}let n_30: nonce = (if v_401 then 2-proj-2-tuple(v_400) else caught-fail) in
        {1168}let k_32: key = (if v_401 then 1-proj-2-tuple(v_400) else caught-fail) in
        {1169}let d_7: aead = (if v_401 then catch-fail(decrypt(k_32,n_30,h_50,ciphertext_19)) else caught-fail) in
        {1170}let v_402: bool = not-caught-fail(d_7) in
        {1171}let v_403: bitstring = (if v_402 then catch-fail(aeadunpack(d_7)) else caught-fail) in
        {1172}let v_404: bool = (not-caught-fail(v_403) && success?(1-proj-3-tuple(v_403))) in
        {1173}let plaintext_21: bitstring = (if v_404 then 3-proj-3-tuple(v_403) else caught-fail) in
        {1174}let adi_7: bitstring = (if v_404 then 2-proj-3-tuple(v_403) else caught-fail) in
        {1175}let valid_17: bool = (if v_404 then 1-proj-3-tuple(v_403) else caught-fail) in
        {1177}let v_405: bitstring = (if v_404 then catch-fail(cipherstateunpack(cs_50)) else caught-fail) in
        {1178}let v_406: bool = (not-caught-fail(v_405) && success?(1-proj-2-tuple(v_405))) in
        {1179}let o_15: nonce = (if v_406 then 2-proj-2-tuple(v_405) else caught-fail) in
        {1180}let k_33: key = (if v_406 then 1-proj-2-tuple(v_405) else caught-fail) in
        {1176}let n_31: nonce = (if v_404 then increment_nonce(n_30) else caught-fail) in
        {1181}let csi_30: cipherstate = (if v_404 then catch-fail((if v_406 then cipherstatepack(k_33,n_31) else fail-any)) else caught-fail) in
        {1182}let v_407: bool = not-caught-fail(csi_30) in
        {1183}let v_408: bitstring = (if v_399 then catch-fail((if v_401 then (if v_402 then (if v_404 then (if v_407 then (csi_30,plaintext_21,valid_17) else fail-any) else fail-any) else fail-any) else fail-any)) else caught-fail) in
        {1184}let v_409: bool = (not-caught-fail(v_408) && success?(1-proj-3-tuple(v_408))) in
        {1185}let valid_18: bool = (if v_409 then 3-proj-3-tuple(v_408) else caught-fail) in
        {1186}let plaintext_22: bitstring = (if v_409 then 2-proj-3-tuple(v_408) else caught-fail) in
        {1187}let csi_31: cipherstate = (if v_409 then 1-proj-3-tuple(v_408) else caught-fail) in
        {1188}let ss_56: symmetricstate = (if v_409 then symmetricstatepack(csi_31,ck_60,h_50) else caught-fail) in
        {1189}let v_410: bitstring = (if v_409 then catch-fail(symmetricstateunpack(ss_56)) else caught-fail) in
        {1190}let v_411: bool = (not-caught-fail(v_410) && success?(1-proj-3-tuple(v_410))) in
        {1191}let h_51: bitstring = (if v_411 then 3-proj-3-tuple(v_410) else caught-fail) in
        {1192}let ck_61: key = (if v_411 then 2-proj-3-tuple(v_410) else caught-fail) in
        {1193}let cs_51: cipherstate = (if v_411 then 1-proj-3-tuple(v_410) else caught-fail) in
        {1194}let ssi_17: symmetricstate = (if v_409 then catch-fail((if v_411 then symmetricstatepack(cs_51,ck_61,hash(h_51,ciphertext_19)) else fail-any)) else caught-fail) in
        {1195}let v_412: bool = not-caught-fail(ssi_17) in
        {1196}let v_413: bitstring = (if v_397 then catch-fail((if v_399 then (if v_409 then (if v_412 then (ssi_17,plaintext_22,valid_18) else fail-any) else fail-any) else fail-any)) else caught-fail) in
        {1197}let v_414: bool = (not-caught-fail(v_413) && success?(1-proj-3-tuple(v_413))) in
        {1198}let valid2_5: bool = (if v_414 then 3-proj-3-tuple(v_413) else caught-fail) in
        {1199}let plaintext_23: bitstring = (if v_414 then 2-proj-3-tuple(v_413) else caught-fail) in
        {1200}let ss_57: symmetricstate = (if v_414 then 1-proj-3-tuple(v_413) else caught-fail) in
        {1159}let valid1_5: bool = (if v_397 then true else caught-fail) in
        {1201}let v_415: bool = (if v_414 then catch-fail((valid1_5 && valid2_5)) else caught-fail) in
        {1202}let hs_28: handshakestate = (if v_415 then handshakestatepack(ss_57,s_11,m_11,e_19,rs_11,rm_11,re_11,psk_9,initiator_8) else caught-fail) in
        {1203}let (hs_29: handshakestate,plaintext_d_1: bitstring,valid_19: bool) = (if v_395 then (if v_397 then (if v_414 then (if undo-catch-fail(v_415) then (hs_28,plaintext_23,true) else fail-any) else fail-any) else fail-any) else fail-any) in
        {1204}event RecvMsg(me_1,them_1,stagepack_d(sid_2),plaintext_d_1);
        {1205}event RecvEnd(valid_19)
    ) | (
        {1207}event LeakS(phase0,me_1);
        {1208}event LeakM(phase0,me_1);
        {1209}out(pub, (key_s(me_1),key_m(me_1)))
    ) | (
        {1210}phase 1;
        {1211}event LeakS(phase1,me_1);
        {1212}event LeakM(phase1,me_1);
        {1213}out(pub, (key_s(me_1),key_m(me_1)))
    )
) | (
    {1214}let me_2: principal = bob in
    {1218}let basis_10: key = key_m(me_2) in
    {1219}let public_key_10: key = catch-fail(dhexp(basis_10,validkey(g))) in
    {1220}let v_416: bool = not-caught-fail(public_key_10) in
    {1221}let m_12: keypair = (if v_416 then keypairpack(validkey(public_key_10),basis_10) else fail-any) in
    {1217}let s_12: keypair = keypairpack(empty,empty) in
    {1222}out(pub, (getpublickey(s_12),getpublickey(m_12)));
    {1216}let sid_3: sessionid = sid in
    {1215}let them_2: principal = alice in
    (
        {1232}let k_34: key = empty in
        {1233}let cs_52: cipherstate = cipherstatepack(k_34,minnonce) in
        {1229}let protocol_name_2: bitstring = somename in
        {1230}let h_52: bitstring = hash(protocol_name_2,empty) in
        {1231}let ck_62: key = h_52 in
        {1234}let ss_58: symmetricstate = symmetricstatepack(cs_52,ck_62,h_52) in
        {1235}let v_417: bitstring = catch-fail(symmetricstateunpack(ss_58)) in
        {1236}let v_418: bool = (not-caught-fail(v_417) && success?(1-proj-3-tuple(v_417))) in
        {1237}let h_53: bitstring = (if v_418 then 3-proj-3-tuple(v_417) else caught-fail) in
        {1238}let ck_63: key = (if v_418 then 2-proj-3-tuple(v_417) else caught-fail) in
        {1239}let cs_53: cipherstate = (if v_418 then 1-proj-3-tuple(v_417) else caught-fail) in
        {1227}let prologue_2: bitstring = empty in
        {1240}let ss_59: symmetricstate = catch-fail((if v_418 then symmetricstatepack(cs_53,ck_63,hash(h_53,prologue_2)) else fail-any)) in
        {1241}let v_419: bool = not-caught-fail(ss_59) in
        {1228}let psk_10: key = empty in
        {1226}let re_12: key = empty in
        {1225}let rm_12: key = empty in
        {1224}let rs_12: key = empty in
        {1223}let e_20: keypair = keypairpack(empty,empty) in
        {1242}let hs_30: handshakestate = (if v_419 then handshakestatepack(ss_59,s_12,m_12,e_20,rs_12,rm_12,re_12,psk_10,false) else fail-any) in
        {1243}insert statestore(me_2,them_2,sid_3,statepack_a(hs_30))
    ) | (
        {1408}get statestore(=me_2,=them_2,=sid_3,statepack_a(hs_31: handshakestate)) in
        {1244}in(pub, message_a_2: bitstring);
        {1245}let v_420: bitstring = catch-fail(handshakestateunpack(hs_31)) in
        {1246}let v_421: bool = (not-caught-fail(v_420) && success?(1-proj-9-tuple(v_420))) in
        {1247}let initiator_9: bool = (if v_421 then 9-proj-9-tuple(v_420) else caught-fail) in
        {1248}let psk_11: key = (if v_421 then 8-proj-9-tuple(v_420) else caught-fail) in
        {1249}let re_13: key = (if v_421 then 7-proj-9-tuple(v_420) else caught-fail) in
        {1250}let rm_13: key = (if v_421 then 6-proj-9-tuple(v_420) else caught-fail) in
        {1251}let rs_13: key = (if v_421 then 5-proj-9-tuple(v_420) else caught-fail) in
        {1252}let e_21: keypair = (if v_421 then 4-proj-9-tuple(v_420) else caught-fail) in
        {1253}let m_13: keypair = (if v_421 then 3-proj-9-tuple(v_420) else caught-fail) in
        {1254}let s_13: keypair = (if v_421 then 2-proj-9-tuple(v_420) else caught-fail) in
        {1255}let ss_60: symmetricstate = (if v_421 then 1-proj-9-tuple(v_420) else caught-fail) in
        {1256}let v_422: bitstring = (if v_421 then catch-fail(deconcat4(message_a_2)) else caught-fail) in
        {1257}let v_423: bool = (not-caught-fail(v_422) && success?(1-proj-4-tuple(v_422))) in
        {1258}let ciphertext_20: bitstring = (if v_423 then 4-proj-4-tuple(v_422) else caught-fail) in
        {1259}let nm_10: bitstring = (if v_423 then 3-proj-4-tuple(v_422) else caught-fail) in
        {1260}let ns_10: bitstring = (if v_423 then 2-proj-4-tuple(v_422) else caught-fail) in
        {1261}let ne_14: bitstring = (if v_423 then 1-proj-4-tuple(v_422) else caught-fail) in
        {1265}let v_424: bitstring = (if v_423 then catch-fail(symmetricstateunpack(ss_60)) else caught-fail) in
        {1266}let v_425: bool = (not-caught-fail(v_424) && success?(1-proj-3-tuple(v_424))) in
        {1267}let h_54: bitstring = (if v_425 then 3-proj-3-tuple(v_424) else caught-fail) in
        {1268}let ck_64: key = (if v_425 then 2-proj-3-tuple(v_424) else caught-fail) in
        {1269}let cs_54: cipherstate = (if v_425 then 1-proj-3-tuple(v_424) else caught-fail) in
        {1264}let re_14: key = (if v_423 then ne_14 else caught-fail) in
        {1270}let ss_61: symmetricstate = (if v_423 then catch-fail((if v_425 then symmetricstatepack(cs_54,ck_64,hash(h_54,re_14)) else fail-any)) else caught-fail) in
        {1271}let v_426: bool = not-caught-fail(ss_61) in
        {1272}let v_427: bitstring = (if v_426 then catch-fail(symmetricstateunpack(ss_61)) else caught-fail) in
        {1273}let v_428: bool = (not-caught-fail(v_427) && success?(1-proj-3-tuple(v_427))) in
        {1274}let h_55: bitstring = (if v_428 then 3-proj-3-tuple(v_427) else caught-fail) in
        {1275}let ck_65: key = (if v_428 then 2-proj-3-tuple(v_427) else caught-fail) in
        {1276}let cs_55: cipherstate = (if v_428 then 1-proj-3-tuple(v_427) else caught-fail) in
        {1277}let v_429: bitstring = (if v_428 then catch-fail(cipherstateunpack(cs_55)) else caught-fail) in
        {1278}let v_430: bool = (not-caught-fail(v_429) && success?(1-proj-2-tuple(v_429))) in
        {1279}let n_32: nonce = (if v_430 then 2-proj-2-tuple(v_429) else caught-fail) in
        {1280}let k_35: key = (if v_430 then 1-proj-2-tuple(v_429) else caught-fail) in
        {1281}let d_8: aead = (if v_430 then catch-fail(decrypt(k_35,n_32,h_55,ns_10)) else caught-fail) in
        {1282}let v_431: bool = not-caught-fail(d_8) in
        {1283}let v_432: bitstring = (if v_431 then catch-fail(aeadunpack(d_8)) else caught-fail) in
        {1284}let v_433: bool = (not-caught-fail(v_432) && success?(1-proj-3-tuple(v_432))) in
        {1285}let plaintext_24: bitstring = (if v_433 then 3-proj-3-tuple(v_432) else caught-fail) in
        {1286}let adi_8: bitstring = (if v_433 then 2-proj-3-tuple(v_432) else caught-fail) in
        {1287}let valid_20: bool = (if v_433 then 1-proj-3-tuple(v_432) else caught-fail) in
        {1289}let v_434: bitstring = (if v_433 then catch-fail(cipherstateunpack(cs_55)) else caught-fail) in
        {1290}let v_435: bool = (not-caught-fail(v_434) && success?(1-proj-2-tuple(v_434))) in
        {1291}let o_16: nonce = (if v_435 then 2-proj-2-tuple(v_434) else caught-fail) in
        {1292}let k_36: key = (if v_435 then 1-proj-2-tuple(v_434) else caught-fail) in
        {1288}let n_33: nonce = (if v_433 then increment_nonce(n_32) else caught-fail) in
        {1293}let csi_32: cipherstate = (if v_433 then catch-fail((if v_435 then cipherstatepack(k_36,n_33) else fail-any)) else caught-fail) in
        {1294}let v_436: bool = not-caught-fail(csi_32) in
        {1295}let v_437: bitstring = (if v_428 then catch-fail((if v_430 then (if v_431 then (if v_433 then (if v_436 then (csi_32,plaintext_24,valid_20) else fail-any) else fail-any) else fail-any) else fail-any)) else caught-fail) in
        {1296}let v_438: bool = (not-caught-fail(v_437) && success?(1-proj-3-tuple(v_437))) in
        {1297}let valid_21: bool = (if v_438 then 3-proj-3-tuple(v_437) else caught-fail) in
        {1298}let plaintext_25: bitstring = (if v_438 then 2-proj-3-tuple(v_437) else caught-fail) in
        {1299}let csi_33: cipherstate = (if v_438 then 1-proj-3-tuple(v_437) else caught-fail) in
        {1300}let ss_62: symmetricstate = (if v_438 then symmetricstatepack(csi_33,ck_65,h_55) else caught-fail) in
        {1301}let v_439: bitstring = (if v_438 then catch-fail(symmetricstateunpack(ss_62)) else caught-fail) in
        {1302}let v_440: bool = (not-caught-fail(v_439) && success?(1-proj-3-tuple(v_439))) in
        {1303}let h_56: bitstring = (if v_440 then 3-proj-3-tuple(v_439) else caught-fail) in
        {1304}let ck_66: key = (if v_440 then 2-proj-3-tuple(v_439) else caught-fail) in
        {1305}let cs_56: cipherstate = (if v_440 then 1-proj-3-tuple(v_439) else caught-fail) in
        {1306}let ssi_18: symmetricstate = (if v_438 then catch-fail((if v_440 then symmetricstatepack(cs_56,ck_66,hash(h_56,ns_10)) else fail-any)) else caught-fail) in
        {1307}let v_441: bool = not-caught-fail(ssi_18) in
        {1308}let v_442: bitstring = (if v_426 then catch-fail((if v_428 then (if v_438 then (if v_441 then (ssi_18,plaintext_25,valid_21) else fail-any) else fail-any) else fail-any)) else caught-fail) in
        {1309}let v_443: bool = (not-caught-fail(v_442) && success?(1-proj-3-tuple(v_442))) in
        {1310}let valid1_7: bool = (if v_443 then 3-proj-3-tuple(v_442) else caught-fail) in
        {1311}let ne_15: bitstring = (if v_443 then 2-proj-3-tuple(v_442) else caught-fail) in
        {1312}let ss_63: symmetricstate = (if v_443 then 1-proj-3-tuple(v_442) else caught-fail) in
        {1314}let v_444: bitstring = (if v_443 then catch-fail(symmetricstateunpack(ss_63)) else caught-fail) in
        {1315}let v_445: bool = (not-caught-fail(v_444) && success?(1-proj-3-tuple(v_444))) in
        {1316}let h_57: bitstring = (if v_445 then 3-proj-3-tuple(v_444) else caught-fail) in
        {1317}let ck_67: key = (if v_445 then 2-proj-3-tuple(v_444) else caught-fail) in
        {1318}let cs_57: cipherstate = (if v_445 then 1-proj-3-tuple(v_444) else caught-fail) in
        {1319}let v_446: bitstring = (if v_445 then catch-fail(cipherstateunpack(cs_57)) else caught-fail) in
        {1320}let v_447: bool = (not-caught-fail(v_446) && success?(1-proj-2-tuple(v_446))) in
        {1321}let n_34: nonce = (if v_447 then 2-proj-2-tuple(v_446) else caught-fail) in
        {1322}let k_37: key = (if v_447 then 1-proj-2-tuple(v_446) else caught-fail) in
        {1323}let d_9: aead = (if v_447 then catch-fail(decrypt(k_37,n_34,h_57,nm_10)) else caught-fail) in
        {1324}let v_448: bool = not-caught-fail(d_9) in
        {1325}let v_449: bitstring = (if v_448 then catch-fail(aeadunpack(d_9)) else caught-fail) in
        {1326}let v_450: bool = (not-caught-fail(v_449) && success?(1-proj-3-tuple(v_449))) in
        {1327}let plaintext_26: bitstring = (if v_450 then 3-proj-3-tuple(v_449) else caught-fail) in
        {1328}let adi_9: bitstring = (if v_450 then 2-proj-3-tuple(v_449) else caught-fail) in
        {1329}let valid_22: bool = (if v_450 then 1-proj-3-tuple(v_449) else caught-fail) in
        {1331}let v_451: bitstring = (if v_450 then catch-fail(cipherstateunpack(cs_57)) else caught-fail) in
        {1332}let v_452: bool = (not-caught-fail(v_451) && success?(1-proj-2-tuple(v_451))) in
        {1333}let o_17: nonce = (if v_452 then 2-proj-2-tuple(v_451) else caught-fail) in
        {1334}let k_38: key = (if v_452 then 1-proj-2-tuple(v_451) else caught-fail) in
        {1330}let n_35: nonce = (if v_450 then increment_nonce(n_34) else caught-fail) in
        {1335}let csi_34: cipherstate = (if v_450 then catch-fail((if v_452 then cipherstatepack(k_38,n_35) else fail-any)) else caught-fail) in
        {1336}let v_453: bool = not-caught-fail(csi_34) in
        {1337}let v_454: bitstring = (if v_445 then catch-fail((if v_447 then (if v_448 then (if v_450 then (if v_453 then (csi_34,plaintext_26,valid_22) else fail-any) else fail-any) else fail-any) else fail-any)) else caught-fail) in
        {1338}let v_455: bool = (not-caught-fail(v_454) && success?(1-proj-3-tuple(v_454))) in
        {1339}let valid_23: bool = (if v_455 then 3-proj-3-tuple(v_454) else caught-fail) in
        {1340}let plaintext_27: bitstring = (if v_455 then 2-proj-3-tuple(v_454) else caught-fail) in
        {1341}let csi_35: cipherstate = (if v_455 then 1-proj-3-tuple(v_454) else caught-fail) in
        {1342}let ss_64: symmetricstate = (if v_455 then symmetricstatepack(csi_35,ck_67,h_57) else caught-fail) in
        {1343}let v_456: bitstring = (if v_455 then catch-fail(symmetricstateunpack(ss_64)) else caught-fail) in
        {1344}let v_457: bool = (not-caught-fail(v_456) && success?(1-proj-3-tuple(v_456))) in
        {1345}let h_58: bitstring = (if v_457 then 3-proj-3-tuple(v_456) else caught-fail) in
        {1346}let ck_68: key = (if v_457 then 2-proj-3-tuple(v_456) else caught-fail) in
        {1347}let cs_58: cipherstate = (if v_457 then 1-proj-3-tuple(v_456) else caught-fail) in
        {1348}let ssi_19: symmetricstate = (if v_455 then catch-fail((if v_457 then symmetricstatepack(cs_58,ck_68,hash(h_58,nm_10)) else fail-any)) else caught-fail) in
        {1349}let v_458: bool = not-caught-fail(ssi_19) in
        {1350}let v_459: bitstring = (if v_443 then catch-fail((if v_445 then (if v_455 then (if v_458 then (ssi_19,plaintext_27,valid_23) else fail-any) else fail-any) else fail-any)) else caught-fail) in
        {1351}let v_460: bool = (not-caught-fail(v_459) && success?(1-proj-3-tuple(v_459))) in
        {1352}let valid2_7: bool = (if v_460 then 3-proj-3-tuple(v_459) else caught-fail) in
        {1353}let ne_16: bitstring = (if v_460 then 2-proj-3-tuple(v_459) else caught-fail) in
        {1354}let ss_65: symmetricstate = (if v_460 then 1-proj-3-tuple(v_459) else caught-fail) in
        {1356}let v_461: bitstring = (if v_460 then catch-fail(symmetricstateunpack(ss_65)) else caught-fail) in
        {1357}let v_462: bool = (not-caught-fail(v_461) && success?(1-proj-3-tuple(v_461))) in
        {1358}let h_59: bitstring = (if v_462 then 3-proj-3-tuple(v_461) else caught-fail) in
        {1359}let ck_69: key = (if v_462 then 2-proj-3-tuple(v_461) else caught-fail) in
        {1360}let cs_59: cipherstate = (if v_462 then 1-proj-3-tuple(v_461) else caught-fail) in
        {1361}let v_463: bitstring = (if v_462 then catch-fail(cipherstateunpack(cs_59)) else caught-fail) in
        {1362}let v_464: bool = (not-caught-fail(v_463) && success?(1-proj-2-tuple(v_463))) in
        {1363}let n_36: nonce = (if v_464 then 2-proj-2-tuple(v_463) else caught-fail) in
        {1364}let k_39: key = (if v_464 then 1-proj-2-tuple(v_463) else caught-fail) in
        {1365}let d_10: aead = (if v_464 then catch-fail(decrypt(k_39,n_36,h_59,ciphertext_20)) else caught-fail) in
        {1366}let v_465: bool = not-caught-fail(d_10) in
        {1367}let v_466: bitstring = (if v_465 then catch-fail(aeadunpack(d_10)) else caught-fail) in
        {1368}let v_467: bool = (not-caught-fail(v_466) && success?(1-proj-3-tuple(v_466))) in
        {1369}let plaintext_28: bitstring = (if v_467 then 3-proj-3-tuple(v_466) else caught-fail) in
        {1370}let adi_10: bitstring = (if v_467 then 2-proj-3-tuple(v_466) else caught-fail) in
        {1371}let valid_24: bool = (if v_467 then 1-proj-3-tuple(v_466) else caught-fail) in
        {1373}let v_468: bitstring = (if v_467 then catch-fail(cipherstateunpack(cs_59)) else caught-fail) in
        {1374}let v_469: bool = (not-caught-fail(v_468) && success?(1-proj-2-tuple(v_468))) in
        {1375}let o_18: nonce = (if v_469 then 2-proj-2-tuple(v_468) else caught-fail) in
        {1376}let k_40: key = (if v_469 then 1-proj-2-tuple(v_468) else caught-fail) in
        {1372}let n_37: nonce = (if v_467 then increment_nonce(n_36) else caught-fail) in
        {1377}let csi_36: cipherstate = (if v_467 then catch-fail((if v_469 then cipherstatepack(k_40,n_37) else fail-any)) else caught-fail) in
        {1378}let v_470: bool = not-caught-fail(csi_36) in
        {1379}let v_471: bitstring = (if v_462 then catch-fail((if v_464 then (if v_465 then (if v_467 then (if v_470 then (csi_36,plaintext_28,valid_24) else fail-any) else fail-any) else fail-any) else fail-any)) else caught-fail) in
        {1380}let v_472: bool = (not-caught-fail(v_471) && success?(1-proj-3-tuple(v_471))) in
        {1381}let valid_25: bool = (if v_472 then 3-proj-3-tuple(v_471) else caught-fail) in
        {1382}let plaintext_29: bitstring = (if v_472 then 2-proj-3-tuple(v_471) else caught-fail) in
        {1383}let csi_37: cipherstate = (if v_472 then 1-proj-3-tuple(v_471) else caught-fail) in
        {1384}let ss_66: symmetricstate = (if v_472 then symmetricstatepack(csi_37,ck_69,h_59) else caught-fail) in
        {1385}let v_473: bitstring = (if v_472 then catch-fail(symmetricstateunpack(ss_66)) else caught-fail) in
        {1386}let v_474: bool = (not-caught-fail(v_473) && success?(1-proj-3-tuple(v_473))) in
        {1387}let h_60: bitstring = (if v_474 then 3-proj-3-tuple(v_473) else caught-fail) in
        {1388}let ck_70: key = (if v_474 then 2-proj-3-tuple(v_473) else caught-fail) in
        {1389}let cs_60: cipherstate = (if v_474 then 1-proj-3-tuple(v_473) else caught-fail) in
        {1390}let ssi_20: symmetricstate = (if v_472 then catch-fail((if v_474 then symmetricstatepack(cs_60,ck_70,hash(h_60,ciphertext_20)) else fail-any)) else caught-fail) in
        {1391}let v_475: bool = not-caught-fail(ssi_20) in
        {1392}let v_476: bitstring = (if v_460 then catch-fail((if v_462 then (if v_472 then (if v_475 then (ssi_20,plaintext_29,valid_25) else fail-any) else fail-any) else fail-any)) else caught-fail) in
        {1393}let v_477: bool = (not-caught-fail(v_476) && success?(1-proj-3-tuple(v_476))) in
        {1394}let valid3_2: bool = (if v_477 then 3-proj-3-tuple(v_476) else caught-fail) in
        {1395}let plaintext_30: bitstring = (if v_477 then 2-proj-3-tuple(v_476) else caught-fail) in
        {1396}let ss_67: symmetricstate = (if v_477 then 1-proj-3-tuple(v_476) else caught-fail) in
        {1400}let basis_12: key = (if v_477 then key_m(them_2) else caught-fail) in
        {1401}let public_key_12: key = (if v_477 then catch-fail(dhexp(basis_12,validkey(g))) else caught-fail) in
        {1402}let v_479: bool = not-caught-fail(public_key_12) in
        {1397}let basis_11: key = (if v_477 then key_s(them_2) else caught-fail) in
        {1398}let public_key_11: key = (if v_477 then catch-fail(dhexp(basis_11,validkey(g))) else caught-fail) in
        {1399}let v_478: bool = not-caught-fail(public_key_11) in
        {1355}let rm_14: key = (if v_460 then ne_16 else caught-fail) in
        {1313}let rs_14: key = (if v_443 then ne_15 else caught-fail) in
        {1403}let v_480: bool = (if v_477 then catch-fail(((valid1_7 && (valid2_7 && valid3_2)) && ((rs_14 = getpublickey((if v_478 then keypairpack(validkey(public_key_11),basis_11) else fail-any))) && (rm_14 = getpublickey((if v_479 then keypairpack(validkey(public_key_12),basis_12) else fail-any)))))) else caught-fail) in
        {1404}let hs_32: handshakestate = (if v_480 then handshakestatepack(ss_67,s_13,m_13,e_21,rs_14,rm_14,re_14,psk_11,initiator_9) else caught-fail) in
        {1405}let (hs_33: handshakestate,plaintext_a: bitstring,valid_26: bool) = (if v_421 then (if v_423 then (if v_426 then (if v_443 then (if v_460 then (if v_477 then (if undo-catch-fail(v_480) then (hs_32,plaintext_30,true) else fail-any) else fail-any) else fail-any) else fail-any) else fail-any) else fail-any) else fail-any) in
        {1406}event RecvMsg(me_2,them_2,stagepack_a(sid_3),plaintext_a);
        {1407}insert statestore(me_2,them_2,sid_3,statepack_b(hs_33))
    ) | (
        {1719}get statestore(=me_2,=them_2,=sid_3,statepack_b(hs_34: handshakestate)) in
        {1410}let v_481: bitstring = catch-fail(handshakestateunpack(hs_34)) in
        {1411}let v_482: bool = (not-caught-fail(v_481) && success?(1-proj-9-tuple(v_481))) in
        {1412}let initiator_10: bool = (if v_482 then 9-proj-9-tuple(v_481) else caught-fail) in
        {1413}let psk_12: key = (if v_482 then 8-proj-9-tuple(v_481) else caught-fail) in
        {1414}let re_15: key = (if v_482 then 7-proj-9-tuple(v_481) else caught-fail) in
        {1415}let rm_15: key = (if v_482 then 6-proj-9-tuple(v_481) else caught-fail) in
        {1416}let rs_15: key = (if v_482 then 5-proj-9-tuple(v_481) else caught-fail) in
        {1417}let e_22: keypair = (if v_482 then 4-proj-9-tuple(v_481) else caught-fail) in
        {1418}let m_14: keypair = (if v_482 then 3-proj-9-tuple(v_481) else caught-fail) in
        {1419}let s_14: keypair = (if v_482 then 2-proj-9-tuple(v_481) else caught-fail) in
        {1420}let ss_68: symmetricstate = (if v_482 then 1-proj-9-tuple(v_481) else caught-fail) in
        {1421}let v_483: bitstring = (if v_482 then catch-fail((empty,empty,empty,empty)) else caught-fail) in
        {1422}let v_484: bool = (not-caught-fail(v_483) && success?(1-proj-4-tuple(v_483))) in
        {1423}let ciphertext_21: bitstring = (if v_484 then 4-proj-4-tuple(v_483) else caught-fail) in
        {1424}let nm_11: bitstring = (if v_484 then 3-proj-4-tuple(v_483) else caught-fail) in
        {1425}let ns_11: bitstring = (if v_484 then 2-proj-4-tuple(v_483) else caught-fail) in
        {1426}let ne_17: bitstring = (if v_484 then 1-proj-4-tuple(v_483) else caught-fail) in
        {1427}let basis_13: key = (if v_484 then key_e(me_2,them_2,sid_3) else caught-fail) in
        {1428}let public_key_13: key = (if v_484 then catch-fail(dhexp(basis_13,validkey(g))) else caught-fail) in
        {1429}let v_485: bool = not-caught-fail(public_key_13) in
        {1430}let e_23: keypair = (if v_484 then catch-fail((if v_485 then keypairpack(validkey(public_key_13),basis_13) else fail-any)) else caught-fail) in
        {1431}let v_486: bool = not-caught-fail(e_23) in
        {1432}let ne_18: bitstring = (if v_486 then catch-fail(getpublickey(e_23)) else caught-fail) in
        {1433}let v_487: bool = not-caught-fail(ne_18) in
        {1434}let v_488: bitstring = (if v_487 then catch-fail(symmetricstateunpack(ss_68)) else caught-fail) in
        {1435}let v_489: bool = (not-caught-fail(v_488) && success?(1-proj-3-tuple(v_488))) in
        {1436}let h_61: bitstring = (if v_489 then 3-proj-3-tuple(v_488) else caught-fail) in
        {1437}let ck_71: key = (if v_489 then 2-proj-3-tuple(v_488) else caught-fail) in
        {1438}let cs_61: cipherstate = (if v_489 then 1-proj-3-tuple(v_488) else caught-fail) in
        {1439}let ss_69: symmetricstate = (if v_487 then catch-fail((if v_489 then symmetricstatepack(cs_61,ck_71,hash(h_61,ne_18)) else fail-any)) else caught-fail) in
        {1440}let v_490: bool = not-caught-fail(ss_69) in
        {1441}let v_491: bitstring = (if v_490 then catch-fail(keypairunpack(e_23)) else caught-fail) in
        {1442}let v_492: bool = (not-caught-fail(v_491) && success?(1-proj-2-tuple(v_491))) in
        {1443}let my_private_key_10: key = (if v_492 then 2-proj-2-tuple(v_491) else caught-fail) in
        {1444}let my_public_key_10: key = (if v_492 then 1-proj-2-tuple(v_491) else caught-fail) in
        {1445}let input_key_material_12: key = (if v_490 then catch-fail((if v_492 then dhexp(my_private_key_10,re_15) else fail-any)) else caught-fail) in
        {1446}let v_493: bool = not-caught-fail(input_key_material_12) in
        {1447}let v_494: bitstring = (if v_493 then catch-fail(symmetricstateunpack(ss_69)) else caught-fail) in
        {1448}let v_495: bool = (not-caught-fail(v_494) && success?(1-proj-3-tuple(v_494))) in
        {1449}let h_62: bitstring = (if v_495 then 3-proj-3-tuple(v_494) else caught-fail) in
        {1450}let ck_72: key = (if v_495 then 2-proj-3-tuple(v_494) else caught-fail) in
        {1451}let cs_62: cipherstate = (if v_495 then 1-proj-3-tuple(v_494) else caught-fail) in
        {1454}let output3_12: key = (if v_495 then hmac_hash3(ck_72,input_key_material_12) else caught-fail) in
        {1453}let output2_12: key = (if v_495 then hmac_hash2(ck_72,input_key_material_12) else caught-fail) in
        {1452}let output1_12: key = (if v_495 then hmac_hash1(ck_72,input_key_material_12) else caught-fail) in
        {1455}let v_496: bitstring = (if v_495 then catch-fail((output1_12,output2_12,output3_12)) else caught-fail) in
        {1456}let v_497: bool = (not-caught-fail(v_496) && success?(1-proj-3-tuple(v_496))) in
        {1457}let output_10: key = (if v_497 then 3-proj-3-tuple(v_496) else caught-fail) in
        {1458}let temp_k_10: key = (if v_497 then 2-proj-3-tuple(v_496) else caught-fail) in
        {1459}let ck_73: key = (if v_497 then 1-proj-3-tuple(v_496) else caught-fail) in
        {1460}let ss_70: symmetricstate = (if v_490 then catch-fail((if v_493 then (if v_495 then (if v_497 then symmetricstatepack(cipherstatepack(temp_k_10,minnonce),ck_73,h_62) else fail-any) else fail-any) else fail-any)) else caught-fail) in
        {1461}let v_498: bool = not-caught-fail(ss_70) in
        {1462}let v_499: bitstring = (if v_498 then catch-fail(keypairunpack(e_23)) else caught-fail) in
        {1463}let v_500: bool = (not-caught-fail(v_499) && success?(1-proj-2-tuple(v_499))) in
        {1464}let my_private_key_11: key = (if v_500 then 2-proj-2-tuple(v_499) else caught-fail) in
        {1465}let my_public_key_11: key = (if v_500 then 1-proj-2-tuple(v_499) else caught-fail) in
        {1466}let input_key_material_13: key = (if v_498 then catch-fail((if v_500 then dhexp(my_private_key_11,rs_15) else fail-any)) else caught-fail) in
        {1467}let v_501: bool = not-caught-fail(input_key_material_13) in
        {1468}let v_502: bitstring = (if v_501 then catch-fail(symmetricstateunpack(ss_70)) else caught-fail) in
        {1469}let v_503: bool = (not-caught-fail(v_502) && success?(1-proj-3-tuple(v_502))) in
        {1470}let h_63: bitstring = (if v_503 then 3-proj-3-tuple(v_502) else caught-fail) in
        {1471}let ck_74: key = (if v_503 then 2-proj-3-tuple(v_502) else caught-fail) in
        {1472}let cs_63: cipherstate = (if v_503 then 1-proj-3-tuple(v_502) else caught-fail) in
        {1475}let output3_13: key = (if v_503 then hmac_hash3(ck_74,input_key_material_13) else caught-fail) in
        {1474}let output2_13: key = (if v_503 then hmac_hash2(ck_74,input_key_material_13) else caught-fail) in
        {1473}let output1_13: key = (if v_503 then hmac_hash1(ck_74,input_key_material_13) else caught-fail) in
        {1476}let v_504: bitstring = (if v_503 then catch-fail((output1_13,output2_13,output3_13)) else caught-fail) in
        {1477}let v_505: bool = (not-caught-fail(v_504) && success?(1-proj-3-tuple(v_504))) in
        {1478}let output_11: key = (if v_505 then 3-proj-3-tuple(v_504) else caught-fail) in
        {1479}let temp_k_11: key = (if v_505 then 2-proj-3-tuple(v_504) else caught-fail) in
        {1480}let ck_75: key = (if v_505 then 1-proj-3-tuple(v_504) else caught-fail) in
        {1481}let ss_71: symmetricstate = (if v_498 then catch-fail((if v_501 then (if v_503 then (if v_505 then symmetricstatepack(cipherstatepack(temp_k_11,minnonce),ck_75,h_63) else fail-any) else fail-any) else fail-any)) else caught-fail) in
        {1482}let v_506: bool = not-caught-fail(ss_71) in
        {1483}let v_507: bitstring = (if v_506 then catch-fail(keypairunpack(e_23)) else caught-fail) in
        {1484}let v_508: bool = (not-caught-fail(v_507) && success?(1-proj-2-tuple(v_507))) in
        {1485}let my_private_key_12: key = (if v_508 then 2-proj-2-tuple(v_507) else caught-fail) in
        {1486}let my_public_key_12: key = (if v_508 then 1-proj-2-tuple(v_507) else caught-fail) in
        {1487}let input_key_material_14: key = (if v_506 then catch-fail((if v_508 then dhexp(my_private_key_12,rm_15) else fail-any)) else caught-fail) in
        {1488}let v_509: bool = not-caught-fail(input_key_material_14) in
        {1489}let v_510: bitstring = (if v_509 then catch-fail(symmetricstateunpack(ss_71)) else caught-fail) in
        {1490}let v_511: bool = (not-caught-fail(v_510) && success?(1-proj-3-tuple(v_510))) in
        {1491}let h_64: bitstring = (if v_511 then 3-proj-3-tuple(v_510) else caught-fail) in
        {1492}let ck_76: key = (if v_511 then 2-proj-3-tuple(v_510) else caught-fail) in
        {1493}let cs_64: cipherstate = (if v_511 then 1-proj-3-tuple(v_510) else caught-fail) in
        {1496}let output3_14: key = (if v_511 then hmac_hash3(ck_76,input_key_material_14) else caught-fail) in
        {1495}let output2_14: key = (if v_511 then hmac_hash2(ck_76,input_key_material_14) else caught-fail) in
        {1494}let output1_14: key = (if v_511 then hmac_hash1(ck_76,input_key_material_14) else caught-fail) in
        {1497}let v_512: bitstring = (if v_511 then catch-fail((output1_14,output2_14,output3_14)) else caught-fail) in
        {1498}let v_513: bool = (not-caught-fail(v_512) && success?(1-proj-3-tuple(v_512))) in
        {1499}let output_12: key = (if v_513 then 3-proj-3-tuple(v_512) else caught-fail) in
        {1500}let temp_k_12: key = (if v_513 then 2-proj-3-tuple(v_512) else caught-fail) in
        {1501}let ck_77: key = (if v_513 then 1-proj-3-tuple(v_512) else caught-fail) in
        {1502}let ss_72: symmetricstate = (if v_506 then catch-fail((if v_509 then (if v_511 then (if v_513 then symmetricstatepack(cipherstatepack(temp_k_12,minnonce),ck_77,h_64) else fail-any) else fail-any) else fail-any)) else caught-fail) in
        {1503}let v_514: bool = not-caught-fail(ss_72) in
        {1504}let basis_14: key = (if v_514 then key_s(me_2) else caught-fail) in
        {1505}let public_key_14: key = (if v_514 then catch-fail(dhexp(basis_14,validkey(g))) else caught-fail) in
        {1506}let v_515: bool = not-caught-fail(public_key_14) in
        {1507}let s_15: keypair = (if v_514 then catch-fail((if v_515 then keypairpack(validkey(public_key_14),basis_14) else fail-any)) else caught-fail) in
        {1508}let v_516: bool = not-caught-fail(s_15) in
        {1509}let plaintext_31: bitstring = (if v_516 then catch-fail(getpublickey(s_15)) else caught-fail) in
        {1510}let v_517: bool = not-caught-fail(plaintext_31) in
        {1511}let v_518: bitstring = (if v_517 then catch-fail(symmetricstateunpack(ss_72)) else caught-fail) in
        {1512}let v_519: bool = (not-caught-fail(v_518) && success?(1-proj-3-tuple(v_518))) in
        {1513}let h_65: bitstring = (if v_519 then 3-proj-3-tuple(v_518) else caught-fail) in
        {1514}let ck_78: key = (if v_519 then 2-proj-3-tuple(v_518) else caught-fail) in
        {1515}let cs_65: cipherstate = (if v_519 then 1-proj-3-tuple(v_518) else caught-fail) in
        {1516}let v_520: bitstring = (if v_519 then catch-fail(cipherstateunpack(cs_65)) else caught-fail) in
        {1517}let v_521: bool = (not-caught-fail(v_520) && success?(1-proj-2-tuple(v_520))) in
        {1518}let n_38: nonce = (if v_521 then 2-proj-2-tuple(v_520) else caught-fail) in
        {1519}let k_41: key = (if v_521 then 1-proj-2-tuple(v_520) else caught-fail) in
        {1522}let v_522: bitstring = (if v_521 then catch-fail(cipherstateunpack(cs_65)) else caught-fail) in
        {1523}let v_523: bool = (not-caught-fail(v_522) && success?(1-proj-2-tuple(v_522))) in
        {1524}let o_19: nonce = (if v_523 then 2-proj-2-tuple(v_522) else caught-fail) in
        {1525}let k_42: key = (if v_523 then 1-proj-2-tuple(v_522) else caught-fail) in
        {1521}let n_39: nonce = (if v_521 then increment_nonce(n_38) else caught-fail) in
        {1526}let csi_38: cipherstate = (if v_521 then catch-fail((if v_523 then cipherstatepack(k_42,n_39) else fail-any)) else caught-fail) in
        {1527}let v_524: bool = not-caught-fail(csi_38) in
        {1520}let e_24: bitstring = (if v_521 then encrypt(k_41,n_38,h_65,plaintext_31) else caught-fail) in
        {1528}let v_525: bitstring = (if v_519 then catch-fail((if v_521 then (if v_524 then (csi_38,e_24) else fail-any) else fail-any)) else caught-fail) in
        {1529}let v_526: bool = (not-caught-fail(v_525) && success?(1-proj-2-tuple(v_525))) in
        {1530}let ciphertext_22: bitstring = (if v_526 then 2-proj-2-tuple(v_525) else caught-fail) in
        {1531}let csi_39: cipherstate = (if v_526 then 1-proj-2-tuple(v_525) else caught-fail) in
        {1532}let ss_73: symmetricstate = (if v_526 then symmetricstatepack(csi_39,ck_78,h_65) else caught-fail) in
        {1533}let v_527: bitstring = (if v_526 then catch-fail(symmetricstateunpack(ss_73)) else caught-fail) in
        {1534}let v_528: bool = (not-caught-fail(v_527) && success?(1-proj-3-tuple(v_527))) in
        {1535}let h_66: bitstring = (if v_528 then 3-proj-3-tuple(v_527) else caught-fail) in
        {1536}let ck_79: key = (if v_528 then 2-proj-3-tuple(v_527) else caught-fail) in
        {1537}let cs_66: cipherstate = (if v_528 then 1-proj-3-tuple(v_527) else caught-fail) in
        {1538}let ssi_21: symmetricstate = (if v_526 then catch-fail((if v_528 then symmetricstatepack(cs_66,ck_79,hash(h_66,ciphertext_22)) else fail-any)) else caught-fail) in
        {1539}let v_529: bool = not-caught-fail(ssi_21) in
        {1540}let v_530: bitstring = (if v_516 then catch-fail((if v_517 then (if v_519 then (if v_526 then (if v_529 then (ssi_21,ciphertext_22) else fail-any) else fail-any) else fail-any) else fail-any)) else caught-fail) in
        {1541}let v_531: bool = (not-caught-fail(v_530) && success?(1-proj-2-tuple(v_530))) in
        {1542}let ns_12: bitstring = (if v_531 then 2-proj-2-tuple(v_530) else caught-fail) in
        {1543}let ss_74: symmetricstate = (if v_531 then 1-proj-2-tuple(v_530) else caught-fail) in
        {1544}let basis_15: key = (if v_531 then key_m(me_2) else caught-fail) in
        {1545}let public_key_15: key = (if v_531 then catch-fail(dhexp(basis_15,validkey(g))) else caught-fail) in
        {1546}let v_532: bool = not-caught-fail(public_key_15) in
        {1547}let m_15: keypair = (if v_531 then catch-fail((if v_532 then keypairpack(validkey(public_key_15),basis_15) else fail-any)) else caught-fail) in
        {1548}let v_533: bool = not-caught-fail(m_15) in
        {1549}let plaintext_32: bitstring = (if v_533 then catch-fail(getpublickey(m_15)) else caught-fail) in
        {1550}let v_534: bool = not-caught-fail(plaintext_32) in
        {1551}let v_535: bitstring = (if v_534 then catch-fail(symmetricstateunpack(ss_74)) else caught-fail) in
        {1552}let v_536: bool = (not-caught-fail(v_535) && success?(1-proj-3-tuple(v_535))) in
        {1553}let h_67: bitstring = (if v_536 then 3-proj-3-tuple(v_535) else caught-fail) in
        {1554}let ck_80: key = (if v_536 then 2-proj-3-tuple(v_535) else caught-fail) in
        {1555}let cs_67: cipherstate = (if v_536 then 1-proj-3-tuple(v_535) else caught-fail) in
        {1556}let v_537: bitstring = (if v_536 then catch-fail(cipherstateunpack(cs_67)) else caught-fail) in
        {1557}let v_538: bool = (not-caught-fail(v_537) && success?(1-proj-2-tuple(v_537))) in
        {1558}let n_40: nonce = (if v_538 then 2-proj-2-tuple(v_537) else caught-fail) in
        {1559}let k_43: key = (if v_538 then 1-proj-2-tuple(v_537) else caught-fail) in
        {1562}let v_539: bitstring = (if v_538 then catch-fail(cipherstateunpack(cs_67)) else caught-fail) in
        {1563}let v_540: bool = (not-caught-fail(v_539) && success?(1-proj-2-tuple(v_539))) in
        {1564}let o_20: nonce = (if v_540 then 2-proj-2-tuple(v_539) else caught-fail) in
        {1565}let k_44: key = (if v_540 then 1-proj-2-tuple(v_539) else caught-fail) in
        {1561}let n_41: nonce = (if v_538 then increment_nonce(n_40) else caught-fail) in
        {1566}let csi_40: cipherstate = (if v_538 then catch-fail((if v_540 then cipherstatepack(k_44,n_41) else fail-any)) else caught-fail) in
        {1567}let v_541: bool = not-caught-fail(csi_40) in
        {1560}let e_25: bitstring = (if v_538 then encrypt(k_43,n_40,h_67,plaintext_32) else caught-fail) in
        {1568}let v_542: bitstring = (if v_536 then catch-fail((if v_538 then (if v_541 then (csi_40,e_25) else fail-any) else fail-any)) else caught-fail) in
        {1569}let v_543: bool = (not-caught-fail(v_542) && success?(1-proj-2-tuple(v_542))) in
        {1570}let ciphertext_23: bitstring = (if v_543 then 2-proj-2-tuple(v_542) else caught-fail) in
        {1571}let csi_41: cipherstate = (if v_543 then 1-proj-2-tuple(v_542) else caught-fail) in
        {1572}let ss_75: symmetricstate = (if v_543 then symmetricstatepack(csi_41,ck_80,h_67) else caught-fail) in
        {1573}let v_544: bitstring = (if v_543 then catch-fail(symmetricstateunpack(ss_75)) else caught-fail) in
        {1574}let v_545: bool = (not-caught-fail(v_544) && success?(1-proj-3-tuple(v_544))) in
        {1575}let h_68: bitstring = (if v_545 then 3-proj-3-tuple(v_544) else caught-fail) in
        {1576}let ck_81: key = (if v_545 then 2-proj-3-tuple(v_544) else caught-fail) in
        {1577}let cs_68: cipherstate = (if v_545 then 1-proj-3-tuple(v_544) else caught-fail) in
        {1578}let ssi_22: symmetricstate = (if v_543 then catch-fail((if v_545 then symmetricstatepack(cs_68,ck_81,hash(h_68,ciphertext_23)) else fail-any)) else caught-fail) in
        {1579}let v_546: bool = not-caught-fail(ssi_22) in
        {1580}let v_547: bitstring = (if v_533 then catch-fail((if v_534 then (if v_536 then (if v_543 then (if v_546 then (ssi_22,ciphertext_23) else fail-any) else fail-any) else fail-any) else fail-any)) else caught-fail) in
        {1581}let v_548: bool = (not-caught-fail(v_547) && success?(1-proj-2-tuple(v_547))) in
        {1582}let nm_12: bitstring = (if v_548 then 2-proj-2-tuple(v_547) else caught-fail) in
        {1583}let ss_76: symmetricstate = (if v_548 then 1-proj-2-tuple(v_547) else caught-fail) in
        {1584}let v_549: bitstring = (if v_548 then catch-fail(keypairunpack(s_15)) else caught-fail) in
        {1585}let v_550: bool = (not-caught-fail(v_549) && success?(1-proj-2-tuple(v_549))) in
        {1586}let my_private_key_13: key = (if v_550 then 2-proj-2-tuple(v_549) else caught-fail) in
        {1587}let my_public_key_13: key = (if v_550 then 1-proj-2-tuple(v_549) else caught-fail) in
        {1588}let input_key_material_15: key = (if v_548 then catch-fail((if v_550 then dhexp(my_private_key_13,re_15) else fail-any)) else caught-fail) in
        {1589}let v_551: bool = not-caught-fail(input_key_material_15) in
        {1590}let v_552: bitstring = (if v_551 then catch-fail(symmetricstateunpack(ss_76)) else caught-fail) in
        {1591}let v_553: bool = (not-caught-fail(v_552) && success?(1-proj-3-tuple(v_552))) in
        {1592}let h_69: bitstring = (if v_553 then 3-proj-3-tuple(v_552) else caught-fail) in
        {1593}let ck_82: key = (if v_553 then 2-proj-3-tuple(v_552) else caught-fail) in
        {1594}let cs_69: cipherstate = (if v_553 then 1-proj-3-tuple(v_552) else caught-fail) in
        {1597}let output3_15: key = (if v_553 then hmac_hash3(ck_82,input_key_material_15) else caught-fail) in
        {1596}let output2_15: key = (if v_553 then hmac_hash2(ck_82,input_key_material_15) else caught-fail) in
        {1595}let output1_15: key = (if v_553 then hmac_hash1(ck_82,input_key_material_15) else caught-fail) in
        {1598}let v_554: bitstring = (if v_553 then catch-fail((output1_15,output2_15,output3_15)) else caught-fail) in
        {1599}let v_555: bool = (not-caught-fail(v_554) && success?(1-proj-3-tuple(v_554))) in
        {1600}let output_13: key = (if v_555 then 3-proj-3-tuple(v_554) else caught-fail) in
        {1601}let temp_k_13: key = (if v_555 then 2-proj-3-tuple(v_554) else caught-fail) in
        {1602}let ck_83: key = (if v_555 then 1-proj-3-tuple(v_554) else caught-fail) in
        {1603}let ss_77: symmetricstate = (if v_548 then catch-fail((if v_551 then (if v_553 then (if v_555 then symmetricstatepack(cipherstatepack(temp_k_13,minnonce),ck_83,h_69) else fail-any) else fail-any) else fail-any)) else caught-fail) in
        {1604}let v_556: bool = not-caught-fail(ss_77) in
        {1605}let v_557: bitstring = (if v_556 then catch-fail(symmetricstateunpack(ss_77)) else caught-fail) in
        {1606}let v_558: bool = (not-caught-fail(v_557) && success?(1-proj-3-tuple(v_557))) in
        {1607}let h_70: bitstring = (if v_558 then 3-proj-3-tuple(v_557) else caught-fail) in
        {1608}let ck_84: key = (if v_558 then 2-proj-3-tuple(v_557) else caught-fail) in
        {1609}let cs_70: cipherstate = (if v_558 then 1-proj-3-tuple(v_557) else caught-fail) in
        {1610}let v_559: bitstring = (if v_558 then catch-fail(cipherstateunpack(cs_70)) else caught-fail) in
        {1611}let v_560: bool = (not-caught-fail(v_559) && success?(1-proj-2-tuple(v_559))) in
        {1612}let n_42: nonce = (if v_560 then 2-proj-2-tuple(v_559) else caught-fail) in
        {1613}let k_45: key = (if v_560 then 1-proj-2-tuple(v_559) else caught-fail) in
        {1616}let v_561: bitstring = (if v_560 then catch-fail(cipherstateunpack(cs_70)) else caught-fail) in
        {1617}let v_562: bool = (not-caught-fail(v_561) && success?(1-proj-2-tuple(v_561))) in
        {1618}let o_21: nonce = (if v_562 then 2-proj-2-tuple(v_561) else caught-fail) in
        {1619}let k_46: key = (if v_562 then 1-proj-2-tuple(v_561) else caught-fail) in
        {1615}let n_43: nonce = (if v_560 then increment_nonce(n_42) else caught-fail) in
        {1620}let csi_42: cipherstate = (if v_560 then catch-fail((if v_562 then cipherstatepack(k_46,n_43) else fail-any)) else caught-fail) in
        {1621}let v_563: bool = not-caught-fail(csi_42) in
        {1409}let payload_4: bitstring = msg_b(me_2,them_2,sid_3) in
        {1614}let e_26: bitstring = (if v_560 then encrypt(k_45,n_42,h_70,payload_4) else caught-fail) in
        {1622}let v_564: bitstring = (if v_558 then catch-fail((if v_560 then (if v_563 then (csi_42,e_26) else fail-any) else fail-any)) else caught-fail) in
        {1623}let v_565: bool = (not-caught-fail(v_564) && success?(1-proj-2-tuple(v_564))) in
        {1624}let ciphertext_24: bitstring = (if v_565 then 2-proj-2-tuple(v_564) else caught-fail) in
        {1625}let csi_43: cipherstate = (if v_565 then 1-proj-2-tuple(v_564) else caught-fail) in
        {1626}let ss_78: symmetricstate = (if v_565 then symmetricstatepack(csi_43,ck_84,h_70) else caught-fail) in
        {1627}let v_566: bitstring = (if v_565 then catch-fail(symmetricstateunpack(ss_78)) else caught-fail) in
        {1628}let v_567: bool = (not-caught-fail(v_566) && success?(1-proj-3-tuple(v_566))) in
        {1629}let h_71: bitstring = (if v_567 then 3-proj-3-tuple(v_566) else caught-fail) in
        {1630}let ck_85: key = (if v_567 then 2-proj-3-tuple(v_566) else caught-fail) in
        {1631}let cs_71: cipherstate = (if v_567 then 1-proj-3-tuple(v_566) else caught-fail) in
        {1632}let ssi_23: symmetricstate = (if v_565 then catch-fail((if v_567 then symmetricstatepack(cs_71,ck_85,hash(h_71,ciphertext_24)) else fail-any)) else caught-fail) in
        {1633}let v_568: bool = not-caught-fail(ssi_23) in
        {1634}let v_569: bitstring = (if v_556 then catch-fail((if v_558 then (if v_565 then (if v_568 then (ssi_23,ciphertext_24) else fail-any) else fail-any) else fail-any)) else caught-fail) in
        {1635}let v_570: bool = (not-caught-fail(v_569) && success?(1-proj-2-tuple(v_569))) in
        {1636}let ciphertext_25: bitstring = (if v_570 then 2-proj-2-tuple(v_569) else caught-fail) in
        {1637}let ss_79: symmetricstate = (if v_570 then 1-proj-2-tuple(v_569) else caught-fail) in
        {1638}let v_571: bitstring = (if v_570 then catch-fail(keypairunpack(m_15)) else caught-fail) in
        {1639}let v_572: bool = (not-caught-fail(v_571) && success?(1-proj-2-tuple(v_571))) in
        {1640}let my_private_key_14: key = (if v_572 then 2-proj-2-tuple(v_571) else caught-fail) in
        {1641}let my_public_key_14: key = (if v_572 then 1-proj-2-tuple(v_571) else caught-fail) in
        {1642}let input_key_material_16: key = (if v_570 then catch-fail((if v_572 then dhexp(my_private_key_14,re_15) else fail-any)) else caught-fail) in
        {1643}let v_573: bool = not-caught-fail(input_key_material_16) in
        {1644}let v_574: bitstring = (if v_573 then catch-fail(symmetricstateunpack(ss_79)) else caught-fail) in
        {1645}let v_575: bool = (not-caught-fail(v_574) && success?(1-proj-3-tuple(v_574))) in
        {1646}let h_72: bitstring = (if v_575 then 3-proj-3-tuple(v_574) else caught-fail) in
        {1647}let ck_86: key = (if v_575 then 2-proj-3-tuple(v_574) else caught-fail) in
        {1648}let cs_72: cipherstate = (if v_575 then 1-proj-3-tuple(v_574) else caught-fail) in
        {1651}let output3_16: key = (if v_575 then hmac_hash3(ck_86,input_key_material_16) else caught-fail) in
        {1650}let output2_16: key = (if v_575 then hmac_hash2(ck_86,input_key_material_16) else caught-fail) in
        {1649}let output1_16: key = (if v_575 then hmac_hash1(ck_86,input_key_material_16) else caught-fail) in
        {1652}let v_576: bitstring = (if v_575 then catch-fail((output1_16,output2_16,output3_16)) else caught-fail) in
        {1653}let v_577: bool = (not-caught-fail(v_576) && success?(1-proj-3-tuple(v_576))) in
        {1654}let output_14: key = (if v_577 then 3-proj-3-tuple(v_576) else caught-fail) in
        {1655}let temp_k_14: key = (if v_577 then 2-proj-3-tuple(v_576) else caught-fail) in
        {1656}let ck_87: key = (if v_577 then 1-proj-3-tuple(v_576) else caught-fail) in
        {1657}let ss_80: symmetricstate = (if v_570 then catch-fail((if v_573 then (if v_575 then (if v_577 then symmetricstatepack(cipherstatepack(temp_k_14,minnonce),ck_87,h_72) else fail-any) else fail-any) else fail-any)) else caught-fail) in
        {1658}let v_578: bool = not-caught-fail(ss_80) in
        {1659}let v_579: bitstring = (if v_578 then catch-fail(symmetricstateunpack(ss_80)) else caught-fail) in
        {1660}let v_580: bool = (not-caught-fail(v_579) && success?(1-proj-3-tuple(v_579))) in
        {1661}let h_73: bitstring = (if v_580 then 3-proj-3-tuple(v_579) else caught-fail) in
        {1662}let ck_88: key = (if v_580 then 2-proj-3-tuple(v_579) else caught-fail) in
        {1663}let cs_73: cipherstate = (if v_580 then 1-proj-3-tuple(v_579) else caught-fail) in
        {1664}let v_581: bitstring = (if v_580 then catch-fail(cipherstateunpack(cs_73)) else caught-fail) in
        {1665}let v_582: bool = (not-caught-fail(v_581) && success?(1-proj-2-tuple(v_581))) in
        {1666}let n_44: nonce = (if v_582 then 2-proj-2-tuple(v_581) else caught-fail) in
        {1667}let k_47: key = (if v_582 then 1-proj-2-tuple(v_581) else caught-fail) in
        {1670}let v_583: bitstring = (if v_582 then catch-fail(cipherstateunpack(cs_73)) else caught-fail) in
        {1671}let v_584: bool = (not-caught-fail(v_583) && success?(1-proj-2-tuple(v_583))) in
        {1672}let o_22: nonce = (if v_584 then 2-proj-2-tuple(v_583) else caught-fail) in
        {1673}let k_48: key = (if v_584 then 1-proj-2-tuple(v_583) else caught-fail) in
        {1669}let n_45: nonce = (if v_582 then increment_nonce(n_44) else caught-fail) in
        {1674}let csi_44: cipherstate = (if v_582 then catch-fail((if v_584 then cipherstatepack(k_48,n_45) else fail-any)) else caught-fail) in
        {1675}let v_585: bool = not-caught-fail(csi_44) in
        {1668}let e_27: bitstring = (if v_582 then encrypt(k_47,n_44,h_73,payload_4) else caught-fail) in
        {1676}let v_586: bitstring = (if v_580 then catch-fail((if v_582 then (if v_585 then (csi_44,e_27) else fail-any) else fail-any)) else caught-fail) in
        {1677}let v_587: bool = (not-caught-fail(v_586) && success?(1-proj-2-tuple(v_586))) in
        {1678}let ciphertext_26: bitstring = (if v_587 then 2-proj-2-tuple(v_586) else caught-fail) in
        {1679}let csi_45: cipherstate = (if v_587 then 1-proj-2-tuple(v_586) else caught-fail) in
        {1680}let ss_81: symmetricstate = (if v_587 then symmetricstatepack(csi_45,ck_88,h_73) else caught-fail) in
        {1681}let v_588: bitstring = (if v_587 then catch-fail(symmetricstateunpack(ss_81)) else caught-fail) in
        {1682}let v_589: bool = (not-caught-fail(v_588) && success?(1-proj-3-tuple(v_588))) in
        {1683}let h_74: bitstring = (if v_589 then 3-proj-3-tuple(v_588) else caught-fail) in
        {1684}let ck_89: key = (if v_589 then 2-proj-3-tuple(v_588) else caught-fail) in
        {1685}let cs_74: cipherstate = (if v_589 then 1-proj-3-tuple(v_588) else caught-fail) in
        {1686}let ssi_24: symmetricstate = (if v_587 then catch-fail((if v_589 then symmetricstatepack(cs_74,ck_89,hash(h_74,ciphertext_26)) else fail-any)) else caught-fail) in
        {1687}let v_590: bool = not-caught-fail(ssi_24) in
        {1688}let v_591: bitstring = (if v_578 then catch-fail((if v_580 then (if v_587 then (if v_590 then (ssi_24,ciphertext_26) else fail-any) else fail-any) else fail-any)) else caught-fail) in
        {1689}let v_592: bool = (not-caught-fail(v_591) && success?(1-proj-2-tuple(v_591))) in
        {1690}let ciphertext_27: bitstring = (if v_592 then 2-proj-2-tuple(v_591) else caught-fail) in
        {1691}let ss_82: symmetricstate = (if v_592 then 1-proj-2-tuple(v_591) else caught-fail) in
        {1694}let v_593: bitstring = (if v_592 then catch-fail(symmetricstateunpack(ss_82)) else caught-fail) in
        {1695}let v_594: bool = (not-caught-fail(v_593) && success?(1-proj-3-tuple(v_593))) in
        {1696}let h_75: bitstring = (if v_594 then 3-proj-3-tuple(v_593) else caught-fail) in
        {1697}let ck_90: key = (if v_594 then 2-proj-3-tuple(v_593) else caught-fail) in
        {1698}let cs_75: cipherstate = (if v_594 then 1-proj-3-tuple(v_593) else caught-fail) in
        {1699}let input_key_material_17: key = (if v_594 then zero else caught-fail) in
        {1702}let output3_17: key = (if v_594 then hmac_hash3(ck_90,input_key_material_17) else caught-fail) in
        {1701}let output2_17: key = (if v_594 then hmac_hash2(ck_90,input_key_material_17) else caught-fail) in
        {1700}let output1_17: key = (if v_594 then hmac_hash1(ck_90,input_key_material_17) else caught-fail) in
        {1703}let v_595: bitstring = (if v_594 then catch-fail((output1_17,output2_17,output3_17)) else caught-fail) in
        {1704}let v_596: bool = (not-caught-fail(v_595) && success?(1-proj-3-tuple(v_595))) in
        {1705}let temp_k3_2: key = (if v_596 then 3-proj-3-tuple(v_595) else caught-fail) in
        {1706}let temp_k2_2: key = (if v_596 then 2-proj-3-tuple(v_595) else caught-fail) in
        {1707}let temp_k1_2: key = (if v_596 then 1-proj-3-tuple(v_595) else caught-fail) in
        {1709}let cs2_10: cipherstate = (if v_596 then cipherstatepack(temp_k2_2,minnonce) else caught-fail) in
        {1708}let cs1_10: cipherstate = (if v_596 then cipherstatepack(temp_k1_2,minnonce) else caught-fail) in
        {1710}let v_597: bitstring = (if v_592 then catch-fail((if v_594 then (if v_596 then (ss_82,cs1_10,cs2_10) else fail-any) else fail-any)) else caught-fail) in
        {1711}let v_598: bool = (not-caught-fail(v_597) && success?(1-proj-3-tuple(v_597))) in
        {1712}let cs2_11: cipherstate = (if v_598 then 3-proj-3-tuple(v_597) else caught-fail) in
        {1713}let cs1_11: cipherstate = (if v_598 then 2-proj-3-tuple(v_597) else caught-fail) in
        {1714}let ssi_25: symmetricstate = (if v_598 then 1-proj-3-tuple(v_597) else caught-fail) in
        {1693}let message_buffer_4: bitstring = (if v_592 then concat4(ne_18,ns_12,nm_12,ciphertext_27) else caught-fail) in
        {1692}let hs_35: handshakestate = (if v_592 then handshakestatepack(ss_82,s_15,m_15,e_23,rs_15,rm_15,re_15,psk_12,initiator_10) else caught-fail) in
        {1715}let (hs_36: handshakestate,message_b_2: bitstring,cs1_12: cipherstate,cs2_12: cipherstate) = (if v_482 then (if v_484 then (if v_486 then (if v_487 then (if v_490 then (if v_498 then (if v_506 then (if v_514 then (if v_516 then (if v_531 then (if v_533 then (if v_548 then (if v_556 then (if v_570 then (if v_578 then (if v_592 then (if v_598 then (hs_35,message_buffer_4,cs1_11,cs2_11) else fail-any) else fail-any) else fail-any) else fail-any) else fail-any) else fail-any) else fail-any) else fail-any) else fail-any) else fail-any) else fail-any) else fail-any) else fail-any) else fail-any) else fail-any) else fail-any) else fail-any) in
        {1716}event SendMsg(me_2,them_2,stagepack_b(sid_3),msg_b(me_2,them_2,sid_3));
        {1717}insert statestore(me_2,them_2,sid_3,statepack_c(hs_36,cs1_12,cs2_12));
        {1718}out(pub, message_b_2)
    ) | (
        {1720}!
        {1787}get statestore(=me_2,=them_2,=sid_3,statepack_c(hs_37: handshakestate,cs1_13: cipherstate,cs2_13: cipherstate)) in
        {1721}let hs_38: handshakestate = handshakestatesetcs(hs_37,cs1_13) in
        {1722}in(pub, message_c_2: bitstring);
        {1723}let v_599: bitstring = catch-fail(handshakestateunpack(hs_38)) in
        {1724}let v_600: bool = (not-caught-fail(v_599) && success?(1-proj-9-tuple(v_599))) in
        {1725}let initiator_11: bool = (if v_600 then 9-proj-9-tuple(v_599) else caught-fail) in
        {1726}let psk_13: key = (if v_600 then 8-proj-9-tuple(v_599) else caught-fail) in
        {1727}let re_16: key = (if v_600 then 7-proj-9-tuple(v_599) else caught-fail) in
        {1728}let rm_16: key = (if v_600 then 6-proj-9-tuple(v_599) else caught-fail) in
        {1729}let rs_16: key = (if v_600 then 5-proj-9-tuple(v_599) else caught-fail) in
        {1730}let e_28: keypair = (if v_600 then 4-proj-9-tuple(v_599) else caught-fail) in
        {1731}let m_16: keypair = (if v_600 then 3-proj-9-tuple(v_599) else caught-fail) in
        {1732}let s_16: keypair = (if v_600 then 2-proj-9-tuple(v_599) else caught-fail) in
        {1733}let ss_83: symmetricstate = (if v_600 then 1-proj-9-tuple(v_599) else caught-fail) in
        {1734}let v_601: bitstring = (if v_600 then catch-fail(deconcat4(message_c_2)) else caught-fail) in
        {1735}let v_602: bool = (not-caught-fail(v_601) && success?(1-proj-4-tuple(v_601))) in
        {1736}let ciphertext_28: bitstring = (if v_602 then 4-proj-4-tuple(v_601) else caught-fail) in
        {1737}let nm_13: bitstring = (if v_602 then 3-proj-4-tuple(v_601) else caught-fail) in
        {1738}let ns_13: bitstring = (if v_602 then 2-proj-4-tuple(v_601) else caught-fail) in
        {1739}let ne_19: bitstring = (if v_602 then 1-proj-4-tuple(v_601) else caught-fail) in
        {1741}let v_603: bitstring = (if v_602 then catch-fail(symmetricstateunpack(ss_83)) else caught-fail) in
        {1742}let v_604: bool = (not-caught-fail(v_603) && success?(1-proj-3-tuple(v_603))) in
        {1743}let h_76: bitstring = (if v_604 then 3-proj-3-tuple(v_603) else caught-fail) in
        {1744}let ck_91: key = (if v_604 then 2-proj-3-tuple(v_603) else caught-fail) in
        {1745}let cs_76: cipherstate = (if v_604 then 1-proj-3-tuple(v_603) else caught-fail) in
        {1746}let v_605: bitstring = (if v_604 then catch-fail(cipherstateunpack(cs_76)) else caught-fail) in
        {1747}let v_606: bool = (not-caught-fail(v_605) && success?(1-proj-2-tuple(v_605))) in
        {1748}let n_46: nonce = (if v_606 then 2-proj-2-tuple(v_605) else caught-fail) in
        {1749}let k_49: key = (if v_606 then 1-proj-2-tuple(v_605) else caught-fail) in
        {1750}let d_11: aead = (if v_606 then catch-fail(decrypt(k_49,n_46,h_76,ciphertext_28)) else caught-fail) in
        {1751}let v_607: bool = not-caught-fail(d_11) in
        {1752}let v_608: bitstring = (if v_607 then catch-fail(aeadunpack(d_11)) else caught-fail) in
        {1753}let v_609: bool = (not-caught-fail(v_608) && success?(1-proj-3-tuple(v_608))) in
        {1754}let plaintext_33: bitstring = (if v_609 then 3-proj-3-tuple(v_608) else caught-fail) in
        {1755}let adi_11: bitstring = (if v_609 then 2-proj-3-tuple(v_608) else caught-fail) in
        {1756}let valid_27: bool = (if v_609 then 1-proj-3-tuple(v_608) else caught-fail) in
        {1758}let v_610: bitstring = (if v_609 then catch-fail(cipherstateunpack(cs_76)) else caught-fail) in
        {1759}let v_611: bool = (not-caught-fail(v_610) && success?(1-proj-2-tuple(v_610))) in
        {1760}let o_23: nonce = (if v_611 then 2-proj-2-tuple(v_610) else caught-fail) in
        {1761}let k_50: key = (if v_611 then 1-proj-2-tuple(v_610) else caught-fail) in
        {1757}let n_47: nonce = (if v_609 then increment_nonce(n_46) else caught-fail) in
        {1762}let csi_46: cipherstate = (if v_609 then catch-fail((if v_611 then cipherstatepack(k_50,n_47) else fail-any)) else caught-fail) in
        {1763}let v_612: bool = not-caught-fail(csi_46) in
        {1764}let v_613: bitstring = (if v_604 then catch-fail((if v_606 then (if v_607 then (if v_609 then (if v_612 then (csi_46,plaintext_33,valid_27) else fail-any) else fail-any) else fail-any) else fail-any)) else caught-fail) in
        {1765}let v_614: bool = (not-caught-fail(v_613) && success?(1-proj-3-tuple(v_613))) in
        {1766}let valid_28: bool = (if v_614 then 3-proj-3-tuple(v_613) else caught-fail) in
        {1767}let plaintext_34: bitstring = (if v_614 then 2-proj-3-tuple(v_613) else caught-fail) in
        {1768}let csi_47: cipherstate = (if v_614 then 1-proj-3-tuple(v_613) else caught-fail) in
        {1769}let ss_84: symmetricstate = (if v_614 then symmetricstatepack(csi_47,ck_91,h_76) else caught-fail) in
        {1770}let v_615: bitstring = (if v_614 then catch-fail(symmetricstateunpack(ss_84)) else caught-fail) in
        {1771}let v_616: bool = (not-caught-fail(v_615) && success?(1-proj-3-tuple(v_615))) in
        {1772}let h_77: bitstring = (if v_616 then 3-proj-3-tuple(v_615) else caught-fail) in
        {1773}let ck_92: key = (if v_616 then 2-proj-3-tuple(v_615) else caught-fail) in
        {1774}let cs_77: cipherstate = (if v_616 then 1-proj-3-tuple(v_615) else caught-fail) in
        {1775}let ssi_26: symmetricstate = (if v_614 then catch-fail((if v_616 then symmetricstatepack(cs_77,ck_92,hash(h_77,ciphertext_28)) else fail-any)) else caught-fail) in
        {1776}let v_617: bool = not-caught-fail(ssi_26) in
        {1777}let v_618: bitstring = (if v_602 then catch-fail((if v_604 then (if v_614 then (if v_617 then (ssi_26,plaintext_34,valid_28) else fail-any) else fail-any) else fail-any)) else caught-fail) in
        {1778}let v_619: bool = (not-caught-fail(v_618) && success?(1-proj-3-tuple(v_618))) in
        {1779}let valid2_8: bool = (if v_619 then 3-proj-3-tuple(v_618) else caught-fail) in
        {1780}let plaintext_35: bitstring = (if v_619 then 2-proj-3-tuple(v_618) else caught-fail) in
        {1781}let ss_85: symmetricstate = (if v_619 then 1-proj-3-tuple(v_618) else caught-fail) in
        {1740}let valid1_8: bool = (if v_602 then true else caught-fail) in
        {1782}let v_620: bool = (if v_619 then catch-fail((valid1_8 && valid2_8)) else caught-fail) in
        {1783}let hs_39: handshakestate = (if v_620 then handshakestatepack(ss_85,s_16,m_16,e_28,rs_16,rm_16,re_16,psk_13,initiator_11) else caught-fail) in
        {1784}let (hs_40: handshakestate,plaintext_c: bitstring,valid_29: bool) = (if v_600 then (if v_602 then (if v_619 then (if undo-catch-fail(v_620) then (hs_39,plaintext_35,true) else fail-any) else fail-any) else fail-any) else fail-any) in
        {1785}event RecvMsg(me_2,them_2,stagepack_c(sid_3),plaintext_c);
        {1786}insert statestore(me_2,them_2,sid_3,statepack_d(hs_40,handshakestategetcs(hs_40),cs2_13))
    ) | (
        {1788}!
        {1846}get statestore(=me_2,=them_2,=sid_3,statepack_d(hs_41: handshakestate,cs1_14: cipherstate,cs2_14: cipherstate)) in
        {1789}let hs_42: handshakestate = handshakestatesetcs(hs_41,cs2_14) in
        {1791}let v_621: bitstring = catch-fail(handshakestateunpack(hs_42)) in
        {1792}let v_622: bool = (not-caught-fail(v_621) && success?(1-proj-9-tuple(v_621))) in
        {1793}let initiator_12: bool = (if v_622 then 9-proj-9-tuple(v_621) else caught-fail) in
        {1794}let psk_14: key = (if v_622 then 8-proj-9-tuple(v_621) else caught-fail) in
        {1795}let re_17: key = (if v_622 then 7-proj-9-tuple(v_621) else caught-fail) in
        {1796}let rm_17: key = (if v_622 then 6-proj-9-tuple(v_621) else caught-fail) in
        {1797}let rs_17: key = (if v_622 then 5-proj-9-tuple(v_621) else caught-fail) in
        {1798}let e_29: keypair = (if v_622 then 4-proj-9-tuple(v_621) else caught-fail) in
        {1799}let m_17: keypair = (if v_622 then 3-proj-9-tuple(v_621) else caught-fail) in
        {1800}let s_17: keypair = (if v_622 then 2-proj-9-tuple(v_621) else caught-fail) in
        {1801}let ss_86: symmetricstate = (if v_622 then 1-proj-9-tuple(v_621) else caught-fail) in
        {1802}let v_623: bitstring = (if v_622 then catch-fail((empty,empty,empty,empty)) else caught-fail) in
        {1803}let v_624: bool = (not-caught-fail(v_623) && success?(1-proj-4-tuple(v_623))) in
        {1804}let ciphertext_29: bitstring = (if v_624 then 4-proj-4-tuple(v_623) else caught-fail) in
        {1805}let nm_14: bitstring = (if v_624 then 3-proj-4-tuple(v_623) else caught-fail) in
        {1806}let ns_14: bitstring = (if v_624 then 2-proj-4-tuple(v_623) else caught-fail) in
        {1807}let ne_20: bitstring = (if v_624 then 1-proj-4-tuple(v_623) else caught-fail) in
        {1808}let v_625: bitstring = (if v_624 then catch-fail(symmetricstateunpack(ss_86)) else caught-fail) in
        {1809}let v_626: bool = (not-caught-fail(v_625) && success?(1-proj-3-tuple(v_625))) in
        {1810}let h_78: bitstring = (if v_626 then 3-proj-3-tuple(v_625) else caught-fail) in
        {1811}let ck_93: key = (if v_626 then 2-proj-3-tuple(v_625) else caught-fail) in
        {1812}let cs_78: cipherstate = (if v_626 then 1-proj-3-tuple(v_625) else caught-fail) in
        {1813}let v_627: bitstring = (if v_626 then catch-fail(cipherstateunpack(cs_78)) else caught-fail) in
        {1814}let v_628: bool = (not-caught-fail(v_627) && success?(1-proj-2-tuple(v_627))) in
        {1815}let n_48: nonce = (if v_628 then 2-proj-2-tuple(v_627) else caught-fail) in
        {1816}let k_51: key = (if v_628 then 1-proj-2-tuple(v_627) else caught-fail) in
        {1819}let v_629: bitstring = (if v_628 then catch-fail(cipherstateunpack(cs_78)) else caught-fail) in
        {1820}let v_630: bool = (not-caught-fail(v_629) && success?(1-proj-2-tuple(v_629))) in
        {1821}let o_24: nonce = (if v_630 then 2-proj-2-tuple(v_629) else caught-fail) in
        {1822}let k_52: key = (if v_630 then 1-proj-2-tuple(v_629) else caught-fail) in
        {1818}let n_49: nonce = (if v_628 then increment_nonce(n_48) else caught-fail) in
        {1823}let csi_48: cipherstate = (if v_628 then catch-fail((if v_630 then cipherstatepack(k_52,n_49) else fail-any)) else caught-fail) in
        {1824}let v_631: bool = not-caught-fail(csi_48) in
        {1790}let payload_5: bitstring = msg_d(me_2,them_2,sid_3) in
        {1817}let e_30: bitstring = (if v_628 then encrypt(k_51,n_48,h_78,payload_5) else caught-fail) in
        {1825}let v_632: bitstring = (if v_626 then catch-fail((if v_628 then (if v_631 then (csi_48,e_30) else fail-any) else fail-any)) else caught-fail) in
        {1826}let v_633: bool = (not-caught-fail(v_632) && success?(1-proj-2-tuple(v_632))) in
        {1827}let ciphertext_30: bitstring = (if v_633 then 2-proj-2-tuple(v_632) else caught-fail) in
        {1828}let csi_49: cipherstate = (if v_633 then 1-proj-2-tuple(v_632) else caught-fail) in
        {1829}let ss_87: symmetricstate = (if v_633 then symmetricstatepack(csi_49,ck_93,h_78) else caught-fail) in
        {1830}let v_634: bitstring = (if v_633 then catch-fail(symmetricstateunpack(ss_87)) else caught-fail) in
        {1831}let v_635: bool = (not-caught-fail(v_634) && success?(1-proj-3-tuple(v_634))) in
        {1832}let h_79: bitstring = (if v_635 then 3-proj-3-tuple(v_634) else caught-fail) in
        {1833}let ck_94: key = (if v_635 then 2-proj-3-tuple(v_634) else caught-fail) in
        {1834}let cs_79: cipherstate = (if v_635 then 1-proj-3-tuple(v_634) else caught-fail) in
        {1835}let ssi_27: symmetricstate = (if v_633 then catch-fail((if v_635 then symmetricstatepack(cs_79,ck_94,hash(h_79,ciphertext_30)) else fail-any)) else caught-fail) in
        {1836}let v_636: bool = not-caught-fail(ssi_27) in
        {1837}let v_637: bitstring = (if v_624 then catch-fail((if v_626 then (if v_633 then (if v_636 then (ssi_27,ciphertext_30) else fail-any) else fail-any) else fail-any)) else caught-fail) in
        {1838}let v_638: bool = (not-caught-fail(v_637) && success?(1-proj-2-tuple(v_637))) in
        {1839}let ciphertext_31: bitstring = (if v_638 then 2-proj-2-tuple(v_637) else caught-fail) in
        {1840}let ss_88: symmetricstate = (if v_638 then 1-proj-2-tuple(v_637) else caught-fail) in
        {1842}let message_buffer_5: bitstring = (if v_638 then concat4(ne_20,ns_14,nm_14,ciphertext_31) else caught-fail) in
        {1841}let hs_43: handshakestate = (if v_638 then handshakestatepack(ss_88,s_17,m_17,e_29,rs_17,rm_17,re_17,psk_14,initiator_12) else caught-fail) in
        {1843}let (hs_44: handshakestate,message_d_2: bitstring) = (if v_622 then (if v_624 then (if v_638 then (hs_43,message_buffer_5) else fail-any) else fail-any) else fail-any) in
        {1844}event SendMsg(me_2,them_2,stagepack_d(sid_3),msg_d(me_2,them_2,sid_3));
        {1845}out(pub, message_d_2)
    ) | (
        {1847}event LeakS(phase0,me_2);
        {1848}event LeakM(phase0,me_2);
        {1849}out(pub, (key_s(me_2),key_m(me_2)))
    ) | (
        {1850}phase 1;
        {1851}event LeakS(phase1,me_2);
        {1852}event LeakM(phase1,me_2);
        {1853}out(pub, (key_s(me_2),key_m(me_2)))
    )
) | (
    {1854}let me_3: principal = bob in
    {1858}let basis_16: key = key_m(me_3) in
    {1859}let public_key_16: key = catch-fail(dhexp(basis_16,validkey(g))) in
    {1860}let v_639: bool = not-caught-fail(public_key_16) in
    {1861}let m_18: keypair = (if v_639 then keypairpack(validkey(public_key_16),basis_16) else fail-any) in
    {1857}let s_18: keypair = keypairpack(empty,empty) in
    {1862}out(pub, (getpublickey(s_18),getpublickey(m_18)));
    {1856}let sid_4: sessionid = sid in
    {1855}let them_3: principal = charlie in
    (
        {1872}let k_53: key = empty in
        {1873}let cs_80: cipherstate = cipherstatepack(k_53,minnonce) in
        {1869}let protocol_name_3: bitstring = somename in
        {1870}let h_80: bitstring = hash(protocol_name_3,empty) in
        {1871}let ck_95: key = h_80 in
        {1874}let ss_89: symmetricstate = symmetricstatepack(cs_80,ck_95,h_80) in
        {1875}let v_640: bitstring = catch-fail(symmetricstateunpack(ss_89)) in
        {1876}let v_641: bool = (not-caught-fail(v_640) && success?(1-proj-3-tuple(v_640))) in
        {1877}let h_81: bitstring = (if v_641 then 3-proj-3-tuple(v_640) else caught-fail) in
        {1878}let ck_96: key = (if v_641 then 2-proj-3-tuple(v_640) else caught-fail) in
        {1879}let cs_81: cipherstate = (if v_641 then 1-proj-3-tuple(v_640) else caught-fail) in
        {1867}let prologue_3: bitstring = empty in
        {1880}let ss_90: symmetricstate = catch-fail((if v_641 then symmetricstatepack(cs_81,ck_96,hash(h_81,prologue_3)) else fail-any)) in
        {1881}let v_642: bool = not-caught-fail(ss_90) in
        {1868}let psk_15: key = empty in
        {1866}let re_18: key = empty in
        {1865}let rm_18: key = empty in
        {1864}let rs_18: key = empty in
        {1863}let e_31: keypair = keypairpack(empty,empty) in
        {1882}let hs_45: handshakestate = (if v_642 then handshakestatepack(ss_90,s_18,m_18,e_31,rs_18,rm_18,re_18,psk_15,false) else fail-any) in
        {1883}insert statestore(me_3,them_3,sid_4,statepack_a(hs_45))
    ) | (
        {2048}get statestore(=me_3,=them_3,=sid_4,statepack_a(hs_46: handshakestate)) in
        {1884}in(pub, message_a_3: bitstring);
        {1885}let v_643: bitstring = catch-fail(handshakestateunpack(hs_46)) in
        {1886}let v_644: bool = (not-caught-fail(v_643) && success?(1-proj-9-tuple(v_643))) in
        {1887}let initiator_13: bool = (if v_644 then 9-proj-9-tuple(v_643) else caught-fail) in
        {1888}let psk_16: key = (if v_644 then 8-proj-9-tuple(v_643) else caught-fail) in
        {1889}let re_19: key = (if v_644 then 7-proj-9-tuple(v_643) else caught-fail) in
        {1890}let rm_19: key = (if v_644 then 6-proj-9-tuple(v_643) else caught-fail) in
        {1891}let rs_19: key = (if v_644 then 5-proj-9-tuple(v_643) else caught-fail) in
        {1892}let e_32: keypair = (if v_644 then 4-proj-9-tuple(v_643) else caught-fail) in
        {1893}let m_19: keypair = (if v_644 then 3-proj-9-tuple(v_643) else caught-fail) in
        {1894}let s_19: keypair = (if v_644 then 2-proj-9-tuple(v_643) else caught-fail) in
        {1895}let ss_91: symmetricstate = (if v_644 then 1-proj-9-tuple(v_643) else caught-fail) in
        {1896}let v_645: bitstring = (if v_644 then catch-fail(deconcat4(message_a_3)) else caught-fail) in
        {1897}let v_646: bool = (not-caught-fail(v_645) && success?(1-proj-4-tuple(v_645))) in
        {1898}let ciphertext_32: bitstring = (if v_646 then 4-proj-4-tuple(v_645) else caught-fail) in
        {1899}let nm_15: bitstring = (if v_646 then 3-proj-4-tuple(v_645) else caught-fail) in
        {1900}let ns_15: bitstring = (if v_646 then 2-proj-4-tuple(v_645) else caught-fail) in
        {1901}let ne_21: bitstring = (if v_646 then 1-proj-4-tuple(v_645) else caught-fail) in
        {1905}let v_647: bitstring = (if v_646 then catch-fail(symmetricstateunpack(ss_91)) else caught-fail) in
        {1906}let v_648: bool = (not-caught-fail(v_647) && success?(1-proj-3-tuple(v_647))) in
        {1907}let h_82: bitstring = (if v_648 then 3-proj-3-tuple(v_647) else caught-fail) in
        {1908}let ck_97: key = (if v_648 then 2-proj-3-tuple(v_647) else caught-fail) in
        {1909}let cs_82: cipherstate = (if v_648 then 1-proj-3-tuple(v_647) else caught-fail) in
        {1904}let re_20: key = (if v_646 then ne_21 else caught-fail) in
        {1910}let ss_92: symmetricstate = (if v_646 then catch-fail((if v_648 then symmetricstatepack(cs_82,ck_97,hash(h_82,re_20)) else fail-any)) else caught-fail) in
        {1911}let v_649: bool = not-caught-fail(ss_92) in
        {1912}let v_650: bitstring = (if v_649 then catch-fail(symmetricstateunpack(ss_92)) else caught-fail) in
        {1913}let v_651: bool = (not-caught-fail(v_650) && success?(1-proj-3-tuple(v_650))) in
        {1914}let h_83: bitstring = (if v_651 then 3-proj-3-tuple(v_650) else caught-fail) in
        {1915}let ck_98: key = (if v_651 then 2-proj-3-tuple(v_650) else caught-fail) in
        {1916}let cs_83: cipherstate = (if v_651 then 1-proj-3-tuple(v_650) else caught-fail) in
        {1917}let v_652: bitstring = (if v_651 then catch-fail(cipherstateunpack(cs_83)) else caught-fail) in
        {1918}let v_653: bool = (not-caught-fail(v_652) && success?(1-proj-2-tuple(v_652))) in
        {1919}let n_50: nonce = (if v_653 then 2-proj-2-tuple(v_652) else caught-fail) in
        {1920}let k_54: key = (if v_653 then 1-proj-2-tuple(v_652) else caught-fail) in
        {1921}let d_12: aead = (if v_653 then catch-fail(decrypt(k_54,n_50,h_83,ns_15)) else caught-fail) in
        {1922}let v_654: bool = not-caught-fail(d_12) in
        {1923}let v_655: bitstring = (if v_654 then catch-fail(aeadunpack(d_12)) else caught-fail) in
        {1924}let v_656: bool = (not-caught-fail(v_655) && success?(1-proj-3-tuple(v_655))) in
        {1925}let plaintext_36: bitstring = (if v_656 then 3-proj-3-tuple(v_655) else caught-fail) in
        {1926}let adi_12: bitstring = (if v_656 then 2-proj-3-tuple(v_655) else caught-fail) in
        {1927}let valid_30: bool = (if v_656 then 1-proj-3-tuple(v_655) else caught-fail) in
        {1929}let v_657: bitstring = (if v_656 then catch-fail(cipherstateunpack(cs_83)) else caught-fail) in
        {1930}let v_658: bool = (not-caught-fail(v_657) && success?(1-proj-2-tuple(v_657))) in
        {1931}let o_25: nonce = (if v_658 then 2-proj-2-tuple(v_657) else caught-fail) in
        {1932}let k_55: key = (if v_658 then 1-proj-2-tuple(v_657) else caught-fail) in
        {1928}let n_51: nonce = (if v_656 then increment_nonce(n_50) else caught-fail) in
        {1933}let csi_50: cipherstate = (if v_656 then catch-fail((if v_658 then cipherstatepack(k_55,n_51) else fail-any)) else caught-fail) in
        {1934}let v_659: bool = not-caught-fail(csi_50) in
        {1935}let v_660: bitstring = (if v_651 then catch-fail((if v_653 then (if v_654 then (if v_656 then (if v_659 then (csi_50,plaintext_36,valid_30) else fail-any) else fail-any) else fail-any) else fail-any)) else caught-fail) in
        {1936}let v_661: bool = (not-caught-fail(v_660) && success?(1-proj-3-tuple(v_660))) in
        {1937}let valid_31: bool = (if v_661 then 3-proj-3-tuple(v_660) else caught-fail) in
        {1938}let plaintext_37: bitstring = (if v_661 then 2-proj-3-tuple(v_660) else caught-fail) in
        {1939}let csi_51: cipherstate = (if v_661 then 1-proj-3-tuple(v_660) else caught-fail) in
        {1940}let ss_93: symmetricstate = (if v_661 then symmetricstatepack(csi_51,ck_98,h_83) else caught-fail) in
        {1941}let v_662: bitstring = (if v_661 then catch-fail(symmetricstateunpack(ss_93)) else caught-fail) in
        {1942}let v_663: bool = (not-caught-fail(v_662) && success?(1-proj-3-tuple(v_662))) in
        {1943}let h_84: bitstring = (if v_663 then 3-proj-3-tuple(v_662) else caught-fail) in
        {1944}let ck_99: key = (if v_663 then 2-proj-3-tuple(v_662) else caught-fail) in
        {1945}let cs_84: cipherstate = (if v_663 then 1-proj-3-tuple(v_662) else caught-fail) in
        {1946}let ssi_28: symmetricstate = (if v_661 then catch-fail((if v_663 then symmetricstatepack(cs_84,ck_99,hash(h_84,ns_15)) else fail-any)) else caught-fail) in
        {1947}let v_664: bool = not-caught-fail(ssi_28) in
        {1948}let v_665: bitstring = (if v_649 then catch-fail((if v_651 then (if v_661 then (if v_664 then (ssi_28,plaintext_37,valid_31) else fail-any) else fail-any) else fail-any)) else caught-fail) in
        {1949}let v_666: bool = (not-caught-fail(v_665) && success?(1-proj-3-tuple(v_665))) in
        {1950}let valid1_10: bool = (if v_666 then 3-proj-3-tuple(v_665) else caught-fail) in
        {1951}let ne_22: bitstring = (if v_666 then 2-proj-3-tuple(v_665) else caught-fail) in
        {1952}let ss_94: symmetricstate = (if v_666 then 1-proj-3-tuple(v_665) else caught-fail) in
        {1954}let v_667: bitstring = (if v_666 then catch-fail(symmetricstateunpack(ss_94)) else caught-fail) in
        {1955}let v_668: bool = (not-caught-fail(v_667) && success?(1-proj-3-tuple(v_667))) in
        {1956}let h_85: bitstring = (if v_668 then 3-proj-3-tuple(v_667) else caught-fail) in
        {1957}let ck_100: key = (if v_668 then 2-proj-3-tuple(v_667) else caught-fail) in
        {1958}let cs_85: cipherstate = (if v_668 then 1-proj-3-tuple(v_667) else caught-fail) in
        {1959}let v_669: bitstring = (if v_668 then catch-fail(cipherstateunpack(cs_85)) else caught-fail) in
        {1960}let v_670: bool = (not-caught-fail(v_669) && success?(1-proj-2-tuple(v_669))) in
        {1961}let n_52: nonce = (if v_670 then 2-proj-2-tuple(v_669) else caught-fail) in
        {1962}let k_56: key = (if v_670 then 1-proj-2-tuple(v_669) else caught-fail) in
        {1963}let d_13: aead = (if v_670 then catch-fail(decrypt(k_56,n_52,h_85,nm_15)) else caught-fail) in
        {1964}let v_671: bool = not-caught-fail(d_13) in
        {1965}let v_672: bitstring = (if v_671 then catch-fail(aeadunpack(d_13)) else caught-fail) in
        {1966}let v_673: bool = (not-caught-fail(v_672) && success?(1-proj-3-tuple(v_672))) in
        {1967}let plaintext_38: bitstring = (if v_673 then 3-proj-3-tuple(v_672) else caught-fail) in
        {1968}let adi_13: bitstring = (if v_673 then 2-proj-3-tuple(v_672) else caught-fail) in
        {1969}let valid_32: bool = (if v_673 then 1-proj-3-tuple(v_672) else caught-fail) in
        {1971}let v_674: bitstring = (if v_673 then catch-fail(cipherstateunpack(cs_85)) else caught-fail) in
        {1972}let v_675: bool = (not-caught-fail(v_674) && success?(1-proj-2-tuple(v_674))) in
        {1973}let o_26: nonce = (if v_675 then 2-proj-2-tuple(v_674) else caught-fail) in
        {1974}let k_57: key = (if v_675 then 1-proj-2-tuple(v_674) else caught-fail) in
        {1970}let n_53: nonce = (if v_673 then increment_nonce(n_52) else caught-fail) in
        {1975}let csi_52: cipherstate = (if v_673 then catch-fail((if v_675 then cipherstatepack(k_57,n_53) else fail-any)) else caught-fail) in
        {1976}let v_676: bool = not-caught-fail(csi_52) in
        {1977}let v_677: bitstring = (if v_668 then catch-fail((if v_670 then (if v_671 then (if v_673 then (if v_676 then (csi_52,plaintext_38,valid_32) else fail-any) else fail-any) else fail-any) else fail-any)) else caught-fail) in
        {1978}let v_678: bool = (not-caught-fail(v_677) && success?(1-proj-3-tuple(v_677))) in
        {1979}let valid_33: bool = (if v_678 then 3-proj-3-tuple(v_677) else caught-fail) in
        {1980}let plaintext_39: bitstring = (if v_678 then 2-proj-3-tuple(v_677) else caught-fail) in
        {1981}let csi_53: cipherstate = (if v_678 then 1-proj-3-tuple(v_677) else caught-fail) in
        {1982}let ss_95: symmetricstate = (if v_678 then symmetricstatepack(csi_53,ck_100,h_85) else caught-fail) in
        {1983}let v_679: bitstring = (if v_678 then catch-fail(symmetricstateunpack(ss_95)) else caught-fail) in
        {1984}let v_680: bool = (not-caught-fail(v_679) && success?(1-proj-3-tuple(v_679))) in
        {1985}let h_86: bitstring = (if v_680 then 3-proj-3-tuple(v_679) else caught-fail) in
        {1986}let ck_101: key = (if v_680 then 2-proj-3-tuple(v_679) else caught-fail) in
        {1987}let cs_86: cipherstate = (if v_680 then 1-proj-3-tuple(v_679) else caught-fail) in
        {1988}let ssi_29: symmetricstate = (if v_678 then catch-fail((if v_680 then symmetricstatepack(cs_86,ck_101,hash(h_86,nm_15)) else fail-any)) else caught-fail) in
        {1989}let v_681: bool = not-caught-fail(ssi_29) in
        {1990}let v_682: bitstring = (if v_666 then catch-fail((if v_668 then (if v_678 then (if v_681 then (ssi_29,plaintext_39,valid_33) else fail-any) else fail-any) else fail-any)) else caught-fail) in
        {1991}let v_683: bool = (not-caught-fail(v_682) && success?(1-proj-3-tuple(v_682))) in
        {1992}let valid2_10: bool = (if v_683 then 3-proj-3-tuple(v_682) else caught-fail) in
        {1993}let ne_23: bitstring = (if v_683 then 2-proj-3-tuple(v_682) else caught-fail) in
        {1994}let ss_96: symmetricstate = (if v_683 then 1-proj-3-tuple(v_682) else caught-fail) in
        {1996}let v_684: bitstring = (if v_683 then catch-fail(symmetricstateunpack(ss_96)) else caught-fail) in
        {1997}let v_685: bool = (not-caught-fail(v_684) && success?(1-proj-3-tuple(v_684))) in
        {1998}let h_87: bitstring = (if v_685 then 3-proj-3-tuple(v_684) else caught-fail) in
        {1999}let ck_102: key = (if v_685 then 2-proj-3-tuple(v_684) else caught-fail) in
        {2000}let cs_87: cipherstate = (if v_685 then 1-proj-3-tuple(v_684) else caught-fail) in
        {2001}let v_686: bitstring = (if v_685 then catch-fail(cipherstateunpack(cs_87)) else caught-fail) in
        {2002}let v_687: bool = (not-caught-fail(v_686) && success?(1-proj-2-tuple(v_686))) in
        {2003}let n_54: nonce = (if v_687 then 2-proj-2-tuple(v_686) else caught-fail) in
        {2004}let k_58: key = (if v_687 then 1-proj-2-tuple(v_686) else caught-fail) in
        {2005}let d_14: aead = (if v_687 then catch-fail(decrypt(k_58,n_54,h_87,ciphertext_32)) else caught-fail) in
        {2006}let v_688: bool = not-caught-fail(d_14) in
        {2007}let v_689: bitstring = (if v_688 then catch-fail(aeadunpack(d_14)) else caught-fail) in
        {2008}let v_690: bool = (not-caught-fail(v_689) && success?(1-proj-3-tuple(v_689))) in
        {2009}let plaintext_40: bitstring = (if v_690 then 3-proj-3-tuple(v_689) else caught-fail) in
        {2010}let adi_14: bitstring = (if v_690 then 2-proj-3-tuple(v_689) else caught-fail) in
        {2011}let valid_34: bool = (if v_690 then 1-proj-3-tuple(v_689) else caught-fail) in
        {2013}let v_691: bitstring = (if v_690 then catch-fail(cipherstateunpack(cs_87)) else caught-fail) in
        {2014}let v_692: bool = (not-caught-fail(v_691) && success?(1-proj-2-tuple(v_691))) in
        {2015}let o_27: nonce = (if v_692 then 2-proj-2-tuple(v_691) else caught-fail) in
        {2016}let k_59: key = (if v_692 then 1-proj-2-tuple(v_691) else caught-fail) in
        {2012}let n_55: nonce = (if v_690 then increment_nonce(n_54) else caught-fail) in
        {2017}let csi_54: cipherstate = (if v_690 then catch-fail((if v_692 then cipherstatepack(k_59,n_55) else fail-any)) else caught-fail) in
        {2018}let v_693: bool = not-caught-fail(csi_54) in
        {2019}let v_694: bitstring = (if v_685 then catch-fail((if v_687 then (if v_688 then (if v_690 then (if v_693 then (csi_54,plaintext_40,valid_34) else fail-any) else fail-any) else fail-any) else fail-any)) else caught-fail) in
        {2020}let v_695: bool = (not-caught-fail(v_694) && success?(1-proj-3-tuple(v_694))) in
        {2021}let valid_35: bool = (if v_695 then 3-proj-3-tuple(v_694) else caught-fail) in
        {2022}let plaintext_41: bitstring = (if v_695 then 2-proj-3-tuple(v_694) else caught-fail) in
        {2023}let csi_55: cipherstate = (if v_695 then 1-proj-3-tuple(v_694) else caught-fail) in
        {2024}let ss_97: symmetricstate = (if v_695 then symmetricstatepack(csi_55,ck_102,h_87) else caught-fail) in
        {2025}let v_696: bitstring = (if v_695 then catch-fail(symmetricstateunpack(ss_97)) else caught-fail) in
        {2026}let v_697: bool = (not-caught-fail(v_696) && success?(1-proj-3-tuple(v_696))) in
        {2027}let h_88: bitstring = (if v_697 then 3-proj-3-tuple(v_696) else caught-fail) in
        {2028}let ck_103: key = (if v_697 then 2-proj-3-tuple(v_696) else caught-fail) in
        {2029}let cs_88: cipherstate = (if v_697 then 1-proj-3-tuple(v_696) else caught-fail) in
        {2030}let ssi_30: symmetricstate = (if v_695 then catch-fail((if v_697 then symmetricstatepack(cs_88,ck_103,hash(h_88,ciphertext_32)) else fail-any)) else caught-fail) in
        {2031}let v_698: bool = not-caught-fail(ssi_30) in
        {2032}let v_699: bitstring = (if v_683 then catch-fail((if v_685 then (if v_695 then (if v_698 then (ssi_30,plaintext_41,valid_35) else fail-any) else fail-any) else fail-any)) else caught-fail) in
        {2033}let v_700: bool = (not-caught-fail(v_699) && success?(1-proj-3-tuple(v_699))) in
        {2034}let valid3_3: bool = (if v_700 then 3-proj-3-tuple(v_699) else caught-fail) in
        {2035}let plaintext_42: bitstring = (if v_700 then 2-proj-3-tuple(v_699) else caught-fail) in
        {2036}let ss_98: symmetricstate = (if v_700 then 1-proj-3-tuple(v_699) else caught-fail) in
        {2040}let basis_18: key = (if v_700 then key_m(them_3) else caught-fail) in
        {2041}let public_key_18: key = (if v_700 then catch-fail(dhexp(basis_18,validkey(g))) else caught-fail) in
        {2042}let v_702: bool = not-caught-fail(public_key_18) in
        {2037}let basis_17: key = (if v_700 then key_s(them_3) else caught-fail) in
        {2038}let public_key_17: key = (if v_700 then catch-fail(dhexp(basis_17,validkey(g))) else caught-fail) in
        {2039}let v_701: bool = not-caught-fail(public_key_17) in
        {1995}let rm_20: key = (if v_683 then ne_23 else caught-fail) in
        {1953}let rs_20: key = (if v_666 then ne_22 else caught-fail) in
        {2043}let v_703: bool = (if v_700 then catch-fail(((valid1_10 && (valid2_10 && valid3_3)) && ((rs_20 = getpublickey((if v_701 then keypairpack(validkey(public_key_17),basis_17) else fail-any))) && (rm_20 = getpublickey((if v_702 then keypairpack(validkey(public_key_18),basis_18) else fail-any)))))) else caught-fail) in
        {2044}let hs_47: handshakestate = (if v_703 then handshakestatepack(ss_98,s_19,m_19,e_32,rs_20,rm_20,re_20,psk_16,initiator_13) else caught-fail) in
        {2045}let (hs_48: handshakestate,plaintext_a_1: bitstring,valid_36: bool) = (if v_644 then (if v_646 then (if v_649 then (if v_666 then (if v_683 then (if v_700 then (if undo-catch-fail(v_703) then (hs_47,plaintext_42,true) else fail-any) else fail-any) else fail-any) else fail-any) else fail-any) else fail-any) else fail-any) in
        {2046}event RecvMsg(me_3,them_3,stagepack_a(sid_4),plaintext_a_1);
        {2047}insert statestore(me_3,them_3,sid_4,statepack_b(hs_48))
    ) | (
        {2359}get statestore(=me_3,=them_3,=sid_4,statepack_b(hs_49: handshakestate)) in
        {2050}let v_704: bitstring = catch-fail(handshakestateunpack(hs_49)) in
        {2051}let v_705: bool = (not-caught-fail(v_704) && success?(1-proj-9-tuple(v_704))) in
        {2052}let initiator_14: bool = (if v_705 then 9-proj-9-tuple(v_704) else caught-fail) in
        {2053}let psk_17: key = (if v_705 then 8-proj-9-tuple(v_704) else caught-fail) in
        {2054}let re_21: key = (if v_705 then 7-proj-9-tuple(v_704) else caught-fail) in
        {2055}let rm_21: key = (if v_705 then 6-proj-9-tuple(v_704) else caught-fail) in
        {2056}let rs_21: key = (if v_705 then 5-proj-9-tuple(v_704) else caught-fail) in
        {2057}let e_33: keypair = (if v_705 then 4-proj-9-tuple(v_704) else caught-fail) in
        {2058}let m_20: keypair = (if v_705 then 3-proj-9-tuple(v_704) else caught-fail) in
        {2059}let s_20: keypair = (if v_705 then 2-proj-9-tuple(v_704) else caught-fail) in
        {2060}let ss_99: symmetricstate = (if v_705 then 1-proj-9-tuple(v_704) else caught-fail) in
        {2061}let v_706: bitstring = (if v_705 then catch-fail((empty,empty,empty,empty)) else caught-fail) in
        {2062}let v_707: bool = (not-caught-fail(v_706) && success?(1-proj-4-tuple(v_706))) in
        {2063}let ciphertext_33: bitstring = (if v_707 then 4-proj-4-tuple(v_706) else caught-fail) in
        {2064}let nm_16: bitstring = (if v_707 then 3-proj-4-tuple(v_706) else caught-fail) in
        {2065}let ns_16: bitstring = (if v_707 then 2-proj-4-tuple(v_706) else caught-fail) in
        {2066}let ne_24: bitstring = (if v_707 then 1-proj-4-tuple(v_706) else caught-fail) in
        {2067}let basis_19: key = (if v_707 then key_e(me_3,them_3,sid_4) else caught-fail) in
        {2068}let public_key_19: key = (if v_707 then catch-fail(dhexp(basis_19,validkey(g))) else caught-fail) in
        {2069}let v_708: bool = not-caught-fail(public_key_19) in
        {2070}let e_34: keypair = (if v_707 then catch-fail((if v_708 then keypairpack(validkey(public_key_19),basis_19) else fail-any)) else caught-fail) in
        {2071}let v_709: bool = not-caught-fail(e_34) in
        {2072}let ne_25: bitstring = (if v_709 then catch-fail(getpublickey(e_34)) else caught-fail) in
        {2073}let v_710: bool = not-caught-fail(ne_25) in
        {2074}let v_711: bitstring = (if v_710 then catch-fail(symmetricstateunpack(ss_99)) else caught-fail) in
        {2075}let v_712: bool = (not-caught-fail(v_711) && success?(1-proj-3-tuple(v_711))) in
        {2076}let h_89: bitstring = (if v_712 then 3-proj-3-tuple(v_711) else caught-fail) in
        {2077}let ck_104: key = (if v_712 then 2-proj-3-tuple(v_711) else caught-fail) in
        {2078}let cs_89: cipherstate = (if v_712 then 1-proj-3-tuple(v_711) else caught-fail) in
        {2079}let ss_100: symmetricstate = (if v_710 then catch-fail((if v_712 then symmetricstatepack(cs_89,ck_104,hash(h_89,ne_25)) else fail-any)) else caught-fail) in
        {2080}let v_713: bool = not-caught-fail(ss_100) in
        {2081}let v_714: bitstring = (if v_713 then catch-fail(keypairunpack(e_34)) else caught-fail) in
        {2082}let v_715: bool = (not-caught-fail(v_714) && success?(1-proj-2-tuple(v_714))) in
        {2083}let my_private_key_15: key = (if v_715 then 2-proj-2-tuple(v_714) else caught-fail) in
        {2084}let my_public_key_15: key = (if v_715 then 1-proj-2-tuple(v_714) else caught-fail) in
        {2085}let input_key_material_18: key = (if v_713 then catch-fail((if v_715 then dhexp(my_private_key_15,re_21) else fail-any)) else caught-fail) in
        {2086}let v_716: bool = not-caught-fail(input_key_material_18) in
        {2087}let v_717: bitstring = (if v_716 then catch-fail(symmetricstateunpack(ss_100)) else caught-fail) in
        {2088}let v_718: bool = (not-caught-fail(v_717) && success?(1-proj-3-tuple(v_717))) in
        {2089}let h_90: bitstring = (if v_718 then 3-proj-3-tuple(v_717) else caught-fail) in
        {2090}let ck_105: key = (if v_718 then 2-proj-3-tuple(v_717) else caught-fail) in
        {2091}let cs_90: cipherstate = (if v_718 then 1-proj-3-tuple(v_717) else caught-fail) in
        {2094}let output3_18: key = (if v_718 then hmac_hash3(ck_105,input_key_material_18) else caught-fail) in
        {2093}let output2_18: key = (if v_718 then hmac_hash2(ck_105,input_key_material_18) else caught-fail) in
        {2092}let output1_18: key = (if v_718 then hmac_hash1(ck_105,input_key_material_18) else caught-fail) in
        {2095}let v_719: bitstring = (if v_718 then catch-fail((output1_18,output2_18,output3_18)) else caught-fail) in
        {2096}let v_720: bool = (not-caught-fail(v_719) && success?(1-proj-3-tuple(v_719))) in
        {2097}let output_15: key = (if v_720 then 3-proj-3-tuple(v_719) else caught-fail) in
        {2098}let temp_k_15: key = (if v_720 then 2-proj-3-tuple(v_719) else caught-fail) in
        {2099}let ck_106: key = (if v_720 then 1-proj-3-tuple(v_719) else caught-fail) in
        {2100}let ss_101: symmetricstate = (if v_713 then catch-fail((if v_716 then (if v_718 then (if v_720 then symmetricstatepack(cipherstatepack(temp_k_15,minnonce),ck_106,h_90) else fail-any) else fail-any) else fail-any)) else caught-fail) in
        {2101}let v_721: bool = not-caught-fail(ss_101) in
        {2102}let v_722: bitstring = (if v_721 then catch-fail(keypairunpack(e_34)) else caught-fail) in
        {2103}let v_723: bool = (not-caught-fail(v_722) && success?(1-proj-2-tuple(v_722))) in
        {2104}let my_private_key_16: key = (if v_723 then 2-proj-2-tuple(v_722) else caught-fail) in
        {2105}let my_public_key_16: key = (if v_723 then 1-proj-2-tuple(v_722) else caught-fail) in
        {2106}let input_key_material_19: key = (if v_721 then catch-fail((if v_723 then dhexp(my_private_key_16,rs_21) else fail-any)) else caught-fail) in
        {2107}let v_724: bool = not-caught-fail(input_key_material_19) in
        {2108}let v_725: bitstring = (if v_724 then catch-fail(symmetricstateunpack(ss_101)) else caught-fail) in
        {2109}let v_726: bool = (not-caught-fail(v_725) && success?(1-proj-3-tuple(v_725))) in
        {2110}let h_91: bitstring = (if v_726 then 3-proj-3-tuple(v_725) else caught-fail) in
        {2111}let ck_107: key = (if v_726 then 2-proj-3-tuple(v_725) else caught-fail) in
        {2112}let cs_91: cipherstate = (if v_726 then 1-proj-3-tuple(v_725) else caught-fail) in
        {2115}let output3_19: key = (if v_726 then hmac_hash3(ck_107,input_key_material_19) else caught-fail) in
        {2114}let output2_19: key = (if v_726 then hmac_hash2(ck_107,input_key_material_19) else caught-fail) in
        {2113}let output1_19: key = (if v_726 then hmac_hash1(ck_107,input_key_material_19) else caught-fail) in
        {2116}let v_727: bitstring = (if v_726 then catch-fail((output1_19,output2_19,output3_19)) else caught-fail) in
        {2117}let v_728: bool = (not-caught-fail(v_727) && success?(1-proj-3-tuple(v_727))) in
        {2118}let output_16: key = (if v_728 then 3-proj-3-tuple(v_727) else caught-fail) in
        {2119}let temp_k_16: key = (if v_728 then 2-proj-3-tuple(v_727) else caught-fail) in
        {2120}let ck_108: key = (if v_728 then 1-proj-3-tuple(v_727) else caught-fail) in
        {2121}let ss_102: symmetricstate = (if v_721 then catch-fail((if v_724 then (if v_726 then (if v_728 then symmetricstatepack(cipherstatepack(temp_k_16,minnonce),ck_108,h_91) else fail-any) else fail-any) else fail-any)) else caught-fail) in
        {2122}let v_729: bool = not-caught-fail(ss_102) in
        {2123}let v_730: bitstring = (if v_729 then catch-fail(keypairunpack(e_34)) else caught-fail) in
        {2124}let v_731: bool = (not-caught-fail(v_730) && success?(1-proj-2-tuple(v_730))) in
        {2125}let my_private_key_17: key = (if v_731 then 2-proj-2-tuple(v_730) else caught-fail) in
        {2126}let my_public_key_17: key = (if v_731 then 1-proj-2-tuple(v_730) else caught-fail) in
        {2127}let input_key_material_20: key = (if v_729 then catch-fail((if v_731 then dhexp(my_private_key_17,rm_21) else fail-any)) else caught-fail) in
        {2128}let v_732: bool = not-caught-fail(input_key_material_20) in
        {2129}let v_733: bitstring = (if v_732 then catch-fail(symmetricstateunpack(ss_102)) else caught-fail) in
        {2130}let v_734: bool = (not-caught-fail(v_733) && success?(1-proj-3-tuple(v_733))) in
        {2131}let h_92: bitstring = (if v_734 then 3-proj-3-tuple(v_733) else caught-fail) in
        {2132}let ck_109: key = (if v_734 then 2-proj-3-tuple(v_733) else caught-fail) in
        {2133}let cs_92: cipherstate = (if v_734 then 1-proj-3-tuple(v_733) else caught-fail) in
        {2136}let output3_20: key = (if v_734 then hmac_hash3(ck_109,input_key_material_20) else caught-fail) in
        {2135}let output2_20: key = (if v_734 then hmac_hash2(ck_109,input_key_material_20) else caught-fail) in
        {2134}let output1_20: key = (if v_734 then hmac_hash1(ck_109,input_key_material_20) else caught-fail) in
        {2137}let v_735: bitstring = (if v_734 then catch-fail((output1_20,output2_20,output3_20)) else caught-fail) in
        {2138}let v_736: bool = (not-caught-fail(v_735) && success?(1-proj-3-tuple(v_735))) in
        {2139}let output_17: key = (if v_736 then 3-proj-3-tuple(v_735) else caught-fail) in
        {2140}let temp_k_17: key = (if v_736 then 2-proj-3-tuple(v_735) else caught-fail) in
        {2141}let ck_110: key = (if v_736 then 1-proj-3-tuple(v_735) else caught-fail) in
        {2142}let ss_103: symmetricstate = (if v_729 then catch-fail((if v_732 then (if v_734 then (if v_736 then symmetricstatepack(cipherstatepack(temp_k_17,minnonce),ck_110,h_92) else fail-any) else fail-any) else fail-any)) else caught-fail) in
        {2143}let v_737: bool = not-caught-fail(ss_103) in
        {2144}let basis_20: key = (if v_737 then key_s(me_3) else caught-fail) in
        {2145}let public_key_20: key = (if v_737 then catch-fail(dhexp(basis_20,validkey(g))) else caught-fail) in
        {2146}let v_738: bool = not-caught-fail(public_key_20) in
        {2147}let s_21: keypair = (if v_737 then catch-fail((if v_738 then keypairpack(validkey(public_key_20),basis_20) else fail-any)) else caught-fail) in
        {2148}let v_739: bool = not-caught-fail(s_21) in
        {2149}let plaintext_43: bitstring = (if v_739 then catch-fail(getpublickey(s_21)) else caught-fail) in
        {2150}let v_740: bool = not-caught-fail(plaintext_43) in
        {2151}let v_741: bitstring = (if v_740 then catch-fail(symmetricstateunpack(ss_103)) else caught-fail) in
        {2152}let v_742: bool = (not-caught-fail(v_741) && success?(1-proj-3-tuple(v_741))) in
        {2153}let h_93: bitstring = (if v_742 then 3-proj-3-tuple(v_741) else caught-fail) in
        {2154}let ck_111: key = (if v_742 then 2-proj-3-tuple(v_741) else caught-fail) in
        {2155}let cs_93: cipherstate = (if v_742 then 1-proj-3-tuple(v_741) else caught-fail) in
        {2156}let v_743: bitstring = (if v_742 then catch-fail(cipherstateunpack(cs_93)) else caught-fail) in
        {2157}let v_744: bool = (not-caught-fail(v_743) && success?(1-proj-2-tuple(v_743))) in
        {2158}let n_56: nonce = (if v_744 then 2-proj-2-tuple(v_743) else caught-fail) in
        {2159}let k_60: key = (if v_744 then 1-proj-2-tuple(v_743) else caught-fail) in
        {2162}let v_745: bitstring = (if v_744 then catch-fail(cipherstateunpack(cs_93)) else caught-fail) in
        {2163}let v_746: bool = (not-caught-fail(v_745) && success?(1-proj-2-tuple(v_745))) in
        {2164}let o_28: nonce = (if v_746 then 2-proj-2-tuple(v_745) else caught-fail) in
        {2165}let k_61: key = (if v_746 then 1-proj-2-tuple(v_745) else caught-fail) in
        {2161}let n_57: nonce = (if v_744 then increment_nonce(n_56) else caught-fail) in
        {2166}let csi_56: cipherstate = (if v_744 then catch-fail((if v_746 then cipherstatepack(k_61,n_57) else fail-any)) else caught-fail) in
        {2167}let v_747: bool = not-caught-fail(csi_56) in
        {2160}let e_35: bitstring = (if v_744 then encrypt(k_60,n_56,h_93,plaintext_43) else caught-fail) in
        {2168}let v_748: bitstring = (if v_742 then catch-fail((if v_744 then (if v_747 then (csi_56,e_35) else fail-any) else fail-any)) else caught-fail) in
        {2169}let v_749: bool = (not-caught-fail(v_748) && success?(1-proj-2-tuple(v_748))) in
        {2170}let ciphertext_34: bitstring = (if v_749 then 2-proj-2-tuple(v_748) else caught-fail) in
        {2171}let csi_57: cipherstate = (if v_749 then 1-proj-2-tuple(v_748) else caught-fail) in
        {2172}let ss_104: symmetricstate = (if v_749 then symmetricstatepack(csi_57,ck_111,h_93) else caught-fail) in
        {2173}let v_750: bitstring = (if v_749 then catch-fail(symmetricstateunpack(ss_104)) else caught-fail) in
        {2174}let v_751: bool = (not-caught-fail(v_750) && success?(1-proj-3-tuple(v_750))) in
        {2175}let h_94: bitstring = (if v_751 then 3-proj-3-tuple(v_750) else caught-fail) in
        {2176}let ck_112: key = (if v_751 then 2-proj-3-tuple(v_750) else caught-fail) in
        {2177}let cs_94: cipherstate = (if v_751 then 1-proj-3-tuple(v_750) else caught-fail) in
        {2178}let ssi_31: symmetricstate = (if v_749 then catch-fail((if v_751 then symmetricstatepack(cs_94,ck_112,hash(h_94,ciphertext_34)) else fail-any)) else caught-fail) in
        {2179}let v_752: bool = not-caught-fail(ssi_31) in
        {2180}let v_753: bitstring = (if v_739 then catch-fail((if v_740 then (if v_742 then (if v_749 then (if v_752 then (ssi_31,ciphertext_34) else fail-any) else fail-any) else fail-any) else fail-any)) else caught-fail) in
        {2181}let v_754: bool = (not-caught-fail(v_753) && success?(1-proj-2-tuple(v_753))) in
        {2182}let ns_17: bitstring = (if v_754 then 2-proj-2-tuple(v_753) else caught-fail) in
        {2183}let ss_105: symmetricstate = (if v_754 then 1-proj-2-tuple(v_753) else caught-fail) in
        {2184}let basis_21: key = (if v_754 then key_m(me_3) else caught-fail) in
        {2185}let public_key_21: key = (if v_754 then catch-fail(dhexp(basis_21,validkey(g))) else caught-fail) in
        {2186}let v_755: bool = not-caught-fail(public_key_21) in
        {2187}let m_21: keypair = (if v_754 then catch-fail((if v_755 then keypairpack(validkey(public_key_21),basis_21) else fail-any)) else caught-fail) in
        {2188}let v_756: bool = not-caught-fail(m_21) in
        {2189}let plaintext_44: bitstring = (if v_756 then catch-fail(getpublickey(m_21)) else caught-fail) in
        {2190}let v_757: bool = not-caught-fail(plaintext_44) in
        {2191}let v_758: bitstring = (if v_757 then catch-fail(symmetricstateunpack(ss_105)) else caught-fail) in
        {2192}let v_759: bool = (not-caught-fail(v_758) && success?(1-proj-3-tuple(v_758))) in
        {2193}let h_95: bitstring = (if v_759 then 3-proj-3-tuple(v_758) else caught-fail) in
        {2194}let ck_113: key = (if v_759 then 2-proj-3-tuple(v_758) else caught-fail) in
        {2195}let cs_95: cipherstate = (if v_759 then 1-proj-3-tuple(v_758) else caught-fail) in
        {2196}let v_760: bitstring = (if v_759 then catch-fail(cipherstateunpack(cs_95)) else caught-fail) in
        {2197}let v_761: bool = (not-caught-fail(v_760) && success?(1-proj-2-tuple(v_760))) in
        {2198}let n_58: nonce = (if v_761 then 2-proj-2-tuple(v_760) else caught-fail) in
        {2199}let k_62: key = (if v_761 then 1-proj-2-tuple(v_760) else caught-fail) in
        {2202}let v_762: bitstring = (if v_761 then catch-fail(cipherstateunpack(cs_95)) else caught-fail) in
        {2203}let v_763: bool = (not-caught-fail(v_762) && success?(1-proj-2-tuple(v_762))) in
        {2204}let o_29: nonce = (if v_763 then 2-proj-2-tuple(v_762) else caught-fail) in
        {2205}let k_63: key = (if v_763 then 1-proj-2-tuple(v_762) else caught-fail) in
        {2201}let n_59: nonce = (if v_761 then increment_nonce(n_58) else caught-fail) in
        {2206}let csi_58: cipherstate = (if v_761 then catch-fail((if v_763 then cipherstatepack(k_63,n_59) else fail-any)) else caught-fail) in
        {2207}let v_764: bool = not-caught-fail(csi_58) in
        {2200}let e_36: bitstring = (if v_761 then encrypt(k_62,n_58,h_95,plaintext_44) else caught-fail) in
        {2208}let v_765: bitstring = (if v_759 then catch-fail((if v_761 then (if v_764 then (csi_58,e_36) else fail-any) else fail-any)) else caught-fail) in
        {2209}let v_766: bool = (not-caught-fail(v_765) && success?(1-proj-2-tuple(v_765))) in
        {2210}let ciphertext_35: bitstring = (if v_766 then 2-proj-2-tuple(v_765) else caught-fail) in
        {2211}let csi_59: cipherstate = (if v_766 then 1-proj-2-tuple(v_765) else caught-fail) in
        {2212}let ss_106: symmetricstate = (if v_766 then symmetricstatepack(csi_59,ck_113,h_95) else caught-fail) in
        {2213}let v_767: bitstring = (if v_766 then catch-fail(symmetricstateunpack(ss_106)) else caught-fail) in
        {2214}let v_768: bool = (not-caught-fail(v_767) && success?(1-proj-3-tuple(v_767))) in
        {2215}let h_96: bitstring = (if v_768 then 3-proj-3-tuple(v_767) else caught-fail) in
        {2216}let ck_114: key = (if v_768 then 2-proj-3-tuple(v_767) else caught-fail) in
        {2217}let cs_96: cipherstate = (if v_768 then 1-proj-3-tuple(v_767) else caught-fail) in
        {2218}let ssi_32: symmetricstate = (if v_766 then catch-fail((if v_768 then symmetricstatepack(cs_96,ck_114,hash(h_96,ciphertext_35)) else fail-any)) else caught-fail) in
        {2219}let v_769: bool = not-caught-fail(ssi_32) in
        {2220}let v_770: bitstring = (if v_756 then catch-fail((if v_757 then (if v_759 then (if v_766 then (if v_769 then (ssi_32,ciphertext_35) else fail-any) else fail-any) else fail-any) else fail-any)) else caught-fail) in
        {2221}let v_771: bool = (not-caught-fail(v_770) && success?(1-proj-2-tuple(v_770))) in
        {2222}let nm_17: bitstring = (if v_771 then 2-proj-2-tuple(v_770) else caught-fail) in
        {2223}let ss_107: symmetricstate = (if v_771 then 1-proj-2-tuple(v_770) else caught-fail) in
        {2224}let v_772: bitstring = (if v_771 then catch-fail(keypairunpack(s_21)) else caught-fail) in
        {2225}let v_773: bool = (not-caught-fail(v_772) && success?(1-proj-2-tuple(v_772))) in
        {2226}let my_private_key_18: key = (if v_773 then 2-proj-2-tuple(v_772) else caught-fail) in
        {2227}let my_public_key_18: key = (if v_773 then 1-proj-2-tuple(v_772) else caught-fail) in
        {2228}let input_key_material_21: key = (if v_771 then catch-fail((if v_773 then dhexp(my_private_key_18,re_21) else fail-any)) else caught-fail) in
        {2229}let v_774: bool = not-caught-fail(input_key_material_21) in
        {2230}let v_775: bitstring = (if v_774 then catch-fail(symmetricstateunpack(ss_107)) else caught-fail) in
        {2231}let v_776: bool = (not-caught-fail(v_775) && success?(1-proj-3-tuple(v_775))) in
        {2232}let h_97: bitstring = (if v_776 then 3-proj-3-tuple(v_775) else caught-fail) in
        {2233}let ck_115: key = (if v_776 then 2-proj-3-tuple(v_775) else caught-fail) in
        {2234}let cs_97: cipherstate = (if v_776 then 1-proj-3-tuple(v_775) else caught-fail) in
        {2237}let output3_21: key = (if v_776 then hmac_hash3(ck_115,input_key_material_21) else caught-fail) in
        {2236}let output2_21: key = (if v_776 then hmac_hash2(ck_115,input_key_material_21) else caught-fail) in
        {2235}let output1_21: key = (if v_776 then hmac_hash1(ck_115,input_key_material_21) else caught-fail) in
        {2238}let v_777: bitstring = (if v_776 then catch-fail((output1_21,output2_21,output3_21)) else caught-fail) in
        {2239}let v_778: bool = (not-caught-fail(v_777) && success?(1-proj-3-tuple(v_777))) in
        {2240}let output_18: key = (if v_778 then 3-proj-3-tuple(v_777) else caught-fail) in
        {2241}let temp_k_18: key = (if v_778 then 2-proj-3-tuple(v_777) else caught-fail) in
        {2242}let ck_116: key = (if v_778 then 1-proj-3-tuple(v_777) else caught-fail) in
        {2243}let ss_108: symmetricstate = (if v_771 then catch-fail((if v_774 then (if v_776 then (if v_778 then symmetricstatepack(cipherstatepack(temp_k_18,minnonce),ck_116,h_97) else fail-any) else fail-any) else fail-any)) else caught-fail) in
        {2244}let v_779: bool = not-caught-fail(ss_108) in
        {2245}let v_780: bitstring = (if v_779 then catch-fail(symmetricstateunpack(ss_108)) else caught-fail) in
        {2246}let v_781: bool = (not-caught-fail(v_780) && success?(1-proj-3-tuple(v_780))) in
        {2247}let h_98: bitstring = (if v_781 then 3-proj-3-tuple(v_780) else caught-fail) in
        {2248}let ck_117: key = (if v_781 then 2-proj-3-tuple(v_780) else caught-fail) in
        {2249}let cs_98: cipherstate = (if v_781 then 1-proj-3-tuple(v_780) else caught-fail) in
        {2250}let v_782: bitstring = (if v_781 then catch-fail(cipherstateunpack(cs_98)) else caught-fail) in
        {2251}let v_783: bool = (not-caught-fail(v_782) && success?(1-proj-2-tuple(v_782))) in
        {2252}let n_60: nonce = (if v_783 then 2-proj-2-tuple(v_782) else caught-fail) in
        {2253}let k_64: key = (if v_783 then 1-proj-2-tuple(v_782) else caught-fail) in
        {2256}let v_784: bitstring = (if v_783 then catch-fail(cipherstateunpack(cs_98)) else caught-fail) in
        {2257}let v_785: bool = (not-caught-fail(v_784) && success?(1-proj-2-tuple(v_784))) in
        {2258}let o_30: nonce = (if v_785 then 2-proj-2-tuple(v_784) else caught-fail) in
        {2259}let k_65: key = (if v_785 then 1-proj-2-tuple(v_784) else caught-fail) in
        {2255}let n_61: nonce = (if v_783 then increment_nonce(n_60) else caught-fail) in
        {2260}let csi_60: cipherstate = (if v_783 then catch-fail((if v_785 then cipherstatepack(k_65,n_61) else fail-any)) else caught-fail) in
        {2261}let v_786: bool = not-caught-fail(csi_60) in
        {2049}let payload_6: bitstring = msg_b(me_3,them_3,sid_4) in
        {2254}let e_37: bitstring = (if v_783 then encrypt(k_64,n_60,h_98,payload_6) else caught-fail) in
        {2262}let v_787: bitstring = (if v_781 then catch-fail((if v_783 then (if v_786 then (csi_60,e_37) else fail-any) else fail-any)) else caught-fail) in
        {2263}let v_788: bool = (not-caught-fail(v_787) && success?(1-proj-2-tuple(v_787))) in
        {2264}let ciphertext_36: bitstring = (if v_788 then 2-proj-2-tuple(v_787) else caught-fail) in
        {2265}let csi_61: cipherstate = (if v_788 then 1-proj-2-tuple(v_787) else caught-fail) in
        {2266}let ss_109: symmetricstate = (if v_788 then symmetricstatepack(csi_61,ck_117,h_98) else caught-fail) in
        {2267}let v_789: bitstring = (if v_788 then catch-fail(symmetricstateunpack(ss_109)) else caught-fail) in
        {2268}let v_790: bool = (not-caught-fail(v_789) && success?(1-proj-3-tuple(v_789))) in
        {2269}let h_99: bitstring = (if v_790 then 3-proj-3-tuple(v_789) else caught-fail) in
        {2270}let ck_118: key = (if v_790 then 2-proj-3-tuple(v_789) else caught-fail) in
        {2271}let cs_99: cipherstate = (if v_790 then 1-proj-3-tuple(v_789) else caught-fail) in
        {2272}let ssi_33: symmetricstate = (if v_788 then catch-fail((if v_790 then symmetricstatepack(cs_99,ck_118,hash(h_99,ciphertext_36)) else fail-any)) else caught-fail) in
        {2273}let v_791: bool = not-caught-fail(ssi_33) in
        {2274}let v_792: bitstring = (if v_779 then catch-fail((if v_781 then (if v_788 then (if v_791 then (ssi_33,ciphertext_36) else fail-any) else fail-any) else fail-any)) else caught-fail) in
        {2275}let v_793: bool = (not-caught-fail(v_792) && success?(1-proj-2-tuple(v_792))) in
        {2276}let ciphertext_37: bitstring = (if v_793 then 2-proj-2-tuple(v_792) else caught-fail) in
        {2277}let ss_110: symmetricstate = (if v_793 then 1-proj-2-tuple(v_792) else caught-fail) in
        {2278}let v_794: bitstring = (if v_793 then catch-fail(keypairunpack(m_21)) else caught-fail) in
        {2279}let v_795: bool = (not-caught-fail(v_794) && success?(1-proj-2-tuple(v_794))) in
        {2280}let my_private_key_19: key = (if v_795 then 2-proj-2-tuple(v_794) else caught-fail) in
        {2281}let my_public_key_19: key = (if v_795 then 1-proj-2-tuple(v_794) else caught-fail) in
        {2282}let input_key_material_22: key = (if v_793 then catch-fail((if v_795 then dhexp(my_private_key_19,re_21) else fail-any)) else caught-fail) in
        {2283}let v_796: bool = not-caught-fail(input_key_material_22) in
        {2284}let v_797: bitstring = (if v_796 then catch-fail(symmetricstateunpack(ss_110)) else caught-fail) in
        {2285}let v_798: bool = (not-caught-fail(v_797) && success?(1-proj-3-tuple(v_797))) in
        {2286}let h_100: bitstring = (if v_798 then 3-proj-3-tuple(v_797) else caught-fail) in
        {2287}let ck_119: key = (if v_798 then 2-proj-3-tuple(v_797) else caught-fail) in
        {2288}let cs_100: cipherstate = (if v_798 then 1-proj-3-tuple(v_797) else caught-fail) in
        {2291}let output3_22: key = (if v_798 then hmac_hash3(ck_119,input_key_material_22) else caught-fail) in
        {2290}let output2_22: key = (if v_798 then hmac_hash2(ck_119,input_key_material_22) else caught-fail) in
        {2289}let output1_22: key = (if v_798 then hmac_hash1(ck_119,input_key_material_22) else caught-fail) in
        {2292}let v_799: bitstring = (if v_798 then catch-fail((output1_22,output2_22,output3_22)) else caught-fail) in
        {2293}let v_800: bool = (not-caught-fail(v_799) && success?(1-proj-3-tuple(v_799))) in
        {2294}let output_19: key = (if v_800 then 3-proj-3-tuple(v_799) else caught-fail) in
        {2295}let temp_k_19: key = (if v_800 then 2-proj-3-tuple(v_799) else caught-fail) in
        {2296}let ck_120: key = (if v_800 then 1-proj-3-tuple(v_799) else caught-fail) in
        {2297}let ss_111: symmetricstate = (if v_793 then catch-fail((if v_796 then (if v_798 then (if v_800 then symmetricstatepack(cipherstatepack(temp_k_19,minnonce),ck_120,h_100) else fail-any) else fail-any) else fail-any)) else caught-fail) in
        {2298}let v_801: bool = not-caught-fail(ss_111) in
        {2299}let v_802: bitstring = (if v_801 then catch-fail(symmetricstateunpack(ss_111)) else caught-fail) in
        {2300}let v_803: bool = (not-caught-fail(v_802) && success?(1-proj-3-tuple(v_802))) in
        {2301}let h_101: bitstring = (if v_803 then 3-proj-3-tuple(v_802) else caught-fail) in
        {2302}let ck_121: key = (if v_803 then 2-proj-3-tuple(v_802) else caught-fail) in
        {2303}let cs_101: cipherstate = (if v_803 then 1-proj-3-tuple(v_802) else caught-fail) in
        {2304}let v_804: bitstring = (if v_803 then catch-fail(cipherstateunpack(cs_101)) else caught-fail) in
        {2305}let v_805: bool = (not-caught-fail(v_804) && success?(1-proj-2-tuple(v_804))) in
        {2306}let n_62: nonce = (if v_805 then 2-proj-2-tuple(v_804) else caught-fail) in
        {2307}let k_66: key = (if v_805 then 1-proj-2-tuple(v_804) else caught-fail) in
        {2310}let v_806: bitstring = (if v_805 then catch-fail(cipherstateunpack(cs_101)) else caught-fail) in
        {2311}let v_807: bool = (not-caught-fail(v_806) && success?(1-proj-2-tuple(v_806))) in
        {2312}let o_31: nonce = (if v_807 then 2-proj-2-tuple(v_806) else caught-fail) in
        {2313}let k_67: key = (if v_807 then 1-proj-2-tuple(v_806) else caught-fail) in
        {2309}let n_63: nonce = (if v_805 then increment_nonce(n_62) else caught-fail) in
        {2314}let csi_62: cipherstate = (if v_805 then catch-fail((if v_807 then cipherstatepack(k_67,n_63) else fail-any)) else caught-fail) in
        {2315}let v_808: bool = not-caught-fail(csi_62) in
        {2308}let e_38: bitstring = (if v_805 then encrypt(k_66,n_62,h_101,payload_6) else caught-fail) in
        {2316}let v_809: bitstring = (if v_803 then catch-fail((if v_805 then (if v_808 then (csi_62,e_38) else fail-any) else fail-any)) else caught-fail) in
        {2317}let v_810: bool = (not-caught-fail(v_809) && success?(1-proj-2-tuple(v_809))) in
        {2318}let ciphertext_38: bitstring = (if v_810 then 2-proj-2-tuple(v_809) else caught-fail) in
        {2319}let csi_63: cipherstate = (if v_810 then 1-proj-2-tuple(v_809) else caught-fail) in
        {2320}let ss_112: symmetricstate = (if v_810 then symmetricstatepack(csi_63,ck_121,h_101) else caught-fail) in
        {2321}let v_811: bitstring = (if v_810 then catch-fail(symmetricstateunpack(ss_112)) else caught-fail) in
        {2322}let v_812: bool = (not-caught-fail(v_811) && success?(1-proj-3-tuple(v_811))) in
        {2323}let h_102: bitstring = (if v_812 then 3-proj-3-tuple(v_811) else caught-fail) in
        {2324}let ck_122: key = (if v_812 then 2-proj-3-tuple(v_811) else caught-fail) in
        {2325}let cs_102: cipherstate = (if v_812 then 1-proj-3-tuple(v_811) else caught-fail) in
        {2326}let ssi_34: symmetricstate = (if v_810 then catch-fail((if v_812 then symmetricstatepack(cs_102,ck_122,hash(h_102,ciphertext_38)) else fail-any)) else caught-fail) in
        {2327}let v_813: bool = not-caught-fail(ssi_34) in
        {2328}let v_814: bitstring = (if v_801 then catch-fail((if v_803 then (if v_810 then (if v_813 then (ssi_34,ciphertext_38) else fail-any) else fail-any) else fail-any)) else caught-fail) in
        {2329}let v_815: bool = (not-caught-fail(v_814) && success?(1-proj-2-tuple(v_814))) in
        {2330}let ciphertext_39: bitstring = (if v_815 then 2-proj-2-tuple(v_814) else caught-fail) in
        {2331}let ss_113: symmetricstate = (if v_815 then 1-proj-2-tuple(v_814) else caught-fail) in
        {2334}let v_816: bitstring = (if v_815 then catch-fail(symmetricstateunpack(ss_113)) else caught-fail) in
        {2335}let v_817: bool = (not-caught-fail(v_816) && success?(1-proj-3-tuple(v_816))) in
        {2336}let h_103: bitstring = (if v_817 then 3-proj-3-tuple(v_816) else caught-fail) in
        {2337}let ck_123: key = (if v_817 then 2-proj-3-tuple(v_816) else caught-fail) in
        {2338}let cs_103: cipherstate = (if v_817 then 1-proj-3-tuple(v_816) else caught-fail) in
        {2339}let input_key_material_23: key = (if v_817 then zero else caught-fail) in
        {2342}let output3_23: key = (if v_817 then hmac_hash3(ck_123,input_key_material_23) else caught-fail) in
        {2341}let output2_23: key = (if v_817 then hmac_hash2(ck_123,input_key_material_23) else caught-fail) in
        {2340}let output1_23: key = (if v_817 then hmac_hash1(ck_123,input_key_material_23) else caught-fail) in
        {2343}let v_818: bitstring = (if v_817 then catch-fail((output1_23,output2_23,output3_23)) else caught-fail) in
        {2344}let v_819: bool = (not-caught-fail(v_818) && success?(1-proj-3-tuple(v_818))) in
        {2345}let temp_k3_3: key = (if v_819 then 3-proj-3-tuple(v_818) else caught-fail) in
        {2346}let temp_k2_3: key = (if v_819 then 2-proj-3-tuple(v_818) else caught-fail) in
        {2347}let temp_k1_3: key = (if v_819 then 1-proj-3-tuple(v_818) else caught-fail) in
        {2349}let cs2_15: cipherstate = (if v_819 then cipherstatepack(temp_k2_3,minnonce) else caught-fail) in
        {2348}let cs1_15: cipherstate = (if v_819 then cipherstatepack(temp_k1_3,minnonce) else caught-fail) in
        {2350}let v_820: bitstring = (if v_815 then catch-fail((if v_817 then (if v_819 then (ss_113,cs1_15,cs2_15) else fail-any) else fail-any)) else caught-fail) in
        {2351}let v_821: bool = (not-caught-fail(v_820) && success?(1-proj-3-tuple(v_820))) in
        {2352}let cs2_16: cipherstate = (if v_821 then 3-proj-3-tuple(v_820) else caught-fail) in
        {2353}let cs1_16: cipherstate = (if v_821 then 2-proj-3-tuple(v_820) else caught-fail) in
        {2354}let ssi_35: symmetricstate = (if v_821 then 1-proj-3-tuple(v_820) else caught-fail) in
        {2333}let message_buffer_6: bitstring = (if v_815 then concat4(ne_25,ns_17,nm_17,ciphertext_39) else caught-fail) in
        {2332}let hs_50: handshakestate = (if v_815 then handshakestatepack(ss_113,s_21,m_21,e_34,rs_21,rm_21,re_21,psk_17,initiator_14) else caught-fail) in
        {2355}let (hs_51: handshakestate,message_b_3: bitstring,cs1_17: cipherstate,cs2_17: cipherstate) = (if v_705 then (if v_707 then (if v_709 then (if v_710 then (if v_713 then (if v_721 then (if v_729 then (if v_737 then (if v_739 then (if v_754 then (if v_756 then (if v_771 then (if v_779 then (if v_793 then (if v_801 then (if v_815 then (if v_821 then (hs_50,message_buffer_6,cs1_16,cs2_16) else fail-any) else fail-any) else fail-any) else fail-any) else fail-any) else fail-any) else fail-any) else fail-any) else fail-any) else fail-any) else fail-any) else fail-any) else fail-any) else fail-any) else fail-any) else fail-any) else fail-any) in
        {2356}event SendMsg(me_3,them_3,stagepack_b(sid_4),msg_b(me_3,them_3,sid_4));
        {2357}insert statestore(me_3,them_3,sid_4,statepack_c(hs_51,cs1_17,cs2_17));
        {2358}out(pub, message_b_3)
    ) | (
        {2360}!
        {2427}get statestore(=me_3,=them_3,=sid_4,statepack_c(hs_52: handshakestate,cs1_18: cipherstate,cs2_18: cipherstate)) in
        {2361}let hs_53: handshakestate = handshakestatesetcs(hs_52,cs1_18) in
        {2362}in(pub, message_c_3: bitstring);
        {2363}let v_822: bitstring = catch-fail(handshakestateunpack(hs_53)) in
        {2364}let v_823: bool = (not-caught-fail(v_822) && success?(1-proj-9-tuple(v_822))) in
        {2365}let initiator_15: bool = (if v_823 then 9-proj-9-tuple(v_822) else caught-fail) in
        {2366}let psk_18: key = (if v_823 then 8-proj-9-tuple(v_822) else caught-fail) in
        {2367}let re_22: key = (if v_823 then 7-proj-9-tuple(v_822) else caught-fail) in
        {2368}let rm_22: key = (if v_823 then 6-proj-9-tuple(v_822) else caught-fail) in
        {2369}let rs_22: key = (if v_823 then 5-proj-9-tuple(v_822) else caught-fail) in
        {2370}let e_39: keypair = (if v_823 then 4-proj-9-tuple(v_822) else caught-fail) in
        {2371}let m_22: keypair = (if v_823 then 3-proj-9-tuple(v_822) else caught-fail) in
        {2372}let s_22: keypair = (if v_823 then 2-proj-9-tuple(v_822) else caught-fail) in
        {2373}let ss_114: symmetricstate = (if v_823 then 1-proj-9-tuple(v_822) else caught-fail) in
        {2374}let v_824: bitstring = (if v_823 then catch-fail(deconcat4(message_c_3)) else caught-fail) in
        {2375}let v_825: bool = (not-caught-fail(v_824) && success?(1-proj-4-tuple(v_824))) in
        {2376}let ciphertext_40: bitstring = (if v_825 then 4-proj-4-tuple(v_824) else caught-fail) in
        {2377}let nm_18: bitstring = (if v_825 then 3-proj-4-tuple(v_824) else caught-fail) in
        {2378}let ns_18: bitstring = (if v_825 then 2-proj-4-tuple(v_824) else caught-fail) in
        {2379}let ne_26: bitstring = (if v_825 then 1-proj-4-tuple(v_824) else caught-fail) in
        {2381}let v_826: bitstring = (if v_825 then catch-fail(symmetricstateunpack(ss_114)) else caught-fail) in
        {2382}let v_827: bool = (not-caught-fail(v_826) && success?(1-proj-3-tuple(v_826))) in
        {2383}let h_104: bitstring = (if v_827 then 3-proj-3-tuple(v_826) else caught-fail) in
        {2384}let ck_124: key = (if v_827 then 2-proj-3-tuple(v_826) else caught-fail) in
        {2385}let cs_104: cipherstate = (if v_827 then 1-proj-3-tuple(v_826) else caught-fail) in
        {2386}let v_828: bitstring = (if v_827 then catch-fail(cipherstateunpack(cs_104)) else caught-fail) in
        {2387}let v_829: bool = (not-caught-fail(v_828) && success?(1-proj-2-tuple(v_828))) in
        {2388}let n_64: nonce = (if v_829 then 2-proj-2-tuple(v_828) else caught-fail) in
        {2389}let k_68: key = (if v_829 then 1-proj-2-tuple(v_828) else caught-fail) in
        {2390}let d_15: aead = (if v_829 then catch-fail(decrypt(k_68,n_64,h_104,ciphertext_40)) else caught-fail) in
        {2391}let v_830: bool = not-caught-fail(d_15) in
        {2392}let v_831: bitstring = (if v_830 then catch-fail(aeadunpack(d_15)) else caught-fail) in
        {2393}let v_832: bool = (not-caught-fail(v_831) && success?(1-proj-3-tuple(v_831))) in
        {2394}let plaintext_45: bitstring = (if v_832 then 3-proj-3-tuple(v_831) else caught-fail) in
        {2395}let adi_15: bitstring = (if v_832 then 2-proj-3-tuple(v_831) else caught-fail) in
        {2396}let valid_37: bool = (if v_832 then 1-proj-3-tuple(v_831) else caught-fail) in
        {2398}let v_833: bitstring = (if v_832 then catch-fail(cipherstateunpack(cs_104)) else caught-fail) in
        {2399}let v_834: bool = (not-caught-fail(v_833) && success?(1-proj-2-tuple(v_833))) in
        {2400}let o_32: nonce = (if v_834 then 2-proj-2-tuple(v_833) else caught-fail) in
        {2401}let k_69: key = (if v_834 then 1-proj-2-tuple(v_833) else caught-fail) in
        {2397}let n_65: nonce = (if v_832 then increment_nonce(n_64) else caught-fail) in
        {2402}let csi_64: cipherstate = (if v_832 then catch-fail((if v_834 then cipherstatepack(k_69,n_65) else fail-any)) else caught-fail) in
        {2403}let v_835: bool = not-caught-fail(csi_64) in
        {2404}let v_836: bitstring = (if v_827 then catch-fail((if v_829 then (if v_830 then (if v_832 then (if v_835 then (csi_64,plaintext_45,valid_37) else fail-any) else fail-any) else fail-any) else fail-any)) else caught-fail) in
        {2405}let v_837: bool = (not-caught-fail(v_836) && success?(1-proj-3-tuple(v_836))) in
        {2406}let valid_38: bool = (if v_837 then 3-proj-3-tuple(v_836) else caught-fail) in
        {2407}let plaintext_46: bitstring = (if v_837 then 2-proj-3-tuple(v_836) else caught-fail) in
        {2408}let csi_65: cipherstate = (if v_837 then 1-proj-3-tuple(v_836) else caught-fail) in
        {2409}let ss_115: symmetricstate = (if v_837 then symmetricstatepack(csi_65,ck_124,h_104) else caught-fail) in
        {2410}let v_838: bitstring = (if v_837 then catch-fail(symmetricstateunpack(ss_115)) else caught-fail) in
        {2411}let v_839: bool = (not-caught-fail(v_838) && success?(1-proj-3-tuple(v_838))) in
        {2412}let h_105: bitstring = (if v_839 then 3-proj-3-tuple(v_838) else caught-fail) in
        {2413}let ck_125: key = (if v_839 then 2-proj-3-tuple(v_838) else caught-fail) in
        {2414}let cs_105: cipherstate = (if v_839 then 1-proj-3-tuple(v_838) else caught-fail) in
        {2415}let ssi_36: symmetricstate = (if v_837 then catch-fail((if v_839 then symmetricstatepack(cs_105,ck_125,hash(h_105,ciphertext_40)) else fail-any)) else caught-fail) in
        {2416}let v_840: bool = not-caught-fail(ssi_36) in
        {2417}let v_841: bitstring = (if v_825 then catch-fail((if v_827 then (if v_837 then (if v_840 then (ssi_36,plaintext_46,valid_38) else fail-any) else fail-any) else fail-any)) else caught-fail) in
        {2418}let v_842: bool = (not-caught-fail(v_841) && success?(1-proj-3-tuple(v_841))) in
        {2419}let valid2_11: bool = (if v_842 then 3-proj-3-tuple(v_841) else caught-fail) in
        {2420}let plaintext_47: bitstring = (if v_842 then 2-proj-3-tuple(v_841) else caught-fail) in
        {2421}let ss_116: symmetricstate = (if v_842 then 1-proj-3-tuple(v_841) else caught-fail) in
        {2380}let valid1_11: bool = (if v_825 then true else caught-fail) in
        {2422}let v_843: bool = (if v_842 then catch-fail((valid1_11 && valid2_11)) else caught-fail) in
        {2423}let hs_54: handshakestate = (if v_843 then handshakestatepack(ss_116,s_22,m_22,e_39,rs_22,rm_22,re_22,psk_18,initiator_15) else caught-fail) in
        {2424}let (hs_55: handshakestate,plaintext_c_1: bitstring,valid_39: bool) = (if v_823 then (if v_825 then (if v_842 then (if undo-catch-fail(v_843) then (hs_54,plaintext_47,true) else fail-any) else fail-any) else fail-any) else fail-any) in
        {2425}event RecvMsg(me_3,them_3,stagepack_c(sid_4),plaintext_c_1);
        {2426}insert statestore(me_3,them_3,sid_4,statepack_d(hs_55,handshakestategetcs(hs_55),cs2_18))
    ) | (
        {2428}!
        {2486}get statestore(=me_3,=them_3,=sid_4,statepack_d(hs_56: handshakestate,cs1_19: cipherstate,cs2_19: cipherstate)) in
        {2429}let hs_57: handshakestate = handshakestatesetcs(hs_56,cs2_19) in
        {2431}let v_844: bitstring = catch-fail(handshakestateunpack(hs_57)) in
        {2432}let v_845: bool = (not-caught-fail(v_844) && success?(1-proj-9-tuple(v_844))) in
        {2433}let initiator_16: bool = (if v_845 then 9-proj-9-tuple(v_844) else caught-fail) in
        {2434}let psk_19: key = (if v_845 then 8-proj-9-tuple(v_844) else caught-fail) in
        {2435}let re_23: key = (if v_845 then 7-proj-9-tuple(v_844) else caught-fail) in
        {2436}let rm_23: key = (if v_845 then 6-proj-9-tuple(v_844) else caught-fail) in
        {2437}let rs_23: key = (if v_845 then 5-proj-9-tuple(v_844) else caught-fail) in
        {2438}let e_40: keypair = (if v_845 then 4-proj-9-tuple(v_844) else caught-fail) in
        {2439}let m_23: keypair = (if v_845 then 3-proj-9-tuple(v_844) else caught-fail) in
        {2440}let s_23: keypair = (if v_845 then 2-proj-9-tuple(v_844) else caught-fail) in
        {2441}let ss_117: symmetricstate = (if v_845 then 1-proj-9-tuple(v_844) else caught-fail) in
        {2442}let v_846: bitstring = (if v_845 then catch-fail((empty,empty,empty,empty)) else caught-fail) in
        {2443}let v_847: bool = (not-caught-fail(v_846) && success?(1-proj-4-tuple(v_846))) in
        {2444}let ciphertext_41: bitstring = (if v_847 then 4-proj-4-tuple(v_846) else caught-fail) in
        {2445}let nm_19: bitstring = (if v_847 then 3-proj-4-tuple(v_846) else caught-fail) in
        {2446}let ns_19: bitstring = (if v_847 then 2-proj-4-tuple(v_846) else caught-fail) in
        {2447}let ne_27: bitstring = (if v_847 then 1-proj-4-tuple(v_846) else caught-fail) in
        {2448}let v_848: bitstring = (if v_847 then catch-fail(symmetricstateunpack(ss_117)) else caught-fail) in
        {2449}let v_849: bool = (not-caught-fail(v_848) && success?(1-proj-3-tuple(v_848))) in
        {2450}let h_106: bitstring = (if v_849 then 3-proj-3-tuple(v_848) else caught-fail) in
        {2451}let ck_126: key = (if v_849 then 2-proj-3-tuple(v_848) else caught-fail) in
        {2452}let cs_106: cipherstate = (if v_849 then 1-proj-3-tuple(v_848) else caught-fail) in
        {2453}let v_850: bitstring = (if v_849 then catch-fail(cipherstateunpack(cs_106)) else caught-fail) in
        {2454}let v_851: bool = (not-caught-fail(v_850) && success?(1-proj-2-tuple(v_850))) in
        {2455}let n_66: nonce = (if v_851 then 2-proj-2-tuple(v_850) else caught-fail) in
        {2456}let k_70: key = (if v_851 then 1-proj-2-tuple(v_850) else caught-fail) in
        {2459}let v_852: bitstring = (if v_851 then catch-fail(cipherstateunpack(cs_106)) else caught-fail) in
        {2460}let v_853: bool = (not-caught-fail(v_852) && success?(1-proj-2-tuple(v_852))) in
        {2461}let o_33: nonce = (if v_853 then 2-proj-2-tuple(v_852) else caught-fail) in
        {2462}let k_71: key = (if v_853 then 1-proj-2-tuple(v_852) else caught-fail) in
        {2458}let n_67: nonce = (if v_851 then increment_nonce(n_66) else caught-fail) in
        {2463}let csi_66: cipherstate = (if v_851 then catch-fail((if v_853 then cipherstatepack(k_71,n_67) else fail-any)) else caught-fail) in
        {2464}let v_854: bool = not-caught-fail(csi_66) in
        {2430}let payload_7: bitstring = msg_d(me_3,them_3,sid_4) in
        {2457}let e_41: bitstring = (if v_851 then encrypt(k_70,n_66,h_106,payload_7) else caught-fail) in
        {2465}let v_855: bitstring = (if v_849 then catch-fail((if v_851 then (if v_854 then (csi_66,e_41) else fail-any) else fail-any)) else caught-fail) in
        {2466}let v_856: bool = (not-caught-fail(v_855) && success?(1-proj-2-tuple(v_855))) in
        {2467}let ciphertext_42: bitstring = (if v_856 then 2-proj-2-tuple(v_855) else caught-fail) in
        {2468}let csi_67: cipherstate = (if v_856 then 1-proj-2-tuple(v_855) else caught-fail) in
        {2469}let ss_118: symmetricstate = (if v_856 then symmetricstatepack(csi_67,ck_126,h_106) else caught-fail) in
        {2470}let v_857: bitstring = (if v_856 then catch-fail(symmetricstateunpack(ss_118)) else caught-fail) in
        {2471}let v_858: bool = (not-caught-fail(v_857) && success?(1-proj-3-tuple(v_857))) in
        {2472}let h_107: bitstring = (if v_858 then 3-proj-3-tuple(v_857) else caught-fail) in
        {2473}let ck_127: key = (if v_858 then 2-proj-3-tuple(v_857) else caught-fail) in
        {2474}let cs_107: cipherstate = (if v_858 then 1-proj-3-tuple(v_857) else caught-fail) in
        {2475}let ssi_37: symmetricstate = (if v_856 then catch-fail((if v_858 then symmetricstatepack(cs_107,ck_127,hash(h_107,ciphertext_42)) else fail-any)) else caught-fail) in
        {2476}let v_859: bool = not-caught-fail(ssi_37) in
        {2477}let v_860: bitstring = (if v_847 then catch-fail((if v_849 then (if v_856 then (if v_859 then (ssi_37,ciphertext_42) else fail-any) else fail-any) else fail-any)) else caught-fail) in
        {2478}let v_861: bool = (not-caught-fail(v_860) && success?(1-proj-2-tuple(v_860))) in
        {2479}let ciphertext_43: bitstring = (if v_861 then 2-proj-2-tuple(v_860) else caught-fail) in
        {2480}let ss_119: symmetricstate = (if v_861 then 1-proj-2-tuple(v_860) else caught-fail) in
        {2482}let message_buffer_7: bitstring = (if v_861 then concat4(ne_27,ns_19,nm_19,ciphertext_43) else caught-fail) in
        {2481}let hs_58: handshakestate = (if v_861 then handshakestatepack(ss_119,s_23,m_23,e_40,rs_23,rm_23,re_23,psk_19,initiator_16) else caught-fail) in
        {2483}let (hs_59: handshakestate,message_d_3: bitstring) = (if v_845 then (if v_847 then (if v_861 then (hs_58,message_buffer_7) else fail-any) else fail-any) else fail-any) in
        {2484}event SendMsg(me_3,them_3,stagepack_d(sid_4),msg_d(me_3,them_3,sid_4));
        {2485}out(pub, message_d_3)
    ) | (
        {2487}event LeakS(phase0,me_3);
        {2488}event LeakM(phase0,me_3);
        {2489}out(pub, (key_s(me_3),key_m(me_3)))
    ) | (
        {2490}phase 1;
        {2491}event LeakS(phase1,me_3);
        {2492}event LeakM(phase1,me_3);
        {2493}out(pub, (key_s(me_3),key_m(me_3)))
    )
)

-- Query event(RecvMsg(bob,alice,stagepack_a(sid_b),m_24)) ==> event(SendMsg(alice,bob,stagepack_a(sid_a),m_24)); event(RecvMsg(bob,alice,stagepack_a(sid_b),m_24)) ==> event(SendMsg(alice,c,stagepack_a(sid_a),m_24)) || (event(LeakS(phase0,alice)) && event(LeakM(phase0,alice))) || (event(LeakS(phase0,bob)) && event(LeakM(phase0,bob))); event(RecvMsg(bob,alice,stagepack_a(sid_b),m_24)) ==> event(SendMsg(alice,c,stagepack_a(sid_a),m_24)) || (event(LeakS(phase0,alice)) && event(LeakM(phase0,alice))); event(RecvMsg(bob,alice,stagepack_a(sid_b),m_24)) ==> event(SendMsg(alice,bob,stagepack_a(sid_a),m_24)) || (event(LeakS(phase0,alice)) && event(LeakM(phase0,alice))) || (event(LeakS(phase0,bob)) && event(LeakM(phase0,bob))); event(RecvMsg(bob,alice,stagepack_a(sid_b),m_24)) ==> event(SendMsg(alice,bob,stagepack_a(sid_a),m_24)) || (event(LeakS(phase0,alice)) && event(LeakM(phase0,alice))); not attacker_p1(msg_a(alice,bob,sid_a)); attacker_p1(msg_a(alice,bob,sid_a)) ==> event(LeakS(px,bob)) && event(LeakM(px,bob)); attacker_p1(msg_a(alice,bob,sid_a)) ==> (event(LeakS(phase0,bob)) && event(LeakM(phase0,bob))) || (event(LeakS(px,bob)) && event(LeakM(px,bob)) && event(LeakS(pz,alice)) && event(LeakM(pz,alice))); attacker_p1(msg_a(alice,bob,sid_a)) ==> event(LeakS(phase0,bob)) && event(LeakM(phase0,bob)); event(RecvMsg(alice,bob,stagepack_b(sid_a),m_24)) ==> event(SendMsg(bob,alice,stagepack_b(sid_b),m_24)); event(RecvMsg(alice,bob,stagepack_b(sid_a),m_24)) ==> event(SendMsg(bob,c,stagepack_b(sid_b),m_24)) || (event(LeakS(phase0,bob)) && event(LeakM(phase0,bob))) || (event(LeakS(phase0,alice)) && event(LeakM(phase0,alice))); event(RecvMsg(alice,bob,stagepack_b(sid_a),m_24)) ==> event(SendMsg(bob,c,stagepack_b(sid_b),m_24)) || (event(LeakS(phase0,bob)) && event(LeakM(phase0,bob))); event(RecvMsg(alice,bob,stagepack_b(sid_a),m_24)) ==> event(SendMsg(bob,alice,stagepack_b(sid_b),m_24)) || (event(LeakS(phase0,bob)) && event(LeakM(phase0,bob))) || (event(LeakS(phase0,alice)) && event(LeakM(phase0,alice))); event(RecvMsg(alice,bob,stagepack_b(sid_a),m_24)) ==> event(SendMsg(bob,alice,stagepack_b(sid_b),m_24)) || (event(LeakS(phase0,bob)) && event(LeakM(phase0,bob))); not attacker_p1(msg_b(bob,alice,sid_b)); attacker_p1(msg_b(bob,alice,sid_b)) ==> event(LeakS(px,alice)) && event(LeakM(px,alice)); attacker_p1(msg_b(bob,alice,sid_b)) ==> (event(LeakS(phase0,alice)) && event(LeakM(phase0,alice))) || (event(LeakS(px,alice)) && event(LeakM(px,alice)) && event(LeakS(pz,bob)) && event(LeakM(pz,bob))); attacker_p1(msg_b(bob,alice,sid_b)) ==> event(LeakS(phase0,alice)) && event(LeakM(phase0,alice)); event(RecvMsg(bob,alice,stagepack_c(sid_b),m_24)) ==> event(SendMsg(alice,bob,stagepack_c(sid_a),m_24)); event(RecvMsg(bob,alice,stagepack_c(sid_b),m_24)) ==> event(SendMsg(alice,c,stagepack_c(sid_a),m_24)) || (event(LeakS(phase0,alice)) && event(LeakM(phase0,alice))) || (event(LeakS(phase0,bob)) && event(LeakM(phase0,bob))); event(RecvMsg(bob,alice,stagepack_c(sid_b),m_24)) ==> event(SendMsg(alice,c,stagepack_c(sid_a),m_24)) || (event(LeakS(phase0,alice)) && event(LeakM(phase0,alice))); event(RecvMsg(bob,alice,stagepack_c(sid_b),m_24)) ==> event(SendMsg(alice,bob,stagepack_c(sid_a),m_24)) || (event(LeakS(phase0,alice)) && event(LeakM(phase0,alice))) || (event(LeakS(phase0,bob)) && event(LeakM(phase0,bob))); event(RecvMsg(bob,alice,stagepack_c(sid_b),m_24)) ==> event(SendMsg(alice,bob,stagepack_c(sid_a),m_24)) || (event(LeakS(phase0,alice)) && event(LeakM(phase0,alice))); not attacker_p1(msg_c(alice,bob,sid_a)); attacker_p1(msg_c(alice,bob,sid_a)) ==> event(LeakS(px,bob)) && event(LeakM(px,bob)); attacker_p1(msg_c(alice,bob,sid_a)) ==> (event(LeakS(phase0,bob)) && event(LeakM(phase0,bob))) || (event(LeakS(px,bob)) && event(LeakM(px,bob)) && event(LeakS(pz,alice)) && event(LeakM(pz,alice))); attacker_p1(msg_c(alice,bob,sid_a)) ==> event(LeakS(phase0,bob)) && event(LeakM(phase0,bob)); event(RecvMsg(alice,bob,stagepack_d(sid_a),m_24)) ==> event(SendMsg(bob,alice,stagepack_d(sid_b),m_24)); event(RecvMsg(alice,bob,stagepack_d(sid_a),m_24)) ==> event(SendMsg(bob,c,stagepack_d(sid_b),m_24)) || (event(LeakS(phase0,bob)) && event(LeakM(phase0,bob))) || (event(LeakS(phase0,alice)) && event(LeakM(phase0,alice))); event(RecvMsg(alice,bob,stagepack_d(sid_a),m_24)) ==> event(SendMsg(bob,c,stagepack_d(sid_b),m_24)) || (event(LeakS(phase0,bob)) && event(LeakM(phase0,bob))); event(RecvMsg(alice,bob,stagepack_d(sid_a),m_24)) ==> event(SendMsg(bob,alice,stagepack_d(sid_b),m_24)) || (event(LeakS(phase0,bob)) && event(LeakM(phase0,bob))) || (event(LeakS(phase0,alice)) && event(LeakM(phase0,alice))); event(RecvMsg(alice,bob,stagepack_d(sid_a),m_24)) ==> event(SendMsg(bob,alice,stagepack_d(sid_b),m_24)) || (event(LeakS(phase0,bob)) && event(LeakM(phase0,bob))); not attacker_p1(msg_d(bob,alice,sid_b)); attacker_p1(msg_d(bob,alice,sid_b)) ==> event(LeakS(px,alice)) && event(LeakM(px,alice)); attacker_p1(msg_d(bob,alice,sid_b)) ==> (event(LeakS(phase0,alice)) && event(LeakM(phase0,alice))) || (event(LeakS(px,alice)) && event(LeakM(px,alice)) && event(LeakS(pz,bob)) && event(LeakM(pz,bob))); attacker_p1(msg_d(bob,alice,sid_b)) ==> event(LeakS(phase0,alice)) && event(LeakM(phase0,alice)); not event(RecvEnd(true)) in process 1.
Translating the process into Horn clauses...
Completing...
200 rules inserted. Base: 200 rules (87 with conclusion selected). Queue: 533 rules.
400 rules inserted. Base: 400 rules (103 with conclusion selected). Queue: 352 rules.
600 rules inserted. Base: 600 rules (106 with conclusion selected). Queue: 157 rules.
800 rules inserted. Base: 795 rules (153 with conclusion selected). Queue: 147 rules.
1000 rules inserted. Base: 987 rules (311 with conclusion selected). Queue: 297 rules.
1200 rules inserted. Base: 1174 rules (419 with conclusion selected). Queue: 231 rules.
1400 rules inserted. Base: 1354 rules (459 with conclusion selected). Queue: 262 rules.
1600 rules inserted. Base: 1547 rules (463 with conclusion selected). Queue: 277 rules.
1800 rules inserted. Base: 1712 rules (465 with conclusion selected). Queue: 248 rules.
2000 rules inserted. Base: 1842 rules (469 with conclusion selected). Queue: 153 rules.
2200 rules inserted. Base: 1895 rules (475 with conclusion selected). Queue: 158 rules.
2400 rules inserted. Base: 1985 rules (475 with conclusion selected). Queue: 215 rules.
2600 rules inserted. Base: 2033 rules (475 with conclusion selected). Queue: 274 rules.
2800 rules inserted. Base: 2074 rules (475 with conclusion selected). Queue: 335 rules.
3000 rules inserted. Base: 2154 rules (475 with conclusion selected). Queue: 385 rules.
3200 rules inserted. Base: 2225 rules (475 with conclusion selected). Queue: 460 rules.
3400 rules inserted. Base: 2289 rules (475 with conclusion selected). Queue: 548 rules.
3600 rules inserted. Base: 2346 rules (475 with conclusion selected). Queue: 618 rules.
3800 rules inserted. Base: 2391 rules (475 with conclusion selected). Queue: 681 rules.
4000 rules inserted. Base: 2440 rules (475 with conclusion selected). Queue: 741 rules.
4200 rules inserted. Base: 2488 rules (475 with conclusion selected). Queue: 812 rules.
4400 rules inserted. Base: 2537 rules (475 with conclusion selected). Queue: 884 rules.
4600 rules inserted. Base: 2581 rules (475 with conclusion selected). Queue: 955 rules.
4800 rules inserted. Base: 2633 rules (475 with conclusion selected). Queue: 1028 rules.
5000 rules inserted. Base: 2677 rules (475 with conclusion selected). Queue: 1081 rules.
5200 rules inserted. Base: 2724 rules (475 with conclusion selected). Queue: 1125 rules.
5400 rules inserted. Base: 2780 rules (475 with conclusion selected). Queue: 1167 rules.
5600 rules inserted. Base: 2832 rules (475 with conclusion selected). Queue: 1219 rules.
5800 rules inserted. Base: 2881 rules (475 with conclusion selected). Queue: 1260 rules.
6000 rules inserted. Base: 2917 rules (475 with conclusion selected). Queue: 1318 rules.
6200 rules inserted. Base: 2949 rules (475 with conclusion selected). Queue: 1366 rules.
6400 rules inserted. Base: 2975 rules (475 with conclusion selected). Queue: 1381 rules.
6600 rules inserted. Base: 3007 rules (475 with conclusion selected). Queue: 1443 rules.
6800 rules inserted. Base: 3042 rules (475 with conclusion selected). Queue: 1485 rules.
7000 rules inserted. Base: 3075 rules (475 with conclusion selected). Queue: 1515 rules.
7200 rules inserted. Base: 3108 rules (475 with conclusion selected). Queue: 1558 rules.
7400 rules inserted. Base: 3153 rules (475 with conclusion selected). Queue: 1620 rules.
7600 rules inserted. Base: 3196 rules (475 with conclusion selected). Queue: 1622 rules.
7800 rules inserted. Base: 3235 rules (475 with conclusion selected). Queue: 1616 rules.
8000 rules inserted. Base: 3274 rules (475 with conclusion selected). Queue: 1672 rules.
8200 rules inserted. Base: 3318 rules (475 with conclusion selected). Queue: 1729 rules.
8400 rules inserted. Base: 3359 rules (475 with conclusion selected). Queue: 1719 rules.
8600 rules inserted. Base: 3399 rules (475 with conclusion selected). Queue: 1712 rules.
8800 rules inserted. Base: 3434 rules (475 with conclusion selected). Queue: 1714 rules.
9000 rules inserted. Base: 3476 rules (475 with conclusion selected). Queue: 1723 rules.
9200 rules inserted. Base: 3504 rules (475 with conclusion selected). Queue: 1707 rules.
9400 rules inserted. Base: 3537 rules (475 with conclusion selected). Queue: 1678 rules.
9600 rules inserted. Base: 3573 rules (475 with conclusion selected). Queue: 1676 rules.
9800 rules inserted. Base: 3613 rules (475 with conclusion selected). Queue: 1684 rules.
10000 rules inserted. Base: 3645 rules (475 with conclusion selected). Queue: 1669 rules.
10200 rules inserted. Base: 3676 rules (475 with conclusion selected). Queue: 1652 rules.
10400 rules inserted. Base: 3706 rules (475 with conclusion selected). Queue: 1619 rules.
10600 rules inserted. Base: 3730 rules (475 with conclusion selected). Queue: 1641 rules.
10800 rules inserted. Base: 3759 rules (475 with conclusion selected). Queue: 1610 rules.
11000 rules inserted. Base: 3780 rules (475 with conclusion selected). Queue: 1556 rules.
11200 rules inserted. Base: 3810 rules (475 with conclusion selected). Queue: 1519 rules.
11400 rules inserted. Base: 3835 rules (475 with conclusion selected). Queue: 1552 rules.
11600 rules inserted. Base: 3861 rules (475 with conclusion selected). Queue: 1505 rules.
11800 rules inserted. Base: 3879 rules (475 with conclusion selected). Queue: 1412 rules.
12000 rules inserted. Base: 3913 rules (475 with conclusion selected). Queue: 1375 rules.
12200 rules inserted. Base: 3952 rules (475 with conclusion selected). Queue: 1375 rules.
12400 rules inserted. Base: 3986 rules (475 with conclusion selected). Queue: 1285 rules.
12600 rules inserted. Base: 4009 rules (475 with conclusion selected). Queue: 1209 rules.
12800 rules inserted. Base: 4039 rules (475 with conclusion selected). Queue: 1195 rules.
13000 rules inserted. Base: 4077 rules (475 with conclusion selected). Queue: 1116 rules.
13200 rules inserted. Base: 4105 rules (475 with conclusion selected). Queue: 1031 rules.
13400 rules inserted. Base: 4129 rules (475 with conclusion selected). Queue: 971 rules.
13600 rules inserted. Base: 4170 rules (475 with conclusion selected). Queue: 879 rules.
13800 rules inserted. Base: 4196 rules (475 with conclusion selected). Queue: 800 rules.
14000 rules inserted. Base: 4234 rules (475 with conclusion selected). Queue: 701 rules.
14200 rules inserted. Base: 4261 rules (475 with conclusion selected). Queue: 588 rules.
14400 rules inserted. Base: 4303 rules (475 with conclusion selected). Queue: 478 rules.
14600 rules inserted. Base: 4327 rules (475 with conclusion selected). Queue: 356 rules.
14800 rules inserted. Base: 4372 rules (475 with conclusion selected). Queue: 203 rules.
15000 rules inserted. Base: 4408 rules (475 with conclusion selected). Queue: 28 rules.
Starting query event(RecvMsg(bob,alice,stagepack_a(sid_b),m_24)) ==> event(SendMsg(alice,bob,stagepack_a(sid_a),m_24))
goal reachable: begin(SendMsg(alice,charlie,stagepack_a(sid_5),msg_a(alice,charlie,sid_5))) -> end(RecvMsg(bob,alice,stagepack_a(sid_6),msg_a(alice,charlie,sid_5)))
Abbreviations:
sid_6 = sid[!1 = @sid]
sid_5 = sid[!1 = @sid_1]

Derivation:
Abbreviations:
sid_5 = sid[!1 = @sid]
sid_6 = sid[!1 = @sid_1]

1. The entry statestore(bob,alice,sid_5,statepack_a(handshakestatepack(symmetricstatepack(cipherstatepack(empty,minnonce),hash(somename,empty),hash(hash(somename,empty),empty)),keypairpack(empty,empty),keypairpack(validkey(dhexp_real(key_m(bob),g)),key_m(bob)),keypairpack(empty,empty),empty,empty,empty,empty,false))) may be inserted in a table at insert {1243}.
table(statestore(bob,alice,sid_5,statepack_a(handshakestatepack(symmetricstatepack(cipherstatepack(empty,minnonce),hash(somename,empty),hash(hash(somename,empty),empty)),keypairpack(empty,empty),keypairpack(validkey(dhexp_real(key_m(bob),g)),key_m(bob)),keypairpack(empty,empty),empty,empty,empty,empty,false)))).

2. The entry statestore(alice,charlie,sid_6,statepack_a(handshakestatepack(symmetricstatepack(cipherstatepack(empty,minnonce),hash(somename,empty),hash(hash(somename,empty),empty)),keypairpack(empty,empty),keypairpack(empty,empty),keypairpack(empty,empty),empty,empty,empty,empty,true))) may be inserted in a table at insert {635}.
table(statestore(alice,charlie,sid_6,statepack_a(handshakestatepack(symmetricstatepack(cipherstatepack(empty,minnonce),hash(somename,empty),hash(hash(somename,empty),empty)),keypairpack(empty,empty),keypairpack(empty,empty),keypairpack(empty,empty),empty,empty,empty,empty,true)))).

3. The entry statestore(alice,charlie,sid_6,statepack_a(handshakestatepack(symmetricstatepack(cipherstatepack(empty,minnonce),hash(somename,empty),hash(hash(somename,empty),empty)),keypairpack(empty,empty),keypairpack(empty,empty),keypairpack(empty,empty),empty,empty,empty,empty,true))) that may be in a table by 2 may be read at get {787}.
The event SendMsg(alice,charlie,stagepack_a(sid_6),msg_a(alice,charlie,sid_6)) may be executed at {784}.
So the message concat4(validkey(dhexp_real(key_e(alice,charlie,sid_6),g)),encrypt(empty,minnonce,hash(hash(hash(somename,empty),empty),validkey(dhexp_real(key_e(alice,charlie,sid_6),g))),validkey(dhexp_real(key_s(alice),g))),encrypt(empty,increment_nonce(minnonce),hash(hash(hash(hash(somename,empty),empty),validkey(dhexp_real(key_e(alice,charlie,sid_6),g))),encrypt(empty,minnonce,hash(hash(hash(somename,empty),empty),validkey(dhexp_real(key_e(alice,charlie,sid_6),g))),validkey(dhexp_real(key_s(alice),g)))),validkey(dhexp_real(key_m(alice),g))),encrypt(empty,increment_nonce(increment_nonce(minnonce)),hash(hash(hash(hash(hash(somename,empty),empty),validkey(dhexp_real(key_e(alice,charlie,sid_6),g))),encrypt(empty,minnonce,hash(hash(hash(somename,empty),empty),validkey(dhexp_real(key_e(alice,charlie,sid_6),g))),validkey(dhexp_real(key_s(alice),g)))),encrypt(empty,increment_nonce(minnonce),hash(hash(hash(hash(somename,empty),empty),validkey(dhexp_real(key_e(alice,charlie,sid_6),g))),encrypt(empty,minnonce,hash(hash(hash(somename,empty),empty),validkey(dhexp_real(key_e(alice,charlie,sid_6),g))),validkey(dhexp_real(key_s(alice),g)))),validkey(dhexp_real(key_m(alice),g)))),msg_a(alice,charlie,sid_6))) may be sent on channel pub at output {786}.
mess(pub,concat4(validkey(dhexp_real(key_e(alice,charlie,sid_6),g)),encrypt(empty,minnonce,hash(hash(hash(somename,empty),empty),validkey(dhexp_real(key_e(alice,charlie,sid_6),g))),validkey(dhexp_real(key_s(alice),g))),encrypt(empty,increment_nonce(minnonce),hash(hash(hash(hash(somename,empty),empty),validkey(dhexp_real(key_e(alice,charlie,sid_6),g))),encrypt(empty,minnonce,hash(hash(hash(somename,empty),empty),validkey(dhexp_real(key_e(alice,charlie,sid_6),g))),validkey(dhexp_real(key_s(alice),g)))),validkey(dhexp_real(key_m(alice),g))),encrypt(empty,increment_nonce(increment_nonce(minnonce)),hash(hash(hash(hash(hash(somename,empty),empty),validkey(dhexp_real(key_e(alice,charlie,sid_6),g))),encrypt(empty,minnonce,hash(hash(hash(somename,empty),empty),validkey(dhexp_real(key_e(alice,charlie,sid_6),g))),validkey(dhexp_real(key_s(alice),g)))),encrypt(empty,increment_nonce(minnonce),hash(hash(hash(hash(somename,empty),empty),validkey(dhexp_real(key_e(alice,charlie,sid_6),g))),encrypt(empty,minnonce,hash(hash(hash(somename,empty),empty),validkey(dhexp_real(key_e(alice,charlie,sid_6),g))),validkey(dhexp_real(key_s(alice),g)))),validkey(dhexp_real(key_m(alice),g)))),msg_a(alice,charlie,sid_6)))).

4. The entry statestore(bob,alice,sid_5,statepack_a(handshakestatepack(symmetricstatepack(cipherstatepack(empty,minnonce),hash(somename,empty),hash(hash(somename,empty),empty)),keypairpack(empty,empty),keypairpack(validkey(dhexp_real(key_m(bob),g)),key_m(bob)),keypairpack(empty,empty),empty,empty,empty,empty,false))) that may be in a table by 1 may be read at get {1408}.
The message concat4(validkey(dhexp_real(key_e(alice,charlie,sid_6),g)),encrypt(empty,minnonce,hash(hash(hash(somename,empty),empty),validkey(dhexp_real(key_e(alice,charlie,sid_6),g))),validkey(dhexp_real(key_s(alice),g))),encrypt(empty,increment_nonce(minnonce),hash(hash(hash(hash(somename,empty),empty),validkey(dhexp_real(key_e(alice,charlie,sid_6),g))),encrypt(empty,minnonce,hash(hash(hash(somename,empty),empty),validkey(dhexp_real(key_e(alice,charlie,sid_6),g))),validkey(dhexp_real(key_s(alice),g)))),validkey(dhexp_real(key_m(alice),g))),encrypt(empty,increment_nonce(increment_nonce(minnonce)),hash(hash(hash(hash(hash(somename,empty),empty),validkey(dhexp_real(key_e(alice,charlie,sid_6),g))),encrypt(empty,minnonce,hash(hash(hash(somename,empty),empty),validkey(dhexp_real(key_e(alice,charlie,sid_6),g))),validkey(dhexp_real(key_s(alice),g)))),encrypt(empty,increment_nonce(minnonce),hash(hash(hash(hash(somename,empty),empty),validkey(dhexp_real(key_e(alice,charlie,sid_6),g))),encrypt(empty,minnonce,hash(hash(hash(somename,empty),empty),validkey(dhexp_real(key_e(alice,charlie,sid_6),g))),validkey(dhexp_real(key_s(alice),g)))),validkey(dhexp_real(key_m(alice),g)))),msg_a(alice,charlie,sid_6))) that may be sent on channel pub by 3 may be received at input {1244}.
So event RecvMsg(bob,alice,stagepack_a(sid_5),msg_a(alice,charlie,sid_6)) may be executed at {1406}.
end(RecvMsg(bob,alice,stagepack_a(sid_5),msg_a(alice,charlie,sid_6))).

5. By 4, end(RecvMsg(bob,alice,stagepack_a(sid_5),msg_a(alice,charlie,sid_6))).
The goal is reached, represented in the following fact:
end(RecvMsg(bob,alice,stagepack_a(sid_5),msg_a(alice,charlie,sid_6))).


RESULT event(RecvMsg(bob,alice,stagepack_a(sid_b),m_24)) ==> event(SendMsg(alice,bob,stagepack_a(sid_a),m_24)) cannot be proved.
Starting query event(RecvMsg(bob,alice,stagepack_a(sid_b),m_24)) ==> event(SendMsg(alice,c,stagepack_a(sid_a),m_24)) || (event(LeakS(phase0,alice)) && event(LeakM(phase0,alice))) || (event(LeakS(phase0,bob)) && event(LeakM(phase0,bob)))
goal reachable: begin(SendMsg(alice,bob,stagepack_a(sid_5),msg_a(alice,bob,sid_5))) -> end(RecvMsg(bob,alice,stagepack_a(sid_6),msg_a(alice,bob,sid_5)))
Abbreviations:
sid_6 = sid[!1 = @sid]
sid_5 = sid[!1 = @sid_1]
goal reachable: begin(SendMsg(alice,charlie,stagepack_a(sid_5),msg_a(alice,charlie,sid_5))) -> end(RecvMsg(bob,alice,stagepack_a(sid_6),msg_a(alice,charlie,sid_5)))
Abbreviations:
sid_6 = sid[!1 = @sid]
sid_5 = sid[!1 = @sid_1]
RESULT event(RecvMsg(bob,alice,stagepack_a(sid_b),m_24)) ==> event(SendMsg(alice,c,stagepack_a(sid_a),m_24)) || (event(LeakS(phase0,alice)) && event(LeakM(phase0,alice))) || (event(LeakS(phase0,bob)) && event(LeakM(phase0,bob))) is true.
Starting query event(RecvMsg(bob,alice,stagepack_a(sid_b),m_24)) ==> event(SendMsg(alice,c,stagepack_a(sid_a),m_24)) || (event(LeakS(phase0,alice)) && event(LeakM(phase0,alice)))
goal reachable: begin(SendMsg(alice,bob,stagepack_a(sid_5),msg_a(alice,bob,sid_5))) -> end(RecvMsg(bob,alice,stagepack_a(sid_6),msg_a(alice,bob,sid_5)))
Abbreviations:
sid_6 = sid[!1 = @sid]
sid_5 = sid[!1 = @sid_1]
goal reachable: begin(SendMsg(alice,charlie,stagepack_a(sid_5),msg_a(alice,charlie,sid_5))) -> end(RecvMsg(bob,alice,stagepack_a(sid_6),msg_a(alice,charlie,sid_5)))
Abbreviations:
sid_6 = sid[!1 = @sid]
sid_5 = sid[!1 = @sid_1]
RESULT event(RecvMsg(bob,alice,stagepack_a(sid_b),m_24)) ==> event(SendMsg(alice,c,stagepack_a(sid_a),m_24)) || (event(LeakS(phase0,alice)) && event(LeakM(phase0,alice))) is true.
Starting query event(RecvMsg(bob,alice,stagepack_a(sid_b),m_24)) ==> event(SendMsg(alice,bob,stagepack_a(sid_a),m_24)) || (event(LeakS(phase0,alice)) && event(LeakM(phase0,alice))) || (event(LeakS(phase0,bob)) && event(LeakM(phase0,bob)))
goal reachable: begin(SendMsg(alice,charlie,stagepack_a(sid_5),msg_a(alice,charlie,sid_5))) -> end(RecvMsg(bob,alice,stagepack_a(sid_6),msg_a(alice,charlie,sid_5)))
Abbreviations:
sid_6 = sid[!1 = @sid]
sid_5 = sid[!1 = @sid_1]

Derivation:
Abbreviations:
sid_5 = sid[!1 = @sid]
sid_6 = sid[!1 = @sid_1]

1. The entry statestore(bob,alice,sid_5,statepack_a(handshakestatepack(symmetricstatepack(cipherstatepack(empty,minnonce),hash(somename,empty),hash(hash(somename,empty),empty)),keypairpack(empty,empty),keypairpack(validkey(dhexp_real(key_m(bob),g)),key_m(bob)),keypairpack(empty,empty),empty,empty,empty,empty,false))) may be inserted in a table at insert {1243}.
table(statestore(bob,alice,sid_5,statepack_a(handshakestatepack(symmetricstatepack(cipherstatepack(empty,minnonce),hash(somename,empty),hash(hash(somename,empty),empty)),keypairpack(empty,empty),keypairpack(validkey(dhexp_real(key_m(bob),g)),key_m(bob)),keypairpack(empty,empty),empty,empty,empty,empty,false)))).

2. The entry statestore(alice,charlie,sid_6,statepack_a(handshakestatepack(symmetricstatepack(cipherstatepack(empty,minnonce),hash(somename,empty),hash(hash(somename,empty),empty)),keypairpack(empty,empty),keypairpack(empty,empty),keypairpack(empty,empty),empty,empty,empty,empty,true))) may be inserted in a table at insert {635}.
table(statestore(alice,charlie,sid_6,statepack_a(handshakestatepack(symmetricstatepack(cipherstatepack(empty,minnonce),hash(somename,empty),hash(hash(somename,empty),empty)),keypairpack(empty,empty),keypairpack(empty,empty),keypairpack(empty,empty),empty,empty,empty,empty,true)))).

3. The entry statestore(alice,charlie,sid_6,statepack_a(handshakestatepack(symmetricstatepack(cipherstatepack(empty,minnonce),hash(somename,empty),hash(hash(somename,empty),empty)),keypairpack(empty,empty),keypairpack(empty,empty),keypairpack(empty,empty),empty,empty,empty,empty,true))) that may be in a table by 2 may be read at get {787}.
The event SendMsg(alice,charlie,stagepack_a(sid_6),msg_a(alice,charlie,sid_6)) may be executed at {784}.
So the message concat4(validkey(dhexp_real(key_e(alice,charlie,sid_6),g)),encrypt(empty,minnonce,hash(hash(hash(somename,empty),empty),validkey(dhexp_real(key_e(alice,charlie,sid_6),g))),validkey(dhexp_real(key_s(alice),g))),encrypt(empty,increment_nonce(minnonce),hash(hash(hash(hash(somename,empty),empty),validkey(dhexp_real(key_e(alice,charlie,sid_6),g))),encrypt(empty,minnonce,hash(hash(hash(somename,empty),empty),validkey(dhexp_real(key_e(alice,charlie,sid_6),g))),validkey(dhexp_real(key_s(alice),g)))),validkey(dhexp_real(key_m(alice),g))),encrypt(empty,increment_nonce(increment_nonce(minnonce)),hash(hash(hash(hash(hash(somename,empty),empty),validkey(dhexp_real(key_e(alice,charlie,sid_6),g))),encrypt(empty,minnonce,hash(hash(hash(somename,empty),empty),validkey(dhexp_real(key_e(alice,charlie,sid_6),g))),validkey(dhexp_real(key_s(alice),g)))),encrypt(empty,increment_nonce(minnonce),hash(hash(hash(hash(somename,empty),empty),validkey(dhexp_real(key_e(alice,charlie,sid_6),g))),encrypt(empty,minnonce,hash(hash(hash(somename,empty),empty),validkey(dhexp_real(key_e(alice,charlie,sid_6),g))),validkey(dhexp_real(key_s(alice),g)))),validkey(dhexp_real(key_m(alice),g)))),msg_a(alice,charlie,sid_6))) may be sent on channel pub at output {786}.
mess(pub,concat4(validkey(dhexp_real(key_e(alice,charlie,sid_6),g)),encrypt(empty,minnonce,hash(hash(hash(somename,empty),empty),validkey(dhexp_real(key_e(alice,charlie,sid_6),g))),validkey(dhexp_real(key_s(alice),g))),encrypt(empty,increment_nonce(minnonce),hash(hash(hash(hash(somename,empty),empty),validkey(dhexp_real(key_e(alice,charlie,sid_6),g))),encrypt(empty,minnonce,hash(hash(hash(somename,empty),empty),validkey(dhexp_real(key_e(alice,charlie,sid_6),g))),validkey(dhexp_real(key_s(alice),g)))),validkey(dhexp_real(key_m(alice),g))),encrypt(empty,increment_nonce(increment_nonce(minnonce)),hash(hash(hash(hash(hash(somename,empty),empty),validkey(dhexp_real(key_e(alice,charlie,sid_6),g))),encrypt(empty,minnonce,hash(hash(hash(somename,empty),empty),validkey(dhexp_real(key_e(alice,charlie,sid_6),g))),validkey(dhexp_real(key_s(alice),g)))),encrypt(empty,increment_nonce(minnonce),hash(hash(hash(hash(somename,empty),empty),validkey(dhexp_real(key_e(alice,charlie,sid_6),g))),encrypt(empty,minnonce,hash(hash(hash(somename,empty),empty),validkey(dhexp_real(key_e(alice,charlie,sid_6),g))),validkey(dhexp_real(key_s(alice),g)))),validkey(dhexp_real(key_m(alice),g)))),msg_a(alice,charlie,sid_6)))).

4. The entry statestore(bob,alice,sid_5,statepack_a(handshakestatepack(symmetricstatepack(cipherstatepack(empty,minnonce),hash(somename,empty),hash(hash(somename,empty),empty)),keypairpack(empty,empty),keypairpack(validkey(dhexp_real(key_m(bob),g)),key_m(bob)),keypairpack(empty,empty),empty,empty,empty,empty,false))) that may be in a table by 1 may be read at get {1408}.
The message concat4(validkey(dhexp_real(key_e(alice,charlie,sid_6),g)),encrypt(empty,minnonce,hash(hash(hash(somename,empty),empty),validkey(dhexp_real(key_e(alice,charlie,sid_6),g))),validkey(dhexp_real(key_s(alice),g))),encrypt(empty,increment_nonce(minnonce),hash(hash(hash(hash(somename,empty),empty),validkey(dhexp_real(key_e(alice,charlie,sid_6),g))),encrypt(empty,minnonce,hash(hash(hash(somename,empty),empty),validkey(dhexp_real(key_e(alice,charlie,sid_6),g))),validkey(dhexp_real(key_s(alice),g)))),validkey(dhexp_real(key_m(alice),g))),encrypt(empty,increment_nonce(increment_nonce(minnonce)),hash(hash(hash(hash(hash(somename,empty),empty),validkey(dhexp_real(key_e(alice,charlie,sid_6),g))),encrypt(empty,minnonce,hash(hash(hash(somename,empty),empty),validkey(dhexp_real(key_e(alice,charlie,sid_6),g))),validkey(dhexp_real(key_s(alice),g)))),encrypt(empty,increment_nonce(minnonce),hash(hash(hash(hash(somename,empty),empty),validkey(dhexp_real(key_e(alice,charlie,sid_6),g))),encrypt(empty,minnonce,hash(hash(hash(somename,empty),empty),validkey(dhexp_real(key_e(alice,charlie,sid_6),g))),validkey(dhexp_real(key_s(alice),g)))),validkey(dhexp_real(key_m(alice),g)))),msg_a(alice,charlie,sid_6))) that may be sent on channel pub by 3 may be received at input {1244}.
So event RecvMsg(bob,alice,stagepack_a(sid_5),msg_a(alice,charlie,sid_6)) may be executed at {1406}.
end(RecvMsg(bob,alice,stagepack_a(sid_5),msg_a(alice,charlie,sid_6))).

5. By 4, end(RecvMsg(bob,alice,stagepack_a(sid_5),msg_a(alice,charlie,sid_6))).
The goal is reached, represented in the following fact:
end(RecvMsg(bob,alice,stagepack_a(sid_5),msg_a(alice,charlie,sid_6))).


RESULT event(RecvMsg(bob,alice,stagepack_a(sid_b),m_24)) ==> event(SendMsg(alice,bob,stagepack_a(sid_a),m_24)) || (event(LeakS(phase0,alice)) && event(LeakM(phase0,alice))) || (event(LeakS(phase0,bob)) && event(LeakM(phase0,bob))) cannot be proved.
Starting query event(RecvMsg(bob,alice,stagepack_a(sid_b),m_24)) ==> event(SendMsg(alice,bob,stagepack_a(sid_a),m_24)) || (event(LeakS(phase0,alice)) && event(LeakM(phase0,alice)))
goal reachable: begin(SendMsg(alice,charlie,stagepack_a(sid_5),msg_a(alice,charlie,sid_5))) -> end(RecvMsg(bob,alice,stagepack_a(sid_6),msg_a(alice,charlie,sid_5)))
Abbreviations:
sid_6 = sid[!1 = @sid]
sid_5 = sid[!1 = @sid_1]

Derivation:
Abbreviations:
sid_5 = sid[!1 = @sid]
sid_6 = sid[!1 = @sid_1]

1. The entry statestore(bob,alice,sid_5,statepack_a(handshakestatepack(symmetricstatepack(cipherstatepack(empty,minnonce),hash(somename,empty),hash(hash(somename,empty),empty)),keypairpack(empty,empty),keypairpack(validkey(dhexp_real(key_m(bob),g)),key_m(bob)),keypairpack(empty,empty),empty,empty,empty,empty,false))) may be inserted in a table at insert {1243}.
table(statestore(bob,alice,sid_5,statepack_a(handshakestatepack(symmetricstatepack(cipherstatepack(empty,minnonce),hash(somename,empty),hash(hash(somename,empty),empty)),keypairpack(empty,empty),keypairpack(validkey(dhexp_real(key_m(bob),g)),key_m(bob)),keypairpack(empty,empty),empty,empty,empty,empty,false)))).

2. The entry statestore(alice,charlie,sid_6,statepack_a(handshakestatepack(symmetricstatepack(cipherstatepack(empty,minnonce),hash(somename,empty),hash(hash(somename,empty),empty)),keypairpack(empty,empty),keypairpack(empty,empty),keypairpack(empty,empty),empty,empty,empty,empty,true))) may be inserted in a table at insert {635}.
table(statestore(alice,charlie,sid_6,statepack_a(handshakestatepack(symmetricstatepack(cipherstatepack(empty,minnonce),hash(somename,empty),hash(hash(somename,empty),empty)),keypairpack(empty,empty),keypairpack(empty,empty),keypairpack(empty,empty),empty,empty,empty,empty,true)))).

3. The entry statestore(alice,charlie,sid_6,statepack_a(handshakestatepack(symmetricstatepack(cipherstatepack(empty,minnonce),hash(somename,empty),hash(hash(somename,empty),empty)),keypairpack(empty,empty),keypairpack(empty,empty),keypairpack(empty,empty),empty,empty,empty,empty,true))) that may be in a table by 2 may be read at get {787}.
The event SendMsg(alice,charlie,stagepack_a(sid_6),msg_a(alice,charlie,sid_6)) may be executed at {784}.
So the message concat4(validkey(dhexp_real(key_e(alice,charlie,sid_6),g)),encrypt(empty,minnonce,hash(hash(hash(somename,empty),empty),validkey(dhexp_real(key_e(alice,charlie,sid_6),g))),validkey(dhexp_real(key_s(alice),g))),encrypt(empty,increment_nonce(minnonce),hash(hash(hash(hash(somename,empty),empty),validkey(dhexp_real(key_e(alice,charlie,sid_6),g))),encrypt(empty,minnonce,hash(hash(hash(somename,empty),empty),validkey(dhexp_real(key_e(alice,charlie,sid_6),g))),validkey(dhexp_real(key_s(alice),g)))),validkey(dhexp_real(key_m(alice),g))),encrypt(empty,increment_nonce(increment_nonce(minnonce)),hash(hash(hash(hash(hash(somename,empty),empty),validkey(dhexp_real(key_e(alice,charlie,sid_6),g))),encrypt(empty,minnonce,hash(hash(hash(somename,empty),empty),validkey(dhexp_real(key_e(alice,charlie,sid_6),g))),validkey(dhexp_real(key_s(alice),g)))),encrypt(empty,increment_nonce(minnonce),hash(hash(hash(hash(somename,empty),empty),validkey(dhexp_real(key_e(alice,charlie,sid_6),g))),encrypt(empty,minnonce,hash(hash(hash(somename,empty),empty),validkey(dhexp_real(key_e(alice,charlie,sid_6),g))),validkey(dhexp_real(key_s(alice),g)))),validkey(dhexp_real(key_m(alice),g)))),msg_a(alice,charlie,sid_6))) may be sent on channel pub at output {786}.
mess(pub,concat4(validkey(dhexp_real(key_e(alice,charlie,sid_6),g)),encrypt(empty,minnonce,hash(hash(hash(somename,empty),empty),validkey(dhexp_real(key_e(alice,charlie,sid_6),g))),validkey(dhexp_real(key_s(alice),g))),encrypt(empty,increment_nonce(minnonce),hash(hash(hash(hash(somename,empty),empty),validkey(dhexp_real(key_e(alice,charlie,sid_6),g))),encrypt(empty,minnonce,hash(hash(hash(somename,empty),empty),validkey(dhexp_real(key_e(alice,charlie,sid_6),g))),validkey(dhexp_real(key_s(alice),g)))),validkey(dhexp_real(key_m(alice),g))),encrypt(empty,increment_nonce(increment_nonce(minnonce)),hash(hash(hash(hash(hash(somename,empty),empty),validkey(dhexp_real(key_e(alice,charlie,sid_6),g))),encrypt(empty,minnonce,hash(hash(hash(somename,empty),empty),validkey(dhexp_real(key_e(alice,charlie,sid_6),g))),validkey(dhexp_real(key_s(alice),g)))),encrypt(empty,increment_nonce(minnonce),hash(hash(hash(hash(somename,empty),empty),validkey(dhexp_real(key_e(alice,charlie,sid_6),g))),encrypt(empty,minnonce,hash(hash(hash(somename,empty),empty),validkey(dhexp_real(key_e(alice,charlie,sid_6),g))),validkey(dhexp_real(key_s(alice),g)))),validkey(dhexp_real(key_m(alice),g)))),msg_a(alice,charlie,sid_6)))).

4. The entry statestore(bob,alice,sid_5,statepack_a(handshakestatepack(symmetricstatepack(cipherstatepack(empty,minnonce),hash(somename,empty),hash(hash(somename,empty),empty)),keypairpack(empty,empty),keypairpack(validkey(dhexp_real(key_m(bob),g)),key_m(bob)),keypairpack(empty,empty),empty,empty,empty,empty,false))) that may be in a table by 1 may be read at get {1408}.
The message concat4(validkey(dhexp_real(key_e(alice,charlie,sid_6),g)),encrypt(empty,minnonce,hash(hash(hash(somename,empty),empty),validkey(dhexp_real(key_e(alice,charlie,sid_6),g))),validkey(dhexp_real(key_s(alice),g))),encrypt(empty,increment_nonce(minnonce),hash(hash(hash(hash(somename,empty),empty),validkey(dhexp_real(key_e(alice,charlie,sid_6),g))),encrypt(empty,minnonce,hash(hash(hash(somename,empty),empty),validkey(dhexp_real(key_e(alice,charlie,sid_6),g))),validkey(dhexp_real(key_s(alice),g)))),validkey(dhexp_real(key_m(alice),g))),encrypt(empty,increment_nonce(increment_nonce(minnonce)),hash(hash(hash(hash(hash(somename,empty),empty),validkey(dhexp_real(key_e(alice,charlie,sid_6),g))),encrypt(empty,minnonce,hash(hash(hash(somename,empty),empty),validkey(dhexp_real(key_e(alice,charlie,sid_6),g))),validkey(dhexp_real(key_s(alice),g)))),encrypt(empty,increment_nonce(minnonce),hash(hash(hash(hash(somename,empty),empty),validkey(dhexp_real(key_e(alice,charlie,sid_6),g))),encrypt(empty,minnonce,hash(hash(hash(somename,empty),empty),validkey(dhexp_real(key_e(alice,charlie,sid_6),g))),validkey(dhexp_real(key_s(alice),g)))),validkey(dhexp_real(key_m(alice),g)))),msg_a(alice,charlie,sid_6))) that may be sent on channel pub by 3 may be received at input {1244}.
So event RecvMsg(bob,alice,stagepack_a(sid_5),msg_a(alice,charlie,sid_6)) may be executed at {1406}.
end(RecvMsg(bob,alice,stagepack_a(sid_5),msg_a(alice,charlie,sid_6))).

5. By 4, end(RecvMsg(bob,alice,stagepack_a(sid_5),msg_a(alice,charlie,sid_6))).
The goal is reached, represented in the following fact:
end(RecvMsg(bob,alice,stagepack_a(sid_5),msg_a(alice,charlie,sid_6))).


RESULT event(RecvMsg(bob,alice,stagepack_a(sid_b),m_24)) ==> event(SendMsg(alice,bob,stagepack_a(sid_a),m_24)) || (event(LeakS(phase0,alice)) && event(LeakM(phase0,alice))) cannot be proved.
Starting query not attacker_p1(msg_a(alice,bob,sid_a))
goal reachable: begin(SendMsg(alice,bob,stagepack_a(sid_5),msg_a(alice,bob,sid_5))) -> attacker_p1(msg_a(alice,bob,sid_5))
Abbreviations:
sid_5 = sid[!1 = @sid]

Derivation:
Abbreviations:
sid_5 = sid[!1 = @sid]

1. Using the function pub the attacker may obtain pub.
attacker(pub).

2. The entry statestore(alice,bob,sid_5,statepack_a(handshakestatepack(symmetricstatepack(cipherstatepack(empty,minnonce),hash(somename,empty),hash(hash(somename,empty),empty)),keypairpack(empty,empty),keypairpack(empty,empty),keypairpack(empty,empty),empty,empty,empty,empty,true))) may be inserted in a table at insert {30}.
table(statestore(alice,bob,sid_5,statepack_a(handshakestatepack(symmetricstatepack(cipherstatepack(empty,minnonce),hash(somename,empty),hash(hash(somename,empty),empty)),keypairpack(empty,empty),keypairpack(empty,empty),keypairpack(empty,empty),empty,empty,empty,empty,true)))).

3. The entry statestore(alice,bob,sid_5,statepack_a(handshakestatepack(symmetricstatepack(cipherstatepack(empty,minnonce),hash(somename,empty),hash(hash(somename,empty),empty)),keypairpack(empty,empty),keypairpack(empty,empty),keypairpack(empty,empty),empty,empty,empty,empty,true))) that may be in a table by 2 may be read at get {182}.
The event SendMsg(alice,bob,stagepack_a(sid_5),msg_a(alice,bob,sid_5)) may be executed at {179}.
So the message concat4(validkey(dhexp_real(key_e(alice,bob,sid_5),g)),encrypt(empty,minnonce,hash(hash(hash(somename,empty),empty),validkey(dhexp_real(key_e(alice,bob,sid_5),g))),validkey(dhexp_real(key_s(alice),g))),encrypt(empty,increment_nonce(minnonce),hash(hash(hash(hash(somename,empty),empty),validkey(dhexp_real(key_e(alice,bob,sid_5),g))),encrypt(empty,minnonce,hash(hash(hash(somename,empty),empty),validkey(dhexp_real(key_e(alice,bob,sid_5),g))),validkey(dhexp_real(key_s(alice),g)))),validkey(dhexp_real(key_m(alice),g))),encrypt(empty,increment_nonce(increment_nonce(minnonce)),hash(hash(hash(hash(hash(somename,empty),empty),validkey(dhexp_real(key_e(alice,bob,sid_5),g))),encrypt(empty,minnonce,hash(hash(hash(somename,empty),empty),validkey(dhexp_real(key_e(alice,bob,sid_5),g))),validkey(dhexp_real(key_s(alice),g)))),encrypt(empty,increment_nonce(minnonce),hash(hash(hash(hash(somename,empty),empty),validkey(dhexp_real(key_e(alice,bob,sid_5),g))),encrypt(empty,minnonce,hash(hash(hash(somename,empty),empty),validkey(dhexp_real(key_e(alice,bob,sid_5),g))),validkey(dhexp_real(key_s(alice),g)))),validkey(dhexp_real(key_m(alice),g)))),msg_a(alice,bob,sid_5))) may be sent on channel pub at output {181}.
mess(pub,concat4(validkey(dhexp_real(key_e(alice,bob,sid_5),g)),encrypt(empty,minnonce,hash(hash(hash(somename,empty),empty),validkey(dhexp_real(key_e(alice,bob,sid_5),g))),validkey(dhexp_real(key_s(alice),g))),encrypt(empty,increment_nonce(minnonce),hash(hash(hash(hash(somename,empty),empty),validkey(dhexp_real(key_e(alice,bob,sid_5),g))),encrypt(empty,minnonce,hash(hash(hash(somename,empty),empty),validkey(dhexp_real(key_e(alice,bob,sid_5),g))),validkey(dhexp_real(key_s(alice),g)))),validkey(dhexp_real(key_m(alice),g))),encrypt(empty,increment_nonce(increment_nonce(minnonce)),hash(hash(hash(hash(hash(somename,empty),empty),validkey(dhexp_real(key_e(alice,bob,sid_5),g))),encrypt(empty,minnonce,hash(hash(hash(somename,empty),empty),validkey(dhexp_real(key_e(alice,bob,sid_5),g))),validkey(dhexp_real(key_s(alice),g)))),encrypt(empty,increment_nonce(minnonce),hash(hash(hash(hash(somename,empty),empty),validkey(dhexp_real(key_e(alice,bob,sid_5),g))),encrypt(empty,minnonce,hash(hash(hash(somename,empty),empty),validkey(dhexp_real(key_e(alice,bob,sid_5),g))),validkey(dhexp_real(key_s(alice),g)))),validkey(dhexp_real(key_m(alice),g)))),msg_a(alice,bob,sid_5)))).

4. By 1, the attacker may have the channel pub.
By 3, the message concat4(validkey(dhexp_real(key_e(alice,bob,sid_5),g)),encrypt(empty,minnonce,hash(hash(hash(somename,empty),empty),validkey(dhexp_real(key_e(alice,bob,sid_5),g))),validkey(dhexp_real(key_s(alice),g))),encrypt(empty,increment_nonce(minnonce),hash(hash(hash(hash(somename,empty),empty),validkey(dhexp_real(key_e(alice,bob,sid_5),g))),encrypt(empty,minnonce,hash(hash(hash(somename,empty),empty),validkey(dhexp_real(key_e(alice,bob,sid_5),g))),validkey(dhexp_real(key_s(alice),g)))),validkey(dhexp_real(key_m(alice),g))),encrypt(empty,increment_nonce(increment_nonce(minnonce)),hash(hash(hash(hash(hash(somename,empty),empty),validkey(dhexp_real(key_e(alice,bob,sid_5),g))),encrypt(empty,minnonce,hash(hash(hash(somename,empty),empty),validkey(dhexp_real(key_e(alice,bob,sid_5),g))),validkey(dhexp_real(key_s(alice),g)))),encrypt(empty,increment_nonce(minnonce),hash(hash(hash(hash(somename,empty),empty),validkey(dhexp_real(key_e(alice,bob,sid_5),g))),encrypt(empty,minnonce,hash(hash(hash(somename,empty),empty),validkey(dhexp_real(key_e(alice,bob,sid_5),g))),validkey(dhexp_real(key_s(alice),g)))),validkey(dhexp_real(key_m(alice),g)))),msg_a(alice,bob,sid_5))) may be sent on this channel.
So the attacker may obtain the message concat4(validkey(dhexp_real(key_e(alice,bob,sid_5),g)),encrypt(empty,minnonce,hash(hash(hash(somename,empty),empty),validkey(dhexp_real(key_e(alice,bob,sid_5),g))),validkey(dhexp_real(key_s(alice),g))),encrypt(empty,increment_nonce(minnonce),hash(hash(hash(hash(somename,empty),empty),validkey(dhexp_real(key_e(alice,bob,sid_5),g))),encrypt(empty,minnonce,hash(hash(hash(somename,empty),empty),validkey(dhexp_real(key_e(alice,bob,sid_5),g))),validkey(dhexp_real(key_s(alice),g)))),validkey(dhexp_real(key_m(alice),g))),encrypt(empty,increment_nonce(increment_nonce(minnonce)),hash(hash(hash(hash(hash(somename,empty),empty),validkey(dhexp_real(key_e(alice,bob,sid_5),g))),encrypt(empty,minnonce,hash(hash(hash(somename,empty),empty),validkey(dhexp_real(key_e(alice,bob,sid_5),g))),validkey(dhexp_real(key_s(alice),g)))),encrypt(empty,increment_nonce(minnonce),hash(hash(hash(hash(somename,empty),empty),validkey(dhexp_real(key_e(alice,bob,sid_5),g))),encrypt(empty,minnonce,hash(hash(hash(somename,empty),empty),validkey(dhexp_real(key_e(alice,bob,sid_5),g))),validkey(dhexp_real(key_s(alice),g)))),validkey(dhexp_real(key_m(alice),g)))),msg_a(alice,bob,sid_5))) by listening on this channel.
attacker(concat4(validkey(dhexp_real(key_e(alice,bob,sid_5),g)),encrypt(empty,minnonce,hash(hash(hash(somename,empty),empty),validkey(dhexp_real(key_e(alice,bob,sid_5),g))),validkey(dhexp_real(key_s(alice),g))),encrypt(empty,increment_nonce(minnonce),hash(hash(hash(hash(somename,empty),empty),validkey(dhexp_real(key_e(alice,bob,sid_5),g))),encrypt(empty,minnonce,hash(hash(hash(somename,empty),empty),validkey(dhexp_real(key_e(alice,bob,sid_5),g))),validkey(dhexp_real(key_s(alice),g)))),validkey(dhexp_real(key_m(alice),g))),encrypt(empty,increment_nonce(increment_nonce(minnonce)),hash(hash(hash(hash(hash(somename,empty),empty),validkey(dhexp_real(key_e(alice,bob,sid_5),g))),encrypt(empty,minnonce,hash(hash(hash(somename,empty),empty),validkey(dhexp_real(key_e(alice,bob,sid_5),g))),validkey(dhexp_real(key_s(alice),g)))),encrypt(empty,increment_nonce(minnonce),hash(hash(hash(hash(somename,empty),empty),validkey(dhexp_real(key_e(alice,bob,sid_5),g))),encrypt(empty,minnonce,hash(hash(hash(somename,empty),empty),validkey(dhexp_real(key_e(alice,bob,sid_5),g))),validkey(dhexp_real(key_s(alice),g)))),validkey(dhexp_real(key_m(alice),g)))),msg_a(alice,bob,sid_5)))).

5. By 4, the attacker may know concat4(validkey(dhexp_real(key_e(alice,bob,sid_5),g)),encrypt(empty,minnonce,hash(hash(hash(somename,empty),empty),validkey(dhexp_real(key_e(alice,bob,sid_5),g))),validkey(dhexp_real(key_s(alice),g))),encrypt(empty,increment_nonce(minnonce),hash(hash(hash(hash(somename,empty),empty),validkey(dhexp_real(key_e(alice,bob,sid_5),g))),encrypt(empty,minnonce,hash(hash(hash(somename,empty),empty),validkey(dhexp_real(key_e(alice,bob,sid_5),g))),validkey(dhexp_real(key_s(alice),g)))),validkey(dhexp_real(key_m(alice),g))),encrypt(empty,increment_nonce(increment_nonce(minnonce)),hash(hash(hash(hash(hash(somename,empty),empty),validkey(dhexp_real(key_e(alice,bob,sid_5),g))),encrypt(empty,minnonce,hash(hash(hash(somename,empty),empty),validkey(dhexp_real(key_e(alice,bob,sid_5),g))),validkey(dhexp_real(key_s(alice),g)))),encrypt(empty,increment_nonce(minnonce),hash(hash(hash(hash(somename,empty),empty),validkey(dhexp_real(key_e(alice,bob,sid_5),g))),encrypt(empty,minnonce,hash(hash(hash(somename,empty),empty),validkey(dhexp_real(key_e(alice,bob,sid_5),g))),validkey(dhexp_real(key_s(alice),g)))),validkey(dhexp_real(key_m(alice),g)))),msg_a(alice,bob,sid_5))).
Using the function 4-proj-concat4 the attacker may obtain encrypt(empty,increment_nonce(increment_nonce(minnonce)),hash(hash(hash(hash(hash(somename,empty),empty),validkey(dhexp_real(key_e(alice,bob,sid_5),g))),encrypt(empty,minnonce,hash(hash(hash(somename,empty),empty),validkey(dhexp_real(key_e(alice,bob,sid_5),g))),validkey(dhexp_real(key_s(alice),g)))),encrypt(empty,increment_nonce(minnonce),hash(hash(hash(hash(somename,empty),empty),validkey(dhexp_real(key_e(alice,bob,sid_5),g))),encrypt(empty,minnonce,hash(hash(hash(somename,empty),empty),validkey(dhexp_real(key_e(alice,bob,sid_5),g))),validkey(dhexp_real(key_s(alice),g)))),validkey(dhexp_real(key_m(alice),g)))),msg_a(alice,bob,sid_5)).
attacker(encrypt(empty,increment_nonce(increment_nonce(minnonce)),hash(hash(hash(hash(hash(somename,empty),empty),validkey(dhexp_real(key_e(alice,bob,sid_5),g))),encrypt(empty,minnonce,hash(hash(hash(somename,empty),empty),validkey(dhexp_real(key_e(alice,bob,sid_5),g))),validkey(dhexp_real(key_s(alice),g)))),encrypt(empty,increment_nonce(minnonce),hash(hash(hash(hash(somename,empty),empty),validkey(dhexp_real(key_e(alice,bob,sid_5),g))),encrypt(empty,minnonce,hash(hash(hash(somename,empty),empty),validkey(dhexp_real(key_e(alice,bob,sid_5),g))),validkey(dhexp_real(key_s(alice),g)))),validkey(dhexp_real(key_m(alice),g)))),msg_a(alice,bob,sid_5))).

6. By 4, the attacker may know concat4(validkey(dhexp_real(key_e(alice,bob,sid_5),g)),encrypt(empty,minnonce,hash(hash(hash(somename,empty),empty),validkey(dhexp_real(key_e(alice,bob,sid_5),g))),validkey(dhexp_real(key_s(alice),g))),encrypt(empty,increment_nonce(minnonce),hash(hash(hash(hash(somename,empty),empty),validkey(dhexp_real(key_e(alice,bob,sid_5),g))),encrypt(empty,minnonce,hash(hash(hash(somename,empty),empty),validkey(dhexp_real(key_e(alice,bob,sid_5),g))),validkey(dhexp_real(key_s(alice),g)))),validkey(dhexp_real(key_m(alice),g))),encrypt(empty,increment_nonce(increment_nonce(minnonce)),hash(hash(hash(hash(hash(somename,empty),empty),validkey(dhexp_real(key_e(alice,bob,sid_5),g))),encrypt(empty,minnonce,hash(hash(hash(somename,empty),empty),validkey(dhexp_real(key_e(alice,bob,sid_5),g))),validkey(dhexp_real(key_s(alice),g)))),encrypt(empty,increment_nonce(minnonce),hash(hash(hash(hash(somename,empty),empty),validkey(dhexp_real(key_e(alice,bob,sid_5),g))),encrypt(empty,minnonce,hash(hash(hash(somename,empty),empty),validkey(dhexp_real(key_e(alice,bob,sid_5),g))),validkey(dhexp_real(key_s(alice),g)))),validkey(dhexp_real(key_m(alice),g)))),msg_a(alice,bob,sid_5))).
Using the function 3-proj-concat4 the attacker may obtain encrypt(empty,increment_nonce(minnonce),hash(hash(hash(hash(somename,empty),empty),validkey(dhexp_real(key_e(alice,bob,sid_5),g))),encrypt(empty,minnonce,hash(hash(hash(somename,empty),empty),validkey(dhexp_real(key_e(alice,bob,sid_5),g))),validkey(dhexp_real(key_s(alice),g)))),validkey(dhexp_real(key_m(alice),g))).
attacker(encrypt(empty,increment_nonce(minnonce),hash(hash(hash(hash(somename,empty),empty),validkey(dhexp_real(key_e(alice,bob,sid_5),g))),encrypt(empty,minnonce,hash(hash(hash(somename,empty),empty),validkey(dhexp_real(key_e(alice,bob,sid_5),g))),validkey(dhexp_real(key_s(alice),g)))),validkey(dhexp_real(key_m(alice),g)))).

7. By 4, the attacker may know concat4(validkey(dhexp_real(key_e(alice,bob,sid_5),g)),encrypt(empty,minnonce,hash(hash(hash(somename,empty),empty),validkey(dhexp_real(key_e(alice,bob,sid_5),g))),validkey(dhexp_real(key_s(alice),g))),encrypt(empty,increment_nonce(minnonce),hash(hash(hash(hash(somename,empty),empty),validkey(dhexp_real(key_e(alice,bob,sid_5),g))),encrypt(empty,minnonce,hash(hash(hash(somename,empty),empty),validkey(dhexp_real(key_e(alice,bob,sid_5),g))),validkey(dhexp_real(key_s(alice),g)))),validkey(dhexp_real(key_m(alice),g))),encrypt(empty,increment_nonce(increment_nonce(minnonce)),hash(hash(hash(hash(hash(somename,empty),empty),validkey(dhexp_real(key_e(alice,bob,sid_5),g))),encrypt(empty,minnonce,hash(hash(hash(somename,empty),empty),validkey(dhexp_real(key_e(alice,bob,sid_5),g))),validkey(dhexp_real(key_s(alice),g)))),encrypt(empty,increment_nonce(minnonce),hash(hash(hash(hash(somename,empty),empty),validkey(dhexp_real(key_e(alice,bob,sid_5),g))),encrypt(empty,minnonce,hash(hash(hash(somename,empty),empty),validkey(dhexp_real(key_e(alice,bob,sid_5),g))),validkey(dhexp_real(key_s(alice),g)))),validkey(dhexp_real(key_m(alice),g)))),msg_a(alice,bob,sid_5))).
Using the function 2-proj-concat4 the attacker may obtain encrypt(empty,minnonce,hash(hash(hash(somename,empty),empty),validkey(dhexp_real(key_e(alice,bob,sid_5),g))),validkey(dhexp_real(key_s(alice),g))).
attacker(encrypt(empty,minnonce,hash(hash(hash(somename,empty),empty),validkey(dhexp_real(key_e(alice,bob,sid_5),g))),validkey(dhexp_real(key_s(alice),g)))).

8. By 4, the attacker may know concat4(validkey(dhexp_real(key_e(alice,bob,sid_5),g)),encrypt(empty,minnonce,hash(hash(hash(somename,empty),empty),validkey(dhexp_real(key_e(alice,bob,sid_5),g))),validkey(dhexp_real(key_s(alice),g))),encrypt(empty,increment_nonce(minnonce),hash(hash(hash(hash(somename,empty),empty),validkey(dhexp_real(key_e(alice,bob,sid_5),g))),encrypt(empty,minnonce,hash(hash(hash(somename,empty),empty),validkey(dhexp_real(key_e(alice,bob,sid_5),g))),validkey(dhexp_real(key_s(alice),g)))),validkey(dhexp_real(key_m(alice),g))),encrypt(empty,increment_nonce(increment_nonce(minnonce)),hash(hash(hash(hash(hash(somename,empty),empty),validkey(dhexp_real(key_e(alice,bob,sid_5),g))),encrypt(empty,minnonce,hash(hash(hash(somename,empty),empty),validkey(dhexp_real(key_e(alice,bob,sid_5),g))),validkey(dhexp_real(key_s(alice),g)))),encrypt(empty,increment_nonce(minnonce),hash(hash(hash(hash(somename,empty),empty),validkey(dhexp_real(key_e(alice,bob,sid_5),g))),encrypt(empty,minnonce,hash(hash(hash(somename,empty),empty),validkey(dhexp_real(key_e(alice,bob,sid_5),g))),validkey(dhexp_real(key_s(alice),g)))),validkey(dhexp_real(key_m(alice),g)))),msg_a(alice,bob,sid_5))).
Using the function 1-proj-concat4 the attacker may obtain validkey(dhexp_real(key_e(alice,bob,sid_5),g)).
attacker(validkey(dhexp_real(key_e(alice,bob,sid_5),g))).

9. Using the function empty the attacker may obtain empty.
attacker(empty).

10. Using the function somename the attacker may obtain somename.
attacker(somename).

11. By 10, the attacker may know somename.
By 9, the attacker may know empty.
Using the function hash the attacker may obtain hash(somename,empty).
attacker(hash(somename,empty)).

12. By 11, the attacker may know hash(somename,empty).
By 9, the attacker may know empty.
Using the function hash the attacker may obtain hash(hash(somename,empty),empty).
attacker(hash(hash(somename,empty),empty)).

13. By 12, the attacker may know hash(hash(somename,empty),empty).
By 8, the attacker may know validkey(dhexp_real(key_e(alice,bob,sid_5),g)).
Using the function hash the attacker may obtain hash(hash(hash(somename,empty),empty),validkey(dhexp_real(key_e(alice,bob,sid_5),g))).
attacker(hash(hash(hash(somename,empty),empty),validkey(dhexp_real(key_e(alice,bob,sid_5),g)))).

14. By 13, the attacker may know hash(hash(hash(somename,empty),empty),validkey(dhexp_real(key_e(alice,bob,sid_5),g))).
By 7, the attacker may know encrypt(empty,minnonce,hash(hash(hash(somename,empty),empty),validkey(dhexp_real(key_e(alice,bob,sid_5),g))),validkey(dhexp_real(key_s(alice),g))).
Using the function hash the attacker may obtain hash(hash(hash(hash(somename,empty),empty),validkey(dhexp_real(key_e(alice,bob,sid_5),g))),encrypt(empty,minnonce,hash(hash(hash(somename,empty),empty),validkey(dhexp_real(key_e(alice,bob,sid_5),g))),validkey(dhexp_real(key_s(alice),g)))).
attacker(hash(hash(hash(hash(somename,empty),empty),validkey(dhexp_real(key_e(alice,bob,sid_5),g))),encrypt(empty,minnonce,hash(hash(hash(somename,empty),empty),validkey(dhexp_real(key_e(alice,bob,sid_5),g))),validkey(dhexp_real(key_s(alice),g))))).

15. By 14, the attacker may know hash(hash(hash(hash(somename,empty),empty),validkey(dhexp_real(key_e(alice,bob,sid_5),g))),encrypt(empty,minnonce,hash(hash(hash(somename,empty),empty),validkey(dhexp_real(key_e(alice,bob,sid_5),g))),validkey(dhexp_real(key_s(alice),g)))).
By 6, the attacker may know encrypt(empty,increment_nonce(minnonce),hash(hash(hash(hash(somename,empty),empty),validkey(dhexp_real(key_e(alice,bob,sid_5),g))),encrypt(empty,minnonce,hash(hash(hash(somename,empty),empty),validkey(dhexp_real(key_e(alice,bob,sid_5),g))),validkey(dhexp_real(key_s(alice),g)))),validkey(dhexp_real(key_m(alice),g))).
Using the function hash the attacker may obtain hash(hash(hash(hash(hash(somename,empty),empty),validkey(dhexp_real(key_e(alice,bob,sid_5),g))),encrypt(empty,minnonce,hash(hash(hash(somename,empty),empty),validkey(dhexp_real(key_e(alice,bob,sid_5),g))),validkey(dhexp_real(key_s(alice),g)))),encrypt(empty,increment_nonce(minnonce),hash(hash(hash(hash(somename,empty),empty),validkey(dhexp_real(key_e(alice,bob,sid_5),g))),encrypt(empty,minnonce,hash(hash(hash(somename,empty),empty),validkey(dhexp_real(key_e(alice,bob,sid_5),g))),validkey(dhexp_real(key_s(alice),g)))),validkey(dhexp_real(key_m(alice),g)))).
attacker(hash(hash(hash(hash(hash(somename,empty),empty),validkey(dhexp_real(key_e(alice,bob,sid_5),g))),encrypt(empty,minnonce,hash(hash(hash(somename,empty),empty),validkey(dhexp_real(key_e(alice,bob,sid_5),g))),validkey(dhexp_real(key_s(alice),g)))),encrypt(empty,increment_nonce(minnonce),hash(hash(hash(hash(somename,empty),empty),validkey(dhexp_real(key_e(alice,bob,sid_5),g))),encrypt(empty,minnonce,hash(hash(hash(somename,empty),empty),validkey(dhexp_real(key_e(alice,bob,sid_5),g))),validkey(dhexp_real(key_s(alice),g)))),validkey(dhexp_real(key_m(alice),g))))).

16. Using the function minnonce the attacker may obtain minnonce.
attacker(minnonce).

17. By 16, the attacker may know minnonce.
Using the function increment_nonce the attacker may obtain increment_nonce(minnonce).
attacker(increment_nonce(minnonce)).

18. By 17, the attacker may know increment_nonce(minnonce).
Using the function increment_nonce the attacker may obtain increment_nonce(increment_nonce(minnonce)).
attacker(increment_nonce(increment_nonce(minnonce))).

19. By 9, the attacker may know empty.
By 18, the attacker may know increment_nonce(increment_nonce(minnonce)).
By 15, the attacker may know hash(hash(hash(hash(hash(somename,empty),empty),validkey(dhexp_real(key_e(alice,bob,sid_5),g))),encrypt(empty,minnonce,hash(hash(hash(somename,empty),empty),validkey(dhexp_real(key_e(alice,bob,sid_5),g))),validkey(dhexp_real(key_s(alice),g)))),encrypt(empty,increment_nonce(minnonce),hash(hash(hash(hash(somename,empty),empty),validkey(dhexp_real(key_e(alice,bob,sid_5),g))),encrypt(empty,minnonce,hash(hash(hash(somename,empty),empty),validkey(dhexp_real(key_e(alice,bob,sid_5),g))),validkey(dhexp_real(key_s(alice),g)))),validkey(dhexp_real(key_m(alice),g)))).
By 5, the attacker may know encrypt(empty,increment_nonce(increment_nonce(minnonce)),hash(hash(hash(hash(hash(somename,empty),empty),validkey(dhexp_real(key_e(alice,bob,sid_5),g))),encrypt(empty,minnonce,hash(hash(hash(somename,empty),empty),validkey(dhexp_real(key_e(alice,bob,sid_5),g))),validkey(dhexp_real(key_s(alice),g)))),encrypt(empty,increment_nonce(minnonce),hash(hash(hash(hash(somename,empty),empty),validkey(dhexp_real(key_e(alice,bob,sid_5),g))),encrypt(empty,minnonce,hash(hash(hash(somename,empty),empty),validkey(dhexp_real(key_e(alice,bob,sid_5),g))),validkey(dhexp_real(key_s(alice),g)))),validkey(dhexp_real(key_m(alice),g)))),msg_a(alice,bob,sid_5)).
Using the function decrypt the attacker may obtain aeadpack(true,hash(hash(hash(hash(hash(somename,empty),empty),validkey(dhexp_real(key_e(alice,bob,sid_5),g))),encrypt(empty,minnonce,hash(hash(hash(somename,empty),empty),validkey(dhexp_real(key_e(alice,bob,sid_5),g))),validkey(dhexp_real(key_s(alice),g)))),encrypt(empty,increment_nonce(minnonce),hash(hash(hash(hash(somename,empty),empty),validkey(dhexp_real(key_e(alice,bob,sid_5),g))),encrypt(empty,minnonce,hash(hash(hash(somename,empty),empty),validkey(dhexp_real(key_e(alice,bob,sid_5),g))),validkey(dhexp_real(key_s(alice),g)))),validkey(dhexp_real(key_m(alice),g)))),msg_a(alice,bob,sid_5)).
attacker(aeadpack(true,hash(hash(hash(hash(hash(somename,empty),empty),validkey(dhexp_real(key_e(alice,bob,sid_5),g))),encrypt(empty,minnonce,hash(hash(hash(somename,empty),empty),validkey(dhexp_real(key_e(alice,bob,sid_5),g))),validkey(dhexp_real(key_s(alice),g)))),encrypt(empty,increment_nonce(minnonce),hash(hash(hash(hash(somename,empty),empty),validkey(dhexp_real(key_e(alice,bob,sid_5),g))),encrypt(empty,minnonce,hash(hash(hash(somename,empty),empty),validkey(dhexp_real(key_e(alice,bob,sid_5),g))),validkey(dhexp_real(key_s(alice),g)))),validkey(dhexp_real(key_m(alice),g)))),msg_a(alice,bob,sid_5))).

20. By 19, the attacker may know aeadpack(true,hash(hash(hash(hash(hash(somename,empty),empty),validkey(dhexp_real(key_e(alice,bob,sid_5),g))),encrypt(empty,minnonce,hash(hash(hash(somename,empty),empty),validkey(dhexp_real(key_e(alice,bob,sid_5),g))),validkey(dhexp_real(key_s(alice),g)))),encrypt(empty,increment_nonce(minnonce),hash(hash(hash(hash(somename,empty),empty),validkey(dhexp_real(key_e(alice,bob,sid_5),g))),encrypt(empty,minnonce,hash(hash(hash(somename,empty),empty),validkey(dhexp_real(key_e(alice,bob,sid_5),g))),validkey(dhexp_real(key_s(alice),g)))),validkey(dhexp_real(key_m(alice),g)))),msg_a(alice,bob,sid_5)).
Using the function 3-proj-aeadpack the attacker may obtain msg_a(alice,bob,sid_5).
attacker(msg_a(alice,bob,sid_5)).

21. By 20, the attacker may know msg_a(alice,bob,sid_5).
So the attacker may know msg_a(alice,bob,sid_5) in phase 1.
attacker_p1(msg_a(alice,bob,sid_5)).

22. By 21, attacker_p1(msg_a(alice,bob,sid_5)).
The goal is reached, represented in the following fact:
attacker_p1(msg_a(alice,bob,sid_5)).


RESULT not attacker_p1(msg_a(alice,bob,sid_a)) cannot be proved.
Starting query attacker_p1(msg_a(alice,bob,sid_a)) ==> event(LeakS(px,bob)) && event(LeakM(px,bob))
goal reachable: begin(SendMsg(alice,bob,stagepack_a(sid_5),msg_a(alice,bob,sid_5))) -> attacker_p1(msg_a(alice,bob,sid_5))
Abbreviations:
sid_5 = sid[!1 = @sid]

Derivation:
Abbreviations:
sid_5 = sid[!1 = @sid]

1. Using the function pub the attacker may obtain pub.
attacker(pub).

2. The entry statestore(alice,bob,sid_5,statepack_a(handshakestatepack(symmetricstatepack(cipherstatepack(empty,minnonce),hash(somename,empty),hash(hash(somename,empty),empty)),keypairpack(empty,empty),keypairpack(empty,empty),keypairpack(empty,empty),empty,empty,empty,empty,true))) may be inserted in a table at insert {30}.
table(statestore(alice,bob,sid_5,statepack_a(handshakestatepack(symmetricstatepack(cipherstatepack(empty,minnonce),hash(somename,empty),hash(hash(somename,empty),empty)),keypairpack(empty,empty),keypairpack(empty,empty),keypairpack(empty,empty),empty,empty,empty,empty,true)))).

3. The entry statestore(alice,bob,sid_5,statepack_a(handshakestatepack(symmetricstatepack(cipherstatepack(empty,minnonce),hash(somename,empty),hash(hash(somename,empty),empty)),keypairpack(empty,empty),keypairpack(empty,empty),keypairpack(empty,empty),empty,empty,empty,empty,true))) that may be in a table by 2 may be read at get {182}.
The event SendMsg(alice,bob,stagepack_a(sid_5),msg_a(alice,bob,sid_5)) may be executed at {179}.
So the message concat4(validkey(dhexp_real(key_e(alice,bob,sid_5),g)),encrypt(empty,minnonce,hash(hash(hash(somename,empty),empty),validkey(dhexp_real(key_e(alice,bob,sid_5),g))),validkey(dhexp_real(key_s(alice),g))),encrypt(empty,increment_nonce(minnonce),hash(hash(hash(hash(somename,empty),empty),validkey(dhexp_real(key_e(alice,bob,sid_5),g))),encrypt(empty,minnonce,hash(hash(hash(somename,empty),empty),validkey(dhexp_real(key_e(alice,bob,sid_5),g))),validkey(dhexp_real(key_s(alice),g)))),validkey(dhexp_real(key_m(alice),g))),encrypt(empty,increment_nonce(increment_nonce(minnonce)),hash(hash(hash(hash(hash(somename,empty),empty),validkey(dhexp_real(key_e(alice,bob,sid_5),g))),encrypt(empty,minnonce,hash(hash(hash(somename,empty),empty),validkey(dhexp_real(key_e(alice,bob,sid_5),g))),validkey(dhexp_real(key_s(alice),g)))),encrypt(empty,increment_nonce(minnonce),hash(hash(hash(hash(somename,empty),empty),validkey(dhexp_real(key_e(alice,bob,sid_5),g))),encrypt(empty,minnonce,hash(hash(hash(somename,empty),empty),validkey(dhexp_real(key_e(alice,bob,sid_5),g))),validkey(dhexp_real(key_s(alice),g)))),validkey(dhexp_real(key_m(alice),g)))),msg_a(alice,bob,sid_5))) may be sent on channel pub at output {181}.
mess(pub,concat4(validkey(dhexp_real(key_e(alice,bob,sid_5),g)),encrypt(empty,minnonce,hash(hash(hash(somename,empty),empty),validkey(dhexp_real(key_e(alice,bob,sid_5),g))),validkey(dhexp_real(key_s(alice),g))),encrypt(empty,increment_nonce(minnonce),hash(hash(hash(hash(somename,empty),empty),validkey(dhexp_real(key_e(alice,bob,sid_5),g))),encrypt(empty,minnonce,hash(hash(hash(somename,empty),empty),validkey(dhexp_real(key_e(alice,bob,sid_5),g))),validkey(dhexp_real(key_s(alice),g)))),validkey(dhexp_real(key_m(alice),g))),encrypt(empty,increment_nonce(increment_nonce(minnonce)),hash(hash(hash(hash(hash(somename,empty),empty),validkey(dhexp_real(key_e(alice,bob,sid_5),g))),encrypt(empty,minnonce,hash(hash(hash(somename,empty),empty),validkey(dhexp_real(key_e(alice,bob,sid_5),g))),validkey(dhexp_real(key_s(alice),g)))),encrypt(empty,increment_nonce(minnonce),hash(hash(hash(hash(somename,empty),empty),validkey(dhexp_real(key_e(alice,bob,sid_5),g))),encrypt(empty,minnonce,hash(hash(hash(somename,empty),empty),validkey(dhexp_real(key_e(alice,bob,sid_5),g))),validkey(dhexp_real(key_s(alice),g)))),validkey(dhexp_real(key_m(alice),g)))),msg_a(alice,bob,sid_5)))).

4. By 1, the attacker may have the channel pub.
By 3, the message concat4(validkey(dhexp_real(key_e(alice,bob,sid_5),g)),encrypt(empty,minnonce,hash(hash(hash(somename,empty),empty),validkey(dhexp_real(key_e(alice,bob,sid_5),g))),validkey(dhexp_real(key_s(alice),g))),encrypt(empty,increment_nonce(minnonce),hash(hash(hash(hash(somename,empty),empty),validkey(dhexp_real(key_e(alice,bob,sid_5),g))),encrypt(empty,minnonce,hash(hash(hash(somename,empty),empty),validkey(dhexp_real(key_e(alice,bob,sid_5),g))),validkey(dhexp_real(key_s(alice),g)))),validkey(dhexp_real(key_m(alice),g))),encrypt(empty,increment_nonce(increment_nonce(minnonce)),hash(hash(hash(hash(hash(somename,empty),empty),validkey(dhexp_real(key_e(alice,bob,sid_5),g))),encrypt(empty,minnonce,hash(hash(hash(somename,empty),empty),validkey(dhexp_real(key_e(alice,bob,sid_5),g))),validkey(dhexp_real(key_s(alice),g)))),encrypt(empty,increment_nonce(minnonce),hash(hash(hash(hash(somename,empty),empty),validkey(dhexp_real(key_e(alice,bob,sid_5),g))),encrypt(empty,minnonce,hash(hash(hash(somename,empty),empty),validkey(dhexp_real(key_e(alice,bob,sid_5),g))),validkey(dhexp_real(key_s(alice),g)))),validkey(dhexp_real(key_m(alice),g)))),msg_a(alice,bob,sid_5))) may be sent on this channel.
So the attacker may obtain the message concat4(validkey(dhexp_real(key_e(alice,bob,sid_5),g)),encrypt(empty,minnonce,hash(hash(hash(somename,empty),empty),validkey(dhexp_real(key_e(alice,bob,sid_5),g))),validkey(dhexp_real(key_s(alice),g))),encrypt(empty,increment_nonce(minnonce),hash(hash(hash(hash(somename,empty),empty),validkey(dhexp_real(key_e(alice,bob,sid_5),g))),encrypt(empty,minnonce,hash(hash(hash(somename,empty),empty),validkey(dhexp_real(key_e(alice,bob,sid_5),g))),validkey(dhexp_real(key_s(alice),g)))),validkey(dhexp_real(key_m(alice),g))),encrypt(empty,increment_nonce(increment_nonce(minnonce)),hash(hash(hash(hash(hash(somename,empty),empty),validkey(dhexp_real(key_e(alice,bob,sid_5),g))),encrypt(empty,minnonce,hash(hash(hash(somename,empty),empty),validkey(dhexp_real(key_e(alice,bob,sid_5),g))),validkey(dhexp_real(key_s(alice),g)))),encrypt(empty,increment_nonce(minnonce),hash(hash(hash(hash(somename,empty),empty),validkey(dhexp_real(key_e(alice,bob,sid_5),g))),encrypt(empty,minnonce,hash(hash(hash(somename,empty),empty),validkey(dhexp_real(key_e(alice,bob,sid_5),g))),validkey(dhexp_real(key_s(alice),g)))),validkey(dhexp_real(key_m(alice),g)))),msg_a(alice,bob,sid_5))) by listening on this channel.
attacker(concat4(validkey(dhexp_real(key_e(alice,bob,sid_5),g)),encrypt(empty,minnonce,hash(hash(hash(somename,empty),empty),validkey(dhexp_real(key_e(alice,bob,sid_5),g))),validkey(dhexp_real(key_s(alice),g))),encrypt(empty,increment_nonce(minnonce),hash(hash(hash(hash(somename,empty),empty),validkey(dhexp_real(key_e(alice,bob,sid_5),g))),encrypt(empty,minnonce,hash(hash(hash(somename,empty),empty),validkey(dhexp_real(key_e(alice,bob,sid_5),g))),validkey(dhexp_real(key_s(alice),g)))),validkey(dhexp_real(key_m(alice),g))),encrypt(empty,increment_nonce(increment_nonce(minnonce)),hash(hash(hash(hash(hash(somename,empty),empty),validkey(dhexp_real(key_e(alice,bob,sid_5),g))),encrypt(empty,minnonce,hash(hash(hash(somename,empty),empty),validkey(dhexp_real(key_e(alice,bob,sid_5),g))),validkey(dhexp_real(key_s(alice),g)))),encrypt(empty,increment_nonce(minnonce),hash(hash(hash(hash(somename,empty),empty),validkey(dhexp_real(key_e(alice,bob,sid_5),g))),encrypt(empty,minnonce,hash(hash(hash(somename,empty),empty),validkey(dhexp_real(key_e(alice,bob,sid_5),g))),validkey(dhexp_real(key_s(alice),g)))),validkey(dhexp_real(key_m(alice),g)))),msg_a(alice,bob,sid_5)))).

5. By 4, the attacker may know concat4(validkey(dhexp_real(key_e(alice,bob,sid_5),g)),encrypt(empty,minnonce,hash(hash(hash(somename,empty),empty),validkey(dhexp_real(key_e(alice,bob,sid_5),g))),validkey(dhexp_real(key_s(alice),g))),encrypt(empty,increment_nonce(minnonce),hash(hash(hash(hash(somename,empty),empty),validkey(dhexp_real(key_e(alice,bob,sid_5),g))),encrypt(empty,minnonce,hash(hash(hash(somename,empty),empty),validkey(dhexp_real(key_e(alice,bob,sid_5),g))),validkey(dhexp_real(key_s(alice),g)))),validkey(dhexp_real(key_m(alice),g))),encrypt(empty,increment_nonce(increment_nonce(minnonce)),hash(hash(hash(hash(hash(somename,empty),empty),validkey(dhexp_real(key_e(alice,bob,sid_5),g))),encrypt(empty,minnonce,hash(hash(hash(somename,empty),empty),validkey(dhexp_real(key_e(alice,bob,sid_5),g))),validkey(dhexp_real(key_s(alice),g)))),encrypt(empty,increment_nonce(minnonce),hash(hash(hash(hash(somename,empty),empty),validkey(dhexp_real(key_e(alice,bob,sid_5),g))),encrypt(empty,minnonce,hash(hash(hash(somename,empty),empty),validkey(dhexp_real(key_e(alice,bob,sid_5),g))),validkey(dhexp_real(key_s(alice),g)))),validkey(dhexp_real(key_m(alice),g)))),msg_a(alice,bob,sid_5))).
Using the function 4-proj-concat4 the attacker may obtain encrypt(empty,increment_nonce(increment_nonce(minnonce)),hash(hash(hash(hash(hash(somename,empty),empty),validkey(dhexp_real(key_e(alice,bob,sid_5),g))),encrypt(empty,minnonce,hash(hash(hash(somename,empty),empty),validkey(dhexp_real(key_e(alice,bob,sid_5),g))),validkey(dhexp_real(key_s(alice),g)))),encrypt(empty,increment_nonce(minnonce),hash(hash(hash(hash(somename,empty),empty),validkey(dhexp_real(key_e(alice,bob,sid_5),g))),encrypt(empty,minnonce,hash(hash(hash(somename,empty),empty),validkey(dhexp_real(key_e(alice,bob,sid_5),g))),validkey(dhexp_real(key_s(alice),g)))),validkey(dhexp_real(key_m(alice),g)))),msg_a(alice,bob,sid_5)).
attacker(encrypt(empty,increment_nonce(increment_nonce(minnonce)),hash(hash(hash(hash(hash(somename,empty),empty),validkey(dhexp_real(key_e(alice,bob,sid_5),g))),encrypt(empty,minnonce,hash(hash(hash(somename,empty),empty),validkey(dhexp_real(key_e(alice,bob,sid_5),g))),validkey(dhexp_real(key_s(alice),g)))),encrypt(empty,increment_nonce(minnonce),hash(hash(hash(hash(somename,empty),empty),validkey(dhexp_real(key_e(alice,bob,sid_5),g))),encrypt(empty,minnonce,hash(hash(hash(somename,empty),empty),validkey(dhexp_real(key_e(alice,bob,sid_5),g))),validkey(dhexp_real(key_s(alice),g)))),validkey(dhexp_real(key_m(alice),g)))),msg_a(alice,bob,sid_5))).

6. By 4, the attacker may know concat4(validkey(dhexp_real(key_e(alice,bob,sid_5),g)),encrypt(empty,minnonce,hash(hash(hash(somename,empty),empty),validkey(dhexp_real(key_e(alice,bob,sid_5),g))),validkey(dhexp_real(key_s(alice),g))),encrypt(empty,increment_nonce(minnonce),hash(hash(hash(hash(somename,empty),empty),validkey(dhexp_real(key_e(alice,bob,sid_5),g))),encrypt(empty,minnonce,hash(hash(hash(somename,empty),empty),validkey(dhexp_real(key_e(alice,bob,sid_5),g))),validkey(dhexp_real(key_s(alice),g)))),validkey(dhexp_real(key_m(alice),g))),encrypt(empty,increment_nonce(increment_nonce(minnonce)),hash(hash(hash(hash(hash(somename,empty),empty),validkey(dhexp_real(key_e(alice,bob,sid_5),g))),encrypt(empty,minnonce,hash(hash(hash(somename,empty),empty),validkey(dhexp_real(key_e(alice,bob,sid_5),g))),validkey(dhexp_real(key_s(alice),g)))),encrypt(empty,increment_nonce(minnonce),hash(hash(hash(hash(somename,empty),empty),validkey(dhexp_real(key_e(alice,bob,sid_5),g))),encrypt(empty,minnonce,hash(hash(hash(somename,empty),empty),validkey(dhexp_real(key_e(alice,bob,sid_5),g))),validkey(dhexp_real(key_s(alice),g)))),validkey(dhexp_real(key_m(alice),g)))),msg_a(alice,bob,sid_5))).
Using the function 3-proj-concat4 the attacker may obtain encrypt(empty,increment_nonce(minnonce),hash(hash(hash(hash(somename,empty),empty),validkey(dhexp_real(key_e(alice,bob,sid_5),g))),encrypt(empty,minnonce,hash(hash(hash(somename,empty),empty),validkey(dhexp_real(key_e(alice,bob,sid_5),g))),validkey(dhexp_real(key_s(alice),g)))),validkey(dhexp_real(key_m(alice),g))).
attacker(encrypt(empty,increment_nonce(minnonce),hash(hash(hash(hash(somename,empty),empty),validkey(dhexp_real(key_e(alice,bob,sid_5),g))),encrypt(empty,minnonce,hash(hash(hash(somename,empty),empty),validkey(dhexp_real(key_e(alice,bob,sid_5),g))),validkey(dhexp_real(key_s(alice),g)))),validkey(dhexp_real(key_m(alice),g)))).

7. By 4, the attacker may know concat4(validkey(dhexp_real(key_e(alice,bob,sid_5),g)),encrypt(empty,minnonce,hash(hash(hash(somename,empty),empty),validkey(dhexp_real(key_e(alice,bob,sid_5),g))),validkey(dhexp_real(key_s(alice),g))),encrypt(empty,increment_nonce(minnonce),hash(hash(hash(hash(somename,empty),empty),validkey(dhexp_real(key_e(alice,bob,sid_5),g))),encrypt(empty,minnonce,hash(hash(hash(somename,empty),empty),validkey(dhexp_real(key_e(alice,bob,sid_5),g))),validkey(dhexp_real(key_s(alice),g)))),validkey(dhexp_real(key_m(alice),g))),encrypt(empty,increment_nonce(increment_nonce(minnonce)),hash(hash(hash(hash(hash(somename,empty),empty),validkey(dhexp_real(key_e(alice,bob,sid_5),g))),encrypt(empty,minnonce,hash(hash(hash(somename,empty),empty),validkey(dhexp_real(key_e(alice,bob,sid_5),g))),validkey(dhexp_real(key_s(alice),g)))),encrypt(empty,increment_nonce(minnonce),hash(hash(hash(hash(somename,empty),empty),validkey(dhexp_real(key_e(alice,bob,sid_5),g))),encrypt(empty,minnonce,hash(hash(hash(somename,empty),empty),validkey(dhexp_real(key_e(alice,bob,sid_5),g))),validkey(dhexp_real(key_s(alice),g)))),validkey(dhexp_real(key_m(alice),g)))),msg_a(alice,bob,sid_5))).
Using the function 2-proj-concat4 the attacker may obtain encrypt(empty,minnonce,hash(hash(hash(somename,empty),empty),validkey(dhexp_real(key_e(alice,bob,sid_5),g))),validkey(dhexp_real(key_s(alice),g))).
attacker(encrypt(empty,minnonce,hash(hash(hash(somename,empty),empty),validkey(dhexp_real(key_e(alice,bob,sid_5),g))),validkey(dhexp_real(key_s(alice),g)))).

8. By 4, the attacker may know concat4(validkey(dhexp_real(key_e(alice,bob,sid_5),g)),encrypt(empty,minnonce,hash(hash(hash(somename,empty),empty),validkey(dhexp_real(key_e(alice,bob,sid_5),g))),validkey(dhexp_real(key_s(alice),g))),encrypt(empty,increment_nonce(minnonce),hash(hash(hash(hash(somename,empty),empty),validkey(dhexp_real(key_e(alice,bob,sid_5),g))),encrypt(empty,minnonce,hash(hash(hash(somename,empty),empty),validkey(dhexp_real(key_e(alice,bob,sid_5),g))),validkey(dhexp_real(key_s(alice),g)))),validkey(dhexp_real(key_m(alice),g))),encrypt(empty,increment_nonce(increment_nonce(minnonce)),hash(hash(hash(hash(hash(somename,empty),empty),validkey(dhexp_real(key_e(alice,bob,sid_5),g))),encrypt(empty,minnonce,hash(hash(hash(somename,empty),empty),validkey(dhexp_real(key_e(alice,bob,sid_5),g))),validkey(dhexp_real(key_s(alice),g)))),encrypt(empty,increment_nonce(minnonce),hash(hash(hash(hash(somename,empty),empty),validkey(dhexp_real(key_e(alice,bob,sid_5),g))),encrypt(empty,minnonce,hash(hash(hash(somename,empty),empty),validkey(dhexp_real(key_e(alice,bob,sid_5),g))),validkey(dhexp_real(key_s(alice),g)))),validkey(dhexp_real(key_m(alice),g)))),msg_a(alice,bob,sid_5))).
Using the function 1-proj-concat4 the attacker may obtain validkey(dhexp_real(key_e(alice,bob,sid_5),g)).
attacker(validkey(dhexp_real(key_e(alice,bob,sid_5),g))).

9. Using the function empty the attacker may obtain empty.
attacker(empty).

10. Using the function somename the attacker may obtain somename.
attacker(somename).

11. By 10, the attacker may know somename.
By 9, the attacker may know empty.
Using the function hash the attacker may obtain hash(somename,empty).
attacker(hash(somename,empty)).

12. By 11, the attacker may know hash(somename,empty).
By 9, the attacker may know empty.
Using the function hash the attacker may obtain hash(hash(somename,empty),empty).
attacker(hash(hash(somename,empty),empty)).

13. By 12, the attacker may know hash(hash(somename,empty),empty).
By 8, the attacker may know validkey(dhexp_real(key_e(alice,bob,sid_5),g)).
Using the function hash the attacker may obtain hash(hash(hash(somename,empty),empty),validkey(dhexp_real(key_e(alice,bob,sid_5),g))).
attacker(hash(hash(hash(somename,empty),empty),validkey(dhexp_real(key_e(alice,bob,sid_5),g)))).

14. By 13, the attacker may know hash(hash(hash(somename,empty),empty),validkey(dhexp_real(key_e(alice,bob,sid_5),g))).
By 7, the attacker may know encrypt(empty,minnonce,hash(hash(hash(somename,empty),empty),validkey(dhexp_real(key_e(alice,bob,sid_5),g))),validkey(dhexp_real(key_s(alice),g))).
Using the function hash the attacker may obtain hash(hash(hash(hash(somename,empty),empty),validkey(dhexp_real(key_e(alice,bob,sid_5),g))),encrypt(empty,minnonce,hash(hash(hash(somename,empty),empty),validkey(dhexp_real(key_e(alice,bob,sid_5),g))),validkey(dhexp_real(key_s(alice),g)))).
attacker(hash(hash(hash(hash(somename,empty),empty),validkey(dhexp_real(key_e(alice,bob,sid_5),g))),encrypt(empty,minnonce,hash(hash(hash(somename,empty),empty),validkey(dhexp_real(key_e(alice,bob,sid_5),g))),validkey(dhexp_real(key_s(alice),g))))).

15. By 14, the attacker may know hash(hash(hash(hash(somename,empty),empty),validkey(dhexp_real(key_e(alice,bob,sid_5),g))),encrypt(empty,minnonce,hash(hash(hash(somename,empty),empty),validkey(dhexp_real(key_e(alice,bob,sid_5),g))),validkey(dhexp_real(key_s(alice),g)))).
By 6, the attacker may know encrypt(empty,increment_nonce(minnonce),hash(hash(hash(hash(somename,empty),empty),validkey(dhexp_real(key_e(alice,bob,sid_5),g))),encrypt(empty,minnonce,hash(hash(hash(somename,empty),empty),validkey(dhexp_real(key_e(alice,bob,sid_5),g))),validkey(dhexp_real(key_s(alice),g)))),validkey(dhexp_real(key_m(alice),g))).
Using the function hash the attacker may obtain hash(hash(hash(hash(hash(somename,empty),empty),validkey(dhexp_real(key_e(alice,bob,sid_5),g))),encrypt(empty,minnonce,hash(hash(hash(somename,empty),empty),validkey(dhexp_real(key_e(alice,bob,sid_5),g))),validkey(dhexp_real(key_s(alice),g)))),encrypt(empty,increment_nonce(minnonce),hash(hash(hash(hash(somename,empty),empty),validkey(dhexp_real(key_e(alice,bob,sid_5),g))),encrypt(empty,minnonce,hash(hash(hash(somename,empty),empty),validkey(dhexp_real(key_e(alice,bob,sid_5),g))),validkey(dhexp_real(key_s(alice),g)))),validkey(dhexp_real(key_m(alice),g)))).
attacker(hash(hash(hash(hash(hash(somename,empty),empty),validkey(dhexp_real(key_e(alice,bob,sid_5),g))),encrypt(empty,minnonce,hash(hash(hash(somename,empty),empty),validkey(dhexp_real(key_e(alice,bob,sid_5),g))),validkey(dhexp_real(key_s(alice),g)))),encrypt(empty,increment_nonce(minnonce),hash(hash(hash(hash(somename,empty),empty),validkey(dhexp_real(key_e(alice,bob,sid_5),g))),encrypt(empty,minnonce,hash(hash(hash(somename,empty),empty),validkey(dhexp_real(key_e(alice,bob,sid_5),g))),validkey(dhexp_real(key_s(alice),g)))),validkey(dhexp_real(key_m(alice),g))))).

16. Using the function minnonce the attacker may obtain minnonce.
attacker(minnonce).

17. By 16, the attacker may know minnonce.
Using the function increment_nonce the attacker may obtain increment_nonce(minnonce).
attacker(increment_nonce(minnonce)).

18. By 17, the attacker may know increment_nonce(minnonce).
Using the function increment_nonce the attacker may obtain increment_nonce(increment_nonce(minnonce)).
attacker(increment_nonce(increment_nonce(minnonce))).

19. By 9, the attacker may know empty.
By 18, the attacker may know increment_nonce(increment_nonce(minnonce)).
By 15, the attacker may know hash(hash(hash(hash(hash(somename,empty),empty),validkey(dhexp_real(key_e(alice,bob,sid_5),g))),encrypt(empty,minnonce,hash(hash(hash(somename,empty),empty),validkey(dhexp_real(key_e(alice,bob,sid_5),g))),validkey(dhexp_real(key_s(alice),g)))),encrypt(empty,increment_nonce(minnonce),hash(hash(hash(hash(somename,empty),empty),validkey(dhexp_real(key_e(alice,bob,sid_5),g))),encrypt(empty,minnonce,hash(hash(hash(somename,empty),empty),validkey(dhexp_real(key_e(alice,bob,sid_5),g))),validkey(dhexp_real(key_s(alice),g)))),validkey(dhexp_real(key_m(alice),g)))).
By 5, the attacker may know encrypt(empty,increment_nonce(increment_nonce(minnonce)),hash(hash(hash(hash(hash(somename,empty),empty),validkey(dhexp_real(key_e(alice,bob,sid_5),g))),encrypt(empty,minnonce,hash(hash(hash(somename,empty),empty),validkey(dhexp_real(key_e(alice,bob,sid_5),g))),validkey(dhexp_real(key_s(alice),g)))),encrypt(empty,increment_nonce(minnonce),hash(hash(hash(hash(somename,empty),empty),validkey(dhexp_real(key_e(alice,bob,sid_5),g))),encrypt(empty,minnonce,hash(hash(hash(somename,empty),empty),validkey(dhexp_real(key_e(alice,bob,sid_5),g))),validkey(dhexp_real(key_s(alice),g)))),validkey(dhexp_real(key_m(alice),g)))),msg_a(alice,bob,sid_5)).
Using the function decrypt the attacker may obtain aeadpack(true,hash(hash(hash(hash(hash(somename,empty),empty),validkey(dhexp_real(key_e(alice,bob,sid_5),g))),encrypt(empty,minnonce,hash(hash(hash(somename,empty),empty),validkey(dhexp_real(key_e(alice,bob,sid_5),g))),validkey(dhexp_real(key_s(alice),g)))),encrypt(empty,increment_nonce(minnonce),hash(hash(hash(hash(somename,empty),empty),validkey(dhexp_real(key_e(alice,bob,sid_5),g))),encrypt(empty,minnonce,hash(hash(hash(somename,empty),empty),validkey(dhexp_real(key_e(alice,bob,sid_5),g))),validkey(dhexp_real(key_s(alice),g)))),validkey(dhexp_real(key_m(alice),g)))),msg_a(alice,bob,sid_5)).
attacker(aeadpack(true,hash(hash(hash(hash(hash(somename,empty),empty),validkey(dhexp_real(key_e(alice,bob,sid_5),g))),encrypt(empty,minnonce,hash(hash(hash(somename,empty),empty),validkey(dhexp_real(key_e(alice,bob,sid_5),g))),validkey(dhexp_real(key_s(alice),g)))),encrypt(empty,increment_nonce(minnonce),hash(hash(hash(hash(somename,empty),empty),validkey(dhexp_real(key_e(alice,bob,sid_5),g))),encrypt(empty,minnonce,hash(hash(hash(somename,empty),empty),validkey(dhexp_real(key_e(alice,bob,sid_5),g))),validkey(dhexp_real(key_s(alice),g)))),validkey(dhexp_real(key_m(alice),g)))),msg_a(alice,bob,sid_5))).

20. By 19, the attacker may know aeadpack(true,hash(hash(hash(hash(hash(somename,empty),empty),validkey(dhexp_real(key_e(alice,bob,sid_5),g))),encrypt(empty,minnonce,hash(hash(hash(somename,empty),empty),validkey(dhexp_real(key_e(alice,bob,sid_5),g))),validkey(dhexp_real(key_s(alice),g)))),encrypt(empty,increment_nonce(minnonce),hash(hash(hash(hash(somename,empty),empty),validkey(dhexp_real(key_e(alice,bob,sid_5),g))),encrypt(empty,minnonce,hash(hash(hash(somename,empty),empty),validkey(dhexp_real(key_e(alice,bob,sid_5),g))),validkey(dhexp_real(key_s(alice),g)))),validkey(dhexp_real(key_m(alice),g)))),msg_a(alice,bob,sid_5)).
Using the function 3-proj-aeadpack the attacker may obtain msg_a(alice,bob,sid_5).
attacker(msg_a(alice,bob,sid_5)).

21. By 20, the attacker may know msg_a(alice,bob,sid_5).
So the attacker may know msg_a(alice,bob,sid_5) in phase 1.
attacker_p1(msg_a(alice,bob,sid_5)).

22. By 21, attacker_p1(msg_a(alice,bob,sid_5)).
The goal is reached, represented in the following fact:
attacker_p1(msg_a(alice,bob,sid_5)).


RESULT attacker_p1(msg_a(alice,bob,sid_a)) ==> event(LeakS(px,bob)) && event(LeakM(px,bob)) cannot be proved.
Starting query attacker_p1(msg_a(alice,bob,sid_a)) ==> (event(LeakS(phase0,bob)) && event(LeakM(phase0,bob))) || (event(LeakS(px,bob)) && event(LeakM(px,bob)) && event(LeakS(pz,alice)) && event(LeakM(pz,alice)))
goal reachable: begin(SendMsg(alice,bob,stagepack_a(sid_5),msg_a(alice,bob,sid_5))) -> attacker_p1(msg_a(alice,bob,sid_5))
Abbreviations:
sid_5 = sid[!1 = @sid]

Derivation:
Abbreviations:
sid_5 = sid[!1 = @sid]

1. Using the function pub the attacker may obtain pub.
attacker(pub).

2. The entry statestore(alice,bob,sid_5,statepack_a(handshakestatepack(symmetricstatepack(cipherstatepack(empty,minnonce),hash(somename,empty),hash(hash(somename,empty),empty)),keypairpack(empty,empty),keypairpack(empty,empty),keypairpack(empty,empty),empty,empty,empty,empty,true))) may be inserted in a table at insert {30}.
table(statestore(alice,bob,sid_5,statepack_a(handshakestatepack(symmetricstatepack(cipherstatepack(empty,minnonce),hash(somename,empty),hash(hash(somename,empty),empty)),keypairpack(empty,empty),keypairpack(empty,empty),keypairpack(empty,empty),empty,empty,empty,empty,true)))).

3. The entry statestore(alice,bob,sid_5,statepack_a(handshakestatepack(symmetricstatepack(cipherstatepack(empty,minnonce),hash(somename,empty),hash(hash(somename,empty),empty)),keypairpack(empty,empty),keypairpack(empty,empty),keypairpack(empty,empty),empty,empty,empty,empty,true))) that may be in a table by 2 may be read at get {182}.
The event SendMsg(alice,bob,stagepack_a(sid_5),msg_a(alice,bob,sid_5)) may be executed at {179}.
So the message concat4(validkey(dhexp_real(key_e(alice,bob,sid_5),g)),encrypt(empty,minnonce,hash(hash(hash(somename,empty),empty),validkey(dhexp_real(key_e(alice,bob,sid_5),g))),validkey(dhexp_real(key_s(alice),g))),encrypt(empty,increment_nonce(minnonce),hash(hash(hash(hash(somename,empty),empty),validkey(dhexp_real(key_e(alice,bob,sid_5),g))),encrypt(empty,minnonce,hash(hash(hash(somename,empty),empty),validkey(dhexp_real(key_e(alice,bob,sid_5),g))),validkey(dhexp_real(key_s(alice),g)))),validkey(dhexp_real(key_m(alice),g))),encrypt(empty,increment_nonce(increment_nonce(minnonce)),hash(hash(hash(hash(hash(somename,empty),empty),validkey(dhexp_real(key_e(alice,bob,sid_5),g))),encrypt(empty,minnonce,hash(hash(hash(somename,empty),empty),validkey(dhexp_real(key_e(alice,bob,sid_5),g))),validkey(dhexp_real(key_s(alice),g)))),encrypt(empty,increment_nonce(minnonce),hash(hash(hash(hash(somename,empty),empty),validkey(dhexp_real(key_e(alice,bob,sid_5),g))),encrypt(empty,minnonce,hash(hash(hash(somename,empty),empty),validkey(dhexp_real(key_e(alice,bob,sid_5),g))),validkey(dhexp_real(key_s(alice),g)))),validkey(dhexp_real(key_m(alice),g)))),msg_a(alice,bob,sid_5))) may be sent on channel pub at output {181}.
mess(pub,concat4(validkey(dhexp_real(key_e(alice,bob,sid_5),g)),encrypt(empty,minnonce,hash(hash(hash(somename,empty),empty),validkey(dhexp_real(key_e(alice,bob,sid_5),g))),validkey(dhexp_real(key_s(alice),g))),encrypt(empty,increment_nonce(minnonce),hash(hash(hash(hash(somename,empty),empty),validkey(dhexp_real(key_e(alice,bob,sid_5),g))),encrypt(empty,minnonce,hash(hash(hash(somename,empty),empty),validkey(dhexp_real(key_e(alice,bob,sid_5),g))),validkey(dhexp_real(key_s(alice),g)))),validkey(dhexp_real(key_m(alice),g))),encrypt(empty,increment_nonce(increment_nonce(minnonce)),hash(hash(hash(hash(hash(somename,empty),empty),validkey(dhexp_real(key_e(alice,bob,sid_5),g))),encrypt(empty,minnonce,hash(hash(hash(somename,empty),empty),validkey(dhexp_real(key_e(alice,bob,sid_5),g))),validkey(dhexp_real(key_s(alice),g)))),encrypt(empty,increment_nonce(minnonce),hash(hash(hash(hash(somename,empty),empty),validkey(dhexp_real(key_e(alice,bob,sid_5),g))),encrypt(empty,minnonce,hash(hash(hash(somename,empty),empty),validkey(dhexp_real(key_e(alice,bob,sid_5),g))),validkey(dhexp_real(key_s(alice),g)))),validkey(dhexp_real(key_m(alice),g)))),msg_a(alice,bob,sid_5)))).

4. By 1, the attacker may have the channel pub.
By 3, the message concat4(validkey(dhexp_real(key_e(alice,bob,sid_5),g)),encrypt(empty,minnonce,hash(hash(hash(somename,empty),empty),validkey(dhexp_real(key_e(alice,bob,sid_5),g))),validkey(dhexp_real(key_s(alice),g))),encrypt(empty,increment_nonce(minnonce),hash(hash(hash(hash(somename,empty),empty),validkey(dhexp_real(key_e(alice,bob,sid_5),g))),encrypt(empty,minnonce,hash(hash(hash(somename,empty),empty),validkey(dhexp_real(key_e(alice,bob,sid_5),g))),validkey(dhexp_real(key_s(alice),g)))),validkey(dhexp_real(key_m(alice),g))),encrypt(empty,increment_nonce(increment_nonce(minnonce)),hash(hash(hash(hash(hash(somename,empty),empty),validkey(dhexp_real(key_e(alice,bob,sid_5),g))),encrypt(empty,minnonce,hash(hash(hash(somename,empty),empty),validkey(dhexp_real(key_e(alice,bob,sid_5),g))),validkey(dhexp_real(key_s(alice),g)))),encrypt(empty,increment_nonce(minnonce),hash(hash(hash(hash(somename,empty),empty),validkey(dhexp_real(key_e(alice,bob,sid_5),g))),encrypt(empty,minnonce,hash(hash(hash(somename,empty),empty),validkey(dhexp_real(key_e(alice,bob,sid_5),g))),validkey(dhexp_real(key_s(alice),g)))),validkey(dhexp_real(key_m(alice),g)))),msg_a(alice,bob,sid_5))) may be sent on this channel.
So the attacker may obtain the message concat4(validkey(dhexp_real(key_e(alice,bob,sid_5),g)),encrypt(empty,minnonce,hash(hash(hash(somename,empty),empty),validkey(dhexp_real(key_e(alice,bob,sid_5),g))),validkey(dhexp_real(key_s(alice),g))),encrypt(empty,increment_nonce(minnonce),hash(hash(hash(hash(somename,empty),empty),validkey(dhexp_real(key_e(alice,bob,sid_5),g))),encrypt(empty,minnonce,hash(hash(hash(somename,empty),empty),validkey(dhexp_real(key_e(alice,bob,sid_5),g))),validkey(dhexp_real(key_s(alice),g)))),validkey(dhexp_real(key_m(alice),g))),encrypt(empty,increment_nonce(increment_nonce(minnonce)),hash(hash(hash(hash(hash(somename,empty),empty),validkey(dhexp_real(key_e(alice,bob,sid_5),g))),encrypt(empty,minnonce,hash(hash(hash(somename,empty),empty),validkey(dhexp_real(key_e(alice,bob,sid_5),g))),validkey(dhexp_real(key_s(alice),g)))),encrypt(empty,increment_nonce(minnonce),hash(hash(hash(hash(somename,empty),empty),validkey(dhexp_real(key_e(alice,bob,sid_5),g))),encrypt(empty,minnonce,hash(hash(hash(somename,empty),empty),validkey(dhexp_real(key_e(alice,bob,sid_5),g))),validkey(dhexp_real(key_s(alice),g)))),validkey(dhexp_real(key_m(alice),g)))),msg_a(alice,bob,sid_5))) by listening on this channel.
attacker(concat4(validkey(dhexp_real(key_e(alice,bob,sid_5),g)),encrypt(empty,minnonce,hash(hash(hash(somename,empty),empty),validkey(dhexp_real(key_e(alice,bob,sid_5),g))),validkey(dhexp_real(key_s(alice),g))),encrypt(empty,increment_nonce(minnonce),hash(hash(hash(hash(somename,empty),empty),validkey(dhexp_real(key_e(alice,bob,sid_5),g))),encrypt(empty,minnonce,hash(hash(hash(somename,empty),empty),validkey(dhexp_real(key_e(alice,bob,sid_5),g))),validkey(dhexp_real(key_s(alice),g)))),validkey(dhexp_real(key_m(alice),g))),encrypt(empty,increment_nonce(increment_nonce(minnonce)),hash(hash(hash(hash(hash(somename,empty),empty),validkey(dhexp_real(key_e(alice,bob,sid_5),g))),encrypt(empty,minnonce,hash(hash(hash(somename,empty),empty),validkey(dhexp_real(key_e(alice,bob,sid_5),g))),validkey(dhexp_real(key_s(alice),g)))),encrypt(empty,increment_nonce(minnonce),hash(hash(hash(hash(somename,empty),empty),validkey(dhexp_real(key_e(alice,bob,sid_5),g))),encrypt(empty,minnonce,hash(hash(hash(somename,empty),empty),validkey(dhexp_real(key_e(alice,bob,sid_5),g))),validkey(dhexp_real(key_s(alice),g)))),validkey(dhexp_real(key_m(alice),g)))),msg_a(alice,bob,sid_5)))).

5. By 4, the attacker may know concat4(validkey(dhexp_real(key_e(alice,bob,sid_5),g)),encrypt(empty,minnonce,hash(hash(hash(somename,empty),empty),validkey(dhexp_real(key_e(alice,bob,sid_5),g))),validkey(dhexp_real(key_s(alice),g))),encrypt(empty,increment_nonce(minnonce),hash(hash(hash(hash(somename,empty),empty),validkey(dhexp_real(key_e(alice,bob,sid_5),g))),encrypt(empty,minnonce,hash(hash(hash(somename,empty),empty),validkey(dhexp_real(key_e(alice,bob,sid_5),g))),validkey(dhexp_real(key_s(alice),g)))),validkey(dhexp_real(key_m(alice),g))),encrypt(empty,increment_nonce(increment_nonce(minnonce)),hash(hash(hash(hash(hash(somename,empty),empty),validkey(dhexp_real(key_e(alice,bob,sid_5),g))),encrypt(empty,minnonce,hash(hash(hash(somename,empty),empty),validkey(dhexp_real(key_e(alice,bob,sid_5),g))),validkey(dhexp_real(key_s(alice),g)))),encrypt(empty,increment_nonce(minnonce),hash(hash(hash(hash(somename,empty),empty),validkey(dhexp_real(key_e(alice,bob,sid_5),g))),encrypt(empty,minnonce,hash(hash(hash(somename,empty),empty),validkey(dhexp_real(key_e(alice,bob,sid_5),g))),validkey(dhexp_real(key_s(alice),g)))),validkey(dhexp_real(key_m(alice),g)))),msg_a(alice,bob,sid_5))).
Using the function 4-proj-concat4 the attacker may obtain encrypt(empty,increment_nonce(increment_nonce(minnonce)),hash(hash(hash(hash(hash(somename,empty),empty),validkey(dhexp_real(key_e(alice,bob,sid_5),g))),encrypt(empty,minnonce,hash(hash(hash(somename,empty),empty),validkey(dhexp_real(key_e(alice,bob,sid_5),g))),validkey(dhexp_real(key_s(alice),g)))),encrypt(empty,increment_nonce(minnonce),hash(hash(hash(hash(somename,empty),empty),validkey(dhexp_real(key_e(alice,bob,sid_5),g))),encrypt(empty,minnonce,hash(hash(hash(somename,empty),empty),validkey(dhexp_real(key_e(alice,bob,sid_5),g))),validkey(dhexp_real(key_s(alice),g)))),validkey(dhexp_real(key_m(alice),g)))),msg_a(alice,bob,sid_5)).
attacker(encrypt(empty,increment_nonce(increment_nonce(minnonce)),hash(hash(hash(hash(hash(somename,empty),empty),validkey(dhexp_real(key_e(alice,bob,sid_5),g))),encrypt(empty,minnonce,hash(hash(hash(somename,empty),empty),validkey(dhexp_real(key_e(alice,bob,sid_5),g))),validkey(dhexp_real(key_s(alice),g)))),encrypt(empty,increment_nonce(minnonce),hash(hash(hash(hash(somename,empty),empty),validkey(dhexp_real(key_e(alice,bob,sid_5),g))),encrypt(empty,minnonce,hash(hash(hash(somename,empty),empty),validkey(dhexp_real(key_e(alice,bob,sid_5),g))),validkey(dhexp_real(key_s(alice),g)))),validkey(dhexp_real(key_m(alice),g)))),msg_a(alice,bob,sid_5))).

6. By 4, the attacker may know concat4(validkey(dhexp_real(key_e(alice,bob,sid_5),g)),encrypt(empty,minnonce,hash(hash(hash(somename,empty),empty),validkey(dhexp_real(key_e(alice,bob,sid_5),g))),validkey(dhexp_real(key_s(alice),g))),encrypt(empty,increment_nonce(minnonce),hash(hash(hash(hash(somename,empty),empty),validkey(dhexp_real(key_e(alice,bob,sid_5),g))),encrypt(empty,minnonce,hash(hash(hash(somename,empty),empty),validkey(dhexp_real(key_e(alice,bob,sid_5),g))),validkey(dhexp_real(key_s(alice),g)))),validkey(dhexp_real(key_m(alice),g))),encrypt(empty,increment_nonce(increment_nonce(minnonce)),hash(hash(hash(hash(hash(somename,empty),empty),validkey(dhexp_real(key_e(alice,bob,sid_5),g))),encrypt(empty,minnonce,hash(hash(hash(somename,empty),empty),validkey(dhexp_real(key_e(alice,bob,sid_5),g))),validkey(dhexp_real(key_s(alice),g)))),encrypt(empty,increment_nonce(minnonce),hash(hash(hash(hash(somename,empty),empty),validkey(dhexp_real(key_e(alice,bob,sid_5),g))),encrypt(empty,minnonce,hash(hash(hash(somename,empty),empty),validkey(dhexp_real(key_e(alice,bob,sid_5),g))),validkey(dhexp_real(key_s(alice),g)))),validkey(dhexp_real(key_m(alice),g)))),msg_a(alice,bob,sid_5))).
Using the function 3-proj-concat4 the attacker may obtain encrypt(empty,increment_nonce(minnonce),hash(hash(hash(hash(somename,empty),empty),validkey(dhexp_real(key_e(alice,bob,sid_5),g))),encrypt(empty,minnonce,hash(hash(hash(somename,empty),empty),validkey(dhexp_real(key_e(alice,bob,sid_5),g))),validkey(dhexp_real(key_s(alice),g)))),validkey(dhexp_real(key_m(alice),g))).
attacker(encrypt(empty,increment_nonce(minnonce),hash(hash(hash(hash(somename,empty),empty),validkey(dhexp_real(key_e(alice,bob,sid_5),g))),encrypt(empty,minnonce,hash(hash(hash(somename,empty),empty),validkey(dhexp_real(key_e(alice,bob,sid_5),g))),validkey(dhexp_real(key_s(alice),g)))),validkey(dhexp_real(key_m(alice),g)))).

7. By 4, the attacker may know concat4(validkey(dhexp_real(key_e(alice,bob,sid_5),g)),encrypt(empty,minnonce,hash(hash(hash(somename,empty),empty),validkey(dhexp_real(key_e(alice,bob,sid_5),g))),validkey(dhexp_real(key_s(alice),g))),encrypt(empty,increment_nonce(minnonce),hash(hash(hash(hash(somename,empty),empty),validkey(dhexp_real(key_e(alice,bob,sid_5),g))),encrypt(empty,minnonce,hash(hash(hash(somename,empty),empty),validkey(dhexp_real(key_e(alice,bob,sid_5),g))),validkey(dhexp_real(key_s(alice),g)))),validkey(dhexp_real(key_m(alice),g))),encrypt(empty,increment_nonce(increment_nonce(minnonce)),hash(hash(hash(hash(hash(somename,empty),empty),validkey(dhexp_real(key_e(alice,bob,sid_5),g))),encrypt(empty,minnonce,hash(hash(hash(somename,empty),empty),validkey(dhexp_real(key_e(alice,bob,sid_5),g))),validkey(dhexp_real(key_s(alice),g)))),encrypt(empty,increment_nonce(minnonce),hash(hash(hash(hash(somename,empty),empty),validkey(dhexp_real(key_e(alice,bob,sid_5),g))),encrypt(empty,minnonce,hash(hash(hash(somename,empty),empty),validkey(dhexp_real(key_e(alice,bob,sid_5),g))),validkey(dhexp_real(key_s(alice),g)))),validkey(dhexp_real(key_m(alice),g)))),msg_a(alice,bob,sid_5))).
Using the function 2-proj-concat4 the attacker may obtain encrypt(empty,minnonce,hash(hash(hash(somename,empty),empty),validkey(dhexp_real(key_e(alice,bob,sid_5),g))),validkey(dhexp_real(key_s(alice),g))).
attacker(encrypt(empty,minnonce,hash(hash(hash(somename,empty),empty),validkey(dhexp_real(key_e(alice,bob,sid_5),g))),validkey(dhexp_real(key_s(alice),g)))).

8. By 4, the attacker may know concat4(validkey(dhexp_real(key_e(alice,bob,sid_5),g)),encrypt(empty,minnonce,hash(hash(hash(somename,empty),empty),validkey(dhexp_real(key_e(alice,bob,sid_5),g))),validkey(dhexp_real(key_s(alice),g))),encrypt(empty,increment_nonce(minnonce),hash(hash(hash(hash(somename,empty),empty),validkey(dhexp_real(key_e(alice,bob,sid_5),g))),encrypt(empty,minnonce,hash(hash(hash(somename,empty),empty),validkey(dhexp_real(key_e(alice,bob,sid_5),g))),validkey(dhexp_real(key_s(alice),g)))),validkey(dhexp_real(key_m(alice),g))),encrypt(empty,increment_nonce(increment_nonce(minnonce)),hash(hash(hash(hash(hash(somename,empty),empty),validkey(dhexp_real(key_e(alice,bob,sid_5),g))),encrypt(empty,minnonce,hash(hash(hash(somename,empty),empty),validkey(dhexp_real(key_e(alice,bob,sid_5),g))),validkey(dhexp_real(key_s(alice),g)))),encrypt(empty,increment_nonce(minnonce),hash(hash(hash(hash(somename,empty),empty),validkey(dhexp_real(key_e(alice,bob,sid_5),g))),encrypt(empty,minnonce,hash(hash(hash(somename,empty),empty),validkey(dhexp_real(key_e(alice,bob,sid_5),g))),validkey(dhexp_real(key_s(alice),g)))),validkey(dhexp_real(key_m(alice),g)))),msg_a(alice,bob,sid_5))).
Using the function 1-proj-concat4 the attacker may obtain validkey(dhexp_real(key_e(alice,bob,sid_5),g)).
attacker(validkey(dhexp_real(key_e(alice,bob,sid_5),g))).

9. Using the function empty the attacker may obtain empty.
attacker(empty).

10. Using the function somename the attacker may obtain somename.
attacker(somename).

11. By 10, the attacker may know somename.
By 9, the attacker may know empty.
Using the function hash the attacker may obtain hash(somename,empty).
attacker(hash(somename,empty)).

12. By 11, the attacker may know hash(somename,empty).
By 9, the attacker may know empty.
Using the function hash the attacker may obtain hash(hash(somename,empty),empty).
attacker(hash(hash(somename,empty),empty)).

13. By 12, the attacker may know hash(hash(somename,empty),empty).
By 8, the attacker may know validkey(dhexp_real(key_e(alice,bob,sid_5),g)).
Using the function hash the attacker may obtain hash(hash(hash(somename,empty),empty),validkey(dhexp_real(key_e(alice,bob,sid_5),g))).
attacker(hash(hash(hash(somename,empty),empty),validkey(dhexp_real(key_e(alice,bob,sid_5),g)))).

14. By 13, the attacker may know hash(hash(hash(somename,empty),empty),validkey(dhexp_real(key_e(alice,bob,sid_5),g))).
By 7, the attacker may know encrypt(empty,minnonce,hash(hash(hash(somename,empty),empty),validkey(dhexp_real(key_e(alice,bob,sid_5),g))),validkey(dhexp_real(key_s(alice),g))).
Using the function hash the attacker may obtain hash(hash(hash(hash(somename,empty),empty),validkey(dhexp_real(key_e(alice,bob,sid_5),g))),encrypt(empty,minnonce,hash(hash(hash(somename,empty),empty),validkey(dhexp_real(key_e(alice,bob,sid_5),g))),validkey(dhexp_real(key_s(alice),g)))).
attacker(hash(hash(hash(hash(somename,empty),empty),validkey(dhexp_real(key_e(alice,bob,sid_5),g))),encrypt(empty,minnonce,hash(hash(hash(somename,empty),empty),validkey(dhexp_real(key_e(alice,bob,sid_5),g))),validkey(dhexp_real(key_s(alice),g))))).

15. By 14, the attacker may know hash(hash(hash(hash(somename,empty),empty),validkey(dhexp_real(key_e(alice,bob,sid_5),g))),encrypt(empty,minnonce,hash(hash(hash(somename,empty),empty),validkey(dhexp_real(key_e(alice,bob,sid_5),g))),validkey(dhexp_real(key_s(alice),g)))).
By 6, the attacker may know encrypt(empty,increment_nonce(minnonce),hash(hash(hash(hash(somename,empty),empty),validkey(dhexp_real(key_e(alice,bob,sid_5),g))),encrypt(empty,minnonce,hash(hash(hash(somename,empty),empty),validkey(dhexp_real(key_e(alice,bob,sid_5),g))),validkey(dhexp_real(key_s(alice),g)))),validkey(dhexp_real(key_m(alice),g))).
Using the function hash the attacker may obtain hash(hash(hash(hash(hash(somename,empty),empty),validkey(dhexp_real(key_e(alice,bob,sid_5),g))),encrypt(empty,minnonce,hash(hash(hash(somename,empty),empty),validkey(dhexp_real(key_e(alice,bob,sid_5),g))),validkey(dhexp_real(key_s(alice),g)))),encrypt(empty,increment_nonce(minnonce),hash(hash(hash(hash(somename,empty),empty),validkey(dhexp_real(key_e(alice,bob,sid_5),g))),encrypt(empty,minnonce,hash(hash(hash(somename,empty),empty),validkey(dhexp_real(key_e(alice,bob,sid_5),g))),validkey(dhexp_real(key_s(alice),g)))),validkey(dhexp_real(key_m(alice),g)))).
attacker(hash(hash(hash(hash(hash(somename,empty),empty),validkey(dhexp_real(key_e(alice,bob,sid_5),g))),encrypt(empty,minnonce,hash(hash(hash(somename,empty),empty),validkey(dhexp_real(key_e(alice,bob,sid_5),g))),validkey(dhexp_real(key_s(alice),g)))),encrypt(empty,increment_nonce(minnonce),hash(hash(hash(hash(somename,empty),empty),validkey(dhexp_real(key_e(alice,bob,sid_5),g))),encrypt(empty,minnonce,hash(hash(hash(somename,empty),empty),validkey(dhexp_real(key_e(alice,bob,sid_5),g))),validkey(dhexp_real(key_s(alice),g)))),validkey(dhexp_real(key_m(alice),g))))).

16. Using the function minnonce the attacker may obtain minnonce.
attacker(minnonce).

17. By 16, the attacker may know minnonce.
Using the function increment_nonce the attacker may obtain increment_nonce(minnonce).
attacker(increment_nonce(minnonce)).

18. By 17, the attacker may know increment_nonce(minnonce).
Using the function increment_nonce the attacker may obtain increment_nonce(increment_nonce(minnonce)).
attacker(increment_nonce(increment_nonce(minnonce))).

19. By 9, the attacker may know empty.
By 18, the attacker may know increment_nonce(increment_nonce(minnonce)).
By 15, the attacker may know hash(hash(hash(hash(hash(somename,empty),empty),validkey(dhexp_real(key_e(alice,bob,sid_5),g))),encrypt(empty,minnonce,hash(hash(hash(somename,empty),empty),validkey(dhexp_real(key_e(alice,bob,sid_5),g))),validkey(dhexp_real(key_s(alice),g)))),encrypt(empty,increment_nonce(minnonce),hash(hash(hash(hash(somename,empty),empty),validkey(dhexp_real(key_e(alice,bob,sid_5),g))),encrypt(empty,minnonce,hash(hash(hash(somename,empty),empty),validkey(dhexp_real(key_e(alice,bob,sid_5),g))),validkey(dhexp_real(key_s(alice),g)))),validkey(dhexp_real(key_m(alice),g)))).
By 5, the attacker may know encrypt(empty,increment_nonce(increment_nonce(minnonce)),hash(hash(hash(hash(hash(somename,empty),empty),validkey(dhexp_real(key_e(alice,bob,sid_5),g))),encrypt(empty,minnonce,hash(hash(hash(somename,empty),empty),validkey(dhexp_real(key_e(alice,bob,sid_5),g))),validkey(dhexp_real(key_s(alice),g)))),encrypt(empty,increment_nonce(minnonce),hash(hash(hash(hash(somename,empty),empty),validkey(dhexp_real(key_e(alice,bob,sid_5),g))),encrypt(empty,minnonce,hash(hash(hash(somename,empty),empty),validkey(dhexp_real(key_e(alice,bob,sid_5),g))),validkey(dhexp_real(key_s(alice),g)))),validkey(dhexp_real(key_m(alice),g)))),msg_a(alice,bob,sid_5)).
Using the function decrypt the attacker may obtain aeadpack(true,hash(hash(hash(hash(hash(somename,empty),empty),validkey(dhexp_real(key_e(alice,bob,sid_5),g))),encrypt(empty,minnonce,hash(hash(hash(somename,empty),empty),validkey(dhexp_real(key_e(alice,bob,sid_5),g))),validkey(dhexp_real(key_s(alice),g)))),encrypt(empty,increment_nonce(minnonce),hash(hash(hash(hash(somename,empty),empty),validkey(dhexp_real(key_e(alice,bob,sid_5),g))),encrypt(empty,minnonce,hash(hash(hash(somename,empty),empty),validkey(dhexp_real(key_e(alice,bob,sid_5),g))),validkey(dhexp_real(key_s(alice),g)))),validkey(dhexp_real(key_m(alice),g)))),msg_a(alice,bob,sid_5)).
attacker(aeadpack(true,hash(hash(hash(hash(hash(somename,empty),empty),validkey(dhexp_real(key_e(alice,bob,sid_5),g))),encrypt(empty,minnonce,hash(hash(hash(somename,empty),empty),validkey(dhexp_real(key_e(alice,bob,sid_5),g))),validkey(dhexp_real(key_s(alice),g)))),encrypt(empty,increment_nonce(minnonce),hash(hash(hash(hash(somename,empty),empty),validkey(dhexp_real(key_e(alice,bob,sid_5),g))),encrypt(empty,minnonce,hash(hash(hash(somename,empty),empty),validkey(dhexp_real(key_e(alice,bob,sid_5),g))),validkey(dhexp_real(key_s(alice),g)))),validkey(dhexp_real(key_m(alice),g)))),msg_a(alice,bob,sid_5))).

20. By 19, the attacker may know aeadpack(true,hash(hash(hash(hash(hash(somename,empty),empty),validkey(dhexp_real(key_e(alice,bob,sid_5),g))),encrypt(empty,minnonce,hash(hash(hash(somename,empty),empty),validkey(dhexp_real(key_e(alice,bob,sid_5),g))),validkey(dhexp_real(key_s(alice),g)))),encrypt(empty,increment_nonce(minnonce),hash(hash(hash(hash(somename,empty),empty),validkey(dhexp_real(key_e(alice,bob,sid_5),g))),encrypt(empty,minnonce,hash(hash(hash(somename,empty),empty),validkey(dhexp_real(key_e(alice,bob,sid_5),g))),validkey(dhexp_real(key_s(alice),g)))),validkey(dhexp_real(key_m(alice),g)))),msg_a(alice,bob,sid_5)).
Using the function 3-proj-aeadpack the attacker may obtain msg_a(alice,bob,sid_5).
attacker(msg_a(alice,bob,sid_5)).

21. By 20, the attacker may know msg_a(alice,bob,sid_5).
So the attacker may know msg_a(alice,bob,sid_5) in phase 1.
attacker_p1(msg_a(alice,bob,sid_5)).

22. By 21, attacker_p1(msg_a(alice,bob,sid_5)).
The goal is reached, represented in the following fact:
attacker_p1(msg_a(alice,bob,sid_5)).


RESULT attacker_p1(msg_a(alice,bob,sid_a)) ==> (event(LeakS(phase0,bob)) && event(LeakM(phase0,bob))) || (event(LeakS(px,bob)) && event(LeakM(px,bob)) && event(LeakS(pz,alice)) && event(LeakM(pz,alice))) cannot be proved.
Starting query attacker_p1(msg_a(alice,bob,sid_a)) ==> event(LeakS(phase0,bob)) && event(LeakM(phase0,bob))
goal reachable: begin(SendMsg(alice,bob,stagepack_a(sid_5),msg_a(alice,bob,sid_5))) -> attacker_p1(msg_a(alice,bob,sid_5))
Abbreviations:
sid_5 = sid[!1 = @sid]

Derivation:
Abbreviations:
sid_5 = sid[!1 = @sid]

1. Using the function pub the attacker may obtain pub.
attacker(pub).

2. The entry statestore(alice,bob,sid_5,statepack_a(handshakestatepack(symmetricstatepack(cipherstatepack(empty,minnonce),hash(somename,empty),hash(hash(somename,empty),empty)),keypairpack(empty,empty),keypairpack(empty,empty),keypairpack(empty,empty),empty,empty,empty,empty,true))) may be inserted in a table at insert {30}.
table(statestore(alice,bob,sid_5,statepack_a(handshakestatepack(symmetricstatepack(cipherstatepack(empty,minnonce),hash(somename,empty),hash(hash(somename,empty),empty)),keypairpack(empty,empty),keypairpack(empty,empty),keypairpack(empty,empty),empty,empty,empty,empty,true)))).

3. The entry statestore(alice,bob,sid_5,statepack_a(handshakestatepack(symmetricstatepack(cipherstatepack(empty,minnonce),hash(somename,empty),hash(hash(somename,empty),empty)),keypairpack(empty,empty),keypairpack(empty,empty),keypairpack(empty,empty),empty,empty,empty,empty,true))) that may be in a table by 2 may be read at get {182}.
The event SendMsg(alice,bob,stagepack_a(sid_5),msg_a(alice,bob,sid_5)) may be executed at {179}.
So the message concat4(validkey(dhexp_real(key_e(alice,bob,sid_5),g)),encrypt(empty,minnonce,hash(hash(hash(somename,empty),empty),validkey(dhexp_real(key_e(alice,bob,sid_5),g))),validkey(dhexp_real(key_s(alice),g))),encrypt(empty,increment_nonce(minnonce),hash(hash(hash(hash(somename,empty),empty),validkey(dhexp_real(key_e(alice,bob,sid_5),g))),encrypt(empty,minnonce,hash(hash(hash(somename,empty),empty),validkey(dhexp_real(key_e(alice,bob,sid_5),g))),validkey(dhexp_real(key_s(alice),g)))),validkey(dhexp_real(key_m(alice),g))),encrypt(empty,increment_nonce(increment_nonce(minnonce)),hash(hash(hash(hash(hash(somename,empty),empty),validkey(dhexp_real(key_e(alice,bob,sid_5),g))),encrypt(empty,minnonce,hash(hash(hash(somename,empty),empty),validkey(dhexp_real(key_e(alice,bob,sid_5),g))),validkey(dhexp_real(key_s(alice),g)))),encrypt(empty,increment_nonce(minnonce),hash(hash(hash(hash(somename,empty),empty),validkey(dhexp_real(key_e(alice,bob,sid_5),g))),encrypt(empty,minnonce,hash(hash(hash(somename,empty),empty),validkey(dhexp_real(key_e(alice,bob,sid_5),g))),validkey(dhexp_real(key_s(alice),g)))),validkey(dhexp_real(key_m(alice),g)))),msg_a(alice,bob,sid_5))) may be sent on channel pub at output {181}.
mess(pub,concat4(validkey(dhexp_real(key_e(alice,bob,sid_5),g)),encrypt(empty,minnonce,hash(hash(hash(somename,empty),empty),validkey(dhexp_real(key_e(alice,bob,sid_5),g))),validkey(dhexp_real(key_s(alice),g))),encrypt(empty,increment_nonce(minnonce),hash(hash(hash(hash(somename,empty),empty),validkey(dhexp_real(key_e(alice,bob,sid_5),g))),encrypt(empty,minnonce,hash(hash(hash(somename,empty),empty),validkey(dhexp_real(key_e(alice,bob,sid_5),g))),validkey(dhexp_real(key_s(alice),g)))),validkey(dhexp_real(key_m(alice),g))),encrypt(empty,increment_nonce(increment_nonce(minnonce)),hash(hash(hash(hash(hash(somename,empty),empty),validkey(dhexp_real(key_e(alice,bob,sid_5),g))),encrypt(empty,minnonce,hash(hash(hash(somename,empty),empty),validkey(dhexp_real(key_e(alice,bob,sid_5),g))),validkey(dhexp_real(key_s(alice),g)))),encrypt(empty,increment_nonce(minnonce),hash(hash(hash(hash(somename,empty),empty),validkey(dhexp_real(key_e(alice,bob,sid_5),g))),encrypt(empty,minnonce,hash(hash(hash(somename,empty),empty),validkey(dhexp_real(key_e(alice,bob,sid_5),g))),validkey(dhexp_real(key_s(alice),g)))),validkey(dhexp_real(key_m(alice),g)))),msg_a(alice,bob,sid_5)))).

4. By 1, the attacker may have the channel pub.
By 3, the message concat4(validkey(dhexp_real(key_e(alice,bob,sid_5),g)),encrypt(empty,minnonce,hash(hash(hash(somename,empty),empty),validkey(dhexp_real(key_e(alice,bob,sid_5),g))),validkey(dhexp_real(key_s(alice),g))),encrypt(empty,increment_nonce(minnonce),hash(hash(hash(hash(somename,empty),empty),validkey(dhexp_real(key_e(alice,bob,sid_5),g))),encrypt(empty,minnonce,hash(hash(hash(somename,empty),empty),validkey(dhexp_real(key_e(alice,bob,sid_5),g))),validkey(dhexp_real(key_s(alice),g)))),validkey(dhexp_real(key_m(alice),g))),encrypt(empty,increment_nonce(increment_nonce(minnonce)),hash(hash(hash(hash(hash(somename,empty),empty),validkey(dhexp_real(key_e(alice,bob,sid_5),g))),encrypt(empty,minnonce,hash(hash(hash(somename,empty),empty),validkey(dhexp_real(key_e(alice,bob,sid_5),g))),validkey(dhexp_real(key_s(alice),g)))),encrypt(empty,increment_nonce(minnonce),hash(hash(hash(hash(somename,empty),empty),validkey(dhexp_real(key_e(alice,bob,sid_5),g))),encrypt(empty,minnonce,hash(hash(hash(somename,empty),empty),validkey(dhexp_real(key_e(alice,bob,sid_5),g))),validkey(dhexp_real(key_s(alice),g)))),validkey(dhexp_real(key_m(alice),g)))),msg_a(alice,bob,sid_5))) may be sent on this channel.
So the attacker may obtain the message concat4(validkey(dhexp_real(key_e(alice,bob,sid_5),g)),encrypt(empty,minnonce,hash(hash(hash(somename,empty),empty),validkey(dhexp_real(key_e(alice,bob,sid_5),g))),validkey(dhexp_real(key_s(alice),g))),encrypt(empty,increment_nonce(minnonce),hash(hash(hash(hash(somename,empty),empty),validkey(dhexp_real(key_e(alice,bob,sid_5),g))),encrypt(empty,minnonce,hash(hash(hash(somename,empty),empty),validkey(dhexp_real(key_e(alice,bob,sid_5),g))),validkey(dhexp_real(key_s(alice),g)))),validkey(dhexp_real(key_m(alice),g))),encrypt(empty,increment_nonce(increment_nonce(minnonce)),hash(hash(hash(hash(hash(somename,empty),empty),validkey(dhexp_real(key_e(alice,bob,sid_5),g))),encrypt(empty,minnonce,hash(hash(hash(somename,empty),empty),validkey(dhexp_real(key_e(alice,bob,sid_5),g))),validkey(dhexp_real(key_s(alice),g)))),encrypt(empty,increment_nonce(minnonce),hash(hash(hash(hash(somename,empty),empty),validkey(dhexp_real(key_e(alice,bob,sid_5),g))),encrypt(empty,minnonce,hash(hash(hash(somename,empty),empty),validkey(dhexp_real(key_e(alice,bob,sid_5),g))),validkey(dhexp_real(key_s(alice),g)))),validkey(dhexp_real(key_m(alice),g)))),msg_a(alice,bob,sid_5))) by listening on this channel.
attacker(concat4(validkey(dhexp_real(key_e(alice,bob,sid_5),g)),encrypt(empty,minnonce,hash(hash(hash(somename,empty),empty),validkey(dhexp_real(key_e(alice,bob,sid_5),g))),validkey(dhexp_real(key_s(alice),g))),encrypt(empty,increment_nonce(minnonce),hash(hash(hash(hash(somename,empty),empty),validkey(dhexp_real(key_e(alice,bob,sid_5),g))),encrypt(empty,minnonce,hash(hash(hash(somename,empty),empty),validkey(dhexp_real(key_e(alice,bob,sid_5),g))),validkey(dhexp_real(key_s(alice),g)))),validkey(dhexp_real(key_m(alice),g))),encrypt(empty,increment_nonce(increment_nonce(minnonce)),hash(hash(hash(hash(hash(somename,empty),empty),validkey(dhexp_real(key_e(alice,bob,sid_5),g))),encrypt(empty,minnonce,hash(hash(hash(somename,empty),empty),validkey(dhexp_real(key_e(alice,bob,sid_5),g))),validkey(dhexp_real(key_s(alice),g)))),encrypt(empty,increment_nonce(minnonce),hash(hash(hash(hash(somename,empty),empty),validkey(dhexp_real(key_e(alice,bob,sid_5),g))),encrypt(empty,minnonce,hash(hash(hash(somename,empty),empty),validkey(dhexp_real(key_e(alice,bob,sid_5),g))),validkey(dhexp_real(key_s(alice),g)))),validkey(dhexp_real(key_m(alice),g)))),msg_a(alice,bob,sid_5)))).

5. By 4, the attacker may know concat4(validkey(dhexp_real(key_e(alice,bob,sid_5),g)),encrypt(empty,minnonce,hash(hash(hash(somename,empty),empty),validkey(dhexp_real(key_e(alice,bob,sid_5),g))),validkey(dhexp_real(key_s(alice),g))),encrypt(empty,increment_nonce(minnonce),hash(hash(hash(hash(somename,empty),empty),validkey(dhexp_real(key_e(alice,bob,sid_5),g))),encrypt(empty,minnonce,hash(hash(hash(somename,empty),empty),validkey(dhexp_real(key_e(alice,bob,sid_5),g))),validkey(dhexp_real(key_s(alice),g)))),validkey(dhexp_real(key_m(alice),g))),encrypt(empty,increment_nonce(increment_nonce(minnonce)),hash(hash(hash(hash(hash(somename,empty),empty),validkey(dhexp_real(key_e(alice,bob,sid_5),g))),encrypt(empty,minnonce,hash(hash(hash(somename,empty),empty),validkey(dhexp_real(key_e(alice,bob,sid_5),g))),validkey(dhexp_real(key_s(alice),g)))),encrypt(empty,increment_nonce(minnonce),hash(hash(hash(hash(somename,empty),empty),validkey(dhexp_real(key_e(alice,bob,sid_5),g))),encrypt(empty,minnonce,hash(hash(hash(somename,empty),empty),validkey(dhexp_real(key_e(alice,bob,sid_5),g))),validkey(dhexp_real(key_s(alice),g)))),validkey(dhexp_real(key_m(alice),g)))),msg_a(alice,bob,sid_5))).
Using the function 4-proj-concat4 the attacker may obtain encrypt(empty,increment_nonce(increment_nonce(minnonce)),hash(hash(hash(hash(hash(somename,empty),empty),validkey(dhexp_real(key_e(alice,bob,sid_5),g))),encrypt(empty,minnonce,hash(hash(hash(somename,empty),empty),validkey(dhexp_real(key_e(alice,bob,sid_5),g))),validkey(dhexp_real(key_s(alice),g)))),encrypt(empty,increment_nonce(minnonce),hash(hash(hash(hash(somename,empty),empty),validkey(dhexp_real(key_e(alice,bob,sid_5),g))),encrypt(empty,minnonce,hash(hash(hash(somename,empty),empty),validkey(dhexp_real(key_e(alice,bob,sid_5),g))),validkey(dhexp_real(key_s(alice),g)))),validkey(dhexp_real(key_m(alice),g)))),msg_a(alice,bob,sid_5)).
attacker(encrypt(empty,increment_nonce(increment_nonce(minnonce)),hash(hash(hash(hash(hash(somename,empty),empty),validkey(dhexp_real(key_e(alice,bob,sid_5),g))),encrypt(empty,minnonce,hash(hash(hash(somename,empty),empty),validkey(dhexp_real(key_e(alice,bob,sid_5),g))),validkey(dhexp_real(key_s(alice),g)))),encrypt(empty,increment_nonce(minnonce),hash(hash(hash(hash(somename,empty),empty),validkey(dhexp_real(key_e(alice,bob,sid_5),g))),encrypt(empty,minnonce,hash(hash(hash(somename,empty),empty),validkey(dhexp_real(key_e(alice,bob,sid_5),g))),validkey(dhexp_real(key_s(alice),g)))),validkey(dhexp_real(key_m(alice),g)))),msg_a(alice,bob,sid_5))).

6. By 4, the attacker may know concat4(validkey(dhexp_real(key_e(alice,bob,sid_5),g)),encrypt(empty,minnonce,hash(hash(hash(somename,empty),empty),validkey(dhexp_real(key_e(alice,bob,sid_5),g))),validkey(dhexp_real(key_s(alice),g))),encrypt(empty,increment_nonce(minnonce),hash(hash(hash(hash(somename,empty),empty),validkey(dhexp_real(key_e(alice,bob,sid_5),g))),encrypt(empty,minnonce,hash(hash(hash(somename,empty),empty),validkey(dhexp_real(key_e(alice,bob,sid_5),g))),validkey(dhexp_real(key_s(alice),g)))),validkey(dhexp_real(key_m(alice),g))),encrypt(empty,increment_nonce(increment_nonce(minnonce)),hash(hash(hash(hash(hash(somename,empty),empty),validkey(dhexp_real(key_e(alice,bob,sid_5),g))),encrypt(empty,minnonce,hash(hash(hash(somename,empty),empty),validkey(dhexp_real(key_e(alice,bob,sid_5),g))),validkey(dhexp_real(key_s(alice),g)))),encrypt(empty,increment_nonce(minnonce),hash(hash(hash(hash(somename,empty),empty),validkey(dhexp_real(key_e(alice,bob,sid_5),g))),encrypt(empty,minnonce,hash(hash(hash(somename,empty),empty),validkey(dhexp_real(key_e(alice,bob,sid_5),g))),validkey(dhexp_real(key_s(alice),g)))),validkey(dhexp_real(key_m(alice),g)))),msg_a(alice,bob,sid_5))).
Using the function 3-proj-concat4 the attacker may obtain encrypt(empty,increment_nonce(minnonce),hash(hash(hash(hash(somename,empty),empty),validkey(dhexp_real(key_e(alice,bob,sid_5),g))),encrypt(empty,minnonce,hash(hash(hash(somename,empty),empty),validkey(dhexp_real(key_e(alice,bob,sid_5),g))),validkey(dhexp_real(key_s(alice),g)))),validkey(dhexp_real(key_m(alice),g))).
attacker(encrypt(empty,increment_nonce(minnonce),hash(hash(hash(hash(somename,empty),empty),validkey(dhexp_real(key_e(alice,bob,sid_5),g))),encrypt(empty,minnonce,hash(hash(hash(somename,empty),empty),validkey(dhexp_real(key_e(alice,bob,sid_5),g))),validkey(dhexp_real(key_s(alice),g)))),validkey(dhexp_real(key_m(alice),g)))).

7. By 4, the attacker may know concat4(validkey(dhexp_real(key_e(alice,bob,sid_5),g)),encrypt(empty,minnonce,hash(hash(hash(somename,empty),empty),validkey(dhexp_real(key_e(alice,bob,sid_5),g))),validkey(dhexp_real(key_s(alice),g))),encrypt(empty,increment_nonce(minnonce),hash(hash(hash(hash(somename,empty),empty),validkey(dhexp_real(key_e(alice,bob,sid_5),g))),encrypt(empty,minnonce,hash(hash(hash(somename,empty),empty),validkey(dhexp_real(key_e(alice,bob,sid_5),g))),validkey(dhexp_real(key_s(alice),g)))),validkey(dhexp_real(key_m(alice),g))),encrypt(empty,increment_nonce(increment_nonce(minnonce)),hash(hash(hash(hash(hash(somename,empty),empty),validkey(dhexp_real(key_e(alice,bob,sid_5),g))),encrypt(empty,minnonce,hash(hash(hash(somename,empty),empty),validkey(dhexp_real(key_e(alice,bob,sid_5),g))),validkey(dhexp_real(key_s(alice),g)))),encrypt(empty,increment_nonce(minnonce),hash(hash(hash(hash(somename,empty),empty),validkey(dhexp_real(key_e(alice,bob,sid_5),g))),encrypt(empty,minnonce,hash(hash(hash(somename,empty),empty),validkey(dhexp_real(key_e(alice,bob,sid_5),g))),validkey(dhexp_real(key_s(alice),g)))),validkey(dhexp_real(key_m(alice),g)))),msg_a(alice,bob,sid_5))).
Using the function 2-proj-concat4 the attacker may obtain encrypt(empty,minnonce,hash(hash(hash(somename,empty),empty),validkey(dhexp_real(key_e(alice,bob,sid_5),g))),validkey(dhexp_real(key_s(alice),g))).
attacker(encrypt(empty,minnonce,hash(hash(hash(somename,empty),empty),validkey(dhexp_real(key_e(alice,bob,sid_5),g))),validkey(dhexp_real(key_s(alice),g)))).

8. By 4, the attacker may know concat4(validkey(dhexp_real(key_e(alice,bob,sid_5),g)),encrypt(empty,minnonce,hash(hash(hash(somename,empty),empty),validkey(dhexp_real(key_e(alice,bob,sid_5),g))),validkey(dhexp_real(key_s(alice),g))),encrypt(empty,increment_nonce(minnonce),hash(hash(hash(hash(somename,empty),empty),validkey(dhexp_real(key_e(alice,bob,sid_5),g))),encrypt(empty,minnonce,hash(hash(hash(somename,empty),empty),validkey(dhexp_real(key_e(alice,bob,sid_5),g))),validkey(dhexp_real(key_s(alice),g)))),validkey(dhexp_real(key_m(alice),g))),encrypt(empty,increment_nonce(increment_nonce(minnonce)),hash(hash(hash(hash(hash(somename,empty),empty),validkey(dhexp_real(key_e(alice,bob,sid_5),g))),encrypt(empty,minnonce,hash(hash(hash(somename,empty),empty),validkey(dhexp_real(key_e(alice,bob,sid_5),g))),validkey(dhexp_real(key_s(alice),g)))),encrypt(empty,increment_nonce(minnonce),hash(hash(hash(hash(somename,empty),empty),validkey(dhexp_real(key_e(alice,bob,sid_5),g))),encrypt(empty,minnonce,hash(hash(hash(somename,empty),empty),validkey(dhexp_real(key_e(alice,bob,sid_5),g))),validkey(dhexp_real(key_s(alice),g)))),validkey(dhexp_real(key_m(alice),g)))),msg_a(alice,bob,sid_5))).
Using the function 1-proj-concat4 the attacker may obtain validkey(dhexp_real(key_e(alice,bob,sid_5),g)).
attacker(validkey(dhexp_real(key_e(alice,bob,sid_5),g))).

9. Using the function empty the attacker may obtain empty.
attacker(empty).

10. Using the function somename the attacker may obtain somename.
attacker(somename).

11. By 10, the attacker may know somename.
By 9, the attacker may know empty.
Using the function hash the attacker may obtain hash(somename,empty).
attacker(hash(somename,empty)).

12. By 11, the attacker may know hash(somename,empty).
By 9, the attacker may know empty.
Using the function hash the attacker may obtain hash(hash(somename,empty),empty).
attacker(hash(hash(somename,empty),empty)).

13. By 12, the attacker may know hash(hash(somename,empty),empty).
By 8, the attacker may know validkey(dhexp_real(key_e(alice,bob,sid_5),g)).
Using the function hash the attacker may obtain hash(hash(hash(somename,empty),empty),validkey(dhexp_real(key_e(alice,bob,sid_5),g))).
attacker(hash(hash(hash(somename,empty),empty),validkey(dhexp_real(key_e(alice,bob,sid_5),g)))).

14. By 13, the attacker may know hash(hash(hash(somename,empty),empty),validkey(dhexp_real(key_e(alice,bob,sid_5),g))).
By 7, the attacker may know encrypt(empty,minnonce,hash(hash(hash(somename,empty),empty),validkey(dhexp_real(key_e(alice,bob,sid_5),g))),validkey(dhexp_real(key_s(alice),g))).
Using the function hash the attacker may obtain hash(hash(hash(hash(somename,empty),empty),validkey(dhexp_real(key_e(alice,bob,sid_5),g))),encrypt(empty,minnonce,hash(hash(hash(somename,empty),empty),validkey(dhexp_real(key_e(alice,bob,sid_5),g))),validkey(dhexp_real(key_s(alice),g)))).
attacker(hash(hash(hash(hash(somename,empty),empty),validkey(dhexp_real(key_e(alice,bob,sid_5),g))),encrypt(empty,minnonce,hash(hash(hash(somename,empty),empty),validkey(dhexp_real(key_e(alice,bob,sid_5),g))),validkey(dhexp_real(key_s(alice),g))))).

15. By 14, the attacker may know hash(hash(hash(hash(somename,empty),empty),validkey(dhexp_real(key_e(alice,bob,sid_5),g))),encrypt(empty,minnonce,hash(hash(hash(somename,empty),empty),validkey(dhexp_real(key_e(alice,bob,sid_5),g))),validkey(dhexp_real(key_s(alice),g)))).
By 6, the attacker may know encrypt(empty,increment_nonce(minnonce),hash(hash(hash(hash(somename,empty),empty),validkey(dhexp_real(key_e(alice,bob,sid_5),g))),encrypt(empty,minnonce,hash(hash(hash(somename,empty),empty),validkey(dhexp_real(key_e(alice,bob,sid_5),g))),validkey(dhexp_real(key_s(alice),g)))),validkey(dhexp_real(key_m(alice),g))).
Using the function hash the attacker may obtain hash(hash(hash(hash(hash(somename,empty),empty),validkey(dhexp_real(key_e(alice,bob,sid_5),g))),encrypt(empty,minnonce,hash(hash(hash(somename,empty),empty),validkey(dhexp_real(key_e(alice,bob,sid_5),g))),validkey(dhexp_real(key_s(alice),g)))),encrypt(empty,increment_nonce(minnonce),hash(hash(hash(hash(somename,empty),empty),validkey(dhexp_real(key_e(alice,bob,sid_5),g))),encrypt(empty,minnonce,hash(hash(hash(somename,empty),empty),validkey(dhexp_real(key_e(alice,bob,sid_5),g))),validkey(dhexp_real(key_s(alice),g)))),validkey(dhexp_real(key_m(alice),g)))).
attacker(hash(hash(hash(hash(hash(somename,empty),empty),validkey(dhexp_real(key_e(alice,bob,sid_5),g))),encrypt(empty,minnonce,hash(hash(hash(somename,empty),empty),validkey(dhexp_real(key_e(alice,bob,sid_5),g))),validkey(dhexp_real(key_s(alice),g)))),encrypt(empty,increment_nonce(minnonce),hash(hash(hash(hash(somename,empty),empty),validkey(dhexp_real(key_e(alice,bob,sid_5),g))),encrypt(empty,minnonce,hash(hash(hash(somename,empty),empty),validkey(dhexp_real(key_e(alice,bob,sid_5),g))),validkey(dhexp_real(key_s(alice),g)))),validkey(dhexp_real(key_m(alice),g))))).

16. Using the function minnonce the attacker may obtain minnonce.
attacker(minnonce).

17. By 16, the attacker may know minnonce.
Using the function increment_nonce the attacker may obtain increment_nonce(minnonce).
attacker(increment_nonce(minnonce)).

18. By 17, the attacker may know increment_nonce(minnonce).
Using the function increment_nonce the attacker may obtain increment_nonce(increment_nonce(minnonce)).
attacker(increment_nonce(increment_nonce(minnonce))).

19. By 9, the attacker may know empty.
By 18, the attacker may know increment_nonce(increment_nonce(minnonce)).
By 15, the attacker may know hash(hash(hash(hash(hash(somename,empty),empty),validkey(dhexp_real(key_e(alice,bob,sid_5),g))),encrypt(empty,minnonce,hash(hash(hash(somename,empty),empty),validkey(dhexp_real(key_e(alice,bob,sid_5),g))),validkey(dhexp_real(key_s(alice),g)))),encrypt(empty,increment_nonce(minnonce),hash(hash(hash(hash(somename,empty),empty),validkey(dhexp_real(key_e(alice,bob,sid_5),g))),encrypt(empty,minnonce,hash(hash(hash(somename,empty),empty),validkey(dhexp_real(key_e(alice,bob,sid_5),g))),validkey(dhexp_real(key_s(alice),g)))),validkey(dhexp_real(key_m(alice),g)))).
By 5, the attacker may know encrypt(empty,increment_nonce(increment_nonce(minnonce)),hash(hash(hash(hash(hash(somename,empty),empty),validkey(dhexp_real(key_e(alice,bob,sid_5),g))),encrypt(empty,minnonce,hash(hash(hash(somename,empty),empty),validkey(dhexp_real(key_e(alice,bob,sid_5),g))),validkey(dhexp_real(key_s(alice),g)))),encrypt(empty,increment_nonce(minnonce),hash(hash(hash(hash(somename,empty),empty),validkey(dhexp_real(key_e(alice,bob,sid_5),g))),encrypt(empty,minnonce,hash(hash(hash(somename,empty),empty),validkey(dhexp_real(key_e(alice,bob,sid_5),g))),validkey(dhexp_real(key_s(alice),g)))),validkey(dhexp_real(key_m(alice),g)))),msg_a(alice,bob,sid_5)).
Using the function decrypt the attacker may obtain aeadpack(true,hash(hash(hash(hash(hash(somename,empty),empty),validkey(dhexp_real(key_e(alice,bob,sid_5),g))),encrypt(empty,minnonce,hash(hash(hash(somename,empty),empty),validkey(dhexp_real(key_e(alice,bob,sid_5),g))),validkey(dhexp_real(key_s(alice),g)))),encrypt(empty,increment_nonce(minnonce),hash(hash(hash(hash(somename,empty),empty),validkey(dhexp_real(key_e(alice,bob,sid_5),g))),encrypt(empty,minnonce,hash(hash(hash(somename,empty),empty),validkey(dhexp_real(key_e(alice,bob,sid_5),g))),validkey(dhexp_real(key_s(alice),g)))),validkey(dhexp_real(key_m(alice),g)))),msg_a(alice,bob,sid_5)).
attacker(aeadpack(true,hash(hash(hash(hash(hash(somename,empty),empty),validkey(dhexp_real(key_e(alice,bob,sid_5),g))),encrypt(empty,minnonce,hash(hash(hash(somename,empty),empty),validkey(dhexp_real(key_e(alice,bob,sid_5),g))),validkey(dhexp_real(key_s(alice),g)))),encrypt(empty,increment_nonce(minnonce),hash(hash(hash(hash(somename,empty),empty),validkey(dhexp_real(key_e(alice,bob,sid_5),g))),encrypt(empty,minnonce,hash(hash(hash(somename,empty),empty),validkey(dhexp_real(key_e(alice,bob,sid_5),g))),validkey(dhexp_real(key_s(alice),g)))),validkey(dhexp_real(key_m(alice),g)))),msg_a(alice,bob,sid_5))).

20. By 19, the attacker may know aeadpack(true,hash(hash(hash(hash(hash(somename,empty),empty),validkey(dhexp_real(key_e(alice,bob,sid_5),g))),encrypt(empty,minnonce,hash(hash(hash(somename,empty),empty),validkey(dhexp_real(key_e(alice,bob,sid_5),g))),validkey(dhexp_real(key_s(alice),g)))),encrypt(empty,increment_nonce(minnonce),hash(hash(hash(hash(somename,empty),empty),validkey(dhexp_real(key_e(alice,bob,sid_5),g))),encrypt(empty,minnonce,hash(hash(hash(somename,empty),empty),validkey(dhexp_real(key_e(alice,bob,sid_5),g))),validkey(dhexp_real(key_s(alice),g)))),validkey(dhexp_real(key_m(alice),g)))),msg_a(alice,bob,sid_5)).
Using the function 3-proj-aeadpack the attacker may obtain msg_a(alice,bob,sid_5).
attacker(msg_a(alice,bob,sid_5)).

21. By 20, the attacker may know msg_a(alice,bob,sid_5).
So the attacker may know msg_a(alice,bob,sid_5) in phase 1.
attacker_p1(msg_a(alice,bob,sid_5)).

22. By 21, attacker_p1(msg_a(alice,bob,sid_5)).
The goal is reached, represented in the following fact:
attacker_p1(msg_a(alice,bob,sid_5)).


RESULT attacker_p1(msg_a(alice,bob,sid_a)) ==> event(LeakS(phase0,bob)) && event(LeakM(phase0,bob)) cannot be proved.
Starting query event(RecvMsg(alice,bob,stagepack_b(sid_a),m_24)) ==> event(SendMsg(bob,alice,stagepack_b(sid_b),m_24))
RESULT event(RecvMsg(alice,bob,stagepack_b(sid_a),m_24)) ==> event(SendMsg(bob,alice,stagepack_b(sid_b),m_24)) is true.
Starting query event(RecvMsg(alice,bob,stagepack_b(sid_a),m_24)) ==> event(SendMsg(bob,c,stagepack_b(sid_b),m_24)) || (event(LeakS(phase0,bob)) && event(LeakM(phase0,bob))) || (event(LeakS(phase0,alice)) && event(LeakM(phase0,alice)))
RESULT event(RecvMsg(alice,bob,stagepack_b(sid_a),m_24)) ==> event(SendMsg(bob,c,stagepack_b(sid_b),m_24)) || (event(LeakS(phase0,bob)) && event(LeakM(phase0,bob))) || (event(LeakS(phase0,alice)) && event(LeakM(phase0,alice))) is true.
Starting query event(RecvMsg(alice,bob,stagepack_b(sid_a),m_24)) ==> event(SendMsg(bob,c,stagepack_b(sid_b),m_24)) || (event(LeakS(phase0,bob)) && event(LeakM(phase0,bob)))
RESULT event(RecvMsg(alice,bob,stagepack_b(sid_a),m_24)) ==> event(SendMsg(bob,c,stagepack_b(sid_b),m_24)) || (event(LeakS(phase0,bob)) && event(LeakM(phase0,bob))) is true.
Starting query event(RecvMsg(alice,bob,stagepack_b(sid_a),m_24)) ==> event(SendMsg(bob,alice,stagepack_b(sid_b),m_24)) || (event(LeakS(phase0,bob)) && event(LeakM(phase0,bob))) || (event(LeakS(phase0,alice)) && event(LeakM(phase0,alice)))
RESULT event(RecvMsg(alice,bob,stagepack_b(sid_a),m_24)) ==> event(SendMsg(bob,alice,stagepack_b(sid_b),m_24)) || (event(LeakS(phase0,bob)) && event(LeakM(phase0,bob))) || (event(LeakS(phase0,alice)) && event(LeakM(phase0,alice))) is true.
Starting query event(RecvMsg(alice,bob,stagepack_b(sid_a),m_24)) ==> event(SendMsg(bob,alice,stagepack_b(sid_b),m_24)) || (event(LeakS(phase0,bob)) && event(LeakM(phase0,bob)))
RESULT event(RecvMsg(alice,bob,stagepack_b(sid_a),m_24)) ==> event(SendMsg(bob,alice,stagepack_b(sid_b),m_24)) || (event(LeakS(phase0,bob)) && event(LeakM(phase0,bob))) is true.
Starting query not attacker_p1(msg_b(bob,alice,sid_b))
RESULT not attacker_p1(msg_b(bob,alice,sid_b)) is true.
Starting query attacker_p1(msg_b(bob,alice,sid_b)) ==> event(LeakS(px,alice)) && event(LeakM(px,alice))
RESULT attacker_p1(msg_b(bob,alice,sid_b)) ==> event(LeakS(px,alice)) && event(LeakM(px,alice)) is true.
Starting query attacker_p1(msg_b(bob,alice,sid_b)) ==> (event(LeakS(phase0,alice)) && event(LeakM(phase0,alice))) || (event(LeakS(px,alice)) && event(LeakM(px,alice)) && event(LeakS(pz,bob)) && event(LeakM(pz,bob)))
RESULT attacker_p1(msg_b(bob,alice,sid_b)) ==> (event(LeakS(phase0,alice)) && event(LeakM(phase0,alice))) || (event(LeakS(px,alice)) && event(LeakM(px,alice)) && event(LeakS(pz,bob)) && event(LeakM(pz,bob))) is true.
Starting query attacker_p1(msg_b(bob,alice,sid_b)) ==> event(LeakS(phase0,alice)) && event(LeakM(phase0,alice))
RESULT attacker_p1(msg_b(bob,alice,sid_b)) ==> event(LeakS(phase0,alice)) && event(LeakM(phase0,alice)) is true.
Starting query event(RecvMsg(bob,alice,stagepack_c(sid_b),m_24)) ==> event(SendMsg(alice,bob,stagepack_c(sid_a),m_24))
RESULT event(RecvMsg(bob,alice,stagepack_c(sid_b),m_24)) ==> event(SendMsg(alice,bob,stagepack_c(sid_a),m_24)) is true.
Starting query event(RecvMsg(bob,alice,stagepack_c(sid_b),m_24)) ==> event(SendMsg(alice,c,stagepack_c(sid_a),m_24)) || (event(LeakS(phase0,alice)) && event(LeakM(phase0,alice))) || (event(LeakS(phase0,bob)) && event(LeakM(phase0,bob)))
RESULT event(RecvMsg(bob,alice,stagepack_c(sid_b),m_24)) ==> event(SendMsg(alice,c,stagepack_c(sid_a),m_24)) || (event(LeakS(phase0,alice)) && event(LeakM(phase0,alice))) || (event(LeakS(phase0,bob)) && event(LeakM(phase0,bob))) is true.
Starting query event(RecvMsg(bob,alice,stagepack_c(sid_b),m_24)) ==> event(SendMsg(alice,c,stagepack_c(sid_a),m_24)) || (event(LeakS(phase0,alice)) && event(LeakM(phase0,alice)))
RESULT event(RecvMsg(bob,alice,stagepack_c(sid_b),m_24)) ==> event(SendMsg(alice,c,stagepack_c(sid_a),m_24)) || (event(LeakS(phase0,alice)) && event(LeakM(phase0,alice))) is true.
Starting query event(RecvMsg(bob,alice,stagepack_c(sid_b),m_24)) ==> event(SendMsg(alice,bob,stagepack_c(sid_a),m_24)) || (event(LeakS(phase0,alice)) && event(LeakM(phase0,alice))) || (event(LeakS(phase0,bob)) && event(LeakM(phase0,bob)))
RESULT event(RecvMsg(bob,alice,stagepack_c(sid_b),m_24)) ==> event(SendMsg(alice,bob,stagepack_c(sid_a),m_24)) || (event(LeakS(phase0,alice)) && event(LeakM(phase0,alice))) || (event(LeakS(phase0,bob)) && event(LeakM(phase0,bob))) is true.
Starting query event(RecvMsg(bob,alice,stagepack_c(sid_b),m_24)) ==> event(SendMsg(alice,bob,stagepack_c(sid_a),m_24)) || (event(LeakS(phase0,alice)) && event(LeakM(phase0,alice)))
RESULT event(RecvMsg(bob,alice,stagepack_c(sid_b),m_24)) ==> event(SendMsg(alice,bob,stagepack_c(sid_a),m_24)) || (event(LeakS(phase0,alice)) && event(LeakM(phase0,alice))) is true.
Starting query not attacker_p1(msg_c(alice,bob,sid_a))
RESULT not attacker_p1(msg_c(alice,bob,sid_a)) is true.
Starting query attacker_p1(msg_c(alice,bob,sid_a)) ==> event(LeakS(px,bob)) && event(LeakM(px,bob))
RESULT attacker_p1(msg_c(alice,bob,sid_a)) ==> event(LeakS(px,bob)) && event(LeakM(px,bob)) is true.
Starting query attacker_p1(msg_c(alice,bob,sid_a)) ==> (event(LeakS(phase0,bob)) && event(LeakM(phase0,bob))) || (event(LeakS(px,bob)) && event(LeakM(px,bob)) && event(LeakS(pz,alice)) && event(LeakM(pz,alice)))
RESULT attacker_p1(msg_c(alice,bob,sid_a)) ==> (event(LeakS(phase0,bob)) && event(LeakM(phase0,bob))) || (event(LeakS(px,bob)) && event(LeakM(px,bob)) && event(LeakS(pz,alice)) && event(LeakM(pz,alice))) is true.
Starting query attacker_p1(msg_c(alice,bob,sid_a)) ==> event(LeakS(phase0,bob)) && event(LeakM(phase0,bob))
RESULT attacker_p1(msg_c(alice,bob,sid_a)) ==> event(LeakS(phase0,bob)) && event(LeakM(phase0,bob)) is true.
Starting query event(RecvMsg(alice,bob,stagepack_d(sid_a),m_24)) ==> event(SendMsg(bob,alice,stagepack_d(sid_b),m_24))
RESULT event(RecvMsg(alice,bob,stagepack_d(sid_a),m_24)) ==> event(SendMsg(bob,alice,stagepack_d(sid_b),m_24)) is true.
Starting query event(RecvMsg(alice,bob,stagepack_d(sid_a),m_24)) ==> event(SendMsg(bob,c,stagepack_d(sid_b),m_24)) || (event(LeakS(phase0,bob)) && event(LeakM(phase0,bob))) || (event(LeakS(phase0,alice)) && event(LeakM(phase0,alice)))
RESULT event(RecvMsg(alice,bob,stagepack_d(sid_a),m_24)) ==> event(SendMsg(bob,c,stagepack_d(sid_b),m_24)) || (event(LeakS(phase0,bob)) && event(LeakM(phase0,bob))) || (event(LeakS(phase0,alice)) && event(LeakM(phase0,alice))) is true.
Starting query event(RecvMsg(alice,bob,stagepack_d(sid_a),m_24)) ==> event(SendMsg(bob,c,stagepack_d(sid_b),m_24)) || (event(LeakS(phase0,bob)) && event(LeakM(phase0,bob)))
RESULT event(RecvMsg(alice,bob,stagepack_d(sid_a),m_24)) ==> event(SendMsg(bob,c,stagepack_d(sid_b),m_24)) || (event(LeakS(phase0,bob)) && event(LeakM(phase0,bob))) is true.
Starting query event(RecvMsg(alice,bob,stagepack_d(sid_a),m_24)) ==> event(SendMsg(bob,alice,stagepack_d(sid_b),m_24)) || (event(LeakS(phase0,bob)) && event(LeakM(phase0,bob))) || (event(LeakS(phase0,alice)) && event(LeakM(phase0,alice)))
RESULT event(RecvMsg(alice,bob,stagepack_d(sid_a),m_24)) ==> event(SendMsg(bob,alice,stagepack_d(sid_b),m_24)) || (event(LeakS(phase0,bob)) && event(LeakM(phase0,bob))) || (event(LeakS(phase0,alice)) && event(LeakM(phase0,alice))) is true.
Starting query event(RecvMsg(alice,bob,stagepack_d(sid_a),m_24)) ==> event(SendMsg(bob,alice,stagepack_d(sid_b),m_24)) || (event(LeakS(phase0,bob)) && event(LeakM(phase0,bob)))
RESULT event(RecvMsg(alice,bob,stagepack_d(sid_a),m_24)) ==> event(SendMsg(bob,alice,stagepack_d(sid_b),m_24)) || (event(LeakS(phase0,bob)) && event(LeakM(phase0,bob))) is true.
Starting query not attacker_p1(msg_d(bob,alice,sid_b))
RESULT not attacker_p1(msg_d(bob,alice,sid_b)) is true.
Starting query attacker_p1(msg_d(bob,alice,sid_b)) ==> event(LeakS(px,alice)) && event(LeakM(px,alice))
RESULT attacker_p1(msg_d(bob,alice,sid_b)) ==> event(LeakS(px,alice)) && event(LeakM(px,alice)) is true.
Starting query attacker_p1(msg_d(bob,alice,sid_b)) ==> (event(LeakS(phase0,alice)) && event(LeakM(phase0,alice))) || (event(LeakS(px,alice)) && event(LeakM(px,alice)) && event(LeakS(pz,bob)) && event(LeakM(pz,bob)))
RESULT attacker_p1(msg_d(bob,alice,sid_b)) ==> (event(LeakS(phase0,alice)) && event(LeakM(phase0,alice))) || (event(LeakS(px,alice)) && event(LeakM(px,alice)) && event(LeakS(pz,bob)) && event(LeakM(pz,bob))) is true.
Starting query attacker_p1(msg_d(bob,alice,sid_b)) ==> event(LeakS(phase0,alice)) && event(LeakM(phase0,alice))
RESULT attacker_p1(msg_d(bob,alice,sid_b)) ==> event(LeakS(phase0,alice)) && event(LeakM(phase0,alice)) is true.
Starting query not event(RecvEnd(true))
RESULT not event(RecvEnd(true)) is true.

--------------------------------------------------------------
Verification summary:

Query event(RecvMsg(bob,alice,stagepack_a(sid_b),m_24)) ==> event(SendMsg(alice,bob,stagepack_a(sid_a),m_24)) cannot be proved.

Query event(RecvMsg(bob,alice,stagepack_a(sid_b),m_24)) ==> event(SendMsg(alice,c,stagepack_a(sid_a),m_24)) || (event(LeakS(phase0,alice)) && event(LeakM(phase0,alice))) || (event(LeakS(phase0,bob)) && event(LeakM(phase0,bob))) is true.

Query event(RecvMsg(bob,alice,stagepack_a(sid_b),m_24)) ==> event(SendMsg(alice,c,stagepack_a(sid_a),m_24)) || (event(LeakS(phase0,alice)) && event(LeakM(phase0,alice))) is true.

Query event(RecvMsg(bob,alice,stagepack_a(sid_b),m_24)) ==> event(SendMsg(alice,bob,stagepack_a(sid_a),m_24)) || (event(LeakS(phase0,alice)) && event(LeakM(phase0,alice))) || (event(LeakS(phase0,bob)) && event(LeakM(phase0,bob))) cannot be proved.

Query event(RecvMsg(bob,alice,stagepack_a(sid_b),m_24)) ==> event(SendMsg(alice,bob,stagepack_a(sid_a),m_24)) || (event(LeakS(phase0,alice)) && event(LeakM(phase0,alice))) cannot be proved.

Query not attacker_p1(msg_a(alice,bob,sid_a)) cannot be proved.

Query attacker_p1(msg_a(alice,bob,sid_a)) ==> event(LeakS(px,bob)) && event(LeakM(px,bob)) cannot be proved.

Query attacker_p1(msg_a(alice,bob,sid_a)) ==> (event(LeakS(phase0,bob)) && event(LeakM(phase0,bob))) || (event(LeakS(px,bob)) && event(LeakM(px,bob)) && event(LeakS(pz,alice)) && event(LeakM(pz,alice))) cannot be proved.

Query attacker_p1(msg_a(alice,bob,sid_a)) ==> event(LeakS(phase0,bob)) && event(LeakM(phase0,bob)) cannot be proved.

Query event(RecvMsg(alice,bob,stagepack_b(sid_a),m_24)) ==> event(SendMsg(bob,alice,stagepack_b(sid_b),m_24)) is true.

Query event(RecvMsg(alice,bob,stagepack_b(sid_a),m_24)) ==> event(SendMsg(bob,c,stagepack_b(sid_b),m_24)) || (event(LeakS(phase0,bob)) && event(LeakM(phase0,bob))) || (event(LeakS(phase0,alice)) && event(LeakM(phase0,alice))) is true.

Query event(RecvMsg(alice,bob,stagepack_b(sid_a),m_24)) ==> event(SendMsg(bob,c,stagepack_b(sid_b),m_24)) || (event(LeakS(phase0,bob)) && event(LeakM(phase0,bob))) is true.

Query event(RecvMsg(alice,bob,stagepack_b(sid_a),m_24)) ==> event(SendMsg(bob,alice,stagepack_b(sid_b),m_24)) || (event(LeakS(phase0,bob)) && event(LeakM(phase0,bob))) || (event(LeakS(phase0,alice)) && event(LeakM(phase0,alice))) is true.

Query event(RecvMsg(alice,bob,stagepack_b(sid_a),m_24)) ==> event(SendMsg(bob,alice,stagepack_b(sid_b),m_24)) || (event(LeakS(phase0,bob)) && event(LeakM(phase0,bob))) is true.

Query not attacker_p1(msg_b(bob,alice,sid_b)) is true.

Query attacker_p1(msg_b(bob,alice,sid_b)) ==> event(LeakS(px,alice)) && event(LeakM(px,alice)) is true.

Query attacker_p1(msg_b(bob,alice,sid_b)) ==> (event(LeakS(phase0,alice)) && event(LeakM(phase0,alice))) || (event(LeakS(px,alice)) && event(LeakM(px,alice)) && event(LeakS(pz,bob)) && event(LeakM(pz,bob))) is true.

Query attacker_p1(msg_b(bob,alice,sid_b)) ==> event(LeakS(phase0,alice)) && event(LeakM(phase0,alice)) is true.

Query event(RecvMsg(bob,alice,stagepack_c(sid_b),m_24)) ==> event(SendMsg(alice,bob,stagepack_c(sid_a),m_24)) is true.

Query event(RecvMsg(bob,alice,stagepack_c(sid_b),m_24)) ==> event(SendMsg(alice,c,stagepack_c(sid_a),m_24)) || (event(LeakS(phase0,alice)) && event(LeakM(phase0,alice))) || (event(LeakS(phase0,bob)) && event(LeakM(phase0,bob))) is true.

Query event(RecvMsg(bob,alice,stagepack_c(sid_b),m_24)) ==> event(SendMsg(alice,c,stagepack_c(sid_a),m_24)) || (event(LeakS(phase0,alice)) && event(LeakM(phase0,alice))) is true.

Query event(RecvMsg(bob,alice,stagepack_c(sid_b),m_24)) ==> event(SendMsg(alice,bob,stagepack_c(sid_a),m_24)) || (event(LeakS(phase0,alice)) && event(LeakM(phase0,alice))) || (event(LeakS(phase0,bob)) && event(LeakM(phase0,bob))) is true.

Query event(RecvMsg(bob,alice,stagepack_c(sid_b),m_24)) ==> event(SendMsg(alice,bob,stagepack_c(sid_a),m_24)) || (event(LeakS(phase0,alice)) && event(LeakM(phase0,alice))) is true.

Query not attacker_p1(msg_c(alice,bob,sid_a)) is true.

Query attacker_p1(msg_c(alice,bob,sid_a)) ==> event(LeakS(px,bob)) && event(LeakM(px,bob)) is true.

Query attacker_p1(msg_c(alice,bob,sid_a)) ==> (event(LeakS(phase0,bob)) && event(LeakM(phase0,bob))) || (event(LeakS(px,bob)) && event(LeakM(px,bob)) && event(LeakS(pz,alice)) && event(LeakM(pz,alice))) is true.

Query attacker_p1(msg_c(alice,bob,sid_a)) ==> event(LeakS(phase0,bob)) && event(LeakM(phase0,bob)) is true.

Query event(RecvMsg(alice,bob,stagepack_d(sid_a),m_24)) ==> event(SendMsg(bob,alice,stagepack_d(sid_b),m_24)) is true.

Query event(RecvMsg(alice,bob,stagepack_d(sid_a),m_24)) ==> event(SendMsg(bob,c,stagepack_d(sid_b),m_24)) || (event(LeakS(phase0,bob)) && event(LeakM(phase0,bob))) || (event(LeakS(phase0,alice)) && event(LeakM(phase0,alice))) is true.

Query event(RecvMsg(alice,bob,stagepack_d(sid_a),m_24)) ==> event(SendMsg(bob,c,stagepack_d(sid_b),m_24)) || (event(LeakS(phase0,bob)) && event(LeakM(phase0,bob))) is true.

Query event(RecvMsg(alice,bob,stagepack_d(sid_a),m_24)) ==> event(SendMsg(bob,alice,stagepack_d(sid_b),m_24)) || (event(LeakS(phase0,bob)) && event(LeakM(phase0,bob))) || (event(LeakS(phase0,alice)) && event(LeakM(phase0,alice))) is true.

Query event(RecvMsg(alice,bob,stagepack_d(sid_a),m_24)) ==> event(SendMsg(bob,alice,stagepack_d(sid_b),m_24)) || (event(LeakS(phase0,bob)) && event(LeakM(phase0,bob))) is true.

Query not attacker_p1(msg_d(bob,alice,sid_b)) is true.

Query attacker_p1(msg_d(bob,alice,sid_b)) ==> event(LeakS(px,alice)) && event(LeakM(px,alice)) is true.

Query attacker_p1(msg_d(bob,alice,sid_b)) ==> (event(LeakS(phase0,alice)) && event(LeakM(phase0,alice))) || (event(LeakS(px,alice)) && event(LeakM(px,alice)) && event(LeakS(pz,bob)) && event(LeakM(pz,bob))) is true.

Query attacker_p1(msg_d(bob,alice,sid_b)) ==> event(LeakS(phase0,alice)) && event(LeakM(phase0,alice)) is true.

Query not event(RecvEnd(true)) is true.

--------------------------------------------------------------


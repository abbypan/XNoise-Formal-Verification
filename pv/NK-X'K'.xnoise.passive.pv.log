File "pv/NK-X'K'.xnoise.passive.pv", line 222, characters 7-8:
Warning: identifier ck rebound.
File "pv/NK-X'K'.xnoise.passive.pv", line 231, characters 7-8:
Warning: identifier ck rebound.
File "pv/NK-X'K'.xnoise.passive.pv", line 232, characters 7-8:
Warning: identifier cs rebound.
File "pv/NK-X'K'.xnoise.passive.pv", line 232, character 36:
Warning: identifier h rebound.
File "pv/NK-X'K'.xnoise.passive.pv", line 262, characters 6-7:
Warning: identifier ss rebound.
File "pv/NK-X'K'.xnoise.passive.pv", line 263, characters 6-7:
Warning: identifier ss rebound.
File "pv/NK-X'K'.xnoise.passive.pv", line 268, characters 6-7:
Warning: identifier ss rebound.
File "pv/NK-X'K'.xnoise.passive.pv", line 269, characters 6-7:
Warning: identifier ss rebound.
File "pv/NK-X'K'.xnoise.passive.pv", line 275, character 6:
Warning: identifier e rebound.
File "pv/NK-X'K'.xnoise.passive.pv", line 276, characters 6-7:
Warning: identifier ne rebound.
File "pv/NK-X'K'.xnoise.passive.pv", line 277, characters 6-7:
Warning: identifier ss rebound.
File "pv/NK-X'K'.xnoise.passive.pv", line 279, characters 6-7:
Warning: identifier ss rebound.
File "pv/NK-X'K'.xnoise.passive.pv", line 280, characters 6-7:
Warning: identifier ss rebound.
File "pv/NK-X'K'.xnoise.passive.pv", line 281, characters 7-8:
Warning: identifier ss rebound.
File "pv/NK-X'K'.xnoise.passive.pv", line 281, characters 26-35:
Warning: identifier ciphertext rebound.
File "pv/NK-X'K'.xnoise.passive.pv", line 282, characters 6-7:
Warning: identifier hs rebound.
File "pv/NK-X'K'.xnoise.passive.pv", line 289, character 6:
Warning: identifier e rebound.
File "pv/NK-X'K'.xnoise.passive.pv", line 290, characters 6-7:
Warning: identifier ne rebound.
File "pv/NK-X'K'.xnoise.passive.pv", line 291, characters 6-7:
Warning: identifier ss rebound.
File "pv/NK-X'K'.xnoise.passive.pv", line 293, characters 6-7:
Warning: identifier ss rebound.
File "pv/NK-X'K'.xnoise.passive.pv", line 294, characters 7-8:
Warning: identifier ss rebound.
File "pv/NK-X'K'.xnoise.passive.pv", line 294, characters 26-35:
Warning: identifier ciphertext rebound.
File "pv/NK-X'K'.xnoise.passive.pv", line 295, characters 6-7:
Warning: identifier hs rebound.
File "pv/NK-X'K'.xnoise.passive.pv", line 306, character 6:
Warning: identifier m rebound.
File "pv/NK-X'K'.xnoise.passive.pv", line 307, characters 7-8:
Warning: identifier ss rebound.
File "pv/NK-X'K'.xnoise.passive.pv", line 307, characters 26-27:
Warning: identifier nm rebound.
File "pv/NK-X'K'.xnoise.passive.pv", line 310, characters 6-7:
Warning: identifier ss rebound.
File "pv/NK-X'K'.xnoise.passive.pv", line 312, characters 7-8:
Warning: identifier ss rebound.
File "pv/NK-X'K'.xnoise.passive.pv", line 312, characters 26-35:
Warning: identifier ciphertext rebound.
File "pv/NK-X'K'.xnoise.passive.pv", line 313, characters 6-7:
Warning: identifier hs rebound.
File "pv/NK-X'K'.xnoise.passive.pv", line 321, characters 7-8:
Warning: identifier ss rebound.
File "pv/NK-X'K'.xnoise.passive.pv", line 321, characters 26-35:
Warning: identifier ciphertext rebound.
File "pv/NK-X'K'.xnoise.passive.pv", line 322, characters 6-7:
Warning: identifier hs rebound.
File "pv/NK-X'K'.xnoise.passive.pv", line 329, characters 7-8:
Warning: identifier ss rebound.
File "pv/NK-X'K'.xnoise.passive.pv", line 329, characters 26-35:
Warning: identifier ciphertext rebound.
File "pv/NK-X'K'.xnoise.passive.pv", line 330, characters 6-7:
Warning: identifier hs rebound.
File "pv/NK-X'K'.xnoise.passive.pv", line 338, characters 6-7:
Warning: identifier re rebound.
File "pv/NK-X'K'.xnoise.passive.pv", line 339, characters 6-7:
Warning: identifier ss rebound.
File "pv/NK-X'K'.xnoise.passive.pv", line 341, characters 6-7:
Warning: identifier ss rebound.
File "pv/NK-X'K'.xnoise.passive.pv", line 342, characters 6-7:
Warning: identifier ss rebound.
File "pv/NK-X'K'.xnoise.passive.pv", line 343, characters 7-8:
Warning: identifier ss rebound.
File "pv/NK-X'K'.xnoise.passive.pv", line 345, characters 13-14:
Warning: identifier hs rebound.
File "pv/NK-X'K'.xnoise.passive.pv", line 353, characters 6-7:
Warning: identifier re rebound.
File "pv/NK-X'K'.xnoise.passive.pv", line 354, characters 6-7:
Warning: identifier ss rebound.
File "pv/NK-X'K'.xnoise.passive.pv", line 356, characters 6-7:
Warning: identifier ss rebound.
File "pv/NK-X'K'.xnoise.passive.pv", line 357, characters 7-8:
Warning: identifier ss rebound.
File "pv/NK-X'K'.xnoise.passive.pv", line 359, characters 13-14:
Warning: identifier hs rebound.
File "pv/NK-X'K'.xnoise.passive.pv", line 371, characters 7-8:
Warning: identifier ss rebound.
File "pv/NK-X'K'.xnoise.passive.pv", line 371, characters 41-46:
Warning: identifier valid1 rebound.
File "pv/NK-X'K'.xnoise.passive.pv", line 372, characters 6-7:
Warning: identifier rm rebound.
File "pv/NK-X'K'.xnoise.passive.pv", line 375, characters 6-7:
Warning: identifier ss rebound.
File "pv/NK-X'K'.xnoise.passive.pv", line 377, characters 7-8:
Warning: identifier ss rebound.
File "pv/NK-X'K'.xnoise.passive.pv", line 379, characters 13-14:
Warning: identifier hs rebound.
File "pv/NK-X'K'.xnoise.passive.pv", line 388, characters 7-8:
Warning: identifier ss rebound.
File "pv/NK-X'K'.xnoise.passive.pv", line 390, characters 13-14:
Warning: identifier hs rebound.
File "pv/NK-X'K'.xnoise.passive.pv", line 398, characters 7-8:
Warning: identifier ss rebound.
File "pv/NK-X'K'.xnoise.passive.pv", line 400, characters 13-14:
Warning: identifier hs rebound.
File "pv/NK-X'K'.xnoise.passive.pv", line 587, characters 7-8:
Warning: identifier hs rebound.
File "pv/NK-X'K'.xnoise.passive.pv", line 588, characters 8-9:
Warning: identifier hs rebound.
File "pv/NK-X'K'.xnoise.passive.pv", line 579, characters 7-8:
Warning: identifier hs rebound.
File "pv/NK-X'K'.xnoise.passive.pv", line 581, characters 8-9:
Warning: identifier hs rebound.
File "pv/NK-X'K'.xnoise.passive.pv", line 573, characters 8-9:
Warning: identifier hs rebound.
File "pv/NK-X'K'.xnoise.passive.pv", line 567, characters 8-9:
Warning: identifier hs rebound.
File "pv/NK-X'K'.xnoise.passive.pv", line 560, characters 8-9:
Warning: identifier hs rebound.
File "pv/NK-X'K'.xnoise.passive.pv", line 643, characters 7-8:
Warning: identifier hs rebound.
File "pv/NK-X'K'.xnoise.passive.pv", line 645, characters 8-9:
Warning: identifier hs rebound.
File "pv/NK-X'K'.xnoise.passive.pv", line 636, characters 7-8:
Warning: identifier hs rebound.
File "pv/NK-X'K'.xnoise.passive.pv", line 637, characters 8-9:
Warning: identifier hs rebound.
File "pv/NK-X'K'.xnoise.passive.pv", line 630, characters 8-9:
Warning: identifier hs rebound.
File "pv/NK-X'K'.xnoise.passive.pv", line 623, characters 8-9:
Warning: identifier hs rebound.
File "pv/NK-X'K'.xnoise.passive.pv", line 617, characters 8-9:
Warning: identifier hs rebound.
Linear part:
dhexp_real(b,dhexp_real(a,g)) = dhexp_real(a,dhexp_real(b,g))
Completing equations...
Completed equations:
dhexp_real(b,dhexp_real(a,g)) = dhexp_real(a,dhexp_real(b,g))
Convergent part: No equation.
Process 0 (that is, the initial process):
{1}out(pub, (key_s(charlie),key_m(charlie)));
{2}!
{3}new sid: sessionid;
(
    {4}let me: principal = alice in
    {5}let them: principal = bob in
    {6}let sid_1: sessionid = sid in
    {7}let s: keypair = keypairpack(empty,empty) in
    {8}let m: keypair = keypairpack(empty,empty) in
    {9}out(pub, (getpublickey(s),getpublickey(m)));
    (
        {10}let e: keypair = keypairpack(empty,empty) in
        {11}let basis: key = key_s(them) in
        {12}let public_key: key = catch-fail(dhexp(basis,validkey(g))) in
        {13}let v: bool = not-caught-fail(public_key) in
        {14}let rs: key = getpublickey((if v then keypairpack(validkey(public_key),basis) else fail-any)) in
        {15}let basis_1: key = key_m(them) in
        {16}let public_key_1: key = catch-fail(dhexp(basis_1,validkey(g))) in
        {17}let v_1: bool = not-caught-fail(public_key_1) in
        {18}let rm: key = getpublickey((if v_1 then keypairpack(validkey(public_key_1),basis_1) else fail-any)) in
        {19}let re: key = empty in
        {20}let prologue: bitstring = empty in
        {21}let psk: key = empty in
        {22}let protocol_name: bitstring = somename in
        {23}let h: bitstring = hash(protocol_name,empty) in
        {24}let ck: key = h in
        {25}let k: key = empty in
        {26}let cs: cipherstate = cipherstatepack(k,minnonce) in
        {27}let ss: symmetricstate = symmetricstatepack(cs,ck,h) in
        {28}let v_2: bitstring = catch-fail(symmetricstateunpack(ss)) in
        {29}let v_3: bool = (not-caught-fail(v_2) && success?(1-proj-3-tuple(v_2))) in
        {30}let h_1: bitstring = (if v_3 then 3-proj-3-tuple(v_2) else caught-fail) in
        {31}let ck_1: key = (if v_3 then 2-proj-3-tuple(v_2) else caught-fail) in
        {32}let cs_1: cipherstate = (if v_3 then 1-proj-3-tuple(v_2) else caught-fail) in
        {33}let ss_1: symmetricstate = catch-fail((if v_3 then symmetricstatepack(cs_1,ck_1,hash(h_1,prologue)) else fail-any)) in
        {34}let v_4: bool = not-caught-fail(ss_1) in
        {35}let v_5: bitstring = (if v_4 then catch-fail(symmetricstateunpack(ss_1)) else caught-fail) in
        {36}let v_6: bool = (not-caught-fail(v_5) && success?(1-proj-3-tuple(v_5))) in
        {37}let h_2: bitstring = (if v_6 then 3-proj-3-tuple(v_5) else caught-fail) in
        {38}let ck_2: key = (if v_6 then 2-proj-3-tuple(v_5) else caught-fail) in
        {39}let cs_2: cipherstate = (if v_6 then 1-proj-3-tuple(v_5) else caught-fail) in
        {40}let ss_2: symmetricstate = (if v_4 then catch-fail((if v_6 then symmetricstatepack(cs_2,ck_2,hash(h_2,rs)) else fail-any)) else caught-fail) in
        {41}let v_7: bool = not-caught-fail(ss_2) in
        {42}let v_8: bitstring = (if v_7 then catch-fail(symmetricstateunpack(ss_2)) else caught-fail) in
        {43}let v_9: bool = (not-caught-fail(v_8) && success?(1-proj-3-tuple(v_8))) in
        {44}let h_3: bitstring = (if v_9 then 3-proj-3-tuple(v_8) else caught-fail) in
        {45}let ck_3: key = (if v_9 then 2-proj-3-tuple(v_8) else caught-fail) in
        {46}let cs_3: cipherstate = (if v_9 then 1-proj-3-tuple(v_8) else caught-fail) in
        {47}let ss_3: symmetricstate = (if v_7 then catch-fail((if v_9 then symmetricstatepack(cs_3,ck_3,hash(h_3,rm)) else fail-any)) else caught-fail) in
        {48}let v_10: bool = not-caught-fail(ss_3) in
        {49}let hs: handshakestate = (if v_4 then (if v_7 then (if v_10 then handshakestatepack(ss_3,s,m,e,rs,rm,re,psk,true) else fail-any) else fail-any) else fail-any) in
        {50}insert statestore(me,them,sid_1,statepack_a(hs))
    ) | (
        {163}get statestore(=me,=them,=sid_1,statepack_a(hs_1: handshakestate)) in
        {51}let payload: bitstring = msg_a(me,them,sid_1) in
        {52}let v_11: bitstring = catch-fail(handshakestateunpack(hs_1)) in
        {53}let v_12: bool = (not-caught-fail(v_11) && success?(1-proj-9-tuple(v_11))) in
        {54}let initiator_1: bool = (if v_12 then 9-proj-9-tuple(v_11) else caught-fail) in
        {55}let psk_1: key = (if v_12 then 8-proj-9-tuple(v_11) else caught-fail) in
        {56}let re_1: key = (if v_12 then 7-proj-9-tuple(v_11) else caught-fail) in
        {57}let rm_1: key = (if v_12 then 6-proj-9-tuple(v_11) else caught-fail) in
        {58}let rs_1: key = (if v_12 then 5-proj-9-tuple(v_11) else caught-fail) in
        {59}let e_1: keypair = (if v_12 then 4-proj-9-tuple(v_11) else caught-fail) in
        {60}let m_1: keypair = (if v_12 then 3-proj-9-tuple(v_11) else caught-fail) in
        {61}let s_1: keypair = (if v_12 then 2-proj-9-tuple(v_11) else caught-fail) in
        {62}let ss_4: symmetricstate = (if v_12 then 1-proj-9-tuple(v_11) else caught-fail) in
        {63}let v_13: bitstring = (if v_12 then catch-fail((empty,empty,empty)) else caught-fail) in
        {64}let v_14: bool = (not-caught-fail(v_13) && success?(1-proj-3-tuple(v_13))) in
        {65}let ciphertext: bitstring = (if v_14 then 3-proj-3-tuple(v_13) else caught-fail) in
        {66}let ns: bitstring = (if v_14 then 2-proj-3-tuple(v_13) else caught-fail) in
        {67}let ne: bitstring = (if v_14 then 1-proj-3-tuple(v_13) else caught-fail) in
        {68}let basis_2: key = (if v_14 then key_e(me,them,sid_1) else caught-fail) in
        {69}let public_key_2: key = (if v_14 then catch-fail(dhexp(basis_2,validkey(g))) else caught-fail) in
        {70}let v_15: bool = not-caught-fail(public_key_2) in
        {71}let e_2: keypair = (if v_14 then catch-fail((if v_15 then keypairpack(validkey(public_key_2),basis_2) else fail-any)) else caught-fail) in
        {72}let v_16: bool = not-caught-fail(e_2) in
        {73}let ne_1: bitstring = (if v_16 then catch-fail(getpublickey(e_2)) else caught-fail) in
        {74}let v_17: bool = not-caught-fail(ne_1) in
        {75}let v_18: bitstring = (if v_17 then catch-fail(symmetricstateunpack(ss_4)) else caught-fail) in
        {76}let v_19: bool = (not-caught-fail(v_18) && success?(1-proj-3-tuple(v_18))) in
        {77}let h_4: bitstring = (if v_19 then 3-proj-3-tuple(v_18) else caught-fail) in
        {78}let ck_4: key = (if v_19 then 2-proj-3-tuple(v_18) else caught-fail) in
        {79}let cs_4: cipherstate = (if v_19 then 1-proj-3-tuple(v_18) else caught-fail) in
        {80}let ss_5: symmetricstate = (if v_17 then catch-fail((if v_19 then symmetricstatepack(cs_4,ck_4,hash(h_4,ne_1)) else fail-any)) else caught-fail) in
        {81}let v_20: bool = not-caught-fail(ss_5) in
        {82}let v_21: bitstring = (if v_20 then catch-fail(keypairunpack(e_2)) else caught-fail) in
        {83}let v_22: bool = (not-caught-fail(v_21) && success?(1-proj-2-tuple(v_21))) in
        {84}let my_private_key: key = (if v_22 then 2-proj-2-tuple(v_21) else caught-fail) in
        {85}let my_public_key: key = (if v_22 then 1-proj-2-tuple(v_21) else caught-fail) in
        {86}let input_key_material: key = (if v_20 then catch-fail((if v_22 then dhexp(my_private_key,rs_1) else fail-any)) else caught-fail) in
        {87}let v_23: bool = not-caught-fail(input_key_material) in
        {88}let v_24: bitstring = (if v_23 then catch-fail(symmetricstateunpack(ss_5)) else caught-fail) in
        {89}let v_25: bool = (not-caught-fail(v_24) && success?(1-proj-3-tuple(v_24))) in
        {90}let h_5: bitstring = (if v_25 then 3-proj-3-tuple(v_24) else caught-fail) in
        {91}let ck_5: key = (if v_25 then 2-proj-3-tuple(v_24) else caught-fail) in
        {92}let cs_5: cipherstate = (if v_25 then 1-proj-3-tuple(v_24) else caught-fail) in
        {93}let output1: key = (if v_25 then hmac_hash1(ck_5,input_key_material) else caught-fail) in
        {94}let output2: key = (if v_25 then hmac_hash2(ck_5,input_key_material) else caught-fail) in
        {95}let output3: key = (if v_25 then hmac_hash3(ck_5,input_key_material) else caught-fail) in
        {96}let v_26: bitstring = (if v_25 then catch-fail((output1,output2,output3)) else caught-fail) in
        {97}let v_27: bool = (not-caught-fail(v_26) && success?(1-proj-3-tuple(v_26))) in
        {98}let output_3: key = (if v_27 then 3-proj-3-tuple(v_26) else caught-fail) in
        {99}let temp_k: key = (if v_27 then 2-proj-3-tuple(v_26) else caught-fail) in
        {100}let ck_6: key = (if v_27 then 1-proj-3-tuple(v_26) else caught-fail) in
        {101}let ss_6: symmetricstate = (if v_20 then catch-fail((if v_23 then (if v_25 then (if v_27 then symmetricstatepack(cipherstatepack(temp_k,minnonce),ck_6,h_5) else fail-any) else fail-any) else fail-any)) else caught-fail) in
        {102}let v_28: bool = not-caught-fail(ss_6) in
        {103}let v_29: bitstring = (if v_28 then catch-fail(keypairunpack(e_2)) else caught-fail) in
        {104}let v_30: bool = (not-caught-fail(v_29) && success?(1-proj-2-tuple(v_29))) in
        {105}let my_private_key_1: key = (if v_30 then 2-proj-2-tuple(v_29) else caught-fail) in
        {106}let my_public_key_1: key = (if v_30 then 1-proj-2-tuple(v_29) else caught-fail) in
        {107}let input_key_material_1: key = (if v_28 then catch-fail((if v_30 then dhexp(my_private_key_1,rm_1) else fail-any)) else caught-fail) in
        {108}let v_31: bool = not-caught-fail(input_key_material_1) in
        {109}let v_32: bitstring = (if v_31 then catch-fail(symmetricstateunpack(ss_6)) else caught-fail) in
        {110}let v_33: bool = (not-caught-fail(v_32) && success?(1-proj-3-tuple(v_32))) in
        {111}let h_6: bitstring = (if v_33 then 3-proj-3-tuple(v_32) else caught-fail) in
        {112}let ck_7: key = (if v_33 then 2-proj-3-tuple(v_32) else caught-fail) in
        {113}let cs_6: cipherstate = (if v_33 then 1-proj-3-tuple(v_32) else caught-fail) in
        {114}let output1_1: key = (if v_33 then hmac_hash1(ck_7,input_key_material_1) else caught-fail) in
        {115}let output2_1: key = (if v_33 then hmac_hash2(ck_7,input_key_material_1) else caught-fail) in
        {116}let output3_1: key = (if v_33 then hmac_hash3(ck_7,input_key_material_1) else caught-fail) in
        {117}let v_34: bitstring = (if v_33 then catch-fail((output1_1,output2_1,output3_1)) else caught-fail) in
        {118}let v_35: bool = (not-caught-fail(v_34) && success?(1-proj-3-tuple(v_34))) in
        {119}let output: key = (if v_35 then 3-proj-3-tuple(v_34) else caught-fail) in
        {120}let temp_k_1: key = (if v_35 then 2-proj-3-tuple(v_34) else caught-fail) in
        {121}let ck_8: key = (if v_35 then 1-proj-3-tuple(v_34) else caught-fail) in
        {122}let ss_7: symmetricstate = (if v_28 then catch-fail((if v_31 then (if v_33 then (if v_35 then symmetricstatepack(cipherstatepack(temp_k_1,minnonce),ck_8,h_6) else fail-any) else fail-any) else fail-any)) else caught-fail) in
        {123}let v_36: bool = not-caught-fail(ss_7) in
        {124}let v_37: bitstring = (if v_36 then catch-fail(symmetricstateunpack(ss_7)) else caught-fail) in
        {125}let v_38: bool = (not-caught-fail(v_37) && success?(1-proj-3-tuple(v_37))) in
        {126}let h_7: bitstring = (if v_38 then 3-proj-3-tuple(v_37) else caught-fail) in
        {127}let ck_9: key = (if v_38 then 2-proj-3-tuple(v_37) else caught-fail) in
        {128}let cs_7: cipherstate = (if v_38 then 1-proj-3-tuple(v_37) else caught-fail) in
        {129}let v_39: bitstring = (if v_38 then catch-fail(cipherstateunpack(cs_7)) else caught-fail) in
        {130}let v_40: bool = (not-caught-fail(v_39) && success?(1-proj-2-tuple(v_39))) in
        {131}let n: nonce = (if v_40 then 2-proj-2-tuple(v_39) else caught-fail) in
        {132}let k_1: key = (if v_40 then 1-proj-2-tuple(v_39) else caught-fail) in
        {133}let e_3: bitstring = (if v_40 then encrypt(k_1,n,h_7,payload) else caught-fail) in
        {134}let n_1: nonce = (if v_40 then increment_nonce(n) else caught-fail) in
        {135}let v_41: bitstring = (if v_40 then catch-fail(cipherstateunpack(cs_7)) else caught-fail) in
        {136}let v_42: bool = (not-caught-fail(v_41) && success?(1-proj-2-tuple(v_41))) in
        {137}let o: nonce = (if v_42 then 2-proj-2-tuple(v_41) else caught-fail) in
        {138}let k_2: key = (if v_42 then 1-proj-2-tuple(v_41) else caught-fail) in
        {139}let csi: cipherstate = (if v_40 then catch-fail((if v_42 then cipherstatepack(k_2,n_1) else fail-any)) else caught-fail) in
        {140}let v_43: bool = not-caught-fail(csi) in
        {141}let v_44: bitstring = (if v_38 then catch-fail((if v_40 then (if v_43 then (csi,e_3) else fail-any) else fail-any)) else caught-fail) in
        {142}let v_45: bool = (not-caught-fail(v_44) && success?(1-proj-2-tuple(v_44))) in
        {143}let ciphertext_1: bitstring = (if v_45 then 2-proj-2-tuple(v_44) else caught-fail) in
        {144}let csi_1: cipherstate = (if v_45 then 1-proj-2-tuple(v_44) else caught-fail) in
        {145}let ss_8: symmetricstate = (if v_45 then symmetricstatepack(csi_1,ck_9,h_7) else caught-fail) in
        {146}let v_46: bitstring = (if v_45 then catch-fail(symmetricstateunpack(ss_8)) else caught-fail) in
        {147}let v_47: bool = (not-caught-fail(v_46) && success?(1-proj-3-tuple(v_46))) in
        {148}let h_8: bitstring = (if v_47 then 3-proj-3-tuple(v_46) else caught-fail) in
        {149}let ck_10: key = (if v_47 then 2-proj-3-tuple(v_46) else caught-fail) in
        {150}let cs_8: cipherstate = (if v_47 then 1-proj-3-tuple(v_46) else caught-fail) in
        {151}let ssi: symmetricstate = (if v_45 then catch-fail((if v_47 then symmetricstatepack(cs_8,ck_10,hash(h_8,ciphertext_1)) else fail-any)) else caught-fail) in
        {152}let v_48: bool = not-caught-fail(ssi) in
        {153}let v_49: bitstring = (if v_36 then catch-fail((if v_38 then (if v_45 then (if v_48 then (ssi,ciphertext_1) else fail-any) else fail-any) else fail-any)) else caught-fail) in
        {154}let v_50: bool = (not-caught-fail(v_49) && success?(1-proj-2-tuple(v_49))) in
        {155}let ciphertext_2: bitstring = (if v_50 then 2-proj-2-tuple(v_49) else caught-fail) in
        {156}let ss_9: symmetricstate = (if v_50 then 1-proj-2-tuple(v_49) else caught-fail) in
        {157}let hs_2: handshakestate = (if v_50 then handshakestatepack(ss_9,s_1,m_1,e_2,rs_1,rm_1,re_1,psk_1,initiator_1) else caught-fail) in
        {158}let message_buffer: bitstring = (if v_50 then concat3(ne_1,ns,ciphertext_2) else caught-fail) in
        {159}let (hs_3: handshakestate,message_a: bitstring) = (if v_12 then (if v_14 then (if v_16 then (if v_17 then (if v_20 then (if v_28 then (if v_36 then (if v_50 then (hs_2,message_buffer) else fail-any) else fail-any) else fail-any) else fail-any) else fail-any) else fail-any) else fail-any) else fail-any) in
        {160}event SendMsg(me,them,stagepack_a(sid_1),msg_a(me,them,sid_1));
        {161}insert statestore(me,them,sid_1,statepack_b(hs_3));
        {162}out(pub, message_a)
    ) | (
        {257}get statestore(=me,=them,=sid_1,statepack_b(hs_4: handshakestate)) in
        {164}in(pub, message_b: bitstring);
        {165}let v_51: bitstring = catch-fail(handshakestateunpack(hs_4)) in
        {166}let v_52: bool = (not-caught-fail(v_51) && success?(1-proj-9-tuple(v_51))) in
        {167}let initiator_2: bool = (if v_52 then 9-proj-9-tuple(v_51) else caught-fail) in
        {168}let psk_2: key = (if v_52 then 8-proj-9-tuple(v_51) else caught-fail) in
        {169}let re_2: key = (if v_52 then 7-proj-9-tuple(v_51) else caught-fail) in
        {170}let rm_2: key = (if v_52 then 6-proj-9-tuple(v_51) else caught-fail) in
        {171}let rs_2: key = (if v_52 then 5-proj-9-tuple(v_51) else caught-fail) in
        {172}let e_4: keypair = (if v_52 then 4-proj-9-tuple(v_51) else caught-fail) in
        {173}let m_2: keypair = (if v_52 then 3-proj-9-tuple(v_51) else caught-fail) in
        {174}let s_2: keypair = (if v_52 then 2-proj-9-tuple(v_51) else caught-fail) in
        {175}let ss_10: symmetricstate = (if v_52 then 1-proj-9-tuple(v_51) else caught-fail) in
        {176}let v_53: bitstring = (if v_52 then catch-fail(deconcat3(message_b)) else caught-fail) in
        {177}let v_54: bool = (not-caught-fail(v_53) && success?(1-proj-3-tuple(v_53))) in
        {178}let ciphertext_3: bitstring = (if v_54 then 3-proj-3-tuple(v_53) else caught-fail) in
        {179}let ns_1: bitstring = (if v_54 then 2-proj-3-tuple(v_53) else caught-fail) in
        {180}let ne_2: bitstring = (if v_54 then 1-proj-3-tuple(v_53) else caught-fail) in
        {181}let valid1: bool = (if v_54 then true else caught-fail) in
        {182}let re_3: key = (if v_54 then ne_2 else caught-fail) in
        {183}let v_55: bitstring = (if v_54 then catch-fail(symmetricstateunpack(ss_10)) else caught-fail) in
        {184}let v_56: bool = (not-caught-fail(v_55) && success?(1-proj-3-tuple(v_55))) in
        {185}let h_9: bitstring = (if v_56 then 3-proj-3-tuple(v_55) else caught-fail) in
        {186}let ck_11: key = (if v_56 then 2-proj-3-tuple(v_55) else caught-fail) in
        {187}let cs_9: cipherstate = (if v_56 then 1-proj-3-tuple(v_55) else caught-fail) in
        {188}let ss_11: symmetricstate = (if v_54 then catch-fail((if v_56 then symmetricstatepack(cs_9,ck_11,hash(h_9,re_3)) else fail-any)) else caught-fail) in
        {189}let v_57: bool = not-caught-fail(ss_11) in
        {190}let v_58: bitstring = (if v_57 then catch-fail(keypairunpack(e_4)) else caught-fail) in
        {191}let v_59: bool = (not-caught-fail(v_58) && success?(1-proj-2-tuple(v_58))) in
        {192}let my_private_key_2: key = (if v_59 then 2-proj-2-tuple(v_58) else caught-fail) in
        {193}let my_public_key_2: key = (if v_59 then 1-proj-2-tuple(v_58) else caught-fail) in
        {194}let input_key_material_2: key = (if v_57 then catch-fail((if v_59 then dhexp(my_private_key_2,re_3) else fail-any)) else caught-fail) in
        {195}let v_60: bool = not-caught-fail(input_key_material_2) in
        {196}let v_61: bitstring = (if v_60 then catch-fail(symmetricstateunpack(ss_11)) else caught-fail) in
        {197}let v_62: bool = (not-caught-fail(v_61) && success?(1-proj-3-tuple(v_61))) in
        {198}let h_10: bitstring = (if v_62 then 3-proj-3-tuple(v_61) else caught-fail) in
        {199}let ck_12: key = (if v_62 then 2-proj-3-tuple(v_61) else caught-fail) in
        {200}let cs_10: cipherstate = (if v_62 then 1-proj-3-tuple(v_61) else caught-fail) in
        {201}let output1_2: key = (if v_62 then hmac_hash1(ck_12,input_key_material_2) else caught-fail) in
        {202}let output2_2: key = (if v_62 then hmac_hash2(ck_12,input_key_material_2) else caught-fail) in
        {203}let output3_2: key = (if v_62 then hmac_hash3(ck_12,input_key_material_2) else caught-fail) in
        {204}let v_63: bitstring = (if v_62 then catch-fail((output1_2,output2_2,output3_2)) else caught-fail) in
        {205}let v_64: bool = (not-caught-fail(v_63) && success?(1-proj-3-tuple(v_63))) in
        {206}let output_1: key = (if v_64 then 3-proj-3-tuple(v_63) else caught-fail) in
        {207}let temp_k_2: key = (if v_64 then 2-proj-3-tuple(v_63) else caught-fail) in
        {208}let ck_13: key = (if v_64 then 1-proj-3-tuple(v_63) else caught-fail) in
        {209}let ss_12: symmetricstate = (if v_57 then catch-fail((if v_60 then (if v_62 then (if v_64 then symmetricstatepack(cipherstatepack(temp_k_2,minnonce),ck_13,h_10) else fail-any) else fail-any) else fail-any)) else caught-fail) in
        {210}let v_65: bool = not-caught-fail(ss_12) in
        {211}let v_66: bitstring = (if v_65 then catch-fail(symmetricstateunpack(ss_12)) else caught-fail) in
        {212}let v_67: bool = (not-caught-fail(v_66) && success?(1-proj-3-tuple(v_66))) in
        {213}let h_11: bitstring = (if v_67 then 3-proj-3-tuple(v_66) else caught-fail) in
        {214}let ck_14: key = (if v_67 then 2-proj-3-tuple(v_66) else caught-fail) in
        {215}let cs_11: cipherstate = (if v_67 then 1-proj-3-tuple(v_66) else caught-fail) in
        {216}let v_68: bitstring = (if v_67 then catch-fail(cipherstateunpack(cs_11)) else caught-fail) in
        {217}let v_69: bool = (not-caught-fail(v_68) && success?(1-proj-2-tuple(v_68))) in
        {218}let n_2: nonce = (if v_69 then 2-proj-2-tuple(v_68) else caught-fail) in
        {219}let k_3: key = (if v_69 then 1-proj-2-tuple(v_68) else caught-fail) in
        {220}let d: aead = (if v_69 then catch-fail(decrypt(k_3,n_2,h_11,ciphertext_3)) else caught-fail) in
        {221}let v_70: bool = not-caught-fail(d) in
        {222}let v_71: bitstring = (if v_70 then catch-fail(aeadunpack(d)) else caught-fail) in
        {223}let v_72: bool = (not-caught-fail(v_71) && success?(1-proj-3-tuple(v_71))) in
        {224}let plaintext: bitstring = (if v_72 then 3-proj-3-tuple(v_71) else caught-fail) in
        {225}let adi: bitstring = (if v_72 then 2-proj-3-tuple(v_71) else caught-fail) in
        {226}let valid: bool = (if v_72 then 1-proj-3-tuple(v_71) else caught-fail) in
        {227}let n_3: nonce = (if v_72 then increment_nonce(n_2) else caught-fail) in
        {228}let v_73: bitstring = (if v_72 then catch-fail(cipherstateunpack(cs_11)) else caught-fail) in
        {229}let v_74: bool = (not-caught-fail(v_73) && success?(1-proj-2-tuple(v_73))) in
        {230}let o_1: nonce = (if v_74 then 2-proj-2-tuple(v_73) else caught-fail) in
        {231}let k_4: key = (if v_74 then 1-proj-2-tuple(v_73) else caught-fail) in
        {232}let csi_2: cipherstate = (if v_72 then catch-fail((if v_74 then cipherstatepack(k_4,n_3) else fail-any)) else caught-fail) in
        {233}let v_75: bool = not-caught-fail(csi_2) in
        {234}let v_76: bitstring = (if v_67 then catch-fail((if v_69 then (if v_70 then (if v_72 then (if v_75 then (csi_2,plaintext,valid) else fail-any) else fail-any) else fail-any) else fail-any)) else caught-fail) in
        {235}let v_77: bool = (not-caught-fail(v_76) && success?(1-proj-3-tuple(v_76))) in
        {236}let valid_1: bool = (if v_77 then 3-proj-3-tuple(v_76) else caught-fail) in
        {237}let plaintext_1: bitstring = (if v_77 then 2-proj-3-tuple(v_76) else caught-fail) in
        {238}let csi_3: cipherstate = (if v_77 then 1-proj-3-tuple(v_76) else caught-fail) in
        {239}let ss_13: symmetricstate = (if v_77 then symmetricstatepack(csi_3,ck_14,h_11) else caught-fail) in
        {240}let v_78: bitstring = (if v_77 then catch-fail(symmetricstateunpack(ss_13)) else caught-fail) in
        {241}let v_79: bool = (not-caught-fail(v_78) && success?(1-proj-3-tuple(v_78))) in
        {242}let h_12: bitstring = (if v_79 then 3-proj-3-tuple(v_78) else caught-fail) in
        {243}let ck_15: key = (if v_79 then 2-proj-3-tuple(v_78) else caught-fail) in
        {244}let cs_12: cipherstate = (if v_79 then 1-proj-3-tuple(v_78) else caught-fail) in
        {245}let ssi_1: symmetricstate = (if v_77 then catch-fail((if v_79 then symmetricstatepack(cs_12,ck_15,hash(h_12,ciphertext_3)) else fail-any)) else caught-fail) in
        {246}let v_80: bool = not-caught-fail(ssi_1) in
        {247}let v_81: bitstring = (if v_65 then catch-fail((if v_67 then (if v_77 then (if v_80 then (ssi_1,plaintext_1,valid_1) else fail-any) else fail-any) else fail-any)) else caught-fail) in
        {248}let v_82: bool = (not-caught-fail(v_81) && success?(1-proj-3-tuple(v_81))) in
        {249}let valid2: bool = (if v_82 then 3-proj-3-tuple(v_81) else caught-fail) in
        {250}let plaintext_2: bitstring = (if v_82 then 2-proj-3-tuple(v_81) else caught-fail) in
        {251}let ss_14: symmetricstate = (if v_82 then 1-proj-3-tuple(v_81) else caught-fail) in
        {252}let v_83: bool = (if v_82 then catch-fail((valid1 && valid2)) else caught-fail) in
        {253}let hs_5: handshakestate = (if v_83 then handshakestatepack(ss_14,s_2,m_2,e_4,rs_2,rm_2,re_3,psk_2,initiator_2) else caught-fail) in
        {254}let (hs_6: handshakestate,plaintext_b: bitstring,valid_2: bool) = (if v_52 then (if v_54 then (if v_57 then (if v_65 then (if v_82 then (if undo-catch-fail(v_83) then (hs_5,plaintext_2,true) else fail-any) else fail-any) else fail-any) else fail-any) else fail-any) else fail-any) in
        {255}event RecvMsg(me,them,stagepack_b(sid_1),plaintext_b);
        {256}insert statestore(me,them,sid_1,statepack_c(hs_6))
    ) | (
        {396}get statestore(=me,=them,=sid_1,statepack_c(hs_7: handshakestate)) in
        {258}let payload_1: bitstring = msg_c(me,them,sid_1) in
        {259}let v_84: bitstring = catch-fail(handshakestateunpack(hs_7)) in
        {260}let v_85: bool = (not-caught-fail(v_84) && success?(1-proj-9-tuple(v_84))) in
        {261}let initiator_3: bool = (if v_85 then 9-proj-9-tuple(v_84) else caught-fail) in
        {262}let psk_3: key = (if v_85 then 8-proj-9-tuple(v_84) else caught-fail) in
        {263}let re_4: key = (if v_85 then 7-proj-9-tuple(v_84) else caught-fail) in
        {264}let rm_3: key = (if v_85 then 6-proj-9-tuple(v_84) else caught-fail) in
        {265}let rs_3: key = (if v_85 then 5-proj-9-tuple(v_84) else caught-fail) in
        {266}let e_5: keypair = (if v_85 then 4-proj-9-tuple(v_84) else caught-fail) in
        {267}let m_3: keypair = (if v_85 then 3-proj-9-tuple(v_84) else caught-fail) in
        {268}let s_3: keypair = (if v_85 then 2-proj-9-tuple(v_84) else caught-fail) in
        {269}let ss_15: symmetricstate = (if v_85 then 1-proj-9-tuple(v_84) else caught-fail) in
        {270}let v_86: bitstring = (if v_85 then catch-fail((empty,empty,empty)) else caught-fail) in
        {271}let v_87: bool = (not-caught-fail(v_86) && success?(1-proj-3-tuple(v_86))) in
        {272}let ciphertext_4: bitstring = (if v_87 then 3-proj-3-tuple(v_86) else caught-fail) in
        {273}let nm: bitstring = (if v_87 then 2-proj-3-tuple(v_86) else caught-fail) in
        {274}let ns_2: bitstring = (if v_87 then 1-proj-3-tuple(v_86) else caught-fail) in
        {275}let basis_3: key = (if v_87 then key_m(me) else caught-fail) in
        {276}let public_key_3: key = (if v_87 then catch-fail(dhexp(basis_3,validkey(g))) else caught-fail) in
        {277}let v_88: bool = not-caught-fail(public_key_3) in
        {278}let m_4: keypair = (if v_87 then catch-fail((if v_88 then keypairpack(validkey(public_key_3),basis_3) else fail-any)) else caught-fail) in
        {279}let v_89: bool = not-caught-fail(m_4) in
        {280}let plaintext_3: bitstring = (if v_89 then catch-fail(getpublickey(m_4)) else caught-fail) in
        {281}let v_90: bool = not-caught-fail(plaintext_3) in
        {282}let v_91: bitstring = (if v_90 then catch-fail(symmetricstateunpack(ss_15)) else caught-fail) in
        {283}let v_92: bool = (not-caught-fail(v_91) && success?(1-proj-3-tuple(v_91))) in
        {284}let h_13: bitstring = (if v_92 then 3-proj-3-tuple(v_91) else caught-fail) in
        {285}let ck_16: key = (if v_92 then 2-proj-3-tuple(v_91) else caught-fail) in
        {286}let cs_13: cipherstate = (if v_92 then 1-proj-3-tuple(v_91) else caught-fail) in
        {287}let v_93: bitstring = (if v_92 then catch-fail(cipherstateunpack(cs_13)) else caught-fail) in
        {288}let v_94: bool = (not-caught-fail(v_93) && success?(1-proj-2-tuple(v_93))) in
        {289}let n_4: nonce = (if v_94 then 2-proj-2-tuple(v_93) else caught-fail) in
        {290}let k_5: key = (if v_94 then 1-proj-2-tuple(v_93) else caught-fail) in
        {291}let e_6: bitstring = (if v_94 then encrypt(k_5,n_4,h_13,plaintext_3) else caught-fail) in
        {292}let n_5: nonce = (if v_94 then increment_nonce(n_4) else caught-fail) in
        {293}let v_95: bitstring = (if v_94 then catch-fail(cipherstateunpack(cs_13)) else caught-fail) in
        {294}let v_96: bool = (not-caught-fail(v_95) && success?(1-proj-2-tuple(v_95))) in
        {295}let o_2: nonce = (if v_96 then 2-proj-2-tuple(v_95) else caught-fail) in
        {296}let k_6: key = (if v_96 then 1-proj-2-tuple(v_95) else caught-fail) in
        {297}let csi_4: cipherstate = (if v_94 then catch-fail((if v_96 then cipherstatepack(k_6,n_5) else fail-any)) else caught-fail) in
        {298}let v_97: bool = not-caught-fail(csi_4) in
        {299}let v_98: bitstring = (if v_92 then catch-fail((if v_94 then (if v_97 then (csi_4,e_6) else fail-any) else fail-any)) else caught-fail) in
        {300}let v_99: bool = (not-caught-fail(v_98) && success?(1-proj-2-tuple(v_98))) in
        {301}let ciphertext_5: bitstring = (if v_99 then 2-proj-2-tuple(v_98) else caught-fail) in
        {302}let csi_5: cipherstate = (if v_99 then 1-proj-2-tuple(v_98) else caught-fail) in
        {303}let ss_16: symmetricstate = (if v_99 then symmetricstatepack(csi_5,ck_16,h_13) else caught-fail) in
        {304}let v_100: bitstring = (if v_99 then catch-fail(symmetricstateunpack(ss_16)) else caught-fail) in
        {305}let v_101: bool = (not-caught-fail(v_100) && success?(1-proj-3-tuple(v_100))) in
        {306}let h_14: bitstring = (if v_101 then 3-proj-3-tuple(v_100) else caught-fail) in
        {307}let ck_17: key = (if v_101 then 2-proj-3-tuple(v_100) else caught-fail) in
        {308}let cs_14: cipherstate = (if v_101 then 1-proj-3-tuple(v_100) else caught-fail) in
        {309}let ssi_2: symmetricstate = (if v_99 then catch-fail((if v_101 then symmetricstatepack(cs_14,ck_17,hash(h_14,ciphertext_5)) else fail-any)) else caught-fail) in
        {310}let v_102: bool = not-caught-fail(ssi_2) in
        {311}let v_103: bitstring = (if v_89 then catch-fail((if v_90 then (if v_92 then (if v_99 then (if v_102 then (ssi_2,ciphertext_5) else fail-any) else fail-any) else fail-any) else fail-any)) else caught-fail) in
        {312}let v_104: bool = (not-caught-fail(v_103) && success?(1-proj-2-tuple(v_103))) in
        {313}let nm_1: bitstring = (if v_104 then 2-proj-2-tuple(v_103) else caught-fail) in
        {314}let ss_17: symmetricstate = (if v_104 then 1-proj-2-tuple(v_103) else caught-fail) in
        {315}let v_105: bitstring = (if v_104 then catch-fail(keypairunpack(m_4)) else caught-fail) in
        {316}let v_106: bool = (not-caught-fail(v_105) && success?(1-proj-2-tuple(v_105))) in
        {317}let my_private_key_3: key = (if v_106 then 2-proj-2-tuple(v_105) else caught-fail) in
        {318}let my_public_key_3: key = (if v_106 then 1-proj-2-tuple(v_105) else caught-fail) in
        {319}let input_key_material_3: key = (if v_104 then catch-fail((if v_106 then dhexp(my_private_key_3,re_4) else fail-any)) else caught-fail) in
        {320}let v_107: bool = not-caught-fail(input_key_material_3) in
        {321}let v_108: bitstring = (if v_107 then catch-fail(symmetricstateunpack(ss_17)) else caught-fail) in
        {322}let v_109: bool = (not-caught-fail(v_108) && success?(1-proj-3-tuple(v_108))) in
        {323}let h_15: bitstring = (if v_109 then 3-proj-3-tuple(v_108) else caught-fail) in
        {324}let ck_18: key = (if v_109 then 2-proj-3-tuple(v_108) else caught-fail) in
        {325}let cs_15: cipherstate = (if v_109 then 1-proj-3-tuple(v_108) else caught-fail) in
        {326}let output1_3: key = (if v_109 then hmac_hash1(ck_18,input_key_material_3) else caught-fail) in
        {327}let output2_3: key = (if v_109 then hmac_hash2(ck_18,input_key_material_3) else caught-fail) in
        {328}let output3_3: key = (if v_109 then hmac_hash3(ck_18,input_key_material_3) else caught-fail) in
        {329}let v_110: bitstring = (if v_109 then catch-fail((output1_3,output2_3,output3_3)) else caught-fail) in
        {330}let v_111: bool = (not-caught-fail(v_110) && success?(1-proj-3-tuple(v_110))) in
        {331}let output_2: key = (if v_111 then 3-proj-3-tuple(v_110) else caught-fail) in
        {332}let temp_k_3: key = (if v_111 then 2-proj-3-tuple(v_110) else caught-fail) in
        {333}let ck_19: key = (if v_111 then 1-proj-3-tuple(v_110) else caught-fail) in
        {334}let ss_18: symmetricstate = (if v_104 then catch-fail((if v_107 then (if v_109 then (if v_111 then symmetricstatepack(cipherstatepack(temp_k_3,minnonce),ck_19,h_15) else fail-any) else fail-any) else fail-any)) else caught-fail) in
        {335}let v_112: bool = not-caught-fail(ss_18) in
        {336}let v_113: bitstring = (if v_112 then catch-fail(symmetricstateunpack(ss_18)) else caught-fail) in
        {337}let v_114: bool = (not-caught-fail(v_113) && success?(1-proj-3-tuple(v_113))) in
        {338}let h_16: bitstring = (if v_114 then 3-proj-3-tuple(v_113) else caught-fail) in
        {339}let ck_20: key = (if v_114 then 2-proj-3-tuple(v_113) else caught-fail) in
        {340}let cs_16: cipherstate = (if v_114 then 1-proj-3-tuple(v_113) else caught-fail) in
        {341}let v_115: bitstring = (if v_114 then catch-fail(cipherstateunpack(cs_16)) else caught-fail) in
        {342}let v_116: bool = (not-caught-fail(v_115) && success?(1-proj-2-tuple(v_115))) in
        {343}let n_6: nonce = (if v_116 then 2-proj-2-tuple(v_115) else caught-fail) in
        {344}let k_7: key = (if v_116 then 1-proj-2-tuple(v_115) else caught-fail) in
        {345}let e_7: bitstring = (if v_116 then encrypt(k_7,n_6,h_16,payload_1) else caught-fail) in
        {346}let n_7: nonce = (if v_116 then increment_nonce(n_6) else caught-fail) in
        {347}let v_117: bitstring = (if v_116 then catch-fail(cipherstateunpack(cs_16)) else caught-fail) in
        {348}let v_118: bool = (not-caught-fail(v_117) && success?(1-proj-2-tuple(v_117))) in
        {349}let o_3: nonce = (if v_118 then 2-proj-2-tuple(v_117) else caught-fail) in
        {350}let k_8: key = (if v_118 then 1-proj-2-tuple(v_117) else caught-fail) in
        {351}let csi_6: cipherstate = (if v_116 then catch-fail((if v_118 then cipherstatepack(k_8,n_7) else fail-any)) else caught-fail) in
        {352}let v_119: bool = not-caught-fail(csi_6) in
        {353}let v_120: bitstring = (if v_114 then catch-fail((if v_116 then (if v_119 then (csi_6,e_7) else fail-any) else fail-any)) else caught-fail) in
        {354}let v_121: bool = (not-caught-fail(v_120) && success?(1-proj-2-tuple(v_120))) in
        {355}let ciphertext_6: bitstring = (if v_121 then 2-proj-2-tuple(v_120) else caught-fail) in
        {356}let csi_7: cipherstate = (if v_121 then 1-proj-2-tuple(v_120) else caught-fail) in
        {357}let ss_19: symmetricstate = (if v_121 then symmetricstatepack(csi_7,ck_20,h_16) else caught-fail) in
        {358}let v_122: bitstring = (if v_121 then catch-fail(symmetricstateunpack(ss_19)) else caught-fail) in
        {359}let v_123: bool = (not-caught-fail(v_122) && success?(1-proj-3-tuple(v_122))) in
        {360}let h_17: bitstring = (if v_123 then 3-proj-3-tuple(v_122) else caught-fail) in
        {361}let ck_21: key = (if v_123 then 2-proj-3-tuple(v_122) else caught-fail) in
        {362}let cs_17: cipherstate = (if v_123 then 1-proj-3-tuple(v_122) else caught-fail) in
        {363}let ssi_3: symmetricstate = (if v_121 then catch-fail((if v_123 then symmetricstatepack(cs_17,ck_21,hash(h_17,ciphertext_6)) else fail-any)) else caught-fail) in
        {364}let v_124: bool = not-caught-fail(ssi_3) in
        {365}let v_125: bitstring = (if v_112 then catch-fail((if v_114 then (if v_121 then (if v_124 then (ssi_3,ciphertext_6) else fail-any) else fail-any) else fail-any)) else caught-fail) in
        {366}let v_126: bool = (not-caught-fail(v_125) && success?(1-proj-2-tuple(v_125))) in
        {367}let ciphertext_7: bitstring = (if v_126 then 2-proj-2-tuple(v_125) else caught-fail) in
        {368}let ss_20: symmetricstate = (if v_126 then 1-proj-2-tuple(v_125) else caught-fail) in
        {369}let hs_8: handshakestate = (if v_126 then handshakestatepack(ss_20,s_3,m_4,e_5,rs_3,rm_3,re_4,psk_3,initiator_3) else caught-fail) in
        {370}let message_buffer_1: bitstring = (if v_126 then concat3(ns_2,nm_1,ciphertext_7) else caught-fail) in
        {371}let v_127: bitstring = (if v_126 then catch-fail(symmetricstateunpack(ss_20)) else caught-fail) in
        {372}let v_128: bool = (not-caught-fail(v_127) && success?(1-proj-3-tuple(v_127))) in
        {373}let h_18: bitstring = (if v_128 then 3-proj-3-tuple(v_127) else caught-fail) in
        {374}let ck_22: key = (if v_128 then 2-proj-3-tuple(v_127) else caught-fail) in
        {375}let cs_18: cipherstate = (if v_128 then 1-proj-3-tuple(v_127) else caught-fail) in
        {376}let input_key_material_4: key = (if v_128 then zero else caught-fail) in
        {377}let output1_4: key = (if v_128 then hmac_hash1(ck_22,input_key_material_4) else caught-fail) in
        {378}let output2_4: key = (if v_128 then hmac_hash2(ck_22,input_key_material_4) else caught-fail) in
        {379}let output3_4: key = (if v_128 then hmac_hash3(ck_22,input_key_material_4) else caught-fail) in
        {380}let v_129: bitstring = (if v_128 then catch-fail((output1_4,output2_4,output3_4)) else caught-fail) in
        {381}let v_130: bool = (not-caught-fail(v_129) && success?(1-proj-3-tuple(v_129))) in
        {382}let temp_k3: key = (if v_130 then 3-proj-3-tuple(v_129) else caught-fail) in
        {383}let temp_k2: key = (if v_130 then 2-proj-3-tuple(v_129) else caught-fail) in
        {384}let temp_k1: key = (if v_130 then 1-proj-3-tuple(v_129) else caught-fail) in
        {385}let cs1: cipherstate = (if v_130 then cipherstatepack(temp_k1,minnonce) else caught-fail) in
        {386}let cs2: cipherstate = (if v_130 then cipherstatepack(temp_k2,minnonce) else caught-fail) in
        {387}let v_131: bitstring = (if v_126 then catch-fail((if v_128 then (if v_130 then (ss_20,cs1,cs2) else fail-any) else fail-any)) else caught-fail) in
        {388}let v_132: bool = (not-caught-fail(v_131) && success?(1-proj-3-tuple(v_131))) in
        {389}let cs2_1: cipherstate = (if v_132 then 3-proj-3-tuple(v_131) else caught-fail) in
        {390}let cs1_1: cipherstate = (if v_132 then 2-proj-3-tuple(v_131) else caught-fail) in
        {391}let ssi_4: symmetricstate = (if v_132 then 1-proj-3-tuple(v_131) else caught-fail) in
        {392}let (hs_9: handshakestate,message_c: bitstring,cs1_2: cipherstate,cs2_2: cipherstate) = (if v_85 then (if v_87 then (if v_89 then (if v_104 then (if v_112 then (if v_126 then (if v_132 then (hs_8,message_buffer_1,cs1_1,cs2_1) else fail-any) else fail-any) else fail-any) else fail-any) else fail-any) else fail-any) else fail-any) in
        {393}event SendMsg(me,them,stagepack_c(sid_1),msg_c(me,them,sid_1));
        {394}insert statestore(me,them,sid_1,statepack_d(hs_9,cs1_2,cs2_2));
        {395}out(pub, message_c)
    ) | (
        {397}!
        {463}get statestore(=me,=them,=sid_1,statepack_d(hs_10: handshakestate,cs1_3: cipherstate,cs2_3: cipherstate)) in
        {398}let hs_11: handshakestate = handshakestatesetcs(hs_10,cs2_3) in
        {399}in(pub, message_d: bitstring);
        {400}let v_133: bitstring = catch-fail(handshakestateunpack(hs_11)) in
        {401}let v_134: bool = (not-caught-fail(v_133) && success?(1-proj-9-tuple(v_133))) in
        {402}let initiator_4: bool = (if v_134 then 9-proj-9-tuple(v_133) else caught-fail) in
        {403}let psk_4: key = (if v_134 then 8-proj-9-tuple(v_133) else caught-fail) in
        {404}let re_5: key = (if v_134 then 7-proj-9-tuple(v_133) else caught-fail) in
        {405}let rm_4: key = (if v_134 then 6-proj-9-tuple(v_133) else caught-fail) in
        {406}let rs_4: key = (if v_134 then 5-proj-9-tuple(v_133) else caught-fail) in
        {407}let e_8: keypair = (if v_134 then 4-proj-9-tuple(v_133) else caught-fail) in
        {408}let m_5: keypair = (if v_134 then 3-proj-9-tuple(v_133) else caught-fail) in
        {409}let s_4: keypair = (if v_134 then 2-proj-9-tuple(v_133) else caught-fail) in
        {410}let ss_21: symmetricstate = (if v_134 then 1-proj-9-tuple(v_133) else caught-fail) in
        {411}let v_135: bitstring = (if v_134 then catch-fail(deconcat3(message_d)) else caught-fail) in
        {412}let v_136: bool = (not-caught-fail(v_135) && success?(1-proj-3-tuple(v_135))) in
        {413}let ciphertext_8: bitstring = (if v_136 then 3-proj-3-tuple(v_135) else caught-fail) in
        {414}let ns_3: bitstring = (if v_136 then 2-proj-3-tuple(v_135) else caught-fail) in
        {415}let ne_3: bitstring = (if v_136 then 1-proj-3-tuple(v_135) else caught-fail) in
        {416}let valid1_1: bool = (if v_136 then true else caught-fail) in
        {417}let v_137: bitstring = (if v_136 then catch-fail(symmetricstateunpack(ss_21)) else caught-fail) in
        {418}let v_138: bool = (not-caught-fail(v_137) && success?(1-proj-3-tuple(v_137))) in
        {419}let h_19: bitstring = (if v_138 then 3-proj-3-tuple(v_137) else caught-fail) in
        {420}let ck_23: key = (if v_138 then 2-proj-3-tuple(v_137) else caught-fail) in
        {421}let cs_19: cipherstate = (if v_138 then 1-proj-3-tuple(v_137) else caught-fail) in
        {422}let v_139: bitstring = (if v_138 then catch-fail(cipherstateunpack(cs_19)) else caught-fail) in
        {423}let v_140: bool = (not-caught-fail(v_139) && success?(1-proj-2-tuple(v_139))) in
        {424}let n_8: nonce = (if v_140 then 2-proj-2-tuple(v_139) else caught-fail) in
        {425}let k_9: key = (if v_140 then 1-proj-2-tuple(v_139) else caught-fail) in
        {426}let d_1: aead = (if v_140 then catch-fail(decrypt(k_9,n_8,h_19,ciphertext_8)) else caught-fail) in
        {427}let v_141: bool = not-caught-fail(d_1) in
        {428}let v_142: bitstring = (if v_141 then catch-fail(aeadunpack(d_1)) else caught-fail) in
        {429}let v_143: bool = (not-caught-fail(v_142) && success?(1-proj-3-tuple(v_142))) in
        {430}let plaintext_4: bitstring = (if v_143 then 3-proj-3-tuple(v_142) else caught-fail) in
        {431}let adi_1: bitstring = (if v_143 then 2-proj-3-tuple(v_142) else caught-fail) in
        {432}let valid_3: bool = (if v_143 then 1-proj-3-tuple(v_142) else caught-fail) in
        {433}let n_9: nonce = (if v_143 then increment_nonce(n_8) else caught-fail) in
        {434}let v_144: bitstring = (if v_143 then catch-fail(cipherstateunpack(cs_19)) else caught-fail) in
        {435}let v_145: bool = (not-caught-fail(v_144) && success?(1-proj-2-tuple(v_144))) in
        {436}let o_4: nonce = (if v_145 then 2-proj-2-tuple(v_144) else caught-fail) in
        {437}let k_10: key = (if v_145 then 1-proj-2-tuple(v_144) else caught-fail) in
        {438}let csi_8: cipherstate = (if v_143 then catch-fail((if v_145 then cipherstatepack(k_10,n_9) else fail-any)) else caught-fail) in
        {439}let v_146: bool = not-caught-fail(csi_8) in
        {440}let v_147: bitstring = (if v_138 then catch-fail((if v_140 then (if v_141 then (if v_143 then (if v_146 then (csi_8,plaintext_4,valid_3) else fail-any) else fail-any) else fail-any) else fail-any)) else caught-fail) in
        {441}let v_148: bool = (not-caught-fail(v_147) && success?(1-proj-3-tuple(v_147))) in
        {442}let valid_4: bool = (if v_148 then 3-proj-3-tuple(v_147) else caught-fail) in
        {443}let plaintext_5: bitstring = (if v_148 then 2-proj-3-tuple(v_147) else caught-fail) in
        {444}let csi_9: cipherstate = (if v_148 then 1-proj-3-tuple(v_147) else caught-fail) in
        {445}let ss_22: symmetricstate = (if v_148 then symmetricstatepack(csi_9,ck_23,h_19) else caught-fail) in
        {446}let v_149: bitstring = (if v_148 then catch-fail(symmetricstateunpack(ss_22)) else caught-fail) in
        {447}let v_150: bool = (not-caught-fail(v_149) && success?(1-proj-3-tuple(v_149))) in
        {448}let h_20: bitstring = (if v_150 then 3-proj-3-tuple(v_149) else caught-fail) in
        {449}let ck_24: key = (if v_150 then 2-proj-3-tuple(v_149) else caught-fail) in
        {450}let cs_20: cipherstate = (if v_150 then 1-proj-3-tuple(v_149) else caught-fail) in
        {451}let ssi_5: symmetricstate = (if v_148 then catch-fail((if v_150 then symmetricstatepack(cs_20,ck_24,hash(h_20,ciphertext_8)) else fail-any)) else caught-fail) in
        {452}let v_151: bool = not-caught-fail(ssi_5) in
        {453}let v_152: bitstring = (if v_136 then catch-fail((if v_138 then (if v_148 then (if v_151 then (ssi_5,plaintext_5,valid_4) else fail-any) else fail-any) else fail-any)) else caught-fail) in
        {454}let v_153: bool = (not-caught-fail(v_152) && success?(1-proj-3-tuple(v_152))) in
        {455}let valid2_1: bool = (if v_153 then 3-proj-3-tuple(v_152) else caught-fail) in
        {456}let plaintext_6: bitstring = (if v_153 then 2-proj-3-tuple(v_152) else caught-fail) in
        {457}let ss_23: symmetricstate = (if v_153 then 1-proj-3-tuple(v_152) else caught-fail) in
        {458}let v_154: bool = (if v_153 then catch-fail((valid1_1 && valid2_1)) else caught-fail) in
        {459}let hs_12: handshakestate = (if v_154 then handshakestatepack(ss_23,s_4,m_5,e_8,rs_4,rm_4,re_5,psk_4,initiator_4) else caught-fail) in
        {460}let (hs_13: handshakestate,plaintext_d: bitstring,valid_5: bool) = (if v_134 then (if v_136 then (if v_153 then (if undo-catch-fail(v_154) then (hs_12,plaintext_6,true) else fail-any) else fail-any) else fail-any) else fail-any) in
        {461}event RecvMsg(me,them,stagepack_d(sid_1),plaintext_d);
        {462}insert statestore(me,them,sid_1,statepack_e(hs_13,cs1_3,handshakestategetcs(hs_13)))
    ) | (
        {464}!
        {521}get statestore(=me,=them,=sid_1,statepack_e(hs_14: handshakestate,cs1_4: cipherstate,cs2_4: cipherstate)) in
        {465}let hs_15: handshakestate = handshakestatesetcs(hs_14,cs1_4) in
        {466}let payload_2: bitstring = msg_e(me,them,sid_1) in
        {467}let v_155: bitstring = catch-fail(handshakestateunpack(hs_15)) in
        {468}let v_156: bool = (not-caught-fail(v_155) && success?(1-proj-9-tuple(v_155))) in
        {469}let initiator_5: bool = (if v_156 then 9-proj-9-tuple(v_155) else caught-fail) in
        {470}let psk_5: key = (if v_156 then 8-proj-9-tuple(v_155) else caught-fail) in
        {471}let re_6: key = (if v_156 then 7-proj-9-tuple(v_155) else caught-fail) in
        {472}let rm_5: key = (if v_156 then 6-proj-9-tuple(v_155) else caught-fail) in
        {473}let rs_5: key = (if v_156 then 5-proj-9-tuple(v_155) else caught-fail) in
        {474}let e_9: keypair = (if v_156 then 4-proj-9-tuple(v_155) else caught-fail) in
        {475}let m_6: keypair = (if v_156 then 3-proj-9-tuple(v_155) else caught-fail) in
        {476}let s_5: keypair = (if v_156 then 2-proj-9-tuple(v_155) else caught-fail) in
        {477}let ss_24: symmetricstate = (if v_156 then 1-proj-9-tuple(v_155) else caught-fail) in
        {478}let v_157: bitstring = (if v_156 then catch-fail((empty,empty,empty)) else caught-fail) in
        {479}let v_158: bool = (not-caught-fail(v_157) && success?(1-proj-3-tuple(v_157))) in
        {480}let ciphertext_9: bitstring = (if v_158 then 3-proj-3-tuple(v_157) else caught-fail) in
        {481}let ns_4: bitstring = (if v_158 then 2-proj-3-tuple(v_157) else caught-fail) in
        {482}let ne_4: bitstring = (if v_158 then 1-proj-3-tuple(v_157) else caught-fail) in
        {483}let v_159: bitstring = (if v_158 then catch-fail(symmetricstateunpack(ss_24)) else caught-fail) in
        {484}let v_160: bool = (not-caught-fail(v_159) && success?(1-proj-3-tuple(v_159))) in
        {485}let h_21: bitstring = (if v_160 then 3-proj-3-tuple(v_159) else caught-fail) in
        {486}let ck_25: key = (if v_160 then 2-proj-3-tuple(v_159) else caught-fail) in
        {487}let cs_21: cipherstate = (if v_160 then 1-proj-3-tuple(v_159) else caught-fail) in
        {488}let v_161: bitstring = (if v_160 then catch-fail(cipherstateunpack(cs_21)) else caught-fail) in
        {489}let v_162: bool = (not-caught-fail(v_161) && success?(1-proj-2-tuple(v_161))) in
        {490}let n_10: nonce = (if v_162 then 2-proj-2-tuple(v_161) else caught-fail) in
        {491}let k_11: key = (if v_162 then 1-proj-2-tuple(v_161) else caught-fail) in
        {492}let e_10: bitstring = (if v_162 then encrypt(k_11,n_10,h_21,payload_2) else caught-fail) in
        {493}let n_11: nonce = (if v_162 then increment_nonce(n_10) else caught-fail) in
        {494}let v_163: bitstring = (if v_162 then catch-fail(cipherstateunpack(cs_21)) else caught-fail) in
        {495}let v_164: bool = (not-caught-fail(v_163) && success?(1-proj-2-tuple(v_163))) in
        {496}let o_5: nonce = (if v_164 then 2-proj-2-tuple(v_163) else caught-fail) in
        {497}let k_12: key = (if v_164 then 1-proj-2-tuple(v_163) else caught-fail) in
        {498}let csi_10: cipherstate = (if v_162 then catch-fail((if v_164 then cipherstatepack(k_12,n_11) else fail-any)) else caught-fail) in
        {499}let v_165: bool = not-caught-fail(csi_10) in
        {500}let v_166: bitstring = (if v_160 then catch-fail((if v_162 then (if v_165 then (csi_10,e_10) else fail-any) else fail-any)) else caught-fail) in
        {501}let v_167: bool = (not-caught-fail(v_166) && success?(1-proj-2-tuple(v_166))) in
        {502}let ciphertext_10: bitstring = (if v_167 then 2-proj-2-tuple(v_166) else caught-fail) in
        {503}let csi_11: cipherstate = (if v_167 then 1-proj-2-tuple(v_166) else caught-fail) in
        {504}let ss_25: symmetricstate = (if v_167 then symmetricstatepack(csi_11,ck_25,h_21) else caught-fail) in
        {505}let v_168: bitstring = (if v_167 then catch-fail(symmetricstateunpack(ss_25)) else caught-fail) in
        {506}let v_169: bool = (not-caught-fail(v_168) && success?(1-proj-3-tuple(v_168))) in
        {507}let h_22: bitstring = (if v_169 then 3-proj-3-tuple(v_168) else caught-fail) in
        {508}let ck_26: key = (if v_169 then 2-proj-3-tuple(v_168) else caught-fail) in
        {509}let cs_22: cipherstate = (if v_169 then 1-proj-3-tuple(v_168) else caught-fail) in
        {510}let ssi_6: symmetricstate = (if v_167 then catch-fail((if v_169 then symmetricstatepack(cs_22,ck_26,hash(h_22,ciphertext_10)) else fail-any)) else caught-fail) in
        {511}let v_170: bool = not-caught-fail(ssi_6) in
        {512}let v_171: bitstring = (if v_158 then catch-fail((if v_160 then (if v_167 then (if v_170 then (ssi_6,ciphertext_10) else fail-any) else fail-any) else fail-any)) else caught-fail) in
        {513}let v_172: bool = (not-caught-fail(v_171) && success?(1-proj-2-tuple(v_171))) in
        {514}let ciphertext_11: bitstring = (if v_172 then 2-proj-2-tuple(v_171) else caught-fail) in
        {515}let ss_26: symmetricstate = (if v_172 then 1-proj-2-tuple(v_171) else caught-fail) in
        {516}let hs_16: handshakestate = (if v_172 then handshakestatepack(ss_26,s_5,m_6,e_9,rs_5,rm_5,re_6,psk_5,initiator_5) else caught-fail) in
        {517}let message_buffer_2: bitstring = (if v_172 then concat3(ne_4,ns_4,ciphertext_11) else caught-fail) in
        {518}let (hs_17: handshakestate,message_e: bitstring) = (if v_156 then (if v_158 then (if v_172 then (hs_16,message_buffer_2) else fail-any) else fail-any) else fail-any) in
        {519}event SendMsg(me,them,stagepack_e(sid_1),msg_e(me,them,sid_1));
        {520}out(pub, message_e)
    ) | (
        {522}event LeakS(phase0,me);
        {523}event LeakM(phase0,me);
        {524}out(pub, (key_s(me),key_m(me)))
    ) | (
        {525}phase 1;
        {526}event LeakS(phase1,me);
        {527}event LeakM(phase1,me);
        {528}out(pub, (key_s(me),key_m(me)))
    )
) | (
    {529}let me_1: principal = alice in
    {530}let them_1: principal = charlie in
    {531}let sid_2: sessionid = sid in
    {532}let s_6: keypair = keypairpack(empty,empty) in
    {533}let m_7: keypair = keypairpack(empty,empty) in
    {534}out(pub, (getpublickey(s_6),getpublickey(m_7)));
    (
        {535}let e_11: keypair = keypairpack(empty,empty) in
        {536}let basis_4: key = key_s(them_1) in
        {537}let public_key_4: key = catch-fail(dhexp(basis_4,validkey(g))) in
        {538}let v_173: bool = not-caught-fail(public_key_4) in
        {539}let rs_6: key = getpublickey((if v_173 then keypairpack(validkey(public_key_4),basis_4) else fail-any)) in
        {540}let basis_5: key = key_m(them_1) in
        {541}let public_key_5: key = catch-fail(dhexp(basis_5,validkey(g))) in
        {542}let v_174: bool = not-caught-fail(public_key_5) in
        {543}let rm_6: key = getpublickey((if v_174 then keypairpack(validkey(public_key_5),basis_5) else fail-any)) in
        {544}let re_7: key = empty in
        {545}let prologue_1: bitstring = empty in
        {546}let psk_6: key = empty in
        {547}let protocol_name_1: bitstring = somename in
        {548}let h_23: bitstring = hash(protocol_name_1,empty) in
        {549}let ck_27: key = h_23 in
        {550}let k_13: key = empty in
        {551}let cs_23: cipherstate = cipherstatepack(k_13,minnonce) in
        {552}let ss_27: symmetricstate = symmetricstatepack(cs_23,ck_27,h_23) in
        {553}let v_175: bitstring = catch-fail(symmetricstateunpack(ss_27)) in
        {554}let v_176: bool = (not-caught-fail(v_175) && success?(1-proj-3-tuple(v_175))) in
        {555}let h_24: bitstring = (if v_176 then 3-proj-3-tuple(v_175) else caught-fail) in
        {556}let ck_28: key = (if v_176 then 2-proj-3-tuple(v_175) else caught-fail) in
        {557}let cs_24: cipherstate = (if v_176 then 1-proj-3-tuple(v_175) else caught-fail) in
        {558}let ss_28: symmetricstate = catch-fail((if v_176 then symmetricstatepack(cs_24,ck_28,hash(h_24,prologue_1)) else fail-any)) in
        {559}let v_177: bool = not-caught-fail(ss_28) in
        {560}let v_178: bitstring = (if v_177 then catch-fail(symmetricstateunpack(ss_28)) else caught-fail) in
        {561}let v_179: bool = (not-caught-fail(v_178) && success?(1-proj-3-tuple(v_178))) in
        {562}let h_25: bitstring = (if v_179 then 3-proj-3-tuple(v_178) else caught-fail) in
        {563}let ck_29: key = (if v_179 then 2-proj-3-tuple(v_178) else caught-fail) in
        {564}let cs_25: cipherstate = (if v_179 then 1-proj-3-tuple(v_178) else caught-fail) in
        {565}let ss_29: symmetricstate = (if v_177 then catch-fail((if v_179 then symmetricstatepack(cs_25,ck_29,hash(h_25,rs_6)) else fail-any)) else caught-fail) in
        {566}let v_180: bool = not-caught-fail(ss_29) in
        {567}let v_181: bitstring = (if v_180 then catch-fail(symmetricstateunpack(ss_29)) else caught-fail) in
        {568}let v_182: bool = (not-caught-fail(v_181) && success?(1-proj-3-tuple(v_181))) in
        {569}let h_26: bitstring = (if v_182 then 3-proj-3-tuple(v_181) else caught-fail) in
        {570}let ck_30: key = (if v_182 then 2-proj-3-tuple(v_181) else caught-fail) in
        {571}let cs_26: cipherstate = (if v_182 then 1-proj-3-tuple(v_181) else caught-fail) in
        {572}let ss_30: symmetricstate = (if v_180 then catch-fail((if v_182 then symmetricstatepack(cs_26,ck_30,hash(h_26,rm_6)) else fail-any)) else caught-fail) in
        {573}let v_183: bool = not-caught-fail(ss_30) in
        {574}let hs_18: handshakestate = (if v_177 then (if v_180 then (if v_183 then handshakestatepack(ss_30,s_6,m_7,e_11,rs_6,rm_6,re_7,psk_6,true) else fail-any) else fail-any) else fail-any) in
        {575}insert statestore(me_1,them_1,sid_2,statepack_a(hs_18))
    ) | (
        {688}get statestore(=me_1,=them_1,=sid_2,statepack_a(hs_19: handshakestate)) in
        {576}let payload_3: bitstring = msg_a(me_1,them_1,sid_2) in
        {577}let v_184: bitstring = catch-fail(handshakestateunpack(hs_19)) in
        {578}let v_185: bool = (not-caught-fail(v_184) && success?(1-proj-9-tuple(v_184))) in
        {579}let initiator_6: bool = (if v_185 then 9-proj-9-tuple(v_184) else caught-fail) in
        {580}let psk_7: key = (if v_185 then 8-proj-9-tuple(v_184) else caught-fail) in
        {581}let re_8: key = (if v_185 then 7-proj-9-tuple(v_184) else caught-fail) in
        {582}let rm_7: key = (if v_185 then 6-proj-9-tuple(v_184) else caught-fail) in
        {583}let rs_7: key = (if v_185 then 5-proj-9-tuple(v_184) else caught-fail) in
        {584}let e_12: keypair = (if v_185 then 4-proj-9-tuple(v_184) else caught-fail) in
        {585}let m_8: keypair = (if v_185 then 3-proj-9-tuple(v_184) else caught-fail) in
        {586}let s_7: keypair = (if v_185 then 2-proj-9-tuple(v_184) else caught-fail) in
        {587}let ss_31: symmetricstate = (if v_185 then 1-proj-9-tuple(v_184) else caught-fail) in
        {588}let v_186: bitstring = (if v_185 then catch-fail((empty,empty,empty)) else caught-fail) in
        {589}let v_187: bool = (not-caught-fail(v_186) && success?(1-proj-3-tuple(v_186))) in
        {590}let ciphertext_12: bitstring = (if v_187 then 3-proj-3-tuple(v_186) else caught-fail) in
        {591}let ns_5: bitstring = (if v_187 then 2-proj-3-tuple(v_186) else caught-fail) in
        {592}let ne_5: bitstring = (if v_187 then 1-proj-3-tuple(v_186) else caught-fail) in
        {593}let basis_6: key = (if v_187 then key_e(me_1,them_1,sid_2) else caught-fail) in
        {594}let public_key_6: key = (if v_187 then catch-fail(dhexp(basis_6,validkey(g))) else caught-fail) in
        {595}let v_188: bool = not-caught-fail(public_key_6) in
        {596}let e_13: keypair = (if v_187 then catch-fail((if v_188 then keypairpack(validkey(public_key_6),basis_6) else fail-any)) else caught-fail) in
        {597}let v_189: bool = not-caught-fail(e_13) in
        {598}let ne_6: bitstring = (if v_189 then catch-fail(getpublickey(e_13)) else caught-fail) in
        {599}let v_190: bool = not-caught-fail(ne_6) in
        {600}let v_191: bitstring = (if v_190 then catch-fail(symmetricstateunpack(ss_31)) else caught-fail) in
        {601}let v_192: bool = (not-caught-fail(v_191) && success?(1-proj-3-tuple(v_191))) in
        {602}let h_27: bitstring = (if v_192 then 3-proj-3-tuple(v_191) else caught-fail) in
        {603}let ck_31: key = (if v_192 then 2-proj-3-tuple(v_191) else caught-fail) in
        {604}let cs_27: cipherstate = (if v_192 then 1-proj-3-tuple(v_191) else caught-fail) in
        {605}let ss_32: symmetricstate = (if v_190 then catch-fail((if v_192 then symmetricstatepack(cs_27,ck_31,hash(h_27,ne_6)) else fail-any)) else caught-fail) in
        {606}let v_193: bool = not-caught-fail(ss_32) in
        {607}let v_194: bitstring = (if v_193 then catch-fail(keypairunpack(e_13)) else caught-fail) in
        {608}let v_195: bool = (not-caught-fail(v_194) && success?(1-proj-2-tuple(v_194))) in
        {609}let my_private_key_4: key = (if v_195 then 2-proj-2-tuple(v_194) else caught-fail) in
        {610}let my_public_key_4: key = (if v_195 then 1-proj-2-tuple(v_194) else caught-fail) in
        {611}let input_key_material_5: key = (if v_193 then catch-fail((if v_195 then dhexp(my_private_key_4,rs_7) else fail-any)) else caught-fail) in
        {612}let v_196: bool = not-caught-fail(input_key_material_5) in
        {613}let v_197: bitstring = (if v_196 then catch-fail(symmetricstateunpack(ss_32)) else caught-fail) in
        {614}let v_198: bool = (not-caught-fail(v_197) && success?(1-proj-3-tuple(v_197))) in
        {615}let h_28: bitstring = (if v_198 then 3-proj-3-tuple(v_197) else caught-fail) in
        {616}let ck_32: key = (if v_198 then 2-proj-3-tuple(v_197) else caught-fail) in
        {617}let cs_28: cipherstate = (if v_198 then 1-proj-3-tuple(v_197) else caught-fail) in
        {618}let output1_5: key = (if v_198 then hmac_hash1(ck_32,input_key_material_5) else caught-fail) in
        {619}let output2_5: key = (if v_198 then hmac_hash2(ck_32,input_key_material_5) else caught-fail) in
        {620}let output3_5: key = (if v_198 then hmac_hash3(ck_32,input_key_material_5) else caught-fail) in
        {621}let v_199: bitstring = (if v_198 then catch-fail((output1_5,output2_5,output3_5)) else caught-fail) in
        {622}let v_200: bool = (not-caught-fail(v_199) && success?(1-proj-3-tuple(v_199))) in
        {623}let output_4: key = (if v_200 then 3-proj-3-tuple(v_199) else caught-fail) in
        {624}let temp_k_4: key = (if v_200 then 2-proj-3-tuple(v_199) else caught-fail) in
        {625}let ck_33: key = (if v_200 then 1-proj-3-tuple(v_199) else caught-fail) in
        {626}let ss_33: symmetricstate = (if v_193 then catch-fail((if v_196 then (if v_198 then (if v_200 then symmetricstatepack(cipherstatepack(temp_k_4,minnonce),ck_33,h_28) else fail-any) else fail-any) else fail-any)) else caught-fail) in
        {627}let v_201: bool = not-caught-fail(ss_33) in
        {628}let v_202: bitstring = (if v_201 then catch-fail(keypairunpack(e_13)) else caught-fail) in
        {629}let v_203: bool = (not-caught-fail(v_202) && success?(1-proj-2-tuple(v_202))) in
        {630}let my_private_key_5: key = (if v_203 then 2-proj-2-tuple(v_202) else caught-fail) in
        {631}let my_public_key_5: key = (if v_203 then 1-proj-2-tuple(v_202) else caught-fail) in
        {632}let input_key_material_6: key = (if v_201 then catch-fail((if v_203 then dhexp(my_private_key_5,rm_7) else fail-any)) else caught-fail) in
        {633}let v_204: bool = not-caught-fail(input_key_material_6) in
        {634}let v_205: bitstring = (if v_204 then catch-fail(symmetricstateunpack(ss_33)) else caught-fail) in
        {635}let v_206: bool = (not-caught-fail(v_205) && success?(1-proj-3-tuple(v_205))) in
        {636}let h_29: bitstring = (if v_206 then 3-proj-3-tuple(v_205) else caught-fail) in
        {637}let ck_34: key = (if v_206 then 2-proj-3-tuple(v_205) else caught-fail) in
        {638}let cs_29: cipherstate = (if v_206 then 1-proj-3-tuple(v_205) else caught-fail) in
        {639}let output1_6: key = (if v_206 then hmac_hash1(ck_34,input_key_material_6) else caught-fail) in
        {640}let output2_6: key = (if v_206 then hmac_hash2(ck_34,input_key_material_6) else caught-fail) in
        {641}let output3_6: key = (if v_206 then hmac_hash3(ck_34,input_key_material_6) else caught-fail) in
        {642}let v_207: bitstring = (if v_206 then catch-fail((output1_6,output2_6,output3_6)) else caught-fail) in
        {643}let v_208: bool = (not-caught-fail(v_207) && success?(1-proj-3-tuple(v_207))) in
        {644}let output_5: key = (if v_208 then 3-proj-3-tuple(v_207) else caught-fail) in
        {645}let temp_k_5: key = (if v_208 then 2-proj-3-tuple(v_207) else caught-fail) in
        {646}let ck_35: key = (if v_208 then 1-proj-3-tuple(v_207) else caught-fail) in
        {647}let ss_34: symmetricstate = (if v_201 then catch-fail((if v_204 then (if v_206 then (if v_208 then symmetricstatepack(cipherstatepack(temp_k_5,minnonce),ck_35,h_29) else fail-any) else fail-any) else fail-any)) else caught-fail) in
        {648}let v_209: bool = not-caught-fail(ss_34) in
        {649}let v_210: bitstring = (if v_209 then catch-fail(symmetricstateunpack(ss_34)) else caught-fail) in
        {650}let v_211: bool = (not-caught-fail(v_210) && success?(1-proj-3-tuple(v_210))) in
        {651}let h_30: bitstring = (if v_211 then 3-proj-3-tuple(v_210) else caught-fail) in
        {652}let ck_36: key = (if v_211 then 2-proj-3-tuple(v_210) else caught-fail) in
        {653}let cs_30: cipherstate = (if v_211 then 1-proj-3-tuple(v_210) else caught-fail) in
        {654}let v_212: bitstring = (if v_211 then catch-fail(cipherstateunpack(cs_30)) else caught-fail) in
        {655}let v_213: bool = (not-caught-fail(v_212) && success?(1-proj-2-tuple(v_212))) in
        {656}let n_12: nonce = (if v_213 then 2-proj-2-tuple(v_212) else caught-fail) in
        {657}let k_14: key = (if v_213 then 1-proj-2-tuple(v_212) else caught-fail) in
        {658}let e_14: bitstring = (if v_213 then encrypt(k_14,n_12,h_30,payload_3) else caught-fail) in
        {659}let n_13: nonce = (if v_213 then increment_nonce(n_12) else caught-fail) in
        {660}let v_214: bitstring = (if v_213 then catch-fail(cipherstateunpack(cs_30)) else caught-fail) in
        {661}let v_215: bool = (not-caught-fail(v_214) && success?(1-proj-2-tuple(v_214))) in
        {662}let o_6: nonce = (if v_215 then 2-proj-2-tuple(v_214) else caught-fail) in
        {663}let k_15: key = (if v_215 then 1-proj-2-tuple(v_214) else caught-fail) in
        {664}let csi_12: cipherstate = (if v_213 then catch-fail((if v_215 then cipherstatepack(k_15,n_13) else fail-any)) else caught-fail) in
        {665}let v_216: bool = not-caught-fail(csi_12) in
        {666}let v_217: bitstring = (if v_211 then catch-fail((if v_213 then (if v_216 then (csi_12,e_14) else fail-any) else fail-any)) else caught-fail) in
        {667}let v_218: bool = (not-caught-fail(v_217) && success?(1-proj-2-tuple(v_217))) in
        {668}let ciphertext_13: bitstring = (if v_218 then 2-proj-2-tuple(v_217) else caught-fail) in
        {669}let csi_13: cipherstate = (if v_218 then 1-proj-2-tuple(v_217) else caught-fail) in
        {670}let ss_35: symmetricstate = (if v_218 then symmetricstatepack(csi_13,ck_36,h_30) else caught-fail) in
        {671}let v_219: bitstring = (if v_218 then catch-fail(symmetricstateunpack(ss_35)) else caught-fail) in
        {672}let v_220: bool = (not-caught-fail(v_219) && success?(1-proj-3-tuple(v_219))) in
        {673}let h_31: bitstring = (if v_220 then 3-proj-3-tuple(v_219) else caught-fail) in
        {674}let ck_37: key = (if v_220 then 2-proj-3-tuple(v_219) else caught-fail) in
        {675}let cs_31: cipherstate = (if v_220 then 1-proj-3-tuple(v_219) else caught-fail) in
        {676}let ssi_7: symmetricstate = (if v_218 then catch-fail((if v_220 then symmetricstatepack(cs_31,ck_37,hash(h_31,ciphertext_13)) else fail-any)) else caught-fail) in
        {677}let v_221: bool = not-caught-fail(ssi_7) in
        {678}let v_222: bitstring = (if v_209 then catch-fail((if v_211 then (if v_218 then (if v_221 then (ssi_7,ciphertext_13) else fail-any) else fail-any) else fail-any)) else caught-fail) in
        {679}let v_223: bool = (not-caught-fail(v_222) && success?(1-proj-2-tuple(v_222))) in
        {680}let ciphertext_14: bitstring = (if v_223 then 2-proj-2-tuple(v_222) else caught-fail) in
        {681}let ss_36: symmetricstate = (if v_223 then 1-proj-2-tuple(v_222) else caught-fail) in
        {682}let hs_20: handshakestate = (if v_223 then handshakestatepack(ss_36,s_7,m_8,e_13,rs_7,rm_7,re_8,psk_7,initiator_6) else caught-fail) in
        {683}let message_buffer_3: bitstring = (if v_223 then concat3(ne_6,ns_5,ciphertext_14) else caught-fail) in
        {684}let (hs_21: handshakestate,message_a_1: bitstring) = (if v_185 then (if v_187 then (if v_189 then (if v_190 then (if v_193 then (if v_201 then (if v_209 then (if v_223 then (hs_20,message_buffer_3) else fail-any) else fail-any) else fail-any) else fail-any) else fail-any) else fail-any) else fail-any) else fail-any) in
        {685}event SendMsg(me_1,them_1,stagepack_a(sid_2),msg_a(me_1,them_1,sid_2));
        {686}insert statestore(me_1,them_1,sid_2,statepack_b(hs_21));
        {687}out(pub, message_a_1)
    ) | (
        {782}get statestore(=me_1,=them_1,=sid_2,statepack_b(hs_22: handshakestate)) in
        {689}in(pub, message_b_1: bitstring);
        {690}let v_224: bitstring = catch-fail(handshakestateunpack(hs_22)) in
        {691}let v_225: bool = (not-caught-fail(v_224) && success?(1-proj-9-tuple(v_224))) in
        {692}let initiator_7: bool = (if v_225 then 9-proj-9-tuple(v_224) else caught-fail) in
        {693}let psk_8: key = (if v_225 then 8-proj-9-tuple(v_224) else caught-fail) in
        {694}let re_9: key = (if v_225 then 7-proj-9-tuple(v_224) else caught-fail) in
        {695}let rm_8: key = (if v_225 then 6-proj-9-tuple(v_224) else caught-fail) in
        {696}let rs_8: key = (if v_225 then 5-proj-9-tuple(v_224) else caught-fail) in
        {697}let e_15: keypair = (if v_225 then 4-proj-9-tuple(v_224) else caught-fail) in
        {698}let m_9: keypair = (if v_225 then 3-proj-9-tuple(v_224) else caught-fail) in
        {699}let s_8: keypair = (if v_225 then 2-proj-9-tuple(v_224) else caught-fail) in
        {700}let ss_37: symmetricstate = (if v_225 then 1-proj-9-tuple(v_224) else caught-fail) in
        {701}let v_226: bitstring = (if v_225 then catch-fail(deconcat3(message_b_1)) else caught-fail) in
        {702}let v_227: bool = (not-caught-fail(v_226) && success?(1-proj-3-tuple(v_226))) in
        {703}let ciphertext_15: bitstring = (if v_227 then 3-proj-3-tuple(v_226) else caught-fail) in
        {704}let ns_6: bitstring = (if v_227 then 2-proj-3-tuple(v_226) else caught-fail) in
        {705}let ne_7: bitstring = (if v_227 then 1-proj-3-tuple(v_226) else caught-fail) in
        {706}let valid1_2: bool = (if v_227 then true else caught-fail) in
        {707}let re_10: key = (if v_227 then ne_7 else caught-fail) in
        {708}let v_228: bitstring = (if v_227 then catch-fail(symmetricstateunpack(ss_37)) else caught-fail) in
        {709}let v_229: bool = (not-caught-fail(v_228) && success?(1-proj-3-tuple(v_228))) in
        {710}let h_32: bitstring = (if v_229 then 3-proj-3-tuple(v_228) else caught-fail) in
        {711}let ck_38: key = (if v_229 then 2-proj-3-tuple(v_228) else caught-fail) in
        {712}let cs_32: cipherstate = (if v_229 then 1-proj-3-tuple(v_228) else caught-fail) in
        {713}let ss_38: symmetricstate = (if v_227 then catch-fail((if v_229 then symmetricstatepack(cs_32,ck_38,hash(h_32,re_10)) else fail-any)) else caught-fail) in
        {714}let v_230: bool = not-caught-fail(ss_38) in
        {715}let v_231: bitstring = (if v_230 then catch-fail(keypairunpack(e_15)) else caught-fail) in
        {716}let v_232: bool = (not-caught-fail(v_231) && success?(1-proj-2-tuple(v_231))) in
        {717}let my_private_key_6: key = (if v_232 then 2-proj-2-tuple(v_231) else caught-fail) in
        {718}let my_public_key_6: key = (if v_232 then 1-proj-2-tuple(v_231) else caught-fail) in
        {719}let input_key_material_7: key = (if v_230 then catch-fail((if v_232 then dhexp(my_private_key_6,re_10) else fail-any)) else caught-fail) in
        {720}let v_233: bool = not-caught-fail(input_key_material_7) in
        {721}let v_234: bitstring = (if v_233 then catch-fail(symmetricstateunpack(ss_38)) else caught-fail) in
        {722}let v_235: bool = (not-caught-fail(v_234) && success?(1-proj-3-tuple(v_234))) in
        {723}let h_33: bitstring = (if v_235 then 3-proj-3-tuple(v_234) else caught-fail) in
        {724}let ck_39: key = (if v_235 then 2-proj-3-tuple(v_234) else caught-fail) in
        {725}let cs_33: cipherstate = (if v_235 then 1-proj-3-tuple(v_234) else caught-fail) in
        {726}let output1_7: key = (if v_235 then hmac_hash1(ck_39,input_key_material_7) else caught-fail) in
        {727}let output2_7: key = (if v_235 then hmac_hash2(ck_39,input_key_material_7) else caught-fail) in
        {728}let output3_7: key = (if v_235 then hmac_hash3(ck_39,input_key_material_7) else caught-fail) in
        {729}let v_236: bitstring = (if v_235 then catch-fail((output1_7,output2_7,output3_7)) else caught-fail) in
        {730}let v_237: bool = (not-caught-fail(v_236) && success?(1-proj-3-tuple(v_236))) in
        {731}let output_6: key = (if v_237 then 3-proj-3-tuple(v_236) else caught-fail) in
        {732}let temp_k_6: key = (if v_237 then 2-proj-3-tuple(v_236) else caught-fail) in
        {733}let ck_40: key = (if v_237 then 1-proj-3-tuple(v_236) else caught-fail) in
        {734}let ss_39: symmetricstate = (if v_230 then catch-fail((if v_233 then (if v_235 then (if v_237 then symmetricstatepack(cipherstatepack(temp_k_6,minnonce),ck_40,h_33) else fail-any) else fail-any) else fail-any)) else caught-fail) in
        {735}let v_238: bool = not-caught-fail(ss_39) in
        {736}let v_239: bitstring = (if v_238 then catch-fail(symmetricstateunpack(ss_39)) else caught-fail) in
        {737}let v_240: bool = (not-caught-fail(v_239) && success?(1-proj-3-tuple(v_239))) in
        {738}let h_34: bitstring = (if v_240 then 3-proj-3-tuple(v_239) else caught-fail) in
        {739}let ck_41: key = (if v_240 then 2-proj-3-tuple(v_239) else caught-fail) in
        {740}let cs_34: cipherstate = (if v_240 then 1-proj-3-tuple(v_239) else caught-fail) in
        {741}let v_241: bitstring = (if v_240 then catch-fail(cipherstateunpack(cs_34)) else caught-fail) in
        {742}let v_242: bool = (not-caught-fail(v_241) && success?(1-proj-2-tuple(v_241))) in
        {743}let n_14: nonce = (if v_242 then 2-proj-2-tuple(v_241) else caught-fail) in
        {744}let k_16: key = (if v_242 then 1-proj-2-tuple(v_241) else caught-fail) in
        {745}let d_2: aead = (if v_242 then catch-fail(decrypt(k_16,n_14,h_34,ciphertext_15)) else caught-fail) in
        {746}let v_243: bool = not-caught-fail(d_2) in
        {747}let v_244: bitstring = (if v_243 then catch-fail(aeadunpack(d_2)) else caught-fail) in
        {748}let v_245: bool = (not-caught-fail(v_244) && success?(1-proj-3-tuple(v_244))) in
        {749}let plaintext_7: bitstring = (if v_245 then 3-proj-3-tuple(v_244) else caught-fail) in
        {750}let adi_2: bitstring = (if v_245 then 2-proj-3-tuple(v_244) else caught-fail) in
        {751}let valid_6: bool = (if v_245 then 1-proj-3-tuple(v_244) else caught-fail) in
        {752}let n_15: nonce = (if v_245 then increment_nonce(n_14) else caught-fail) in
        {753}let v_246: bitstring = (if v_245 then catch-fail(cipherstateunpack(cs_34)) else caught-fail) in
        {754}let v_247: bool = (not-caught-fail(v_246) && success?(1-proj-2-tuple(v_246))) in
        {755}let o_7: nonce = (if v_247 then 2-proj-2-tuple(v_246) else caught-fail) in
        {756}let k_17: key = (if v_247 then 1-proj-2-tuple(v_246) else caught-fail) in
        {757}let csi_14: cipherstate = (if v_245 then catch-fail((if v_247 then cipherstatepack(k_17,n_15) else fail-any)) else caught-fail) in
        {758}let v_248: bool = not-caught-fail(csi_14) in
        {759}let v_249: bitstring = (if v_240 then catch-fail((if v_242 then (if v_243 then (if v_245 then (if v_248 then (csi_14,plaintext_7,valid_6) else fail-any) else fail-any) else fail-any) else fail-any)) else caught-fail) in
        {760}let v_250: bool = (not-caught-fail(v_249) && success?(1-proj-3-tuple(v_249))) in
        {761}let valid_7: bool = (if v_250 then 3-proj-3-tuple(v_249) else caught-fail) in
        {762}let plaintext_8: bitstring = (if v_250 then 2-proj-3-tuple(v_249) else caught-fail) in
        {763}let csi_15: cipherstate = (if v_250 then 1-proj-3-tuple(v_249) else caught-fail) in
        {764}let ss_40: symmetricstate = (if v_250 then symmetricstatepack(csi_15,ck_41,h_34) else caught-fail) in
        {765}let v_251: bitstring = (if v_250 then catch-fail(symmetricstateunpack(ss_40)) else caught-fail) in
        {766}let v_252: bool = (not-caught-fail(v_251) && success?(1-proj-3-tuple(v_251))) in
        {767}let h_35: bitstring = (if v_252 then 3-proj-3-tuple(v_251) else caught-fail) in
        {768}let ck_42: key = (if v_252 then 2-proj-3-tuple(v_251) else caught-fail) in
        {769}let cs_35: cipherstate = (if v_252 then 1-proj-3-tuple(v_251) else caught-fail) in
        {770}let ssi_8: symmetricstate = (if v_250 then catch-fail((if v_252 then symmetricstatepack(cs_35,ck_42,hash(h_35,ciphertext_15)) else fail-any)) else caught-fail) in
        {771}let v_253: bool = not-caught-fail(ssi_8) in
        {772}let v_254: bitstring = (if v_238 then catch-fail((if v_240 then (if v_250 then (if v_253 then (ssi_8,plaintext_8,valid_7) else fail-any) else fail-any) else fail-any)) else caught-fail) in
        {773}let v_255: bool = (not-caught-fail(v_254) && success?(1-proj-3-tuple(v_254))) in
        {774}let valid2_2: bool = (if v_255 then 3-proj-3-tuple(v_254) else caught-fail) in
        {775}let plaintext_9: bitstring = (if v_255 then 2-proj-3-tuple(v_254) else caught-fail) in
        {776}let ss_41: symmetricstate = (if v_255 then 1-proj-3-tuple(v_254) else caught-fail) in
        {777}let v_256: bool = (if v_255 then catch-fail((valid1_2 && valid2_2)) else caught-fail) in
        {778}let hs_23: handshakestate = (if v_256 then handshakestatepack(ss_41,s_8,m_9,e_15,rs_8,rm_8,re_10,psk_8,initiator_7) else caught-fail) in
        {779}let (hs_24: handshakestate,plaintext_b_1: bitstring,valid_8: bool) = (if v_225 then (if v_227 then (if v_230 then (if v_238 then (if v_255 then (if undo-catch-fail(v_256) then (hs_23,plaintext_9,true) else fail-any) else fail-any) else fail-any) else fail-any) else fail-any) else fail-any) in
        {780}event RecvMsg(me_1,them_1,stagepack_b(sid_2),plaintext_b_1);
        {781}insert statestore(me_1,them_1,sid_2,statepack_c(hs_24))
    ) | (
        {921}get statestore(=me_1,=them_1,=sid_2,statepack_c(hs_25: handshakestate)) in
        {783}let payload_4: bitstring = msg_c(me_1,them_1,sid_2) in
        {784}let v_257: bitstring = catch-fail(handshakestateunpack(hs_25)) in
        {785}let v_258: bool = (not-caught-fail(v_257) && success?(1-proj-9-tuple(v_257))) in
        {786}let initiator_8: bool = (if v_258 then 9-proj-9-tuple(v_257) else caught-fail) in
        {787}let psk_9: key = (if v_258 then 8-proj-9-tuple(v_257) else caught-fail) in
        {788}let re_11: key = (if v_258 then 7-proj-9-tuple(v_257) else caught-fail) in
        {789}let rm_9: key = (if v_258 then 6-proj-9-tuple(v_257) else caught-fail) in
        {790}let rs_9: key = (if v_258 then 5-proj-9-tuple(v_257) else caught-fail) in
        {791}let e_16: keypair = (if v_258 then 4-proj-9-tuple(v_257) else caught-fail) in
        {792}let m_10: keypair = (if v_258 then 3-proj-9-tuple(v_257) else caught-fail) in
        {793}let s_9: keypair = (if v_258 then 2-proj-9-tuple(v_257) else caught-fail) in
        {794}let ss_42: symmetricstate = (if v_258 then 1-proj-9-tuple(v_257) else caught-fail) in
        {795}let v_259: bitstring = (if v_258 then catch-fail((empty,empty,empty)) else caught-fail) in
        {796}let v_260: bool = (not-caught-fail(v_259) && success?(1-proj-3-tuple(v_259))) in
        {797}let ciphertext_16: bitstring = (if v_260 then 3-proj-3-tuple(v_259) else caught-fail) in
        {798}let nm_2: bitstring = (if v_260 then 2-proj-3-tuple(v_259) else caught-fail) in
        {799}let ns_7: bitstring = (if v_260 then 1-proj-3-tuple(v_259) else caught-fail) in
        {800}let basis_7: key = (if v_260 then key_m(me_1) else caught-fail) in
        {801}let public_key_7: key = (if v_260 then catch-fail(dhexp(basis_7,validkey(g))) else caught-fail) in
        {802}let v_261: bool = not-caught-fail(public_key_7) in
        {803}let m_11: keypair = (if v_260 then catch-fail((if v_261 then keypairpack(validkey(public_key_7),basis_7) else fail-any)) else caught-fail) in
        {804}let v_262: bool = not-caught-fail(m_11) in
        {805}let plaintext_10: bitstring = (if v_262 then catch-fail(getpublickey(m_11)) else caught-fail) in
        {806}let v_263: bool = not-caught-fail(plaintext_10) in
        {807}let v_264: bitstring = (if v_263 then catch-fail(symmetricstateunpack(ss_42)) else caught-fail) in
        {808}let v_265: bool = (not-caught-fail(v_264) && success?(1-proj-3-tuple(v_264))) in
        {809}let h_36: bitstring = (if v_265 then 3-proj-3-tuple(v_264) else caught-fail) in
        {810}let ck_43: key = (if v_265 then 2-proj-3-tuple(v_264) else caught-fail) in
        {811}let cs_36: cipherstate = (if v_265 then 1-proj-3-tuple(v_264) else caught-fail) in
        {812}let v_266: bitstring = (if v_265 then catch-fail(cipherstateunpack(cs_36)) else caught-fail) in
        {813}let v_267: bool = (not-caught-fail(v_266) && success?(1-proj-2-tuple(v_266))) in
        {814}let n_16: nonce = (if v_267 then 2-proj-2-tuple(v_266) else caught-fail) in
        {815}let k_18: key = (if v_267 then 1-proj-2-tuple(v_266) else caught-fail) in
        {816}let e_17: bitstring = (if v_267 then encrypt(k_18,n_16,h_36,plaintext_10) else caught-fail) in
        {817}let n_17: nonce = (if v_267 then increment_nonce(n_16) else caught-fail) in
        {818}let v_268: bitstring = (if v_267 then catch-fail(cipherstateunpack(cs_36)) else caught-fail) in
        {819}let v_269: bool = (not-caught-fail(v_268) && success?(1-proj-2-tuple(v_268))) in
        {820}let o_8: nonce = (if v_269 then 2-proj-2-tuple(v_268) else caught-fail) in
        {821}let k_19: key = (if v_269 then 1-proj-2-tuple(v_268) else caught-fail) in
        {822}let csi_16: cipherstate = (if v_267 then catch-fail((if v_269 then cipherstatepack(k_19,n_17) else fail-any)) else caught-fail) in
        {823}let v_270: bool = not-caught-fail(csi_16) in
        {824}let v_271: bitstring = (if v_265 then catch-fail((if v_267 then (if v_270 then (csi_16,e_17) else fail-any) else fail-any)) else caught-fail) in
        {825}let v_272: bool = (not-caught-fail(v_271) && success?(1-proj-2-tuple(v_271))) in
        {826}let ciphertext_17: bitstring = (if v_272 then 2-proj-2-tuple(v_271) else caught-fail) in
        {827}let csi_17: cipherstate = (if v_272 then 1-proj-2-tuple(v_271) else caught-fail) in
        {828}let ss_43: symmetricstate = (if v_272 then symmetricstatepack(csi_17,ck_43,h_36) else caught-fail) in
        {829}let v_273: bitstring = (if v_272 then catch-fail(symmetricstateunpack(ss_43)) else caught-fail) in
        {830}let v_274: bool = (not-caught-fail(v_273) && success?(1-proj-3-tuple(v_273))) in
        {831}let h_37: bitstring = (if v_274 then 3-proj-3-tuple(v_273) else caught-fail) in
        {832}let ck_44: key = (if v_274 then 2-proj-3-tuple(v_273) else caught-fail) in
        {833}let cs_37: cipherstate = (if v_274 then 1-proj-3-tuple(v_273) else caught-fail) in
        {834}let ssi_9: symmetricstate = (if v_272 then catch-fail((if v_274 then symmetricstatepack(cs_37,ck_44,hash(h_37,ciphertext_17)) else fail-any)) else caught-fail) in
        {835}let v_275: bool = not-caught-fail(ssi_9) in
        {836}let v_276: bitstring = (if v_262 then catch-fail((if v_263 then (if v_265 then (if v_272 then (if v_275 then (ssi_9,ciphertext_17) else fail-any) else fail-any) else fail-any) else fail-any)) else caught-fail) in
        {837}let v_277: bool = (not-caught-fail(v_276) && success?(1-proj-2-tuple(v_276))) in
        {838}let nm_3: bitstring = (if v_277 then 2-proj-2-tuple(v_276) else caught-fail) in
        {839}let ss_44: symmetricstate = (if v_277 then 1-proj-2-tuple(v_276) else caught-fail) in
        {840}let v_278: bitstring = (if v_277 then catch-fail(keypairunpack(m_11)) else caught-fail) in
        {841}let v_279: bool = (not-caught-fail(v_278) && success?(1-proj-2-tuple(v_278))) in
        {842}let my_private_key_7: key = (if v_279 then 2-proj-2-tuple(v_278) else caught-fail) in
        {843}let my_public_key_7: key = (if v_279 then 1-proj-2-tuple(v_278) else caught-fail) in
        {844}let input_key_material_8: key = (if v_277 then catch-fail((if v_279 then dhexp(my_private_key_7,re_11) else fail-any)) else caught-fail) in
        {845}let v_280: bool = not-caught-fail(input_key_material_8) in
        {846}let v_281: bitstring = (if v_280 then catch-fail(symmetricstateunpack(ss_44)) else caught-fail) in
        {847}let v_282: bool = (not-caught-fail(v_281) && success?(1-proj-3-tuple(v_281))) in
        {848}let h_38: bitstring = (if v_282 then 3-proj-3-tuple(v_281) else caught-fail) in
        {849}let ck_45: key = (if v_282 then 2-proj-3-tuple(v_281) else caught-fail) in
        {850}let cs_38: cipherstate = (if v_282 then 1-proj-3-tuple(v_281) else caught-fail) in
        {851}let output1_8: key = (if v_282 then hmac_hash1(ck_45,input_key_material_8) else caught-fail) in
        {852}let output2_8: key = (if v_282 then hmac_hash2(ck_45,input_key_material_8) else caught-fail) in
        {853}let output3_8: key = (if v_282 then hmac_hash3(ck_45,input_key_material_8) else caught-fail) in
        {854}let v_283: bitstring = (if v_282 then catch-fail((output1_8,output2_8,output3_8)) else caught-fail) in
        {855}let v_284: bool = (not-caught-fail(v_283) && success?(1-proj-3-tuple(v_283))) in
        {856}let output_7: key = (if v_284 then 3-proj-3-tuple(v_283) else caught-fail) in
        {857}let temp_k_7: key = (if v_284 then 2-proj-3-tuple(v_283) else caught-fail) in
        {858}let ck_46: key = (if v_284 then 1-proj-3-tuple(v_283) else caught-fail) in
        {859}let ss_45: symmetricstate = (if v_277 then catch-fail((if v_280 then (if v_282 then (if v_284 then symmetricstatepack(cipherstatepack(temp_k_7,minnonce),ck_46,h_38) else fail-any) else fail-any) else fail-any)) else caught-fail) in
        {860}let v_285: bool = not-caught-fail(ss_45) in
        {861}let v_286: bitstring = (if v_285 then catch-fail(symmetricstateunpack(ss_45)) else caught-fail) in
        {862}let v_287: bool = (not-caught-fail(v_286) && success?(1-proj-3-tuple(v_286))) in
        {863}let h_39: bitstring = (if v_287 then 3-proj-3-tuple(v_286) else caught-fail) in
        {864}let ck_47: key = (if v_287 then 2-proj-3-tuple(v_286) else caught-fail) in
        {865}let cs_39: cipherstate = (if v_287 then 1-proj-3-tuple(v_286) else caught-fail) in
        {866}let v_288: bitstring = (if v_287 then catch-fail(cipherstateunpack(cs_39)) else caught-fail) in
        {867}let v_289: bool = (not-caught-fail(v_288) && success?(1-proj-2-tuple(v_288))) in
        {868}let n_18: nonce = (if v_289 then 2-proj-2-tuple(v_288) else caught-fail) in
        {869}let k_20: key = (if v_289 then 1-proj-2-tuple(v_288) else caught-fail) in
        {870}let e_18: bitstring = (if v_289 then encrypt(k_20,n_18,h_39,payload_4) else caught-fail) in
        {871}let n_19: nonce = (if v_289 then increment_nonce(n_18) else caught-fail) in
        {872}let v_290: bitstring = (if v_289 then catch-fail(cipherstateunpack(cs_39)) else caught-fail) in
        {873}let v_291: bool = (not-caught-fail(v_290) && success?(1-proj-2-tuple(v_290))) in
        {874}let o_9: nonce = (if v_291 then 2-proj-2-tuple(v_290) else caught-fail) in
        {875}let k_21: key = (if v_291 then 1-proj-2-tuple(v_290) else caught-fail) in
        {876}let csi_18: cipherstate = (if v_289 then catch-fail((if v_291 then cipherstatepack(k_21,n_19) else fail-any)) else caught-fail) in
        {877}let v_292: bool = not-caught-fail(csi_18) in
        {878}let v_293: bitstring = (if v_287 then catch-fail((if v_289 then (if v_292 then (csi_18,e_18) else fail-any) else fail-any)) else caught-fail) in
        {879}let v_294: bool = (not-caught-fail(v_293) && success?(1-proj-2-tuple(v_293))) in
        {880}let ciphertext_18: bitstring = (if v_294 then 2-proj-2-tuple(v_293) else caught-fail) in
        {881}let csi_19: cipherstate = (if v_294 then 1-proj-2-tuple(v_293) else caught-fail) in
        {882}let ss_46: symmetricstate = (if v_294 then symmetricstatepack(csi_19,ck_47,h_39) else caught-fail) in
        {883}let v_295: bitstring = (if v_294 then catch-fail(symmetricstateunpack(ss_46)) else caught-fail) in
        {884}let v_296: bool = (not-caught-fail(v_295) && success?(1-proj-3-tuple(v_295))) in
        {885}let h_40: bitstring = (if v_296 then 3-proj-3-tuple(v_295) else caught-fail) in
        {886}let ck_48: key = (if v_296 then 2-proj-3-tuple(v_295) else caught-fail) in
        {887}let cs_40: cipherstate = (if v_296 then 1-proj-3-tuple(v_295) else caught-fail) in
        {888}let ssi_10: symmetricstate = (if v_294 then catch-fail((if v_296 then symmetricstatepack(cs_40,ck_48,hash(h_40,ciphertext_18)) else fail-any)) else caught-fail) in
        {889}let v_297: bool = not-caught-fail(ssi_10) in
        {890}let v_298: bitstring = (if v_285 then catch-fail((if v_287 then (if v_294 then (if v_297 then (ssi_10,ciphertext_18) else fail-any) else fail-any) else fail-any)) else caught-fail) in
        {891}let v_299: bool = (not-caught-fail(v_298) && success?(1-proj-2-tuple(v_298))) in
        {892}let ciphertext_19: bitstring = (if v_299 then 2-proj-2-tuple(v_298) else caught-fail) in
        {893}let ss_47: symmetricstate = (if v_299 then 1-proj-2-tuple(v_298) else caught-fail) in
        {894}let hs_26: handshakestate = (if v_299 then handshakestatepack(ss_47,s_9,m_11,e_16,rs_9,rm_9,re_11,psk_9,initiator_8) else caught-fail) in
        {895}let message_buffer_4: bitstring = (if v_299 then concat3(ns_7,nm_3,ciphertext_19) else caught-fail) in
        {896}let v_300: bitstring = (if v_299 then catch-fail(symmetricstateunpack(ss_47)) else caught-fail) in
        {897}let v_301: bool = (not-caught-fail(v_300) && success?(1-proj-3-tuple(v_300))) in
        {898}let h_41: bitstring = (if v_301 then 3-proj-3-tuple(v_300) else caught-fail) in
        {899}let ck_49: key = (if v_301 then 2-proj-3-tuple(v_300) else caught-fail) in
        {900}let cs_41: cipherstate = (if v_301 then 1-proj-3-tuple(v_300) else caught-fail) in
        {901}let input_key_material_9: key = (if v_301 then zero else caught-fail) in
        {902}let output1_9: key = (if v_301 then hmac_hash1(ck_49,input_key_material_9) else caught-fail) in
        {903}let output2_9: key = (if v_301 then hmac_hash2(ck_49,input_key_material_9) else caught-fail) in
        {904}let output3_9: key = (if v_301 then hmac_hash3(ck_49,input_key_material_9) else caught-fail) in
        {905}let v_302: bitstring = (if v_301 then catch-fail((output1_9,output2_9,output3_9)) else caught-fail) in
        {906}let v_303: bool = (not-caught-fail(v_302) && success?(1-proj-3-tuple(v_302))) in
        {907}let temp_k3_1: key = (if v_303 then 3-proj-3-tuple(v_302) else caught-fail) in
        {908}let temp_k2_1: key = (if v_303 then 2-proj-3-tuple(v_302) else caught-fail) in
        {909}let temp_k1_1: key = (if v_303 then 1-proj-3-tuple(v_302) else caught-fail) in
        {910}let cs1_5: cipherstate = (if v_303 then cipherstatepack(temp_k1_1,minnonce) else caught-fail) in
        {911}let cs2_5: cipherstate = (if v_303 then cipherstatepack(temp_k2_1,minnonce) else caught-fail) in
        {912}let v_304: bitstring = (if v_299 then catch-fail((if v_301 then (if v_303 then (ss_47,cs1_5,cs2_5) else fail-any) else fail-any)) else caught-fail) in
        {913}let v_305: bool = (not-caught-fail(v_304) && success?(1-proj-3-tuple(v_304))) in
        {914}let cs2_6: cipherstate = (if v_305 then 3-proj-3-tuple(v_304) else caught-fail) in
        {915}let cs1_6: cipherstate = (if v_305 then 2-proj-3-tuple(v_304) else caught-fail) in
        {916}let ssi_11: symmetricstate = (if v_305 then 1-proj-3-tuple(v_304) else caught-fail) in
        {917}let (hs_27: handshakestate,message_c_1: bitstring,cs1_7: cipherstate,cs2_7: cipherstate) = (if v_258 then (if v_260 then (if v_262 then (if v_277 then (if v_285 then (if v_299 then (if v_305 then (hs_26,message_buffer_4,cs1_6,cs2_6) else fail-any) else fail-any) else fail-any) else fail-any) else fail-any) else fail-any) else fail-any) in
        {918}event SendMsg(me_1,them_1,stagepack_c(sid_2),msg_c(me_1,them_1,sid_2));
        {919}insert statestore(me_1,them_1,sid_2,statepack_d(hs_27,cs1_7,cs2_7));
        {920}out(pub, message_c_1)
    ) | (
        {922}!
        {988}get statestore(=me_1,=them_1,=sid_2,statepack_d(hs_28: handshakestate,cs1_8: cipherstate,cs2_8: cipherstate)) in
        {923}let hs_29: handshakestate = handshakestatesetcs(hs_28,cs2_8) in
        {924}in(pub, message_d_1: bitstring);
        {925}let v_306: bitstring = catch-fail(handshakestateunpack(hs_29)) in
        {926}let v_307: bool = (not-caught-fail(v_306) && success?(1-proj-9-tuple(v_306))) in
        {927}let initiator_9: bool = (if v_307 then 9-proj-9-tuple(v_306) else caught-fail) in
        {928}let psk_10: key = (if v_307 then 8-proj-9-tuple(v_306) else caught-fail) in
        {929}let re_12: key = (if v_307 then 7-proj-9-tuple(v_306) else caught-fail) in
        {930}let rm_10: key = (if v_307 then 6-proj-9-tuple(v_306) else caught-fail) in
        {931}let rs_10: key = (if v_307 then 5-proj-9-tuple(v_306) else caught-fail) in
        {932}let e_19: keypair = (if v_307 then 4-proj-9-tuple(v_306) else caught-fail) in
        {933}let m_12: keypair = (if v_307 then 3-proj-9-tuple(v_306) else caught-fail) in
        {934}let s_10: keypair = (if v_307 then 2-proj-9-tuple(v_306) else caught-fail) in
        {935}let ss_48: symmetricstate = (if v_307 then 1-proj-9-tuple(v_306) else caught-fail) in
        {936}let v_308: bitstring = (if v_307 then catch-fail(deconcat3(message_d_1)) else caught-fail) in
        {937}let v_309: bool = (not-caught-fail(v_308) && success?(1-proj-3-tuple(v_308))) in
        {938}let ciphertext_20: bitstring = (if v_309 then 3-proj-3-tuple(v_308) else caught-fail) in
        {939}let ns_8: bitstring = (if v_309 then 2-proj-3-tuple(v_308) else caught-fail) in
        {940}let ne_8: bitstring = (if v_309 then 1-proj-3-tuple(v_308) else caught-fail) in
        {941}let valid1_3: bool = (if v_309 then true else caught-fail) in
        {942}let v_310: bitstring = (if v_309 then catch-fail(symmetricstateunpack(ss_48)) else caught-fail) in
        {943}let v_311: bool = (not-caught-fail(v_310) && success?(1-proj-3-tuple(v_310))) in
        {944}let h_42: bitstring = (if v_311 then 3-proj-3-tuple(v_310) else caught-fail) in
        {945}let ck_50: key = (if v_311 then 2-proj-3-tuple(v_310) else caught-fail) in
        {946}let cs_42: cipherstate = (if v_311 then 1-proj-3-tuple(v_310) else caught-fail) in
        {947}let v_312: bitstring = (if v_311 then catch-fail(cipherstateunpack(cs_42)) else caught-fail) in
        {948}let v_313: bool = (not-caught-fail(v_312) && success?(1-proj-2-tuple(v_312))) in
        {949}let n_20: nonce = (if v_313 then 2-proj-2-tuple(v_312) else caught-fail) in
        {950}let k_22: key = (if v_313 then 1-proj-2-tuple(v_312) else caught-fail) in
        {951}let d_3: aead = (if v_313 then catch-fail(decrypt(k_22,n_20,h_42,ciphertext_20)) else caught-fail) in
        {952}let v_314: bool = not-caught-fail(d_3) in
        {953}let v_315: bitstring = (if v_314 then catch-fail(aeadunpack(d_3)) else caught-fail) in
        {954}let v_316: bool = (not-caught-fail(v_315) && success?(1-proj-3-tuple(v_315))) in
        {955}let plaintext_11: bitstring = (if v_316 then 3-proj-3-tuple(v_315) else caught-fail) in
        {956}let adi_3: bitstring = (if v_316 then 2-proj-3-tuple(v_315) else caught-fail) in
        {957}let valid_9: bool = (if v_316 then 1-proj-3-tuple(v_315) else caught-fail) in
        {958}let n_21: nonce = (if v_316 then increment_nonce(n_20) else caught-fail) in
        {959}let v_317: bitstring = (if v_316 then catch-fail(cipherstateunpack(cs_42)) else caught-fail) in
        {960}let v_318: bool = (not-caught-fail(v_317) && success?(1-proj-2-tuple(v_317))) in
        {961}let o_10: nonce = (if v_318 then 2-proj-2-tuple(v_317) else caught-fail) in
        {962}let k_23: key = (if v_318 then 1-proj-2-tuple(v_317) else caught-fail) in
        {963}let csi_20: cipherstate = (if v_316 then catch-fail((if v_318 then cipherstatepack(k_23,n_21) else fail-any)) else caught-fail) in
        {964}let v_319: bool = not-caught-fail(csi_20) in
        {965}let v_320: bitstring = (if v_311 then catch-fail((if v_313 then (if v_314 then (if v_316 then (if v_319 then (csi_20,plaintext_11,valid_9) else fail-any) else fail-any) else fail-any) else fail-any)) else caught-fail) in
        {966}let v_321: bool = (not-caught-fail(v_320) && success?(1-proj-3-tuple(v_320))) in
        {967}let valid_10: bool = (if v_321 then 3-proj-3-tuple(v_320) else caught-fail) in
        {968}let plaintext_12: bitstring = (if v_321 then 2-proj-3-tuple(v_320) else caught-fail) in
        {969}let csi_21: cipherstate = (if v_321 then 1-proj-3-tuple(v_320) else caught-fail) in
        {970}let ss_49: symmetricstate = (if v_321 then symmetricstatepack(csi_21,ck_50,h_42) else caught-fail) in
        {971}let v_322: bitstring = (if v_321 then catch-fail(symmetricstateunpack(ss_49)) else caught-fail) in
        {972}let v_323: bool = (not-caught-fail(v_322) && success?(1-proj-3-tuple(v_322))) in
        {973}let h_43: bitstring = (if v_323 then 3-proj-3-tuple(v_322) else caught-fail) in
        {974}let ck_51: key = (if v_323 then 2-proj-3-tuple(v_322) else caught-fail) in
        {975}let cs_43: cipherstate = (if v_323 then 1-proj-3-tuple(v_322) else caught-fail) in
        {976}let ssi_12: symmetricstate = (if v_321 then catch-fail((if v_323 then symmetricstatepack(cs_43,ck_51,hash(h_43,ciphertext_20)) else fail-any)) else caught-fail) in
        {977}let v_324: bool = not-caught-fail(ssi_12) in
        {978}let v_325: bitstring = (if v_309 then catch-fail((if v_311 then (if v_321 then (if v_324 then (ssi_12,plaintext_12,valid_10) else fail-any) else fail-any) else fail-any)) else caught-fail) in
        {979}let v_326: bool = (not-caught-fail(v_325) && success?(1-proj-3-tuple(v_325))) in
        {980}let valid2_3: bool = (if v_326 then 3-proj-3-tuple(v_325) else caught-fail) in
        {981}let plaintext_13: bitstring = (if v_326 then 2-proj-3-tuple(v_325) else caught-fail) in
        {982}let ss_50: symmetricstate = (if v_326 then 1-proj-3-tuple(v_325) else caught-fail) in
        {983}let v_327: bool = (if v_326 then catch-fail((valid1_3 && valid2_3)) else caught-fail) in
        {984}let hs_30: handshakestate = (if v_327 then handshakestatepack(ss_50,s_10,m_12,e_19,rs_10,rm_10,re_12,psk_10,initiator_9) else caught-fail) in
        {985}let (hs_31: handshakestate,plaintext_d_1: bitstring,valid_11: bool) = (if v_307 then (if v_309 then (if v_326 then (if undo-catch-fail(v_327) then (hs_30,plaintext_13,true) else fail-any) else fail-any) else fail-any) else fail-any) in
        {986}event RecvMsg(me_1,them_1,stagepack_d(sid_2),plaintext_d_1);
        {987}insert statestore(me_1,them_1,sid_2,statepack_e(hs_31,cs1_8,handshakestategetcs(hs_31)))
    ) | (
        {989}!
        {1046}get statestore(=me_1,=them_1,=sid_2,statepack_e(hs_32: handshakestate,cs1_9: cipherstate,cs2_9: cipherstate)) in
        {990}let hs_33: handshakestate = handshakestatesetcs(hs_32,cs1_9) in
        {991}let payload_5: bitstring = msg_e(me_1,them_1,sid_2) in
        {992}let v_328: bitstring = catch-fail(handshakestateunpack(hs_33)) in
        {993}let v_329: bool = (not-caught-fail(v_328) && success?(1-proj-9-tuple(v_328))) in
        {994}let initiator_10: bool = (if v_329 then 9-proj-9-tuple(v_328) else caught-fail) in
        {995}let psk_11: key = (if v_329 then 8-proj-9-tuple(v_328) else caught-fail) in
        {996}let re_13: key = (if v_329 then 7-proj-9-tuple(v_328) else caught-fail) in
        {997}let rm_11: key = (if v_329 then 6-proj-9-tuple(v_328) else caught-fail) in
        {998}let rs_11: key = (if v_329 then 5-proj-9-tuple(v_328) else caught-fail) in
        {999}let e_20: keypair = (if v_329 then 4-proj-9-tuple(v_328) else caught-fail) in
        {1000}let m_13: keypair = (if v_329 then 3-proj-9-tuple(v_328) else caught-fail) in
        {1001}let s_11: keypair = (if v_329 then 2-proj-9-tuple(v_328) else caught-fail) in
        {1002}let ss_51: symmetricstate = (if v_329 then 1-proj-9-tuple(v_328) else caught-fail) in
        {1003}let v_330: bitstring = (if v_329 then catch-fail((empty,empty,empty)) else caught-fail) in
        {1004}let v_331: bool = (not-caught-fail(v_330) && success?(1-proj-3-tuple(v_330))) in
        {1005}let ciphertext_21: bitstring = (if v_331 then 3-proj-3-tuple(v_330) else caught-fail) in
        {1006}let ns_9: bitstring = (if v_331 then 2-proj-3-tuple(v_330) else caught-fail) in
        {1007}let ne_9: bitstring = (if v_331 then 1-proj-3-tuple(v_330) else caught-fail) in
        {1008}let v_332: bitstring = (if v_331 then catch-fail(symmetricstateunpack(ss_51)) else caught-fail) in
        {1009}let v_333: bool = (not-caught-fail(v_332) && success?(1-proj-3-tuple(v_332))) in
        {1010}let h_44: bitstring = (if v_333 then 3-proj-3-tuple(v_332) else caught-fail) in
        {1011}let ck_52: key = (if v_333 then 2-proj-3-tuple(v_332) else caught-fail) in
        {1012}let cs_44: cipherstate = (if v_333 then 1-proj-3-tuple(v_332) else caught-fail) in
        {1013}let v_334: bitstring = (if v_333 then catch-fail(cipherstateunpack(cs_44)) else caught-fail) in
        {1014}let v_335: bool = (not-caught-fail(v_334) && success?(1-proj-2-tuple(v_334))) in
        {1015}let n_22: nonce = (if v_335 then 2-proj-2-tuple(v_334) else caught-fail) in
        {1016}let k_24: key = (if v_335 then 1-proj-2-tuple(v_334) else caught-fail) in
        {1017}let e_21: bitstring = (if v_335 then encrypt(k_24,n_22,h_44,payload_5) else caught-fail) in
        {1018}let n_23: nonce = (if v_335 then increment_nonce(n_22) else caught-fail) in
        {1019}let v_336: bitstring = (if v_335 then catch-fail(cipherstateunpack(cs_44)) else caught-fail) in
        {1020}let v_337: bool = (not-caught-fail(v_336) && success?(1-proj-2-tuple(v_336))) in
        {1021}let o_11: nonce = (if v_337 then 2-proj-2-tuple(v_336) else caught-fail) in
        {1022}let k_25: key = (if v_337 then 1-proj-2-tuple(v_336) else caught-fail) in
        {1023}let csi_22: cipherstate = (if v_335 then catch-fail((if v_337 then cipherstatepack(k_25,n_23) else fail-any)) else caught-fail) in
        {1024}let v_338: bool = not-caught-fail(csi_22) in
        {1025}let v_339: bitstring = (if v_333 then catch-fail((if v_335 then (if v_338 then (csi_22,e_21) else fail-any) else fail-any)) else caught-fail) in
        {1026}let v_340: bool = (not-caught-fail(v_339) && success?(1-proj-2-tuple(v_339))) in
        {1027}let ciphertext_22: bitstring = (if v_340 then 2-proj-2-tuple(v_339) else caught-fail) in
        {1028}let csi_23: cipherstate = (if v_340 then 1-proj-2-tuple(v_339) else caught-fail) in
        {1029}let ss_52: symmetricstate = (if v_340 then symmetricstatepack(csi_23,ck_52,h_44) else caught-fail) in
        {1030}let v_341: bitstring = (if v_340 then catch-fail(symmetricstateunpack(ss_52)) else caught-fail) in
        {1031}let v_342: bool = (not-caught-fail(v_341) && success?(1-proj-3-tuple(v_341))) in
        {1032}let h_45: bitstring = (if v_342 then 3-proj-3-tuple(v_341) else caught-fail) in
        {1033}let ck_53: key = (if v_342 then 2-proj-3-tuple(v_341) else caught-fail) in
        {1034}let cs_45: cipherstate = (if v_342 then 1-proj-3-tuple(v_341) else caught-fail) in
        {1035}let ssi_13: symmetricstate = (if v_340 then catch-fail((if v_342 then symmetricstatepack(cs_45,ck_53,hash(h_45,ciphertext_22)) else fail-any)) else caught-fail) in
        {1036}let v_343: bool = not-caught-fail(ssi_13) in
        {1037}let v_344: bitstring = (if v_331 then catch-fail((if v_333 then (if v_340 then (if v_343 then (ssi_13,ciphertext_22) else fail-any) else fail-any) else fail-any)) else caught-fail) in
        {1038}let v_345: bool = (not-caught-fail(v_344) && success?(1-proj-2-tuple(v_344))) in
        {1039}let ciphertext_23: bitstring = (if v_345 then 2-proj-2-tuple(v_344) else caught-fail) in
        {1040}let ss_53: symmetricstate = (if v_345 then 1-proj-2-tuple(v_344) else caught-fail) in
        {1041}let hs_34: handshakestate = (if v_345 then handshakestatepack(ss_53,s_11,m_13,e_20,rs_11,rm_11,re_13,psk_11,initiator_10) else caught-fail) in
        {1042}let message_buffer_5: bitstring = (if v_345 then concat3(ne_9,ns_9,ciphertext_23) else caught-fail) in
        {1043}let (hs_35: handshakestate,message_e_1: bitstring) = (if v_329 then (if v_331 then (if v_345 then (hs_34,message_buffer_5) else fail-any) else fail-any) else fail-any) in
        {1044}event SendMsg(me_1,them_1,stagepack_e(sid_2),msg_e(me_1,them_1,sid_2));
        {1045}out(pub, message_e_1)
    ) | (
        {1047}event LeakS(phase0,me_1);
        {1048}event LeakM(phase0,me_1);
        {1049}out(pub, (key_s(me_1),key_m(me_1)))
    ) | (
        {1050}phase 1;
        {1051}event LeakS(phase1,me_1);
        {1052}event LeakM(phase1,me_1);
        {1053}out(pub, (key_s(me_1),key_m(me_1)))
    )
) | (
    {1054}let me_2: principal = bob in
    {1055}let them_2: principal = alice in
    {1056}let sid_3: sessionid = sid in
    {1057}let basis_8: key = key_s(me_2) in
    {1058}let public_key_8: key = catch-fail(dhexp(basis_8,validkey(g))) in
    {1059}let v_346: bool = not-caught-fail(public_key_8) in
    {1060}let s_12: keypair = (if v_346 then keypairpack(validkey(public_key_8),basis_8) else fail-any) in
    {1061}let basis_9: key = key_m(me_2) in
    {1062}let public_key_9: key = catch-fail(dhexp(basis_9,validkey(g))) in
    {1063}let v_347: bool = not-caught-fail(public_key_9) in
    {1064}let m_14: keypair = (if v_347 then keypairpack(validkey(public_key_9),basis_9) else fail-any) in
    {1065}out(pub, (getpublickey(s_12),getpublickey(m_14)));
    (
        {1066}let e_22: keypair = keypairpack(empty,empty) in
        {1067}let rs_12: key = empty in
        {1068}let rm_12: key = empty in
        {1069}let re_14: key = empty in
        {1070}let prologue_2: bitstring = empty in
        {1071}let psk_12: key = empty in
        {1072}let protocol_name_2: bitstring = somename in
        {1073}let h_46: bitstring = hash(protocol_name_2,empty) in
        {1074}let ck_54: key = h_46 in
        {1075}let k_26: key = empty in
        {1076}let cs_46: cipherstate = cipherstatepack(k_26,minnonce) in
        {1077}let ss_54: symmetricstate = symmetricstatepack(cs_46,ck_54,h_46) in
        {1078}let v_348: bitstring = catch-fail(symmetricstateunpack(ss_54)) in
        {1079}let v_349: bool = (not-caught-fail(v_348) && success?(1-proj-3-tuple(v_348))) in
        {1080}let h_47: bitstring = (if v_349 then 3-proj-3-tuple(v_348) else caught-fail) in
        {1081}let ck_55: key = (if v_349 then 2-proj-3-tuple(v_348) else caught-fail) in
        {1082}let cs_47: cipherstate = (if v_349 then 1-proj-3-tuple(v_348) else caught-fail) in
        {1083}let ss_55: symmetricstate = catch-fail((if v_349 then symmetricstatepack(cs_47,ck_55,hash(h_47,prologue_2)) else fail-any)) in
        {1084}let v_350: bool = not-caught-fail(ss_55) in
        {1085}let data: bitstring = (if v_350 then catch-fail(getpublickey(s_12)) else caught-fail) in
        {1086}let v_351: bool = not-caught-fail(data) in
        {1087}let v_352: bitstring = (if v_351 then catch-fail(symmetricstateunpack(ss_55)) else caught-fail) in
        {1088}let v_353: bool = (not-caught-fail(v_352) && success?(1-proj-3-tuple(v_352))) in
        {1089}let h_48: bitstring = (if v_353 then 3-proj-3-tuple(v_352) else caught-fail) in
        {1090}let ck_56: key = (if v_353 then 2-proj-3-tuple(v_352) else caught-fail) in
        {1091}let cs_48: cipherstate = (if v_353 then 1-proj-3-tuple(v_352) else caught-fail) in
        {1092}let ss_56: symmetricstate = (if v_350 then catch-fail((if v_351 then (if v_353 then symmetricstatepack(cs_48,ck_56,hash(h_48,data)) else fail-any) else fail-any)) else caught-fail) in
        {1093}let v_354: bool = not-caught-fail(ss_56) in
        {1094}let data_1: bitstring = (if v_354 then catch-fail(getpublickey(m_14)) else caught-fail) in
        {1095}let v_355: bool = not-caught-fail(data_1) in
        {1096}let v_356: bitstring = (if v_355 then catch-fail(symmetricstateunpack(ss_56)) else caught-fail) in
        {1097}let v_357: bool = (not-caught-fail(v_356) && success?(1-proj-3-tuple(v_356))) in
        {1098}let h_49: bitstring = (if v_357 then 3-proj-3-tuple(v_356) else caught-fail) in
        {1099}let ck_57: key = (if v_357 then 2-proj-3-tuple(v_356) else caught-fail) in
        {1100}let cs_49: cipherstate = (if v_357 then 1-proj-3-tuple(v_356) else caught-fail) in
        {1101}let ss_57: symmetricstate = (if v_354 then catch-fail((if v_355 then (if v_357 then symmetricstatepack(cs_49,ck_57,hash(h_49,data_1)) else fail-any) else fail-any)) else caught-fail) in
        {1102}let v_358: bool = not-caught-fail(ss_57) in
        {1103}let hs_36: handshakestate = (if v_350 then (if v_354 then (if v_358 then handshakestatepack(ss_57,s_12,m_14,e_22,rs_12,rm_12,re_14,psk_12,false) else fail-any) else fail-any) else fail-any) in
        {1104}insert statestore(me_2,them_2,sid_3,statepack_a(hs_36))
    ) | (
        {1219}get statestore(=me_2,=them_2,=sid_3,statepack_a(hs_37: handshakestate)) in
        {1105}in(pub, message_a_2: bitstring);
        {1106}let v_359: bitstring = catch-fail(handshakestateunpack(hs_37)) in
        {1107}let v_360: bool = (not-caught-fail(v_359) && success?(1-proj-9-tuple(v_359))) in
        {1108}let initiator_11: bool = (if v_360 then 9-proj-9-tuple(v_359) else caught-fail) in
        {1109}let psk_13: key = (if v_360 then 8-proj-9-tuple(v_359) else caught-fail) in
        {1110}let re_15: key = (if v_360 then 7-proj-9-tuple(v_359) else caught-fail) in
        {1111}let rm_13: key = (if v_360 then 6-proj-9-tuple(v_359) else caught-fail) in
        {1112}let rs_13: key = (if v_360 then 5-proj-9-tuple(v_359) else caught-fail) in
        {1113}let e_23: keypair = (if v_360 then 4-proj-9-tuple(v_359) else caught-fail) in
        {1114}let m_15: keypair = (if v_360 then 3-proj-9-tuple(v_359) else caught-fail) in
        {1115}let s_13: keypair = (if v_360 then 2-proj-9-tuple(v_359) else caught-fail) in
        {1116}let ss_58: symmetricstate = (if v_360 then 1-proj-9-tuple(v_359) else caught-fail) in
        {1117}let v_361: bitstring = (if v_360 then catch-fail(deconcat3(message_a_2)) else caught-fail) in
        {1118}let v_362: bool = (not-caught-fail(v_361) && success?(1-proj-3-tuple(v_361))) in
        {1119}let ciphertext_24: bitstring = (if v_362 then 3-proj-3-tuple(v_361) else caught-fail) in
        {1120}let ns_10: bitstring = (if v_362 then 2-proj-3-tuple(v_361) else caught-fail) in
        {1121}let ne_10: bitstring = (if v_362 then 1-proj-3-tuple(v_361) else caught-fail) in
        {1122}let valid1_4: bool = (if v_362 then true else caught-fail) in
        {1123}let re_16: key = (if v_362 then ne_10 else caught-fail) in
        {1124}let v_363: bitstring = (if v_362 then catch-fail(symmetricstateunpack(ss_58)) else caught-fail) in
        {1125}let v_364: bool = (not-caught-fail(v_363) && success?(1-proj-3-tuple(v_363))) in
        {1126}let h_50: bitstring = (if v_364 then 3-proj-3-tuple(v_363) else caught-fail) in
        {1127}let ck_58: key = (if v_364 then 2-proj-3-tuple(v_363) else caught-fail) in
        {1128}let cs_50: cipherstate = (if v_364 then 1-proj-3-tuple(v_363) else caught-fail) in
        {1129}let ss_59: symmetricstate = (if v_362 then catch-fail((if v_364 then symmetricstatepack(cs_50,ck_58,hash(h_50,re_16)) else fail-any)) else caught-fail) in
        {1130}let v_365: bool = not-caught-fail(ss_59) in
        {1131}let v_366: bitstring = (if v_365 then catch-fail(keypairunpack(s_13)) else caught-fail) in
        {1132}let v_367: bool = (not-caught-fail(v_366) && success?(1-proj-2-tuple(v_366))) in
        {1133}let my_private_key_8: key = (if v_367 then 2-proj-2-tuple(v_366) else caught-fail) in
        {1134}let my_public_key_8: key = (if v_367 then 1-proj-2-tuple(v_366) else caught-fail) in
        {1135}let input_key_material_10: key = (if v_365 then catch-fail((if v_367 then dhexp(my_private_key_8,re_16) else fail-any)) else caught-fail) in
        {1136}let v_368: bool = not-caught-fail(input_key_material_10) in
        {1137}let v_369: bitstring = (if v_368 then catch-fail(symmetricstateunpack(ss_59)) else caught-fail) in
        {1138}let v_370: bool = (not-caught-fail(v_369) && success?(1-proj-3-tuple(v_369))) in
        {1139}let h_51: bitstring = (if v_370 then 3-proj-3-tuple(v_369) else caught-fail) in
        {1140}let ck_59: key = (if v_370 then 2-proj-3-tuple(v_369) else caught-fail) in
        {1141}let cs_51: cipherstate = (if v_370 then 1-proj-3-tuple(v_369) else caught-fail) in
        {1142}let output1_10: key = (if v_370 then hmac_hash1(ck_59,input_key_material_10) else caught-fail) in
        {1143}let output2_10: key = (if v_370 then hmac_hash2(ck_59,input_key_material_10) else caught-fail) in
        {1144}let output3_10: key = (if v_370 then hmac_hash3(ck_59,input_key_material_10) else caught-fail) in
        {1145}let v_371: bitstring = (if v_370 then catch-fail((output1_10,output2_10,output3_10)) else caught-fail) in
        {1146}let v_372: bool = (not-caught-fail(v_371) && success?(1-proj-3-tuple(v_371))) in
        {1147}let output_8: key = (if v_372 then 3-proj-3-tuple(v_371) else caught-fail) in
        {1148}let temp_k_8: key = (if v_372 then 2-proj-3-tuple(v_371) else caught-fail) in
        {1149}let ck_60: key = (if v_372 then 1-proj-3-tuple(v_371) else caught-fail) in
        {1150}let ss_60: symmetricstate = (if v_365 then catch-fail((if v_368 then (if v_370 then (if v_372 then symmetricstatepack(cipherstatepack(temp_k_8,minnonce),ck_60,h_51) else fail-any) else fail-any) else fail-any)) else caught-fail) in
        {1151}let v_373: bool = not-caught-fail(ss_60) in
        {1152}let v_374: bitstring = (if v_373 then catch-fail(keypairunpack(m_15)) else caught-fail) in
        {1153}let v_375: bool = (not-caught-fail(v_374) && success?(1-proj-2-tuple(v_374))) in
        {1154}let my_private_key_9: key = (if v_375 then 2-proj-2-tuple(v_374) else caught-fail) in
        {1155}let my_public_key_9: key = (if v_375 then 1-proj-2-tuple(v_374) else caught-fail) in
        {1156}let input_key_material_11: key = (if v_373 then catch-fail((if v_375 then dhexp(my_private_key_9,re_16) else fail-any)) else caught-fail) in
        {1157}let v_376: bool = not-caught-fail(input_key_material_11) in
        {1158}let v_377: bitstring = (if v_376 then catch-fail(symmetricstateunpack(ss_60)) else caught-fail) in
        {1159}let v_378: bool = (not-caught-fail(v_377) && success?(1-proj-3-tuple(v_377))) in
        {1160}let h_52: bitstring = (if v_378 then 3-proj-3-tuple(v_377) else caught-fail) in
        {1161}let ck_61: key = (if v_378 then 2-proj-3-tuple(v_377) else caught-fail) in
        {1162}let cs_52: cipherstate = (if v_378 then 1-proj-3-tuple(v_377) else caught-fail) in
        {1163}let output1_11: key = (if v_378 then hmac_hash1(ck_61,input_key_material_11) else caught-fail) in
        {1164}let output2_11: key = (if v_378 then hmac_hash2(ck_61,input_key_material_11) else caught-fail) in
        {1165}let output3_11: key = (if v_378 then hmac_hash3(ck_61,input_key_material_11) else caught-fail) in
        {1166}let v_379: bitstring = (if v_378 then catch-fail((output1_11,output2_11,output3_11)) else caught-fail) in
        {1167}let v_380: bool = (not-caught-fail(v_379) && success?(1-proj-3-tuple(v_379))) in
        {1168}let output_9: key = (if v_380 then 3-proj-3-tuple(v_379) else caught-fail) in
        {1169}let temp_k_9: key = (if v_380 then 2-proj-3-tuple(v_379) else caught-fail) in
        {1170}let ck_62: key = (if v_380 then 1-proj-3-tuple(v_379) else caught-fail) in
        {1171}let ss_61: symmetricstate = (if v_373 then catch-fail((if v_376 then (if v_378 then (if v_380 then symmetricstatepack(cipherstatepack(temp_k_9,minnonce),ck_62,h_52) else fail-any) else fail-any) else fail-any)) else caught-fail) in
        {1172}let v_381: bool = not-caught-fail(ss_61) in
        {1173}let v_382: bitstring = (if v_381 then catch-fail(symmetricstateunpack(ss_61)) else caught-fail) in
        {1174}let v_383: bool = (not-caught-fail(v_382) && success?(1-proj-3-tuple(v_382))) in
        {1175}let h_53: bitstring = (if v_383 then 3-proj-3-tuple(v_382) else caught-fail) in
        {1176}let ck_63: key = (if v_383 then 2-proj-3-tuple(v_382) else caught-fail) in
        {1177}let cs_53: cipherstate = (if v_383 then 1-proj-3-tuple(v_382) else caught-fail) in
        {1178}let v_384: bitstring = (if v_383 then catch-fail(cipherstateunpack(cs_53)) else caught-fail) in
        {1179}let v_385: bool = (not-caught-fail(v_384) && success?(1-proj-2-tuple(v_384))) in
        {1180}let n_24: nonce = (if v_385 then 2-proj-2-tuple(v_384) else caught-fail) in
        {1181}let k_27: key = (if v_385 then 1-proj-2-tuple(v_384) else caught-fail) in
        {1182}let d_4: aead = (if v_385 then catch-fail(decrypt(k_27,n_24,h_53,ciphertext_24)) else caught-fail) in
        {1183}let v_386: bool = not-caught-fail(d_4) in
        {1184}let v_387: bitstring = (if v_386 then catch-fail(aeadunpack(d_4)) else caught-fail) in
        {1185}let v_388: bool = (not-caught-fail(v_387) && success?(1-proj-3-tuple(v_387))) in
        {1186}let plaintext_14: bitstring = (if v_388 then 3-proj-3-tuple(v_387) else caught-fail) in
        {1187}let adi_4: bitstring = (if v_388 then 2-proj-3-tuple(v_387) else caught-fail) in
        {1188}let valid_12: bool = (if v_388 then 1-proj-3-tuple(v_387) else caught-fail) in
        {1189}let n_25: nonce = (if v_388 then increment_nonce(n_24) else caught-fail) in
        {1190}let v_389: bitstring = (if v_388 then catch-fail(cipherstateunpack(cs_53)) else caught-fail) in
        {1191}let v_390: bool = (not-caught-fail(v_389) && success?(1-proj-2-tuple(v_389))) in
        {1192}let o_12: nonce = (if v_390 then 2-proj-2-tuple(v_389) else caught-fail) in
        {1193}let k_28: key = (if v_390 then 1-proj-2-tuple(v_389) else caught-fail) in
        {1194}let csi_24: cipherstate = (if v_388 then catch-fail((if v_390 then cipherstatepack(k_28,n_25) else fail-any)) else caught-fail) in
        {1195}let v_391: bool = not-caught-fail(csi_24) in
        {1196}let v_392: bitstring = (if v_383 then catch-fail((if v_385 then (if v_386 then (if v_388 then (if v_391 then (csi_24,plaintext_14,valid_12) else fail-any) else fail-any) else fail-any) else fail-any)) else caught-fail) in
        {1197}let v_393: bool = (not-caught-fail(v_392) && success?(1-proj-3-tuple(v_392))) in
        {1198}let valid_13: bool = (if v_393 then 3-proj-3-tuple(v_392) else caught-fail) in
        {1199}let plaintext_15: bitstring = (if v_393 then 2-proj-3-tuple(v_392) else caught-fail) in
        {1200}let csi_25: cipherstate = (if v_393 then 1-proj-3-tuple(v_392) else caught-fail) in
        {1201}let ss_62: symmetricstate = (if v_393 then symmetricstatepack(csi_25,ck_63,h_53) else caught-fail) in
        {1202}let v_394: bitstring = (if v_393 then catch-fail(symmetricstateunpack(ss_62)) else caught-fail) in
        {1203}let v_395: bool = (not-caught-fail(v_394) && success?(1-proj-3-tuple(v_394))) in
        {1204}let h_54: bitstring = (if v_395 then 3-proj-3-tuple(v_394) else caught-fail) in
        {1205}let ck_64: key = (if v_395 then 2-proj-3-tuple(v_394) else caught-fail) in
        {1206}let cs_54: cipherstate = (if v_395 then 1-proj-3-tuple(v_394) else caught-fail) in
        {1207}let ssi_14: symmetricstate = (if v_393 then catch-fail((if v_395 then symmetricstatepack(cs_54,ck_64,hash(h_54,ciphertext_24)) else fail-any)) else caught-fail) in
        {1208}let v_396: bool = not-caught-fail(ssi_14) in
        {1209}let v_397: bitstring = (if v_381 then catch-fail((if v_383 then (if v_393 then (if v_396 then (ssi_14,plaintext_15,valid_13) else fail-any) else fail-any) else fail-any)) else caught-fail) in
        {1210}let v_398: bool = (not-caught-fail(v_397) && success?(1-proj-3-tuple(v_397))) in
        {1211}let valid2_4: bool = (if v_398 then 3-proj-3-tuple(v_397) else caught-fail) in
        {1212}let plaintext_16: bitstring = (if v_398 then 2-proj-3-tuple(v_397) else caught-fail) in
        {1213}let ss_63: symmetricstate = (if v_398 then 1-proj-3-tuple(v_397) else caught-fail) in
        {1214}let v_399: bool = (if v_398 then catch-fail((valid1_4 && valid2_4)) else caught-fail) in
        {1215}let hs_38: handshakestate = (if v_399 then handshakestatepack(ss_63,s_13,m_15,e_23,rs_13,rm_13,re_16,psk_13,initiator_11) else caught-fail) in
        {1216}let (hs_39: handshakestate,plaintext_a: bitstring,valid_14: bool) = (if v_360 then (if v_362 then (if v_365 then (if v_373 then (if v_381 then (if v_398 then (if undo-catch-fail(v_399) then (hs_38,plaintext_16,true) else fail-any) else fail-any) else fail-any) else fail-any) else fail-any) else fail-any) else fail-any) in
        {1217}event RecvMsg(me_2,them_2,stagepack_a(sid_3),plaintext_a);
        {1218}insert statestore(me_2,them_2,sid_3,statepack_b(hs_39))
    ) | (
        {1311}get statestore(=me_2,=them_2,=sid_3,statepack_b(hs_40: handshakestate)) in
        {1220}let payload_6: bitstring = msg_b(me_2,them_2,sid_3) in
        {1221}let v_400: bitstring = catch-fail(handshakestateunpack(hs_40)) in
        {1222}let v_401: bool = (not-caught-fail(v_400) && success?(1-proj-9-tuple(v_400))) in
        {1223}let initiator_12: bool = (if v_401 then 9-proj-9-tuple(v_400) else caught-fail) in
        {1224}let psk_14: key = (if v_401 then 8-proj-9-tuple(v_400) else caught-fail) in
        {1225}let re_17: key = (if v_401 then 7-proj-9-tuple(v_400) else caught-fail) in
        {1226}let rm_14: key = (if v_401 then 6-proj-9-tuple(v_400) else caught-fail) in
        {1227}let rs_14: key = (if v_401 then 5-proj-9-tuple(v_400) else caught-fail) in
        {1228}let e_24: keypair = (if v_401 then 4-proj-9-tuple(v_400) else caught-fail) in
        {1229}let m_16: keypair = (if v_401 then 3-proj-9-tuple(v_400) else caught-fail) in
        {1230}let s_14: keypair = (if v_401 then 2-proj-9-tuple(v_400) else caught-fail) in
        {1231}let ss_64: symmetricstate = (if v_401 then 1-proj-9-tuple(v_400) else caught-fail) in
        {1232}let v_402: bitstring = (if v_401 then catch-fail((empty,empty,empty)) else caught-fail) in
        {1233}let v_403: bool = (not-caught-fail(v_402) && success?(1-proj-3-tuple(v_402))) in
        {1234}let ciphertext_25: bitstring = (if v_403 then 3-proj-3-tuple(v_402) else caught-fail) in
        {1235}let ns_11: bitstring = (if v_403 then 2-proj-3-tuple(v_402) else caught-fail) in
        {1236}let ne_11: bitstring = (if v_403 then 1-proj-3-tuple(v_402) else caught-fail) in
        {1237}let basis_10: key = (if v_403 then key_e(me_2,them_2,sid_3) else caught-fail) in
        {1238}let public_key_10: key = (if v_403 then catch-fail(dhexp(basis_10,validkey(g))) else caught-fail) in
        {1239}let v_404: bool = not-caught-fail(public_key_10) in
        {1240}let e_25: keypair = (if v_403 then catch-fail((if v_404 then keypairpack(validkey(public_key_10),basis_10) else fail-any)) else caught-fail) in
        {1241}let v_405: bool = not-caught-fail(e_25) in
        {1242}let ne_12: bitstring = (if v_405 then catch-fail(getpublickey(e_25)) else caught-fail) in
        {1243}let v_406: bool = not-caught-fail(ne_12) in
        {1244}let v_407: bitstring = (if v_406 then catch-fail(symmetricstateunpack(ss_64)) else caught-fail) in
        {1245}let v_408: bool = (not-caught-fail(v_407) && success?(1-proj-3-tuple(v_407))) in
        {1246}let h_55: bitstring = (if v_408 then 3-proj-3-tuple(v_407) else caught-fail) in
        {1247}let ck_65: key = (if v_408 then 2-proj-3-tuple(v_407) else caught-fail) in
        {1248}let cs_55: cipherstate = (if v_408 then 1-proj-3-tuple(v_407) else caught-fail) in
        {1249}let ss_65: symmetricstate = (if v_406 then catch-fail((if v_408 then symmetricstatepack(cs_55,ck_65,hash(h_55,ne_12)) else fail-any)) else caught-fail) in
        {1250}let v_409: bool = not-caught-fail(ss_65) in
        {1251}let v_410: bitstring = (if v_409 then catch-fail(keypairunpack(e_25)) else caught-fail) in
        {1252}let v_411: bool = (not-caught-fail(v_410) && success?(1-proj-2-tuple(v_410))) in
        {1253}let my_private_key_10: key = (if v_411 then 2-proj-2-tuple(v_410) else caught-fail) in
        {1254}let my_public_key_10: key = (if v_411 then 1-proj-2-tuple(v_410) else caught-fail) in
        {1255}let input_key_material_12: key = (if v_409 then catch-fail((if v_411 then dhexp(my_private_key_10,re_17) else fail-any)) else caught-fail) in
        {1256}let v_412: bool = not-caught-fail(input_key_material_12) in
        {1257}let v_413: bitstring = (if v_412 then catch-fail(symmetricstateunpack(ss_65)) else caught-fail) in
        {1258}let v_414: bool = (not-caught-fail(v_413) && success?(1-proj-3-tuple(v_413))) in
        {1259}let h_56: bitstring = (if v_414 then 3-proj-3-tuple(v_413) else caught-fail) in
        {1260}let ck_66: key = (if v_414 then 2-proj-3-tuple(v_413) else caught-fail) in
        {1261}let cs_56: cipherstate = (if v_414 then 1-proj-3-tuple(v_413) else caught-fail) in
        {1262}let output1_12: key = (if v_414 then hmac_hash1(ck_66,input_key_material_12) else caught-fail) in
        {1263}let output2_12: key = (if v_414 then hmac_hash2(ck_66,input_key_material_12) else caught-fail) in
        {1264}let output3_12: key = (if v_414 then hmac_hash3(ck_66,input_key_material_12) else caught-fail) in
        {1265}let v_415: bitstring = (if v_414 then catch-fail((output1_12,output2_12,output3_12)) else caught-fail) in
        {1266}let v_416: bool = (not-caught-fail(v_415) && success?(1-proj-3-tuple(v_415))) in
        {1267}let output_10: key = (if v_416 then 3-proj-3-tuple(v_415) else caught-fail) in
        {1268}let temp_k_10: key = (if v_416 then 2-proj-3-tuple(v_415) else caught-fail) in
        {1269}let ck_67: key = (if v_416 then 1-proj-3-tuple(v_415) else caught-fail) in
        {1270}let ss_66: symmetricstate = (if v_409 then catch-fail((if v_412 then (if v_414 then (if v_416 then symmetricstatepack(cipherstatepack(temp_k_10,minnonce),ck_67,h_56) else fail-any) else fail-any) else fail-any)) else caught-fail) in
        {1271}let v_417: bool = not-caught-fail(ss_66) in
        {1272}let v_418: bitstring = (if v_417 then catch-fail(symmetricstateunpack(ss_66)) else caught-fail) in
        {1273}let v_419: bool = (not-caught-fail(v_418) && success?(1-proj-3-tuple(v_418))) in
        {1274}let h_57: bitstring = (if v_419 then 3-proj-3-tuple(v_418) else caught-fail) in
        {1275}let ck_68: key = (if v_419 then 2-proj-3-tuple(v_418) else caught-fail) in
        {1276}let cs_57: cipherstate = (if v_419 then 1-proj-3-tuple(v_418) else caught-fail) in
        {1277}let v_420: bitstring = (if v_419 then catch-fail(cipherstateunpack(cs_57)) else caught-fail) in
        {1278}let v_421: bool = (not-caught-fail(v_420) && success?(1-proj-2-tuple(v_420))) in
        {1279}let n_26: nonce = (if v_421 then 2-proj-2-tuple(v_420) else caught-fail) in
        {1280}let k_29: key = (if v_421 then 1-proj-2-tuple(v_420) else caught-fail) in
        {1281}let e_26: bitstring = (if v_421 then encrypt(k_29,n_26,h_57,payload_6) else caught-fail) in
        {1282}let n_27: nonce = (if v_421 then increment_nonce(n_26) else caught-fail) in
        {1283}let v_422: bitstring = (if v_421 then catch-fail(cipherstateunpack(cs_57)) else caught-fail) in
        {1284}let v_423: bool = (not-caught-fail(v_422) && success?(1-proj-2-tuple(v_422))) in
        {1285}let o_13: nonce = (if v_423 then 2-proj-2-tuple(v_422) else caught-fail) in
        {1286}let k_30: key = (if v_423 then 1-proj-2-tuple(v_422) else caught-fail) in
        {1287}let csi_26: cipherstate = (if v_421 then catch-fail((if v_423 then cipherstatepack(k_30,n_27) else fail-any)) else caught-fail) in
        {1288}let v_424: bool = not-caught-fail(csi_26) in
        {1289}let v_425: bitstring = (if v_419 then catch-fail((if v_421 then (if v_424 then (csi_26,e_26) else fail-any) else fail-any)) else caught-fail) in
        {1290}let v_426: bool = (not-caught-fail(v_425) && success?(1-proj-2-tuple(v_425))) in
        {1291}let ciphertext_26: bitstring = (if v_426 then 2-proj-2-tuple(v_425) else caught-fail) in
        {1292}let csi_27: cipherstate = (if v_426 then 1-proj-2-tuple(v_425) else caught-fail) in
        {1293}let ss_67: symmetricstate = (if v_426 then symmetricstatepack(csi_27,ck_68,h_57) else caught-fail) in
        {1294}let v_427: bitstring = (if v_426 then catch-fail(symmetricstateunpack(ss_67)) else caught-fail) in
        {1295}let v_428: bool = (not-caught-fail(v_427) && success?(1-proj-3-tuple(v_427))) in
        {1296}let h_58: bitstring = (if v_428 then 3-proj-3-tuple(v_427) else caught-fail) in
        {1297}let ck_69: key = (if v_428 then 2-proj-3-tuple(v_427) else caught-fail) in
        {1298}let cs_58: cipherstate = (if v_428 then 1-proj-3-tuple(v_427) else caught-fail) in
        {1299}let ssi_15: symmetricstate = (if v_426 then catch-fail((if v_428 then symmetricstatepack(cs_58,ck_69,hash(h_58,ciphertext_26)) else fail-any)) else caught-fail) in
        {1300}let v_429: bool = not-caught-fail(ssi_15) in
        {1301}let v_430: bitstring = (if v_417 then catch-fail((if v_419 then (if v_426 then (if v_429 then (ssi_15,ciphertext_26) else fail-any) else fail-any) else fail-any)) else caught-fail) in
        {1302}let v_431: bool = (not-caught-fail(v_430) && success?(1-proj-2-tuple(v_430))) in
        {1303}let ciphertext_27: bitstring = (if v_431 then 2-proj-2-tuple(v_430) else caught-fail) in
        {1304}let ss_68: symmetricstate = (if v_431 then 1-proj-2-tuple(v_430) else caught-fail) in
        {1305}let hs_41: handshakestate = (if v_431 then handshakestatepack(ss_68,s_14,m_16,e_25,rs_14,rm_14,re_17,psk_14,initiator_12) else caught-fail) in
        {1306}let message_buffer_6: bitstring = (if v_431 then concat3(ne_12,ns_11,ciphertext_27) else caught-fail) in
        {1307}let (hs_42: handshakestate,message_b_2: bitstring) = (if v_401 then (if v_403 then (if v_405 then (if v_406 then (if v_409 then (if v_417 then (if v_431 then (hs_41,message_buffer_6) else fail-any) else fail-any) else fail-any) else fail-any) else fail-any) else fail-any) else fail-any) in
        {1308}event SendMsg(me_2,them_2,stagepack_b(sid_3),msg_b(me_2,them_2,sid_3));
        {1309}insert statestore(me_2,them_2,sid_3,statepack_c(hs_42));
        {1310}out(pub, message_b_2)
    ) | (
        {1463}get statestore(=me_2,=them_2,=sid_3,statepack_c(hs_43: handshakestate)) in
        {1312}in(pub, message_c_2: bitstring);
        {1313}let v_432: bitstring = catch-fail(handshakestateunpack(hs_43)) in
        {1314}let v_433: bool = (not-caught-fail(v_432) && success?(1-proj-9-tuple(v_432))) in
        {1315}let initiator_13: bool = (if v_433 then 9-proj-9-tuple(v_432) else caught-fail) in
        {1316}let psk_15: key = (if v_433 then 8-proj-9-tuple(v_432) else caught-fail) in
        {1317}let re_18: key = (if v_433 then 7-proj-9-tuple(v_432) else caught-fail) in
        {1318}let rm_15: key = (if v_433 then 6-proj-9-tuple(v_432) else caught-fail) in
        {1319}let rs_15: key = (if v_433 then 5-proj-9-tuple(v_432) else caught-fail) in
        {1320}let e_27: keypair = (if v_433 then 4-proj-9-tuple(v_432) else caught-fail) in
        {1321}let m_17: keypair = (if v_433 then 3-proj-9-tuple(v_432) else caught-fail) in
        {1322}let s_15: keypair = (if v_433 then 2-proj-9-tuple(v_432) else caught-fail) in
        {1323}let ss_69: symmetricstate = (if v_433 then 1-proj-9-tuple(v_432) else caught-fail) in
        {1324}let v_434: bitstring = (if v_433 then catch-fail(deconcat3(message_c_2)) else caught-fail) in
        {1325}let v_435: bool = (not-caught-fail(v_434) && success?(1-proj-3-tuple(v_434))) in
        {1326}let ciphertext_28: bitstring = (if v_435 then 3-proj-3-tuple(v_434) else caught-fail) in
        {1327}let nm_4: bitstring = (if v_435 then 2-proj-3-tuple(v_434) else caught-fail) in
        {1328}let ns_12: bitstring = (if v_435 then 1-proj-3-tuple(v_434) else caught-fail) in
        {1329}let valid1_5: bool = (if v_435 then true else caught-fail) in
        {1330}let v_436: bitstring = (if v_435 then catch-fail(symmetricstateunpack(ss_69)) else caught-fail) in
        {1331}let v_437: bool = (not-caught-fail(v_436) && success?(1-proj-3-tuple(v_436))) in
        {1332}let h_59: bitstring = (if v_437 then 3-proj-3-tuple(v_436) else caught-fail) in
        {1333}let ck_70: key = (if v_437 then 2-proj-3-tuple(v_436) else caught-fail) in
        {1334}let cs_59: cipherstate = (if v_437 then 1-proj-3-tuple(v_436) else caught-fail) in
        {1335}let v_438: bitstring = (if v_437 then catch-fail(cipherstateunpack(cs_59)) else caught-fail) in
        {1336}let v_439: bool = (not-caught-fail(v_438) && success?(1-proj-2-tuple(v_438))) in
        {1337}let n_28: nonce = (if v_439 then 2-proj-2-tuple(v_438) else caught-fail) in
        {1338}let k_31: key = (if v_439 then 1-proj-2-tuple(v_438) else caught-fail) in
        {1339}let d_5: aead = (if v_439 then catch-fail(decrypt(k_31,n_28,h_59,nm_4)) else caught-fail) in
        {1340}let v_440: bool = not-caught-fail(d_5) in
        {1341}let v_441: bitstring = (if v_440 then catch-fail(aeadunpack(d_5)) else caught-fail) in
        {1342}let v_442: bool = (not-caught-fail(v_441) && success?(1-proj-3-tuple(v_441))) in
        {1343}let plaintext_17: bitstring = (if v_442 then 3-proj-3-tuple(v_441) else caught-fail) in
        {1344}let adi_5: bitstring = (if v_442 then 2-proj-3-tuple(v_441) else caught-fail) in
        {1345}let valid_15: bool = (if v_442 then 1-proj-3-tuple(v_441) else caught-fail) in
        {1346}let n_29: nonce = (if v_442 then increment_nonce(n_28) else caught-fail) in
        {1347}let v_443: bitstring = (if v_442 then catch-fail(cipherstateunpack(cs_59)) else caught-fail) in
        {1348}let v_444: bool = (not-caught-fail(v_443) && success?(1-proj-2-tuple(v_443))) in
        {1349}let o_14: nonce = (if v_444 then 2-proj-2-tuple(v_443) else caught-fail) in
        {1350}let k_32: key = (if v_444 then 1-proj-2-tuple(v_443) else caught-fail) in
        {1351}let csi_28: cipherstate = (if v_442 then catch-fail((if v_444 then cipherstatepack(k_32,n_29) else fail-any)) else caught-fail) in
        {1352}let v_445: bool = not-caught-fail(csi_28) in
        {1353}let v_446: bitstring = (if v_437 then catch-fail((if v_439 then (if v_440 then (if v_442 then (if v_445 then (csi_28,plaintext_17,valid_15) else fail-any) else fail-any) else fail-any) else fail-any)) else caught-fail) in
        {1354}let v_447: bool = (not-caught-fail(v_446) && success?(1-proj-3-tuple(v_446))) in
        {1355}let valid_16: bool = (if v_447 then 3-proj-3-tuple(v_446) else caught-fail) in
        {1356}let plaintext_18: bitstring = (if v_447 then 2-proj-3-tuple(v_446) else caught-fail) in
        {1357}let csi_29: cipherstate = (if v_447 then 1-proj-3-tuple(v_446) else caught-fail) in
        {1358}let ss_70: symmetricstate = (if v_447 then symmetricstatepack(csi_29,ck_70,h_59) else caught-fail) in
        {1359}let v_448: bitstring = (if v_447 then catch-fail(symmetricstateunpack(ss_70)) else caught-fail) in
        {1360}let v_449: bool = (not-caught-fail(v_448) && success?(1-proj-3-tuple(v_448))) in
        {1361}let h_60: bitstring = (if v_449 then 3-proj-3-tuple(v_448) else caught-fail) in
        {1362}let ck_71: key = (if v_449 then 2-proj-3-tuple(v_448) else caught-fail) in
        {1363}let cs_60: cipherstate = (if v_449 then 1-proj-3-tuple(v_448) else caught-fail) in
        {1364}let ssi_16: symmetricstate = (if v_447 then catch-fail((if v_449 then symmetricstatepack(cs_60,ck_71,hash(h_60,nm_4)) else fail-any)) else caught-fail) in
        {1365}let v_450: bool = not-caught-fail(ssi_16) in
        {1366}let v_451: bitstring = (if v_435 then catch-fail((if v_437 then (if v_447 then (if v_450 then (ssi_16,plaintext_18,valid_16) else fail-any) else fail-any) else fail-any)) else caught-fail) in
        {1367}let v_452: bool = (not-caught-fail(v_451) && success?(1-proj-3-tuple(v_451))) in
        {1368}let valid1_6: bool = (if v_452 then 3-proj-3-tuple(v_451) else caught-fail) in
        {1369}let nem: bitstring = (if v_452 then 2-proj-3-tuple(v_451) else caught-fail) in
        {1370}let ss_71: symmetricstate = (if v_452 then 1-proj-3-tuple(v_451) else caught-fail) in
        {1371}let rm_16: key = (if v_452 then nem else caught-fail) in
        {1372}let v_453: bitstring = (if v_452 then catch-fail(keypairunpack(e_27)) else caught-fail) in
        {1373}let v_454: bool = (not-caught-fail(v_453) && success?(1-proj-2-tuple(v_453))) in
        {1374}let my_private_key_11: key = (if v_454 then 2-proj-2-tuple(v_453) else caught-fail) in
        {1375}let my_public_key_11: key = (if v_454 then 1-proj-2-tuple(v_453) else caught-fail) in
        {1376}let input_key_material_13: key = (if v_452 then catch-fail((if v_454 then dhexp(my_private_key_11,rm_16) else fail-any)) else caught-fail) in
        {1377}let v_455: bool = not-caught-fail(input_key_material_13) in
        {1378}let v_456: bitstring = (if v_455 then catch-fail(symmetricstateunpack(ss_71)) else caught-fail) in
        {1379}let v_457: bool = (not-caught-fail(v_456) && success?(1-proj-3-tuple(v_456))) in
        {1380}let h_61: bitstring = (if v_457 then 3-proj-3-tuple(v_456) else caught-fail) in
        {1381}let ck_72: key = (if v_457 then 2-proj-3-tuple(v_456) else caught-fail) in
        {1382}let cs_61: cipherstate = (if v_457 then 1-proj-3-tuple(v_456) else caught-fail) in
        {1383}let output1_13: key = (if v_457 then hmac_hash1(ck_72,input_key_material_13) else caught-fail) in
        {1384}let output2_13: key = (if v_457 then hmac_hash2(ck_72,input_key_material_13) else caught-fail) in
        {1385}let output3_13: key = (if v_457 then hmac_hash3(ck_72,input_key_material_13) else caught-fail) in
        {1386}let v_458: bitstring = (if v_457 then catch-fail((output1_13,output2_13,output3_13)) else caught-fail) in
        {1387}let v_459: bool = (not-caught-fail(v_458) && success?(1-proj-3-tuple(v_458))) in
        {1388}let output_11: key = (if v_459 then 3-proj-3-tuple(v_458) else caught-fail) in
        {1389}let temp_k_11: key = (if v_459 then 2-proj-3-tuple(v_458) else caught-fail) in
        {1390}let ck_73: key = (if v_459 then 1-proj-3-tuple(v_458) else caught-fail) in
        {1391}let ss_72: symmetricstate = (if v_452 then catch-fail((if v_455 then (if v_457 then (if v_459 then symmetricstatepack(cipherstatepack(temp_k_11,minnonce),ck_73,h_61) else fail-any) else fail-any) else fail-any)) else caught-fail) in
        {1392}let v_460: bool = not-caught-fail(ss_72) in
        {1393}let v_461: bitstring = (if v_460 then catch-fail(symmetricstateunpack(ss_72)) else caught-fail) in
        {1394}let v_462: bool = (not-caught-fail(v_461) && success?(1-proj-3-tuple(v_461))) in
        {1395}let h_62: bitstring = (if v_462 then 3-proj-3-tuple(v_461) else caught-fail) in
        {1396}let ck_74: key = (if v_462 then 2-proj-3-tuple(v_461) else caught-fail) in
        {1397}let cs_62: cipherstate = (if v_462 then 1-proj-3-tuple(v_461) else caught-fail) in
        {1398}let v_463: bitstring = (if v_462 then catch-fail(cipherstateunpack(cs_62)) else caught-fail) in
        {1399}let v_464: bool = (not-caught-fail(v_463) && success?(1-proj-2-tuple(v_463))) in
        {1400}let n_30: nonce = (if v_464 then 2-proj-2-tuple(v_463) else caught-fail) in
        {1401}let k_33: key = (if v_464 then 1-proj-2-tuple(v_463) else caught-fail) in
        {1402}let d_6: aead = (if v_464 then catch-fail(decrypt(k_33,n_30,h_62,ciphertext_28)) else caught-fail) in
        {1403}let v_465: bool = not-caught-fail(d_6) in
        {1404}let v_466: bitstring = (if v_465 then catch-fail(aeadunpack(d_6)) else caught-fail) in
        {1405}let v_467: bool = (not-caught-fail(v_466) && success?(1-proj-3-tuple(v_466))) in
        {1406}let plaintext_19: bitstring = (if v_467 then 3-proj-3-tuple(v_466) else caught-fail) in
        {1407}let adi_6: bitstring = (if v_467 then 2-proj-3-tuple(v_466) else caught-fail) in
        {1408}let valid_17: bool = (if v_467 then 1-proj-3-tuple(v_466) else caught-fail) in
        {1409}let n_31: nonce = (if v_467 then increment_nonce(n_30) else caught-fail) in
        {1410}let v_468: bitstring = (if v_467 then catch-fail(cipherstateunpack(cs_62)) else caught-fail) in
        {1411}let v_469: bool = (not-caught-fail(v_468) && success?(1-proj-2-tuple(v_468))) in
        {1412}let o_15: nonce = (if v_469 then 2-proj-2-tuple(v_468) else caught-fail) in
        {1413}let k_34: key = (if v_469 then 1-proj-2-tuple(v_468) else caught-fail) in
        {1414}let csi_30: cipherstate = (if v_467 then catch-fail((if v_469 then cipherstatepack(k_34,n_31) else fail-any)) else caught-fail) in
        {1415}let v_470: bool = not-caught-fail(csi_30) in
        {1416}let v_471: bitstring = (if v_462 then catch-fail((if v_464 then (if v_465 then (if v_467 then (if v_470 then (csi_30,plaintext_19,valid_17) else fail-any) else fail-any) else fail-any) else fail-any)) else caught-fail) in
        {1417}let v_472: bool = (not-caught-fail(v_471) && success?(1-proj-3-tuple(v_471))) in
        {1418}let valid_18: bool = (if v_472 then 3-proj-3-tuple(v_471) else caught-fail) in
        {1419}let plaintext_20: bitstring = (if v_472 then 2-proj-3-tuple(v_471) else caught-fail) in
        {1420}let csi_31: cipherstate = (if v_472 then 1-proj-3-tuple(v_471) else caught-fail) in
        {1421}let ss_73: symmetricstate = (if v_472 then symmetricstatepack(csi_31,ck_74,h_62) else caught-fail) in
        {1422}let v_473: bitstring = (if v_472 then catch-fail(symmetricstateunpack(ss_73)) else caught-fail) in
        {1423}let v_474: bool = (not-caught-fail(v_473) && success?(1-proj-3-tuple(v_473))) in
        {1424}let h_63: bitstring = (if v_474 then 3-proj-3-tuple(v_473) else caught-fail) in
        {1425}let ck_75: key = (if v_474 then 2-proj-3-tuple(v_473) else caught-fail) in
        {1426}let cs_63: cipherstate = (if v_474 then 1-proj-3-tuple(v_473) else caught-fail) in
        {1427}let ssi_17: symmetricstate = (if v_472 then catch-fail((if v_474 then symmetricstatepack(cs_63,ck_75,hash(h_63,ciphertext_28)) else fail-any)) else caught-fail) in
        {1428}let v_475: bool = not-caught-fail(ssi_17) in
        {1429}let v_476: bitstring = (if v_460 then catch-fail((if v_462 then (if v_472 then (if v_475 then (ssi_17,plaintext_20,valid_18) else fail-any) else fail-any) else fail-any)) else caught-fail) in
        {1430}let v_477: bool = (not-caught-fail(v_476) && success?(1-proj-3-tuple(v_476))) in
        {1431}let valid2_5: bool = (if v_477 then 3-proj-3-tuple(v_476) else caught-fail) in
        {1432}let plaintext_21: bitstring = (if v_477 then 2-proj-3-tuple(v_476) else caught-fail) in
        {1433}let ss_74: symmetricstate = (if v_477 then 1-proj-3-tuple(v_476) else caught-fail) in
        {1434}let basis_11: key = (if v_477 then key_s(them_2) else caught-fail) in
        {1435}let public_key_11: key = (if v_477 then catch-fail(dhexp(basis_11,validkey(g))) else caught-fail) in
        {1436}let v_478: bool = not-caught-fail(public_key_11) in
        {1437}let v_479: bool = (if v_477 then catch-fail(((valid1_6 && valid2_5) && (rs_15 = getpublickey((if v_478 then keypairpack(validkey(public_key_11),basis_11) else fail-any))))) else caught-fail) in
        {1438}let hs_44: handshakestate = (if v_479 then handshakestatepack(ss_74,s_15,m_17,e_27,rs_15,rm_16,re_18,psk_15,initiator_13) else caught-fail) in
        {1439}let v_480: bitstring = (if v_479 then catch-fail(symmetricstateunpack(ss_74)) else caught-fail) in
        {1440}let v_481: bool = (not-caught-fail(v_480) && success?(1-proj-3-tuple(v_480))) in
        {1441}let h_64: bitstring = (if v_481 then 3-proj-3-tuple(v_480) else caught-fail) in
        {1442}let ck_76: key = (if v_481 then 2-proj-3-tuple(v_480) else caught-fail) in
        {1443}let cs_64: cipherstate = (if v_481 then 1-proj-3-tuple(v_480) else caught-fail) in
        {1444}let input_key_material_14: key = (if v_481 then zero else caught-fail) in
        {1445}let output1_14: key = (if v_481 then hmac_hash1(ck_76,input_key_material_14) else caught-fail) in
        {1446}let output2_14: key = (if v_481 then hmac_hash2(ck_76,input_key_material_14) else caught-fail) in
        {1447}let output3_14: key = (if v_481 then hmac_hash3(ck_76,input_key_material_14) else caught-fail) in
        {1448}let v_482: bitstring = (if v_481 then catch-fail((output1_14,output2_14,output3_14)) else caught-fail) in
        {1449}let v_483: bool = (not-caught-fail(v_482) && success?(1-proj-3-tuple(v_482))) in
        {1450}let temp_k3_2: key = (if v_483 then 3-proj-3-tuple(v_482) else caught-fail) in
        {1451}let temp_k2_2: key = (if v_483 then 2-proj-3-tuple(v_482) else caught-fail) in
        {1452}let temp_k1_2: key = (if v_483 then 1-proj-3-tuple(v_482) else caught-fail) in
        {1453}let cs1_10: cipherstate = (if v_483 then cipherstatepack(temp_k1_2,minnonce) else caught-fail) in
        {1454}let cs2_10: cipherstate = (if v_483 then cipherstatepack(temp_k2_2,minnonce) else caught-fail) in
        {1455}let v_484: bitstring = (if v_479 then catch-fail((if v_481 then (if v_483 then (ss_74,cs1_10,cs2_10) else fail-any) else fail-any)) else caught-fail) in
        {1456}let v_485: bool = (not-caught-fail(v_484) && success?(1-proj-3-tuple(v_484))) in
        {1457}let cs2_11: cipherstate = (if v_485 then 3-proj-3-tuple(v_484) else caught-fail) in
        {1458}let cs1_11: cipherstate = (if v_485 then 2-proj-3-tuple(v_484) else caught-fail) in
        {1459}let ssi_18: symmetricstate = (if v_485 then 1-proj-3-tuple(v_484) else caught-fail) in
        {1460}let (hs_45: handshakestate,plaintext_c: bitstring,valid_19: bool,cs1_12: cipherstate,cs2_12: cipherstate) = (if v_433 then (if v_435 then (if v_452 then (if v_460 then (if v_477 then (if undo-catch-fail(v_479) then (if v_485 then (hs_44,plaintext_21,true,cs1_11,cs2_11) else fail-any) else fail-any) else fail-any) else fail-any) else fail-any) else fail-any) else fail-any) in
        {1461}event RecvMsg(me_2,them_2,stagepack_c(sid_3),plaintext_c);
        {1462}insert statestore(me_2,them_2,sid_3,statepack_d(hs_45,cs1_12,cs2_12))
    ) | (
        {1464}!
        {1522}get statestore(=me_2,=them_2,=sid_3,statepack_d(hs_46: handshakestate,cs1_13: cipherstate,cs2_13: cipherstate)) in
        {1465}let hs_47: handshakestate = handshakestatesetcs(hs_46,cs2_13) in
        {1466}let payload_7: bitstring = msg_d(me_2,them_2,sid_3) in
        {1467}let v_486: bitstring = catch-fail(handshakestateunpack(hs_47)) in
        {1468}let v_487: bool = (not-caught-fail(v_486) && success?(1-proj-9-tuple(v_486))) in
        {1469}let initiator_14: bool = (if v_487 then 9-proj-9-tuple(v_486) else caught-fail) in
        {1470}let psk_16: key = (if v_487 then 8-proj-9-tuple(v_486) else caught-fail) in
        {1471}let re_19: key = (if v_487 then 7-proj-9-tuple(v_486) else caught-fail) in
        {1472}let rm_17: key = (if v_487 then 6-proj-9-tuple(v_486) else caught-fail) in
        {1473}let rs_16: key = (if v_487 then 5-proj-9-tuple(v_486) else caught-fail) in
        {1474}let e_28: keypair = (if v_487 then 4-proj-9-tuple(v_486) else caught-fail) in
        {1475}let m_18: keypair = (if v_487 then 3-proj-9-tuple(v_486) else caught-fail) in
        {1476}let s_16: keypair = (if v_487 then 2-proj-9-tuple(v_486) else caught-fail) in
        {1477}let ss_75: symmetricstate = (if v_487 then 1-proj-9-tuple(v_486) else caught-fail) in
        {1478}let v_488: bitstring = (if v_487 then catch-fail((empty,empty,empty)) else caught-fail) in
        {1479}let v_489: bool = (not-caught-fail(v_488) && success?(1-proj-3-tuple(v_488))) in
        {1480}let ciphertext_29: bitstring = (if v_489 then 3-proj-3-tuple(v_488) else caught-fail) in
        {1481}let ns_13: bitstring = (if v_489 then 2-proj-3-tuple(v_488) else caught-fail) in
        {1482}let ne_13: bitstring = (if v_489 then 1-proj-3-tuple(v_488) else caught-fail) in
        {1483}let v_490: bitstring = (if v_489 then catch-fail(symmetricstateunpack(ss_75)) else caught-fail) in
        {1484}let v_491: bool = (not-caught-fail(v_490) && success?(1-proj-3-tuple(v_490))) in
        {1485}let h_65: bitstring = (if v_491 then 3-proj-3-tuple(v_490) else caught-fail) in
        {1486}let ck_77: key = (if v_491 then 2-proj-3-tuple(v_490) else caught-fail) in
        {1487}let cs_65: cipherstate = (if v_491 then 1-proj-3-tuple(v_490) else caught-fail) in
        {1488}let v_492: bitstring = (if v_491 then catch-fail(cipherstateunpack(cs_65)) else caught-fail) in
        {1489}let v_493: bool = (not-caught-fail(v_492) && success?(1-proj-2-tuple(v_492))) in
        {1490}let n_32: nonce = (if v_493 then 2-proj-2-tuple(v_492) else caught-fail) in
        {1491}let k_35: key = (if v_493 then 1-proj-2-tuple(v_492) else caught-fail) in
        {1492}let e_29: bitstring = (if v_493 then encrypt(k_35,n_32,h_65,payload_7) else caught-fail) in
        {1493}let n_33: nonce = (if v_493 then increment_nonce(n_32) else caught-fail) in
        {1494}let v_494: bitstring = (if v_493 then catch-fail(cipherstateunpack(cs_65)) else caught-fail) in
        {1495}let v_495: bool = (not-caught-fail(v_494) && success?(1-proj-2-tuple(v_494))) in
        {1496}let o_16: nonce = (if v_495 then 2-proj-2-tuple(v_494) else caught-fail) in
        {1497}let k_36: key = (if v_495 then 1-proj-2-tuple(v_494) else caught-fail) in
        {1498}let csi_32: cipherstate = (if v_493 then catch-fail((if v_495 then cipherstatepack(k_36,n_33) else fail-any)) else caught-fail) in
        {1499}let v_496: bool = not-caught-fail(csi_32) in
        {1500}let v_497: bitstring = (if v_491 then catch-fail((if v_493 then (if v_496 then (csi_32,e_29) else fail-any) else fail-any)) else caught-fail) in
        {1501}let v_498: bool = (not-caught-fail(v_497) && success?(1-proj-2-tuple(v_497))) in
        {1502}let ciphertext_30: bitstring = (if v_498 then 2-proj-2-tuple(v_497) else caught-fail) in
        {1503}let csi_33: cipherstate = (if v_498 then 1-proj-2-tuple(v_497) else caught-fail) in
        {1504}let ss_76: symmetricstate = (if v_498 then symmetricstatepack(csi_33,ck_77,h_65) else caught-fail) in
        {1505}let v_499: bitstring = (if v_498 then catch-fail(symmetricstateunpack(ss_76)) else caught-fail) in
        {1506}let v_500: bool = (not-caught-fail(v_499) && success?(1-proj-3-tuple(v_499))) in
        {1507}let h_66: bitstring = (if v_500 then 3-proj-3-tuple(v_499) else caught-fail) in
        {1508}let ck_78: key = (if v_500 then 2-proj-3-tuple(v_499) else caught-fail) in
        {1509}let cs_66: cipherstate = (if v_500 then 1-proj-3-tuple(v_499) else caught-fail) in
        {1510}let ssi_19: symmetricstate = (if v_498 then catch-fail((if v_500 then symmetricstatepack(cs_66,ck_78,hash(h_66,ciphertext_30)) else fail-any)) else caught-fail) in
        {1511}let v_501: bool = not-caught-fail(ssi_19) in
        {1512}let v_502: bitstring = (if v_489 then catch-fail((if v_491 then (if v_498 then (if v_501 then (ssi_19,ciphertext_30) else fail-any) else fail-any) else fail-any)) else caught-fail) in
        {1513}let v_503: bool = (not-caught-fail(v_502) && success?(1-proj-2-tuple(v_502))) in
        {1514}let ciphertext_31: bitstring = (if v_503 then 2-proj-2-tuple(v_502) else caught-fail) in
        {1515}let ss_77: symmetricstate = (if v_503 then 1-proj-2-tuple(v_502) else caught-fail) in
        {1516}let hs_48: handshakestate = (if v_503 then handshakestatepack(ss_77,s_16,m_18,e_28,rs_16,rm_17,re_19,psk_16,initiator_14) else caught-fail) in
        {1517}let message_buffer_7: bitstring = (if v_503 then concat3(ne_13,ns_13,ciphertext_31) else caught-fail) in
        {1518}let (hs_49: handshakestate,message_d_2: bitstring) = (if v_487 then (if v_489 then (if v_503 then (hs_48,message_buffer_7) else fail-any) else fail-any) else fail-any) in
        {1519}event SendMsg(me_2,them_2,stagepack_d(sid_3),msg_d(me_2,them_2,sid_3));
        {1520}insert statestore(me_2,them_2,sid_3,statepack_e(hs_49,cs1_13,handshakestategetcs(hs_49)));
        {1521}out(pub, message_d_2)
    ) | (
        {1523}!
        {1589}get statestore(=me_2,=them_2,=sid_3,statepack_e(hs_50: handshakestate,cs1_14: cipherstate,cs2_14: cipherstate)) in
        {1524}let hs_51: handshakestate = handshakestatesetcs(hs_50,cs1_14) in
        {1525}in(pub, message_e_2: bitstring);
        {1526}let v_504: bitstring = catch-fail(handshakestateunpack(hs_51)) in
        {1527}let v_505: bool = (not-caught-fail(v_504) && success?(1-proj-9-tuple(v_504))) in
        {1528}let initiator_15: bool = (if v_505 then 9-proj-9-tuple(v_504) else caught-fail) in
        {1529}let psk_17: key = (if v_505 then 8-proj-9-tuple(v_504) else caught-fail) in
        {1530}let re_20: key = (if v_505 then 7-proj-9-tuple(v_504) else caught-fail) in
        {1531}let rm_18: key = (if v_505 then 6-proj-9-tuple(v_504) else caught-fail) in
        {1532}let rs_17: key = (if v_505 then 5-proj-9-tuple(v_504) else caught-fail) in
        {1533}let e_30: keypair = (if v_505 then 4-proj-9-tuple(v_504) else caught-fail) in
        {1534}let m_19: keypair = (if v_505 then 3-proj-9-tuple(v_504) else caught-fail) in
        {1535}let s_17: keypair = (if v_505 then 2-proj-9-tuple(v_504) else caught-fail) in
        {1536}let ss_78: symmetricstate = (if v_505 then 1-proj-9-tuple(v_504) else caught-fail) in
        {1537}let v_506: bitstring = (if v_505 then catch-fail(deconcat3(message_e_2)) else caught-fail) in
        {1538}let v_507: bool = (not-caught-fail(v_506) && success?(1-proj-3-tuple(v_506))) in
        {1539}let ciphertext_32: bitstring = (if v_507 then 3-proj-3-tuple(v_506) else caught-fail) in
        {1540}let ns_14: bitstring = (if v_507 then 2-proj-3-tuple(v_506) else caught-fail) in
        {1541}let ne_14: bitstring = (if v_507 then 1-proj-3-tuple(v_506) else caught-fail) in
        {1542}let valid1_7: bool = (if v_507 then true else caught-fail) in
        {1543}let v_508: bitstring = (if v_507 then catch-fail(symmetricstateunpack(ss_78)) else caught-fail) in
        {1544}let v_509: bool = (not-caught-fail(v_508) && success?(1-proj-3-tuple(v_508))) in
        {1545}let h_67: bitstring = (if v_509 then 3-proj-3-tuple(v_508) else caught-fail) in
        {1546}let ck_79: key = (if v_509 then 2-proj-3-tuple(v_508) else caught-fail) in
        {1547}let cs_67: cipherstate = (if v_509 then 1-proj-3-tuple(v_508) else caught-fail) in
        {1548}let v_510: bitstring = (if v_509 then catch-fail(cipherstateunpack(cs_67)) else caught-fail) in
        {1549}let v_511: bool = (not-caught-fail(v_510) && success?(1-proj-2-tuple(v_510))) in
        {1550}let n_34: nonce = (if v_511 then 2-proj-2-tuple(v_510) else caught-fail) in
        {1551}let k_37: key = (if v_511 then 1-proj-2-tuple(v_510) else caught-fail) in
        {1552}let d_7: aead = (if v_511 then catch-fail(decrypt(k_37,n_34,h_67,ciphertext_32)) else caught-fail) in
        {1553}let v_512: bool = not-caught-fail(d_7) in
        {1554}let v_513: bitstring = (if v_512 then catch-fail(aeadunpack(d_7)) else caught-fail) in
        {1555}let v_514: bool = (not-caught-fail(v_513) && success?(1-proj-3-tuple(v_513))) in
        {1556}let plaintext_22: bitstring = (if v_514 then 3-proj-3-tuple(v_513) else caught-fail) in
        {1557}let adi_7: bitstring = (if v_514 then 2-proj-3-tuple(v_513) else caught-fail) in
        {1558}let valid_20: bool = (if v_514 then 1-proj-3-tuple(v_513) else caught-fail) in
        {1559}let n_35: nonce = (if v_514 then increment_nonce(n_34) else caught-fail) in
        {1560}let v_515: bitstring = (if v_514 then catch-fail(cipherstateunpack(cs_67)) else caught-fail) in
        {1561}let v_516: bool = (not-caught-fail(v_515) && success?(1-proj-2-tuple(v_515))) in
        {1562}let o_17: nonce = (if v_516 then 2-proj-2-tuple(v_515) else caught-fail) in
        {1563}let k_38: key = (if v_516 then 1-proj-2-tuple(v_515) else caught-fail) in
        {1564}let csi_34: cipherstate = (if v_514 then catch-fail((if v_516 then cipherstatepack(k_38,n_35) else fail-any)) else caught-fail) in
        {1565}let v_517: bool = not-caught-fail(csi_34) in
        {1566}let v_518: bitstring = (if v_509 then catch-fail((if v_511 then (if v_512 then (if v_514 then (if v_517 then (csi_34,plaintext_22,valid_20) else fail-any) else fail-any) else fail-any) else fail-any)) else caught-fail) in
        {1567}let v_519: bool = (not-caught-fail(v_518) && success?(1-proj-3-tuple(v_518))) in
        {1568}let valid_21: bool = (if v_519 then 3-proj-3-tuple(v_518) else caught-fail) in
        {1569}let plaintext_23: bitstring = (if v_519 then 2-proj-3-tuple(v_518) else caught-fail) in
        {1570}let csi_35: cipherstate = (if v_519 then 1-proj-3-tuple(v_518) else caught-fail) in
        {1571}let ss_79: symmetricstate = (if v_519 then symmetricstatepack(csi_35,ck_79,h_67) else caught-fail) in
        {1572}let v_520: bitstring = (if v_519 then catch-fail(symmetricstateunpack(ss_79)) else caught-fail) in
        {1573}let v_521: bool = (not-caught-fail(v_520) && success?(1-proj-3-tuple(v_520))) in
        {1574}let h_68: bitstring = (if v_521 then 3-proj-3-tuple(v_520) else caught-fail) in
        {1575}let ck_80: key = (if v_521 then 2-proj-3-tuple(v_520) else caught-fail) in
        {1576}let cs_68: cipherstate = (if v_521 then 1-proj-3-tuple(v_520) else caught-fail) in
        {1577}let ssi_20: symmetricstate = (if v_519 then catch-fail((if v_521 then symmetricstatepack(cs_68,ck_80,hash(h_68,ciphertext_32)) else fail-any)) else caught-fail) in
        {1578}let v_522: bool = not-caught-fail(ssi_20) in
        {1579}let v_523: bitstring = (if v_507 then catch-fail((if v_509 then (if v_519 then (if v_522 then (ssi_20,plaintext_23,valid_21) else fail-any) else fail-any) else fail-any)) else caught-fail) in
        {1580}let v_524: bool = (not-caught-fail(v_523) && success?(1-proj-3-tuple(v_523))) in
        {1581}let valid2_6: bool = (if v_524 then 3-proj-3-tuple(v_523) else caught-fail) in
        {1582}let plaintext_24: bitstring = (if v_524 then 2-proj-3-tuple(v_523) else caught-fail) in
        {1583}let ss_80: symmetricstate = (if v_524 then 1-proj-3-tuple(v_523) else caught-fail) in
        {1584}let v_525: bool = (if v_524 then catch-fail((valid1_7 && valid2_6)) else caught-fail) in
        {1585}let hs_52: handshakestate = (if v_525 then handshakestatepack(ss_80,s_17,m_19,e_30,rs_17,rm_18,re_20,psk_17,initiator_15) else caught-fail) in
        {1586}let (hs_53: handshakestate,plaintext_e: bitstring,valid_22: bool) = (if v_505 then (if v_507 then (if v_524 then (if undo-catch-fail(v_525) then (hs_52,plaintext_24,true) else fail-any) else fail-any) else fail-any) else fail-any) in
        {1587}event RecvMsg(me_2,them_2,stagepack_e(sid_3),plaintext_e);
        {1588}event RecvEnd(valid_22)
    ) | (
        {1590}event LeakS(phase0,me_2);
        {1591}event LeakM(phase0,me_2);
        {1592}out(pub, (key_s(me_2),key_m(me_2)))
    ) | (
        {1593}phase 1;
        {1594}event LeakS(phase1,me_2);
        {1595}event LeakM(phase1,me_2);
        {1596}out(pub, (key_s(me_2),key_m(me_2)))
    )
) | (
    {1597}let me_3: principal = bob in
    {1598}let them_3: principal = charlie in
    {1599}let sid_4: sessionid = sid in
    {1600}let basis_12: key = key_s(me_3) in
    {1601}let public_key_12: key = catch-fail(dhexp(basis_12,validkey(g))) in
    {1602}let v_526: bool = not-caught-fail(public_key_12) in
    {1603}let s_18: keypair = (if v_526 then keypairpack(validkey(public_key_12),basis_12) else fail-any) in
    {1604}let basis_13: key = key_m(me_3) in
    {1605}let public_key_13: key = catch-fail(dhexp(basis_13,validkey(g))) in
    {1606}let v_527: bool = not-caught-fail(public_key_13) in
    {1607}let m_20: keypair = (if v_527 then keypairpack(validkey(public_key_13),basis_13) else fail-any) in
    {1608}out(pub, (getpublickey(s_18),getpublickey(m_20)));
    (
        {1609}let e_31: keypair = keypairpack(empty,empty) in
        {1610}let rs_18: key = empty in
        {1611}let rm_19: key = empty in
        {1612}let re_21: key = empty in
        {1613}let prologue_3: bitstring = empty in
        {1614}let psk_18: key = empty in
        {1615}let protocol_name_3: bitstring = somename in
        {1616}let h_69: bitstring = hash(protocol_name_3,empty) in
        {1617}let ck_81: key = h_69 in
        {1618}let k_39: key = empty in
        {1619}let cs_69: cipherstate = cipherstatepack(k_39,minnonce) in
        {1620}let ss_81: symmetricstate = symmetricstatepack(cs_69,ck_81,h_69) in
        {1621}let v_528: bitstring = catch-fail(symmetricstateunpack(ss_81)) in
        {1622}let v_529: bool = (not-caught-fail(v_528) && success?(1-proj-3-tuple(v_528))) in
        {1623}let h_70: bitstring = (if v_529 then 3-proj-3-tuple(v_528) else caught-fail) in
        {1624}let ck_82: key = (if v_529 then 2-proj-3-tuple(v_528) else caught-fail) in
        {1625}let cs_70: cipherstate = (if v_529 then 1-proj-3-tuple(v_528) else caught-fail) in
        {1626}let ss_82: symmetricstate = catch-fail((if v_529 then symmetricstatepack(cs_70,ck_82,hash(h_70,prologue_3)) else fail-any)) in
        {1627}let v_530: bool = not-caught-fail(ss_82) in
        {1628}let data_2: bitstring = (if v_530 then catch-fail(getpublickey(s_18)) else caught-fail) in
        {1629}let v_531: bool = not-caught-fail(data_2) in
        {1630}let v_532: bitstring = (if v_531 then catch-fail(symmetricstateunpack(ss_82)) else caught-fail) in
        {1631}let v_533: bool = (not-caught-fail(v_532) && success?(1-proj-3-tuple(v_532))) in
        {1632}let h_71: bitstring = (if v_533 then 3-proj-3-tuple(v_532) else caught-fail) in
        {1633}let ck_83: key = (if v_533 then 2-proj-3-tuple(v_532) else caught-fail) in
        {1634}let cs_71: cipherstate = (if v_533 then 1-proj-3-tuple(v_532) else caught-fail) in
        {1635}let ss_83: symmetricstate = (if v_530 then catch-fail((if v_531 then (if v_533 then symmetricstatepack(cs_71,ck_83,hash(h_71,data_2)) else fail-any) else fail-any)) else caught-fail) in
        {1636}let v_534: bool = not-caught-fail(ss_83) in
        {1637}let data_3: bitstring = (if v_534 then catch-fail(getpublickey(m_20)) else caught-fail) in
        {1638}let v_535: bool = not-caught-fail(data_3) in
        {1639}let v_536: bitstring = (if v_535 then catch-fail(symmetricstateunpack(ss_83)) else caught-fail) in
        {1640}let v_537: bool = (not-caught-fail(v_536) && success?(1-proj-3-tuple(v_536))) in
        {1641}let h_72: bitstring = (if v_537 then 3-proj-3-tuple(v_536) else caught-fail) in
        {1642}let ck_84: key = (if v_537 then 2-proj-3-tuple(v_536) else caught-fail) in
        {1643}let cs_72: cipherstate = (if v_537 then 1-proj-3-tuple(v_536) else caught-fail) in
        {1644}let ss_84: symmetricstate = (if v_534 then catch-fail((if v_535 then (if v_537 then symmetricstatepack(cs_72,ck_84,hash(h_72,data_3)) else fail-any) else fail-any)) else caught-fail) in
        {1645}let v_538: bool = not-caught-fail(ss_84) in
        {1646}let hs_54: handshakestate = (if v_530 then (if v_534 then (if v_538 then handshakestatepack(ss_84,s_18,m_20,e_31,rs_18,rm_19,re_21,psk_18,false) else fail-any) else fail-any) else fail-any) in
        {1647}insert statestore(me_3,them_3,sid_4,statepack_a(hs_54))
    ) | (
        {1762}get statestore(=me_3,=them_3,=sid_4,statepack_a(hs_55: handshakestate)) in
        {1648}in(pub, message_a_3: bitstring);
        {1649}let v_539: bitstring = catch-fail(handshakestateunpack(hs_55)) in
        {1650}let v_540: bool = (not-caught-fail(v_539) && success?(1-proj-9-tuple(v_539))) in
        {1651}let initiator_16: bool = (if v_540 then 9-proj-9-tuple(v_539) else caught-fail) in
        {1652}let psk_19: key = (if v_540 then 8-proj-9-tuple(v_539) else caught-fail) in
        {1653}let re_22: key = (if v_540 then 7-proj-9-tuple(v_539) else caught-fail) in
        {1654}let rm_20: key = (if v_540 then 6-proj-9-tuple(v_539) else caught-fail) in
        {1655}let rs_19: key = (if v_540 then 5-proj-9-tuple(v_539) else caught-fail) in
        {1656}let e_32: keypair = (if v_540 then 4-proj-9-tuple(v_539) else caught-fail) in
        {1657}let m_21: keypair = (if v_540 then 3-proj-9-tuple(v_539) else caught-fail) in
        {1658}let s_19: keypair = (if v_540 then 2-proj-9-tuple(v_539) else caught-fail) in
        {1659}let ss_85: symmetricstate = (if v_540 then 1-proj-9-tuple(v_539) else caught-fail) in
        {1660}let v_541: bitstring = (if v_540 then catch-fail(deconcat3(message_a_3)) else caught-fail) in
        {1661}let v_542: bool = (not-caught-fail(v_541) && success?(1-proj-3-tuple(v_541))) in
        {1662}let ciphertext_33: bitstring = (if v_542 then 3-proj-3-tuple(v_541) else caught-fail) in
        {1663}let ns_15: bitstring = (if v_542 then 2-proj-3-tuple(v_541) else caught-fail) in
        {1664}let ne_15: bitstring = (if v_542 then 1-proj-3-tuple(v_541) else caught-fail) in
        {1665}let valid1_8: bool = (if v_542 then true else caught-fail) in
        {1666}let re_23: key = (if v_542 then ne_15 else caught-fail) in
        {1667}let v_543: bitstring = (if v_542 then catch-fail(symmetricstateunpack(ss_85)) else caught-fail) in
        {1668}let v_544: bool = (not-caught-fail(v_543) && success?(1-proj-3-tuple(v_543))) in
        {1669}let h_73: bitstring = (if v_544 then 3-proj-3-tuple(v_543) else caught-fail) in
        {1670}let ck_85: key = (if v_544 then 2-proj-3-tuple(v_543) else caught-fail) in
        {1671}let cs_73: cipherstate = (if v_544 then 1-proj-3-tuple(v_543) else caught-fail) in
        {1672}let ss_86: symmetricstate = (if v_542 then catch-fail((if v_544 then symmetricstatepack(cs_73,ck_85,hash(h_73,re_23)) else fail-any)) else caught-fail) in
        {1673}let v_545: bool = not-caught-fail(ss_86) in
        {1674}let v_546: bitstring = (if v_545 then catch-fail(keypairunpack(s_19)) else caught-fail) in
        {1675}let v_547: bool = (not-caught-fail(v_546) && success?(1-proj-2-tuple(v_546))) in
        {1676}let my_private_key_12: key = (if v_547 then 2-proj-2-tuple(v_546) else caught-fail) in
        {1677}let my_public_key_12: key = (if v_547 then 1-proj-2-tuple(v_546) else caught-fail) in
        {1678}let input_key_material_15: key = (if v_545 then catch-fail((if v_547 then dhexp(my_private_key_12,re_23) else fail-any)) else caught-fail) in
        {1679}let v_548: bool = not-caught-fail(input_key_material_15) in
        {1680}let v_549: bitstring = (if v_548 then catch-fail(symmetricstateunpack(ss_86)) else caught-fail) in
        {1681}let v_550: bool = (not-caught-fail(v_549) && success?(1-proj-3-tuple(v_549))) in
        {1682}let h_74: bitstring = (if v_550 then 3-proj-3-tuple(v_549) else caught-fail) in
        {1683}let ck_86: key = (if v_550 then 2-proj-3-tuple(v_549) else caught-fail) in
        {1684}let cs_74: cipherstate = (if v_550 then 1-proj-3-tuple(v_549) else caught-fail) in
        {1685}let output1_15: key = (if v_550 then hmac_hash1(ck_86,input_key_material_15) else caught-fail) in
        {1686}let output2_15: key = (if v_550 then hmac_hash2(ck_86,input_key_material_15) else caught-fail) in
        {1687}let output3_15: key = (if v_550 then hmac_hash3(ck_86,input_key_material_15) else caught-fail) in
        {1688}let v_551: bitstring = (if v_550 then catch-fail((output1_15,output2_15,output3_15)) else caught-fail) in
        {1689}let v_552: bool = (not-caught-fail(v_551) && success?(1-proj-3-tuple(v_551))) in
        {1690}let output_12: key = (if v_552 then 3-proj-3-tuple(v_551) else caught-fail) in
        {1691}let temp_k_12: key = (if v_552 then 2-proj-3-tuple(v_551) else caught-fail) in
        {1692}let ck_87: key = (if v_552 then 1-proj-3-tuple(v_551) else caught-fail) in
        {1693}let ss_87: symmetricstate = (if v_545 then catch-fail((if v_548 then (if v_550 then (if v_552 then symmetricstatepack(cipherstatepack(temp_k_12,minnonce),ck_87,h_74) else fail-any) else fail-any) else fail-any)) else caught-fail) in
        {1694}let v_553: bool = not-caught-fail(ss_87) in
        {1695}let v_554: bitstring = (if v_553 then catch-fail(keypairunpack(m_21)) else caught-fail) in
        {1696}let v_555: bool = (not-caught-fail(v_554) && success?(1-proj-2-tuple(v_554))) in
        {1697}let my_private_key_13: key = (if v_555 then 2-proj-2-tuple(v_554) else caught-fail) in
        {1698}let my_public_key_13: key = (if v_555 then 1-proj-2-tuple(v_554) else caught-fail) in
        {1699}let input_key_material_16: key = (if v_553 then catch-fail((if v_555 then dhexp(my_private_key_13,re_23) else fail-any)) else caught-fail) in
        {1700}let v_556: bool = not-caught-fail(input_key_material_16) in
        {1701}let v_557: bitstring = (if v_556 then catch-fail(symmetricstateunpack(ss_87)) else caught-fail) in
        {1702}let v_558: bool = (not-caught-fail(v_557) && success?(1-proj-3-tuple(v_557))) in
        {1703}let h_75: bitstring = (if v_558 then 3-proj-3-tuple(v_557) else caught-fail) in
        {1704}let ck_88: key = (if v_558 then 2-proj-3-tuple(v_557) else caught-fail) in
        {1705}let cs_75: cipherstate = (if v_558 then 1-proj-3-tuple(v_557) else caught-fail) in
        {1706}let output1_16: key = (if v_558 then hmac_hash1(ck_88,input_key_material_16) else caught-fail) in
        {1707}let output2_16: key = (if v_558 then hmac_hash2(ck_88,input_key_material_16) else caught-fail) in
        {1708}let output3_16: key = (if v_558 then hmac_hash3(ck_88,input_key_material_16) else caught-fail) in
        {1709}let v_559: bitstring = (if v_558 then catch-fail((output1_16,output2_16,output3_16)) else caught-fail) in
        {1710}let v_560: bool = (not-caught-fail(v_559) && success?(1-proj-3-tuple(v_559))) in
        {1711}let output_13: key = (if v_560 then 3-proj-3-tuple(v_559) else caught-fail) in
        {1712}let temp_k_13: key = (if v_560 then 2-proj-3-tuple(v_559) else caught-fail) in
        {1713}let ck_89: key = (if v_560 then 1-proj-3-tuple(v_559) else caught-fail) in
        {1714}let ss_88: symmetricstate = (if v_553 then catch-fail((if v_556 then (if v_558 then (if v_560 then symmetricstatepack(cipherstatepack(temp_k_13,minnonce),ck_89,h_75) else fail-any) else fail-any) else fail-any)) else caught-fail) in
        {1715}let v_561: bool = not-caught-fail(ss_88) in
        {1716}let v_562: bitstring = (if v_561 then catch-fail(symmetricstateunpack(ss_88)) else caught-fail) in
        {1717}let v_563: bool = (not-caught-fail(v_562) && success?(1-proj-3-tuple(v_562))) in
        {1718}let h_76: bitstring = (if v_563 then 3-proj-3-tuple(v_562) else caught-fail) in
        {1719}let ck_90: key = (if v_563 then 2-proj-3-tuple(v_562) else caught-fail) in
        {1720}let cs_76: cipherstate = (if v_563 then 1-proj-3-tuple(v_562) else caught-fail) in
        {1721}let v_564: bitstring = (if v_563 then catch-fail(cipherstateunpack(cs_76)) else caught-fail) in
        {1722}let v_565: bool = (not-caught-fail(v_564) && success?(1-proj-2-tuple(v_564))) in
        {1723}let n_36: nonce = (if v_565 then 2-proj-2-tuple(v_564) else caught-fail) in
        {1724}let k_40: key = (if v_565 then 1-proj-2-tuple(v_564) else caught-fail) in
        {1725}let d_8: aead = (if v_565 then catch-fail(decrypt(k_40,n_36,h_76,ciphertext_33)) else caught-fail) in
        {1726}let v_566: bool = not-caught-fail(d_8) in
        {1727}let v_567: bitstring = (if v_566 then catch-fail(aeadunpack(d_8)) else caught-fail) in
        {1728}let v_568: bool = (not-caught-fail(v_567) && success?(1-proj-3-tuple(v_567))) in
        {1729}let plaintext_25: bitstring = (if v_568 then 3-proj-3-tuple(v_567) else caught-fail) in
        {1730}let adi_8: bitstring = (if v_568 then 2-proj-3-tuple(v_567) else caught-fail) in
        {1731}let valid_23: bool = (if v_568 then 1-proj-3-tuple(v_567) else caught-fail) in
        {1732}let n_37: nonce = (if v_568 then increment_nonce(n_36) else caught-fail) in
        {1733}let v_569: bitstring = (if v_568 then catch-fail(cipherstateunpack(cs_76)) else caught-fail) in
        {1734}let v_570: bool = (not-caught-fail(v_569) && success?(1-proj-2-tuple(v_569))) in
        {1735}let o_18: nonce = (if v_570 then 2-proj-2-tuple(v_569) else caught-fail) in
        {1736}let k_41: key = (if v_570 then 1-proj-2-tuple(v_569) else caught-fail) in
        {1737}let csi_36: cipherstate = (if v_568 then catch-fail((if v_570 then cipherstatepack(k_41,n_37) else fail-any)) else caught-fail) in
        {1738}let v_571: bool = not-caught-fail(csi_36) in
        {1739}let v_572: bitstring = (if v_563 then catch-fail((if v_565 then (if v_566 then (if v_568 then (if v_571 then (csi_36,plaintext_25,valid_23) else fail-any) else fail-any) else fail-any) else fail-any)) else caught-fail) in
        {1740}let v_573: bool = (not-caught-fail(v_572) && success?(1-proj-3-tuple(v_572))) in
        {1741}let valid_24: bool = (if v_573 then 3-proj-3-tuple(v_572) else caught-fail) in
        {1742}let plaintext_26: bitstring = (if v_573 then 2-proj-3-tuple(v_572) else caught-fail) in
        {1743}let csi_37: cipherstate = (if v_573 then 1-proj-3-tuple(v_572) else caught-fail) in
        {1744}let ss_89: symmetricstate = (if v_573 then symmetricstatepack(csi_37,ck_90,h_76) else caught-fail) in
        {1745}let v_574: bitstring = (if v_573 then catch-fail(symmetricstateunpack(ss_89)) else caught-fail) in
        {1746}let v_575: bool = (not-caught-fail(v_574) && success?(1-proj-3-tuple(v_574))) in
        {1747}let h_77: bitstring = (if v_575 then 3-proj-3-tuple(v_574) else caught-fail) in
        {1748}let ck_91: key = (if v_575 then 2-proj-3-tuple(v_574) else caught-fail) in
        {1749}let cs_77: cipherstate = (if v_575 then 1-proj-3-tuple(v_574) else caught-fail) in
        {1750}let ssi_21: symmetricstate = (if v_573 then catch-fail((if v_575 then symmetricstatepack(cs_77,ck_91,hash(h_77,ciphertext_33)) else fail-any)) else caught-fail) in
        {1751}let v_576: bool = not-caught-fail(ssi_21) in
        {1752}let v_577: bitstring = (if v_561 then catch-fail((if v_563 then (if v_573 then (if v_576 then (ssi_21,plaintext_26,valid_24) else fail-any) else fail-any) else fail-any)) else caught-fail) in
        {1753}let v_578: bool = (not-caught-fail(v_577) && success?(1-proj-3-tuple(v_577))) in
        {1754}let valid2_7: bool = (if v_578 then 3-proj-3-tuple(v_577) else caught-fail) in
        {1755}let plaintext_27: bitstring = (if v_578 then 2-proj-3-tuple(v_577) else caught-fail) in
        {1756}let ss_90: symmetricstate = (if v_578 then 1-proj-3-tuple(v_577) else caught-fail) in
        {1757}let v_579: bool = (if v_578 then catch-fail((valid1_8 && valid2_7)) else caught-fail) in
        {1758}let hs_56: handshakestate = (if v_579 then handshakestatepack(ss_90,s_19,m_21,e_32,rs_19,rm_20,re_23,psk_19,initiator_16) else caught-fail) in
        {1759}let (hs_57: handshakestate,plaintext_a_1: bitstring,valid_25: bool) = (if v_540 then (if v_542 then (if v_545 then (if v_553 then (if v_561 then (if v_578 then (if undo-catch-fail(v_579) then (hs_56,plaintext_27,true) else fail-any) else fail-any) else fail-any) else fail-any) else fail-any) else fail-any) else fail-any) in
        {1760}event RecvMsg(me_3,them_3,stagepack_a(sid_4),plaintext_a_1);
        {1761}insert statestore(me_3,them_3,sid_4,statepack_b(hs_57))
    ) | (
        {1854}get statestore(=me_3,=them_3,=sid_4,statepack_b(hs_58: handshakestate)) in
        {1763}let payload_8: bitstring = msg_b(me_3,them_3,sid_4) in
        {1764}let v_580: bitstring = catch-fail(handshakestateunpack(hs_58)) in
        {1765}let v_581: bool = (not-caught-fail(v_580) && success?(1-proj-9-tuple(v_580))) in
        {1766}let initiator_17: bool = (if v_581 then 9-proj-9-tuple(v_580) else caught-fail) in
        {1767}let psk_20: key = (if v_581 then 8-proj-9-tuple(v_580) else caught-fail) in
        {1768}let re_24: key = (if v_581 then 7-proj-9-tuple(v_580) else caught-fail) in
        {1769}let rm_21: key = (if v_581 then 6-proj-9-tuple(v_580) else caught-fail) in
        {1770}let rs_20: key = (if v_581 then 5-proj-9-tuple(v_580) else caught-fail) in
        {1771}let e_33: keypair = (if v_581 then 4-proj-9-tuple(v_580) else caught-fail) in
        {1772}let m_22: keypair = (if v_581 then 3-proj-9-tuple(v_580) else caught-fail) in
        {1773}let s_20: keypair = (if v_581 then 2-proj-9-tuple(v_580) else caught-fail) in
        {1774}let ss_91: symmetricstate = (if v_581 then 1-proj-9-tuple(v_580) else caught-fail) in
        {1775}let v_582: bitstring = (if v_581 then catch-fail((empty,empty,empty)) else caught-fail) in
        {1776}let v_583: bool = (not-caught-fail(v_582) && success?(1-proj-3-tuple(v_582))) in
        {1777}let ciphertext_34: bitstring = (if v_583 then 3-proj-3-tuple(v_582) else caught-fail) in
        {1778}let ns_16: bitstring = (if v_583 then 2-proj-3-tuple(v_582) else caught-fail) in
        {1779}let ne_16: bitstring = (if v_583 then 1-proj-3-tuple(v_582) else caught-fail) in
        {1780}let basis_14: key = (if v_583 then key_e(me_3,them_3,sid_4) else caught-fail) in
        {1781}let public_key_14: key = (if v_583 then catch-fail(dhexp(basis_14,validkey(g))) else caught-fail) in
        {1782}let v_584: bool = not-caught-fail(public_key_14) in
        {1783}let e_34: keypair = (if v_583 then catch-fail((if v_584 then keypairpack(validkey(public_key_14),basis_14) else fail-any)) else caught-fail) in
        {1784}let v_585: bool = not-caught-fail(e_34) in
        {1785}let ne_17: bitstring = (if v_585 then catch-fail(getpublickey(e_34)) else caught-fail) in
        {1786}let v_586: bool = not-caught-fail(ne_17) in
        {1787}let v_587: bitstring = (if v_586 then catch-fail(symmetricstateunpack(ss_91)) else caught-fail) in
        {1788}let v_588: bool = (not-caught-fail(v_587) && success?(1-proj-3-tuple(v_587))) in
        {1789}let h_78: bitstring = (if v_588 then 3-proj-3-tuple(v_587) else caught-fail) in
        {1790}let ck_92: key = (if v_588 then 2-proj-3-tuple(v_587) else caught-fail) in
        {1791}let cs_78: cipherstate = (if v_588 then 1-proj-3-tuple(v_587) else caught-fail) in
        {1792}let ss_92: symmetricstate = (if v_586 then catch-fail((if v_588 then symmetricstatepack(cs_78,ck_92,hash(h_78,ne_17)) else fail-any)) else caught-fail) in
        {1793}let v_589: bool = not-caught-fail(ss_92) in
        {1794}let v_590: bitstring = (if v_589 then catch-fail(keypairunpack(e_34)) else caught-fail) in
        {1795}let v_591: bool = (not-caught-fail(v_590) && success?(1-proj-2-tuple(v_590))) in
        {1796}let my_private_key_14: key = (if v_591 then 2-proj-2-tuple(v_590) else caught-fail) in
        {1797}let my_public_key_14: key = (if v_591 then 1-proj-2-tuple(v_590) else caught-fail) in
        {1798}let input_key_material_17: key = (if v_589 then catch-fail((if v_591 then dhexp(my_private_key_14,re_24) else fail-any)) else caught-fail) in
        {1799}let v_592: bool = not-caught-fail(input_key_material_17) in
        {1800}let v_593: bitstring = (if v_592 then catch-fail(symmetricstateunpack(ss_92)) else caught-fail) in
        {1801}let v_594: bool = (not-caught-fail(v_593) && success?(1-proj-3-tuple(v_593))) in
        {1802}let h_79: bitstring = (if v_594 then 3-proj-3-tuple(v_593) else caught-fail) in
        {1803}let ck_93: key = (if v_594 then 2-proj-3-tuple(v_593) else caught-fail) in
        {1804}let cs_79: cipherstate = (if v_594 then 1-proj-3-tuple(v_593) else caught-fail) in
        {1805}let output1_17: key = (if v_594 then hmac_hash1(ck_93,input_key_material_17) else caught-fail) in
        {1806}let output2_17: key = (if v_594 then hmac_hash2(ck_93,input_key_material_17) else caught-fail) in
        {1807}let output3_17: key = (if v_594 then hmac_hash3(ck_93,input_key_material_17) else caught-fail) in
        {1808}let v_595: bitstring = (if v_594 then catch-fail((output1_17,output2_17,output3_17)) else caught-fail) in
        {1809}let v_596: bool = (not-caught-fail(v_595) && success?(1-proj-3-tuple(v_595))) in
        {1810}let output_14: key = (if v_596 then 3-proj-3-tuple(v_595) else caught-fail) in
        {1811}let temp_k_14: key = (if v_596 then 2-proj-3-tuple(v_595) else caught-fail) in
        {1812}let ck_94: key = (if v_596 then 1-proj-3-tuple(v_595) else caught-fail) in
        {1813}let ss_93: symmetricstate = (if v_589 then catch-fail((if v_592 then (if v_594 then (if v_596 then symmetricstatepack(cipherstatepack(temp_k_14,minnonce),ck_94,h_79) else fail-any) else fail-any) else fail-any)) else caught-fail) in
        {1814}let v_597: bool = not-caught-fail(ss_93) in
        {1815}let v_598: bitstring = (if v_597 then catch-fail(symmetricstateunpack(ss_93)) else caught-fail) in
        {1816}let v_599: bool = (not-caught-fail(v_598) && success?(1-proj-3-tuple(v_598))) in
        {1817}let h_80: bitstring = (if v_599 then 3-proj-3-tuple(v_598) else caught-fail) in
        {1818}let ck_95: key = (if v_599 then 2-proj-3-tuple(v_598) else caught-fail) in
        {1819}let cs_80: cipherstate = (if v_599 then 1-proj-3-tuple(v_598) else caught-fail) in
        {1820}let v_600: bitstring = (if v_599 then catch-fail(cipherstateunpack(cs_80)) else caught-fail) in
        {1821}let v_601: bool = (not-caught-fail(v_600) && success?(1-proj-2-tuple(v_600))) in
        {1822}let n_38: nonce = (if v_601 then 2-proj-2-tuple(v_600) else caught-fail) in
        {1823}let k_42: key = (if v_601 then 1-proj-2-tuple(v_600) else caught-fail) in
        {1824}let e_35: bitstring = (if v_601 then encrypt(k_42,n_38,h_80,payload_8) else caught-fail) in
        {1825}let n_39: nonce = (if v_601 then increment_nonce(n_38) else caught-fail) in
        {1826}let v_602: bitstring = (if v_601 then catch-fail(cipherstateunpack(cs_80)) else caught-fail) in
        {1827}let v_603: bool = (not-caught-fail(v_602) && success?(1-proj-2-tuple(v_602))) in
        {1828}let o_19: nonce = (if v_603 then 2-proj-2-tuple(v_602) else caught-fail) in
        {1829}let k_43: key = (if v_603 then 1-proj-2-tuple(v_602) else caught-fail) in
        {1830}let csi_38: cipherstate = (if v_601 then catch-fail((if v_603 then cipherstatepack(k_43,n_39) else fail-any)) else caught-fail) in
        {1831}let v_604: bool = not-caught-fail(csi_38) in
        {1832}let v_605: bitstring = (if v_599 then catch-fail((if v_601 then (if v_604 then (csi_38,e_35) else fail-any) else fail-any)) else caught-fail) in
        {1833}let v_606: bool = (not-caught-fail(v_605) && success?(1-proj-2-tuple(v_605))) in
        {1834}let ciphertext_35: bitstring = (if v_606 then 2-proj-2-tuple(v_605) else caught-fail) in
        {1835}let csi_39: cipherstate = (if v_606 then 1-proj-2-tuple(v_605) else caught-fail) in
        {1836}let ss_94: symmetricstate = (if v_606 then symmetricstatepack(csi_39,ck_95,h_80) else caught-fail) in
        {1837}let v_607: bitstring = (if v_606 then catch-fail(symmetricstateunpack(ss_94)) else caught-fail) in
        {1838}let v_608: bool = (not-caught-fail(v_607) && success?(1-proj-3-tuple(v_607))) in
        {1839}let h_81: bitstring = (if v_608 then 3-proj-3-tuple(v_607) else caught-fail) in
        {1840}let ck_96: key = (if v_608 then 2-proj-3-tuple(v_607) else caught-fail) in
        {1841}let cs_81: cipherstate = (if v_608 then 1-proj-3-tuple(v_607) else caught-fail) in
        {1842}let ssi_22: symmetricstate = (if v_606 then catch-fail((if v_608 then symmetricstatepack(cs_81,ck_96,hash(h_81,ciphertext_35)) else fail-any)) else caught-fail) in
        {1843}let v_609: bool = not-caught-fail(ssi_22) in
        {1844}let v_610: bitstring = (if v_597 then catch-fail((if v_599 then (if v_606 then (if v_609 then (ssi_22,ciphertext_35) else fail-any) else fail-any) else fail-any)) else caught-fail) in
        {1845}let v_611: bool = (not-caught-fail(v_610) && success?(1-proj-2-tuple(v_610))) in
        {1846}let ciphertext_36: bitstring = (if v_611 then 2-proj-2-tuple(v_610) else caught-fail) in
        {1847}let ss_95: symmetricstate = (if v_611 then 1-proj-2-tuple(v_610) else caught-fail) in
        {1848}let hs_59: handshakestate = (if v_611 then handshakestatepack(ss_95,s_20,m_22,e_34,rs_20,rm_21,re_24,psk_20,initiator_17) else caught-fail) in
        {1849}let message_buffer_8: bitstring = (if v_611 then concat3(ne_17,ns_16,ciphertext_36) else caught-fail) in
        {1850}let (hs_60: handshakestate,message_b_3: bitstring) = (if v_581 then (if v_583 then (if v_585 then (if v_586 then (if v_589 then (if v_597 then (if v_611 then (hs_59,message_buffer_8) else fail-any) else fail-any) else fail-any) else fail-any) else fail-any) else fail-any) else fail-any) in
        {1851}event SendMsg(me_3,them_3,stagepack_b(sid_4),msg_b(me_3,them_3,sid_4));
        {1852}insert statestore(me_3,them_3,sid_4,statepack_c(hs_60));
        {1853}out(pub, message_b_3)
    ) | (
        {2006}get statestore(=me_3,=them_3,=sid_4,statepack_c(hs_61: handshakestate)) in
        {1855}in(pub, message_c_3: bitstring);
        {1856}let v_612: bitstring = catch-fail(handshakestateunpack(hs_61)) in
        {1857}let v_613: bool = (not-caught-fail(v_612) && success?(1-proj-9-tuple(v_612))) in
        {1858}let initiator_18: bool = (if v_613 then 9-proj-9-tuple(v_612) else caught-fail) in
        {1859}let psk_21: key = (if v_613 then 8-proj-9-tuple(v_612) else caught-fail) in
        {1860}let re_25: key = (if v_613 then 7-proj-9-tuple(v_612) else caught-fail) in
        {1861}let rm_22: key = (if v_613 then 6-proj-9-tuple(v_612) else caught-fail) in
        {1862}let rs_21: key = (if v_613 then 5-proj-9-tuple(v_612) else caught-fail) in
        {1863}let e_36: keypair = (if v_613 then 4-proj-9-tuple(v_612) else caught-fail) in
        {1864}let m_23: keypair = (if v_613 then 3-proj-9-tuple(v_612) else caught-fail) in
        {1865}let s_21: keypair = (if v_613 then 2-proj-9-tuple(v_612) else caught-fail) in
        {1866}let ss_96: symmetricstate = (if v_613 then 1-proj-9-tuple(v_612) else caught-fail) in
        {1867}let v_614: bitstring = (if v_613 then catch-fail(deconcat3(message_c_3)) else caught-fail) in
        {1868}let v_615: bool = (not-caught-fail(v_614) && success?(1-proj-3-tuple(v_614))) in
        {1869}let ciphertext_37: bitstring = (if v_615 then 3-proj-3-tuple(v_614) else caught-fail) in
        {1870}let nm_5: bitstring = (if v_615 then 2-proj-3-tuple(v_614) else caught-fail) in
        {1871}let ns_17: bitstring = (if v_615 then 1-proj-3-tuple(v_614) else caught-fail) in
        {1872}let valid1_9: bool = (if v_615 then true else caught-fail) in
        {1873}let v_616: bitstring = (if v_615 then catch-fail(symmetricstateunpack(ss_96)) else caught-fail) in
        {1874}let v_617: bool = (not-caught-fail(v_616) && success?(1-proj-3-tuple(v_616))) in
        {1875}let h_82: bitstring = (if v_617 then 3-proj-3-tuple(v_616) else caught-fail) in
        {1876}let ck_97: key = (if v_617 then 2-proj-3-tuple(v_616) else caught-fail) in
        {1877}let cs_82: cipherstate = (if v_617 then 1-proj-3-tuple(v_616) else caught-fail) in
        {1878}let v_618: bitstring = (if v_617 then catch-fail(cipherstateunpack(cs_82)) else caught-fail) in
        {1879}let v_619: bool = (not-caught-fail(v_618) && success?(1-proj-2-tuple(v_618))) in
        {1880}let n_40: nonce = (if v_619 then 2-proj-2-tuple(v_618) else caught-fail) in
        {1881}let k_44: key = (if v_619 then 1-proj-2-tuple(v_618) else caught-fail) in
        {1882}let d_9: aead = (if v_619 then catch-fail(decrypt(k_44,n_40,h_82,nm_5)) else caught-fail) in
        {1883}let v_620: bool = not-caught-fail(d_9) in
        {1884}let v_621: bitstring = (if v_620 then catch-fail(aeadunpack(d_9)) else caught-fail) in
        {1885}let v_622: bool = (not-caught-fail(v_621) && success?(1-proj-3-tuple(v_621))) in
        {1886}let plaintext_28: bitstring = (if v_622 then 3-proj-3-tuple(v_621) else caught-fail) in
        {1887}let adi_9: bitstring = (if v_622 then 2-proj-3-tuple(v_621) else caught-fail) in
        {1888}let valid_26: bool = (if v_622 then 1-proj-3-tuple(v_621) else caught-fail) in
        {1889}let n_41: nonce = (if v_622 then increment_nonce(n_40) else caught-fail) in
        {1890}let v_623: bitstring = (if v_622 then catch-fail(cipherstateunpack(cs_82)) else caught-fail) in
        {1891}let v_624: bool = (not-caught-fail(v_623) && success?(1-proj-2-tuple(v_623))) in
        {1892}let o_20: nonce = (if v_624 then 2-proj-2-tuple(v_623) else caught-fail) in
        {1893}let k_45: key = (if v_624 then 1-proj-2-tuple(v_623) else caught-fail) in
        {1894}let csi_40: cipherstate = (if v_622 then catch-fail((if v_624 then cipherstatepack(k_45,n_41) else fail-any)) else caught-fail) in
        {1895}let v_625: bool = not-caught-fail(csi_40) in
        {1896}let v_626: bitstring = (if v_617 then catch-fail((if v_619 then (if v_620 then (if v_622 then (if v_625 then (csi_40,plaintext_28,valid_26) else fail-any) else fail-any) else fail-any) else fail-any)) else caught-fail) in
        {1897}let v_627: bool = (not-caught-fail(v_626) && success?(1-proj-3-tuple(v_626))) in
        {1898}let valid_27: bool = (if v_627 then 3-proj-3-tuple(v_626) else caught-fail) in
        {1899}let plaintext_29: bitstring = (if v_627 then 2-proj-3-tuple(v_626) else caught-fail) in
        {1900}let csi_41: cipherstate = (if v_627 then 1-proj-3-tuple(v_626) else caught-fail) in
        {1901}let ss_97: symmetricstate = (if v_627 then symmetricstatepack(csi_41,ck_97,h_82) else caught-fail) in
        {1902}let v_628: bitstring = (if v_627 then catch-fail(symmetricstateunpack(ss_97)) else caught-fail) in
        {1903}let v_629: bool = (not-caught-fail(v_628) && success?(1-proj-3-tuple(v_628))) in
        {1904}let h_83: bitstring = (if v_629 then 3-proj-3-tuple(v_628) else caught-fail) in
        {1905}let ck_98: key = (if v_629 then 2-proj-3-tuple(v_628) else caught-fail) in
        {1906}let cs_83: cipherstate = (if v_629 then 1-proj-3-tuple(v_628) else caught-fail) in
        {1907}let ssi_23: symmetricstate = (if v_627 then catch-fail((if v_629 then symmetricstatepack(cs_83,ck_98,hash(h_83,nm_5)) else fail-any)) else caught-fail) in
        {1908}let v_630: bool = not-caught-fail(ssi_23) in
        {1909}let v_631: bitstring = (if v_615 then catch-fail((if v_617 then (if v_627 then (if v_630 then (ssi_23,plaintext_29,valid_27) else fail-any) else fail-any) else fail-any)) else caught-fail) in
        {1910}let v_632: bool = (not-caught-fail(v_631) && success?(1-proj-3-tuple(v_631))) in
        {1911}let valid1_10: bool = (if v_632 then 3-proj-3-tuple(v_631) else caught-fail) in
        {1912}let nem_1: bitstring = (if v_632 then 2-proj-3-tuple(v_631) else caught-fail) in
        {1913}let ss_98: symmetricstate = (if v_632 then 1-proj-3-tuple(v_631) else caught-fail) in
        {1914}let rm_23: key = (if v_632 then nem_1 else caught-fail) in
        {1915}let v_633: bitstring = (if v_632 then catch-fail(keypairunpack(e_36)) else caught-fail) in
        {1916}let v_634: bool = (not-caught-fail(v_633) && success?(1-proj-2-tuple(v_633))) in
        {1917}let my_private_key_15: key = (if v_634 then 2-proj-2-tuple(v_633) else caught-fail) in
        {1918}let my_public_key_15: key = (if v_634 then 1-proj-2-tuple(v_633) else caught-fail) in
        {1919}let input_key_material_18: key = (if v_632 then catch-fail((if v_634 then dhexp(my_private_key_15,rm_23) else fail-any)) else caught-fail) in
        {1920}let v_635: bool = not-caught-fail(input_key_material_18) in
        {1921}let v_636: bitstring = (if v_635 then catch-fail(symmetricstateunpack(ss_98)) else caught-fail) in
        {1922}let v_637: bool = (not-caught-fail(v_636) && success?(1-proj-3-tuple(v_636))) in
        {1923}let h_84: bitstring = (if v_637 then 3-proj-3-tuple(v_636) else caught-fail) in
        {1924}let ck_99: key = (if v_637 then 2-proj-3-tuple(v_636) else caught-fail) in
        {1925}let cs_84: cipherstate = (if v_637 then 1-proj-3-tuple(v_636) else caught-fail) in
        {1926}let output1_18: key = (if v_637 then hmac_hash1(ck_99,input_key_material_18) else caught-fail) in
        {1927}let output2_18: key = (if v_637 then hmac_hash2(ck_99,input_key_material_18) else caught-fail) in
        {1928}let output3_18: key = (if v_637 then hmac_hash3(ck_99,input_key_material_18) else caught-fail) in
        {1929}let v_638: bitstring = (if v_637 then catch-fail((output1_18,output2_18,output3_18)) else caught-fail) in
        {1930}let v_639: bool = (not-caught-fail(v_638) && success?(1-proj-3-tuple(v_638))) in
        {1931}let output_15: key = (if v_639 then 3-proj-3-tuple(v_638) else caught-fail) in
        {1932}let temp_k_15: key = (if v_639 then 2-proj-3-tuple(v_638) else caught-fail) in
        {1933}let ck_100: key = (if v_639 then 1-proj-3-tuple(v_638) else caught-fail) in
        {1934}let ss_99: symmetricstate = (if v_632 then catch-fail((if v_635 then (if v_637 then (if v_639 then symmetricstatepack(cipherstatepack(temp_k_15,minnonce),ck_100,h_84) else fail-any) else fail-any) else fail-any)) else caught-fail) in
        {1935}let v_640: bool = not-caught-fail(ss_99) in
        {1936}let v_641: bitstring = (if v_640 then catch-fail(symmetricstateunpack(ss_99)) else caught-fail) in
        {1937}let v_642: bool = (not-caught-fail(v_641) && success?(1-proj-3-tuple(v_641))) in
        {1938}let h_85: bitstring = (if v_642 then 3-proj-3-tuple(v_641) else caught-fail) in
        {1939}let ck_101: key = (if v_642 then 2-proj-3-tuple(v_641) else caught-fail) in
        {1940}let cs_85: cipherstate = (if v_642 then 1-proj-3-tuple(v_641) else caught-fail) in
        {1941}let v_643: bitstring = (if v_642 then catch-fail(cipherstateunpack(cs_85)) else caught-fail) in
        {1942}let v_644: bool = (not-caught-fail(v_643) && success?(1-proj-2-tuple(v_643))) in
        {1943}let n_42: nonce = (if v_644 then 2-proj-2-tuple(v_643) else caught-fail) in
        {1944}let k_46: key = (if v_644 then 1-proj-2-tuple(v_643) else caught-fail) in
        {1945}let d_10: aead = (if v_644 then catch-fail(decrypt(k_46,n_42,h_85,ciphertext_37)) else caught-fail) in
        {1946}let v_645: bool = not-caught-fail(d_10) in
        {1947}let v_646: bitstring = (if v_645 then catch-fail(aeadunpack(d_10)) else caught-fail) in
        {1948}let v_647: bool = (not-caught-fail(v_646) && success?(1-proj-3-tuple(v_646))) in
        {1949}let plaintext_30: bitstring = (if v_647 then 3-proj-3-tuple(v_646) else caught-fail) in
        {1950}let adi_10: bitstring = (if v_647 then 2-proj-3-tuple(v_646) else caught-fail) in
        {1951}let valid_28: bool = (if v_647 then 1-proj-3-tuple(v_646) else caught-fail) in
        {1952}let n_43: nonce = (if v_647 then increment_nonce(n_42) else caught-fail) in
        {1953}let v_648: bitstring = (if v_647 then catch-fail(cipherstateunpack(cs_85)) else caught-fail) in
        {1954}let v_649: bool = (not-caught-fail(v_648) && success?(1-proj-2-tuple(v_648))) in
        {1955}let o_21: nonce = (if v_649 then 2-proj-2-tuple(v_648) else caught-fail) in
        {1956}let k_47: key = (if v_649 then 1-proj-2-tuple(v_648) else caught-fail) in
        {1957}let csi_42: cipherstate = (if v_647 then catch-fail((if v_649 then cipherstatepack(k_47,n_43) else fail-any)) else caught-fail) in
        {1958}let v_650: bool = not-caught-fail(csi_42) in
        {1959}let v_651: bitstring = (if v_642 then catch-fail((if v_644 then (if v_645 then (if v_647 then (if v_650 then (csi_42,plaintext_30,valid_28) else fail-any) else fail-any) else fail-any) else fail-any)) else caught-fail) in
        {1960}let v_652: bool = (not-caught-fail(v_651) && success?(1-proj-3-tuple(v_651))) in
        {1961}let valid_29: bool = (if v_652 then 3-proj-3-tuple(v_651) else caught-fail) in
        {1962}let plaintext_31: bitstring = (if v_652 then 2-proj-3-tuple(v_651) else caught-fail) in
        {1963}let csi_43: cipherstate = (if v_652 then 1-proj-3-tuple(v_651) else caught-fail) in
        {1964}let ss_100: symmetricstate = (if v_652 then symmetricstatepack(csi_43,ck_101,h_85) else caught-fail) in
        {1965}let v_653: bitstring = (if v_652 then catch-fail(symmetricstateunpack(ss_100)) else caught-fail) in
        {1966}let v_654: bool = (not-caught-fail(v_653) && success?(1-proj-3-tuple(v_653))) in
        {1967}let h_86: bitstring = (if v_654 then 3-proj-3-tuple(v_653) else caught-fail) in
        {1968}let ck_102: key = (if v_654 then 2-proj-3-tuple(v_653) else caught-fail) in
        {1969}let cs_86: cipherstate = (if v_654 then 1-proj-3-tuple(v_653) else caught-fail) in
        {1970}let ssi_24: symmetricstate = (if v_652 then catch-fail((if v_654 then symmetricstatepack(cs_86,ck_102,hash(h_86,ciphertext_37)) else fail-any)) else caught-fail) in
        {1971}let v_655: bool = not-caught-fail(ssi_24) in
        {1972}let v_656: bitstring = (if v_640 then catch-fail((if v_642 then (if v_652 then (if v_655 then (ssi_24,plaintext_31,valid_29) else fail-any) else fail-any) else fail-any)) else caught-fail) in
        {1973}let v_657: bool = (not-caught-fail(v_656) && success?(1-proj-3-tuple(v_656))) in
        {1974}let valid2_8: bool = (if v_657 then 3-proj-3-tuple(v_656) else caught-fail) in
        {1975}let plaintext_32: bitstring = (if v_657 then 2-proj-3-tuple(v_656) else caught-fail) in
        {1976}let ss_101: symmetricstate = (if v_657 then 1-proj-3-tuple(v_656) else caught-fail) in
        {1977}let basis_15: key = (if v_657 then key_s(them_3) else caught-fail) in
        {1978}let public_key_15: key = (if v_657 then catch-fail(dhexp(basis_15,validkey(g))) else caught-fail) in
        {1979}let v_658: bool = not-caught-fail(public_key_15) in
        {1980}let v_659: bool = (if v_657 then catch-fail(((valid1_10 && valid2_8) && (rs_21 = getpublickey((if v_658 then keypairpack(validkey(public_key_15),basis_15) else fail-any))))) else caught-fail) in
        {1981}let hs_62: handshakestate = (if v_659 then handshakestatepack(ss_101,s_21,m_23,e_36,rs_21,rm_23,re_25,psk_21,initiator_18) else caught-fail) in
        {1982}let v_660: bitstring = (if v_659 then catch-fail(symmetricstateunpack(ss_101)) else caught-fail) in
        {1983}let v_661: bool = (not-caught-fail(v_660) && success?(1-proj-3-tuple(v_660))) in
        {1984}let h_87: bitstring = (if v_661 then 3-proj-3-tuple(v_660) else caught-fail) in
        {1985}let ck_103: key = (if v_661 then 2-proj-3-tuple(v_660) else caught-fail) in
        {1986}let cs_87: cipherstate = (if v_661 then 1-proj-3-tuple(v_660) else caught-fail) in
        {1987}let input_key_material_19: key = (if v_661 then zero else caught-fail) in
        {1988}let output1_19: key = (if v_661 then hmac_hash1(ck_103,input_key_material_19) else caught-fail) in
        {1989}let output2_19: key = (if v_661 then hmac_hash2(ck_103,input_key_material_19) else caught-fail) in
        {1990}let output3_19: key = (if v_661 then hmac_hash3(ck_103,input_key_material_19) else caught-fail) in
        {1991}let v_662: bitstring = (if v_661 then catch-fail((output1_19,output2_19,output3_19)) else caught-fail) in
        {1992}let v_663: bool = (not-caught-fail(v_662) && success?(1-proj-3-tuple(v_662))) in
        {1993}let temp_k3_3: key = (if v_663 then 3-proj-3-tuple(v_662) else caught-fail) in
        {1994}let temp_k2_3: key = (if v_663 then 2-proj-3-tuple(v_662) else caught-fail) in
        {1995}let temp_k1_3: key = (if v_663 then 1-proj-3-tuple(v_662) else caught-fail) in
        {1996}let cs1_15: cipherstate = (if v_663 then cipherstatepack(temp_k1_3,minnonce) else caught-fail) in
        {1997}let cs2_15: cipherstate = (if v_663 then cipherstatepack(temp_k2_3,minnonce) else caught-fail) in
        {1998}let v_664: bitstring = (if v_659 then catch-fail((if v_661 then (if v_663 then (ss_101,cs1_15,cs2_15) else fail-any) else fail-any)) else caught-fail) in
        {1999}let v_665: bool = (not-caught-fail(v_664) && success?(1-proj-3-tuple(v_664))) in
        {2000}let cs2_16: cipherstate = (if v_665 then 3-proj-3-tuple(v_664) else caught-fail) in
        {2001}let cs1_16: cipherstate = (if v_665 then 2-proj-3-tuple(v_664) else caught-fail) in
        {2002}let ssi_25: symmetricstate = (if v_665 then 1-proj-3-tuple(v_664) else caught-fail) in
        {2003}let (hs_63: handshakestate,plaintext_c_1: bitstring,valid_30: bool,cs1_17: cipherstate,cs2_17: cipherstate) = (if v_613 then (if v_615 then (if v_632 then (if v_640 then (if v_657 then (if undo-catch-fail(v_659) then (if v_665 then (hs_62,plaintext_32,true,cs1_16,cs2_16) else fail-any) else fail-any) else fail-any) else fail-any) else fail-any) else fail-any) else fail-any) in
        {2004}event RecvMsg(me_3,them_3,stagepack_c(sid_4),plaintext_c_1);
        {2005}insert statestore(me_3,them_3,sid_4,statepack_d(hs_63,cs1_17,cs2_17))
    ) | (
        {2007}!
        {2065}get statestore(=me_3,=them_3,=sid_4,statepack_d(hs_64: handshakestate,cs1_18: cipherstate,cs2_18: cipherstate)) in
        {2008}let hs_65: handshakestate = handshakestatesetcs(hs_64,cs2_18) in
        {2009}let payload_9: bitstring = msg_d(me_3,them_3,sid_4) in
        {2010}let v_666: bitstring = catch-fail(handshakestateunpack(hs_65)) in
        {2011}let v_667: bool = (not-caught-fail(v_666) && success?(1-proj-9-tuple(v_666))) in
        {2012}let initiator_19: bool = (if v_667 then 9-proj-9-tuple(v_666) else caught-fail) in
        {2013}let psk_22: key = (if v_667 then 8-proj-9-tuple(v_666) else caught-fail) in
        {2014}let re_26: key = (if v_667 then 7-proj-9-tuple(v_666) else caught-fail) in
        {2015}let rm_24: key = (if v_667 then 6-proj-9-tuple(v_666) else caught-fail) in
        {2016}let rs_22: key = (if v_667 then 5-proj-9-tuple(v_666) else caught-fail) in
        {2017}let e_37: keypair = (if v_667 then 4-proj-9-tuple(v_666) else caught-fail) in
        {2018}let m_24: keypair = (if v_667 then 3-proj-9-tuple(v_666) else caught-fail) in
        {2019}let s_22: keypair = (if v_667 then 2-proj-9-tuple(v_666) else caught-fail) in
        {2020}let ss_102: symmetricstate = (if v_667 then 1-proj-9-tuple(v_666) else caught-fail) in
        {2021}let v_668: bitstring = (if v_667 then catch-fail((empty,empty,empty)) else caught-fail) in
        {2022}let v_669: bool = (not-caught-fail(v_668) && success?(1-proj-3-tuple(v_668))) in
        {2023}let ciphertext_38: bitstring = (if v_669 then 3-proj-3-tuple(v_668) else caught-fail) in
        {2024}let ns_18: bitstring = (if v_669 then 2-proj-3-tuple(v_668) else caught-fail) in
        {2025}let ne_18: bitstring = (if v_669 then 1-proj-3-tuple(v_668) else caught-fail) in
        {2026}let v_670: bitstring = (if v_669 then catch-fail(symmetricstateunpack(ss_102)) else caught-fail) in
        {2027}let v_671: bool = (not-caught-fail(v_670) && success?(1-proj-3-tuple(v_670))) in
        {2028}let h_88: bitstring = (if v_671 then 3-proj-3-tuple(v_670) else caught-fail) in
        {2029}let ck_104: key = (if v_671 then 2-proj-3-tuple(v_670) else caught-fail) in
        {2030}let cs_88: cipherstate = (if v_671 then 1-proj-3-tuple(v_670) else caught-fail) in
        {2031}let v_672: bitstring = (if v_671 then catch-fail(cipherstateunpack(cs_88)) else caught-fail) in
        {2032}let v_673: bool = (not-caught-fail(v_672) && success?(1-proj-2-tuple(v_672))) in
        {2033}let n_44: nonce = (if v_673 then 2-proj-2-tuple(v_672) else caught-fail) in
        {2034}let k_48: key = (if v_673 then 1-proj-2-tuple(v_672) else caught-fail) in
        {2035}let e_38: bitstring = (if v_673 then encrypt(k_48,n_44,h_88,payload_9) else caught-fail) in
        {2036}let n_45: nonce = (if v_673 then increment_nonce(n_44) else caught-fail) in
        {2037}let v_674: bitstring = (if v_673 then catch-fail(cipherstateunpack(cs_88)) else caught-fail) in
        {2038}let v_675: bool = (not-caught-fail(v_674) && success?(1-proj-2-tuple(v_674))) in
        {2039}let o_22: nonce = (if v_675 then 2-proj-2-tuple(v_674) else caught-fail) in
        {2040}let k_49: key = (if v_675 then 1-proj-2-tuple(v_674) else caught-fail) in
        {2041}let csi_44: cipherstate = (if v_673 then catch-fail((if v_675 then cipherstatepack(k_49,n_45) else fail-any)) else caught-fail) in
        {2042}let v_676: bool = not-caught-fail(csi_44) in
        {2043}let v_677: bitstring = (if v_671 then catch-fail((if v_673 then (if v_676 then (csi_44,e_38) else fail-any) else fail-any)) else caught-fail) in
        {2044}let v_678: bool = (not-caught-fail(v_677) && success?(1-proj-2-tuple(v_677))) in
        {2045}let ciphertext_39: bitstring = (if v_678 then 2-proj-2-tuple(v_677) else caught-fail) in
        {2046}let csi_45: cipherstate = (if v_678 then 1-proj-2-tuple(v_677) else caught-fail) in
        {2047}let ss_103: symmetricstate = (if v_678 then symmetricstatepack(csi_45,ck_104,h_88) else caught-fail) in
        {2048}let v_679: bitstring = (if v_678 then catch-fail(symmetricstateunpack(ss_103)) else caught-fail) in
        {2049}let v_680: bool = (not-caught-fail(v_679) && success?(1-proj-3-tuple(v_679))) in
        {2050}let h_89: bitstring = (if v_680 then 3-proj-3-tuple(v_679) else caught-fail) in
        {2051}let ck_105: key = (if v_680 then 2-proj-3-tuple(v_679) else caught-fail) in
        {2052}let cs_89: cipherstate = (if v_680 then 1-proj-3-tuple(v_679) else caught-fail) in
        {2053}let ssi_26: symmetricstate = (if v_678 then catch-fail((if v_680 then symmetricstatepack(cs_89,ck_105,hash(h_89,ciphertext_39)) else fail-any)) else caught-fail) in
        {2054}let v_681: bool = not-caught-fail(ssi_26) in
        {2055}let v_682: bitstring = (if v_669 then catch-fail((if v_671 then (if v_678 then (if v_681 then (ssi_26,ciphertext_39) else fail-any) else fail-any) else fail-any)) else caught-fail) in
        {2056}let v_683: bool = (not-caught-fail(v_682) && success?(1-proj-2-tuple(v_682))) in
        {2057}let ciphertext_40: bitstring = (if v_683 then 2-proj-2-tuple(v_682) else caught-fail) in
        {2058}let ss_104: symmetricstate = (if v_683 then 1-proj-2-tuple(v_682) else caught-fail) in
        {2059}let hs_66: handshakestate = (if v_683 then handshakestatepack(ss_104,s_22,m_24,e_37,rs_22,rm_24,re_26,psk_22,initiator_19) else caught-fail) in
        {2060}let message_buffer_9: bitstring = (if v_683 then concat3(ne_18,ns_18,ciphertext_40) else caught-fail) in
        {2061}let (hs_67: handshakestate,message_d_3: bitstring) = (if v_667 then (if v_669 then (if v_683 then (hs_66,message_buffer_9) else fail-any) else fail-any) else fail-any) in
        {2062}event SendMsg(me_3,them_3,stagepack_d(sid_4),msg_d(me_3,them_3,sid_4));
        {2063}insert statestore(me_3,them_3,sid_4,statepack_e(hs_67,cs1_18,handshakestategetcs(hs_67)));
        {2064}out(pub, message_d_3)
    ) | (
        {2066}!
        {2132}get statestore(=me_3,=them_3,=sid_4,statepack_e(hs_68: handshakestate,cs1_19: cipherstate,cs2_19: cipherstate)) in
        {2067}let hs_69: handshakestate = handshakestatesetcs(hs_68,cs1_19) in
        {2068}in(pub, message_e_3: bitstring);
        {2069}let v_684: bitstring = catch-fail(handshakestateunpack(hs_69)) in
        {2070}let v_685: bool = (not-caught-fail(v_684) && success?(1-proj-9-tuple(v_684))) in
        {2071}let initiator_20: bool = (if v_685 then 9-proj-9-tuple(v_684) else caught-fail) in
        {2072}let psk_23: key = (if v_685 then 8-proj-9-tuple(v_684) else caught-fail) in
        {2073}let re_27: key = (if v_685 then 7-proj-9-tuple(v_684) else caught-fail) in
        {2074}let rm_25: key = (if v_685 then 6-proj-9-tuple(v_684) else caught-fail) in
        {2075}let rs_23: key = (if v_685 then 5-proj-9-tuple(v_684) else caught-fail) in
        {2076}let e_39: keypair = (if v_685 then 4-proj-9-tuple(v_684) else caught-fail) in
        {2077}let m_25: keypair = (if v_685 then 3-proj-9-tuple(v_684) else caught-fail) in
        {2078}let s_23: keypair = (if v_685 then 2-proj-9-tuple(v_684) else caught-fail) in
        {2079}let ss_105: symmetricstate = (if v_685 then 1-proj-9-tuple(v_684) else caught-fail) in
        {2080}let v_686: bitstring = (if v_685 then catch-fail(deconcat3(message_e_3)) else caught-fail) in
        {2081}let v_687: bool = (not-caught-fail(v_686) && success?(1-proj-3-tuple(v_686))) in
        {2082}let ciphertext_41: bitstring = (if v_687 then 3-proj-3-tuple(v_686) else caught-fail) in
        {2083}let ns_19: bitstring = (if v_687 then 2-proj-3-tuple(v_686) else caught-fail) in
        {2084}let ne_19: bitstring = (if v_687 then 1-proj-3-tuple(v_686) else caught-fail) in
        {2085}let valid1_11: bool = (if v_687 then true else caught-fail) in
        {2086}let v_688: bitstring = (if v_687 then catch-fail(symmetricstateunpack(ss_105)) else caught-fail) in
        {2087}let v_689: bool = (not-caught-fail(v_688) && success?(1-proj-3-tuple(v_688))) in
        {2088}let h_90: bitstring = (if v_689 then 3-proj-3-tuple(v_688) else caught-fail) in
        {2089}let ck_106: key = (if v_689 then 2-proj-3-tuple(v_688) else caught-fail) in
        {2090}let cs_90: cipherstate = (if v_689 then 1-proj-3-tuple(v_688) else caught-fail) in
        {2091}let v_690: bitstring = (if v_689 then catch-fail(cipherstateunpack(cs_90)) else caught-fail) in
        {2092}let v_691: bool = (not-caught-fail(v_690) && success?(1-proj-2-tuple(v_690))) in
        {2093}let n_46: nonce = (if v_691 then 2-proj-2-tuple(v_690) else caught-fail) in
        {2094}let k_50: key = (if v_691 then 1-proj-2-tuple(v_690) else caught-fail) in
        {2095}let d_11: aead = (if v_691 then catch-fail(decrypt(k_50,n_46,h_90,ciphertext_41)) else caught-fail) in
        {2096}let v_692: bool = not-caught-fail(d_11) in
        {2097}let v_693: bitstring = (if v_692 then catch-fail(aeadunpack(d_11)) else caught-fail) in
        {2098}let v_694: bool = (not-caught-fail(v_693) && success?(1-proj-3-tuple(v_693))) in
        {2099}let plaintext_33: bitstring = (if v_694 then 3-proj-3-tuple(v_693) else caught-fail) in
        {2100}let adi_11: bitstring = (if v_694 then 2-proj-3-tuple(v_693) else caught-fail) in
        {2101}let valid_31: bool = (if v_694 then 1-proj-3-tuple(v_693) else caught-fail) in
        {2102}let n_47: nonce = (if v_694 then increment_nonce(n_46) else caught-fail) in
        {2103}let v_695: bitstring = (if v_694 then catch-fail(cipherstateunpack(cs_90)) else caught-fail) in
        {2104}let v_696: bool = (not-caught-fail(v_695) && success?(1-proj-2-tuple(v_695))) in
        {2105}let o_23: nonce = (if v_696 then 2-proj-2-tuple(v_695) else caught-fail) in
        {2106}let k_51: key = (if v_696 then 1-proj-2-tuple(v_695) else caught-fail) in
        {2107}let csi_46: cipherstate = (if v_694 then catch-fail((if v_696 then cipherstatepack(k_51,n_47) else fail-any)) else caught-fail) in
        {2108}let v_697: bool = not-caught-fail(csi_46) in
        {2109}let v_698: bitstring = (if v_689 then catch-fail((if v_691 then (if v_692 then (if v_694 then (if v_697 then (csi_46,plaintext_33,valid_31) else fail-any) else fail-any) else fail-any) else fail-any)) else caught-fail) in
        {2110}let v_699: bool = (not-caught-fail(v_698) && success?(1-proj-3-tuple(v_698))) in
        {2111}let valid_32: bool = (if v_699 then 3-proj-3-tuple(v_698) else caught-fail) in
        {2112}let plaintext_34: bitstring = (if v_699 then 2-proj-3-tuple(v_698) else caught-fail) in
        {2113}let csi_47: cipherstate = (if v_699 then 1-proj-3-tuple(v_698) else caught-fail) in
        {2114}let ss_106: symmetricstate = (if v_699 then symmetricstatepack(csi_47,ck_106,h_90) else caught-fail) in
        {2115}let v_700: bitstring = (if v_699 then catch-fail(symmetricstateunpack(ss_106)) else caught-fail) in
        {2116}let v_701: bool = (not-caught-fail(v_700) && success?(1-proj-3-tuple(v_700))) in
        {2117}let h_91: bitstring = (if v_701 then 3-proj-3-tuple(v_700) else caught-fail) in
        {2118}let ck_107: key = (if v_701 then 2-proj-3-tuple(v_700) else caught-fail) in
        {2119}let cs_91: cipherstate = (if v_701 then 1-proj-3-tuple(v_700) else caught-fail) in
        {2120}let ssi_27: symmetricstate = (if v_699 then catch-fail((if v_701 then symmetricstatepack(cs_91,ck_107,hash(h_91,ciphertext_41)) else fail-any)) else caught-fail) in
        {2121}let v_702: bool = not-caught-fail(ssi_27) in
        {2122}let v_703: bitstring = (if v_687 then catch-fail((if v_689 then (if v_699 then (if v_702 then (ssi_27,plaintext_34,valid_32) else fail-any) else fail-any) else fail-any)) else caught-fail) in
        {2123}let v_704: bool = (not-caught-fail(v_703) && success?(1-proj-3-tuple(v_703))) in
        {2124}let valid2_9: bool = (if v_704 then 3-proj-3-tuple(v_703) else caught-fail) in
        {2125}let plaintext_35: bitstring = (if v_704 then 2-proj-3-tuple(v_703) else caught-fail) in
        {2126}let ss_107: symmetricstate = (if v_704 then 1-proj-3-tuple(v_703) else caught-fail) in
        {2127}let v_705: bool = (if v_704 then catch-fail((valid1_11 && valid2_9)) else caught-fail) in
        {2128}let hs_70: handshakestate = (if v_705 then handshakestatepack(ss_107,s_23,m_25,e_39,rs_23,rm_25,re_27,psk_23,initiator_20) else caught-fail) in
        {2129}let (hs_71: handshakestate,plaintext_e_1: bitstring,valid_33: bool) = (if v_685 then (if v_687 then (if v_704 then (if undo-catch-fail(v_705) then (hs_70,plaintext_35,true) else fail-any) else fail-any) else fail-any) else fail-any) in
        {2130}event RecvMsg(me_3,them_3,stagepack_e(sid_4),plaintext_e_1);
        {2131}event RecvEnd(valid_33)
    ) | (
        {2133}event LeakS(phase0,me_3);
        {2134}event LeakM(phase0,me_3);
        {2135}out(pub, (key_s(me_3),key_m(me_3)))
    ) | (
        {2136}phase 1;
        {2137}event LeakS(phase1,me_3);
        {2138}event LeakM(phase1,me_3);
        {2139}out(pub, (key_s(me_3),key_m(me_3)))
    )
)

--  Process 1 (that is, process 0, with let moved downwards):
{1}out(pub, (key_s(charlie),key_m(charlie)));
{2}!
{3}new sid: sessionid;
(
    {8}let m: keypair = keypairpack(empty,empty) in
    {7}let s: keypair = keypairpack(empty,empty) in
    {9}out(pub, (getpublickey(s),getpublickey(m)));
    {6}let sid_1: sessionid = sid in
    {5}let them: principal = bob in
    {4}let me: principal = alice in
    (
        {11}let basis: key = key_s(them) in
        {12}let public_key: key = catch-fail(dhexp(basis,validkey(g))) in
        {13}let v: bool = not-caught-fail(public_key) in
        {14}let rs: key = getpublickey((if v then keypairpack(validkey(public_key),basis) else fail-any)) in
        {15}let basis_1: key = key_m(them) in
        {16}let public_key_1: key = catch-fail(dhexp(basis_1,validkey(g))) in
        {17}let v_1: bool = not-caught-fail(public_key_1) in
        {18}let rm: key = getpublickey((if v_1 then keypairpack(validkey(public_key_1),basis_1) else fail-any)) in
        {25}let k: key = empty in
        {26}let cs: cipherstate = cipherstatepack(k,minnonce) in
        {22}let protocol_name: bitstring = somename in
        {23}let h: bitstring = hash(protocol_name,empty) in
        {24}let ck: key = h in
        {27}let ss: symmetricstate = symmetricstatepack(cs,ck,h) in
        {28}let v_2: bitstring = catch-fail(symmetricstateunpack(ss)) in
        {29}let v_3: bool = (not-caught-fail(v_2) && success?(1-proj-3-tuple(v_2))) in
        {30}let h_1: bitstring = (if v_3 then 3-proj-3-tuple(v_2) else caught-fail) in
        {31}let ck_1: key = (if v_3 then 2-proj-3-tuple(v_2) else caught-fail) in
        {32}let cs_1: cipherstate = (if v_3 then 1-proj-3-tuple(v_2) else caught-fail) in
        {20}let prologue: bitstring = empty in
        {33}let ss_1: symmetricstate = catch-fail((if v_3 then symmetricstatepack(cs_1,ck_1,hash(h_1,prologue)) else fail-any)) in
        {34}let v_4: bool = not-caught-fail(ss_1) in
        {35}let v_5: bitstring = (if v_4 then catch-fail(symmetricstateunpack(ss_1)) else caught-fail) in
        {36}let v_6: bool = (not-caught-fail(v_5) && success?(1-proj-3-tuple(v_5))) in
        {37}let h_2: bitstring = (if v_6 then 3-proj-3-tuple(v_5) else caught-fail) in
        {38}let ck_2: key = (if v_6 then 2-proj-3-tuple(v_5) else caught-fail) in
        {39}let cs_2: cipherstate = (if v_6 then 1-proj-3-tuple(v_5) else caught-fail) in
        {40}let ss_2: symmetricstate = (if v_4 then catch-fail((if v_6 then symmetricstatepack(cs_2,ck_2,hash(h_2,rs)) else fail-any)) else caught-fail) in
        {41}let v_7: bool = not-caught-fail(ss_2) in
        {42}let v_8: bitstring = (if v_7 then catch-fail(symmetricstateunpack(ss_2)) else caught-fail) in
        {43}let v_9: bool = (not-caught-fail(v_8) && success?(1-proj-3-tuple(v_8))) in
        {44}let h_3: bitstring = (if v_9 then 3-proj-3-tuple(v_8) else caught-fail) in
        {45}let ck_3: key = (if v_9 then 2-proj-3-tuple(v_8) else caught-fail) in
        {46}let cs_3: cipherstate = (if v_9 then 1-proj-3-tuple(v_8) else caught-fail) in
        {47}let ss_3: symmetricstate = (if v_7 then catch-fail((if v_9 then symmetricstatepack(cs_3,ck_3,hash(h_3,rm)) else fail-any)) else caught-fail) in
        {48}let v_10: bool = not-caught-fail(ss_3) in
        {21}let psk: key = empty in
        {19}let re: key = empty in
        {10}let e: keypair = keypairpack(empty,empty) in
        {49}let hs: handshakestate = (if v_4 then (if v_7 then (if v_10 then handshakestatepack(ss_3,s,m,e,rs,rm,re,psk,true) else fail-any) else fail-any) else fail-any) in
        {50}insert statestore(me,them,sid_1,statepack_a(hs))
    ) | (
        {163}get statestore(=me,=them,=sid_1,statepack_a(hs_1: handshakestate)) in
        {52}let v_11: bitstring = catch-fail(handshakestateunpack(hs_1)) in
        {53}let v_12: bool = (not-caught-fail(v_11) && success?(1-proj-9-tuple(v_11))) in
        {54}let initiator_1: bool = (if v_12 then 9-proj-9-tuple(v_11) else caught-fail) in
        {55}let psk_1: key = (if v_12 then 8-proj-9-tuple(v_11) else caught-fail) in
        {56}let re_1: key = (if v_12 then 7-proj-9-tuple(v_11) else caught-fail) in
        {57}let rm_1: key = (if v_12 then 6-proj-9-tuple(v_11) else caught-fail) in
        {58}let rs_1: key = (if v_12 then 5-proj-9-tuple(v_11) else caught-fail) in
        {59}let e_1: keypair = (if v_12 then 4-proj-9-tuple(v_11) else caught-fail) in
        {60}let m_1: keypair = (if v_12 then 3-proj-9-tuple(v_11) else caught-fail) in
        {61}let s_1: keypair = (if v_12 then 2-proj-9-tuple(v_11) else caught-fail) in
        {62}let ss_4: symmetricstate = (if v_12 then 1-proj-9-tuple(v_11) else caught-fail) in
        {63}let v_13: bitstring = (if v_12 then catch-fail((empty,empty,empty)) else caught-fail) in
        {64}let v_14: bool = (not-caught-fail(v_13) && success?(1-proj-3-tuple(v_13))) in
        {65}let ciphertext: bitstring = (if v_14 then 3-proj-3-tuple(v_13) else caught-fail) in
        {66}let ns: bitstring = (if v_14 then 2-proj-3-tuple(v_13) else caught-fail) in
        {67}let ne: bitstring = (if v_14 then 1-proj-3-tuple(v_13) else caught-fail) in
        {68}let basis_2: key = (if v_14 then key_e(me,them,sid_1) else caught-fail) in
        {69}let public_key_2: key = (if v_14 then catch-fail(dhexp(basis_2,validkey(g))) else caught-fail) in
        {70}let v_15: bool = not-caught-fail(public_key_2) in
        {71}let e_2: keypair = (if v_14 then catch-fail((if v_15 then keypairpack(validkey(public_key_2),basis_2) else fail-any)) else caught-fail) in
        {72}let v_16: bool = not-caught-fail(e_2) in
        {73}let ne_1: bitstring = (if v_16 then catch-fail(getpublickey(e_2)) else caught-fail) in
        {74}let v_17: bool = not-caught-fail(ne_1) in
        {75}let v_18: bitstring = (if v_17 then catch-fail(symmetricstateunpack(ss_4)) else caught-fail) in
        {76}let v_19: bool = (not-caught-fail(v_18) && success?(1-proj-3-tuple(v_18))) in
        {77}let h_4: bitstring = (if v_19 then 3-proj-3-tuple(v_18) else caught-fail) in
        {78}let ck_4: key = (if v_19 then 2-proj-3-tuple(v_18) else caught-fail) in
        {79}let cs_4: cipherstate = (if v_19 then 1-proj-3-tuple(v_18) else caught-fail) in
        {80}let ss_5: symmetricstate = (if v_17 then catch-fail((if v_19 then symmetricstatepack(cs_4,ck_4,hash(h_4,ne_1)) else fail-any)) else caught-fail) in
        {81}let v_20: bool = not-caught-fail(ss_5) in
        {82}let v_21: bitstring = (if v_20 then catch-fail(keypairunpack(e_2)) else caught-fail) in
        {83}let v_22: bool = (not-caught-fail(v_21) && success?(1-proj-2-tuple(v_21))) in
        {84}let my_private_key: key = (if v_22 then 2-proj-2-tuple(v_21) else caught-fail) in
        {85}let my_public_key: key = (if v_22 then 1-proj-2-tuple(v_21) else caught-fail) in
        {86}let input_key_material: key = (if v_20 then catch-fail((if v_22 then dhexp(my_private_key,rs_1) else fail-any)) else caught-fail) in
        {87}let v_23: bool = not-caught-fail(input_key_material) in
        {88}let v_24: bitstring = (if v_23 then catch-fail(symmetricstateunpack(ss_5)) else caught-fail) in
        {89}let v_25: bool = (not-caught-fail(v_24) && success?(1-proj-3-tuple(v_24))) in
        {90}let h_5: bitstring = (if v_25 then 3-proj-3-tuple(v_24) else caught-fail) in
        {91}let ck_5: key = (if v_25 then 2-proj-3-tuple(v_24) else caught-fail) in
        {92}let cs_5: cipherstate = (if v_25 then 1-proj-3-tuple(v_24) else caught-fail) in
        {95}let output3: key = (if v_25 then hmac_hash3(ck_5,input_key_material) else caught-fail) in
        {94}let output2: key = (if v_25 then hmac_hash2(ck_5,input_key_material) else caught-fail) in
        {93}let output1: key = (if v_25 then hmac_hash1(ck_5,input_key_material) else caught-fail) in
        {96}let v_26: bitstring = (if v_25 then catch-fail((output1,output2,output3)) else caught-fail) in
        {97}let v_27: bool = (not-caught-fail(v_26) && success?(1-proj-3-tuple(v_26))) in
        {98}let output_3: key = (if v_27 then 3-proj-3-tuple(v_26) else caught-fail) in
        {99}let temp_k: key = (if v_27 then 2-proj-3-tuple(v_26) else caught-fail) in
        {100}let ck_6: key = (if v_27 then 1-proj-3-tuple(v_26) else caught-fail) in
        {101}let ss_6: symmetricstate = (if v_20 then catch-fail((if v_23 then (if v_25 then (if v_27 then symmetricstatepack(cipherstatepack(temp_k,minnonce),ck_6,h_5) else fail-any) else fail-any) else fail-any)) else caught-fail) in
        {102}let v_28: bool = not-caught-fail(ss_6) in
        {103}let v_29: bitstring = (if v_28 then catch-fail(keypairunpack(e_2)) else caught-fail) in
        {104}let v_30: bool = (not-caught-fail(v_29) && success?(1-proj-2-tuple(v_29))) in
        {105}let my_private_key_1: key = (if v_30 then 2-proj-2-tuple(v_29) else caught-fail) in
        {106}let my_public_key_1: key = (if v_30 then 1-proj-2-tuple(v_29) else caught-fail) in
        {107}let input_key_material_1: key = (if v_28 then catch-fail((if v_30 then dhexp(my_private_key_1,rm_1) else fail-any)) else caught-fail) in
        {108}let v_31: bool = not-caught-fail(input_key_material_1) in
        {109}let v_32: bitstring = (if v_31 then catch-fail(symmetricstateunpack(ss_6)) else caught-fail) in
        {110}let v_33: bool = (not-caught-fail(v_32) && success?(1-proj-3-tuple(v_32))) in
        {111}let h_6: bitstring = (if v_33 then 3-proj-3-tuple(v_32) else caught-fail) in
        {112}let ck_7: key = (if v_33 then 2-proj-3-tuple(v_32) else caught-fail) in
        {113}let cs_6: cipherstate = (if v_33 then 1-proj-3-tuple(v_32) else caught-fail) in
        {116}let output3_1: key = (if v_33 then hmac_hash3(ck_7,input_key_material_1) else caught-fail) in
        {115}let output2_1: key = (if v_33 then hmac_hash2(ck_7,input_key_material_1) else caught-fail) in
        {114}let output1_1: key = (if v_33 then hmac_hash1(ck_7,input_key_material_1) else caught-fail) in
        {117}let v_34: bitstring = (if v_33 then catch-fail((output1_1,output2_1,output3_1)) else caught-fail) in
        {118}let v_35: bool = (not-caught-fail(v_34) && success?(1-proj-3-tuple(v_34))) in
        {119}let output: key = (if v_35 then 3-proj-3-tuple(v_34) else caught-fail) in
        {120}let temp_k_1: key = (if v_35 then 2-proj-3-tuple(v_34) else caught-fail) in
        {121}let ck_8: key = (if v_35 then 1-proj-3-tuple(v_34) else caught-fail) in
        {122}let ss_7: symmetricstate = (if v_28 then catch-fail((if v_31 then (if v_33 then (if v_35 then symmetricstatepack(cipherstatepack(temp_k_1,minnonce),ck_8,h_6) else fail-any) else fail-any) else fail-any)) else caught-fail) in
        {123}let v_36: bool = not-caught-fail(ss_7) in
        {124}let v_37: bitstring = (if v_36 then catch-fail(symmetricstateunpack(ss_7)) else caught-fail) in
        {125}let v_38: bool = (not-caught-fail(v_37) && success?(1-proj-3-tuple(v_37))) in
        {126}let h_7: bitstring = (if v_38 then 3-proj-3-tuple(v_37) else caught-fail) in
        {127}let ck_9: key = (if v_38 then 2-proj-3-tuple(v_37) else caught-fail) in
        {128}let cs_7: cipherstate = (if v_38 then 1-proj-3-tuple(v_37) else caught-fail) in
        {129}let v_39: bitstring = (if v_38 then catch-fail(cipherstateunpack(cs_7)) else caught-fail) in
        {130}let v_40: bool = (not-caught-fail(v_39) && success?(1-proj-2-tuple(v_39))) in
        {131}let n: nonce = (if v_40 then 2-proj-2-tuple(v_39) else caught-fail) in
        {132}let k_1: key = (if v_40 then 1-proj-2-tuple(v_39) else caught-fail) in
        {135}let v_41: bitstring = (if v_40 then catch-fail(cipherstateunpack(cs_7)) else caught-fail) in
        {136}let v_42: bool = (not-caught-fail(v_41) && success?(1-proj-2-tuple(v_41))) in
        {137}let o: nonce = (if v_42 then 2-proj-2-tuple(v_41) else caught-fail) in
        {138}let k_2: key = (if v_42 then 1-proj-2-tuple(v_41) else caught-fail) in
        {134}let n_1: nonce = (if v_40 then increment_nonce(n) else caught-fail) in
        {139}let csi: cipherstate = (if v_40 then catch-fail((if v_42 then cipherstatepack(k_2,n_1) else fail-any)) else caught-fail) in
        {140}let v_43: bool = not-caught-fail(csi) in
        {51}let payload: bitstring = msg_a(me,them,sid_1) in
        {133}let e_3: bitstring = (if v_40 then encrypt(k_1,n,h_7,payload) else caught-fail) in
        {141}let v_44: bitstring = (if v_38 then catch-fail((if v_40 then (if v_43 then (csi,e_3) else fail-any) else fail-any)) else caught-fail) in
        {142}let v_45: bool = (not-caught-fail(v_44) && success?(1-proj-2-tuple(v_44))) in
        {143}let ciphertext_1: bitstring = (if v_45 then 2-proj-2-tuple(v_44) else caught-fail) in
        {144}let csi_1: cipherstate = (if v_45 then 1-proj-2-tuple(v_44) else caught-fail) in
        {145}let ss_8: symmetricstate = (if v_45 then symmetricstatepack(csi_1,ck_9,h_7) else caught-fail) in
        {146}let v_46: bitstring = (if v_45 then catch-fail(symmetricstateunpack(ss_8)) else caught-fail) in
        {147}let v_47: bool = (not-caught-fail(v_46) && success?(1-proj-3-tuple(v_46))) in
        {148}let h_8: bitstring = (if v_47 then 3-proj-3-tuple(v_46) else caught-fail) in
        {149}let ck_10: key = (if v_47 then 2-proj-3-tuple(v_46) else caught-fail) in
        {150}let cs_8: cipherstate = (if v_47 then 1-proj-3-tuple(v_46) else caught-fail) in
        {151}let ssi: symmetricstate = (if v_45 then catch-fail((if v_47 then symmetricstatepack(cs_8,ck_10,hash(h_8,ciphertext_1)) else fail-any)) else caught-fail) in
        {152}let v_48: bool = not-caught-fail(ssi) in
        {153}let v_49: bitstring = (if v_36 then catch-fail((if v_38 then (if v_45 then (if v_48 then (ssi,ciphertext_1) else fail-any) else fail-any) else fail-any)) else caught-fail) in
        {154}let v_50: bool = (not-caught-fail(v_49) && success?(1-proj-2-tuple(v_49))) in
        {155}let ciphertext_2: bitstring = (if v_50 then 2-proj-2-tuple(v_49) else caught-fail) in
        {156}let ss_9: symmetricstate = (if v_50 then 1-proj-2-tuple(v_49) else caught-fail) in
        {158}let message_buffer: bitstring = (if v_50 then concat3(ne_1,ns,ciphertext_2) else caught-fail) in
        {157}let hs_2: handshakestate = (if v_50 then handshakestatepack(ss_9,s_1,m_1,e_2,rs_1,rm_1,re_1,psk_1,initiator_1) else caught-fail) in
        {159}let (hs_3: handshakestate,message_a: bitstring) = (if v_12 then (if v_14 then (if v_16 then (if v_17 then (if v_20 then (if v_28 then (if v_36 then (if v_50 then (hs_2,message_buffer) else fail-any) else fail-any) else fail-any) else fail-any) else fail-any) else fail-any) else fail-any) else fail-any) in
        {160}event SendMsg(me,them,stagepack_a(sid_1),msg_a(me,them,sid_1));
        {161}insert statestore(me,them,sid_1,statepack_b(hs_3));
        {162}out(pub, message_a)
    ) | (
        {257}get statestore(=me,=them,=sid_1,statepack_b(hs_4: handshakestate)) in
        {164}in(pub, message_b: bitstring);
        {165}let v_51: bitstring = catch-fail(handshakestateunpack(hs_4)) in
        {166}let v_52: bool = (not-caught-fail(v_51) && success?(1-proj-9-tuple(v_51))) in
        {167}let initiator_2: bool = (if v_52 then 9-proj-9-tuple(v_51) else caught-fail) in
        {168}let psk_2: key = (if v_52 then 8-proj-9-tuple(v_51) else caught-fail) in
        {169}let re_2: key = (if v_52 then 7-proj-9-tuple(v_51) else caught-fail) in
        {170}let rm_2: key = (if v_52 then 6-proj-9-tuple(v_51) else caught-fail) in
        {171}let rs_2: key = (if v_52 then 5-proj-9-tuple(v_51) else caught-fail) in
        {172}let e_4: keypair = (if v_52 then 4-proj-9-tuple(v_51) else caught-fail) in
        {173}let m_2: keypair = (if v_52 then 3-proj-9-tuple(v_51) else caught-fail) in
        {174}let s_2: keypair = (if v_52 then 2-proj-9-tuple(v_51) else caught-fail) in
        {175}let ss_10: symmetricstate = (if v_52 then 1-proj-9-tuple(v_51) else caught-fail) in
        {176}let v_53: bitstring = (if v_52 then catch-fail(deconcat3(message_b)) else caught-fail) in
        {177}let v_54: bool = (not-caught-fail(v_53) && success?(1-proj-3-tuple(v_53))) in
        {178}let ciphertext_3: bitstring = (if v_54 then 3-proj-3-tuple(v_53) else caught-fail) in
        {179}let ns_1: bitstring = (if v_54 then 2-proj-3-tuple(v_53) else caught-fail) in
        {180}let ne_2: bitstring = (if v_54 then 1-proj-3-tuple(v_53) else caught-fail) in
        {183}let v_55: bitstring = (if v_54 then catch-fail(symmetricstateunpack(ss_10)) else caught-fail) in
        {184}let v_56: bool = (not-caught-fail(v_55) && success?(1-proj-3-tuple(v_55))) in
        {185}let h_9: bitstring = (if v_56 then 3-proj-3-tuple(v_55) else caught-fail) in
        {186}let ck_11: key = (if v_56 then 2-proj-3-tuple(v_55) else caught-fail) in
        {187}let cs_9: cipherstate = (if v_56 then 1-proj-3-tuple(v_55) else caught-fail) in
        {182}let re_3: key = (if v_54 then ne_2 else caught-fail) in
        {188}let ss_11: symmetricstate = (if v_54 then catch-fail((if v_56 then symmetricstatepack(cs_9,ck_11,hash(h_9,re_3)) else fail-any)) else caught-fail) in
        {189}let v_57: bool = not-caught-fail(ss_11) in
        {190}let v_58: bitstring = (if v_57 then catch-fail(keypairunpack(e_4)) else caught-fail) in
        {191}let v_59: bool = (not-caught-fail(v_58) && success?(1-proj-2-tuple(v_58))) in
        {192}let my_private_key_2: key = (if v_59 then 2-proj-2-tuple(v_58) else caught-fail) in
        {193}let my_public_key_2: key = (if v_59 then 1-proj-2-tuple(v_58) else caught-fail) in
        {194}let input_key_material_2: key = (if v_57 then catch-fail((if v_59 then dhexp(my_private_key_2,re_3) else fail-any)) else caught-fail) in
        {195}let v_60: bool = not-caught-fail(input_key_material_2) in
        {196}let v_61: bitstring = (if v_60 then catch-fail(symmetricstateunpack(ss_11)) else caught-fail) in
        {197}let v_62: bool = (not-caught-fail(v_61) && success?(1-proj-3-tuple(v_61))) in
        {198}let h_10: bitstring = (if v_62 then 3-proj-3-tuple(v_61) else caught-fail) in
        {199}let ck_12: key = (if v_62 then 2-proj-3-tuple(v_61) else caught-fail) in
        {200}let cs_10: cipherstate = (if v_62 then 1-proj-3-tuple(v_61) else caught-fail) in
        {203}let output3_2: key = (if v_62 then hmac_hash3(ck_12,input_key_material_2) else caught-fail) in
        {202}let output2_2: key = (if v_62 then hmac_hash2(ck_12,input_key_material_2) else caught-fail) in
        {201}let output1_2: key = (if v_62 then hmac_hash1(ck_12,input_key_material_2) else caught-fail) in
        {204}let v_63: bitstring = (if v_62 then catch-fail((output1_2,output2_2,output3_2)) else caught-fail) in
        {205}let v_64: bool = (not-caught-fail(v_63) && success?(1-proj-3-tuple(v_63))) in
        {206}let output_1: key = (if v_64 then 3-proj-3-tuple(v_63) else caught-fail) in
        {207}let temp_k_2: key = (if v_64 then 2-proj-3-tuple(v_63) else caught-fail) in
        {208}let ck_13: key = (if v_64 then 1-proj-3-tuple(v_63) else caught-fail) in
        {209}let ss_12: symmetricstate = (if v_57 then catch-fail((if v_60 then (if v_62 then (if v_64 then symmetricstatepack(cipherstatepack(temp_k_2,minnonce),ck_13,h_10) else fail-any) else fail-any) else fail-any)) else caught-fail) in
        {210}let v_65: bool = not-caught-fail(ss_12) in
        {211}let v_66: bitstring = (if v_65 then catch-fail(symmetricstateunpack(ss_12)) else caught-fail) in
        {212}let v_67: bool = (not-caught-fail(v_66) && success?(1-proj-3-tuple(v_66))) in
        {213}let h_11: bitstring = (if v_67 then 3-proj-3-tuple(v_66) else caught-fail) in
        {214}let ck_14: key = (if v_67 then 2-proj-3-tuple(v_66) else caught-fail) in
        {215}let cs_11: cipherstate = (if v_67 then 1-proj-3-tuple(v_66) else caught-fail) in
        {216}let v_68: bitstring = (if v_67 then catch-fail(cipherstateunpack(cs_11)) else caught-fail) in
        {217}let v_69: bool = (not-caught-fail(v_68) && success?(1-proj-2-tuple(v_68))) in
        {218}let n_2: nonce = (if v_69 then 2-proj-2-tuple(v_68) else caught-fail) in
        {219}let k_3: key = (if v_69 then 1-proj-2-tuple(v_68) else caught-fail) in
        {220}let d: aead = (if v_69 then catch-fail(decrypt(k_3,n_2,h_11,ciphertext_3)) else caught-fail) in
        {221}let v_70: bool = not-caught-fail(d) in
        {222}let v_71: bitstring = (if v_70 then catch-fail(aeadunpack(d)) else caught-fail) in
        {223}let v_72: bool = (not-caught-fail(v_71) && success?(1-proj-3-tuple(v_71))) in
        {224}let plaintext: bitstring = (if v_72 then 3-proj-3-tuple(v_71) else caught-fail) in
        {225}let adi: bitstring = (if v_72 then 2-proj-3-tuple(v_71) else caught-fail) in
        {226}let valid: bool = (if v_72 then 1-proj-3-tuple(v_71) else caught-fail) in
        {228}let v_73: bitstring = (if v_72 then catch-fail(cipherstateunpack(cs_11)) else caught-fail) in
        {229}let v_74: bool = (not-caught-fail(v_73) && success?(1-proj-2-tuple(v_73))) in
        {230}let o_1: nonce = (if v_74 then 2-proj-2-tuple(v_73) else caught-fail) in
        {231}let k_4: key = (if v_74 then 1-proj-2-tuple(v_73) else caught-fail) in
        {227}let n_3: nonce = (if v_72 then increment_nonce(n_2) else caught-fail) in
        {232}let csi_2: cipherstate = (if v_72 then catch-fail((if v_74 then cipherstatepack(k_4,n_3) else fail-any)) else caught-fail) in
        {233}let v_75: bool = not-caught-fail(csi_2) in
        {234}let v_76: bitstring = (if v_67 then catch-fail((if v_69 then (if v_70 then (if v_72 then (if v_75 then (csi_2,plaintext,valid) else fail-any) else fail-any) else fail-any) else fail-any)) else caught-fail) in
        {235}let v_77: bool = (not-caught-fail(v_76) && success?(1-proj-3-tuple(v_76))) in
        {236}let valid_1: bool = (if v_77 then 3-proj-3-tuple(v_76) else caught-fail) in
        {237}let plaintext_1: bitstring = (if v_77 then 2-proj-3-tuple(v_76) else caught-fail) in
        {238}let csi_3: cipherstate = (if v_77 then 1-proj-3-tuple(v_76) else caught-fail) in
        {239}let ss_13: symmetricstate = (if v_77 then symmetricstatepack(csi_3,ck_14,h_11) else caught-fail) in
        {240}let v_78: bitstring = (if v_77 then catch-fail(symmetricstateunpack(ss_13)) else caught-fail) in
        {241}let v_79: bool = (not-caught-fail(v_78) && success?(1-proj-3-tuple(v_78))) in
        {242}let h_12: bitstring = (if v_79 then 3-proj-3-tuple(v_78) else caught-fail) in
        {243}let ck_15: key = (if v_79 then 2-proj-3-tuple(v_78) else caught-fail) in
        {244}let cs_12: cipherstate = (if v_79 then 1-proj-3-tuple(v_78) else caught-fail) in
        {245}let ssi_1: symmetricstate = (if v_77 then catch-fail((if v_79 then symmetricstatepack(cs_12,ck_15,hash(h_12,ciphertext_3)) else fail-any)) else caught-fail) in
        {246}let v_80: bool = not-caught-fail(ssi_1) in
        {247}let v_81: bitstring = (if v_65 then catch-fail((if v_67 then (if v_77 then (if v_80 then (ssi_1,plaintext_1,valid_1) else fail-any) else fail-any) else fail-any)) else caught-fail) in
        {248}let v_82: bool = (not-caught-fail(v_81) && success?(1-proj-3-tuple(v_81))) in
        {249}let valid2: bool = (if v_82 then 3-proj-3-tuple(v_81) else caught-fail) in
        {250}let plaintext_2: bitstring = (if v_82 then 2-proj-3-tuple(v_81) else caught-fail) in
        {251}let ss_14: symmetricstate = (if v_82 then 1-proj-3-tuple(v_81) else caught-fail) in
        {181}let valid1: bool = (if v_54 then true else caught-fail) in
        {252}let v_83: bool = (if v_82 then catch-fail((valid1 && valid2)) else caught-fail) in
        {253}let hs_5: handshakestate = (if v_83 then handshakestatepack(ss_14,s_2,m_2,e_4,rs_2,rm_2,re_3,psk_2,initiator_2) else caught-fail) in
        {254}let (hs_6: handshakestate,plaintext_b: bitstring,valid_2: bool) = (if v_52 then (if v_54 then (if v_57 then (if v_65 then (if v_82 then (if undo-catch-fail(v_83) then (hs_5,plaintext_2,true) else fail-any) else fail-any) else fail-any) else fail-any) else fail-any) else fail-any) in
        {255}event RecvMsg(me,them,stagepack_b(sid_1),plaintext_b);
        {256}insert statestore(me,them,sid_1,statepack_c(hs_6))
    ) | (
        {396}get statestore(=me,=them,=sid_1,statepack_c(hs_7: handshakestate)) in
        {259}let v_84: bitstring = catch-fail(handshakestateunpack(hs_7)) in
        {260}let v_85: bool = (not-caught-fail(v_84) && success?(1-proj-9-tuple(v_84))) in
        {261}let initiator_3: bool = (if v_85 then 9-proj-9-tuple(v_84) else caught-fail) in
        {262}let psk_3: key = (if v_85 then 8-proj-9-tuple(v_84) else caught-fail) in
        {263}let re_4: key = (if v_85 then 7-proj-9-tuple(v_84) else caught-fail) in
        {264}let rm_3: key = (if v_85 then 6-proj-9-tuple(v_84) else caught-fail) in
        {265}let rs_3: key = (if v_85 then 5-proj-9-tuple(v_84) else caught-fail) in
        {266}let e_5: keypair = (if v_85 then 4-proj-9-tuple(v_84) else caught-fail) in
        {267}let m_3: keypair = (if v_85 then 3-proj-9-tuple(v_84) else caught-fail) in
        {268}let s_3: keypair = (if v_85 then 2-proj-9-tuple(v_84) else caught-fail) in
        {269}let ss_15: symmetricstate = (if v_85 then 1-proj-9-tuple(v_84) else caught-fail) in
        {270}let v_86: bitstring = (if v_85 then catch-fail((empty,empty,empty)) else caught-fail) in
        {271}let v_87: bool = (not-caught-fail(v_86) && success?(1-proj-3-tuple(v_86))) in
        {272}let ciphertext_4: bitstring = (if v_87 then 3-proj-3-tuple(v_86) else caught-fail) in
        {273}let nm: bitstring = (if v_87 then 2-proj-3-tuple(v_86) else caught-fail) in
        {274}let ns_2: bitstring = (if v_87 then 1-proj-3-tuple(v_86) else caught-fail) in
        {275}let basis_3: key = (if v_87 then key_m(me) else caught-fail) in
        {276}let public_key_3: key = (if v_87 then catch-fail(dhexp(basis_3,validkey(g))) else caught-fail) in
        {277}let v_88: bool = not-caught-fail(public_key_3) in
        {278}let m_4: keypair = (if v_87 then catch-fail((if v_88 then keypairpack(validkey(public_key_3),basis_3) else fail-any)) else caught-fail) in
        {279}let v_89: bool = not-caught-fail(m_4) in
        {280}let plaintext_3: bitstring = (if v_89 then catch-fail(getpublickey(m_4)) else caught-fail) in
        {281}let v_90: bool = not-caught-fail(plaintext_3) in
        {282}let v_91: bitstring = (if v_90 then catch-fail(symmetricstateunpack(ss_15)) else caught-fail) in
        {283}let v_92: bool = (not-caught-fail(v_91) && success?(1-proj-3-tuple(v_91))) in
        {284}let h_13: bitstring = (if v_92 then 3-proj-3-tuple(v_91) else caught-fail) in
        {285}let ck_16: key = (if v_92 then 2-proj-3-tuple(v_91) else caught-fail) in
        {286}let cs_13: cipherstate = (if v_92 then 1-proj-3-tuple(v_91) else caught-fail) in
        {287}let v_93: bitstring = (if v_92 then catch-fail(cipherstateunpack(cs_13)) else caught-fail) in
        {288}let v_94: bool = (not-caught-fail(v_93) && success?(1-proj-2-tuple(v_93))) in
        {289}let n_4: nonce = (if v_94 then 2-proj-2-tuple(v_93) else caught-fail) in
        {290}let k_5: key = (if v_94 then 1-proj-2-tuple(v_93) else caught-fail) in
        {293}let v_95: bitstring = (if v_94 then catch-fail(cipherstateunpack(cs_13)) else caught-fail) in
        {294}let v_96: bool = (not-caught-fail(v_95) && success?(1-proj-2-tuple(v_95))) in
        {295}let o_2: nonce = (if v_96 then 2-proj-2-tuple(v_95) else caught-fail) in
        {296}let k_6: key = (if v_96 then 1-proj-2-tuple(v_95) else caught-fail) in
        {292}let n_5: nonce = (if v_94 then increment_nonce(n_4) else caught-fail) in
        {297}let csi_4: cipherstate = (if v_94 then catch-fail((if v_96 then cipherstatepack(k_6,n_5) else fail-any)) else caught-fail) in
        {298}let v_97: bool = not-caught-fail(csi_4) in
        {291}let e_6: bitstring = (if v_94 then encrypt(k_5,n_4,h_13,plaintext_3) else caught-fail) in
        {299}let v_98: bitstring = (if v_92 then catch-fail((if v_94 then (if v_97 then (csi_4,e_6) else fail-any) else fail-any)) else caught-fail) in
        {300}let v_99: bool = (not-caught-fail(v_98) && success?(1-proj-2-tuple(v_98))) in
        {301}let ciphertext_5: bitstring = (if v_99 then 2-proj-2-tuple(v_98) else caught-fail) in
        {302}let csi_5: cipherstate = (if v_99 then 1-proj-2-tuple(v_98) else caught-fail) in
        {303}let ss_16: symmetricstate = (if v_99 then symmetricstatepack(csi_5,ck_16,h_13) else caught-fail) in
        {304}let v_100: bitstring = (if v_99 then catch-fail(symmetricstateunpack(ss_16)) else caught-fail) in
        {305}let v_101: bool = (not-caught-fail(v_100) && success?(1-proj-3-tuple(v_100))) in
        {306}let h_14: bitstring = (if v_101 then 3-proj-3-tuple(v_100) else caught-fail) in
        {307}let ck_17: key = (if v_101 then 2-proj-3-tuple(v_100) else caught-fail) in
        {308}let cs_14: cipherstate = (if v_101 then 1-proj-3-tuple(v_100) else caught-fail) in
        {309}let ssi_2: symmetricstate = (if v_99 then catch-fail((if v_101 then symmetricstatepack(cs_14,ck_17,hash(h_14,ciphertext_5)) else fail-any)) else caught-fail) in
        {310}let v_102: bool = not-caught-fail(ssi_2) in
        {311}let v_103: bitstring = (if v_89 then catch-fail((if v_90 then (if v_92 then (if v_99 then (if v_102 then (ssi_2,ciphertext_5) else fail-any) else fail-any) else fail-any) else fail-any)) else caught-fail) in
        {312}let v_104: bool = (not-caught-fail(v_103) && success?(1-proj-2-tuple(v_103))) in
        {313}let nm_1: bitstring = (if v_104 then 2-proj-2-tuple(v_103) else caught-fail) in
        {314}let ss_17: symmetricstate = (if v_104 then 1-proj-2-tuple(v_103) else caught-fail) in
        {315}let v_105: bitstring = (if v_104 then catch-fail(keypairunpack(m_4)) else caught-fail) in
        {316}let v_106: bool = (not-caught-fail(v_105) && success?(1-proj-2-tuple(v_105))) in
        {317}let my_private_key_3: key = (if v_106 then 2-proj-2-tuple(v_105) else caught-fail) in
        {318}let my_public_key_3: key = (if v_106 then 1-proj-2-tuple(v_105) else caught-fail) in
        {319}let input_key_material_3: key = (if v_104 then catch-fail((if v_106 then dhexp(my_private_key_3,re_4) else fail-any)) else caught-fail) in
        {320}let v_107: bool = not-caught-fail(input_key_material_3) in
        {321}let v_108: bitstring = (if v_107 then catch-fail(symmetricstateunpack(ss_17)) else caught-fail) in
        {322}let v_109: bool = (not-caught-fail(v_108) && success?(1-proj-3-tuple(v_108))) in
        {323}let h_15: bitstring = (if v_109 then 3-proj-3-tuple(v_108) else caught-fail) in
        {324}let ck_18: key = (if v_109 then 2-proj-3-tuple(v_108) else caught-fail) in
        {325}let cs_15: cipherstate = (if v_109 then 1-proj-3-tuple(v_108) else caught-fail) in
        {328}let output3_3: key = (if v_109 then hmac_hash3(ck_18,input_key_material_3) else caught-fail) in
        {327}let output2_3: key = (if v_109 then hmac_hash2(ck_18,input_key_material_3) else caught-fail) in
        {326}let output1_3: key = (if v_109 then hmac_hash1(ck_18,input_key_material_3) else caught-fail) in
        {329}let v_110: bitstring = (if v_109 then catch-fail((output1_3,output2_3,output3_3)) else caught-fail) in
        {330}let v_111: bool = (not-caught-fail(v_110) && success?(1-proj-3-tuple(v_110))) in
        {331}let output_2: key = (if v_111 then 3-proj-3-tuple(v_110) else caught-fail) in
        {332}let temp_k_3: key = (if v_111 then 2-proj-3-tuple(v_110) else caught-fail) in
        {333}let ck_19: key = (if v_111 then 1-proj-3-tuple(v_110) else caught-fail) in
        {334}let ss_18: symmetricstate = (if v_104 then catch-fail((if v_107 then (if v_109 then (if v_111 then symmetricstatepack(cipherstatepack(temp_k_3,minnonce),ck_19,h_15) else fail-any) else fail-any) else fail-any)) else caught-fail) in
        {335}let v_112: bool = not-caught-fail(ss_18) in
        {336}let v_113: bitstring = (if v_112 then catch-fail(symmetricstateunpack(ss_18)) else caught-fail) in
        {337}let v_114: bool = (not-caught-fail(v_113) && success?(1-proj-3-tuple(v_113))) in
        {338}let h_16: bitstring = (if v_114 then 3-proj-3-tuple(v_113) else caught-fail) in
        {339}let ck_20: key = (if v_114 then 2-proj-3-tuple(v_113) else caught-fail) in
        {340}let cs_16: cipherstate = (if v_114 then 1-proj-3-tuple(v_113) else caught-fail) in
        {341}let v_115: bitstring = (if v_114 then catch-fail(cipherstateunpack(cs_16)) else caught-fail) in
        {342}let v_116: bool = (not-caught-fail(v_115) && success?(1-proj-2-tuple(v_115))) in
        {343}let n_6: nonce = (if v_116 then 2-proj-2-tuple(v_115) else caught-fail) in
        {344}let k_7: key = (if v_116 then 1-proj-2-tuple(v_115) else caught-fail) in
        {347}let v_117: bitstring = (if v_116 then catch-fail(cipherstateunpack(cs_16)) else caught-fail) in
        {348}let v_118: bool = (not-caught-fail(v_117) && success?(1-proj-2-tuple(v_117))) in
        {349}let o_3: nonce = (if v_118 then 2-proj-2-tuple(v_117) else caught-fail) in
        {350}let k_8: key = (if v_118 then 1-proj-2-tuple(v_117) else caught-fail) in
        {346}let n_7: nonce = (if v_116 then increment_nonce(n_6) else caught-fail) in
        {351}let csi_6: cipherstate = (if v_116 then catch-fail((if v_118 then cipherstatepack(k_8,n_7) else fail-any)) else caught-fail) in
        {352}let v_119: bool = not-caught-fail(csi_6) in
        {258}let payload_1: bitstring = msg_c(me,them,sid_1) in
        {345}let e_7: bitstring = (if v_116 then encrypt(k_7,n_6,h_16,payload_1) else caught-fail) in
        {353}let v_120: bitstring = (if v_114 then catch-fail((if v_116 then (if v_119 then (csi_6,e_7) else fail-any) else fail-any)) else caught-fail) in
        {354}let v_121: bool = (not-caught-fail(v_120) && success?(1-proj-2-tuple(v_120))) in
        {355}let ciphertext_6: bitstring = (if v_121 then 2-proj-2-tuple(v_120) else caught-fail) in
        {356}let csi_7: cipherstate = (if v_121 then 1-proj-2-tuple(v_120) else caught-fail) in
        {357}let ss_19: symmetricstate = (if v_121 then symmetricstatepack(csi_7,ck_20,h_16) else caught-fail) in
        {358}let v_122: bitstring = (if v_121 then catch-fail(symmetricstateunpack(ss_19)) else caught-fail) in
        {359}let v_123: bool = (not-caught-fail(v_122) && success?(1-proj-3-tuple(v_122))) in
        {360}let h_17: bitstring = (if v_123 then 3-proj-3-tuple(v_122) else caught-fail) in
        {361}let ck_21: key = (if v_123 then 2-proj-3-tuple(v_122) else caught-fail) in
        {362}let cs_17: cipherstate = (if v_123 then 1-proj-3-tuple(v_122) else caught-fail) in
        {363}let ssi_3: symmetricstate = (if v_121 then catch-fail((if v_123 then symmetricstatepack(cs_17,ck_21,hash(h_17,ciphertext_6)) else fail-any)) else caught-fail) in
        {364}let v_124: bool = not-caught-fail(ssi_3) in
        {365}let v_125: bitstring = (if v_112 then catch-fail((if v_114 then (if v_121 then (if v_124 then (ssi_3,ciphertext_6) else fail-any) else fail-any) else fail-any)) else caught-fail) in
        {366}let v_126: bool = (not-caught-fail(v_125) && success?(1-proj-2-tuple(v_125))) in
        {367}let ciphertext_7: bitstring = (if v_126 then 2-proj-2-tuple(v_125) else caught-fail) in
        {368}let ss_20: symmetricstate = (if v_126 then 1-proj-2-tuple(v_125) else caught-fail) in
        {371}let v_127: bitstring = (if v_126 then catch-fail(symmetricstateunpack(ss_20)) else caught-fail) in
        {372}let v_128: bool = (not-caught-fail(v_127) && success?(1-proj-3-tuple(v_127))) in
        {373}let h_18: bitstring = (if v_128 then 3-proj-3-tuple(v_127) else caught-fail) in
        {374}let ck_22: key = (if v_128 then 2-proj-3-tuple(v_127) else caught-fail) in
        {375}let cs_18: cipherstate = (if v_128 then 1-proj-3-tuple(v_127) else caught-fail) in
        {376}let input_key_material_4: key = (if v_128 then zero else caught-fail) in
        {379}let output3_4: key = (if v_128 then hmac_hash3(ck_22,input_key_material_4) else caught-fail) in
        {378}let output2_4: key = (if v_128 then hmac_hash2(ck_22,input_key_material_4) else caught-fail) in
        {377}let output1_4: key = (if v_128 then hmac_hash1(ck_22,input_key_material_4) else caught-fail) in
        {380}let v_129: bitstring = (if v_128 then catch-fail((output1_4,output2_4,output3_4)) else caught-fail) in
        {381}let v_130: bool = (not-caught-fail(v_129) && success?(1-proj-3-tuple(v_129))) in
        {382}let temp_k3: key = (if v_130 then 3-proj-3-tuple(v_129) else caught-fail) in
        {383}let temp_k2: key = (if v_130 then 2-proj-3-tuple(v_129) else caught-fail) in
        {384}let temp_k1: key = (if v_130 then 1-proj-3-tuple(v_129) else caught-fail) in
        {386}let cs2: cipherstate = (if v_130 then cipherstatepack(temp_k2,minnonce) else caught-fail) in
        {385}let cs1: cipherstate = (if v_130 then cipherstatepack(temp_k1,minnonce) else caught-fail) in
        {387}let v_131: bitstring = (if v_126 then catch-fail((if v_128 then (if v_130 then (ss_20,cs1,cs2) else fail-any) else fail-any)) else caught-fail) in
        {388}let v_132: bool = (not-caught-fail(v_131) && success?(1-proj-3-tuple(v_131))) in
        {389}let cs2_1: cipherstate = (if v_132 then 3-proj-3-tuple(v_131) else caught-fail) in
        {390}let cs1_1: cipherstate = (if v_132 then 2-proj-3-tuple(v_131) else caught-fail) in
        {391}let ssi_4: symmetricstate = (if v_132 then 1-proj-3-tuple(v_131) else caught-fail) in
        {370}let message_buffer_1: bitstring = (if v_126 then concat3(ns_2,nm_1,ciphertext_7) else caught-fail) in
        {369}let hs_8: handshakestate = (if v_126 then handshakestatepack(ss_20,s_3,m_4,e_5,rs_3,rm_3,re_4,psk_3,initiator_3) else caught-fail) in
        {392}let (hs_9: handshakestate,message_c: bitstring,cs1_2: cipherstate,cs2_2: cipherstate) = (if v_85 then (if v_87 then (if v_89 then (if v_104 then (if v_112 then (if v_126 then (if v_132 then (hs_8,message_buffer_1,cs1_1,cs2_1) else fail-any) else fail-any) else fail-any) else fail-any) else fail-any) else fail-any) else fail-any) in
        {393}event SendMsg(me,them,stagepack_c(sid_1),msg_c(me,them,sid_1));
        {394}insert statestore(me,them,sid_1,statepack_d(hs_9,cs1_2,cs2_2));
        {395}out(pub, message_c)
    ) | (
        {397}!
        {463}get statestore(=me,=them,=sid_1,statepack_d(hs_10: handshakestate,cs1_3: cipherstate,cs2_3: cipherstate)) in
        {398}let hs_11: handshakestate = handshakestatesetcs(hs_10,cs2_3) in
        {399}in(pub, message_d: bitstring);
        {400}let v_133: bitstring = catch-fail(handshakestateunpack(hs_11)) in
        {401}let v_134: bool = (not-caught-fail(v_133) && success?(1-proj-9-tuple(v_133))) in
        {402}let initiator_4: bool = (if v_134 then 9-proj-9-tuple(v_133) else caught-fail) in
        {403}let psk_4: key = (if v_134 then 8-proj-9-tuple(v_133) else caught-fail) in
        {404}let re_5: key = (if v_134 then 7-proj-9-tuple(v_133) else caught-fail) in
        {405}let rm_4: key = (if v_134 then 6-proj-9-tuple(v_133) else caught-fail) in
        {406}let rs_4: key = (if v_134 then 5-proj-9-tuple(v_133) else caught-fail) in
        {407}let e_8: keypair = (if v_134 then 4-proj-9-tuple(v_133) else caught-fail) in
        {408}let m_5: keypair = (if v_134 then 3-proj-9-tuple(v_133) else caught-fail) in
        {409}let s_4: keypair = (if v_134 then 2-proj-9-tuple(v_133) else caught-fail) in
        {410}let ss_21: symmetricstate = (if v_134 then 1-proj-9-tuple(v_133) else caught-fail) in
        {411}let v_135: bitstring = (if v_134 then catch-fail(deconcat3(message_d)) else caught-fail) in
        {412}let v_136: bool = (not-caught-fail(v_135) && success?(1-proj-3-tuple(v_135))) in
        {413}let ciphertext_8: bitstring = (if v_136 then 3-proj-3-tuple(v_135) else caught-fail) in
        {414}let ns_3: bitstring = (if v_136 then 2-proj-3-tuple(v_135) else caught-fail) in
        {415}let ne_3: bitstring = (if v_136 then 1-proj-3-tuple(v_135) else caught-fail) in
        {417}let v_137: bitstring = (if v_136 then catch-fail(symmetricstateunpack(ss_21)) else caught-fail) in
        {418}let v_138: bool = (not-caught-fail(v_137) && success?(1-proj-3-tuple(v_137))) in
        {419}let h_19: bitstring = (if v_138 then 3-proj-3-tuple(v_137) else caught-fail) in
        {420}let ck_23: key = (if v_138 then 2-proj-3-tuple(v_137) else caught-fail) in
        {421}let cs_19: cipherstate = (if v_138 then 1-proj-3-tuple(v_137) else caught-fail) in
        {422}let v_139: bitstring = (if v_138 then catch-fail(cipherstateunpack(cs_19)) else caught-fail) in
        {423}let v_140: bool = (not-caught-fail(v_139) && success?(1-proj-2-tuple(v_139))) in
        {424}let n_8: nonce = (if v_140 then 2-proj-2-tuple(v_139) else caught-fail) in
        {425}let k_9: key = (if v_140 then 1-proj-2-tuple(v_139) else caught-fail) in
        {426}let d_1: aead = (if v_140 then catch-fail(decrypt(k_9,n_8,h_19,ciphertext_8)) else caught-fail) in
        {427}let v_141: bool = not-caught-fail(d_1) in
        {428}let v_142: bitstring = (if v_141 then catch-fail(aeadunpack(d_1)) else caught-fail) in
        {429}let v_143: bool = (not-caught-fail(v_142) && success?(1-proj-3-tuple(v_142))) in
        {430}let plaintext_4: bitstring = (if v_143 then 3-proj-3-tuple(v_142) else caught-fail) in
        {431}let adi_1: bitstring = (if v_143 then 2-proj-3-tuple(v_142) else caught-fail) in
        {432}let valid_3: bool = (if v_143 then 1-proj-3-tuple(v_142) else caught-fail) in
        {434}let v_144: bitstring = (if v_143 then catch-fail(cipherstateunpack(cs_19)) else caught-fail) in
        {435}let v_145: bool = (not-caught-fail(v_144) && success?(1-proj-2-tuple(v_144))) in
        {436}let o_4: nonce = (if v_145 then 2-proj-2-tuple(v_144) else caught-fail) in
        {437}let k_10: key = (if v_145 then 1-proj-2-tuple(v_144) else caught-fail) in
        {433}let n_9: nonce = (if v_143 then increment_nonce(n_8) else caught-fail) in
        {438}let csi_8: cipherstate = (if v_143 then catch-fail((if v_145 then cipherstatepack(k_10,n_9) else fail-any)) else caught-fail) in
        {439}let v_146: bool = not-caught-fail(csi_8) in
        {440}let v_147: bitstring = (if v_138 then catch-fail((if v_140 then (if v_141 then (if v_143 then (if v_146 then (csi_8,plaintext_4,valid_3) else fail-any) else fail-any) else fail-any) else fail-any)) else caught-fail) in
        {441}let v_148: bool = (not-caught-fail(v_147) && success?(1-proj-3-tuple(v_147))) in
        {442}let valid_4: bool = (if v_148 then 3-proj-3-tuple(v_147) else caught-fail) in
        {443}let plaintext_5: bitstring = (if v_148 then 2-proj-3-tuple(v_147) else caught-fail) in
        {444}let csi_9: cipherstate = (if v_148 then 1-proj-3-tuple(v_147) else caught-fail) in
        {445}let ss_22: symmetricstate = (if v_148 then symmetricstatepack(csi_9,ck_23,h_19) else caught-fail) in
        {446}let v_149: bitstring = (if v_148 then catch-fail(symmetricstateunpack(ss_22)) else caught-fail) in
        {447}let v_150: bool = (not-caught-fail(v_149) && success?(1-proj-3-tuple(v_149))) in
        {448}let h_20: bitstring = (if v_150 then 3-proj-3-tuple(v_149) else caught-fail) in
        {449}let ck_24: key = (if v_150 then 2-proj-3-tuple(v_149) else caught-fail) in
        {450}let cs_20: cipherstate = (if v_150 then 1-proj-3-tuple(v_149) else caught-fail) in
        {451}let ssi_5: symmetricstate = (if v_148 then catch-fail((if v_150 then symmetricstatepack(cs_20,ck_24,hash(h_20,ciphertext_8)) else fail-any)) else caught-fail) in
        {452}let v_151: bool = not-caught-fail(ssi_5) in
        {453}let v_152: bitstring = (if v_136 then catch-fail((if v_138 then (if v_148 then (if v_151 then (ssi_5,plaintext_5,valid_4) else fail-any) else fail-any) else fail-any)) else caught-fail) in
        {454}let v_153: bool = (not-caught-fail(v_152) && success?(1-proj-3-tuple(v_152))) in
        {455}let valid2_1: bool = (if v_153 then 3-proj-3-tuple(v_152) else caught-fail) in
        {456}let plaintext_6: bitstring = (if v_153 then 2-proj-3-tuple(v_152) else caught-fail) in
        {457}let ss_23: symmetricstate = (if v_153 then 1-proj-3-tuple(v_152) else caught-fail) in
        {416}let valid1_1: bool = (if v_136 then true else caught-fail) in
        {458}let v_154: bool = (if v_153 then catch-fail((valid1_1 && valid2_1)) else caught-fail) in
        {459}let hs_12: handshakestate = (if v_154 then handshakestatepack(ss_23,s_4,m_5,e_8,rs_4,rm_4,re_5,psk_4,initiator_4) else caught-fail) in
        {460}let (hs_13: handshakestate,plaintext_d: bitstring,valid_5: bool) = (if v_134 then (if v_136 then (if v_153 then (if undo-catch-fail(v_154) then (hs_12,plaintext_6,true) else fail-any) else fail-any) else fail-any) else fail-any) in
        {461}event RecvMsg(me,them,stagepack_d(sid_1),plaintext_d);
        {462}insert statestore(me,them,sid_1,statepack_e(hs_13,cs1_3,handshakestategetcs(hs_13)))
    ) | (
        {464}!
        {521}get statestore(=me,=them,=sid_1,statepack_e(hs_14: handshakestate,cs1_4: cipherstate,cs2_4: cipherstate)) in
        {465}let hs_15: handshakestate = handshakestatesetcs(hs_14,cs1_4) in
        {467}let v_155: bitstring = catch-fail(handshakestateunpack(hs_15)) in
        {468}let v_156: bool = (not-caught-fail(v_155) && success?(1-proj-9-tuple(v_155))) in
        {469}let initiator_5: bool = (if v_156 then 9-proj-9-tuple(v_155) else caught-fail) in
        {470}let psk_5: key = (if v_156 then 8-proj-9-tuple(v_155) else caught-fail) in
        {471}let re_6: key = (if v_156 then 7-proj-9-tuple(v_155) else caught-fail) in
        {472}let rm_5: key = (if v_156 then 6-proj-9-tuple(v_155) else caught-fail) in
        {473}let rs_5: key = (if v_156 then 5-proj-9-tuple(v_155) else caught-fail) in
        {474}let e_9: keypair = (if v_156 then 4-proj-9-tuple(v_155) else caught-fail) in
        {475}let m_6: keypair = (if v_156 then 3-proj-9-tuple(v_155) else caught-fail) in
        {476}let s_5: keypair = (if v_156 then 2-proj-9-tuple(v_155) else caught-fail) in
        {477}let ss_24: symmetricstate = (if v_156 then 1-proj-9-tuple(v_155) else caught-fail) in
        {478}let v_157: bitstring = (if v_156 then catch-fail((empty,empty,empty)) else caught-fail) in
        {479}let v_158: bool = (not-caught-fail(v_157) && success?(1-proj-3-tuple(v_157))) in
        {480}let ciphertext_9: bitstring = (if v_158 then 3-proj-3-tuple(v_157) else caught-fail) in
        {481}let ns_4: bitstring = (if v_158 then 2-proj-3-tuple(v_157) else caught-fail) in
        {482}let ne_4: bitstring = (if v_158 then 1-proj-3-tuple(v_157) else caught-fail) in
        {483}let v_159: bitstring = (if v_158 then catch-fail(symmetricstateunpack(ss_24)) else caught-fail) in
        {484}let v_160: bool = (not-caught-fail(v_159) && success?(1-proj-3-tuple(v_159))) in
        {485}let h_21: bitstring = (if v_160 then 3-proj-3-tuple(v_159) else caught-fail) in
        {486}let ck_25: key = (if v_160 then 2-proj-3-tuple(v_159) else caught-fail) in
        {487}let cs_21: cipherstate = (if v_160 then 1-proj-3-tuple(v_159) else caught-fail) in
        {488}let v_161: bitstring = (if v_160 then catch-fail(cipherstateunpack(cs_21)) else caught-fail) in
        {489}let v_162: bool = (not-caught-fail(v_161) && success?(1-proj-2-tuple(v_161))) in
        {490}let n_10: nonce = (if v_162 then 2-proj-2-tuple(v_161) else caught-fail) in
        {491}let k_11: key = (if v_162 then 1-proj-2-tuple(v_161) else caught-fail) in
        {494}let v_163: bitstring = (if v_162 then catch-fail(cipherstateunpack(cs_21)) else caught-fail) in
        {495}let v_164: bool = (not-caught-fail(v_163) && success?(1-proj-2-tuple(v_163))) in
        {496}let o_5: nonce = (if v_164 then 2-proj-2-tuple(v_163) else caught-fail) in
        {497}let k_12: key = (if v_164 then 1-proj-2-tuple(v_163) else caught-fail) in
        {493}let n_11: nonce = (if v_162 then increment_nonce(n_10) else caught-fail) in
        {498}let csi_10: cipherstate = (if v_162 then catch-fail((if v_164 then cipherstatepack(k_12,n_11) else fail-any)) else caught-fail) in
        {499}let v_165: bool = not-caught-fail(csi_10) in
        {466}let payload_2: bitstring = msg_e(me,them,sid_1) in
        {492}let e_10: bitstring = (if v_162 then encrypt(k_11,n_10,h_21,payload_2) else caught-fail) in
        {500}let v_166: bitstring = (if v_160 then catch-fail((if v_162 then (if v_165 then (csi_10,e_10) else fail-any) else fail-any)) else caught-fail) in
        {501}let v_167: bool = (not-caught-fail(v_166) && success?(1-proj-2-tuple(v_166))) in
        {502}let ciphertext_10: bitstring = (if v_167 then 2-proj-2-tuple(v_166) else caught-fail) in
        {503}let csi_11: cipherstate = (if v_167 then 1-proj-2-tuple(v_166) else caught-fail) in
        {504}let ss_25: symmetricstate = (if v_167 then symmetricstatepack(csi_11,ck_25,h_21) else caught-fail) in
        {505}let v_168: bitstring = (if v_167 then catch-fail(symmetricstateunpack(ss_25)) else caught-fail) in
        {506}let v_169: bool = (not-caught-fail(v_168) && success?(1-proj-3-tuple(v_168))) in
        {507}let h_22: bitstring = (if v_169 then 3-proj-3-tuple(v_168) else caught-fail) in
        {508}let ck_26: key = (if v_169 then 2-proj-3-tuple(v_168) else caught-fail) in
        {509}let cs_22: cipherstate = (if v_169 then 1-proj-3-tuple(v_168) else caught-fail) in
        {510}let ssi_6: symmetricstate = (if v_167 then catch-fail((if v_169 then symmetricstatepack(cs_22,ck_26,hash(h_22,ciphertext_10)) else fail-any)) else caught-fail) in
        {511}let v_170: bool = not-caught-fail(ssi_6) in
        {512}let v_171: bitstring = (if v_158 then catch-fail((if v_160 then (if v_167 then (if v_170 then (ssi_6,ciphertext_10) else fail-any) else fail-any) else fail-any)) else caught-fail) in
        {513}let v_172: bool = (not-caught-fail(v_171) && success?(1-proj-2-tuple(v_171))) in
        {514}let ciphertext_11: bitstring = (if v_172 then 2-proj-2-tuple(v_171) else caught-fail) in
        {515}let ss_26: symmetricstate = (if v_172 then 1-proj-2-tuple(v_171) else caught-fail) in
        {517}let message_buffer_2: bitstring = (if v_172 then concat3(ne_4,ns_4,ciphertext_11) else caught-fail) in
        {516}let hs_16: handshakestate = (if v_172 then handshakestatepack(ss_26,s_5,m_6,e_9,rs_5,rm_5,re_6,psk_5,initiator_5) else caught-fail) in
        {518}let (hs_17: handshakestate,message_e: bitstring) = (if v_156 then (if v_158 then (if v_172 then (hs_16,message_buffer_2) else fail-any) else fail-any) else fail-any) in
        {519}event SendMsg(me,them,stagepack_e(sid_1),msg_e(me,them,sid_1));
        {520}out(pub, message_e)
    ) | (
        {522}event LeakS(phase0,me);
        {523}event LeakM(phase0,me);
        {524}out(pub, (key_s(me),key_m(me)))
    ) | (
        {525}phase 1;
        {526}event LeakS(phase1,me);
        {527}event LeakM(phase1,me);
        {528}out(pub, (key_s(me),key_m(me)))
    )
) | (
    {533}let m_7: keypair = keypairpack(empty,empty) in
    {532}let s_6: keypair = keypairpack(empty,empty) in
    {534}out(pub, (getpublickey(s_6),getpublickey(m_7)));
    {531}let sid_2: sessionid = sid in
    {530}let them_1: principal = charlie in
    {529}let me_1: principal = alice in
    (
        {536}let basis_4: key = key_s(them_1) in
        {537}let public_key_4: key = catch-fail(dhexp(basis_4,validkey(g))) in
        {538}let v_173: bool = not-caught-fail(public_key_4) in
        {539}let rs_6: key = getpublickey((if v_173 then keypairpack(validkey(public_key_4),basis_4) else fail-any)) in
        {540}let basis_5: key = key_m(them_1) in
        {541}let public_key_5: key = catch-fail(dhexp(basis_5,validkey(g))) in
        {542}let v_174: bool = not-caught-fail(public_key_5) in
        {543}let rm_6: key = getpublickey((if v_174 then keypairpack(validkey(public_key_5),basis_5) else fail-any)) in
        {550}let k_13: key = empty in
        {551}let cs_23: cipherstate = cipherstatepack(k_13,minnonce) in
        {547}let protocol_name_1: bitstring = somename in
        {548}let h_23: bitstring = hash(protocol_name_1,empty) in
        {549}let ck_27: key = h_23 in
        {552}let ss_27: symmetricstate = symmetricstatepack(cs_23,ck_27,h_23) in
        {553}let v_175: bitstring = catch-fail(symmetricstateunpack(ss_27)) in
        {554}let v_176: bool = (not-caught-fail(v_175) && success?(1-proj-3-tuple(v_175))) in
        {555}let h_24: bitstring = (if v_176 then 3-proj-3-tuple(v_175) else caught-fail) in
        {556}let ck_28: key = (if v_176 then 2-proj-3-tuple(v_175) else caught-fail) in
        {557}let cs_24: cipherstate = (if v_176 then 1-proj-3-tuple(v_175) else caught-fail) in
        {545}let prologue_1: bitstring = empty in
        {558}let ss_28: symmetricstate = catch-fail((if v_176 then symmetricstatepack(cs_24,ck_28,hash(h_24,prologue_1)) else fail-any)) in
        {559}let v_177: bool = not-caught-fail(ss_28) in
        {560}let v_178: bitstring = (if v_177 then catch-fail(symmetricstateunpack(ss_28)) else caught-fail) in
        {561}let v_179: bool = (not-caught-fail(v_178) && success?(1-proj-3-tuple(v_178))) in
        {562}let h_25: bitstring = (if v_179 then 3-proj-3-tuple(v_178) else caught-fail) in
        {563}let ck_29: key = (if v_179 then 2-proj-3-tuple(v_178) else caught-fail) in
        {564}let cs_25: cipherstate = (if v_179 then 1-proj-3-tuple(v_178) else caught-fail) in
        {565}let ss_29: symmetricstate = (if v_177 then catch-fail((if v_179 then symmetricstatepack(cs_25,ck_29,hash(h_25,rs_6)) else fail-any)) else caught-fail) in
        {566}let v_180: bool = not-caught-fail(ss_29) in
        {567}let v_181: bitstring = (if v_180 then catch-fail(symmetricstateunpack(ss_29)) else caught-fail) in
        {568}let v_182: bool = (not-caught-fail(v_181) && success?(1-proj-3-tuple(v_181))) in
        {569}let h_26: bitstring = (if v_182 then 3-proj-3-tuple(v_181) else caught-fail) in
        {570}let ck_30: key = (if v_182 then 2-proj-3-tuple(v_181) else caught-fail) in
        {571}let cs_26: cipherstate = (if v_182 then 1-proj-3-tuple(v_181) else caught-fail) in
        {572}let ss_30: symmetricstate = (if v_180 then catch-fail((if v_182 then symmetricstatepack(cs_26,ck_30,hash(h_26,rm_6)) else fail-any)) else caught-fail) in
        {573}let v_183: bool = not-caught-fail(ss_30) in
        {546}let psk_6: key = empty in
        {544}let re_7: key = empty in
        {535}let e_11: keypair = keypairpack(empty,empty) in
        {574}let hs_18: handshakestate = (if v_177 then (if v_180 then (if v_183 then handshakestatepack(ss_30,s_6,m_7,e_11,rs_6,rm_6,re_7,psk_6,true) else fail-any) else fail-any) else fail-any) in
        {575}insert statestore(me_1,them_1,sid_2,statepack_a(hs_18))
    ) | (
        {688}get statestore(=me_1,=them_1,=sid_2,statepack_a(hs_19: handshakestate)) in
        {577}let v_184: bitstring = catch-fail(handshakestateunpack(hs_19)) in
        {578}let v_185: bool = (not-caught-fail(v_184) && success?(1-proj-9-tuple(v_184))) in
        {579}let initiator_6: bool = (if v_185 then 9-proj-9-tuple(v_184) else caught-fail) in
        {580}let psk_7: key = (if v_185 then 8-proj-9-tuple(v_184) else caught-fail) in
        {581}let re_8: key = (if v_185 then 7-proj-9-tuple(v_184) else caught-fail) in
        {582}let rm_7: key = (if v_185 then 6-proj-9-tuple(v_184) else caught-fail) in
        {583}let rs_7: key = (if v_185 then 5-proj-9-tuple(v_184) else caught-fail) in
        {584}let e_12: keypair = (if v_185 then 4-proj-9-tuple(v_184) else caught-fail) in
        {585}let m_8: keypair = (if v_185 then 3-proj-9-tuple(v_184) else caught-fail) in
        {586}let s_7: keypair = (if v_185 then 2-proj-9-tuple(v_184) else caught-fail) in
        {587}let ss_31: symmetricstate = (if v_185 then 1-proj-9-tuple(v_184) else caught-fail) in
        {588}let v_186: bitstring = (if v_185 then catch-fail((empty,empty,empty)) else caught-fail) in
        {589}let v_187: bool = (not-caught-fail(v_186) && success?(1-proj-3-tuple(v_186))) in
        {590}let ciphertext_12: bitstring = (if v_187 then 3-proj-3-tuple(v_186) else caught-fail) in
        {591}let ns_5: bitstring = (if v_187 then 2-proj-3-tuple(v_186) else caught-fail) in
        {592}let ne_5: bitstring = (if v_187 then 1-proj-3-tuple(v_186) else caught-fail) in
        {593}let basis_6: key = (if v_187 then key_e(me_1,them_1,sid_2) else caught-fail) in
        {594}let public_key_6: key = (if v_187 then catch-fail(dhexp(basis_6,validkey(g))) else caught-fail) in
        {595}let v_188: bool = not-caught-fail(public_key_6) in
        {596}let e_13: keypair = (if v_187 then catch-fail((if v_188 then keypairpack(validkey(public_key_6),basis_6) else fail-any)) else caught-fail) in
        {597}let v_189: bool = not-caught-fail(e_13) in
        {598}let ne_6: bitstring = (if v_189 then catch-fail(getpublickey(e_13)) else caught-fail) in
        {599}let v_190: bool = not-caught-fail(ne_6) in
        {600}let v_191: bitstring = (if v_190 then catch-fail(symmetricstateunpack(ss_31)) else caught-fail) in
        {601}let v_192: bool = (not-caught-fail(v_191) && success?(1-proj-3-tuple(v_191))) in
        {602}let h_27: bitstring = (if v_192 then 3-proj-3-tuple(v_191) else caught-fail) in
        {603}let ck_31: key = (if v_192 then 2-proj-3-tuple(v_191) else caught-fail) in
        {604}let cs_27: cipherstate = (if v_192 then 1-proj-3-tuple(v_191) else caught-fail) in
        {605}let ss_32: symmetricstate = (if v_190 then catch-fail((if v_192 then symmetricstatepack(cs_27,ck_31,hash(h_27,ne_6)) else fail-any)) else caught-fail) in
        {606}let v_193: bool = not-caught-fail(ss_32) in
        {607}let v_194: bitstring = (if v_193 then catch-fail(keypairunpack(e_13)) else caught-fail) in
        {608}let v_195: bool = (not-caught-fail(v_194) && success?(1-proj-2-tuple(v_194))) in
        {609}let my_private_key_4: key = (if v_195 then 2-proj-2-tuple(v_194) else caught-fail) in
        {610}let my_public_key_4: key = (if v_195 then 1-proj-2-tuple(v_194) else caught-fail) in
        {611}let input_key_material_5: key = (if v_193 then catch-fail((if v_195 then dhexp(my_private_key_4,rs_7) else fail-any)) else caught-fail) in
        {612}let v_196: bool = not-caught-fail(input_key_material_5) in
        {613}let v_197: bitstring = (if v_196 then catch-fail(symmetricstateunpack(ss_32)) else caught-fail) in
        {614}let v_198: bool = (not-caught-fail(v_197) && success?(1-proj-3-tuple(v_197))) in
        {615}let h_28: bitstring = (if v_198 then 3-proj-3-tuple(v_197) else caught-fail) in
        {616}let ck_32: key = (if v_198 then 2-proj-3-tuple(v_197) else caught-fail) in
        {617}let cs_28: cipherstate = (if v_198 then 1-proj-3-tuple(v_197) else caught-fail) in
        {620}let output3_5: key = (if v_198 then hmac_hash3(ck_32,input_key_material_5) else caught-fail) in
        {619}let output2_5: key = (if v_198 then hmac_hash2(ck_32,input_key_material_5) else caught-fail) in
        {618}let output1_5: key = (if v_198 then hmac_hash1(ck_32,input_key_material_5) else caught-fail) in
        {621}let v_199: bitstring = (if v_198 then catch-fail((output1_5,output2_5,output3_5)) else caught-fail) in
        {622}let v_200: bool = (not-caught-fail(v_199) && success?(1-proj-3-tuple(v_199))) in
        {623}let output_4: key = (if v_200 then 3-proj-3-tuple(v_199) else caught-fail) in
        {624}let temp_k_4: key = (if v_200 then 2-proj-3-tuple(v_199) else caught-fail) in
        {625}let ck_33: key = (if v_200 then 1-proj-3-tuple(v_199) else caught-fail) in
        {626}let ss_33: symmetricstate = (if v_193 then catch-fail((if v_196 then (if v_198 then (if v_200 then symmetricstatepack(cipherstatepack(temp_k_4,minnonce),ck_33,h_28) else fail-any) else fail-any) else fail-any)) else caught-fail) in
        {627}let v_201: bool = not-caught-fail(ss_33) in
        {628}let v_202: bitstring = (if v_201 then catch-fail(keypairunpack(e_13)) else caught-fail) in
        {629}let v_203: bool = (not-caught-fail(v_202) && success?(1-proj-2-tuple(v_202))) in
        {630}let my_private_key_5: key = (if v_203 then 2-proj-2-tuple(v_202) else caught-fail) in
        {631}let my_public_key_5: key = (if v_203 then 1-proj-2-tuple(v_202) else caught-fail) in
        {632}let input_key_material_6: key = (if v_201 then catch-fail((if v_203 then dhexp(my_private_key_5,rm_7) else fail-any)) else caught-fail) in
        {633}let v_204: bool = not-caught-fail(input_key_material_6) in
        {634}let v_205: bitstring = (if v_204 then catch-fail(symmetricstateunpack(ss_33)) else caught-fail) in
        {635}let v_206: bool = (not-caught-fail(v_205) && success?(1-proj-3-tuple(v_205))) in
        {636}let h_29: bitstring = (if v_206 then 3-proj-3-tuple(v_205) else caught-fail) in
        {637}let ck_34: key = (if v_206 then 2-proj-3-tuple(v_205) else caught-fail) in
        {638}let cs_29: cipherstate = (if v_206 then 1-proj-3-tuple(v_205) else caught-fail) in
        {641}let output3_6: key = (if v_206 then hmac_hash3(ck_34,input_key_material_6) else caught-fail) in
        {640}let output2_6: key = (if v_206 then hmac_hash2(ck_34,input_key_material_6) else caught-fail) in
        {639}let output1_6: key = (if v_206 then hmac_hash1(ck_34,input_key_material_6) else caught-fail) in
        {642}let v_207: bitstring = (if v_206 then catch-fail((output1_6,output2_6,output3_6)) else caught-fail) in
        {643}let v_208: bool = (not-caught-fail(v_207) && success?(1-proj-3-tuple(v_207))) in
        {644}let output_5: key = (if v_208 then 3-proj-3-tuple(v_207) else caught-fail) in
        {645}let temp_k_5: key = (if v_208 then 2-proj-3-tuple(v_207) else caught-fail) in
        {646}let ck_35: key = (if v_208 then 1-proj-3-tuple(v_207) else caught-fail) in
        {647}let ss_34: symmetricstate = (if v_201 then catch-fail((if v_204 then (if v_206 then (if v_208 then symmetricstatepack(cipherstatepack(temp_k_5,minnonce),ck_35,h_29) else fail-any) else fail-any) else fail-any)) else caught-fail) in
        {648}let v_209: bool = not-caught-fail(ss_34) in
        {649}let v_210: bitstring = (if v_209 then catch-fail(symmetricstateunpack(ss_34)) else caught-fail) in
        {650}let v_211: bool = (not-caught-fail(v_210) && success?(1-proj-3-tuple(v_210))) in
        {651}let h_30: bitstring = (if v_211 then 3-proj-3-tuple(v_210) else caught-fail) in
        {652}let ck_36: key = (if v_211 then 2-proj-3-tuple(v_210) else caught-fail) in
        {653}let cs_30: cipherstate = (if v_211 then 1-proj-3-tuple(v_210) else caught-fail) in
        {654}let v_212: bitstring = (if v_211 then catch-fail(cipherstateunpack(cs_30)) else caught-fail) in
        {655}let v_213: bool = (not-caught-fail(v_212) && success?(1-proj-2-tuple(v_212))) in
        {656}let n_12: nonce = (if v_213 then 2-proj-2-tuple(v_212) else caught-fail) in
        {657}let k_14: key = (if v_213 then 1-proj-2-tuple(v_212) else caught-fail) in
        {660}let v_214: bitstring = (if v_213 then catch-fail(cipherstateunpack(cs_30)) else caught-fail) in
        {661}let v_215: bool = (not-caught-fail(v_214) && success?(1-proj-2-tuple(v_214))) in
        {662}let o_6: nonce = (if v_215 then 2-proj-2-tuple(v_214) else caught-fail) in
        {663}let k_15: key = (if v_215 then 1-proj-2-tuple(v_214) else caught-fail) in
        {659}let n_13: nonce = (if v_213 then increment_nonce(n_12) else caught-fail) in
        {664}let csi_12: cipherstate = (if v_213 then catch-fail((if v_215 then cipherstatepack(k_15,n_13) else fail-any)) else caught-fail) in
        {665}let v_216: bool = not-caught-fail(csi_12) in
        {576}let payload_3: bitstring = msg_a(me_1,them_1,sid_2) in
        {658}let e_14: bitstring = (if v_213 then encrypt(k_14,n_12,h_30,payload_3) else caught-fail) in
        {666}let v_217: bitstring = (if v_211 then catch-fail((if v_213 then (if v_216 then (csi_12,e_14) else fail-any) else fail-any)) else caught-fail) in
        {667}let v_218: bool = (not-caught-fail(v_217) && success?(1-proj-2-tuple(v_217))) in
        {668}let ciphertext_13: bitstring = (if v_218 then 2-proj-2-tuple(v_217) else caught-fail) in
        {669}let csi_13: cipherstate = (if v_218 then 1-proj-2-tuple(v_217) else caught-fail) in
        {670}let ss_35: symmetricstate = (if v_218 then symmetricstatepack(csi_13,ck_36,h_30) else caught-fail) in
        {671}let v_219: bitstring = (if v_218 then catch-fail(symmetricstateunpack(ss_35)) else caught-fail) in
        {672}let v_220: bool = (not-caught-fail(v_219) && success?(1-proj-3-tuple(v_219))) in
        {673}let h_31: bitstring = (if v_220 then 3-proj-3-tuple(v_219) else caught-fail) in
        {674}let ck_37: key = (if v_220 then 2-proj-3-tuple(v_219) else caught-fail) in
        {675}let cs_31: cipherstate = (if v_220 then 1-proj-3-tuple(v_219) else caught-fail) in
        {676}let ssi_7: symmetricstate = (if v_218 then catch-fail((if v_220 then symmetricstatepack(cs_31,ck_37,hash(h_31,ciphertext_13)) else fail-any)) else caught-fail) in
        {677}let v_221: bool = not-caught-fail(ssi_7) in
        {678}let v_222: bitstring = (if v_209 then catch-fail((if v_211 then (if v_218 then (if v_221 then (ssi_7,ciphertext_13) else fail-any) else fail-any) else fail-any)) else caught-fail) in
        {679}let v_223: bool = (not-caught-fail(v_222) && success?(1-proj-2-tuple(v_222))) in
        {680}let ciphertext_14: bitstring = (if v_223 then 2-proj-2-tuple(v_222) else caught-fail) in
        {681}let ss_36: symmetricstate = (if v_223 then 1-proj-2-tuple(v_222) else caught-fail) in
        {683}let message_buffer_3: bitstring = (if v_223 then concat3(ne_6,ns_5,ciphertext_14) else caught-fail) in
        {682}let hs_20: handshakestate = (if v_223 then handshakestatepack(ss_36,s_7,m_8,e_13,rs_7,rm_7,re_8,psk_7,initiator_6) else caught-fail) in
        {684}let (hs_21: handshakestate,message_a_1: bitstring) = (if v_185 then (if v_187 then (if v_189 then (if v_190 then (if v_193 then (if v_201 then (if v_209 then (if v_223 then (hs_20,message_buffer_3) else fail-any) else fail-any) else fail-any) else fail-any) else fail-any) else fail-any) else fail-any) else fail-any) in
        {685}event SendMsg(me_1,them_1,stagepack_a(sid_2),msg_a(me_1,them_1,sid_2));
        {686}insert statestore(me_1,them_1,sid_2,statepack_b(hs_21));
        {687}out(pub, message_a_1)
    ) | (
        {782}get statestore(=me_1,=them_1,=sid_2,statepack_b(hs_22: handshakestate)) in
        {689}in(pub, message_b_1: bitstring);
        {690}let v_224: bitstring = catch-fail(handshakestateunpack(hs_22)) in
        {691}let v_225: bool = (not-caught-fail(v_224) && success?(1-proj-9-tuple(v_224))) in
        {692}let initiator_7: bool = (if v_225 then 9-proj-9-tuple(v_224) else caught-fail) in
        {693}let psk_8: key = (if v_225 then 8-proj-9-tuple(v_224) else caught-fail) in
        {694}let re_9: key = (if v_225 then 7-proj-9-tuple(v_224) else caught-fail) in
        {695}let rm_8: key = (if v_225 then 6-proj-9-tuple(v_224) else caught-fail) in
        {696}let rs_8: key = (if v_225 then 5-proj-9-tuple(v_224) else caught-fail) in
        {697}let e_15: keypair = (if v_225 then 4-proj-9-tuple(v_224) else caught-fail) in
        {698}let m_9: keypair = (if v_225 then 3-proj-9-tuple(v_224) else caught-fail) in
        {699}let s_8: keypair = (if v_225 then 2-proj-9-tuple(v_224) else caught-fail) in
        {700}let ss_37: symmetricstate = (if v_225 then 1-proj-9-tuple(v_224) else caught-fail) in
        {701}let v_226: bitstring = (if v_225 then catch-fail(deconcat3(message_b_1)) else caught-fail) in
        {702}let v_227: bool = (not-caught-fail(v_226) && success?(1-proj-3-tuple(v_226))) in
        {703}let ciphertext_15: bitstring = (if v_227 then 3-proj-3-tuple(v_226) else caught-fail) in
        {704}let ns_6: bitstring = (if v_227 then 2-proj-3-tuple(v_226) else caught-fail) in
        {705}let ne_7: bitstring = (if v_227 then 1-proj-3-tuple(v_226) else caught-fail) in
        {708}let v_228: bitstring = (if v_227 then catch-fail(symmetricstateunpack(ss_37)) else caught-fail) in
        {709}let v_229: bool = (not-caught-fail(v_228) && success?(1-proj-3-tuple(v_228))) in
        {710}let h_32: bitstring = (if v_229 then 3-proj-3-tuple(v_228) else caught-fail) in
        {711}let ck_38: key = (if v_229 then 2-proj-3-tuple(v_228) else caught-fail) in
        {712}let cs_32: cipherstate = (if v_229 then 1-proj-3-tuple(v_228) else caught-fail) in
        {707}let re_10: key = (if v_227 then ne_7 else caught-fail) in
        {713}let ss_38: symmetricstate = (if v_227 then catch-fail((if v_229 then symmetricstatepack(cs_32,ck_38,hash(h_32,re_10)) else fail-any)) else caught-fail) in
        {714}let v_230: bool = not-caught-fail(ss_38) in
        {715}let v_231: bitstring = (if v_230 then catch-fail(keypairunpack(e_15)) else caught-fail) in
        {716}let v_232: bool = (not-caught-fail(v_231) && success?(1-proj-2-tuple(v_231))) in
        {717}let my_private_key_6: key = (if v_232 then 2-proj-2-tuple(v_231) else caught-fail) in
        {718}let my_public_key_6: key = (if v_232 then 1-proj-2-tuple(v_231) else caught-fail) in
        {719}let input_key_material_7: key = (if v_230 then catch-fail((if v_232 then dhexp(my_private_key_6,re_10) else fail-any)) else caught-fail) in
        {720}let v_233: bool = not-caught-fail(input_key_material_7) in
        {721}let v_234: bitstring = (if v_233 then catch-fail(symmetricstateunpack(ss_38)) else caught-fail) in
        {722}let v_235: bool = (not-caught-fail(v_234) && success?(1-proj-3-tuple(v_234))) in
        {723}let h_33: bitstring = (if v_235 then 3-proj-3-tuple(v_234) else caught-fail) in
        {724}let ck_39: key = (if v_235 then 2-proj-3-tuple(v_234) else caught-fail) in
        {725}let cs_33: cipherstate = (if v_235 then 1-proj-3-tuple(v_234) else caught-fail) in
        {728}let output3_7: key = (if v_235 then hmac_hash3(ck_39,input_key_material_7) else caught-fail) in
        {727}let output2_7: key = (if v_235 then hmac_hash2(ck_39,input_key_material_7) else caught-fail) in
        {726}let output1_7: key = (if v_235 then hmac_hash1(ck_39,input_key_material_7) else caught-fail) in
        {729}let v_236: bitstring = (if v_235 then catch-fail((output1_7,output2_7,output3_7)) else caught-fail) in
        {730}let v_237: bool = (not-caught-fail(v_236) && success?(1-proj-3-tuple(v_236))) in
        {731}let output_6: key = (if v_237 then 3-proj-3-tuple(v_236) else caught-fail) in
        {732}let temp_k_6: key = (if v_237 then 2-proj-3-tuple(v_236) else caught-fail) in
        {733}let ck_40: key = (if v_237 then 1-proj-3-tuple(v_236) else caught-fail) in
        {734}let ss_39: symmetricstate = (if v_230 then catch-fail((if v_233 then (if v_235 then (if v_237 then symmetricstatepack(cipherstatepack(temp_k_6,minnonce),ck_40,h_33) else fail-any) else fail-any) else fail-any)) else caught-fail) in
        {735}let v_238: bool = not-caught-fail(ss_39) in
        {736}let v_239: bitstring = (if v_238 then catch-fail(symmetricstateunpack(ss_39)) else caught-fail) in
        {737}let v_240: bool = (not-caught-fail(v_239) && success?(1-proj-3-tuple(v_239))) in
        {738}let h_34: bitstring = (if v_240 then 3-proj-3-tuple(v_239) else caught-fail) in
        {739}let ck_41: key = (if v_240 then 2-proj-3-tuple(v_239) else caught-fail) in
        {740}let cs_34: cipherstate = (if v_240 then 1-proj-3-tuple(v_239) else caught-fail) in
        {741}let v_241: bitstring = (if v_240 then catch-fail(cipherstateunpack(cs_34)) else caught-fail) in
        {742}let v_242: bool = (not-caught-fail(v_241) && success?(1-proj-2-tuple(v_241))) in
        {743}let n_14: nonce = (if v_242 then 2-proj-2-tuple(v_241) else caught-fail) in
        {744}let k_16: key = (if v_242 then 1-proj-2-tuple(v_241) else caught-fail) in
        {745}let d_2: aead = (if v_242 then catch-fail(decrypt(k_16,n_14,h_34,ciphertext_15)) else caught-fail) in
        {746}let v_243: bool = not-caught-fail(d_2) in
        {747}let v_244: bitstring = (if v_243 then catch-fail(aeadunpack(d_2)) else caught-fail) in
        {748}let v_245: bool = (not-caught-fail(v_244) && success?(1-proj-3-tuple(v_244))) in
        {749}let plaintext_7: bitstring = (if v_245 then 3-proj-3-tuple(v_244) else caught-fail) in
        {750}let adi_2: bitstring = (if v_245 then 2-proj-3-tuple(v_244) else caught-fail) in
        {751}let valid_6: bool = (if v_245 then 1-proj-3-tuple(v_244) else caught-fail) in
        {753}let v_246: bitstring = (if v_245 then catch-fail(cipherstateunpack(cs_34)) else caught-fail) in
        {754}let v_247: bool = (not-caught-fail(v_246) && success?(1-proj-2-tuple(v_246))) in
        {755}let o_7: nonce = (if v_247 then 2-proj-2-tuple(v_246) else caught-fail) in
        {756}let k_17: key = (if v_247 then 1-proj-2-tuple(v_246) else caught-fail) in
        {752}let n_15: nonce = (if v_245 then increment_nonce(n_14) else caught-fail) in
        {757}let csi_14: cipherstate = (if v_245 then catch-fail((if v_247 then cipherstatepack(k_17,n_15) else fail-any)) else caught-fail) in
        {758}let v_248: bool = not-caught-fail(csi_14) in
        {759}let v_249: bitstring = (if v_240 then catch-fail((if v_242 then (if v_243 then (if v_245 then (if v_248 then (csi_14,plaintext_7,valid_6) else fail-any) else fail-any) else fail-any) else fail-any)) else caught-fail) in
        {760}let v_250: bool = (not-caught-fail(v_249) && success?(1-proj-3-tuple(v_249))) in
        {761}let valid_7: bool = (if v_250 then 3-proj-3-tuple(v_249) else caught-fail) in
        {762}let plaintext_8: bitstring = (if v_250 then 2-proj-3-tuple(v_249) else caught-fail) in
        {763}let csi_15: cipherstate = (if v_250 then 1-proj-3-tuple(v_249) else caught-fail) in
        {764}let ss_40: symmetricstate = (if v_250 then symmetricstatepack(csi_15,ck_41,h_34) else caught-fail) in
        {765}let v_251: bitstring = (if v_250 then catch-fail(symmetricstateunpack(ss_40)) else caught-fail) in
        {766}let v_252: bool = (not-caught-fail(v_251) && success?(1-proj-3-tuple(v_251))) in
        {767}let h_35: bitstring = (if v_252 then 3-proj-3-tuple(v_251) else caught-fail) in
        {768}let ck_42: key = (if v_252 then 2-proj-3-tuple(v_251) else caught-fail) in
        {769}let cs_35: cipherstate = (if v_252 then 1-proj-3-tuple(v_251) else caught-fail) in
        {770}let ssi_8: symmetricstate = (if v_250 then catch-fail((if v_252 then symmetricstatepack(cs_35,ck_42,hash(h_35,ciphertext_15)) else fail-any)) else caught-fail) in
        {771}let v_253: bool = not-caught-fail(ssi_8) in
        {772}let v_254: bitstring = (if v_238 then catch-fail((if v_240 then (if v_250 then (if v_253 then (ssi_8,plaintext_8,valid_7) else fail-any) else fail-any) else fail-any)) else caught-fail) in
        {773}let v_255: bool = (not-caught-fail(v_254) && success?(1-proj-3-tuple(v_254))) in
        {774}let valid2_2: bool = (if v_255 then 3-proj-3-tuple(v_254) else caught-fail) in
        {775}let plaintext_9: bitstring = (if v_255 then 2-proj-3-tuple(v_254) else caught-fail) in
        {776}let ss_41: symmetricstate = (if v_255 then 1-proj-3-tuple(v_254) else caught-fail) in
        {706}let valid1_2: bool = (if v_227 then true else caught-fail) in
        {777}let v_256: bool = (if v_255 then catch-fail((valid1_2 && valid2_2)) else caught-fail) in
        {778}let hs_23: handshakestate = (if v_256 then handshakestatepack(ss_41,s_8,m_9,e_15,rs_8,rm_8,re_10,psk_8,initiator_7) else caught-fail) in
        {779}let (hs_24: handshakestate,plaintext_b_1: bitstring,valid_8: bool) = (if v_225 then (if v_227 then (if v_230 then (if v_238 then (if v_255 then (if undo-catch-fail(v_256) then (hs_23,plaintext_9,true) else fail-any) else fail-any) else fail-any) else fail-any) else fail-any) else fail-any) in
        {780}event RecvMsg(me_1,them_1,stagepack_b(sid_2),plaintext_b_1);
        {781}insert statestore(me_1,them_1,sid_2,statepack_c(hs_24))
    ) | (
        {921}get statestore(=me_1,=them_1,=sid_2,statepack_c(hs_25: handshakestate)) in
        {784}let v_257: bitstring = catch-fail(handshakestateunpack(hs_25)) in
        {785}let v_258: bool = (not-caught-fail(v_257) && success?(1-proj-9-tuple(v_257))) in
        {786}let initiator_8: bool = (if v_258 then 9-proj-9-tuple(v_257) else caught-fail) in
        {787}let psk_9: key = (if v_258 then 8-proj-9-tuple(v_257) else caught-fail) in
        {788}let re_11: key = (if v_258 then 7-proj-9-tuple(v_257) else caught-fail) in
        {789}let rm_9: key = (if v_258 then 6-proj-9-tuple(v_257) else caught-fail) in
        {790}let rs_9: key = (if v_258 then 5-proj-9-tuple(v_257) else caught-fail) in
        {791}let e_16: keypair = (if v_258 then 4-proj-9-tuple(v_257) else caught-fail) in
        {792}let m_10: keypair = (if v_258 then 3-proj-9-tuple(v_257) else caught-fail) in
        {793}let s_9: keypair = (if v_258 then 2-proj-9-tuple(v_257) else caught-fail) in
        {794}let ss_42: symmetricstate = (if v_258 then 1-proj-9-tuple(v_257) else caught-fail) in
        {795}let v_259: bitstring = (if v_258 then catch-fail((empty,empty,empty)) else caught-fail) in
        {796}let v_260: bool = (not-caught-fail(v_259) && success?(1-proj-3-tuple(v_259))) in
        {797}let ciphertext_16: bitstring = (if v_260 then 3-proj-3-tuple(v_259) else caught-fail) in
        {798}let nm_2: bitstring = (if v_260 then 2-proj-3-tuple(v_259) else caught-fail) in
        {799}let ns_7: bitstring = (if v_260 then 1-proj-3-tuple(v_259) else caught-fail) in
        {800}let basis_7: key = (if v_260 then key_m(me_1) else caught-fail) in
        {801}let public_key_7: key = (if v_260 then catch-fail(dhexp(basis_7,validkey(g))) else caught-fail) in
        {802}let v_261: bool = not-caught-fail(public_key_7) in
        {803}let m_11: keypair = (if v_260 then catch-fail((if v_261 then keypairpack(validkey(public_key_7),basis_7) else fail-any)) else caught-fail) in
        {804}let v_262: bool = not-caught-fail(m_11) in
        {805}let plaintext_10: bitstring = (if v_262 then catch-fail(getpublickey(m_11)) else caught-fail) in
        {806}let v_263: bool = not-caught-fail(plaintext_10) in
        {807}let v_264: bitstring = (if v_263 then catch-fail(symmetricstateunpack(ss_42)) else caught-fail) in
        {808}let v_265: bool = (not-caught-fail(v_264) && success?(1-proj-3-tuple(v_264))) in
        {809}let h_36: bitstring = (if v_265 then 3-proj-3-tuple(v_264) else caught-fail) in
        {810}let ck_43: key = (if v_265 then 2-proj-3-tuple(v_264) else caught-fail) in
        {811}let cs_36: cipherstate = (if v_265 then 1-proj-3-tuple(v_264) else caught-fail) in
        {812}let v_266: bitstring = (if v_265 then catch-fail(cipherstateunpack(cs_36)) else caught-fail) in
        {813}let v_267: bool = (not-caught-fail(v_266) && success?(1-proj-2-tuple(v_266))) in
        {814}let n_16: nonce = (if v_267 then 2-proj-2-tuple(v_266) else caught-fail) in
        {815}let k_18: key = (if v_267 then 1-proj-2-tuple(v_266) else caught-fail) in
        {818}let v_268: bitstring = (if v_267 then catch-fail(cipherstateunpack(cs_36)) else caught-fail) in
        {819}let v_269: bool = (not-caught-fail(v_268) && success?(1-proj-2-tuple(v_268))) in
        {820}let o_8: nonce = (if v_269 then 2-proj-2-tuple(v_268) else caught-fail) in
        {821}let k_19: key = (if v_269 then 1-proj-2-tuple(v_268) else caught-fail) in
        {817}let n_17: nonce = (if v_267 then increment_nonce(n_16) else caught-fail) in
        {822}let csi_16: cipherstate = (if v_267 then catch-fail((if v_269 then cipherstatepack(k_19,n_17) else fail-any)) else caught-fail) in
        {823}let v_270: bool = not-caught-fail(csi_16) in
        {816}let e_17: bitstring = (if v_267 then encrypt(k_18,n_16,h_36,plaintext_10) else caught-fail) in
        {824}let v_271: bitstring = (if v_265 then catch-fail((if v_267 then (if v_270 then (csi_16,e_17) else fail-any) else fail-any)) else caught-fail) in
        {825}let v_272: bool = (not-caught-fail(v_271) && success?(1-proj-2-tuple(v_271))) in
        {826}let ciphertext_17: bitstring = (if v_272 then 2-proj-2-tuple(v_271) else caught-fail) in
        {827}let csi_17: cipherstate = (if v_272 then 1-proj-2-tuple(v_271) else caught-fail) in
        {828}let ss_43: symmetricstate = (if v_272 then symmetricstatepack(csi_17,ck_43,h_36) else caught-fail) in
        {829}let v_273: bitstring = (if v_272 then catch-fail(symmetricstateunpack(ss_43)) else caught-fail) in
        {830}let v_274: bool = (not-caught-fail(v_273) && success?(1-proj-3-tuple(v_273))) in
        {831}let h_37: bitstring = (if v_274 then 3-proj-3-tuple(v_273) else caught-fail) in
        {832}let ck_44: key = (if v_274 then 2-proj-3-tuple(v_273) else caught-fail) in
        {833}let cs_37: cipherstate = (if v_274 then 1-proj-3-tuple(v_273) else caught-fail) in
        {834}let ssi_9: symmetricstate = (if v_272 then catch-fail((if v_274 then symmetricstatepack(cs_37,ck_44,hash(h_37,ciphertext_17)) else fail-any)) else caught-fail) in
        {835}let v_275: bool = not-caught-fail(ssi_9) in
        {836}let v_276: bitstring = (if v_262 then catch-fail((if v_263 then (if v_265 then (if v_272 then (if v_275 then (ssi_9,ciphertext_17) else fail-any) else fail-any) else fail-any) else fail-any)) else caught-fail) in
        {837}let v_277: bool = (not-caught-fail(v_276) && success?(1-proj-2-tuple(v_276))) in
        {838}let nm_3: bitstring = (if v_277 then 2-proj-2-tuple(v_276) else caught-fail) in
        {839}let ss_44: symmetricstate = (if v_277 then 1-proj-2-tuple(v_276) else caught-fail) in
        {840}let v_278: bitstring = (if v_277 then catch-fail(keypairunpack(m_11)) else caught-fail) in
        {841}let v_279: bool = (not-caught-fail(v_278) && success?(1-proj-2-tuple(v_278))) in
        {842}let my_private_key_7: key = (if v_279 then 2-proj-2-tuple(v_278) else caught-fail) in
        {843}let my_public_key_7: key = (if v_279 then 1-proj-2-tuple(v_278) else caught-fail) in
        {844}let input_key_material_8: key = (if v_277 then catch-fail((if v_279 then dhexp(my_private_key_7,re_11) else fail-any)) else caught-fail) in
        {845}let v_280: bool = not-caught-fail(input_key_material_8) in
        {846}let v_281: bitstring = (if v_280 then catch-fail(symmetricstateunpack(ss_44)) else caught-fail) in
        {847}let v_282: bool = (not-caught-fail(v_281) && success?(1-proj-3-tuple(v_281))) in
        {848}let h_38: bitstring = (if v_282 then 3-proj-3-tuple(v_281) else caught-fail) in
        {849}let ck_45: key = (if v_282 then 2-proj-3-tuple(v_281) else caught-fail) in
        {850}let cs_38: cipherstate = (if v_282 then 1-proj-3-tuple(v_281) else caught-fail) in
        {853}let output3_8: key = (if v_282 then hmac_hash3(ck_45,input_key_material_8) else caught-fail) in
        {852}let output2_8: key = (if v_282 then hmac_hash2(ck_45,input_key_material_8) else caught-fail) in
        {851}let output1_8: key = (if v_282 then hmac_hash1(ck_45,input_key_material_8) else caught-fail) in
        {854}let v_283: bitstring = (if v_282 then catch-fail((output1_8,output2_8,output3_8)) else caught-fail) in
        {855}let v_284: bool = (not-caught-fail(v_283) && success?(1-proj-3-tuple(v_283))) in
        {856}let output_7: key = (if v_284 then 3-proj-3-tuple(v_283) else caught-fail) in
        {857}let temp_k_7: key = (if v_284 then 2-proj-3-tuple(v_283) else caught-fail) in
        {858}let ck_46: key = (if v_284 then 1-proj-3-tuple(v_283) else caught-fail) in
        {859}let ss_45: symmetricstate = (if v_277 then catch-fail((if v_280 then (if v_282 then (if v_284 then symmetricstatepack(cipherstatepack(temp_k_7,minnonce),ck_46,h_38) else fail-any) else fail-any) else fail-any)) else caught-fail) in
        {860}let v_285: bool = not-caught-fail(ss_45) in
        {861}let v_286: bitstring = (if v_285 then catch-fail(symmetricstateunpack(ss_45)) else caught-fail) in
        {862}let v_287: bool = (not-caught-fail(v_286) && success?(1-proj-3-tuple(v_286))) in
        {863}let h_39: bitstring = (if v_287 then 3-proj-3-tuple(v_286) else caught-fail) in
        {864}let ck_47: key = (if v_287 then 2-proj-3-tuple(v_286) else caught-fail) in
        {865}let cs_39: cipherstate = (if v_287 then 1-proj-3-tuple(v_286) else caught-fail) in
        {866}let v_288: bitstring = (if v_287 then catch-fail(cipherstateunpack(cs_39)) else caught-fail) in
        {867}let v_289: bool = (not-caught-fail(v_288) && success?(1-proj-2-tuple(v_288))) in
        {868}let n_18: nonce = (if v_289 then 2-proj-2-tuple(v_288) else caught-fail) in
        {869}let k_20: key = (if v_289 then 1-proj-2-tuple(v_288) else caught-fail) in
        {872}let v_290: bitstring = (if v_289 then catch-fail(cipherstateunpack(cs_39)) else caught-fail) in
        {873}let v_291: bool = (not-caught-fail(v_290) && success?(1-proj-2-tuple(v_290))) in
        {874}let o_9: nonce = (if v_291 then 2-proj-2-tuple(v_290) else caught-fail) in
        {875}let k_21: key = (if v_291 then 1-proj-2-tuple(v_290) else caught-fail) in
        {871}let n_19: nonce = (if v_289 then increment_nonce(n_18) else caught-fail) in
        {876}let csi_18: cipherstate = (if v_289 then catch-fail((if v_291 then cipherstatepack(k_21,n_19) else fail-any)) else caught-fail) in
        {877}let v_292: bool = not-caught-fail(csi_18) in
        {783}let payload_4: bitstring = msg_c(me_1,them_1,sid_2) in
        {870}let e_18: bitstring = (if v_289 then encrypt(k_20,n_18,h_39,payload_4) else caught-fail) in
        {878}let v_293: bitstring = (if v_287 then catch-fail((if v_289 then (if v_292 then (csi_18,e_18) else fail-any) else fail-any)) else caught-fail) in
        {879}let v_294: bool = (not-caught-fail(v_293) && success?(1-proj-2-tuple(v_293))) in
        {880}let ciphertext_18: bitstring = (if v_294 then 2-proj-2-tuple(v_293) else caught-fail) in
        {881}let csi_19: cipherstate = (if v_294 then 1-proj-2-tuple(v_293) else caught-fail) in
        {882}let ss_46: symmetricstate = (if v_294 then symmetricstatepack(csi_19,ck_47,h_39) else caught-fail) in
        {883}let v_295: bitstring = (if v_294 then catch-fail(symmetricstateunpack(ss_46)) else caught-fail) in
        {884}let v_296: bool = (not-caught-fail(v_295) && success?(1-proj-3-tuple(v_295))) in
        {885}let h_40: bitstring = (if v_296 then 3-proj-3-tuple(v_295) else caught-fail) in
        {886}let ck_48: key = (if v_296 then 2-proj-3-tuple(v_295) else caught-fail) in
        {887}let cs_40: cipherstate = (if v_296 then 1-proj-3-tuple(v_295) else caught-fail) in
        {888}let ssi_10: symmetricstate = (if v_294 then catch-fail((if v_296 then symmetricstatepack(cs_40,ck_48,hash(h_40,ciphertext_18)) else fail-any)) else caught-fail) in
        {889}let v_297: bool = not-caught-fail(ssi_10) in
        {890}let v_298: bitstring = (if v_285 then catch-fail((if v_287 then (if v_294 then (if v_297 then (ssi_10,ciphertext_18) else fail-any) else fail-any) else fail-any)) else caught-fail) in
        {891}let v_299: bool = (not-caught-fail(v_298) && success?(1-proj-2-tuple(v_298))) in
        {892}let ciphertext_19: bitstring = (if v_299 then 2-proj-2-tuple(v_298) else caught-fail) in
        {893}let ss_47: symmetricstate = (if v_299 then 1-proj-2-tuple(v_298) else caught-fail) in
        {896}let v_300: bitstring = (if v_299 then catch-fail(symmetricstateunpack(ss_47)) else caught-fail) in
        {897}let v_301: bool = (not-caught-fail(v_300) && success?(1-proj-3-tuple(v_300))) in
        {898}let h_41: bitstring = (if v_301 then 3-proj-3-tuple(v_300) else caught-fail) in
        {899}let ck_49: key = (if v_301 then 2-proj-3-tuple(v_300) else caught-fail) in
        {900}let cs_41: cipherstate = (if v_301 then 1-proj-3-tuple(v_300) else caught-fail) in
        {901}let input_key_material_9: key = (if v_301 then zero else caught-fail) in
        {904}let output3_9: key = (if v_301 then hmac_hash3(ck_49,input_key_material_9) else caught-fail) in
        {903}let output2_9: key = (if v_301 then hmac_hash2(ck_49,input_key_material_9) else caught-fail) in
        {902}let output1_9: key = (if v_301 then hmac_hash1(ck_49,input_key_material_9) else caught-fail) in
        {905}let v_302: bitstring = (if v_301 then catch-fail((output1_9,output2_9,output3_9)) else caught-fail) in
        {906}let v_303: bool = (not-caught-fail(v_302) && success?(1-proj-3-tuple(v_302))) in
        {907}let temp_k3_1: key = (if v_303 then 3-proj-3-tuple(v_302) else caught-fail) in
        {908}let temp_k2_1: key = (if v_303 then 2-proj-3-tuple(v_302) else caught-fail) in
        {909}let temp_k1_1: key = (if v_303 then 1-proj-3-tuple(v_302) else caught-fail) in
        {911}let cs2_5: cipherstate = (if v_303 then cipherstatepack(temp_k2_1,minnonce) else caught-fail) in
        {910}let cs1_5: cipherstate = (if v_303 then cipherstatepack(temp_k1_1,minnonce) else caught-fail) in
        {912}let v_304: bitstring = (if v_299 then catch-fail((if v_301 then (if v_303 then (ss_47,cs1_5,cs2_5) else fail-any) else fail-any)) else caught-fail) in
        {913}let v_305: bool = (not-caught-fail(v_304) && success?(1-proj-3-tuple(v_304))) in
        {914}let cs2_6: cipherstate = (if v_305 then 3-proj-3-tuple(v_304) else caught-fail) in
        {915}let cs1_6: cipherstate = (if v_305 then 2-proj-3-tuple(v_304) else caught-fail) in
        {916}let ssi_11: symmetricstate = (if v_305 then 1-proj-3-tuple(v_304) else caught-fail) in
        {895}let message_buffer_4: bitstring = (if v_299 then concat3(ns_7,nm_3,ciphertext_19) else caught-fail) in
        {894}let hs_26: handshakestate = (if v_299 then handshakestatepack(ss_47,s_9,m_11,e_16,rs_9,rm_9,re_11,psk_9,initiator_8) else caught-fail) in
        {917}let (hs_27: handshakestate,message_c_1: bitstring,cs1_7: cipherstate,cs2_7: cipherstate) = (if v_258 then (if v_260 then (if v_262 then (if v_277 then (if v_285 then (if v_299 then (if v_305 then (hs_26,message_buffer_4,cs1_6,cs2_6) else fail-any) else fail-any) else fail-any) else fail-any) else fail-any) else fail-any) else fail-any) in
        {918}event SendMsg(me_1,them_1,stagepack_c(sid_2),msg_c(me_1,them_1,sid_2));
        {919}insert statestore(me_1,them_1,sid_2,statepack_d(hs_27,cs1_7,cs2_7));
        {920}out(pub, message_c_1)
    ) | (
        {922}!
        {988}get statestore(=me_1,=them_1,=sid_2,statepack_d(hs_28: handshakestate,cs1_8: cipherstate,cs2_8: cipherstate)) in
        {923}let hs_29: handshakestate = handshakestatesetcs(hs_28,cs2_8) in
        {924}in(pub, message_d_1: bitstring);
        {925}let v_306: bitstring = catch-fail(handshakestateunpack(hs_29)) in
        {926}let v_307: bool = (not-caught-fail(v_306) && success?(1-proj-9-tuple(v_306))) in
        {927}let initiator_9: bool = (if v_307 then 9-proj-9-tuple(v_306) else caught-fail) in
        {928}let psk_10: key = (if v_307 then 8-proj-9-tuple(v_306) else caught-fail) in
        {929}let re_12: key = (if v_307 then 7-proj-9-tuple(v_306) else caught-fail) in
        {930}let rm_10: key = (if v_307 then 6-proj-9-tuple(v_306) else caught-fail) in
        {931}let rs_10: key = (if v_307 then 5-proj-9-tuple(v_306) else caught-fail) in
        {932}let e_19: keypair = (if v_307 then 4-proj-9-tuple(v_306) else caught-fail) in
        {933}let m_12: keypair = (if v_307 then 3-proj-9-tuple(v_306) else caught-fail) in
        {934}let s_10: keypair = (if v_307 then 2-proj-9-tuple(v_306) else caught-fail) in
        {935}let ss_48: symmetricstate = (if v_307 then 1-proj-9-tuple(v_306) else caught-fail) in
        {936}let v_308: bitstring = (if v_307 then catch-fail(deconcat3(message_d_1)) else caught-fail) in
        {937}let v_309: bool = (not-caught-fail(v_308) && success?(1-proj-3-tuple(v_308))) in
        {938}let ciphertext_20: bitstring = (if v_309 then 3-proj-3-tuple(v_308) else caught-fail) in
        {939}let ns_8: bitstring = (if v_309 then 2-proj-3-tuple(v_308) else caught-fail) in
        {940}let ne_8: bitstring = (if v_309 then 1-proj-3-tuple(v_308) else caught-fail) in
        {942}let v_310: bitstring = (if v_309 then catch-fail(symmetricstateunpack(ss_48)) else caught-fail) in
        {943}let v_311: bool = (not-caught-fail(v_310) && success?(1-proj-3-tuple(v_310))) in
        {944}let h_42: bitstring = (if v_311 then 3-proj-3-tuple(v_310) else caught-fail) in
        {945}let ck_50: key = (if v_311 then 2-proj-3-tuple(v_310) else caught-fail) in
        {946}let cs_42: cipherstate = (if v_311 then 1-proj-3-tuple(v_310) else caught-fail) in
        {947}let v_312: bitstring = (if v_311 then catch-fail(cipherstateunpack(cs_42)) else caught-fail) in
        {948}let v_313: bool = (not-caught-fail(v_312) && success?(1-proj-2-tuple(v_312))) in
        {949}let n_20: nonce = (if v_313 then 2-proj-2-tuple(v_312) else caught-fail) in
        {950}let k_22: key = (if v_313 then 1-proj-2-tuple(v_312) else caught-fail) in
        {951}let d_3: aead = (if v_313 then catch-fail(decrypt(k_22,n_20,h_42,ciphertext_20)) else caught-fail) in
        {952}let v_314: bool = not-caught-fail(d_3) in
        {953}let v_315: bitstring = (if v_314 then catch-fail(aeadunpack(d_3)) else caught-fail) in
        {954}let v_316: bool = (not-caught-fail(v_315) && success?(1-proj-3-tuple(v_315))) in
        {955}let plaintext_11: bitstring = (if v_316 then 3-proj-3-tuple(v_315) else caught-fail) in
        {956}let adi_3: bitstring = (if v_316 then 2-proj-3-tuple(v_315) else caught-fail) in
        {957}let valid_9: bool = (if v_316 then 1-proj-3-tuple(v_315) else caught-fail) in
        {959}let v_317: bitstring = (if v_316 then catch-fail(cipherstateunpack(cs_42)) else caught-fail) in
        {960}let v_318: bool = (not-caught-fail(v_317) && success?(1-proj-2-tuple(v_317))) in
        {961}let o_10: nonce = (if v_318 then 2-proj-2-tuple(v_317) else caught-fail) in
        {962}let k_23: key = (if v_318 then 1-proj-2-tuple(v_317) else caught-fail) in
        {958}let n_21: nonce = (if v_316 then increment_nonce(n_20) else caught-fail) in
        {963}let csi_20: cipherstate = (if v_316 then catch-fail((if v_318 then cipherstatepack(k_23,n_21) else fail-any)) else caught-fail) in
        {964}let v_319: bool = not-caught-fail(csi_20) in
        {965}let v_320: bitstring = (if v_311 then catch-fail((if v_313 then (if v_314 then (if v_316 then (if v_319 then (csi_20,plaintext_11,valid_9) else fail-any) else fail-any) else fail-any) else fail-any)) else caught-fail) in
        {966}let v_321: bool = (not-caught-fail(v_320) && success?(1-proj-3-tuple(v_320))) in
        {967}let valid_10: bool = (if v_321 then 3-proj-3-tuple(v_320) else caught-fail) in
        {968}let plaintext_12: bitstring = (if v_321 then 2-proj-3-tuple(v_320) else caught-fail) in
        {969}let csi_21: cipherstate = (if v_321 then 1-proj-3-tuple(v_320) else caught-fail) in
        {970}let ss_49: symmetricstate = (if v_321 then symmetricstatepack(csi_21,ck_50,h_42) else caught-fail) in
        {971}let v_322: bitstring = (if v_321 then catch-fail(symmetricstateunpack(ss_49)) else caught-fail) in
        {972}let v_323: bool = (not-caught-fail(v_322) && success?(1-proj-3-tuple(v_322))) in
        {973}let h_43: bitstring = (if v_323 then 3-proj-3-tuple(v_322) else caught-fail) in
        {974}let ck_51: key = (if v_323 then 2-proj-3-tuple(v_322) else caught-fail) in
        {975}let cs_43: cipherstate = (if v_323 then 1-proj-3-tuple(v_322) else caught-fail) in
        {976}let ssi_12: symmetricstate = (if v_321 then catch-fail((if v_323 then symmetricstatepack(cs_43,ck_51,hash(h_43,ciphertext_20)) else fail-any)) else caught-fail) in
        {977}let v_324: bool = not-caught-fail(ssi_12) in
        {978}let v_325: bitstring = (if v_309 then catch-fail((if v_311 then (if v_321 then (if v_324 then (ssi_12,plaintext_12,valid_10) else fail-any) else fail-any) else fail-any)) else caught-fail) in
        {979}let v_326: bool = (not-caught-fail(v_325) && success?(1-proj-3-tuple(v_325))) in
        {980}let valid2_3: bool = (if v_326 then 3-proj-3-tuple(v_325) else caught-fail) in
        {981}let plaintext_13: bitstring = (if v_326 then 2-proj-3-tuple(v_325) else caught-fail) in
        {982}let ss_50: symmetricstate = (if v_326 then 1-proj-3-tuple(v_325) else caught-fail) in
        {941}let valid1_3: bool = (if v_309 then true else caught-fail) in
        {983}let v_327: bool = (if v_326 then catch-fail((valid1_3 && valid2_3)) else caught-fail) in
        {984}let hs_30: handshakestate = (if v_327 then handshakestatepack(ss_50,s_10,m_12,e_19,rs_10,rm_10,re_12,psk_10,initiator_9) else caught-fail) in
        {985}let (hs_31: handshakestate,plaintext_d_1: bitstring,valid_11: bool) = (if v_307 then (if v_309 then (if v_326 then (if undo-catch-fail(v_327) then (hs_30,plaintext_13,true) else fail-any) else fail-any) else fail-any) else fail-any) in
        {986}event RecvMsg(me_1,them_1,stagepack_d(sid_2),plaintext_d_1);
        {987}insert statestore(me_1,them_1,sid_2,statepack_e(hs_31,cs1_8,handshakestategetcs(hs_31)))
    ) | (
        {989}!
        {1046}get statestore(=me_1,=them_1,=sid_2,statepack_e(hs_32: handshakestate,cs1_9: cipherstate,cs2_9: cipherstate)) in
        {990}let hs_33: handshakestate = handshakestatesetcs(hs_32,cs1_9) in
        {992}let v_328: bitstring = catch-fail(handshakestateunpack(hs_33)) in
        {993}let v_329: bool = (not-caught-fail(v_328) && success?(1-proj-9-tuple(v_328))) in
        {994}let initiator_10: bool = (if v_329 then 9-proj-9-tuple(v_328) else caught-fail) in
        {995}let psk_11: key = (if v_329 then 8-proj-9-tuple(v_328) else caught-fail) in
        {996}let re_13: key = (if v_329 then 7-proj-9-tuple(v_328) else caught-fail) in
        {997}let rm_11: key = (if v_329 then 6-proj-9-tuple(v_328) else caught-fail) in
        {998}let rs_11: key = (if v_329 then 5-proj-9-tuple(v_328) else caught-fail) in
        {999}let e_20: keypair = (if v_329 then 4-proj-9-tuple(v_328) else caught-fail) in
        {1000}let m_13: keypair = (if v_329 then 3-proj-9-tuple(v_328) else caught-fail) in
        {1001}let s_11: keypair = (if v_329 then 2-proj-9-tuple(v_328) else caught-fail) in
        {1002}let ss_51: symmetricstate = (if v_329 then 1-proj-9-tuple(v_328) else caught-fail) in
        {1003}let v_330: bitstring = (if v_329 then catch-fail((empty,empty,empty)) else caught-fail) in
        {1004}let v_331: bool = (not-caught-fail(v_330) && success?(1-proj-3-tuple(v_330))) in
        {1005}let ciphertext_21: bitstring = (if v_331 then 3-proj-3-tuple(v_330) else caught-fail) in
        {1006}let ns_9: bitstring = (if v_331 then 2-proj-3-tuple(v_330) else caught-fail) in
        {1007}let ne_9: bitstring = (if v_331 then 1-proj-3-tuple(v_330) else caught-fail) in
        {1008}let v_332: bitstring = (if v_331 then catch-fail(symmetricstateunpack(ss_51)) else caught-fail) in
        {1009}let v_333: bool = (not-caught-fail(v_332) && success?(1-proj-3-tuple(v_332))) in
        {1010}let h_44: bitstring = (if v_333 then 3-proj-3-tuple(v_332) else caught-fail) in
        {1011}let ck_52: key = (if v_333 then 2-proj-3-tuple(v_332) else caught-fail) in
        {1012}let cs_44: cipherstate = (if v_333 then 1-proj-3-tuple(v_332) else caught-fail) in
        {1013}let v_334: bitstring = (if v_333 then catch-fail(cipherstateunpack(cs_44)) else caught-fail) in
        {1014}let v_335: bool = (not-caught-fail(v_334) && success?(1-proj-2-tuple(v_334))) in
        {1015}let n_22: nonce = (if v_335 then 2-proj-2-tuple(v_334) else caught-fail) in
        {1016}let k_24: key = (if v_335 then 1-proj-2-tuple(v_334) else caught-fail) in
        {1019}let v_336: bitstring = (if v_335 then catch-fail(cipherstateunpack(cs_44)) else caught-fail) in
        {1020}let v_337: bool = (not-caught-fail(v_336) && success?(1-proj-2-tuple(v_336))) in
        {1021}let o_11: nonce = (if v_337 then 2-proj-2-tuple(v_336) else caught-fail) in
        {1022}let k_25: key = (if v_337 then 1-proj-2-tuple(v_336) else caught-fail) in
        {1018}let n_23: nonce = (if v_335 then increment_nonce(n_22) else caught-fail) in
        {1023}let csi_22: cipherstate = (if v_335 then catch-fail((if v_337 then cipherstatepack(k_25,n_23) else fail-any)) else caught-fail) in
        {1024}let v_338: bool = not-caught-fail(csi_22) in
        {991}let payload_5: bitstring = msg_e(me_1,them_1,sid_2) in
        {1017}let e_21: bitstring = (if v_335 then encrypt(k_24,n_22,h_44,payload_5) else caught-fail) in
        {1025}let v_339: bitstring = (if v_333 then catch-fail((if v_335 then (if v_338 then (csi_22,e_21) else fail-any) else fail-any)) else caught-fail) in
        {1026}let v_340: bool = (not-caught-fail(v_339) && success?(1-proj-2-tuple(v_339))) in
        {1027}let ciphertext_22: bitstring = (if v_340 then 2-proj-2-tuple(v_339) else caught-fail) in
        {1028}let csi_23: cipherstate = (if v_340 then 1-proj-2-tuple(v_339) else caught-fail) in
        {1029}let ss_52: symmetricstate = (if v_340 then symmetricstatepack(csi_23,ck_52,h_44) else caught-fail) in
        {1030}let v_341: bitstring = (if v_340 then catch-fail(symmetricstateunpack(ss_52)) else caught-fail) in
        {1031}let v_342: bool = (not-caught-fail(v_341) && success?(1-proj-3-tuple(v_341))) in
        {1032}let h_45: bitstring = (if v_342 then 3-proj-3-tuple(v_341) else caught-fail) in
        {1033}let ck_53: key = (if v_342 then 2-proj-3-tuple(v_341) else caught-fail) in
        {1034}let cs_45: cipherstate = (if v_342 then 1-proj-3-tuple(v_341) else caught-fail) in
        {1035}let ssi_13: symmetricstate = (if v_340 then catch-fail((if v_342 then symmetricstatepack(cs_45,ck_53,hash(h_45,ciphertext_22)) else fail-any)) else caught-fail) in
        {1036}let v_343: bool = not-caught-fail(ssi_13) in
        {1037}let v_344: bitstring = (if v_331 then catch-fail((if v_333 then (if v_340 then (if v_343 then (ssi_13,ciphertext_22) else fail-any) else fail-any) else fail-any)) else caught-fail) in
        {1038}let v_345: bool = (not-caught-fail(v_344) && success?(1-proj-2-tuple(v_344))) in
        {1039}let ciphertext_23: bitstring = (if v_345 then 2-proj-2-tuple(v_344) else caught-fail) in
        {1040}let ss_53: symmetricstate = (if v_345 then 1-proj-2-tuple(v_344) else caught-fail) in
        {1042}let message_buffer_5: bitstring = (if v_345 then concat3(ne_9,ns_9,ciphertext_23) else caught-fail) in
        {1041}let hs_34: handshakestate = (if v_345 then handshakestatepack(ss_53,s_11,m_13,e_20,rs_11,rm_11,re_13,psk_11,initiator_10) else caught-fail) in
        {1043}let (hs_35: handshakestate,message_e_1: bitstring) = (if v_329 then (if v_331 then (if v_345 then (hs_34,message_buffer_5) else fail-any) else fail-any) else fail-any) in
        {1044}event SendMsg(me_1,them_1,stagepack_e(sid_2),msg_e(me_1,them_1,sid_2));
        {1045}out(pub, message_e_1)
    ) | (
        {1047}event LeakS(phase0,me_1);
        {1048}event LeakM(phase0,me_1);
        {1049}out(pub, (key_s(me_1),key_m(me_1)))
    ) | (
        {1050}phase 1;
        {1051}event LeakS(phase1,me_1);
        {1052}event LeakM(phase1,me_1);
        {1053}out(pub, (key_s(me_1),key_m(me_1)))
    )
) | (
    {1054}let me_2: principal = bob in
    {1057}let basis_8: key = key_s(me_2) in
    {1058}let public_key_8: key = catch-fail(dhexp(basis_8,validkey(g))) in
    {1059}let v_346: bool = not-caught-fail(public_key_8) in
    {1060}let s_12: keypair = (if v_346 then keypairpack(validkey(public_key_8),basis_8) else fail-any) in
    {1061}let basis_9: key = key_m(me_2) in
    {1062}let public_key_9: key = catch-fail(dhexp(basis_9,validkey(g))) in
    {1063}let v_347: bool = not-caught-fail(public_key_9) in
    {1064}let m_14: keypair = (if v_347 then keypairpack(validkey(public_key_9),basis_9) else fail-any) in
    {1065}out(pub, (getpublickey(s_12),getpublickey(m_14)));
    {1056}let sid_3: sessionid = sid in
    {1055}let them_2: principal = alice in
    (
        {1075}let k_26: key = empty in
        {1076}let cs_46: cipherstate = cipherstatepack(k_26,minnonce) in
        {1072}let protocol_name_2: bitstring = somename in
        {1073}let h_46: bitstring = hash(protocol_name_2,empty) in
        {1074}let ck_54: key = h_46 in
        {1077}let ss_54: symmetricstate = symmetricstatepack(cs_46,ck_54,h_46) in
        {1078}let v_348: bitstring = catch-fail(symmetricstateunpack(ss_54)) in
        {1079}let v_349: bool = (not-caught-fail(v_348) && success?(1-proj-3-tuple(v_348))) in
        {1080}let h_47: bitstring = (if v_349 then 3-proj-3-tuple(v_348) else caught-fail) in
        {1081}let ck_55: key = (if v_349 then 2-proj-3-tuple(v_348) else caught-fail) in
        {1082}let cs_47: cipherstate = (if v_349 then 1-proj-3-tuple(v_348) else caught-fail) in
        {1070}let prologue_2: bitstring = empty in
        {1083}let ss_55: symmetricstate = catch-fail((if v_349 then symmetricstatepack(cs_47,ck_55,hash(h_47,prologue_2)) else fail-any)) in
        {1084}let v_350: bool = not-caught-fail(ss_55) in
        {1085}let data: bitstring = (if v_350 then catch-fail(getpublickey(s_12)) else caught-fail) in
        {1086}let v_351: bool = not-caught-fail(data) in
        {1087}let v_352: bitstring = (if v_351 then catch-fail(symmetricstateunpack(ss_55)) else caught-fail) in
        {1088}let v_353: bool = (not-caught-fail(v_352) && success?(1-proj-3-tuple(v_352))) in
        {1089}let h_48: bitstring = (if v_353 then 3-proj-3-tuple(v_352) else caught-fail) in
        {1090}let ck_56: key = (if v_353 then 2-proj-3-tuple(v_352) else caught-fail) in
        {1091}let cs_48: cipherstate = (if v_353 then 1-proj-3-tuple(v_352) else caught-fail) in
        {1092}let ss_56: symmetricstate = (if v_350 then catch-fail((if v_351 then (if v_353 then symmetricstatepack(cs_48,ck_56,hash(h_48,data)) else fail-any) else fail-any)) else caught-fail) in
        {1093}let v_354: bool = not-caught-fail(ss_56) in
        {1094}let data_1: bitstring = (if v_354 then catch-fail(getpublickey(m_14)) else caught-fail) in
        {1095}let v_355: bool = not-caught-fail(data_1) in
        {1096}let v_356: bitstring = (if v_355 then catch-fail(symmetricstateunpack(ss_56)) else caught-fail) in
        {1097}let v_357: bool = (not-caught-fail(v_356) && success?(1-proj-3-tuple(v_356))) in
        {1098}let h_49: bitstring = (if v_357 then 3-proj-3-tuple(v_356) else caught-fail) in
        {1099}let ck_57: key = (if v_357 then 2-proj-3-tuple(v_356) else caught-fail) in
        {1100}let cs_49: cipherstate = (if v_357 then 1-proj-3-tuple(v_356) else caught-fail) in
        {1101}let ss_57: symmetricstate = (if v_354 then catch-fail((if v_355 then (if v_357 then symmetricstatepack(cs_49,ck_57,hash(h_49,data_1)) else fail-any) else fail-any)) else caught-fail) in
        {1102}let v_358: bool = not-caught-fail(ss_57) in
        {1071}let psk_12: key = empty in
        {1069}let re_14: key = empty in
        {1068}let rm_12: key = empty in
        {1067}let rs_12: key = empty in
        {1066}let e_22: keypair = keypairpack(empty,empty) in
        {1103}let hs_36: handshakestate = (if v_350 then (if v_354 then (if v_358 then handshakestatepack(ss_57,s_12,m_14,e_22,rs_12,rm_12,re_14,psk_12,false) else fail-any) else fail-any) else fail-any) in
        {1104}insert statestore(me_2,them_2,sid_3,statepack_a(hs_36))
    ) | (
        {1219}get statestore(=me_2,=them_2,=sid_3,statepack_a(hs_37: handshakestate)) in
        {1105}in(pub, message_a_2: bitstring);
        {1106}let v_359: bitstring = catch-fail(handshakestateunpack(hs_37)) in
        {1107}let v_360: bool = (not-caught-fail(v_359) && success?(1-proj-9-tuple(v_359))) in
        {1108}let initiator_11: bool = (if v_360 then 9-proj-9-tuple(v_359) else caught-fail) in
        {1109}let psk_13: key = (if v_360 then 8-proj-9-tuple(v_359) else caught-fail) in
        {1110}let re_15: key = (if v_360 then 7-proj-9-tuple(v_359) else caught-fail) in
        {1111}let rm_13: key = (if v_360 then 6-proj-9-tuple(v_359) else caught-fail) in
        {1112}let rs_13: key = (if v_360 then 5-proj-9-tuple(v_359) else caught-fail) in
        {1113}let e_23: keypair = (if v_360 then 4-proj-9-tuple(v_359) else caught-fail) in
        {1114}let m_15: keypair = (if v_360 then 3-proj-9-tuple(v_359) else caught-fail) in
        {1115}let s_13: keypair = (if v_360 then 2-proj-9-tuple(v_359) else caught-fail) in
        {1116}let ss_58: symmetricstate = (if v_360 then 1-proj-9-tuple(v_359) else caught-fail) in
        {1117}let v_361: bitstring = (if v_360 then catch-fail(deconcat3(message_a_2)) else caught-fail) in
        {1118}let v_362: bool = (not-caught-fail(v_361) && success?(1-proj-3-tuple(v_361))) in
        {1119}let ciphertext_24: bitstring = (if v_362 then 3-proj-3-tuple(v_361) else caught-fail) in
        {1120}let ns_10: bitstring = (if v_362 then 2-proj-3-tuple(v_361) else caught-fail) in
        {1121}let ne_10: bitstring = (if v_362 then 1-proj-3-tuple(v_361) else caught-fail) in
        {1124}let v_363: bitstring = (if v_362 then catch-fail(symmetricstateunpack(ss_58)) else caught-fail) in
        {1125}let v_364: bool = (not-caught-fail(v_363) && success?(1-proj-3-tuple(v_363))) in
        {1126}let h_50: bitstring = (if v_364 then 3-proj-3-tuple(v_363) else caught-fail) in
        {1127}let ck_58: key = (if v_364 then 2-proj-3-tuple(v_363) else caught-fail) in
        {1128}let cs_50: cipherstate = (if v_364 then 1-proj-3-tuple(v_363) else caught-fail) in
        {1123}let re_16: key = (if v_362 then ne_10 else caught-fail) in
        {1129}let ss_59: symmetricstate = (if v_362 then catch-fail((if v_364 then symmetricstatepack(cs_50,ck_58,hash(h_50,re_16)) else fail-any)) else caught-fail) in
        {1130}let v_365: bool = not-caught-fail(ss_59) in
        {1131}let v_366: bitstring = (if v_365 then catch-fail(keypairunpack(s_13)) else caught-fail) in
        {1132}let v_367: bool = (not-caught-fail(v_366) && success?(1-proj-2-tuple(v_366))) in
        {1133}let my_private_key_8: key = (if v_367 then 2-proj-2-tuple(v_366) else caught-fail) in
        {1134}let my_public_key_8: key = (if v_367 then 1-proj-2-tuple(v_366) else caught-fail) in
        {1135}let input_key_material_10: key = (if v_365 then catch-fail((if v_367 then dhexp(my_private_key_8,re_16) else fail-any)) else caught-fail) in
        {1136}let v_368: bool = not-caught-fail(input_key_material_10) in
        {1137}let v_369: bitstring = (if v_368 then catch-fail(symmetricstateunpack(ss_59)) else caught-fail) in
        {1138}let v_370: bool = (not-caught-fail(v_369) && success?(1-proj-3-tuple(v_369))) in
        {1139}let h_51: bitstring = (if v_370 then 3-proj-3-tuple(v_369) else caught-fail) in
        {1140}let ck_59: key = (if v_370 then 2-proj-3-tuple(v_369) else caught-fail) in
        {1141}let cs_51: cipherstate = (if v_370 then 1-proj-3-tuple(v_369) else caught-fail) in
        {1144}let output3_10: key = (if v_370 then hmac_hash3(ck_59,input_key_material_10) else caught-fail) in
        {1143}let output2_10: key = (if v_370 then hmac_hash2(ck_59,input_key_material_10) else caught-fail) in
        {1142}let output1_10: key = (if v_370 then hmac_hash1(ck_59,input_key_material_10) else caught-fail) in
        {1145}let v_371: bitstring = (if v_370 then catch-fail((output1_10,output2_10,output3_10)) else caught-fail) in
        {1146}let v_372: bool = (not-caught-fail(v_371) && success?(1-proj-3-tuple(v_371))) in
        {1147}let output_8: key = (if v_372 then 3-proj-3-tuple(v_371) else caught-fail) in
        {1148}let temp_k_8: key = (if v_372 then 2-proj-3-tuple(v_371) else caught-fail) in
        {1149}let ck_60: key = (if v_372 then 1-proj-3-tuple(v_371) else caught-fail) in
        {1150}let ss_60: symmetricstate = (if v_365 then catch-fail((if v_368 then (if v_370 then (if v_372 then symmetricstatepack(cipherstatepack(temp_k_8,minnonce),ck_60,h_51) else fail-any) else fail-any) else fail-any)) else caught-fail) in
        {1151}let v_373: bool = not-caught-fail(ss_60) in
        {1152}let v_374: bitstring = (if v_373 then catch-fail(keypairunpack(m_15)) else caught-fail) in
        {1153}let v_375: bool = (not-caught-fail(v_374) && success?(1-proj-2-tuple(v_374))) in
        {1154}let my_private_key_9: key = (if v_375 then 2-proj-2-tuple(v_374) else caught-fail) in
        {1155}let my_public_key_9: key = (if v_375 then 1-proj-2-tuple(v_374) else caught-fail) in
        {1156}let input_key_material_11: key = (if v_373 then catch-fail((if v_375 then dhexp(my_private_key_9,re_16) else fail-any)) else caught-fail) in
        {1157}let v_376: bool = not-caught-fail(input_key_material_11) in
        {1158}let v_377: bitstring = (if v_376 then catch-fail(symmetricstateunpack(ss_60)) else caught-fail) in
        {1159}let v_378: bool = (not-caught-fail(v_377) && success?(1-proj-3-tuple(v_377))) in
        {1160}let h_52: bitstring = (if v_378 then 3-proj-3-tuple(v_377) else caught-fail) in
        {1161}let ck_61: key = (if v_378 then 2-proj-3-tuple(v_377) else caught-fail) in
        {1162}let cs_52: cipherstate = (if v_378 then 1-proj-3-tuple(v_377) else caught-fail) in
        {1165}let output3_11: key = (if v_378 then hmac_hash3(ck_61,input_key_material_11) else caught-fail) in
        {1164}let output2_11: key = (if v_378 then hmac_hash2(ck_61,input_key_material_11) else caught-fail) in
        {1163}let output1_11: key = (if v_378 then hmac_hash1(ck_61,input_key_material_11) else caught-fail) in
        {1166}let v_379: bitstring = (if v_378 then catch-fail((output1_11,output2_11,output3_11)) else caught-fail) in
        {1167}let v_380: bool = (not-caught-fail(v_379) && success?(1-proj-3-tuple(v_379))) in
        {1168}let output_9: key = (if v_380 then 3-proj-3-tuple(v_379) else caught-fail) in
        {1169}let temp_k_9: key = (if v_380 then 2-proj-3-tuple(v_379) else caught-fail) in
        {1170}let ck_62: key = (if v_380 then 1-proj-3-tuple(v_379) else caught-fail) in
        {1171}let ss_61: symmetricstate = (if v_373 then catch-fail((if v_376 then (if v_378 then (if v_380 then symmetricstatepack(cipherstatepack(temp_k_9,minnonce),ck_62,h_52) else fail-any) else fail-any) else fail-any)) else caught-fail) in
        {1172}let v_381: bool = not-caught-fail(ss_61) in
        {1173}let v_382: bitstring = (if v_381 then catch-fail(symmetricstateunpack(ss_61)) else caught-fail) in
        {1174}let v_383: bool = (not-caught-fail(v_382) && success?(1-proj-3-tuple(v_382))) in
        {1175}let h_53: bitstring = (if v_383 then 3-proj-3-tuple(v_382) else caught-fail) in
        {1176}let ck_63: key = (if v_383 then 2-proj-3-tuple(v_382) else caught-fail) in
        {1177}let cs_53: cipherstate = (if v_383 then 1-proj-3-tuple(v_382) else caught-fail) in
        {1178}let v_384: bitstring = (if v_383 then catch-fail(cipherstateunpack(cs_53)) else caught-fail) in
        {1179}let v_385: bool = (not-caught-fail(v_384) && success?(1-proj-2-tuple(v_384))) in
        {1180}let n_24: nonce = (if v_385 then 2-proj-2-tuple(v_384) else caught-fail) in
        {1181}let k_27: key = (if v_385 then 1-proj-2-tuple(v_384) else caught-fail) in
        {1182}let d_4: aead = (if v_385 then catch-fail(decrypt(k_27,n_24,h_53,ciphertext_24)) else caught-fail) in
        {1183}let v_386: bool = not-caught-fail(d_4) in
        {1184}let v_387: bitstring = (if v_386 then catch-fail(aeadunpack(d_4)) else caught-fail) in
        {1185}let v_388: bool = (not-caught-fail(v_387) && success?(1-proj-3-tuple(v_387))) in
        {1186}let plaintext_14: bitstring = (if v_388 then 3-proj-3-tuple(v_387) else caught-fail) in
        {1187}let adi_4: bitstring = (if v_388 then 2-proj-3-tuple(v_387) else caught-fail) in
        {1188}let valid_12: bool = (if v_388 then 1-proj-3-tuple(v_387) else caught-fail) in
        {1190}let v_389: bitstring = (if v_388 then catch-fail(cipherstateunpack(cs_53)) else caught-fail) in
        {1191}let v_390: bool = (not-caught-fail(v_389) && success?(1-proj-2-tuple(v_389))) in
        {1192}let o_12: nonce = (if v_390 then 2-proj-2-tuple(v_389) else caught-fail) in
        {1193}let k_28: key = (if v_390 then 1-proj-2-tuple(v_389) else caught-fail) in
        {1189}let n_25: nonce = (if v_388 then increment_nonce(n_24) else caught-fail) in
        {1194}let csi_24: cipherstate = (if v_388 then catch-fail((if v_390 then cipherstatepack(k_28,n_25) else fail-any)) else caught-fail) in
        {1195}let v_391: bool = not-caught-fail(csi_24) in
        {1196}let v_392: bitstring = (if v_383 then catch-fail((if v_385 then (if v_386 then (if v_388 then (if v_391 then (csi_24,plaintext_14,valid_12) else fail-any) else fail-any) else fail-any) else fail-any)) else caught-fail) in
        {1197}let v_393: bool = (not-caught-fail(v_392) && success?(1-proj-3-tuple(v_392))) in
        {1198}let valid_13: bool = (if v_393 then 3-proj-3-tuple(v_392) else caught-fail) in
        {1199}let plaintext_15: bitstring = (if v_393 then 2-proj-3-tuple(v_392) else caught-fail) in
        {1200}let csi_25: cipherstate = (if v_393 then 1-proj-3-tuple(v_392) else caught-fail) in
        {1201}let ss_62: symmetricstate = (if v_393 then symmetricstatepack(csi_25,ck_63,h_53) else caught-fail) in
        {1202}let v_394: bitstring = (if v_393 then catch-fail(symmetricstateunpack(ss_62)) else caught-fail) in
        {1203}let v_395: bool = (not-caught-fail(v_394) && success?(1-proj-3-tuple(v_394))) in
        {1204}let h_54: bitstring = (if v_395 then 3-proj-3-tuple(v_394) else caught-fail) in
        {1205}let ck_64: key = (if v_395 then 2-proj-3-tuple(v_394) else caught-fail) in
        {1206}let cs_54: cipherstate = (if v_395 then 1-proj-3-tuple(v_394) else caught-fail) in
        {1207}let ssi_14: symmetricstate = (if v_393 then catch-fail((if v_395 then symmetricstatepack(cs_54,ck_64,hash(h_54,ciphertext_24)) else fail-any)) else caught-fail) in
        {1208}let v_396: bool = not-caught-fail(ssi_14) in
        {1209}let v_397: bitstring = (if v_381 then catch-fail((if v_383 then (if v_393 then (if v_396 then (ssi_14,plaintext_15,valid_13) else fail-any) else fail-any) else fail-any)) else caught-fail) in
        {1210}let v_398: bool = (not-caught-fail(v_397) && success?(1-proj-3-tuple(v_397))) in
        {1211}let valid2_4: bool = (if v_398 then 3-proj-3-tuple(v_397) else caught-fail) in
        {1212}let plaintext_16: bitstring = (if v_398 then 2-proj-3-tuple(v_397) else caught-fail) in
        {1213}let ss_63: symmetricstate = (if v_398 then 1-proj-3-tuple(v_397) else caught-fail) in
        {1122}let valid1_4: bool = (if v_362 then true else caught-fail) in
        {1214}let v_399: bool = (if v_398 then catch-fail((valid1_4 && valid2_4)) else caught-fail) in
        {1215}let hs_38: handshakestate = (if v_399 then handshakestatepack(ss_63,s_13,m_15,e_23,rs_13,rm_13,re_16,psk_13,initiator_11) else caught-fail) in
        {1216}let (hs_39: handshakestate,plaintext_a: bitstring,valid_14: bool) = (if v_360 then (if v_362 then (if v_365 then (if v_373 then (if v_381 then (if v_398 then (if undo-catch-fail(v_399) then (hs_38,plaintext_16,true) else fail-any) else fail-any) else fail-any) else fail-any) else fail-any) else fail-any) else fail-any) in
        {1217}event RecvMsg(me_2,them_2,stagepack_a(sid_3),plaintext_a);
        {1218}insert statestore(me_2,them_2,sid_3,statepack_b(hs_39))
    ) | (
        {1311}get statestore(=me_2,=them_2,=sid_3,statepack_b(hs_40: handshakestate)) in
        {1221}let v_400: bitstring = catch-fail(handshakestateunpack(hs_40)) in
        {1222}let v_401: bool = (not-caught-fail(v_400) && success?(1-proj-9-tuple(v_400))) in
        {1223}let initiator_12: bool = (if v_401 then 9-proj-9-tuple(v_400) else caught-fail) in
        {1224}let psk_14: key = (if v_401 then 8-proj-9-tuple(v_400) else caught-fail) in
        {1225}let re_17: key = (if v_401 then 7-proj-9-tuple(v_400) else caught-fail) in
        {1226}let rm_14: key = (if v_401 then 6-proj-9-tuple(v_400) else caught-fail) in
        {1227}let rs_14: key = (if v_401 then 5-proj-9-tuple(v_400) else caught-fail) in
        {1228}let e_24: keypair = (if v_401 then 4-proj-9-tuple(v_400) else caught-fail) in
        {1229}let m_16: keypair = (if v_401 then 3-proj-9-tuple(v_400) else caught-fail) in
        {1230}let s_14: keypair = (if v_401 then 2-proj-9-tuple(v_400) else caught-fail) in
        {1231}let ss_64: symmetricstate = (if v_401 then 1-proj-9-tuple(v_400) else caught-fail) in
        {1232}let v_402: bitstring = (if v_401 then catch-fail((empty,empty,empty)) else caught-fail) in
        {1233}let v_403: bool = (not-caught-fail(v_402) && success?(1-proj-3-tuple(v_402))) in
        {1234}let ciphertext_25: bitstring = (if v_403 then 3-proj-3-tuple(v_402) else caught-fail) in
        {1235}let ns_11: bitstring = (if v_403 then 2-proj-3-tuple(v_402) else caught-fail) in
        {1236}let ne_11: bitstring = (if v_403 then 1-proj-3-tuple(v_402) else caught-fail) in
        {1237}let basis_10: key = (if v_403 then key_e(me_2,them_2,sid_3) else caught-fail) in
        {1238}let public_key_10: key = (if v_403 then catch-fail(dhexp(basis_10,validkey(g))) else caught-fail) in
        {1239}let v_404: bool = not-caught-fail(public_key_10) in
        {1240}let e_25: keypair = (if v_403 then catch-fail((if v_404 then keypairpack(validkey(public_key_10),basis_10) else fail-any)) else caught-fail) in
        {1241}let v_405: bool = not-caught-fail(e_25) in
        {1242}let ne_12: bitstring = (if v_405 then catch-fail(getpublickey(e_25)) else caught-fail) in
        {1243}let v_406: bool = not-caught-fail(ne_12) in
        {1244}let v_407: bitstring = (if v_406 then catch-fail(symmetricstateunpack(ss_64)) else caught-fail) in
        {1245}let v_408: bool = (not-caught-fail(v_407) && success?(1-proj-3-tuple(v_407))) in
        {1246}let h_55: bitstring = (if v_408 then 3-proj-3-tuple(v_407) else caught-fail) in
        {1247}let ck_65: key = (if v_408 then 2-proj-3-tuple(v_407) else caught-fail) in
        {1248}let cs_55: cipherstate = (if v_408 then 1-proj-3-tuple(v_407) else caught-fail) in
        {1249}let ss_65: symmetricstate = (if v_406 then catch-fail((if v_408 then symmetricstatepack(cs_55,ck_65,hash(h_55,ne_12)) else fail-any)) else caught-fail) in
        {1250}let v_409: bool = not-caught-fail(ss_65) in
        {1251}let v_410: bitstring = (if v_409 then catch-fail(keypairunpack(e_25)) else caught-fail) in
        {1252}let v_411: bool = (not-caught-fail(v_410) && success?(1-proj-2-tuple(v_410))) in
        {1253}let my_private_key_10: key = (if v_411 then 2-proj-2-tuple(v_410) else caught-fail) in
        {1254}let my_public_key_10: key = (if v_411 then 1-proj-2-tuple(v_410) else caught-fail) in
        {1255}let input_key_material_12: key = (if v_409 then catch-fail((if v_411 then dhexp(my_private_key_10,re_17) else fail-any)) else caught-fail) in
        {1256}let v_412: bool = not-caught-fail(input_key_material_12) in
        {1257}let v_413: bitstring = (if v_412 then catch-fail(symmetricstateunpack(ss_65)) else caught-fail) in
        {1258}let v_414: bool = (not-caught-fail(v_413) && success?(1-proj-3-tuple(v_413))) in
        {1259}let h_56: bitstring = (if v_414 then 3-proj-3-tuple(v_413) else caught-fail) in
        {1260}let ck_66: key = (if v_414 then 2-proj-3-tuple(v_413) else caught-fail) in
        {1261}let cs_56: cipherstate = (if v_414 then 1-proj-3-tuple(v_413) else caught-fail) in
        {1264}let output3_12: key = (if v_414 then hmac_hash3(ck_66,input_key_material_12) else caught-fail) in
        {1263}let output2_12: key = (if v_414 then hmac_hash2(ck_66,input_key_material_12) else caught-fail) in
        {1262}let output1_12: key = (if v_414 then hmac_hash1(ck_66,input_key_material_12) else caught-fail) in
        {1265}let v_415: bitstring = (if v_414 then catch-fail((output1_12,output2_12,output3_12)) else caught-fail) in
        {1266}let v_416: bool = (not-caught-fail(v_415) && success?(1-proj-3-tuple(v_415))) in
        {1267}let output_10: key = (if v_416 then 3-proj-3-tuple(v_415) else caught-fail) in
        {1268}let temp_k_10: key = (if v_416 then 2-proj-3-tuple(v_415) else caught-fail) in
        {1269}let ck_67: key = (if v_416 then 1-proj-3-tuple(v_415) else caught-fail) in
        {1270}let ss_66: symmetricstate = (if v_409 then catch-fail((if v_412 then (if v_414 then (if v_416 then symmetricstatepack(cipherstatepack(temp_k_10,minnonce),ck_67,h_56) else fail-any) else fail-any) else fail-any)) else caught-fail) in
        {1271}let v_417: bool = not-caught-fail(ss_66) in
        {1272}let v_418: bitstring = (if v_417 then catch-fail(symmetricstateunpack(ss_66)) else caught-fail) in
        {1273}let v_419: bool = (not-caught-fail(v_418) && success?(1-proj-3-tuple(v_418))) in
        {1274}let h_57: bitstring = (if v_419 then 3-proj-3-tuple(v_418) else caught-fail) in
        {1275}let ck_68: key = (if v_419 then 2-proj-3-tuple(v_418) else caught-fail) in
        {1276}let cs_57: cipherstate = (if v_419 then 1-proj-3-tuple(v_418) else caught-fail) in
        {1277}let v_420: bitstring = (if v_419 then catch-fail(cipherstateunpack(cs_57)) else caught-fail) in
        {1278}let v_421: bool = (not-caught-fail(v_420) && success?(1-proj-2-tuple(v_420))) in
        {1279}let n_26: nonce = (if v_421 then 2-proj-2-tuple(v_420) else caught-fail) in
        {1280}let k_29: key = (if v_421 then 1-proj-2-tuple(v_420) else caught-fail) in
        {1283}let v_422: bitstring = (if v_421 then catch-fail(cipherstateunpack(cs_57)) else caught-fail) in
        {1284}let v_423: bool = (not-caught-fail(v_422) && success?(1-proj-2-tuple(v_422))) in
        {1285}let o_13: nonce = (if v_423 then 2-proj-2-tuple(v_422) else caught-fail) in
        {1286}let k_30: key = (if v_423 then 1-proj-2-tuple(v_422) else caught-fail) in
        {1282}let n_27: nonce = (if v_421 then increment_nonce(n_26) else caught-fail) in
        {1287}let csi_26: cipherstate = (if v_421 then catch-fail((if v_423 then cipherstatepack(k_30,n_27) else fail-any)) else caught-fail) in
        {1288}let v_424: bool = not-caught-fail(csi_26) in
        {1220}let payload_6: bitstring = msg_b(me_2,them_2,sid_3) in
        {1281}let e_26: bitstring = (if v_421 then encrypt(k_29,n_26,h_57,payload_6) else caught-fail) in
        {1289}let v_425: bitstring = (if v_419 then catch-fail((if v_421 then (if v_424 then (csi_26,e_26) else fail-any) else fail-any)) else caught-fail) in
        {1290}let v_426: bool = (not-caught-fail(v_425) && success?(1-proj-2-tuple(v_425))) in
        {1291}let ciphertext_26: bitstring = (if v_426 then 2-proj-2-tuple(v_425) else caught-fail) in
        {1292}let csi_27: cipherstate = (if v_426 then 1-proj-2-tuple(v_425) else caught-fail) in
        {1293}let ss_67: symmetricstate = (if v_426 then symmetricstatepack(csi_27,ck_68,h_57) else caught-fail) in
        {1294}let v_427: bitstring = (if v_426 then catch-fail(symmetricstateunpack(ss_67)) else caught-fail) in
        {1295}let v_428: bool = (not-caught-fail(v_427) && success?(1-proj-3-tuple(v_427))) in
        {1296}let h_58: bitstring = (if v_428 then 3-proj-3-tuple(v_427) else caught-fail) in
        {1297}let ck_69: key = (if v_428 then 2-proj-3-tuple(v_427) else caught-fail) in
        {1298}let cs_58: cipherstate = (if v_428 then 1-proj-3-tuple(v_427) else caught-fail) in
        {1299}let ssi_15: symmetricstate = (if v_426 then catch-fail((if v_428 then symmetricstatepack(cs_58,ck_69,hash(h_58,ciphertext_26)) else fail-any)) else caught-fail) in
        {1300}let v_429: bool = not-caught-fail(ssi_15) in
        {1301}let v_430: bitstring = (if v_417 then catch-fail((if v_419 then (if v_426 then (if v_429 then (ssi_15,ciphertext_26) else fail-any) else fail-any) else fail-any)) else caught-fail) in
        {1302}let v_431: bool = (not-caught-fail(v_430) && success?(1-proj-2-tuple(v_430))) in
        {1303}let ciphertext_27: bitstring = (if v_431 then 2-proj-2-tuple(v_430) else caught-fail) in
        {1304}let ss_68: symmetricstate = (if v_431 then 1-proj-2-tuple(v_430) else caught-fail) in
        {1306}let message_buffer_6: bitstring = (if v_431 then concat3(ne_12,ns_11,ciphertext_27) else caught-fail) in
        {1305}let hs_41: handshakestate = (if v_431 then handshakestatepack(ss_68,s_14,m_16,e_25,rs_14,rm_14,re_17,psk_14,initiator_12) else caught-fail) in
        {1307}let (hs_42: handshakestate,message_b_2: bitstring) = (if v_401 then (if v_403 then (if v_405 then (if v_406 then (if v_409 then (if v_417 then (if v_431 then (hs_41,message_buffer_6) else fail-any) else fail-any) else fail-any) else fail-any) else fail-any) else fail-any) else fail-any) in
        {1308}event SendMsg(me_2,them_2,stagepack_b(sid_3),msg_b(me_2,them_2,sid_3));
        {1309}insert statestore(me_2,them_2,sid_3,statepack_c(hs_42));
        {1310}out(pub, message_b_2)
    ) | (
        {1463}get statestore(=me_2,=them_2,=sid_3,statepack_c(hs_43: handshakestate)) in
        {1312}in(pub, message_c_2: bitstring);
        {1313}let v_432: bitstring = catch-fail(handshakestateunpack(hs_43)) in
        {1314}let v_433: bool = (not-caught-fail(v_432) && success?(1-proj-9-tuple(v_432))) in
        {1315}let initiator_13: bool = (if v_433 then 9-proj-9-tuple(v_432) else caught-fail) in
        {1316}let psk_15: key = (if v_433 then 8-proj-9-tuple(v_432) else caught-fail) in
        {1317}let re_18: key = (if v_433 then 7-proj-9-tuple(v_432) else caught-fail) in
        {1318}let rm_15: key = (if v_433 then 6-proj-9-tuple(v_432) else caught-fail) in
        {1319}let rs_15: key = (if v_433 then 5-proj-9-tuple(v_432) else caught-fail) in
        {1320}let e_27: keypair = (if v_433 then 4-proj-9-tuple(v_432) else caught-fail) in
        {1321}let m_17: keypair = (if v_433 then 3-proj-9-tuple(v_432) else caught-fail) in
        {1322}let s_15: keypair = (if v_433 then 2-proj-9-tuple(v_432) else caught-fail) in
        {1323}let ss_69: symmetricstate = (if v_433 then 1-proj-9-tuple(v_432) else caught-fail) in
        {1324}let v_434: bitstring = (if v_433 then catch-fail(deconcat3(message_c_2)) else caught-fail) in
        {1325}let v_435: bool = (not-caught-fail(v_434) && success?(1-proj-3-tuple(v_434))) in
        {1326}let ciphertext_28: bitstring = (if v_435 then 3-proj-3-tuple(v_434) else caught-fail) in
        {1327}let nm_4: bitstring = (if v_435 then 2-proj-3-tuple(v_434) else caught-fail) in
        {1328}let ns_12: bitstring = (if v_435 then 1-proj-3-tuple(v_434) else caught-fail) in
        {1330}let v_436: bitstring = (if v_435 then catch-fail(symmetricstateunpack(ss_69)) else caught-fail) in
        {1331}let v_437: bool = (not-caught-fail(v_436) && success?(1-proj-3-tuple(v_436))) in
        {1332}let h_59: bitstring = (if v_437 then 3-proj-3-tuple(v_436) else caught-fail) in
        {1333}let ck_70: key = (if v_437 then 2-proj-3-tuple(v_436) else caught-fail) in
        {1334}let cs_59: cipherstate = (if v_437 then 1-proj-3-tuple(v_436) else caught-fail) in
        {1335}let v_438: bitstring = (if v_437 then catch-fail(cipherstateunpack(cs_59)) else caught-fail) in
        {1336}let v_439: bool = (not-caught-fail(v_438) && success?(1-proj-2-tuple(v_438))) in
        {1337}let n_28: nonce = (if v_439 then 2-proj-2-tuple(v_438) else caught-fail) in
        {1338}let k_31: key = (if v_439 then 1-proj-2-tuple(v_438) else caught-fail) in
        {1339}let d_5: aead = (if v_439 then catch-fail(decrypt(k_31,n_28,h_59,nm_4)) else caught-fail) in
        {1340}let v_440: bool = not-caught-fail(d_5) in
        {1341}let v_441: bitstring = (if v_440 then catch-fail(aeadunpack(d_5)) else caught-fail) in
        {1342}let v_442: bool = (not-caught-fail(v_441) && success?(1-proj-3-tuple(v_441))) in
        {1343}let plaintext_17: bitstring = (if v_442 then 3-proj-3-tuple(v_441) else caught-fail) in
        {1344}let adi_5: bitstring = (if v_442 then 2-proj-3-tuple(v_441) else caught-fail) in
        {1345}let valid_15: bool = (if v_442 then 1-proj-3-tuple(v_441) else caught-fail) in
        {1347}let v_443: bitstring = (if v_442 then catch-fail(cipherstateunpack(cs_59)) else caught-fail) in
        {1348}let v_444: bool = (not-caught-fail(v_443) && success?(1-proj-2-tuple(v_443))) in
        {1349}let o_14: nonce = (if v_444 then 2-proj-2-tuple(v_443) else caught-fail) in
        {1350}let k_32: key = (if v_444 then 1-proj-2-tuple(v_443) else caught-fail) in
        {1346}let n_29: nonce = (if v_442 then increment_nonce(n_28) else caught-fail) in
        {1351}let csi_28: cipherstate = (if v_442 then catch-fail((if v_444 then cipherstatepack(k_32,n_29) else fail-any)) else caught-fail) in
        {1352}let v_445: bool = not-caught-fail(csi_28) in
        {1353}let v_446: bitstring = (if v_437 then catch-fail((if v_439 then (if v_440 then (if v_442 then (if v_445 then (csi_28,plaintext_17,valid_15) else fail-any) else fail-any) else fail-any) else fail-any)) else caught-fail) in
        {1354}let v_447: bool = (not-caught-fail(v_446) && success?(1-proj-3-tuple(v_446))) in
        {1355}let valid_16: bool = (if v_447 then 3-proj-3-tuple(v_446) else caught-fail) in
        {1356}let plaintext_18: bitstring = (if v_447 then 2-proj-3-tuple(v_446) else caught-fail) in
        {1357}let csi_29: cipherstate = (if v_447 then 1-proj-3-tuple(v_446) else caught-fail) in
        {1358}let ss_70: symmetricstate = (if v_447 then symmetricstatepack(csi_29,ck_70,h_59) else caught-fail) in
        {1359}let v_448: bitstring = (if v_447 then catch-fail(symmetricstateunpack(ss_70)) else caught-fail) in
        {1360}let v_449: bool = (not-caught-fail(v_448) && success?(1-proj-3-tuple(v_448))) in
        {1361}let h_60: bitstring = (if v_449 then 3-proj-3-tuple(v_448) else caught-fail) in
        {1362}let ck_71: key = (if v_449 then 2-proj-3-tuple(v_448) else caught-fail) in
        {1363}let cs_60: cipherstate = (if v_449 then 1-proj-3-tuple(v_448) else caught-fail) in
        {1364}let ssi_16: symmetricstate = (if v_447 then catch-fail((if v_449 then symmetricstatepack(cs_60,ck_71,hash(h_60,nm_4)) else fail-any)) else caught-fail) in
        {1365}let v_450: bool = not-caught-fail(ssi_16) in
        {1366}let v_451: bitstring = (if v_435 then catch-fail((if v_437 then (if v_447 then (if v_450 then (ssi_16,plaintext_18,valid_16) else fail-any) else fail-any) else fail-any)) else caught-fail) in
        {1367}let v_452: bool = (not-caught-fail(v_451) && success?(1-proj-3-tuple(v_451))) in
        {1368}let valid1_6: bool = (if v_452 then 3-proj-3-tuple(v_451) else caught-fail) in
        {1369}let nem: bitstring = (if v_452 then 2-proj-3-tuple(v_451) else caught-fail) in
        {1370}let ss_71: symmetricstate = (if v_452 then 1-proj-3-tuple(v_451) else caught-fail) in
        {1372}let v_453: bitstring = (if v_452 then catch-fail(keypairunpack(e_27)) else caught-fail) in
        {1373}let v_454: bool = (not-caught-fail(v_453) && success?(1-proj-2-tuple(v_453))) in
        {1374}let my_private_key_11: key = (if v_454 then 2-proj-2-tuple(v_453) else caught-fail) in
        {1375}let my_public_key_11: key = (if v_454 then 1-proj-2-tuple(v_453) else caught-fail) in
        {1371}let rm_16: key = (if v_452 then nem else caught-fail) in
        {1376}let input_key_material_13: key = (if v_452 then catch-fail((if v_454 then dhexp(my_private_key_11,rm_16) else fail-any)) else caught-fail) in
        {1377}let v_455: bool = not-caught-fail(input_key_material_13) in
        {1378}let v_456: bitstring = (if v_455 then catch-fail(symmetricstateunpack(ss_71)) else caught-fail) in
        {1379}let v_457: bool = (not-caught-fail(v_456) && success?(1-proj-3-tuple(v_456))) in
        {1380}let h_61: bitstring = (if v_457 then 3-proj-3-tuple(v_456) else caught-fail) in
        {1381}let ck_72: key = (if v_457 then 2-proj-3-tuple(v_456) else caught-fail) in
        {1382}let cs_61: cipherstate = (if v_457 then 1-proj-3-tuple(v_456) else caught-fail) in
        {1385}let output3_13: key = (if v_457 then hmac_hash3(ck_72,input_key_material_13) else caught-fail) in
        {1384}let output2_13: key = (if v_457 then hmac_hash2(ck_72,input_key_material_13) else caught-fail) in
        {1383}let output1_13: key = (if v_457 then hmac_hash1(ck_72,input_key_material_13) else caught-fail) in
        {1386}let v_458: bitstring = (if v_457 then catch-fail((output1_13,output2_13,output3_13)) else caught-fail) in
        {1387}let v_459: bool = (not-caught-fail(v_458) && success?(1-proj-3-tuple(v_458))) in
        {1388}let output_11: key = (if v_459 then 3-proj-3-tuple(v_458) else caught-fail) in
        {1389}let temp_k_11: key = (if v_459 then 2-proj-3-tuple(v_458) else caught-fail) in
        {1390}let ck_73: key = (if v_459 then 1-proj-3-tuple(v_458) else caught-fail) in
        {1391}let ss_72: symmetricstate = (if v_452 then catch-fail((if v_455 then (if v_457 then (if v_459 then symmetricstatepack(cipherstatepack(temp_k_11,minnonce),ck_73,h_61) else fail-any) else fail-any) else fail-any)) else caught-fail) in
        {1392}let v_460: bool = not-caught-fail(ss_72) in
        {1393}let v_461: bitstring = (if v_460 then catch-fail(symmetricstateunpack(ss_72)) else caught-fail) in
        {1394}let v_462: bool = (not-caught-fail(v_461) && success?(1-proj-3-tuple(v_461))) in
        {1395}let h_62: bitstring = (if v_462 then 3-proj-3-tuple(v_461) else caught-fail) in
        {1396}let ck_74: key = (if v_462 then 2-proj-3-tuple(v_461) else caught-fail) in
        {1397}let cs_62: cipherstate = (if v_462 then 1-proj-3-tuple(v_461) else caught-fail) in
        {1398}let v_463: bitstring = (if v_462 then catch-fail(cipherstateunpack(cs_62)) else caught-fail) in
        {1399}let v_464: bool = (not-caught-fail(v_463) && success?(1-proj-2-tuple(v_463))) in
        {1400}let n_30: nonce = (if v_464 then 2-proj-2-tuple(v_463) else caught-fail) in
        {1401}let k_33: key = (if v_464 then 1-proj-2-tuple(v_463) else caught-fail) in
        {1402}let d_6: aead = (if v_464 then catch-fail(decrypt(k_33,n_30,h_62,ciphertext_28)) else caught-fail) in
        {1403}let v_465: bool = not-caught-fail(d_6) in
        {1404}let v_466: bitstring = (if v_465 then catch-fail(aeadunpack(d_6)) else caught-fail) in
        {1405}let v_467: bool = (not-caught-fail(v_466) && success?(1-proj-3-tuple(v_466))) in
        {1406}let plaintext_19: bitstring = (if v_467 then 3-proj-3-tuple(v_466) else caught-fail) in
        {1407}let adi_6: bitstring = (if v_467 then 2-proj-3-tuple(v_466) else caught-fail) in
        {1408}let valid_17: bool = (if v_467 then 1-proj-3-tuple(v_466) else caught-fail) in
        {1410}let v_468: bitstring = (if v_467 then catch-fail(cipherstateunpack(cs_62)) else caught-fail) in
        {1411}let v_469: bool = (not-caught-fail(v_468) && success?(1-proj-2-tuple(v_468))) in
        {1412}let o_15: nonce = (if v_469 then 2-proj-2-tuple(v_468) else caught-fail) in
        {1413}let k_34: key = (if v_469 then 1-proj-2-tuple(v_468) else caught-fail) in
        {1409}let n_31: nonce = (if v_467 then increment_nonce(n_30) else caught-fail) in
        {1414}let csi_30: cipherstate = (if v_467 then catch-fail((if v_469 then cipherstatepack(k_34,n_31) else fail-any)) else caught-fail) in
        {1415}let v_470: bool = not-caught-fail(csi_30) in
        {1416}let v_471: bitstring = (if v_462 then catch-fail((if v_464 then (if v_465 then (if v_467 then (if v_470 then (csi_30,plaintext_19,valid_17) else fail-any) else fail-any) else fail-any) else fail-any)) else caught-fail) in
        {1417}let v_472: bool = (not-caught-fail(v_471) && success?(1-proj-3-tuple(v_471))) in
        {1418}let valid_18: bool = (if v_472 then 3-proj-3-tuple(v_471) else caught-fail) in
        {1419}let plaintext_20: bitstring = (if v_472 then 2-proj-3-tuple(v_471) else caught-fail) in
        {1420}let csi_31: cipherstate = (if v_472 then 1-proj-3-tuple(v_471) else caught-fail) in
        {1421}let ss_73: symmetricstate = (if v_472 then symmetricstatepack(csi_31,ck_74,h_62) else caught-fail) in
        {1422}let v_473: bitstring = (if v_472 then catch-fail(symmetricstateunpack(ss_73)) else caught-fail) in
        {1423}let v_474: bool = (not-caught-fail(v_473) && success?(1-proj-3-tuple(v_473))) in
        {1424}let h_63: bitstring = (if v_474 then 3-proj-3-tuple(v_473) else caught-fail) in
        {1425}let ck_75: key = (if v_474 then 2-proj-3-tuple(v_473) else caught-fail) in
        {1426}let cs_63: cipherstate = (if v_474 then 1-proj-3-tuple(v_473) else caught-fail) in
        {1427}let ssi_17: symmetricstate = (if v_472 then catch-fail((if v_474 then symmetricstatepack(cs_63,ck_75,hash(h_63,ciphertext_28)) else fail-any)) else caught-fail) in
        {1428}let v_475: bool = not-caught-fail(ssi_17) in
        {1429}let v_476: bitstring = (if v_460 then catch-fail((if v_462 then (if v_472 then (if v_475 then (ssi_17,plaintext_20,valid_18) else fail-any) else fail-any) else fail-any)) else caught-fail) in
        {1430}let v_477: bool = (not-caught-fail(v_476) && success?(1-proj-3-tuple(v_476))) in
        {1431}let valid2_5: bool = (if v_477 then 3-proj-3-tuple(v_476) else caught-fail) in
        {1432}let plaintext_21: bitstring = (if v_477 then 2-proj-3-tuple(v_476) else caught-fail) in
        {1433}let ss_74: symmetricstate = (if v_477 then 1-proj-3-tuple(v_476) else caught-fail) in
        {1434}let basis_11: key = (if v_477 then key_s(them_2) else caught-fail) in
        {1435}let public_key_11: key = (if v_477 then catch-fail(dhexp(basis_11,validkey(g))) else caught-fail) in
        {1436}let v_478: bool = not-caught-fail(public_key_11) in
        {1437}let v_479: bool = (if v_477 then catch-fail(((valid1_6 && valid2_5) && (rs_15 = getpublickey((if v_478 then keypairpack(validkey(public_key_11),basis_11) else fail-any))))) else caught-fail) in
        {1439}let v_480: bitstring = (if v_479 then catch-fail(symmetricstateunpack(ss_74)) else caught-fail) in
        {1440}let v_481: bool = (not-caught-fail(v_480) && success?(1-proj-3-tuple(v_480))) in
        {1441}let h_64: bitstring = (if v_481 then 3-proj-3-tuple(v_480) else caught-fail) in
        {1442}let ck_76: key = (if v_481 then 2-proj-3-tuple(v_480) else caught-fail) in
        {1443}let cs_64: cipherstate = (if v_481 then 1-proj-3-tuple(v_480) else caught-fail) in
        {1444}let input_key_material_14: key = (if v_481 then zero else caught-fail) in
        {1447}let output3_14: key = (if v_481 then hmac_hash3(ck_76,input_key_material_14) else caught-fail) in
        {1446}let output2_14: key = (if v_481 then hmac_hash2(ck_76,input_key_material_14) else caught-fail) in
        {1445}let output1_14: key = (if v_481 then hmac_hash1(ck_76,input_key_material_14) else caught-fail) in
        {1448}let v_482: bitstring = (if v_481 then catch-fail((output1_14,output2_14,output3_14)) else caught-fail) in
        {1449}let v_483: bool = (not-caught-fail(v_482) && success?(1-proj-3-tuple(v_482))) in
        {1450}let temp_k3_2: key = (if v_483 then 3-proj-3-tuple(v_482) else caught-fail) in
        {1451}let temp_k2_2: key = (if v_483 then 2-proj-3-tuple(v_482) else caught-fail) in
        {1452}let temp_k1_2: key = (if v_483 then 1-proj-3-tuple(v_482) else caught-fail) in
        {1454}let cs2_10: cipherstate = (if v_483 then cipherstatepack(temp_k2_2,minnonce) else caught-fail) in
        {1453}let cs1_10: cipherstate = (if v_483 then cipherstatepack(temp_k1_2,minnonce) else caught-fail) in
        {1455}let v_484: bitstring = (if v_479 then catch-fail((if v_481 then (if v_483 then (ss_74,cs1_10,cs2_10) else fail-any) else fail-any)) else caught-fail) in
        {1456}let v_485: bool = (not-caught-fail(v_484) && success?(1-proj-3-tuple(v_484))) in
        {1457}let cs2_11: cipherstate = (if v_485 then 3-proj-3-tuple(v_484) else caught-fail) in
        {1458}let cs1_11: cipherstate = (if v_485 then 2-proj-3-tuple(v_484) else caught-fail) in
        {1459}let ssi_18: symmetricstate = (if v_485 then 1-proj-3-tuple(v_484) else caught-fail) in
        {1438}let hs_44: handshakestate = (if v_479 then handshakestatepack(ss_74,s_15,m_17,e_27,rs_15,rm_16,re_18,psk_15,initiator_13) else caught-fail) in
        {1460}let (hs_45: handshakestate,plaintext_c: bitstring,valid_19: bool,cs1_12: cipherstate,cs2_12: cipherstate) = (if v_433 then (if v_435 then (if v_452 then (if v_460 then (if v_477 then (if undo-catch-fail(v_479) then (if v_485 then (hs_44,plaintext_21,true,cs1_11,cs2_11) else fail-any) else fail-any) else fail-any) else fail-any) else fail-any) else fail-any) else fail-any) in
        {1461}event RecvMsg(me_2,them_2,stagepack_c(sid_3),plaintext_c);
        {1462}insert statestore(me_2,them_2,sid_3,statepack_d(hs_45,cs1_12,cs2_12))
    ) | (
        {1464}!
        {1522}get statestore(=me_2,=them_2,=sid_3,statepack_d(hs_46: handshakestate,cs1_13: cipherstate,cs2_13: cipherstate)) in
        {1465}let hs_47: handshakestate = handshakestatesetcs(hs_46,cs2_13) in
        {1467}let v_486: bitstring = catch-fail(handshakestateunpack(hs_47)) in
        {1468}let v_487: bool = (not-caught-fail(v_486) && success?(1-proj-9-tuple(v_486))) in
        {1469}let initiator_14: bool = (if v_487 then 9-proj-9-tuple(v_486) else caught-fail) in
        {1470}let psk_16: key = (if v_487 then 8-proj-9-tuple(v_486) else caught-fail) in
        {1471}let re_19: key = (if v_487 then 7-proj-9-tuple(v_486) else caught-fail) in
        {1472}let rm_17: key = (if v_487 then 6-proj-9-tuple(v_486) else caught-fail) in
        {1473}let rs_16: key = (if v_487 then 5-proj-9-tuple(v_486) else caught-fail) in
        {1474}let e_28: keypair = (if v_487 then 4-proj-9-tuple(v_486) else caught-fail) in
        {1475}let m_18: keypair = (if v_487 then 3-proj-9-tuple(v_486) else caught-fail) in
        {1476}let s_16: keypair = (if v_487 then 2-proj-9-tuple(v_486) else caught-fail) in
        {1477}let ss_75: symmetricstate = (if v_487 then 1-proj-9-tuple(v_486) else caught-fail) in
        {1478}let v_488: bitstring = (if v_487 then catch-fail((empty,empty,empty)) else caught-fail) in
        {1479}let v_489: bool = (not-caught-fail(v_488) && success?(1-proj-3-tuple(v_488))) in
        {1480}let ciphertext_29: bitstring = (if v_489 then 3-proj-3-tuple(v_488) else caught-fail) in
        {1481}let ns_13: bitstring = (if v_489 then 2-proj-3-tuple(v_488) else caught-fail) in
        {1482}let ne_13: bitstring = (if v_489 then 1-proj-3-tuple(v_488) else caught-fail) in
        {1483}let v_490: bitstring = (if v_489 then catch-fail(symmetricstateunpack(ss_75)) else caught-fail) in
        {1484}let v_491: bool = (not-caught-fail(v_490) && success?(1-proj-3-tuple(v_490))) in
        {1485}let h_65: bitstring = (if v_491 then 3-proj-3-tuple(v_490) else caught-fail) in
        {1486}let ck_77: key = (if v_491 then 2-proj-3-tuple(v_490) else caught-fail) in
        {1487}let cs_65: cipherstate = (if v_491 then 1-proj-3-tuple(v_490) else caught-fail) in
        {1488}let v_492: bitstring = (if v_491 then catch-fail(cipherstateunpack(cs_65)) else caught-fail) in
        {1489}let v_493: bool = (not-caught-fail(v_492) && success?(1-proj-2-tuple(v_492))) in
        {1490}let n_32: nonce = (if v_493 then 2-proj-2-tuple(v_492) else caught-fail) in
        {1491}let k_35: key = (if v_493 then 1-proj-2-tuple(v_492) else caught-fail) in
        {1494}let v_494: bitstring = (if v_493 then catch-fail(cipherstateunpack(cs_65)) else caught-fail) in
        {1495}let v_495: bool = (not-caught-fail(v_494) && success?(1-proj-2-tuple(v_494))) in
        {1496}let o_16: nonce = (if v_495 then 2-proj-2-tuple(v_494) else caught-fail) in
        {1497}let k_36: key = (if v_495 then 1-proj-2-tuple(v_494) else caught-fail) in
        {1493}let n_33: nonce = (if v_493 then increment_nonce(n_32) else caught-fail) in
        {1498}let csi_32: cipherstate = (if v_493 then catch-fail((if v_495 then cipherstatepack(k_36,n_33) else fail-any)) else caught-fail) in
        {1499}let v_496: bool = not-caught-fail(csi_32) in
        {1466}let payload_7: bitstring = msg_d(me_2,them_2,sid_3) in
        {1492}let e_29: bitstring = (if v_493 then encrypt(k_35,n_32,h_65,payload_7) else caught-fail) in
        {1500}let v_497: bitstring = (if v_491 then catch-fail((if v_493 then (if v_496 then (csi_32,e_29) else fail-any) else fail-any)) else caught-fail) in
        {1501}let v_498: bool = (not-caught-fail(v_497) && success?(1-proj-2-tuple(v_497))) in
        {1502}let ciphertext_30: bitstring = (if v_498 then 2-proj-2-tuple(v_497) else caught-fail) in
        {1503}let csi_33: cipherstate = (if v_498 then 1-proj-2-tuple(v_497) else caught-fail) in
        {1504}let ss_76: symmetricstate = (if v_498 then symmetricstatepack(csi_33,ck_77,h_65) else caught-fail) in
        {1505}let v_499: bitstring = (if v_498 then catch-fail(symmetricstateunpack(ss_76)) else caught-fail) in
        {1506}let v_500: bool = (not-caught-fail(v_499) && success?(1-proj-3-tuple(v_499))) in
        {1507}let h_66: bitstring = (if v_500 then 3-proj-3-tuple(v_499) else caught-fail) in
        {1508}let ck_78: key = (if v_500 then 2-proj-3-tuple(v_499) else caught-fail) in
        {1509}let cs_66: cipherstate = (if v_500 then 1-proj-3-tuple(v_499) else caught-fail) in
        {1510}let ssi_19: symmetricstate = (if v_498 then catch-fail((if v_500 then symmetricstatepack(cs_66,ck_78,hash(h_66,ciphertext_30)) else fail-any)) else caught-fail) in
        {1511}let v_501: bool = not-caught-fail(ssi_19) in
        {1512}let v_502: bitstring = (if v_489 then catch-fail((if v_491 then (if v_498 then (if v_501 then (ssi_19,ciphertext_30) else fail-any) else fail-any) else fail-any)) else caught-fail) in
        {1513}let v_503: bool = (not-caught-fail(v_502) && success?(1-proj-2-tuple(v_502))) in
        {1514}let ciphertext_31: bitstring = (if v_503 then 2-proj-2-tuple(v_502) else caught-fail) in
        {1515}let ss_77: symmetricstate = (if v_503 then 1-proj-2-tuple(v_502) else caught-fail) in
        {1517}let message_buffer_7: bitstring = (if v_503 then concat3(ne_13,ns_13,ciphertext_31) else caught-fail) in
        {1516}let hs_48: handshakestate = (if v_503 then handshakestatepack(ss_77,s_16,m_18,e_28,rs_16,rm_17,re_19,psk_16,initiator_14) else caught-fail) in
        {1518}let (hs_49: handshakestate,message_d_2: bitstring) = (if v_487 then (if v_489 then (if v_503 then (hs_48,message_buffer_7) else fail-any) else fail-any) else fail-any) in
        {1519}event SendMsg(me_2,them_2,stagepack_d(sid_3),msg_d(me_2,them_2,sid_3));
        {1520}insert statestore(me_2,them_2,sid_3,statepack_e(hs_49,cs1_13,handshakestategetcs(hs_49)));
        {1521}out(pub, message_d_2)
    ) | (
        {1523}!
        {1589}get statestore(=me_2,=them_2,=sid_3,statepack_e(hs_50: handshakestate,cs1_14: cipherstate,cs2_14: cipherstate)) in
        {1524}let hs_51: handshakestate = handshakestatesetcs(hs_50,cs1_14) in
        {1525}in(pub, message_e_2: bitstring);
        {1526}let v_504: bitstring = catch-fail(handshakestateunpack(hs_51)) in
        {1527}let v_505: bool = (not-caught-fail(v_504) && success?(1-proj-9-tuple(v_504))) in
        {1528}let initiator_15: bool = (if v_505 then 9-proj-9-tuple(v_504) else caught-fail) in
        {1529}let psk_17: key = (if v_505 then 8-proj-9-tuple(v_504) else caught-fail) in
        {1530}let re_20: key = (if v_505 then 7-proj-9-tuple(v_504) else caught-fail) in
        {1531}let rm_18: key = (if v_505 then 6-proj-9-tuple(v_504) else caught-fail) in
        {1532}let rs_17: key = (if v_505 then 5-proj-9-tuple(v_504) else caught-fail) in
        {1533}let e_30: keypair = (if v_505 then 4-proj-9-tuple(v_504) else caught-fail) in
        {1534}let m_19: keypair = (if v_505 then 3-proj-9-tuple(v_504) else caught-fail) in
        {1535}let s_17: keypair = (if v_505 then 2-proj-9-tuple(v_504) else caught-fail) in
        {1536}let ss_78: symmetricstate = (if v_505 then 1-proj-9-tuple(v_504) else caught-fail) in
        {1537}let v_506: bitstring = (if v_505 then catch-fail(deconcat3(message_e_2)) else caught-fail) in
        {1538}let v_507: bool = (not-caught-fail(v_506) && success?(1-proj-3-tuple(v_506))) in
        {1539}let ciphertext_32: bitstring = (if v_507 then 3-proj-3-tuple(v_506) else caught-fail) in
        {1540}let ns_14: bitstring = (if v_507 then 2-proj-3-tuple(v_506) else caught-fail) in
        {1541}let ne_14: bitstring = (if v_507 then 1-proj-3-tuple(v_506) else caught-fail) in
        {1543}let v_508: bitstring = (if v_507 then catch-fail(symmetricstateunpack(ss_78)) else caught-fail) in
        {1544}let v_509: bool = (not-caught-fail(v_508) && success?(1-proj-3-tuple(v_508))) in
        {1545}let h_67: bitstring = (if v_509 then 3-proj-3-tuple(v_508) else caught-fail) in
        {1546}let ck_79: key = (if v_509 then 2-proj-3-tuple(v_508) else caught-fail) in
        {1547}let cs_67: cipherstate = (if v_509 then 1-proj-3-tuple(v_508) else caught-fail) in
        {1548}let v_510: bitstring = (if v_509 then catch-fail(cipherstateunpack(cs_67)) else caught-fail) in
        {1549}let v_511: bool = (not-caught-fail(v_510) && success?(1-proj-2-tuple(v_510))) in
        {1550}let n_34: nonce = (if v_511 then 2-proj-2-tuple(v_510) else caught-fail) in
        {1551}let k_37: key = (if v_511 then 1-proj-2-tuple(v_510) else caught-fail) in
        {1552}let d_7: aead = (if v_511 then catch-fail(decrypt(k_37,n_34,h_67,ciphertext_32)) else caught-fail) in
        {1553}let v_512: bool = not-caught-fail(d_7) in
        {1554}let v_513: bitstring = (if v_512 then catch-fail(aeadunpack(d_7)) else caught-fail) in
        {1555}let v_514: bool = (not-caught-fail(v_513) && success?(1-proj-3-tuple(v_513))) in
        {1556}let plaintext_22: bitstring = (if v_514 then 3-proj-3-tuple(v_513) else caught-fail) in
        {1557}let adi_7: bitstring = (if v_514 then 2-proj-3-tuple(v_513) else caught-fail) in
        {1558}let valid_20: bool = (if v_514 then 1-proj-3-tuple(v_513) else caught-fail) in
        {1560}let v_515: bitstring = (if v_514 then catch-fail(cipherstateunpack(cs_67)) else caught-fail) in
        {1561}let v_516: bool = (not-caught-fail(v_515) && success?(1-proj-2-tuple(v_515))) in
        {1562}let o_17: nonce = (if v_516 then 2-proj-2-tuple(v_515) else caught-fail) in
        {1563}let k_38: key = (if v_516 then 1-proj-2-tuple(v_515) else caught-fail) in
        {1559}let n_35: nonce = (if v_514 then increment_nonce(n_34) else caught-fail) in
        {1564}let csi_34: cipherstate = (if v_514 then catch-fail((if v_516 then cipherstatepack(k_38,n_35) else fail-any)) else caught-fail) in
        {1565}let v_517: bool = not-caught-fail(csi_34) in
        {1566}let v_518: bitstring = (if v_509 then catch-fail((if v_511 then (if v_512 then (if v_514 then (if v_517 then (csi_34,plaintext_22,valid_20) else fail-any) else fail-any) else fail-any) else fail-any)) else caught-fail) in
        {1567}let v_519: bool = (not-caught-fail(v_518) && success?(1-proj-3-tuple(v_518))) in
        {1568}let valid_21: bool = (if v_519 then 3-proj-3-tuple(v_518) else caught-fail) in
        {1569}let plaintext_23: bitstring = (if v_519 then 2-proj-3-tuple(v_518) else caught-fail) in
        {1570}let csi_35: cipherstate = (if v_519 then 1-proj-3-tuple(v_518) else caught-fail) in
        {1571}let ss_79: symmetricstate = (if v_519 then symmetricstatepack(csi_35,ck_79,h_67) else caught-fail) in
        {1572}let v_520: bitstring = (if v_519 then catch-fail(symmetricstateunpack(ss_79)) else caught-fail) in
        {1573}let v_521: bool = (not-caught-fail(v_520) && success?(1-proj-3-tuple(v_520))) in
        {1574}let h_68: bitstring = (if v_521 then 3-proj-3-tuple(v_520) else caught-fail) in
        {1575}let ck_80: key = (if v_521 then 2-proj-3-tuple(v_520) else caught-fail) in
        {1576}let cs_68: cipherstate = (if v_521 then 1-proj-3-tuple(v_520) else caught-fail) in
        {1577}let ssi_20: symmetricstate = (if v_519 then catch-fail((if v_521 then symmetricstatepack(cs_68,ck_80,hash(h_68,ciphertext_32)) else fail-any)) else caught-fail) in
        {1578}let v_522: bool = not-caught-fail(ssi_20) in
        {1579}let v_523: bitstring = (if v_507 then catch-fail((if v_509 then (if v_519 then (if v_522 then (ssi_20,plaintext_23,valid_21) else fail-any) else fail-any) else fail-any)) else caught-fail) in
        {1580}let v_524: bool = (not-caught-fail(v_523) && success?(1-proj-3-tuple(v_523))) in
        {1581}let valid2_6: bool = (if v_524 then 3-proj-3-tuple(v_523) else caught-fail) in
        {1582}let plaintext_24: bitstring = (if v_524 then 2-proj-3-tuple(v_523) else caught-fail) in
        {1583}let ss_80: symmetricstate = (if v_524 then 1-proj-3-tuple(v_523) else caught-fail) in
        {1542}let valid1_7: bool = (if v_507 then true else caught-fail) in
        {1584}let v_525: bool = (if v_524 then catch-fail((valid1_7 && valid2_6)) else caught-fail) in
        {1585}let hs_52: handshakestate = (if v_525 then handshakestatepack(ss_80,s_17,m_19,e_30,rs_17,rm_18,re_20,psk_17,initiator_15) else caught-fail) in
        {1586}let (hs_53: handshakestate,plaintext_e: bitstring,valid_22: bool) = (if v_505 then (if v_507 then (if v_524 then (if undo-catch-fail(v_525) then (hs_52,plaintext_24,true) else fail-any) else fail-any) else fail-any) else fail-any) in
        {1587}event RecvMsg(me_2,them_2,stagepack_e(sid_3),plaintext_e);
        {1588}event RecvEnd(valid_22)
    ) | (
        {1590}event LeakS(phase0,me_2);
        {1591}event LeakM(phase0,me_2);
        {1592}out(pub, (key_s(me_2),key_m(me_2)))
    ) | (
        {1593}phase 1;
        {1594}event LeakS(phase1,me_2);
        {1595}event LeakM(phase1,me_2);
        {1596}out(pub, (key_s(me_2),key_m(me_2)))
    )
) | (
    {1597}let me_3: principal = bob in
    {1600}let basis_12: key = key_s(me_3) in
    {1601}let public_key_12: key = catch-fail(dhexp(basis_12,validkey(g))) in
    {1602}let v_526: bool = not-caught-fail(public_key_12) in
    {1603}let s_18: keypair = (if v_526 then keypairpack(validkey(public_key_12),basis_12) else fail-any) in
    {1604}let basis_13: key = key_m(me_3) in
    {1605}let public_key_13: key = catch-fail(dhexp(basis_13,validkey(g))) in
    {1606}let v_527: bool = not-caught-fail(public_key_13) in
    {1607}let m_20: keypair = (if v_527 then keypairpack(validkey(public_key_13),basis_13) else fail-any) in
    {1608}out(pub, (getpublickey(s_18),getpublickey(m_20)));
    {1599}let sid_4: sessionid = sid in
    {1598}let them_3: principal = charlie in
    (
        {1618}let k_39: key = empty in
        {1619}let cs_69: cipherstate = cipherstatepack(k_39,minnonce) in
        {1615}let protocol_name_3: bitstring = somename in
        {1616}let h_69: bitstring = hash(protocol_name_3,empty) in
        {1617}let ck_81: key = h_69 in
        {1620}let ss_81: symmetricstate = symmetricstatepack(cs_69,ck_81,h_69) in
        {1621}let v_528: bitstring = catch-fail(symmetricstateunpack(ss_81)) in
        {1622}let v_529: bool = (not-caught-fail(v_528) && success?(1-proj-3-tuple(v_528))) in
        {1623}let h_70: bitstring = (if v_529 then 3-proj-3-tuple(v_528) else caught-fail) in
        {1624}let ck_82: key = (if v_529 then 2-proj-3-tuple(v_528) else caught-fail) in
        {1625}let cs_70: cipherstate = (if v_529 then 1-proj-3-tuple(v_528) else caught-fail) in
        {1613}let prologue_3: bitstring = empty in
        {1626}let ss_82: symmetricstate = catch-fail((if v_529 then symmetricstatepack(cs_70,ck_82,hash(h_70,prologue_3)) else fail-any)) in
        {1627}let v_530: bool = not-caught-fail(ss_82) in
        {1628}let data_2: bitstring = (if v_530 then catch-fail(getpublickey(s_18)) else caught-fail) in
        {1629}let v_531: bool = not-caught-fail(data_2) in
        {1630}let v_532: bitstring = (if v_531 then catch-fail(symmetricstateunpack(ss_82)) else caught-fail) in
        {1631}let v_533: bool = (not-caught-fail(v_532) && success?(1-proj-3-tuple(v_532))) in
        {1632}let h_71: bitstring = (if v_533 then 3-proj-3-tuple(v_532) else caught-fail) in
        {1633}let ck_83: key = (if v_533 then 2-proj-3-tuple(v_532) else caught-fail) in
        {1634}let cs_71: cipherstate = (if v_533 then 1-proj-3-tuple(v_532) else caught-fail) in
        {1635}let ss_83: symmetricstate = (if v_530 then catch-fail((if v_531 then (if v_533 then symmetricstatepack(cs_71,ck_83,hash(h_71,data_2)) else fail-any) else fail-any)) else caught-fail) in
        {1636}let v_534: bool = not-caught-fail(ss_83) in
        {1637}let data_3: bitstring = (if v_534 then catch-fail(getpublickey(m_20)) else caught-fail) in
        {1638}let v_535: bool = not-caught-fail(data_3) in
        {1639}let v_536: bitstring = (if v_535 then catch-fail(symmetricstateunpack(ss_83)) else caught-fail) in
        {1640}let v_537: bool = (not-caught-fail(v_536) && success?(1-proj-3-tuple(v_536))) in
        {1641}let h_72: bitstring = (if v_537 then 3-proj-3-tuple(v_536) else caught-fail) in
        {1642}let ck_84: key = (if v_537 then 2-proj-3-tuple(v_536) else caught-fail) in
        {1643}let cs_72: cipherstate = (if v_537 then 1-proj-3-tuple(v_536) else caught-fail) in
        {1644}let ss_84: symmetricstate = (if v_534 then catch-fail((if v_535 then (if v_537 then symmetricstatepack(cs_72,ck_84,hash(h_72,data_3)) else fail-any) else fail-any)) else caught-fail) in
        {1645}let v_538: bool = not-caught-fail(ss_84) in
        {1614}let psk_18: key = empty in
        {1612}let re_21: key = empty in
        {1611}let rm_19: key = empty in
        {1610}let rs_18: key = empty in
        {1609}let e_31: keypair = keypairpack(empty,empty) in
        {1646}let hs_54: handshakestate = (if v_530 then (if v_534 then (if v_538 then handshakestatepack(ss_84,s_18,m_20,e_31,rs_18,rm_19,re_21,psk_18,false) else fail-any) else fail-any) else fail-any) in
        {1647}insert statestore(me_3,them_3,sid_4,statepack_a(hs_54))
    ) | (
        {1762}get statestore(=me_3,=them_3,=sid_4,statepack_a(hs_55: handshakestate)) in
        {1648}in(pub, message_a_3: bitstring);
        {1649}let v_539: bitstring = catch-fail(handshakestateunpack(hs_55)) in
        {1650}let v_540: bool = (not-caught-fail(v_539) && success?(1-proj-9-tuple(v_539))) in
        {1651}let initiator_16: bool = (if v_540 then 9-proj-9-tuple(v_539) else caught-fail) in
        {1652}let psk_19: key = (if v_540 then 8-proj-9-tuple(v_539) else caught-fail) in
        {1653}let re_22: key = (if v_540 then 7-proj-9-tuple(v_539) else caught-fail) in
        {1654}let rm_20: key = (if v_540 then 6-proj-9-tuple(v_539) else caught-fail) in
        {1655}let rs_19: key = (if v_540 then 5-proj-9-tuple(v_539) else caught-fail) in
        {1656}let e_32: keypair = (if v_540 then 4-proj-9-tuple(v_539) else caught-fail) in
        {1657}let m_21: keypair = (if v_540 then 3-proj-9-tuple(v_539) else caught-fail) in
        {1658}let s_19: keypair = (if v_540 then 2-proj-9-tuple(v_539) else caught-fail) in
        {1659}let ss_85: symmetricstate = (if v_540 then 1-proj-9-tuple(v_539) else caught-fail) in
        {1660}let v_541: bitstring = (if v_540 then catch-fail(deconcat3(message_a_3)) else caught-fail) in
        {1661}let v_542: bool = (not-caught-fail(v_541) && success?(1-proj-3-tuple(v_541))) in
        {1662}let ciphertext_33: bitstring = (if v_542 then 3-proj-3-tuple(v_541) else caught-fail) in
        {1663}let ns_15: bitstring = (if v_542 then 2-proj-3-tuple(v_541) else caught-fail) in
        {1664}let ne_15: bitstring = (if v_542 then 1-proj-3-tuple(v_541) else caught-fail) in
        {1667}let v_543: bitstring = (if v_542 then catch-fail(symmetricstateunpack(ss_85)) else caught-fail) in
        {1668}let v_544: bool = (not-caught-fail(v_543) && success?(1-proj-3-tuple(v_543))) in
        {1669}let h_73: bitstring = (if v_544 then 3-proj-3-tuple(v_543) else caught-fail) in
        {1670}let ck_85: key = (if v_544 then 2-proj-3-tuple(v_543) else caught-fail) in
        {1671}let cs_73: cipherstate = (if v_544 then 1-proj-3-tuple(v_543) else caught-fail) in
        {1666}let re_23: key = (if v_542 then ne_15 else caught-fail) in
        {1672}let ss_86: symmetricstate = (if v_542 then catch-fail((if v_544 then symmetricstatepack(cs_73,ck_85,hash(h_73,re_23)) else fail-any)) else caught-fail) in
        {1673}let v_545: bool = not-caught-fail(ss_86) in
        {1674}let v_546: bitstring = (if v_545 then catch-fail(keypairunpack(s_19)) else caught-fail) in
        {1675}let v_547: bool = (not-caught-fail(v_546) && success?(1-proj-2-tuple(v_546))) in
        {1676}let my_private_key_12: key = (if v_547 then 2-proj-2-tuple(v_546) else caught-fail) in
        {1677}let my_public_key_12: key = (if v_547 then 1-proj-2-tuple(v_546) else caught-fail) in
        {1678}let input_key_material_15: key = (if v_545 then catch-fail((if v_547 then dhexp(my_private_key_12,re_23) else fail-any)) else caught-fail) in
        {1679}let v_548: bool = not-caught-fail(input_key_material_15) in
        {1680}let v_549: bitstring = (if v_548 then catch-fail(symmetricstateunpack(ss_86)) else caught-fail) in
        {1681}let v_550: bool = (not-caught-fail(v_549) && success?(1-proj-3-tuple(v_549))) in
        {1682}let h_74: bitstring = (if v_550 then 3-proj-3-tuple(v_549) else caught-fail) in
        {1683}let ck_86: key = (if v_550 then 2-proj-3-tuple(v_549) else caught-fail) in
        {1684}let cs_74: cipherstate = (if v_550 then 1-proj-3-tuple(v_549) else caught-fail) in
        {1687}let output3_15: key = (if v_550 then hmac_hash3(ck_86,input_key_material_15) else caught-fail) in
        {1686}let output2_15: key = (if v_550 then hmac_hash2(ck_86,input_key_material_15) else caught-fail) in
        {1685}let output1_15: key = (if v_550 then hmac_hash1(ck_86,input_key_material_15) else caught-fail) in
        {1688}let v_551: bitstring = (if v_550 then catch-fail((output1_15,output2_15,output3_15)) else caught-fail) in
        {1689}let v_552: bool = (not-caught-fail(v_551) && success?(1-proj-3-tuple(v_551))) in
        {1690}let output_12: key = (if v_552 then 3-proj-3-tuple(v_551) else caught-fail) in
        {1691}let temp_k_12: key = (if v_552 then 2-proj-3-tuple(v_551) else caught-fail) in
        {1692}let ck_87: key = (if v_552 then 1-proj-3-tuple(v_551) else caught-fail) in
        {1693}let ss_87: symmetricstate = (if v_545 then catch-fail((if v_548 then (if v_550 then (if v_552 then symmetricstatepack(cipherstatepack(temp_k_12,minnonce),ck_87,h_74) else fail-any) else fail-any) else fail-any)) else caught-fail) in
        {1694}let v_553: bool = not-caught-fail(ss_87) in
        {1695}let v_554: bitstring = (if v_553 then catch-fail(keypairunpack(m_21)) else caught-fail) in
        {1696}let v_555: bool = (not-caught-fail(v_554) && success?(1-proj-2-tuple(v_554))) in
        {1697}let my_private_key_13: key = (if v_555 then 2-proj-2-tuple(v_554) else caught-fail) in
        {1698}let my_public_key_13: key = (if v_555 then 1-proj-2-tuple(v_554) else caught-fail) in
        {1699}let input_key_material_16: key = (if v_553 then catch-fail((if v_555 then dhexp(my_private_key_13,re_23) else fail-any)) else caught-fail) in
        {1700}let v_556: bool = not-caught-fail(input_key_material_16) in
        {1701}let v_557: bitstring = (if v_556 then catch-fail(symmetricstateunpack(ss_87)) else caught-fail) in
        {1702}let v_558: bool = (not-caught-fail(v_557) && success?(1-proj-3-tuple(v_557))) in
        {1703}let h_75: bitstring = (if v_558 then 3-proj-3-tuple(v_557) else caught-fail) in
        {1704}let ck_88: key = (if v_558 then 2-proj-3-tuple(v_557) else caught-fail) in
        {1705}let cs_75: cipherstate = (if v_558 then 1-proj-3-tuple(v_557) else caught-fail) in
        {1708}let output3_16: key = (if v_558 then hmac_hash3(ck_88,input_key_material_16) else caught-fail) in
        {1707}let output2_16: key = (if v_558 then hmac_hash2(ck_88,input_key_material_16) else caught-fail) in
        {1706}let output1_16: key = (if v_558 then hmac_hash1(ck_88,input_key_material_16) else caught-fail) in
        {1709}let v_559: bitstring = (if v_558 then catch-fail((output1_16,output2_16,output3_16)) else caught-fail) in
        {1710}let v_560: bool = (not-caught-fail(v_559) && success?(1-proj-3-tuple(v_559))) in
        {1711}let output_13: key = (if v_560 then 3-proj-3-tuple(v_559) else caught-fail) in
        {1712}let temp_k_13: key = (if v_560 then 2-proj-3-tuple(v_559) else caught-fail) in
        {1713}let ck_89: key = (if v_560 then 1-proj-3-tuple(v_559) else caught-fail) in
        {1714}let ss_88: symmetricstate = (if v_553 then catch-fail((if v_556 then (if v_558 then (if v_560 then symmetricstatepack(cipherstatepack(temp_k_13,minnonce),ck_89,h_75) else fail-any) else fail-any) else fail-any)) else caught-fail) in
        {1715}let v_561: bool = not-caught-fail(ss_88) in
        {1716}let v_562: bitstring = (if v_561 then catch-fail(symmetricstateunpack(ss_88)) else caught-fail) in
        {1717}let v_563: bool = (not-caught-fail(v_562) && success?(1-proj-3-tuple(v_562))) in
        {1718}let h_76: bitstring = (if v_563 then 3-proj-3-tuple(v_562) else caught-fail) in
        {1719}let ck_90: key = (if v_563 then 2-proj-3-tuple(v_562) else caught-fail) in
        {1720}let cs_76: cipherstate = (if v_563 then 1-proj-3-tuple(v_562) else caught-fail) in
        {1721}let v_564: bitstring = (if v_563 then catch-fail(cipherstateunpack(cs_76)) else caught-fail) in
        {1722}let v_565: bool = (not-caught-fail(v_564) && success?(1-proj-2-tuple(v_564))) in
        {1723}let n_36: nonce = (if v_565 then 2-proj-2-tuple(v_564) else caught-fail) in
        {1724}let k_40: key = (if v_565 then 1-proj-2-tuple(v_564) else caught-fail) in
        {1725}let d_8: aead = (if v_565 then catch-fail(decrypt(k_40,n_36,h_76,ciphertext_33)) else caught-fail) in
        {1726}let v_566: bool = not-caught-fail(d_8) in
        {1727}let v_567: bitstring = (if v_566 then catch-fail(aeadunpack(d_8)) else caught-fail) in
        {1728}let v_568: bool = (not-caught-fail(v_567) && success?(1-proj-3-tuple(v_567))) in
        {1729}let plaintext_25: bitstring = (if v_568 then 3-proj-3-tuple(v_567) else caught-fail) in
        {1730}let adi_8: bitstring = (if v_568 then 2-proj-3-tuple(v_567) else caught-fail) in
        {1731}let valid_23: bool = (if v_568 then 1-proj-3-tuple(v_567) else caught-fail) in
        {1733}let v_569: bitstring = (if v_568 then catch-fail(cipherstateunpack(cs_76)) else caught-fail) in
        {1734}let v_570: bool = (not-caught-fail(v_569) && success?(1-proj-2-tuple(v_569))) in
        {1735}let o_18: nonce = (if v_570 then 2-proj-2-tuple(v_569) else caught-fail) in
        {1736}let k_41: key = (if v_570 then 1-proj-2-tuple(v_569) else caught-fail) in
        {1732}let n_37: nonce = (if v_568 then increment_nonce(n_36) else caught-fail) in
        {1737}let csi_36: cipherstate = (if v_568 then catch-fail((if v_570 then cipherstatepack(k_41,n_37) else fail-any)) else caught-fail) in
        {1738}let v_571: bool = not-caught-fail(csi_36) in
        {1739}let v_572: bitstring = (if v_563 then catch-fail((if v_565 then (if v_566 then (if v_568 then (if v_571 then (csi_36,plaintext_25,valid_23) else fail-any) else fail-any) else fail-any) else fail-any)) else caught-fail) in
        {1740}let v_573: bool = (not-caught-fail(v_572) && success?(1-proj-3-tuple(v_572))) in
        {1741}let valid_24: bool = (if v_573 then 3-proj-3-tuple(v_572) else caught-fail) in
        {1742}let plaintext_26: bitstring = (if v_573 then 2-proj-3-tuple(v_572) else caught-fail) in
        {1743}let csi_37: cipherstate = (if v_573 then 1-proj-3-tuple(v_572) else caught-fail) in
        {1744}let ss_89: symmetricstate = (if v_573 then symmetricstatepack(csi_37,ck_90,h_76) else caught-fail) in
        {1745}let v_574: bitstring = (if v_573 then catch-fail(symmetricstateunpack(ss_89)) else caught-fail) in
        {1746}let v_575: bool = (not-caught-fail(v_574) && success?(1-proj-3-tuple(v_574))) in
        {1747}let h_77: bitstring = (if v_575 then 3-proj-3-tuple(v_574) else caught-fail) in
        {1748}let ck_91: key = (if v_575 then 2-proj-3-tuple(v_574) else caught-fail) in
        {1749}let cs_77: cipherstate = (if v_575 then 1-proj-3-tuple(v_574) else caught-fail) in
        {1750}let ssi_21: symmetricstate = (if v_573 then catch-fail((if v_575 then symmetricstatepack(cs_77,ck_91,hash(h_77,ciphertext_33)) else fail-any)) else caught-fail) in
        {1751}let v_576: bool = not-caught-fail(ssi_21) in
        {1752}let v_577: bitstring = (if v_561 then catch-fail((if v_563 then (if v_573 then (if v_576 then (ssi_21,plaintext_26,valid_24) else fail-any) else fail-any) else fail-any)) else caught-fail) in
        {1753}let v_578: bool = (not-caught-fail(v_577) && success?(1-proj-3-tuple(v_577))) in
        {1754}let valid2_7: bool = (if v_578 then 3-proj-3-tuple(v_577) else caught-fail) in
        {1755}let plaintext_27: bitstring = (if v_578 then 2-proj-3-tuple(v_577) else caught-fail) in
        {1756}let ss_90: symmetricstate = (if v_578 then 1-proj-3-tuple(v_577) else caught-fail) in
        {1665}let valid1_8: bool = (if v_542 then true else caught-fail) in
        {1757}let v_579: bool = (if v_578 then catch-fail((valid1_8 && valid2_7)) else caught-fail) in
        {1758}let hs_56: handshakestate = (if v_579 then handshakestatepack(ss_90,s_19,m_21,e_32,rs_19,rm_20,re_23,psk_19,initiator_16) else caught-fail) in
        {1759}let (hs_57: handshakestate,plaintext_a_1: bitstring,valid_25: bool) = (if v_540 then (if v_542 then (if v_545 then (if v_553 then (if v_561 then (if v_578 then (if undo-catch-fail(v_579) then (hs_56,plaintext_27,true) else fail-any) else fail-any) else fail-any) else fail-any) else fail-any) else fail-any) else fail-any) in
        {1760}event RecvMsg(me_3,them_3,stagepack_a(sid_4),plaintext_a_1);
        {1761}insert statestore(me_3,them_3,sid_4,statepack_b(hs_57))
    ) | (
        {1854}get statestore(=me_3,=them_3,=sid_4,statepack_b(hs_58: handshakestate)) in
        {1764}let v_580: bitstring = catch-fail(handshakestateunpack(hs_58)) in
        {1765}let v_581: bool = (not-caught-fail(v_580) && success?(1-proj-9-tuple(v_580))) in
        {1766}let initiator_17: bool = (if v_581 then 9-proj-9-tuple(v_580) else caught-fail) in
        {1767}let psk_20: key = (if v_581 then 8-proj-9-tuple(v_580) else caught-fail) in
        {1768}let re_24: key = (if v_581 then 7-proj-9-tuple(v_580) else caught-fail) in
        {1769}let rm_21: key = (if v_581 then 6-proj-9-tuple(v_580) else caught-fail) in
        {1770}let rs_20: key = (if v_581 then 5-proj-9-tuple(v_580) else caught-fail) in
        {1771}let e_33: keypair = (if v_581 then 4-proj-9-tuple(v_580) else caught-fail) in
        {1772}let m_22: keypair = (if v_581 then 3-proj-9-tuple(v_580) else caught-fail) in
        {1773}let s_20: keypair = (if v_581 then 2-proj-9-tuple(v_580) else caught-fail) in
        {1774}let ss_91: symmetricstate = (if v_581 then 1-proj-9-tuple(v_580) else caught-fail) in
        {1775}let v_582: bitstring = (if v_581 then catch-fail((empty,empty,empty)) else caught-fail) in
        {1776}let v_583: bool = (not-caught-fail(v_582) && success?(1-proj-3-tuple(v_582))) in
        {1777}let ciphertext_34: bitstring = (if v_583 then 3-proj-3-tuple(v_582) else caught-fail) in
        {1778}let ns_16: bitstring = (if v_583 then 2-proj-3-tuple(v_582) else caught-fail) in
        {1779}let ne_16: bitstring = (if v_583 then 1-proj-3-tuple(v_582) else caught-fail) in
        {1780}let basis_14: key = (if v_583 then key_e(me_3,them_3,sid_4) else caught-fail) in
        {1781}let public_key_14: key = (if v_583 then catch-fail(dhexp(basis_14,validkey(g))) else caught-fail) in
        {1782}let v_584: bool = not-caught-fail(public_key_14) in
        {1783}let e_34: keypair = (if v_583 then catch-fail((if v_584 then keypairpack(validkey(public_key_14),basis_14) else fail-any)) else caught-fail) in
        {1784}let v_585: bool = not-caught-fail(e_34) in
        {1785}let ne_17: bitstring = (if v_585 then catch-fail(getpublickey(e_34)) else caught-fail) in
        {1786}let v_586: bool = not-caught-fail(ne_17) in
        {1787}let v_587: bitstring = (if v_586 then catch-fail(symmetricstateunpack(ss_91)) else caught-fail) in
        {1788}let v_588: bool = (not-caught-fail(v_587) && success?(1-proj-3-tuple(v_587))) in
        {1789}let h_78: bitstring = (if v_588 then 3-proj-3-tuple(v_587) else caught-fail) in
        {1790}let ck_92: key = (if v_588 then 2-proj-3-tuple(v_587) else caught-fail) in
        {1791}let cs_78: cipherstate = (if v_588 then 1-proj-3-tuple(v_587) else caught-fail) in
        {1792}let ss_92: symmetricstate = (if v_586 then catch-fail((if v_588 then symmetricstatepack(cs_78,ck_92,hash(h_78,ne_17)) else fail-any)) else caught-fail) in
        {1793}let v_589: bool = not-caught-fail(ss_92) in
        {1794}let v_590: bitstring = (if v_589 then catch-fail(keypairunpack(e_34)) else caught-fail) in
        {1795}let v_591: bool = (not-caught-fail(v_590) && success?(1-proj-2-tuple(v_590))) in
        {1796}let my_private_key_14: key = (if v_591 then 2-proj-2-tuple(v_590) else caught-fail) in
        {1797}let my_public_key_14: key = (if v_591 then 1-proj-2-tuple(v_590) else caught-fail) in
        {1798}let input_key_material_17: key = (if v_589 then catch-fail((if v_591 then dhexp(my_private_key_14,re_24) else fail-any)) else caught-fail) in
        {1799}let v_592: bool = not-caught-fail(input_key_material_17) in
        {1800}let v_593: bitstring = (if v_592 then catch-fail(symmetricstateunpack(ss_92)) else caught-fail) in
        {1801}let v_594: bool = (not-caught-fail(v_593) && success?(1-proj-3-tuple(v_593))) in
        {1802}let h_79: bitstring = (if v_594 then 3-proj-3-tuple(v_593) else caught-fail) in
        {1803}let ck_93: key = (if v_594 then 2-proj-3-tuple(v_593) else caught-fail) in
        {1804}let cs_79: cipherstate = (if v_594 then 1-proj-3-tuple(v_593) else caught-fail) in
        {1807}let output3_17: key = (if v_594 then hmac_hash3(ck_93,input_key_material_17) else caught-fail) in
        {1806}let output2_17: key = (if v_594 then hmac_hash2(ck_93,input_key_material_17) else caught-fail) in
        {1805}let output1_17: key = (if v_594 then hmac_hash1(ck_93,input_key_material_17) else caught-fail) in
        {1808}let v_595: bitstring = (if v_594 then catch-fail((output1_17,output2_17,output3_17)) else caught-fail) in
        {1809}let v_596: bool = (not-caught-fail(v_595) && success?(1-proj-3-tuple(v_595))) in
        {1810}let output_14: key = (if v_596 then 3-proj-3-tuple(v_595) else caught-fail) in
        {1811}let temp_k_14: key = (if v_596 then 2-proj-3-tuple(v_595) else caught-fail) in
        {1812}let ck_94: key = (if v_596 then 1-proj-3-tuple(v_595) else caught-fail) in
        {1813}let ss_93: symmetricstate = (if v_589 then catch-fail((if v_592 then (if v_594 then (if v_596 then symmetricstatepack(cipherstatepack(temp_k_14,minnonce),ck_94,h_79) else fail-any) else fail-any) else fail-any)) else caught-fail) in
        {1814}let v_597: bool = not-caught-fail(ss_93) in
        {1815}let v_598: bitstring = (if v_597 then catch-fail(symmetricstateunpack(ss_93)) else caught-fail) in
        {1816}let v_599: bool = (not-caught-fail(v_598) && success?(1-proj-3-tuple(v_598))) in
        {1817}let h_80: bitstring = (if v_599 then 3-proj-3-tuple(v_598) else caught-fail) in
        {1818}let ck_95: key = (if v_599 then 2-proj-3-tuple(v_598) else caught-fail) in
        {1819}let cs_80: cipherstate = (if v_599 then 1-proj-3-tuple(v_598) else caught-fail) in
        {1820}let v_600: bitstring = (if v_599 then catch-fail(cipherstateunpack(cs_80)) else caught-fail) in
        {1821}let v_601: bool = (not-caught-fail(v_600) && success?(1-proj-2-tuple(v_600))) in
        {1822}let n_38: nonce = (if v_601 then 2-proj-2-tuple(v_600) else caught-fail) in
        {1823}let k_42: key = (if v_601 then 1-proj-2-tuple(v_600) else caught-fail) in
        {1826}let v_602: bitstring = (if v_601 then catch-fail(cipherstateunpack(cs_80)) else caught-fail) in
        {1827}let v_603: bool = (not-caught-fail(v_602) && success?(1-proj-2-tuple(v_602))) in
        {1828}let o_19: nonce = (if v_603 then 2-proj-2-tuple(v_602) else caught-fail) in
        {1829}let k_43: key = (if v_603 then 1-proj-2-tuple(v_602) else caught-fail) in
        {1825}let n_39: nonce = (if v_601 then increment_nonce(n_38) else caught-fail) in
        {1830}let csi_38: cipherstate = (if v_601 then catch-fail((if v_603 then cipherstatepack(k_43,n_39) else fail-any)) else caught-fail) in
        {1831}let v_604: bool = not-caught-fail(csi_38) in
        {1763}let payload_8: bitstring = msg_b(me_3,them_3,sid_4) in
        {1824}let e_35: bitstring = (if v_601 then encrypt(k_42,n_38,h_80,payload_8) else caught-fail) in
        {1832}let v_605: bitstring = (if v_599 then catch-fail((if v_601 then (if v_604 then (csi_38,e_35) else fail-any) else fail-any)) else caught-fail) in
        {1833}let v_606: bool = (not-caught-fail(v_605) && success?(1-proj-2-tuple(v_605))) in
        {1834}let ciphertext_35: bitstring = (if v_606 then 2-proj-2-tuple(v_605) else caught-fail) in
        {1835}let csi_39: cipherstate = (if v_606 then 1-proj-2-tuple(v_605) else caught-fail) in
        {1836}let ss_94: symmetricstate = (if v_606 then symmetricstatepack(csi_39,ck_95,h_80) else caught-fail) in
        {1837}let v_607: bitstring = (if v_606 then catch-fail(symmetricstateunpack(ss_94)) else caught-fail) in
        {1838}let v_608: bool = (not-caught-fail(v_607) && success?(1-proj-3-tuple(v_607))) in
        {1839}let h_81: bitstring = (if v_608 then 3-proj-3-tuple(v_607) else caught-fail) in
        {1840}let ck_96: key = (if v_608 then 2-proj-3-tuple(v_607) else caught-fail) in
        {1841}let cs_81: cipherstate = (if v_608 then 1-proj-3-tuple(v_607) else caught-fail) in
        {1842}let ssi_22: symmetricstate = (if v_606 then catch-fail((if v_608 then symmetricstatepack(cs_81,ck_96,hash(h_81,ciphertext_35)) else fail-any)) else caught-fail) in
        {1843}let v_609: bool = not-caught-fail(ssi_22) in
        {1844}let v_610: bitstring = (if v_597 then catch-fail((if v_599 then (if v_606 then (if v_609 then (ssi_22,ciphertext_35) else fail-any) else fail-any) else fail-any)) else caught-fail) in
        {1845}let v_611: bool = (not-caught-fail(v_610) && success?(1-proj-2-tuple(v_610))) in
        {1846}let ciphertext_36: bitstring = (if v_611 then 2-proj-2-tuple(v_610) else caught-fail) in
        {1847}let ss_95: symmetricstate = (if v_611 then 1-proj-2-tuple(v_610) else caught-fail) in
        {1849}let message_buffer_8: bitstring = (if v_611 then concat3(ne_17,ns_16,ciphertext_36) else caught-fail) in
        {1848}let hs_59: handshakestate = (if v_611 then handshakestatepack(ss_95,s_20,m_22,e_34,rs_20,rm_21,re_24,psk_20,initiator_17) else caught-fail) in
        {1850}let (hs_60: handshakestate,message_b_3: bitstring) = (if v_581 then (if v_583 then (if v_585 then (if v_586 then (if v_589 then (if v_597 then (if v_611 then (hs_59,message_buffer_8) else fail-any) else fail-any) else fail-any) else fail-any) else fail-any) else fail-any) else fail-any) in
        {1851}event SendMsg(me_3,them_3,stagepack_b(sid_4),msg_b(me_3,them_3,sid_4));
        {1852}insert statestore(me_3,them_3,sid_4,statepack_c(hs_60));
        {1853}out(pub, message_b_3)
    ) | (
        {2006}get statestore(=me_3,=them_3,=sid_4,statepack_c(hs_61: handshakestate)) in
        {1855}in(pub, message_c_3: bitstring);
        {1856}let v_612: bitstring = catch-fail(handshakestateunpack(hs_61)) in
        {1857}let v_613: bool = (not-caught-fail(v_612) && success?(1-proj-9-tuple(v_612))) in
        {1858}let initiator_18: bool = (if v_613 then 9-proj-9-tuple(v_612) else caught-fail) in
        {1859}let psk_21: key = (if v_613 then 8-proj-9-tuple(v_612) else caught-fail) in
        {1860}let re_25: key = (if v_613 then 7-proj-9-tuple(v_612) else caught-fail) in
        {1861}let rm_22: key = (if v_613 then 6-proj-9-tuple(v_612) else caught-fail) in
        {1862}let rs_21: key = (if v_613 then 5-proj-9-tuple(v_612) else caught-fail) in
        {1863}let e_36: keypair = (if v_613 then 4-proj-9-tuple(v_612) else caught-fail) in
        {1864}let m_23: keypair = (if v_613 then 3-proj-9-tuple(v_612) else caught-fail) in
        {1865}let s_21: keypair = (if v_613 then 2-proj-9-tuple(v_612) else caught-fail) in
        {1866}let ss_96: symmetricstate = (if v_613 then 1-proj-9-tuple(v_612) else caught-fail) in
        {1867}let v_614: bitstring = (if v_613 then catch-fail(deconcat3(message_c_3)) else caught-fail) in
        {1868}let v_615: bool = (not-caught-fail(v_614) && success?(1-proj-3-tuple(v_614))) in
        {1869}let ciphertext_37: bitstring = (if v_615 then 3-proj-3-tuple(v_614) else caught-fail) in
        {1870}let nm_5: bitstring = (if v_615 then 2-proj-3-tuple(v_614) else caught-fail) in
        {1871}let ns_17: bitstring = (if v_615 then 1-proj-3-tuple(v_614) else caught-fail) in
        {1873}let v_616: bitstring = (if v_615 then catch-fail(symmetricstateunpack(ss_96)) else caught-fail) in
        {1874}let v_617: bool = (not-caught-fail(v_616) && success?(1-proj-3-tuple(v_616))) in
        {1875}let h_82: bitstring = (if v_617 then 3-proj-3-tuple(v_616) else caught-fail) in
        {1876}let ck_97: key = (if v_617 then 2-proj-3-tuple(v_616) else caught-fail) in
        {1877}let cs_82: cipherstate = (if v_617 then 1-proj-3-tuple(v_616) else caught-fail) in
        {1878}let v_618: bitstring = (if v_617 then catch-fail(cipherstateunpack(cs_82)) else caught-fail) in
        {1879}let v_619: bool = (not-caught-fail(v_618) && success?(1-proj-2-tuple(v_618))) in
        {1880}let n_40: nonce = (if v_619 then 2-proj-2-tuple(v_618) else caught-fail) in
        {1881}let k_44: key = (if v_619 then 1-proj-2-tuple(v_618) else caught-fail) in
        {1882}let d_9: aead = (if v_619 then catch-fail(decrypt(k_44,n_40,h_82,nm_5)) else caught-fail) in
        {1883}let v_620: bool = not-caught-fail(d_9) in
        {1884}let v_621: bitstring = (if v_620 then catch-fail(aeadunpack(d_9)) else caught-fail) in
        {1885}let v_622: bool = (not-caught-fail(v_621) && success?(1-proj-3-tuple(v_621))) in
        {1886}let plaintext_28: bitstring = (if v_622 then 3-proj-3-tuple(v_621) else caught-fail) in
        {1887}let adi_9: bitstring = (if v_622 then 2-proj-3-tuple(v_621) else caught-fail) in
        {1888}let valid_26: bool = (if v_622 then 1-proj-3-tuple(v_621) else caught-fail) in
        {1890}let v_623: bitstring = (if v_622 then catch-fail(cipherstateunpack(cs_82)) else caught-fail) in
        {1891}let v_624: bool = (not-caught-fail(v_623) && success?(1-proj-2-tuple(v_623))) in
        {1892}let o_20: nonce = (if v_624 then 2-proj-2-tuple(v_623) else caught-fail) in
        {1893}let k_45: key = (if v_624 then 1-proj-2-tuple(v_623) else caught-fail) in
        {1889}let n_41: nonce = (if v_622 then increment_nonce(n_40) else caught-fail) in
        {1894}let csi_40: cipherstate = (if v_622 then catch-fail((if v_624 then cipherstatepack(k_45,n_41) else fail-any)) else caught-fail) in
        {1895}let v_625: bool = not-caught-fail(csi_40) in
        {1896}let v_626: bitstring = (if v_617 then catch-fail((if v_619 then (if v_620 then (if v_622 then (if v_625 then (csi_40,plaintext_28,valid_26) else fail-any) else fail-any) else fail-any) else fail-any)) else caught-fail) in
        {1897}let v_627: bool = (not-caught-fail(v_626) && success?(1-proj-3-tuple(v_626))) in
        {1898}let valid_27: bool = (if v_627 then 3-proj-3-tuple(v_626) else caught-fail) in
        {1899}let plaintext_29: bitstring = (if v_627 then 2-proj-3-tuple(v_626) else caught-fail) in
        {1900}let csi_41: cipherstate = (if v_627 then 1-proj-3-tuple(v_626) else caught-fail) in
        {1901}let ss_97: symmetricstate = (if v_627 then symmetricstatepack(csi_41,ck_97,h_82) else caught-fail) in
        {1902}let v_628: bitstring = (if v_627 then catch-fail(symmetricstateunpack(ss_97)) else caught-fail) in
        {1903}let v_629: bool = (not-caught-fail(v_628) && success?(1-proj-3-tuple(v_628))) in
        {1904}let h_83: bitstring = (if v_629 then 3-proj-3-tuple(v_628) else caught-fail) in
        {1905}let ck_98: key = (if v_629 then 2-proj-3-tuple(v_628) else caught-fail) in
        {1906}let cs_83: cipherstate = (if v_629 then 1-proj-3-tuple(v_628) else caught-fail) in
        {1907}let ssi_23: symmetricstate = (if v_627 then catch-fail((if v_629 then symmetricstatepack(cs_83,ck_98,hash(h_83,nm_5)) else fail-any)) else caught-fail) in
        {1908}let v_630: bool = not-caught-fail(ssi_23) in
        {1909}let v_631: bitstring = (if v_615 then catch-fail((if v_617 then (if v_627 then (if v_630 then (ssi_23,plaintext_29,valid_27) else fail-any) else fail-any) else fail-any)) else caught-fail) in
        {1910}let v_632: bool = (not-caught-fail(v_631) && success?(1-proj-3-tuple(v_631))) in
        {1911}let valid1_10: bool = (if v_632 then 3-proj-3-tuple(v_631) else caught-fail) in
        {1912}let nem_1: bitstring = (if v_632 then 2-proj-3-tuple(v_631) else caught-fail) in
        {1913}let ss_98: symmetricstate = (if v_632 then 1-proj-3-tuple(v_631) else caught-fail) in
        {1915}let v_633: bitstring = (if v_632 then catch-fail(keypairunpack(e_36)) else caught-fail) in
        {1916}let v_634: bool = (not-caught-fail(v_633) && success?(1-proj-2-tuple(v_633))) in
        {1917}let my_private_key_15: key = (if v_634 then 2-proj-2-tuple(v_633) else caught-fail) in
        {1918}let my_public_key_15: key = (if v_634 then 1-proj-2-tuple(v_633) else caught-fail) in
        {1914}let rm_23: key = (if v_632 then nem_1 else caught-fail) in
        {1919}let input_key_material_18: key = (if v_632 then catch-fail((if v_634 then dhexp(my_private_key_15,rm_23) else fail-any)) else caught-fail) in
        {1920}let v_635: bool = not-caught-fail(input_key_material_18) in
        {1921}let v_636: bitstring = (if v_635 then catch-fail(symmetricstateunpack(ss_98)) else caught-fail) in
        {1922}let v_637: bool = (not-caught-fail(v_636) && success?(1-proj-3-tuple(v_636))) in
        {1923}let h_84: bitstring = (if v_637 then 3-proj-3-tuple(v_636) else caught-fail) in
        {1924}let ck_99: key = (if v_637 then 2-proj-3-tuple(v_636) else caught-fail) in
        {1925}let cs_84: cipherstate = (if v_637 then 1-proj-3-tuple(v_636) else caught-fail) in
        {1928}let output3_18: key = (if v_637 then hmac_hash3(ck_99,input_key_material_18) else caught-fail) in
        {1927}let output2_18: key = (if v_637 then hmac_hash2(ck_99,input_key_material_18) else caught-fail) in
        {1926}let output1_18: key = (if v_637 then hmac_hash1(ck_99,input_key_material_18) else caught-fail) in
        {1929}let v_638: bitstring = (if v_637 then catch-fail((output1_18,output2_18,output3_18)) else caught-fail) in
        {1930}let v_639: bool = (not-caught-fail(v_638) && success?(1-proj-3-tuple(v_638))) in
        {1931}let output_15: key = (if v_639 then 3-proj-3-tuple(v_638) else caught-fail) in
        {1932}let temp_k_15: key = (if v_639 then 2-proj-3-tuple(v_638) else caught-fail) in
        {1933}let ck_100: key = (if v_639 then 1-proj-3-tuple(v_638) else caught-fail) in
        {1934}let ss_99: symmetricstate = (if v_632 then catch-fail((if v_635 then (if v_637 then (if v_639 then symmetricstatepack(cipherstatepack(temp_k_15,minnonce),ck_100,h_84) else fail-any) else fail-any) else fail-any)) else caught-fail) in
        {1935}let v_640: bool = not-caught-fail(ss_99) in
        {1936}let v_641: bitstring = (if v_640 then catch-fail(symmetricstateunpack(ss_99)) else caught-fail) in
        {1937}let v_642: bool = (not-caught-fail(v_641) && success?(1-proj-3-tuple(v_641))) in
        {1938}let h_85: bitstring = (if v_642 then 3-proj-3-tuple(v_641) else caught-fail) in
        {1939}let ck_101: key = (if v_642 then 2-proj-3-tuple(v_641) else caught-fail) in
        {1940}let cs_85: cipherstate = (if v_642 then 1-proj-3-tuple(v_641) else caught-fail) in
        {1941}let v_643: bitstring = (if v_642 then catch-fail(cipherstateunpack(cs_85)) else caught-fail) in
        {1942}let v_644: bool = (not-caught-fail(v_643) && success?(1-proj-2-tuple(v_643))) in
        {1943}let n_42: nonce = (if v_644 then 2-proj-2-tuple(v_643) else caught-fail) in
        {1944}let k_46: key = (if v_644 then 1-proj-2-tuple(v_643) else caught-fail) in
        {1945}let d_10: aead = (if v_644 then catch-fail(decrypt(k_46,n_42,h_85,ciphertext_37)) else caught-fail) in
        {1946}let v_645: bool = not-caught-fail(d_10) in
        {1947}let v_646: bitstring = (if v_645 then catch-fail(aeadunpack(d_10)) else caught-fail) in
        {1948}let v_647: bool = (not-caught-fail(v_646) && success?(1-proj-3-tuple(v_646))) in
        {1949}let plaintext_30: bitstring = (if v_647 then 3-proj-3-tuple(v_646) else caught-fail) in
        {1950}let adi_10: bitstring = (if v_647 then 2-proj-3-tuple(v_646) else caught-fail) in
        {1951}let valid_28: bool = (if v_647 then 1-proj-3-tuple(v_646) else caught-fail) in
        {1953}let v_648: bitstring = (if v_647 then catch-fail(cipherstateunpack(cs_85)) else caught-fail) in
        {1954}let v_649: bool = (not-caught-fail(v_648) && success?(1-proj-2-tuple(v_648))) in
        {1955}let o_21: nonce = (if v_649 then 2-proj-2-tuple(v_648) else caught-fail) in
        {1956}let k_47: key = (if v_649 then 1-proj-2-tuple(v_648) else caught-fail) in
        {1952}let n_43: nonce = (if v_647 then increment_nonce(n_42) else caught-fail) in
        {1957}let csi_42: cipherstate = (if v_647 then catch-fail((if v_649 then cipherstatepack(k_47,n_43) else fail-any)) else caught-fail) in
        {1958}let v_650: bool = not-caught-fail(csi_42) in
        {1959}let v_651: bitstring = (if v_642 then catch-fail((if v_644 then (if v_645 then (if v_647 then (if v_650 then (csi_42,plaintext_30,valid_28) else fail-any) else fail-any) else fail-any) else fail-any)) else caught-fail) in
        {1960}let v_652: bool = (not-caught-fail(v_651) && success?(1-proj-3-tuple(v_651))) in
        {1961}let valid_29: bool = (if v_652 then 3-proj-3-tuple(v_651) else caught-fail) in
        {1962}let plaintext_31: bitstring = (if v_652 then 2-proj-3-tuple(v_651) else caught-fail) in
        {1963}let csi_43: cipherstate = (if v_652 then 1-proj-3-tuple(v_651) else caught-fail) in
        {1964}let ss_100: symmetricstate = (if v_652 then symmetricstatepack(csi_43,ck_101,h_85) else caught-fail) in
        {1965}let v_653: bitstring = (if v_652 then catch-fail(symmetricstateunpack(ss_100)) else caught-fail) in
        {1966}let v_654: bool = (not-caught-fail(v_653) && success?(1-proj-3-tuple(v_653))) in
        {1967}let h_86: bitstring = (if v_654 then 3-proj-3-tuple(v_653) else caught-fail) in
        {1968}let ck_102: key = (if v_654 then 2-proj-3-tuple(v_653) else caught-fail) in
        {1969}let cs_86: cipherstate = (if v_654 then 1-proj-3-tuple(v_653) else caught-fail) in
        {1970}let ssi_24: symmetricstate = (if v_652 then catch-fail((if v_654 then symmetricstatepack(cs_86,ck_102,hash(h_86,ciphertext_37)) else fail-any)) else caught-fail) in
        {1971}let v_655: bool = not-caught-fail(ssi_24) in
        {1972}let v_656: bitstring = (if v_640 then catch-fail((if v_642 then (if v_652 then (if v_655 then (ssi_24,plaintext_31,valid_29) else fail-any) else fail-any) else fail-any)) else caught-fail) in
        {1973}let v_657: bool = (not-caught-fail(v_656) && success?(1-proj-3-tuple(v_656))) in
        {1974}let valid2_8: bool = (if v_657 then 3-proj-3-tuple(v_656) else caught-fail) in
        {1975}let plaintext_32: bitstring = (if v_657 then 2-proj-3-tuple(v_656) else caught-fail) in
        {1976}let ss_101: symmetricstate = (if v_657 then 1-proj-3-tuple(v_656) else caught-fail) in
        {1977}let basis_15: key = (if v_657 then key_s(them_3) else caught-fail) in
        {1978}let public_key_15: key = (if v_657 then catch-fail(dhexp(basis_15,validkey(g))) else caught-fail) in
        {1979}let v_658: bool = not-caught-fail(public_key_15) in
        {1980}let v_659: bool = (if v_657 then catch-fail(((valid1_10 && valid2_8) && (rs_21 = getpublickey((if v_658 then keypairpack(validkey(public_key_15),basis_15) else fail-any))))) else caught-fail) in
        {1982}let v_660: bitstring = (if v_659 then catch-fail(symmetricstateunpack(ss_101)) else caught-fail) in
        {1983}let v_661: bool = (not-caught-fail(v_660) && success?(1-proj-3-tuple(v_660))) in
        {1984}let h_87: bitstring = (if v_661 then 3-proj-3-tuple(v_660) else caught-fail) in
        {1985}let ck_103: key = (if v_661 then 2-proj-3-tuple(v_660) else caught-fail) in
        {1986}let cs_87: cipherstate = (if v_661 then 1-proj-3-tuple(v_660) else caught-fail) in
        {1987}let input_key_material_19: key = (if v_661 then zero else caught-fail) in
        {1990}let output3_19: key = (if v_661 then hmac_hash3(ck_103,input_key_material_19) else caught-fail) in
        {1989}let output2_19: key = (if v_661 then hmac_hash2(ck_103,input_key_material_19) else caught-fail) in
        {1988}let output1_19: key = (if v_661 then hmac_hash1(ck_103,input_key_material_19) else caught-fail) in
        {1991}let v_662: bitstring = (if v_661 then catch-fail((output1_19,output2_19,output3_19)) else caught-fail) in
        {1992}let v_663: bool = (not-caught-fail(v_662) && success?(1-proj-3-tuple(v_662))) in
        {1993}let temp_k3_3: key = (if v_663 then 3-proj-3-tuple(v_662) else caught-fail) in
        {1994}let temp_k2_3: key = (if v_663 then 2-proj-3-tuple(v_662) else caught-fail) in
        {1995}let temp_k1_3: key = (if v_663 then 1-proj-3-tuple(v_662) else caught-fail) in
        {1997}let cs2_15: cipherstate = (if v_663 then cipherstatepack(temp_k2_3,minnonce) else caught-fail) in
        {1996}let cs1_15: cipherstate = (if v_663 then cipherstatepack(temp_k1_3,minnonce) else caught-fail) in
        {1998}let v_664: bitstring = (if v_659 then catch-fail((if v_661 then (if v_663 then (ss_101,cs1_15,cs2_15) else fail-any) else fail-any)) else caught-fail) in
        {1999}let v_665: bool = (not-caught-fail(v_664) && success?(1-proj-3-tuple(v_664))) in
        {2000}let cs2_16: cipherstate = (if v_665 then 3-proj-3-tuple(v_664) else caught-fail) in
        {2001}let cs1_16: cipherstate = (if v_665 then 2-proj-3-tuple(v_664) else caught-fail) in
        {2002}let ssi_25: symmetricstate = (if v_665 then 1-proj-3-tuple(v_664) else caught-fail) in
        {1981}let hs_62: handshakestate = (if v_659 then handshakestatepack(ss_101,s_21,m_23,e_36,rs_21,rm_23,re_25,psk_21,initiator_18) else caught-fail) in
        {2003}let (hs_63: handshakestate,plaintext_c_1: bitstring,valid_30: bool,cs1_17: cipherstate,cs2_17: cipherstate) = (if v_613 then (if v_615 then (if v_632 then (if v_640 then (if v_657 then (if undo-catch-fail(v_659) then (if v_665 then (hs_62,plaintext_32,true,cs1_16,cs2_16) else fail-any) else fail-any) else fail-any) else fail-any) else fail-any) else fail-any) else fail-any) in
        {2004}event RecvMsg(me_3,them_3,stagepack_c(sid_4),plaintext_c_1);
        {2005}insert statestore(me_3,them_3,sid_4,statepack_d(hs_63,cs1_17,cs2_17))
    ) | (
        {2007}!
        {2065}get statestore(=me_3,=them_3,=sid_4,statepack_d(hs_64: handshakestate,cs1_18: cipherstate,cs2_18: cipherstate)) in
        {2008}let hs_65: handshakestate = handshakestatesetcs(hs_64,cs2_18) in
        {2010}let v_666: bitstring = catch-fail(handshakestateunpack(hs_65)) in
        {2011}let v_667: bool = (not-caught-fail(v_666) && success?(1-proj-9-tuple(v_666))) in
        {2012}let initiator_19: bool = (if v_667 then 9-proj-9-tuple(v_666) else caught-fail) in
        {2013}let psk_22: key = (if v_667 then 8-proj-9-tuple(v_666) else caught-fail) in
        {2014}let re_26: key = (if v_667 then 7-proj-9-tuple(v_666) else caught-fail) in
        {2015}let rm_24: key = (if v_667 then 6-proj-9-tuple(v_666) else caught-fail) in
        {2016}let rs_22: key = (if v_667 then 5-proj-9-tuple(v_666) else caught-fail) in
        {2017}let e_37: keypair = (if v_667 then 4-proj-9-tuple(v_666) else caught-fail) in
        {2018}let m_24: keypair = (if v_667 then 3-proj-9-tuple(v_666) else caught-fail) in
        {2019}let s_22: keypair = (if v_667 then 2-proj-9-tuple(v_666) else caught-fail) in
        {2020}let ss_102: symmetricstate = (if v_667 then 1-proj-9-tuple(v_666) else caught-fail) in
        {2021}let v_668: bitstring = (if v_667 then catch-fail((empty,empty,empty)) else caught-fail) in
        {2022}let v_669: bool = (not-caught-fail(v_668) && success?(1-proj-3-tuple(v_668))) in
        {2023}let ciphertext_38: bitstring = (if v_669 then 3-proj-3-tuple(v_668) else caught-fail) in
        {2024}let ns_18: bitstring = (if v_669 then 2-proj-3-tuple(v_668) else caught-fail) in
        {2025}let ne_18: bitstring = (if v_669 then 1-proj-3-tuple(v_668) else caught-fail) in
        {2026}let v_670: bitstring = (if v_669 then catch-fail(symmetricstateunpack(ss_102)) else caught-fail) in
        {2027}let v_671: bool = (not-caught-fail(v_670) && success?(1-proj-3-tuple(v_670))) in
        {2028}let h_88: bitstring = (if v_671 then 3-proj-3-tuple(v_670) else caught-fail) in
        {2029}let ck_104: key = (if v_671 then 2-proj-3-tuple(v_670) else caught-fail) in
        {2030}let cs_88: cipherstate = (if v_671 then 1-proj-3-tuple(v_670) else caught-fail) in
        {2031}let v_672: bitstring = (if v_671 then catch-fail(cipherstateunpack(cs_88)) else caught-fail) in
        {2032}let v_673: bool = (not-caught-fail(v_672) && success?(1-proj-2-tuple(v_672))) in
        {2033}let n_44: nonce = (if v_673 then 2-proj-2-tuple(v_672) else caught-fail) in
        {2034}let k_48: key = (if v_673 then 1-proj-2-tuple(v_672) else caught-fail) in
        {2037}let v_674: bitstring = (if v_673 then catch-fail(cipherstateunpack(cs_88)) else caught-fail) in
        {2038}let v_675: bool = (not-caught-fail(v_674) && success?(1-proj-2-tuple(v_674))) in
        {2039}let o_22: nonce = (if v_675 then 2-proj-2-tuple(v_674) else caught-fail) in
        {2040}let k_49: key = (if v_675 then 1-proj-2-tuple(v_674) else caught-fail) in
        {2036}let n_45: nonce = (if v_673 then increment_nonce(n_44) else caught-fail) in
        {2041}let csi_44: cipherstate = (if v_673 then catch-fail((if v_675 then cipherstatepack(k_49,n_45) else fail-any)) else caught-fail) in
        {2042}let v_676: bool = not-caught-fail(csi_44) in
        {2009}let payload_9: bitstring = msg_d(me_3,them_3,sid_4) in
        {2035}let e_38: bitstring = (if v_673 then encrypt(k_48,n_44,h_88,payload_9) else caught-fail) in
        {2043}let v_677: bitstring = (if v_671 then catch-fail((if v_673 then (if v_676 then (csi_44,e_38) else fail-any) else fail-any)) else caught-fail) in
        {2044}let v_678: bool = (not-caught-fail(v_677) && success?(1-proj-2-tuple(v_677))) in
        {2045}let ciphertext_39: bitstring = (if v_678 then 2-proj-2-tuple(v_677) else caught-fail) in
        {2046}let csi_45: cipherstate = (if v_678 then 1-proj-2-tuple(v_677) else caught-fail) in
        {2047}let ss_103: symmetricstate = (if v_678 then symmetricstatepack(csi_45,ck_104,h_88) else caught-fail) in
        {2048}let v_679: bitstring = (if v_678 then catch-fail(symmetricstateunpack(ss_103)) else caught-fail) in
        {2049}let v_680: bool = (not-caught-fail(v_679) && success?(1-proj-3-tuple(v_679))) in
        {2050}let h_89: bitstring = (if v_680 then 3-proj-3-tuple(v_679) else caught-fail) in
        {2051}let ck_105: key = (if v_680 then 2-proj-3-tuple(v_679) else caught-fail) in
        {2052}let cs_89: cipherstate = (if v_680 then 1-proj-3-tuple(v_679) else caught-fail) in
        {2053}let ssi_26: symmetricstate = (if v_678 then catch-fail((if v_680 then symmetricstatepack(cs_89,ck_105,hash(h_89,ciphertext_39)) else fail-any)) else caught-fail) in
        {2054}let v_681: bool = not-caught-fail(ssi_26) in
        {2055}let v_682: bitstring = (if v_669 then catch-fail((if v_671 then (if v_678 then (if v_681 then (ssi_26,ciphertext_39) else fail-any) else fail-any) else fail-any)) else caught-fail) in
        {2056}let v_683: bool = (not-caught-fail(v_682) && success?(1-proj-2-tuple(v_682))) in
        {2057}let ciphertext_40: bitstring = (if v_683 then 2-proj-2-tuple(v_682) else caught-fail) in
        {2058}let ss_104: symmetricstate = (if v_683 then 1-proj-2-tuple(v_682) else caught-fail) in
        {2060}let message_buffer_9: bitstring = (if v_683 then concat3(ne_18,ns_18,ciphertext_40) else caught-fail) in
        {2059}let hs_66: handshakestate = (if v_683 then handshakestatepack(ss_104,s_22,m_24,e_37,rs_22,rm_24,re_26,psk_22,initiator_19) else caught-fail) in
        {2061}let (hs_67: handshakestate,message_d_3: bitstring) = (if v_667 then (if v_669 then (if v_683 then (hs_66,message_buffer_9) else fail-any) else fail-any) else fail-any) in
        {2062}event SendMsg(me_3,them_3,stagepack_d(sid_4),msg_d(me_3,them_3,sid_4));
        {2063}insert statestore(me_3,them_3,sid_4,statepack_e(hs_67,cs1_18,handshakestategetcs(hs_67)));
        {2064}out(pub, message_d_3)
    ) | (
        {2066}!
        {2132}get statestore(=me_3,=them_3,=sid_4,statepack_e(hs_68: handshakestate,cs1_19: cipherstate,cs2_19: cipherstate)) in
        {2067}let hs_69: handshakestate = handshakestatesetcs(hs_68,cs1_19) in
        {2068}in(pub, message_e_3: bitstring);
        {2069}let v_684: bitstring = catch-fail(handshakestateunpack(hs_69)) in
        {2070}let v_685: bool = (not-caught-fail(v_684) && success?(1-proj-9-tuple(v_684))) in
        {2071}let initiator_20: bool = (if v_685 then 9-proj-9-tuple(v_684) else caught-fail) in
        {2072}let psk_23: key = (if v_685 then 8-proj-9-tuple(v_684) else caught-fail) in
        {2073}let re_27: key = (if v_685 then 7-proj-9-tuple(v_684) else caught-fail) in
        {2074}let rm_25: key = (if v_685 then 6-proj-9-tuple(v_684) else caught-fail) in
        {2075}let rs_23: key = (if v_685 then 5-proj-9-tuple(v_684) else caught-fail) in
        {2076}let e_39: keypair = (if v_685 then 4-proj-9-tuple(v_684) else caught-fail) in
        {2077}let m_25: keypair = (if v_685 then 3-proj-9-tuple(v_684) else caught-fail) in
        {2078}let s_23: keypair = (if v_685 then 2-proj-9-tuple(v_684) else caught-fail) in
        {2079}let ss_105: symmetricstate = (if v_685 then 1-proj-9-tuple(v_684) else caught-fail) in
        {2080}let v_686: bitstring = (if v_685 then catch-fail(deconcat3(message_e_3)) else caught-fail) in
        {2081}let v_687: bool = (not-caught-fail(v_686) && success?(1-proj-3-tuple(v_686))) in
        {2082}let ciphertext_41: bitstring = (if v_687 then 3-proj-3-tuple(v_686) else caught-fail) in
        {2083}let ns_19: bitstring = (if v_687 then 2-proj-3-tuple(v_686) else caught-fail) in
        {2084}let ne_19: bitstring = (if v_687 then 1-proj-3-tuple(v_686) else caught-fail) in
        {2086}let v_688: bitstring = (if v_687 then catch-fail(symmetricstateunpack(ss_105)) else caught-fail) in
        {2087}let v_689: bool = (not-caught-fail(v_688) && success?(1-proj-3-tuple(v_688))) in
        {2088}let h_90: bitstring = (if v_689 then 3-proj-3-tuple(v_688) else caught-fail) in
        {2089}let ck_106: key = (if v_689 then 2-proj-3-tuple(v_688) else caught-fail) in
        {2090}let cs_90: cipherstate = (if v_689 then 1-proj-3-tuple(v_688) else caught-fail) in
        {2091}let v_690: bitstring = (if v_689 then catch-fail(cipherstateunpack(cs_90)) else caught-fail) in
        {2092}let v_691: bool = (not-caught-fail(v_690) && success?(1-proj-2-tuple(v_690))) in
        {2093}let n_46: nonce = (if v_691 then 2-proj-2-tuple(v_690) else caught-fail) in
        {2094}let k_50: key = (if v_691 then 1-proj-2-tuple(v_690) else caught-fail) in
        {2095}let d_11: aead = (if v_691 then catch-fail(decrypt(k_50,n_46,h_90,ciphertext_41)) else caught-fail) in
        {2096}let v_692: bool = not-caught-fail(d_11) in
        {2097}let v_693: bitstring = (if v_692 then catch-fail(aeadunpack(d_11)) else caught-fail) in
        {2098}let v_694: bool = (not-caught-fail(v_693) && success?(1-proj-3-tuple(v_693))) in
        {2099}let plaintext_33: bitstring = (if v_694 then 3-proj-3-tuple(v_693) else caught-fail) in
        {2100}let adi_11: bitstring = (if v_694 then 2-proj-3-tuple(v_693) else caught-fail) in
        {2101}let valid_31: bool = (if v_694 then 1-proj-3-tuple(v_693) else caught-fail) in
        {2103}let v_695: bitstring = (if v_694 then catch-fail(cipherstateunpack(cs_90)) else caught-fail) in
        {2104}let v_696: bool = (not-caught-fail(v_695) && success?(1-proj-2-tuple(v_695))) in
        {2105}let o_23: nonce = (if v_696 then 2-proj-2-tuple(v_695) else caught-fail) in
        {2106}let k_51: key = (if v_696 then 1-proj-2-tuple(v_695) else caught-fail) in
        {2102}let n_47: nonce = (if v_694 then increment_nonce(n_46) else caught-fail) in
        {2107}let csi_46: cipherstate = (if v_694 then catch-fail((if v_696 then cipherstatepack(k_51,n_47) else fail-any)) else caught-fail) in
        {2108}let v_697: bool = not-caught-fail(csi_46) in
        {2109}let v_698: bitstring = (if v_689 then catch-fail((if v_691 then (if v_692 then (if v_694 then (if v_697 then (csi_46,plaintext_33,valid_31) else fail-any) else fail-any) else fail-any) else fail-any)) else caught-fail) in
        {2110}let v_699: bool = (not-caught-fail(v_698) && success?(1-proj-3-tuple(v_698))) in
        {2111}let valid_32: bool = (if v_699 then 3-proj-3-tuple(v_698) else caught-fail) in
        {2112}let plaintext_34: bitstring = (if v_699 then 2-proj-3-tuple(v_698) else caught-fail) in
        {2113}let csi_47: cipherstate = (if v_699 then 1-proj-3-tuple(v_698) else caught-fail) in
        {2114}let ss_106: symmetricstate = (if v_699 then symmetricstatepack(csi_47,ck_106,h_90) else caught-fail) in
        {2115}let v_700: bitstring = (if v_699 then catch-fail(symmetricstateunpack(ss_106)) else caught-fail) in
        {2116}let v_701: bool = (not-caught-fail(v_700) && success?(1-proj-3-tuple(v_700))) in
        {2117}let h_91: bitstring = (if v_701 then 3-proj-3-tuple(v_700) else caught-fail) in
        {2118}let ck_107: key = (if v_701 then 2-proj-3-tuple(v_700) else caught-fail) in
        {2119}let cs_91: cipherstate = (if v_701 then 1-proj-3-tuple(v_700) else caught-fail) in
        {2120}let ssi_27: symmetricstate = (if v_699 then catch-fail((if v_701 then symmetricstatepack(cs_91,ck_107,hash(h_91,ciphertext_41)) else fail-any)) else caught-fail) in
        {2121}let v_702: bool = not-caught-fail(ssi_27) in
        {2122}let v_703: bitstring = (if v_687 then catch-fail((if v_689 then (if v_699 then (if v_702 then (ssi_27,plaintext_34,valid_32) else fail-any) else fail-any) else fail-any)) else caught-fail) in
        {2123}let v_704: bool = (not-caught-fail(v_703) && success?(1-proj-3-tuple(v_703))) in
        {2124}let valid2_9: bool = (if v_704 then 3-proj-3-tuple(v_703) else caught-fail) in
        {2125}let plaintext_35: bitstring = (if v_704 then 2-proj-3-tuple(v_703) else caught-fail) in
        {2126}let ss_107: symmetricstate = (if v_704 then 1-proj-3-tuple(v_703) else caught-fail) in
        {2085}let valid1_11: bool = (if v_687 then true else caught-fail) in
        {2127}let v_705: bool = (if v_704 then catch-fail((valid1_11 && valid2_9)) else caught-fail) in
        {2128}let hs_70: handshakestate = (if v_705 then handshakestatepack(ss_107,s_23,m_25,e_39,rs_23,rm_25,re_27,psk_23,initiator_20) else caught-fail) in
        {2129}let (hs_71: handshakestate,plaintext_e_1: bitstring,valid_33: bool) = (if v_685 then (if v_687 then (if v_704 then (if undo-catch-fail(v_705) then (hs_70,plaintext_35,true) else fail-any) else fail-any) else fail-any) else fail-any) in
        {2130}event RecvMsg(me_3,them_3,stagepack_e(sid_4),plaintext_e_1);
        {2131}event RecvEnd(valid_33)
    ) | (
        {2133}event LeakS(phase0,me_3);
        {2134}event LeakM(phase0,me_3);
        {2135}out(pub, (key_s(me_3),key_m(me_3)))
    ) | (
        {2136}phase 1;
        {2137}event LeakS(phase1,me_3);
        {2138}event LeakM(phase1,me_3);
        {2139}out(pub, (key_s(me_3),key_m(me_3)))
    )
)

-- Query event(RecvMsg(bob,alice,stagepack_a(sid_b),m_26)) ==> event(SendMsg(alice,bob,stagepack_a(sid_a),m_26)); event(RecvMsg(bob,alice,stagepack_a(sid_b),m_26)) ==> event(SendMsg(alice,c,stagepack_a(sid_a),m_26)) || (event(LeakS(phase0,alice)) && event(LeakM(phase0,alice))) || (event(LeakS(phase0,bob)) && event(LeakM(phase0,bob))); event(RecvMsg(bob,alice,stagepack_a(sid_b),m_26)) ==> event(SendMsg(alice,c,stagepack_a(sid_a),m_26)) || (event(LeakS(phase0,alice)) && event(LeakM(phase0,alice))); event(RecvMsg(bob,alice,stagepack_a(sid_b),m_26)) ==> event(SendMsg(alice,bob,stagepack_a(sid_a),m_26)) || (event(LeakS(phase0,alice)) && event(LeakM(phase0,alice))) || (event(LeakS(phase0,bob)) && event(LeakM(phase0,bob))); event(RecvMsg(bob,alice,stagepack_a(sid_b),m_26)) ==> event(SendMsg(alice,bob,stagepack_a(sid_a),m_26)) || (event(LeakS(phase0,alice)) && event(LeakM(phase0,alice))); not attacker_p1(msg_a(alice,bob,sid_a)); attacker_p1(msg_a(alice,bob,sid_a)) ==> event(LeakS(px,bob)) && event(LeakM(px,bob)); attacker_p1(msg_a(alice,bob,sid_a)) ==> (event(LeakS(phase0,bob)) && event(LeakM(phase0,bob))) || (event(LeakS(px,bob)) && event(LeakM(px,bob)) && event(LeakS(pz,alice)) && event(LeakM(pz,alice))); attacker_p1(msg_a(alice,bob,sid_a)) ==> event(LeakS(phase0,bob)) && event(LeakM(phase0,bob)); event(RecvMsg(alice,bob,stagepack_b(sid_a),m_26)) ==> event(SendMsg(bob,alice,stagepack_b(sid_b),m_26)); event(RecvMsg(alice,bob,stagepack_b(sid_a),m_26)) ==> event(SendMsg(bob,c,stagepack_b(sid_b),m_26)) || (event(LeakS(phase0,bob)) && event(LeakM(phase0,bob))) || (event(LeakS(phase0,alice)) && event(LeakM(phase0,alice))); event(RecvMsg(alice,bob,stagepack_b(sid_a),m_26)) ==> event(SendMsg(bob,c,stagepack_b(sid_b),m_26)) || (event(LeakS(phase0,bob)) && event(LeakM(phase0,bob))); event(RecvMsg(alice,bob,stagepack_b(sid_a),m_26)) ==> event(SendMsg(bob,alice,stagepack_b(sid_b),m_26)) || (event(LeakS(phase0,bob)) && event(LeakM(phase0,bob))) || (event(LeakS(phase0,alice)) && event(LeakM(phase0,alice))); event(RecvMsg(alice,bob,stagepack_b(sid_a),m_26)) ==> event(SendMsg(bob,alice,stagepack_b(sid_b),m_26)) || (event(LeakS(phase0,bob)) && event(LeakM(phase0,bob))); not attacker_p1(msg_b(bob,alice,sid_b)); attacker_p1(msg_b(bob,alice,sid_b)) ==> event(LeakS(px,alice)) && event(LeakM(px,alice)); attacker_p1(msg_b(bob,alice,sid_b)) ==> (event(LeakS(phase0,alice)) && event(LeakM(phase0,alice))) || (event(LeakS(px,alice)) && event(LeakM(px,alice)) && event(LeakS(pz,bob)) && event(LeakM(pz,bob))); attacker_p1(msg_b(bob,alice,sid_b)) ==> event(LeakS(phase0,alice)) && event(LeakM(phase0,alice)); event(RecvMsg(bob,alice,stagepack_c(sid_b),m_26)) ==> event(SendMsg(alice,bob,stagepack_c(sid_a),m_26)); event(RecvMsg(bob,alice,stagepack_c(sid_b),m_26)) ==> event(SendMsg(alice,c,stagepack_c(sid_a),m_26)) || (event(LeakS(phase0,alice)) && event(LeakM(phase0,alice))) || (event(LeakS(phase0,bob)) && event(LeakM(phase0,bob))); event(RecvMsg(bob,alice,stagepack_c(sid_b),m_26)) ==> event(SendMsg(alice,c,stagepack_c(sid_a),m_26)) || (event(LeakS(phase0,alice)) && event(LeakM(phase0,alice))); event(RecvMsg(bob,alice,stagepack_c(sid_b),m_26)) ==> event(SendMsg(alice,bob,stagepack_c(sid_a),m_26)) || (event(LeakS(phase0,alice)) && event(LeakM(phase0,alice))) || (event(LeakS(phase0,bob)) && event(LeakM(phase0,bob))); event(RecvMsg(bob,alice,stagepack_c(sid_b),m_26)) ==> event(SendMsg(alice,bob,stagepack_c(sid_a),m_26)) || (event(LeakS(phase0,alice)) && event(LeakM(phase0,alice))); not attacker_p1(msg_c(alice,bob,sid_a)); attacker_p1(msg_c(alice,bob,sid_a)) ==> event(LeakS(px,bob)) && event(LeakM(px,bob)); attacker_p1(msg_c(alice,bob,sid_a)) ==> (event(LeakS(phase0,bob)) && event(LeakM(phase0,bob))) || (event(LeakS(px,bob)) && event(LeakM(px,bob)) && event(LeakS(pz,alice)) && event(LeakM(pz,alice))); attacker_p1(msg_c(alice,bob,sid_a)) ==> event(LeakS(phase0,bob)) && event(LeakM(phase0,bob)); event(RecvMsg(alice,bob,stagepack_d(sid_a),m_26)) ==> event(SendMsg(bob,alice,stagepack_d(sid_b),m_26)); event(RecvMsg(alice,bob,stagepack_d(sid_a),m_26)) ==> event(SendMsg(bob,c,stagepack_d(sid_b),m_26)) || (event(LeakS(phase0,bob)) && event(LeakM(phase0,bob))) || (event(LeakS(phase0,alice)) && event(LeakM(phase0,alice))); event(RecvMsg(alice,bob,stagepack_d(sid_a),m_26)) ==> event(SendMsg(bob,c,stagepack_d(sid_b),m_26)) || (event(LeakS(phase0,bob)) && event(LeakM(phase0,bob))); event(RecvMsg(alice,bob,stagepack_d(sid_a),m_26)) ==> event(SendMsg(bob,alice,stagepack_d(sid_b),m_26)) || (event(LeakS(phase0,bob)) && event(LeakM(phase0,bob))) || (event(LeakS(phase0,alice)) && event(LeakM(phase0,alice))); event(RecvMsg(alice,bob,stagepack_d(sid_a),m_26)) ==> event(SendMsg(bob,alice,stagepack_d(sid_b),m_26)) || (event(LeakS(phase0,bob)) && event(LeakM(phase0,bob))); not attacker_p1(msg_d(bob,alice,sid_b)); attacker_p1(msg_d(bob,alice,sid_b)) ==> event(LeakS(px,alice)) && event(LeakM(px,alice)); attacker_p1(msg_d(bob,alice,sid_b)) ==> (event(LeakS(phase0,alice)) && event(LeakM(phase0,alice))) || (event(LeakS(px,alice)) && event(LeakM(px,alice)) && event(LeakS(pz,bob)) && event(LeakM(pz,bob))); attacker_p1(msg_d(bob,alice,sid_b)) ==> event(LeakS(phase0,alice)) && event(LeakM(phase0,alice)); event(RecvMsg(bob,alice,stagepack_e(sid_b),m_26)) ==> event(SendMsg(alice,bob,stagepack_e(sid_a),m_26)); event(RecvMsg(bob,alice,stagepack_e(sid_b),m_26)) ==> event(SendMsg(alice,c,stagepack_e(sid_a),m_26)) || (event(LeakS(phase0,alice)) && event(LeakM(phase0,alice))) || (event(LeakS(phase0,bob)) && event(LeakM(phase0,bob))); event(RecvMsg(bob,alice,stagepack_e(sid_b),m_26)) ==> event(SendMsg(alice,c,stagepack_e(sid_a),m_26)) || (event(LeakS(phase0,alice)) && event(LeakM(phase0,alice))); event(RecvMsg(bob,alice,stagepack_e(sid_b),m_26)) ==> event(SendMsg(alice,bob,stagepack_e(sid_a),m_26)) || (event(LeakS(phase0,alice)) && event(LeakM(phase0,alice))) || (event(LeakS(phase0,bob)) && event(LeakM(phase0,bob))); event(RecvMsg(bob,alice,stagepack_e(sid_b),m_26)) ==> event(SendMsg(alice,bob,stagepack_e(sid_a),m_26)) || (event(LeakS(phase0,alice)) && event(LeakM(phase0,alice))); not attacker_p1(msg_e(alice,bob,sid_a)); attacker_p1(msg_e(alice,bob,sid_a)) ==> event(LeakS(px,bob)) && event(LeakM(px,bob)); attacker_p1(msg_e(alice,bob,sid_a)) ==> event(LeakS(phase0,bob)) || (event(LeakS(px,bob)) && event(LeakM(px,bob)) && event(LeakS(pz,alice)) && event(LeakM(pz,alice))); attacker_p1(msg_e(alice,bob,sid_a)) ==> event(LeakS(phase0,bob)) && event(LeakM(phase0,bob)); not event(RecvEnd(true)) in process 1.
Translating the process into Horn clauses...
Completing...
200 rules inserted. Base: 200 rules (89 with conclusion selected). Queue: 159 rules.
400 rules inserted. Base: 398 rules (143 with conclusion selected). Queue: 70 rules.
600 rules inserted. Base: 595 rules (238 with conclusion selected). Queue: 112 rules.
800 rules inserted. Base: 795 rules (296 with conclusion selected). Queue: 209 rules.
1000 rules inserted. Base: 994 rules (373 with conclusion selected). Queue: 354 rules.
1200 rules inserted. Base: 1184 rules (425 with conclusion selected). Queue: 296 rules.
1400 rules inserted. Base: 1357 rules (446 with conclusion selected). Queue: 305 rules.
1600 rules inserted. Base: 1497 rules (446 with conclusion selected). Queue: 371 rules.
1800 rules inserted. Base: 1640 rules (446 with conclusion selected). Queue: 435 rules.
2000 rules inserted. Base: 1788 rules (446 with conclusion selected). Queue: 497 rules.
2200 rules inserted. Base: 1863 rules (446 with conclusion selected). Queue: 489 rules.
2400 rules inserted. Base: 1946 rules (446 with conclusion selected). Queue: 508 rules.
2600 rules inserted. Base: 2046 rules (446 with conclusion selected). Queue: 501 rules.
2800 rules inserted. Base: 2174 rules (446 with conclusion selected). Queue: 546 rules.
3000 rules inserted. Base: 2254 rules (446 with conclusion selected). Queue: 529 rules.
3200 rules inserted. Base: 2362 rules (446 with conclusion selected). Queue: 540 rules.
3400 rules inserted. Base: 2467 rules (446 with conclusion selected). Queue: 535 rules.
3600 rules inserted. Base: 2563 rules (446 with conclusion selected). Queue: 581 rules.
3800 rules inserted. Base: 2675 rules (446 with conclusion selected). Queue: 644 rules.
4000 rules inserted. Base: 2779 rules (446 with conclusion selected). Queue: 688 rules.
4200 rules inserted. Base: 2890 rules (447 with conclusion selected). Queue: 757 rules.
4400 rules inserted. Base: 2992 rules (447 with conclusion selected). Queue: 827 rules.
4600 rules inserted. Base: 3081 rules (447 with conclusion selected). Queue: 873 rules.
4800 rules inserted. Base: 3192 rules (448 with conclusion selected). Queue: 928 rules.
5000 rules inserted. Base: 3302 rules (448 with conclusion selected). Queue: 988 rules.
5200 rules inserted. Base: 3406 rules (448 with conclusion selected). Queue: 1056 rules.
5400 rules inserted. Base: 3515 rules (448 with conclusion selected). Queue: 1118 rules.
5600 rules inserted. Base: 3576 rules (448 with conclusion selected). Queue: 1150 rules.
5800 rules inserted. Base: 3697 rules (448 with conclusion selected). Queue: 1202 rules.
6000 rules inserted. Base: 3801 rules (448 with conclusion selected). Queue: 1254 rules.
6200 rules inserted. Base: 3922 rules (448 with conclusion selected). Queue: 1315 rules.
6400 rules inserted. Base: 4027 rules (448 with conclusion selected). Queue: 1368 rules.
6600 rules inserted. Base: 4100 rules (449 with conclusion selected). Queue: 1413 rules.
6800 rules inserted. Base: 4189 rules (449 with conclusion selected). Queue: 1438 rules.
7000 rules inserted. Base: 4271 rules (449 with conclusion selected). Queue: 1469 rules.
7200 rules inserted. Base: 4346 rules (449 with conclusion selected). Queue: 1520 rules.
7400 rules inserted. Base: 4419 rules (449 with conclusion selected). Queue: 1550 rules.
7600 rules inserted. Base: 4485 rules (449 with conclusion selected). Queue: 1592 rules.
7800 rules inserted. Base: 4587 rules (449 with conclusion selected). Queue: 1603 rules.
8000 rules inserted. Base: 4376 rules (449 with conclusion selected). Queue: 1613 rules.
8200 rules inserted. Base: 4437 rules (449 with conclusion selected). Queue: 1623 rules.
8400 rules inserted. Base: 4496 rules (449 with conclusion selected). Queue: 1633 rules.
8600 rules inserted. Base: 4576 rules (449 with conclusion selected). Queue: 1655 rules.
8800 rules inserted. Base: 4656 rules (449 with conclusion selected). Queue: 1663 rules.
9000 rules inserted. Base: 4729 rules (449 with conclusion selected). Queue: 1683 rules.
9200 rules inserted. Base: 4796 rules (449 with conclusion selected). Queue: 1706 rules.
9400 rules inserted. Base: 4862 rules (449 with conclusion selected). Queue: 1728 rules.
9600 rules inserted. Base: 4917 rules (449 with conclusion selected). Queue: 1728 rules.
9800 rules inserted. Base: 4975 rules (449 with conclusion selected). Queue: 1736 rules.
10000 rules inserted. Base: 5024 rules (449 with conclusion selected). Queue: 1715 rules.
10200 rules inserted. Base: 5096 rules (449 with conclusion selected). Queue: 1699 rules.
10400 rules inserted. Base: 5166 rules (449 with conclusion selected). Queue: 1684 rules.
10600 rules inserted. Base: 5224 rules (449 with conclusion selected). Queue: 1681 rules.
10800 rules inserted. Base: 5285 rules (449 with conclusion selected). Queue: 1680 rules.
11000 rules inserted. Base: 5344 rules (449 with conclusion selected). Queue: 1679 rules.
11200 rules inserted. Base: 5410 rules (449 with conclusion selected). Queue: 1681 rules.
11400 rules inserted. Base: 5439 rules (449 with conclusion selected). Queue: 1668 rules.
11600 rules inserted. Base: 5464 rules (449 with conclusion selected). Queue: 1645 rules.
11800 rules inserted. Base: 5546 rules (449 with conclusion selected). Queue: 1616 rules.
12000 rules inserted. Base: 5627 rules (449 with conclusion selected). Queue: 1587 rules.
12200 rules inserted. Base: 5711 rules (449 with conclusion selected). Queue: 1566 rules.
12400 rules inserted. Base: 5786 rules (449 with conclusion selected). Queue: 1536 rules.
12600 rules inserted. Base: 5866 rules (449 with conclusion selected). Queue: 1501 rules.
12800 rules inserted. Base: 5949 rules (449 with conclusion selected). Queue: 1478 rules.
13000 rules inserted. Base: 5956 rules (449 with conclusion selected). Queue: 1485 rules.
13200 rules inserted. Base: 5964 rules (449 with conclusion selected). Queue: 1499 rules.
13400 rules inserted. Base: 6065 rules (449 with conclusion selected). Queue: 1509 rules.
13600 rules inserted. Base: 6168 rules (449 with conclusion selected). Queue: 1527 rules.
13800 rules inserted. Base: 6258 rules (449 with conclusion selected). Queue: 1565 rules.
14000 rules inserted. Base: 6364 rules (449 with conclusion selected). Queue: 1582 rules.
14200 rules inserted. Base: 6465 rules (449 with conclusion selected). Queue: 1592 rules.
14400 rules inserted. Base: 6557 rules (449 with conclusion selected). Queue: 1582 rules.
14600 rules inserted. Base: 6616 rules (449 with conclusion selected). Queue: 1545 rules.
14800 rules inserted. Base: 6665 rules (449 with conclusion selected). Queue: 1511 rules.
15000 rules inserted. Base: 6772 rules (449 with conclusion selected). Queue: 1514 rules.
15200 rules inserted. Base: 6887 rules (449 with conclusion selected). Queue: 1505 rules.
15400 rules inserted. Base: 7003 rules (449 with conclusion selected). Queue: 1488 rules.
15600 rules inserted. Base: 7118 rules (449 with conclusion selected). Queue: 1475 rules.
15800 rules inserted. Base: 7238 rules (449 with conclusion selected). Queue: 1455 rules.
16000 rules inserted. Base: 7330 rules (449 with conclusion selected). Queue: 1439 rules.
16200 rules inserted. Base: 7424 rules (449 with conclusion selected). Queue: 1411 rules.
16400 rules inserted. Base: 7554 rules (449 with conclusion selected). Queue: 1425 rules.
16600 rules inserted. Base: 7672 rules (449 with conclusion selected). Queue: 1433 rules.
16800 rules inserted. Base: 7803 rules (449 with conclusion selected). Queue: 1469 rules.
17000 rules inserted. Base: 7940 rules (449 with conclusion selected). Queue: 1466 rules.
17200 rules inserted. Base: 8042 rules (449 with conclusion selected). Queue: 1461 rules.
17400 rules inserted. Base: 8151 rules (449 with conclusion selected). Queue: 1457 rules.
17600 rules inserted. Base: 8240 rules (449 with conclusion selected). Queue: 1442 rules.
17800 rules inserted. Base: 8366 rules (449 with conclusion selected). Queue: 1437 rules.
18000 rules inserted. Base: 8497 rules (449 with conclusion selected). Queue: 1450 rules.
18200 rules inserted. Base: 8633 rules (449 with conclusion selected). Queue: 1475 rules.
18400 rules inserted. Base: 8772 rules (449 with conclusion selected). Queue: 1467 rules.
18600 rules inserted. Base: 8868 rules (449 with conclusion selected). Queue: 1495 rules.
18800 rules inserted. Base: 8930 rules (449 with conclusion selected). Queue: 1520 rules.
19000 rules inserted. Base: 8966 rules (449 with conclusion selected). Queue: 1549 rules.
19200 rules inserted. Base: 9092 rules (449 with conclusion selected). Queue: 1553 rules.
19400 rules inserted. Base: 9211 rules (449 with conclusion selected). Queue: 1606 rules.
19600 rules inserted. Base: 9323 rules (449 with conclusion selected). Queue: 1659 rules.
19800 rules inserted. Base: 9445 rules (449 with conclusion selected). Queue: 1668 rules.
20000 rules inserted. Base: 9548 rules (449 with conclusion selected). Queue: 1699 rules.
20200 rules inserted. Base: 9558 rules (449 with conclusion selected). Queue: 1741 rules.
20400 rules inserted. Base: 9572 rules (449 with conclusion selected). Queue: 1751 rules.
20600 rules inserted. Base: 9685 rules (449 with conclusion selected). Queue: 1782 rules.
20800 rules inserted. Base: 9790 rules (449 with conclusion selected). Queue: 1825 rules.
21000 rules inserted. Base: 9913 rules (449 with conclusion selected). Queue: 1859 rules.
21200 rules inserted. Base: 10046 rules (449 with conclusion selected). Queue: 1901 rules.
21400 rules inserted. Base: 10153 rules (449 with conclusion selected). Queue: 1946 rules.
21600 rules inserted. Base: 10265 rules (449 with conclusion selected). Queue: 1970 rules.
21800 rules inserted. Base: 10327 rules (449 with conclusion selected). Queue: 1933 rules.
22000 rules inserted. Base: 10379 rules (449 with conclusion selected). Queue: 1852 rules.
22200 rules inserted. Base: 10521 rules (449 with conclusion selected). Queue: 1868 rules.
22400 rules inserted. Base: 10668 rules (449 with conclusion selected). Queue: 1870 rules.
22600 rules inserted. Base: 10810 rules (449 with conclusion selected). Queue: 1876 rules.
22800 rules inserted. Base: 10966 rules (449 with conclusion selected). Queue: 1841 rules.
23000 rules inserted. Base: 11120 rules (449 with conclusion selected). Queue: 1787 rules.
23200 rules inserted. Base: 11276 rules (449 with conclusion selected). Queue: 1731 rules.
23400 rules inserted. Base: 11416 rules (449 with conclusion selected). Queue: 1661 rules.
23600 rules inserted. Base: 11482 rules (449 with conclusion selected). Queue: 1591 rules.
23800 rules inserted. Base: 11568 rules (449 with conclusion selected). Queue: 1497 rules.
24000 rules inserted. Base: 11618 rules (449 with conclusion selected). Queue: 1411 rules.
24200 rules inserted. Base: 11760 rules (449 with conclusion selected). Queue: 1347 rules.
24400 rules inserted. Base: 11932 rules (449 with conclusion selected). Queue: 1289 rules.
24600 rules inserted. Base: 12116 rules (449 with conclusion selected). Queue: 1168 rules.
24800 rules inserted. Base: 12290 rules (449 with conclusion selected). Queue: 1074 rules.
25000 rules inserted. Base: 12323 rules (449 with conclusion selected). Queue: 982 rules.
25200 rules inserted. Base: 12390 rules (449 with conclusion selected). Queue: 935 rules.
25400 rules inserted. Base: 12420 rules (449 with conclusion selected). Queue: 807 rules.
25600 rules inserted. Base: 12616 rules (449 with conclusion selected). Queue: 671 rules.
25800 rules inserted. Base: 12702 rules (449 with conclusion selected). Queue: 723 rules.
26000 rules inserted. Base: 12780 rules (449 with conclusion selected). Queue: 690 rules.
26200 rules inserted. Base: 12868 rules (449 with conclusion selected). Queue: 613 rules.
26400 rules inserted. Base: 12956 rules (449 with conclusion selected). Queue: 610 rules.
26600 rules inserted. Base: 12985 rules (449 with conclusion selected). Queue: 397 rules.
26800 rules inserted. Base: 12998 rules (449 with conclusion selected). Queue: 173 rules.
Starting query event(RecvMsg(bob,alice,stagepack_a(sid_b),m_26)) ==> event(SendMsg(alice,bob,stagepack_a(sid_a),m_26))
goal reachable: begin(SendMsg(alice,bob,stagepack_a(sid_5),msg_a(alice,bob,sid_5))) -> end(RecvMsg(bob,alice,stagepack_a(sid_6),msg_a(alice,bob,sid_5)))
Abbreviations:
sid_6 = sid[!1 = @sid]
sid_5 = sid[!1 = @sid_1]
RESULT event(RecvMsg(bob,alice,stagepack_a(sid_b),m_26)) ==> event(SendMsg(alice,bob,stagepack_a(sid_a),m_26)) is true.
Starting query event(RecvMsg(bob,alice,stagepack_a(sid_b),m_26)) ==> event(SendMsg(alice,c,stagepack_a(sid_a),m_26)) || (event(LeakS(phase0,alice)) && event(LeakM(phase0,alice))) || (event(LeakS(phase0,bob)) && event(LeakM(phase0,bob)))
goal reachable: begin(SendMsg(alice,bob,stagepack_a(sid_5),msg_a(alice,bob,sid_5))) -> end(RecvMsg(bob,alice,stagepack_a(sid_6),msg_a(alice,bob,sid_5)))
Abbreviations:
sid_6 = sid[!1 = @sid]
sid_5 = sid[!1 = @sid_1]
RESULT event(RecvMsg(bob,alice,stagepack_a(sid_b),m_26)) ==> event(SendMsg(alice,c,stagepack_a(sid_a),m_26)) || (event(LeakS(phase0,alice)) && event(LeakM(phase0,alice))) || (event(LeakS(phase0,bob)) && event(LeakM(phase0,bob))) is true.
Starting query event(RecvMsg(bob,alice,stagepack_a(sid_b),m_26)) ==> event(SendMsg(alice,c,stagepack_a(sid_a),m_26)) || (event(LeakS(phase0,alice)) && event(LeakM(phase0,alice)))
goal reachable: begin(SendMsg(alice,bob,stagepack_a(sid_5),msg_a(alice,bob,sid_5))) -> end(RecvMsg(bob,alice,stagepack_a(sid_6),msg_a(alice,bob,sid_5)))
Abbreviations:
sid_6 = sid[!1 = @sid]
sid_5 = sid[!1 = @sid_1]
RESULT event(RecvMsg(bob,alice,stagepack_a(sid_b),m_26)) ==> event(SendMsg(alice,c,stagepack_a(sid_a),m_26)) || (event(LeakS(phase0,alice)) && event(LeakM(phase0,alice))) is true.
Starting query event(RecvMsg(bob,alice,stagepack_a(sid_b),m_26)) ==> event(SendMsg(alice,bob,stagepack_a(sid_a),m_26)) || (event(LeakS(phase0,alice)) && event(LeakM(phase0,alice))) || (event(LeakS(phase0,bob)) && event(LeakM(phase0,bob)))
goal reachable: begin(SendMsg(alice,bob,stagepack_a(sid_5),msg_a(alice,bob,sid_5))) -> end(RecvMsg(bob,alice,stagepack_a(sid_6),msg_a(alice,bob,sid_5)))
Abbreviations:
sid_6 = sid[!1 = @sid]
sid_5 = sid[!1 = @sid_1]
RESULT event(RecvMsg(bob,alice,stagepack_a(sid_b),m_26)) ==> event(SendMsg(alice,bob,stagepack_a(sid_a),m_26)) || (event(LeakS(phase0,alice)) && event(LeakM(phase0,alice))) || (event(LeakS(phase0,bob)) && event(LeakM(phase0,bob))) is true.
Starting query event(RecvMsg(bob,alice,stagepack_a(sid_b),m_26)) ==> event(SendMsg(alice,bob,stagepack_a(sid_a),m_26)) || (event(LeakS(phase0,alice)) && event(LeakM(phase0,alice)))
goal reachable: begin(SendMsg(alice,bob,stagepack_a(sid_5),msg_a(alice,bob,sid_5))) -> end(RecvMsg(bob,alice,stagepack_a(sid_6),msg_a(alice,bob,sid_5)))
Abbreviations:
sid_6 = sid[!1 = @sid]
sid_5 = sid[!1 = @sid_1]
RESULT event(RecvMsg(bob,alice,stagepack_a(sid_b),m_26)) ==> event(SendMsg(alice,bob,stagepack_a(sid_a),m_26)) || (event(LeakS(phase0,alice)) && event(LeakM(phase0,alice))) is true.
Starting query not attacker_p1(msg_a(alice,bob,sid_a))
goal reachable: begin(LeakM(phase1,bob)) && begin(LeakS(phase1,bob)) && begin(SendMsg(alice,bob,stagepack_a(sid_5),msg_a(alice,bob,sid_5))) -> attacker_p1(msg_a(alice,bob,sid_5))
Abbreviations:
sid_5 = sid[!1 = @sid]

Derivation:
Abbreviations:
sid_5 = sid[!1 = @sid]

1. Using the function pub the attacker may obtain pub.
attacker(pub).

2. The entry statestore(alice,bob,sid_5,statepack_a(handshakestatepack(symmetricstatepack(cipherstatepack(empty,minnonce),hash(somename,empty),hash(hash(hash(hash(somename,empty),empty),validkey(dhexp_real(key_s(bob),g))),validkey(dhexp_real(key_m(bob),g)))),keypairpack(empty,empty),keypairpack(empty,empty),keypairpack(empty,empty),validkey(dhexp_real(key_s(bob),g)),validkey(dhexp_real(key_m(bob),g)),empty,empty,true))) may be inserted in a table at insert {50}.
table(statestore(alice,bob,sid_5,statepack_a(handshakestatepack(symmetricstatepack(cipherstatepack(empty,minnonce),hash(somename,empty),hash(hash(hash(hash(somename,empty),empty),validkey(dhexp_real(key_s(bob),g))),validkey(dhexp_real(key_m(bob),g)))),keypairpack(empty,empty),keypairpack(empty,empty),keypairpack(empty,empty),validkey(dhexp_real(key_s(bob),g)),validkey(dhexp_real(key_m(bob),g)),empty,empty,true)))).

3. The entry statestore(alice,bob,sid_5,statepack_a(handshakestatepack(symmetricstatepack(cipherstatepack(empty,minnonce),hash(somename,empty),hash(hash(hash(hash(somename,empty),empty),validkey(dhexp_real(key_s(bob),g))),validkey(dhexp_real(key_m(bob),g)))),keypairpack(empty,empty),keypairpack(empty,empty),keypairpack(empty,empty),validkey(dhexp_real(key_s(bob),g)),validkey(dhexp_real(key_m(bob),g)),empty,empty,true))) that may be in a table by 2 may be read at get {163}.
The event SendMsg(alice,bob,stagepack_a(sid_5),msg_a(alice,bob,sid_5)) may be executed at {160}.
So the message concat3(validkey(dhexp_real(key_e(alice,bob,sid_5),g)),empty,encrypt(hmac_hash2(hmac_hash1(hash(somename,empty),dhexp_real(key_e(alice,bob,sid_5),dhexp_real(key_s(bob),g))),dhexp_real(key_e(alice,bob,sid_5),dhexp_real(key_m(bob),g))),minnonce,hash(hash(hash(hash(hash(somename,empty),empty),validkey(dhexp_real(key_s(bob),g))),validkey(dhexp_real(key_m(bob),g))),validkey(dhexp_real(key_e(alice,bob,sid_5),g))),msg_a(alice,bob,sid_5))) may be sent on channel pub at output {162}.
mess(pub,concat3(validkey(dhexp_real(key_e(alice,bob,sid_5),g)),empty,encrypt(hmac_hash2(hmac_hash1(hash(somename,empty),dhexp_real(key_e(alice,bob,sid_5),dhexp_real(key_s(bob),g))),dhexp_real(key_e(alice,bob,sid_5),dhexp_real(key_m(bob),g))),minnonce,hash(hash(hash(hash(hash(somename,empty),empty),validkey(dhexp_real(key_s(bob),g))),validkey(dhexp_real(key_m(bob),g))),validkey(dhexp_real(key_e(alice,bob,sid_5),g))),msg_a(alice,bob,sid_5)))).

4. By 1, the attacker may have the channel pub.
By 3, the message concat3(validkey(dhexp_real(key_e(alice,bob,sid_5),g)),empty,encrypt(hmac_hash2(hmac_hash1(hash(somename,empty),dhexp_real(key_e(alice,bob,sid_5),dhexp_real(key_s(bob),g))),dhexp_real(key_e(alice,bob,sid_5),dhexp_real(key_m(bob),g))),minnonce,hash(hash(hash(hash(hash(somename,empty),empty),validkey(dhexp_real(key_s(bob),g))),validkey(dhexp_real(key_m(bob),g))),validkey(dhexp_real(key_e(alice,bob,sid_5),g))),msg_a(alice,bob,sid_5))) may be sent on this channel.
So the attacker may obtain the message concat3(validkey(dhexp_real(key_e(alice,bob,sid_5),g)),empty,encrypt(hmac_hash2(hmac_hash1(hash(somename,empty),dhexp_real(key_e(alice,bob,sid_5),dhexp_real(key_s(bob),g))),dhexp_real(key_e(alice,bob,sid_5),dhexp_real(key_m(bob),g))),minnonce,hash(hash(hash(hash(hash(somename,empty),empty),validkey(dhexp_real(key_s(bob),g))),validkey(dhexp_real(key_m(bob),g))),validkey(dhexp_real(key_e(alice,bob,sid_5),g))),msg_a(alice,bob,sid_5))) by listening on this channel.
attacker(concat3(validkey(dhexp_real(key_e(alice,bob,sid_5),g)),empty,encrypt(hmac_hash2(hmac_hash1(hash(somename,empty),dhexp_real(key_e(alice,bob,sid_5),dhexp_real(key_s(bob),g))),dhexp_real(key_e(alice,bob,sid_5),dhexp_real(key_m(bob),g))),minnonce,hash(hash(hash(hash(hash(somename,empty),empty),validkey(dhexp_real(key_s(bob),g))),validkey(dhexp_real(key_m(bob),g))),validkey(dhexp_real(key_e(alice,bob,sid_5),g))),msg_a(alice,bob,sid_5)))).

5. By 4, the attacker may know concat3(validkey(dhexp_real(key_e(alice,bob,sid_5),g)),empty,encrypt(hmac_hash2(hmac_hash1(hash(somename,empty),dhexp_real(key_e(alice,bob,sid_5),dhexp_real(key_s(bob),g))),dhexp_real(key_e(alice,bob,sid_5),dhexp_real(key_m(bob),g))),minnonce,hash(hash(hash(hash(hash(somename,empty),empty),validkey(dhexp_real(key_s(bob),g))),validkey(dhexp_real(key_m(bob),g))),validkey(dhexp_real(key_e(alice,bob,sid_5),g))),msg_a(alice,bob,sid_5))).
Using the function 3-proj-concat3 the attacker may obtain encrypt(hmac_hash2(hmac_hash1(hash(somename,empty),dhexp_real(key_e(alice,bob,sid_5),dhexp_real(key_s(bob),g))),dhexp_real(key_e(alice,bob,sid_5),dhexp_real(key_m(bob),g))),minnonce,hash(hash(hash(hash(hash(somename,empty),empty),validkey(dhexp_real(key_s(bob),g))),validkey(dhexp_real(key_m(bob),g))),validkey(dhexp_real(key_e(alice,bob,sid_5),g))),msg_a(alice,bob,sid_5)).
attacker(encrypt(hmac_hash2(hmac_hash1(hash(somename,empty),dhexp_real(key_e(alice,bob,sid_5),dhexp_real(key_s(bob),g))),dhexp_real(key_e(alice,bob,sid_5),dhexp_real(key_m(bob),g))),minnonce,hash(hash(hash(hash(hash(somename,empty),empty),validkey(dhexp_real(key_s(bob),g))),validkey(dhexp_real(key_m(bob),g))),validkey(dhexp_real(key_e(alice,bob,sid_5),g))),msg_a(alice,bob,sid_5))).

6. By 5, the attacker may know encrypt(hmac_hash2(hmac_hash1(hash(somename,empty),dhexp_real(key_e(alice,bob,sid_5),dhexp_real(key_s(bob),g))),dhexp_real(key_e(alice,bob,sid_5),dhexp_real(key_m(bob),g))),minnonce,hash(hash(hash(hash(hash(somename,empty),empty),validkey(dhexp_real(key_s(bob),g))),validkey(dhexp_real(key_m(bob),g))),validkey(dhexp_real(key_e(alice,bob,sid_5),g))),msg_a(alice,bob,sid_5)).
So the attacker may know encrypt(hmac_hash2(hmac_hash1(hash(somename,empty),dhexp_real(key_e(alice,bob,sid_5),dhexp_real(key_s(bob),g))),dhexp_real(key_e(alice,bob,sid_5),dhexp_real(key_m(bob),g))),minnonce,hash(hash(hash(hash(hash(somename,empty),empty),validkey(dhexp_real(key_s(bob),g))),validkey(dhexp_real(key_m(bob),g))),validkey(dhexp_real(key_e(alice,bob,sid_5),g))),msg_a(alice,bob,sid_5)) in phase 1.
attacker_p1(encrypt(hmac_hash2(hmac_hash1(hash(somename,empty),dhexp_real(key_e(alice,bob,sid_5),dhexp_real(key_s(bob),g))),dhexp_real(key_e(alice,bob,sid_5),dhexp_real(key_m(bob),g))),minnonce,hash(hash(hash(hash(hash(somename,empty),empty),validkey(dhexp_real(key_s(bob),g))),validkey(dhexp_real(key_m(bob),g))),validkey(dhexp_real(key_e(alice,bob,sid_5),g))),msg_a(alice,bob,sid_5))).

7. By 4, the attacker may know concat3(validkey(dhexp_real(key_e(alice,bob,sid_5),g)),empty,encrypt(hmac_hash2(hmac_hash1(hash(somename,empty),dhexp_real(key_e(alice,bob,sid_5),dhexp_real(key_s(bob),g))),dhexp_real(key_e(alice,bob,sid_5),dhexp_real(key_m(bob),g))),minnonce,hash(hash(hash(hash(hash(somename,empty),empty),validkey(dhexp_real(key_s(bob),g))),validkey(dhexp_real(key_m(bob),g))),validkey(dhexp_real(key_e(alice,bob,sid_5),g))),msg_a(alice,bob,sid_5))).
Using the function 1-proj-concat3 the attacker may obtain validkey(dhexp_real(key_e(alice,bob,sid_5),g)).
attacker(validkey(dhexp_real(key_e(alice,bob,sid_5),g))).

8. The message (validkey(dhexp_real(key_s(bob),g)),validkey(dhexp_real(key_m(bob),g))) may be sent on channel pub at output {1065}.
mess(pub,(validkey(dhexp_real(key_s(bob),g)),validkey(dhexp_real(key_m(bob),g)))).

9. By 1, the attacker may have the channel pub.
By 8, the message (validkey(dhexp_real(key_s(bob),g)),validkey(dhexp_real(key_m(bob),g))) may be sent on this channel.
So the attacker may obtain the message (validkey(dhexp_real(key_s(bob),g)),validkey(dhexp_real(key_m(bob),g))) by listening on this channel.
attacker((validkey(dhexp_real(key_s(bob),g)),validkey(dhexp_real(key_m(bob),g)))).

10. By 9, the attacker may know (validkey(dhexp_real(key_s(bob),g)),validkey(dhexp_real(key_m(bob),g))).
Using the function 2-proj-2-tuple the attacker may obtain validkey(dhexp_real(key_m(bob),g)).
attacker(validkey(dhexp_real(key_m(bob),g))).

11. By 9, the attacker may know (validkey(dhexp_real(key_s(bob),g)),validkey(dhexp_real(key_m(bob),g))).
Using the function 1-proj-2-tuple the attacker may obtain validkey(dhexp_real(key_s(bob),g)).
attacker(validkey(dhexp_real(key_s(bob),g))).

12. Using the function empty the attacker may obtain empty.
attacker(empty).

13. Using the function somename the attacker may obtain somename.
attacker(somename).

14. By 13, the attacker may know somename.
By 12, the attacker may know empty.
Using the function hash the attacker may obtain hash(somename,empty).
attacker(hash(somename,empty)).

15. By 14, the attacker may know hash(somename,empty).
By 12, the attacker may know empty.
Using the function hash the attacker may obtain hash(hash(somename,empty),empty).
attacker(hash(hash(somename,empty),empty)).

16. By 15, the attacker may know hash(hash(somename,empty),empty).
By 11, the attacker may know validkey(dhexp_real(key_s(bob),g)).
Using the function hash the attacker may obtain hash(hash(hash(somename,empty),empty),validkey(dhexp_real(key_s(bob),g))).
attacker(hash(hash(hash(somename,empty),empty),validkey(dhexp_real(key_s(bob),g)))).

17. By 16, the attacker may know hash(hash(hash(somename,empty),empty),validkey(dhexp_real(key_s(bob),g))).
By 10, the attacker may know validkey(dhexp_real(key_m(bob),g)).
Using the function hash the attacker may obtain hash(hash(hash(hash(somename,empty),empty),validkey(dhexp_real(key_s(bob),g))),validkey(dhexp_real(key_m(bob),g))).
attacker(hash(hash(hash(hash(somename,empty),empty),validkey(dhexp_real(key_s(bob),g))),validkey(dhexp_real(key_m(bob),g)))).

18. By 17, the attacker may know hash(hash(hash(hash(somename,empty),empty),validkey(dhexp_real(key_s(bob),g))),validkey(dhexp_real(key_m(bob),g))).
By 7, the attacker may know validkey(dhexp_real(key_e(alice,bob,sid_5),g)).
Using the function hash the attacker may obtain hash(hash(hash(hash(hash(somename,empty),empty),validkey(dhexp_real(key_s(bob),g))),validkey(dhexp_real(key_m(bob),g))),validkey(dhexp_real(key_e(alice,bob,sid_5),g))).
attacker(hash(hash(hash(hash(hash(somename,empty),empty),validkey(dhexp_real(key_s(bob),g))),validkey(dhexp_real(key_m(bob),g))),validkey(dhexp_real(key_e(alice,bob,sid_5),g)))).

19. By 18, the attacker may know hash(hash(hash(hash(hash(somename,empty),empty),validkey(dhexp_real(key_s(bob),g))),validkey(dhexp_real(key_m(bob),g))),validkey(dhexp_real(key_e(alice,bob,sid_5),g))).
So the attacker may know hash(hash(hash(hash(hash(somename,empty),empty),validkey(dhexp_real(key_s(bob),g))),validkey(dhexp_real(key_m(bob),g))),validkey(dhexp_real(key_e(alice,bob,sid_5),g))) in phase 1.
attacker_p1(hash(hash(hash(hash(hash(somename,empty),empty),validkey(dhexp_real(key_s(bob),g))),validkey(dhexp_real(key_m(bob),g))),validkey(dhexp_real(key_e(alice,bob,sid_5),g)))).

20. Using the function minnonce the attacker may obtain minnonce in phase 1.
attacker_p1(minnonce).

21. By 7, the attacker may know validkey(dhexp_real(key_e(alice,bob,sid_5),g)).
So the attacker may know validkey(dhexp_real(key_e(alice,bob,sid_5),g)) in phase 1.
attacker_p1(validkey(dhexp_real(key_e(alice,bob,sid_5),g))).

22. Using the function pub the attacker may obtain pub in phase 1.
attacker_p1(pub).

23. The event LeakS(phase1,bob) may be executed at {1594}.
The event LeakM(phase1,bob) may be executed at {1595}.
So the message (key_s(bob),key_m(bob)) may be sent on channel pub in phase 1 at output {1596}.
mess_p1(pub,(key_s(bob),key_m(bob))).

24. By 22, the attacker may have the channel pub in phase 1.
By 23, the message (key_s(bob),key_m(bob)) in phase 1 may be sent on this channel.
So the attacker may obtain the message (key_s(bob),key_m(bob)) in phase 1 by listening on this channel.
attacker_p1((key_s(bob),key_m(bob))).

25. By 24, the attacker may know (key_s(bob),key_m(bob)) in phase 1.
Using the function 2-proj-2-tuple the attacker may obtain key_m(bob) in phase 1.
attacker_p1(key_m(bob)).

26. By 25, the attacker may know key_m(bob) in phase 1.
By 21, the attacker may know validkey(dhexp_real(key_e(alice,bob,sid_5),g)) in phase 1.
Using the function dhexp the attacker may obtain dhexp_real(key_e(alice,bob,sid_5),dhexp_real(key_m(bob),g)) in phase 1.
attacker_p1(dhexp_real(key_e(alice,bob,sid_5),dhexp_real(key_m(bob),g))).

27. By 24, the attacker may know (key_s(bob),key_m(bob)) in phase 1.
Using the function 1-proj-2-tuple the attacker may obtain key_s(bob) in phase 1.
attacker_p1(key_s(bob)).

28. By 27, the attacker may know key_s(bob) in phase 1.
By 21, the attacker may know validkey(dhexp_real(key_e(alice,bob,sid_5),g)) in phase 1.
Using the function dhexp the attacker may obtain dhexp_real(key_e(alice,bob,sid_5),dhexp_real(key_s(bob),g)) in phase 1.
attacker_p1(dhexp_real(key_e(alice,bob,sid_5),dhexp_real(key_s(bob),g))).

29. Using the function empty the attacker may obtain empty in phase 1.
attacker_p1(empty).

30. Using the function somename the attacker may obtain somename in phase 1.
attacker_p1(somename).

31. By 30, the attacker may know somename in phase 1.
By 29, the attacker may know empty in phase 1.
Using the function hash the attacker may obtain hash(somename,empty) in phase 1.
attacker_p1(hash(somename,empty)).

32. By 31, the attacker may know hash(somename,empty) in phase 1.
By 28, the attacker may know dhexp_real(key_e(alice,bob,sid_5),dhexp_real(key_s(bob),g)) in phase 1.
Using the function hmac_hash1 the attacker may obtain hmac_hash1(hash(somename,empty),dhexp_real(key_e(alice,bob,sid_5),dhexp_real(key_s(bob),g))) in phase 1.
attacker_p1(hmac_hash1(hash(somename,empty),dhexp_real(key_e(alice,bob,sid_5),dhexp_real(key_s(bob),g)))).

33. By 32, the attacker may know hmac_hash1(hash(somename,empty),dhexp_real(key_e(alice,bob,sid_5),dhexp_real(key_s(bob),g))) in phase 1.
By 26, the attacker may know dhexp_real(key_e(alice,bob,sid_5),dhexp_real(key_m(bob),g)) in phase 1.
Using the function hmac_hash2 the attacker may obtain hmac_hash2(hmac_hash1(hash(somename,empty),dhexp_real(key_e(alice,bob,sid_5),dhexp_real(key_s(bob),g))),dhexp_real(key_e(alice,bob,sid_5),dhexp_real(key_m(bob),g))) in phase 1.
attacker_p1(hmac_hash2(hmac_hash1(hash(somename,empty),dhexp_real(key_e(alice,bob,sid_5),dhexp_real(key_s(bob),g))),dhexp_real(key_e(alice,bob,sid_5),dhexp_real(key_m(bob),g)))).

34. By 33, the attacker may know hmac_hash2(hmac_hash1(hash(somename,empty),dhexp_real(key_e(alice,bob,sid_5),dhexp_real(key_s(bob),g))),dhexp_real(key_e(alice,bob,sid_5),dhexp_real(key_m(bob),g))) in phase 1.
By 20, the attacker may know minnonce in phase 1.
By 19, the attacker may know hash(hash(hash(hash(hash(somename,empty),empty),validkey(dhexp_real(key_s(bob),g))),validkey(dhexp_real(key_m(bob),g))),validkey(dhexp_real(key_e(alice,bob,sid_5),g))) in phase 1.
By 6, the attacker may know encrypt(hmac_hash2(hmac_hash1(hash(somename,empty),dhexp_real(key_e(alice,bob,sid_5),dhexp_real(key_s(bob),g))),dhexp_real(key_e(alice,bob,sid_5),dhexp_real(key_m(bob),g))),minnonce,hash(hash(hash(hash(hash(somename,empty),empty),validkey(dhexp_real(key_s(bob),g))),validkey(dhexp_real(key_m(bob),g))),validkey(dhexp_real(key_e(alice,bob,sid_5),g))),msg_a(alice,bob,sid_5)) in phase 1.
Using the function decrypt the attacker may obtain aeadpack(true,hash(hash(hash(hash(hash(somename,empty),empty),validkey(dhexp_real(key_s(bob),g))),validkey(dhexp_real(key_m(bob),g))),validkey(dhexp_real(key_e(alice,bob,sid_5),g))),msg_a(alice,bob,sid_5)) in phase 1.
attacker_p1(aeadpack(true,hash(hash(hash(hash(hash(somename,empty),empty),validkey(dhexp_real(key_s(bob),g))),validkey(dhexp_real(key_m(bob),g))),validkey(dhexp_real(key_e(alice,bob,sid_5),g))),msg_a(alice,bob,sid_5))).

35. By 34, the attacker may know aeadpack(true,hash(hash(hash(hash(hash(somename,empty),empty),validkey(dhexp_real(key_s(bob),g))),validkey(dhexp_real(key_m(bob),g))),validkey(dhexp_real(key_e(alice,bob,sid_5),g))),msg_a(alice,bob,sid_5)) in phase 1.
Using the function 3-proj-aeadpack the attacker may obtain msg_a(alice,bob,sid_5) in phase 1.
attacker_p1(msg_a(alice,bob,sid_5)).

36. By 35, attacker_p1(msg_a(alice,bob,sid_5)).
The goal is reached, represented in the following fact:
attacker_p1(msg_a(alice,bob,sid_5)).


RESULT not attacker_p1(msg_a(alice,bob,sid_a)) cannot be proved.
Starting query attacker_p1(msg_a(alice,bob,sid_a)) ==> event(LeakS(px,bob)) && event(LeakM(px,bob))
goal reachable: begin(LeakM(phase1,bob)) && begin(LeakS(phase1,bob)) && begin(SendMsg(alice,bob,stagepack_a(sid_5),msg_a(alice,bob,sid_5))) -> attacker_p1(msg_a(alice,bob,sid_5))
Abbreviations:
sid_5 = sid[!1 = @sid]
goal reachable: begin(LeakM(phase0,bob)) && begin(LeakS(phase0,bob)) && begin(SendMsg(alice,bob,stagepack_a(sid_5),msg_a(alice,bob,sid_5))) -> attacker_p1(msg_a(alice,bob,sid_5))
Abbreviations:
sid_5 = sid[!1 = @sid]
RESULT attacker_p1(msg_a(alice,bob,sid_a)) ==> event(LeakS(px,bob)) && event(LeakM(px,bob)) is true.
Starting query attacker_p1(msg_a(alice,bob,sid_a)) ==> (event(LeakS(phase0,bob)) && event(LeakM(phase0,bob))) || (event(LeakS(px,bob)) && event(LeakM(px,bob)) && event(LeakS(pz,alice)) && event(LeakM(pz,alice)))
goal reachable: begin(LeakM(phase1,bob)) && begin(LeakS(phase1,bob)) && begin(SendMsg(alice,bob,stagepack_a(sid_5),msg_a(alice,bob,sid_5))) -> attacker_p1(msg_a(alice,bob,sid_5))
Abbreviations:
sid_5 = sid[!1 = @sid]

Derivation:
Abbreviations:
sid_5 = sid[!1 = @sid]

1. Using the function pub the attacker may obtain pub.
attacker(pub).

2. The entry statestore(alice,bob,sid_5,statepack_a(handshakestatepack(symmetricstatepack(cipherstatepack(empty,minnonce),hash(somename,empty),hash(hash(hash(hash(somename,empty),empty),validkey(dhexp_real(key_s(bob),g))),validkey(dhexp_real(key_m(bob),g)))),keypairpack(empty,empty),keypairpack(empty,empty),keypairpack(empty,empty),validkey(dhexp_real(key_s(bob),g)),validkey(dhexp_real(key_m(bob),g)),empty,empty,true))) may be inserted in a table at insert {50}.
table(statestore(alice,bob,sid_5,statepack_a(handshakestatepack(symmetricstatepack(cipherstatepack(empty,minnonce),hash(somename,empty),hash(hash(hash(hash(somename,empty),empty),validkey(dhexp_real(key_s(bob),g))),validkey(dhexp_real(key_m(bob),g)))),keypairpack(empty,empty),keypairpack(empty,empty),keypairpack(empty,empty),validkey(dhexp_real(key_s(bob),g)),validkey(dhexp_real(key_m(bob),g)),empty,empty,true)))).

3. The entry statestore(alice,bob,sid_5,statepack_a(handshakestatepack(symmetricstatepack(cipherstatepack(empty,minnonce),hash(somename,empty),hash(hash(hash(hash(somename,empty),empty),validkey(dhexp_real(key_s(bob),g))),validkey(dhexp_real(key_m(bob),g)))),keypairpack(empty,empty),keypairpack(empty,empty),keypairpack(empty,empty),validkey(dhexp_real(key_s(bob),g)),validkey(dhexp_real(key_m(bob),g)),empty,empty,true))) that may be in a table by 2 may be read at get {163}.
The event SendMsg(alice,bob,stagepack_a(sid_5),msg_a(alice,bob,sid_5)) may be executed at {160}.
So the message concat3(validkey(dhexp_real(key_e(alice,bob,sid_5),g)),empty,encrypt(hmac_hash2(hmac_hash1(hash(somename,empty),dhexp_real(key_e(alice,bob,sid_5),dhexp_real(key_s(bob),g))),dhexp_real(key_e(alice,bob,sid_5),dhexp_real(key_m(bob),g))),minnonce,hash(hash(hash(hash(hash(somename,empty),empty),validkey(dhexp_real(key_s(bob),g))),validkey(dhexp_real(key_m(bob),g))),validkey(dhexp_real(key_e(alice,bob,sid_5),g))),msg_a(alice,bob,sid_5))) may be sent on channel pub at output {162}.
mess(pub,concat3(validkey(dhexp_real(key_e(alice,bob,sid_5),g)),empty,encrypt(hmac_hash2(hmac_hash1(hash(somename,empty),dhexp_real(key_e(alice,bob,sid_5),dhexp_real(key_s(bob),g))),dhexp_real(key_e(alice,bob,sid_5),dhexp_real(key_m(bob),g))),minnonce,hash(hash(hash(hash(hash(somename,empty),empty),validkey(dhexp_real(key_s(bob),g))),validkey(dhexp_real(key_m(bob),g))),validkey(dhexp_real(key_e(alice,bob,sid_5),g))),msg_a(alice,bob,sid_5)))).

4. By 1, the attacker may have the channel pub.
By 3, the message concat3(validkey(dhexp_real(key_e(alice,bob,sid_5),g)),empty,encrypt(hmac_hash2(hmac_hash1(hash(somename,empty),dhexp_real(key_e(alice,bob,sid_5),dhexp_real(key_s(bob),g))),dhexp_real(key_e(alice,bob,sid_5),dhexp_real(key_m(bob),g))),minnonce,hash(hash(hash(hash(hash(somename,empty),empty),validkey(dhexp_real(key_s(bob),g))),validkey(dhexp_real(key_m(bob),g))),validkey(dhexp_real(key_e(alice,bob,sid_5),g))),msg_a(alice,bob,sid_5))) may be sent on this channel.
So the attacker may obtain the message concat3(validkey(dhexp_real(key_e(alice,bob,sid_5),g)),empty,encrypt(hmac_hash2(hmac_hash1(hash(somename,empty),dhexp_real(key_e(alice,bob,sid_5),dhexp_real(key_s(bob),g))),dhexp_real(key_e(alice,bob,sid_5),dhexp_real(key_m(bob),g))),minnonce,hash(hash(hash(hash(hash(somename,empty),empty),validkey(dhexp_real(key_s(bob),g))),validkey(dhexp_real(key_m(bob),g))),validkey(dhexp_real(key_e(alice,bob,sid_5),g))),msg_a(alice,bob,sid_5))) by listening on this channel.
attacker(concat3(validkey(dhexp_real(key_e(alice,bob,sid_5),g)),empty,encrypt(hmac_hash2(hmac_hash1(hash(somename,empty),dhexp_real(key_e(alice,bob,sid_5),dhexp_real(key_s(bob),g))),dhexp_real(key_e(alice,bob,sid_5),dhexp_real(key_m(bob),g))),minnonce,hash(hash(hash(hash(hash(somename,empty),empty),validkey(dhexp_real(key_s(bob),g))),validkey(dhexp_real(key_m(bob),g))),validkey(dhexp_real(key_e(alice,bob,sid_5),g))),msg_a(alice,bob,sid_5)))).

5. By 4, the attacker may know concat3(validkey(dhexp_real(key_e(alice,bob,sid_5),g)),empty,encrypt(hmac_hash2(hmac_hash1(hash(somename,empty),dhexp_real(key_e(alice,bob,sid_5),dhexp_real(key_s(bob),g))),dhexp_real(key_e(alice,bob,sid_5),dhexp_real(key_m(bob),g))),minnonce,hash(hash(hash(hash(hash(somename,empty),empty),validkey(dhexp_real(key_s(bob),g))),validkey(dhexp_real(key_m(bob),g))),validkey(dhexp_real(key_e(alice,bob,sid_5),g))),msg_a(alice,bob,sid_5))).
Using the function 3-proj-concat3 the attacker may obtain encrypt(hmac_hash2(hmac_hash1(hash(somename,empty),dhexp_real(key_e(alice,bob,sid_5),dhexp_real(key_s(bob),g))),dhexp_real(key_e(alice,bob,sid_5),dhexp_real(key_m(bob),g))),minnonce,hash(hash(hash(hash(hash(somename,empty),empty),validkey(dhexp_real(key_s(bob),g))),validkey(dhexp_real(key_m(bob),g))),validkey(dhexp_real(key_e(alice,bob,sid_5),g))),msg_a(alice,bob,sid_5)).
attacker(encrypt(hmac_hash2(hmac_hash1(hash(somename,empty),dhexp_real(key_e(alice,bob,sid_5),dhexp_real(key_s(bob),g))),dhexp_real(key_e(alice,bob,sid_5),dhexp_real(key_m(bob),g))),minnonce,hash(hash(hash(hash(hash(somename,empty),empty),validkey(dhexp_real(key_s(bob),g))),validkey(dhexp_real(key_m(bob),g))),validkey(dhexp_real(key_e(alice,bob,sid_5),g))),msg_a(alice,bob,sid_5))).

6. By 5, the attacker may know encrypt(hmac_hash2(hmac_hash1(hash(somename,empty),dhexp_real(key_e(alice,bob,sid_5),dhexp_real(key_s(bob),g))),dhexp_real(key_e(alice,bob,sid_5),dhexp_real(key_m(bob),g))),minnonce,hash(hash(hash(hash(hash(somename,empty),empty),validkey(dhexp_real(key_s(bob),g))),validkey(dhexp_real(key_m(bob),g))),validkey(dhexp_real(key_e(alice,bob,sid_5),g))),msg_a(alice,bob,sid_5)).
So the attacker may know encrypt(hmac_hash2(hmac_hash1(hash(somename,empty),dhexp_real(key_e(alice,bob,sid_5),dhexp_real(key_s(bob),g))),dhexp_real(key_e(alice,bob,sid_5),dhexp_real(key_m(bob),g))),minnonce,hash(hash(hash(hash(hash(somename,empty),empty),validkey(dhexp_real(key_s(bob),g))),validkey(dhexp_real(key_m(bob),g))),validkey(dhexp_real(key_e(alice,bob,sid_5),g))),msg_a(alice,bob,sid_5)) in phase 1.
attacker_p1(encrypt(hmac_hash2(hmac_hash1(hash(somename,empty),dhexp_real(key_e(alice,bob,sid_5),dhexp_real(key_s(bob),g))),dhexp_real(key_e(alice,bob,sid_5),dhexp_real(key_m(bob),g))),minnonce,hash(hash(hash(hash(hash(somename,empty),empty),validkey(dhexp_real(key_s(bob),g))),validkey(dhexp_real(key_m(bob),g))),validkey(dhexp_real(key_e(alice,bob,sid_5),g))),msg_a(alice,bob,sid_5))).

7. By 4, the attacker may know concat3(validkey(dhexp_real(key_e(alice,bob,sid_5),g)),empty,encrypt(hmac_hash2(hmac_hash1(hash(somename,empty),dhexp_real(key_e(alice,bob,sid_5),dhexp_real(key_s(bob),g))),dhexp_real(key_e(alice,bob,sid_5),dhexp_real(key_m(bob),g))),minnonce,hash(hash(hash(hash(hash(somename,empty),empty),validkey(dhexp_real(key_s(bob),g))),validkey(dhexp_real(key_m(bob),g))),validkey(dhexp_real(key_e(alice,bob,sid_5),g))),msg_a(alice,bob,sid_5))).
Using the function 1-proj-concat3 the attacker may obtain validkey(dhexp_real(key_e(alice,bob,sid_5),g)).
attacker(validkey(dhexp_real(key_e(alice,bob,sid_5),g))).

8. The message (validkey(dhexp_real(key_s(bob),g)),validkey(dhexp_real(key_m(bob),g))) may be sent on channel pub at output {1065}.
mess(pub,(validkey(dhexp_real(key_s(bob),g)),validkey(dhexp_real(key_m(bob),g)))).

9. By 1, the attacker may have the channel pub.
By 8, the message (validkey(dhexp_real(key_s(bob),g)),validkey(dhexp_real(key_m(bob),g))) may be sent on this channel.
So the attacker may obtain the message (validkey(dhexp_real(key_s(bob),g)),validkey(dhexp_real(key_m(bob),g))) by listening on this channel.
attacker((validkey(dhexp_real(key_s(bob),g)),validkey(dhexp_real(key_m(bob),g)))).

10. By 9, the attacker may know (validkey(dhexp_real(key_s(bob),g)),validkey(dhexp_real(key_m(bob),g))).
Using the function 2-proj-2-tuple the attacker may obtain validkey(dhexp_real(key_m(bob),g)).
attacker(validkey(dhexp_real(key_m(bob),g))).

11. By 9, the attacker may know (validkey(dhexp_real(key_s(bob),g)),validkey(dhexp_real(key_m(bob),g))).
Using the function 1-proj-2-tuple the attacker may obtain validkey(dhexp_real(key_s(bob),g)).
attacker(validkey(dhexp_real(key_s(bob),g))).

12. Using the function empty the attacker may obtain empty.
attacker(empty).

13. Using the function somename the attacker may obtain somename.
attacker(somename).

14. By 13, the attacker may know somename.
By 12, the attacker may know empty.
Using the function hash the attacker may obtain hash(somename,empty).
attacker(hash(somename,empty)).

15. By 14, the attacker may know hash(somename,empty).
By 12, the attacker may know empty.
Using the function hash the attacker may obtain hash(hash(somename,empty),empty).
attacker(hash(hash(somename,empty),empty)).

16. By 15, the attacker may know hash(hash(somename,empty),empty).
By 11, the attacker may know validkey(dhexp_real(key_s(bob),g)).
Using the function hash the attacker may obtain hash(hash(hash(somename,empty),empty),validkey(dhexp_real(key_s(bob),g))).
attacker(hash(hash(hash(somename,empty),empty),validkey(dhexp_real(key_s(bob),g)))).

17. By 16, the attacker may know hash(hash(hash(somename,empty),empty),validkey(dhexp_real(key_s(bob),g))).
By 10, the attacker may know validkey(dhexp_real(key_m(bob),g)).
Using the function hash the attacker may obtain hash(hash(hash(hash(somename,empty),empty),validkey(dhexp_real(key_s(bob),g))),validkey(dhexp_real(key_m(bob),g))).
attacker(hash(hash(hash(hash(somename,empty),empty),validkey(dhexp_real(key_s(bob),g))),validkey(dhexp_real(key_m(bob),g)))).

18. By 17, the attacker may know hash(hash(hash(hash(somename,empty),empty),validkey(dhexp_real(key_s(bob),g))),validkey(dhexp_real(key_m(bob),g))).
By 7, the attacker may know validkey(dhexp_real(key_e(alice,bob,sid_5),g)).
Using the function hash the attacker may obtain hash(hash(hash(hash(hash(somename,empty),empty),validkey(dhexp_real(key_s(bob),g))),validkey(dhexp_real(key_m(bob),g))),validkey(dhexp_real(key_e(alice,bob,sid_5),g))).
attacker(hash(hash(hash(hash(hash(somename,empty),empty),validkey(dhexp_real(key_s(bob),g))),validkey(dhexp_real(key_m(bob),g))),validkey(dhexp_real(key_e(alice,bob,sid_5),g)))).

19. By 18, the attacker may know hash(hash(hash(hash(hash(somename,empty),empty),validkey(dhexp_real(key_s(bob),g))),validkey(dhexp_real(key_m(bob),g))),validkey(dhexp_real(key_e(alice,bob,sid_5),g))).
So the attacker may know hash(hash(hash(hash(hash(somename,empty),empty),validkey(dhexp_real(key_s(bob),g))),validkey(dhexp_real(key_m(bob),g))),validkey(dhexp_real(key_e(alice,bob,sid_5),g))) in phase 1.
attacker_p1(hash(hash(hash(hash(hash(somename,empty),empty),validkey(dhexp_real(key_s(bob),g))),validkey(dhexp_real(key_m(bob),g))),validkey(dhexp_real(key_e(alice,bob,sid_5),g)))).

20. Using the function minnonce the attacker may obtain minnonce in phase 1.
attacker_p1(minnonce).

21. By 7, the attacker may know validkey(dhexp_real(key_e(alice,bob,sid_5),g)).
So the attacker may know validkey(dhexp_real(key_e(alice,bob,sid_5),g)) in phase 1.
attacker_p1(validkey(dhexp_real(key_e(alice,bob,sid_5),g))).

22. Using the function pub the attacker may obtain pub in phase 1.
attacker_p1(pub).

23. The event LeakS(phase1,bob) may be executed at {1594}.
The event LeakM(phase1,bob) may be executed at {1595}.
So the message (key_s(bob),key_m(bob)) may be sent on channel pub in phase 1 at output {1596}.
mess_p1(pub,(key_s(bob),key_m(bob))).

24. By 22, the attacker may have the channel pub in phase 1.
By 23, the message (key_s(bob),key_m(bob)) in phase 1 may be sent on this channel.
So the attacker may obtain the message (key_s(bob),key_m(bob)) in phase 1 by listening on this channel.
attacker_p1((key_s(bob),key_m(bob))).

25. By 24, the attacker may know (key_s(bob),key_m(bob)) in phase 1.
Using the function 2-proj-2-tuple the attacker may obtain key_m(bob) in phase 1.
attacker_p1(key_m(bob)).

26. By 25, the attacker may know key_m(bob) in phase 1.
By 21, the attacker may know validkey(dhexp_real(key_e(alice,bob,sid_5),g)) in phase 1.
Using the function dhexp the attacker may obtain dhexp_real(key_e(alice,bob,sid_5),dhexp_real(key_m(bob),g)) in phase 1.
attacker_p1(dhexp_real(key_e(alice,bob,sid_5),dhexp_real(key_m(bob),g))).

27. By 24, the attacker may know (key_s(bob),key_m(bob)) in phase 1.
Using the function 1-proj-2-tuple the attacker may obtain key_s(bob) in phase 1.
attacker_p1(key_s(bob)).

28. By 27, the attacker may know key_s(bob) in phase 1.
By 21, the attacker may know validkey(dhexp_real(key_e(alice,bob,sid_5),g)) in phase 1.
Using the function dhexp the attacker may obtain dhexp_real(key_e(alice,bob,sid_5),dhexp_real(key_s(bob),g)) in phase 1.
attacker_p1(dhexp_real(key_e(alice,bob,sid_5),dhexp_real(key_s(bob),g))).

29. Using the function empty the attacker may obtain empty in phase 1.
attacker_p1(empty).

30. Using the function somename the attacker may obtain somename in phase 1.
attacker_p1(somename).

31. By 30, the attacker may know somename in phase 1.
By 29, the attacker may know empty in phase 1.
Using the function hash the attacker may obtain hash(somename,empty) in phase 1.
attacker_p1(hash(somename,empty)).

32. By 31, the attacker may know hash(somename,empty) in phase 1.
By 28, the attacker may know dhexp_real(key_e(alice,bob,sid_5),dhexp_real(key_s(bob),g)) in phase 1.
Using the function hmac_hash1 the attacker may obtain hmac_hash1(hash(somename,empty),dhexp_real(key_e(alice,bob,sid_5),dhexp_real(key_s(bob),g))) in phase 1.
attacker_p1(hmac_hash1(hash(somename,empty),dhexp_real(key_e(alice,bob,sid_5),dhexp_real(key_s(bob),g)))).

33. By 32, the attacker may know hmac_hash1(hash(somename,empty),dhexp_real(key_e(alice,bob,sid_5),dhexp_real(key_s(bob),g))) in phase 1.
By 26, the attacker may know dhexp_real(key_e(alice,bob,sid_5),dhexp_real(key_m(bob),g)) in phase 1.
Using the function hmac_hash2 the attacker may obtain hmac_hash2(hmac_hash1(hash(somename,empty),dhexp_real(key_e(alice,bob,sid_5),dhexp_real(key_s(bob),g))),dhexp_real(key_e(alice,bob,sid_5),dhexp_real(key_m(bob),g))) in phase 1.
attacker_p1(hmac_hash2(hmac_hash1(hash(somename,empty),dhexp_real(key_e(alice,bob,sid_5),dhexp_real(key_s(bob),g))),dhexp_real(key_e(alice,bob,sid_5),dhexp_real(key_m(bob),g)))).

34. By 33, the attacker may know hmac_hash2(hmac_hash1(hash(somename,empty),dhexp_real(key_e(alice,bob,sid_5),dhexp_real(key_s(bob),g))),dhexp_real(key_e(alice,bob,sid_5),dhexp_real(key_m(bob),g))) in phase 1.
By 20, the attacker may know minnonce in phase 1.
By 19, the attacker may know hash(hash(hash(hash(hash(somename,empty),empty),validkey(dhexp_real(key_s(bob),g))),validkey(dhexp_real(key_m(bob),g))),validkey(dhexp_real(key_e(alice,bob,sid_5),g))) in phase 1.
By 6, the attacker may know encrypt(hmac_hash2(hmac_hash1(hash(somename,empty),dhexp_real(key_e(alice,bob,sid_5),dhexp_real(key_s(bob),g))),dhexp_real(key_e(alice,bob,sid_5),dhexp_real(key_m(bob),g))),minnonce,hash(hash(hash(hash(hash(somename,empty),empty),validkey(dhexp_real(key_s(bob),g))),validkey(dhexp_real(key_m(bob),g))),validkey(dhexp_real(key_e(alice,bob,sid_5),g))),msg_a(alice,bob,sid_5)) in phase 1.
Using the function decrypt the attacker may obtain aeadpack(true,hash(hash(hash(hash(hash(somename,empty),empty),validkey(dhexp_real(key_s(bob),g))),validkey(dhexp_real(key_m(bob),g))),validkey(dhexp_real(key_e(alice,bob,sid_5),g))),msg_a(alice,bob,sid_5)) in phase 1.
attacker_p1(aeadpack(true,hash(hash(hash(hash(hash(somename,empty),empty),validkey(dhexp_real(key_s(bob),g))),validkey(dhexp_real(key_m(bob),g))),validkey(dhexp_real(key_e(alice,bob,sid_5),g))),msg_a(alice,bob,sid_5))).

35. By 34, the attacker may know aeadpack(true,hash(hash(hash(hash(hash(somename,empty),empty),validkey(dhexp_real(key_s(bob),g))),validkey(dhexp_real(key_m(bob),g))),validkey(dhexp_real(key_e(alice,bob,sid_5),g))),msg_a(alice,bob,sid_5)) in phase 1.
Using the function 3-proj-aeadpack the attacker may obtain msg_a(alice,bob,sid_5) in phase 1.
attacker_p1(msg_a(alice,bob,sid_5)).

36. By 35, attacker_p1(msg_a(alice,bob,sid_5)).
The goal is reached, represented in the following fact:
attacker_p1(msg_a(alice,bob,sid_5)).


RESULT attacker_p1(msg_a(alice,bob,sid_a)) ==> (event(LeakS(phase0,bob)) && event(LeakM(phase0,bob))) || (event(LeakS(px,bob)) && event(LeakM(px,bob)) && event(LeakS(pz,alice)) && event(LeakM(pz,alice))) cannot be proved.
Starting query attacker_p1(msg_a(alice,bob,sid_a)) ==> event(LeakS(phase0,bob)) && event(LeakM(phase0,bob))
goal reachable: begin(LeakM(phase1,bob)) && begin(LeakS(phase1,bob)) && begin(SendMsg(alice,bob,stagepack_a(sid_5),msg_a(alice,bob,sid_5))) -> attacker_p1(msg_a(alice,bob,sid_5))
Abbreviations:
sid_5 = sid[!1 = @sid]

Derivation:
Abbreviations:
sid_5 = sid[!1 = @sid]

1. Using the function pub the attacker may obtain pub.
attacker(pub).

2. The entry statestore(alice,bob,sid_5,statepack_a(handshakestatepack(symmetricstatepack(cipherstatepack(empty,minnonce),hash(somename,empty),hash(hash(hash(hash(somename,empty),empty),validkey(dhexp_real(key_s(bob),g))),validkey(dhexp_real(key_m(bob),g)))),keypairpack(empty,empty),keypairpack(empty,empty),keypairpack(empty,empty),validkey(dhexp_real(key_s(bob),g)),validkey(dhexp_real(key_m(bob),g)),empty,empty,true))) may be inserted in a table at insert {50}.
table(statestore(alice,bob,sid_5,statepack_a(handshakestatepack(symmetricstatepack(cipherstatepack(empty,minnonce),hash(somename,empty),hash(hash(hash(hash(somename,empty),empty),validkey(dhexp_real(key_s(bob),g))),validkey(dhexp_real(key_m(bob),g)))),keypairpack(empty,empty),keypairpack(empty,empty),keypairpack(empty,empty),validkey(dhexp_real(key_s(bob),g)),validkey(dhexp_real(key_m(bob),g)),empty,empty,true)))).

3. The entry statestore(alice,bob,sid_5,statepack_a(handshakestatepack(symmetricstatepack(cipherstatepack(empty,minnonce),hash(somename,empty),hash(hash(hash(hash(somename,empty),empty),validkey(dhexp_real(key_s(bob),g))),validkey(dhexp_real(key_m(bob),g)))),keypairpack(empty,empty),keypairpack(empty,empty),keypairpack(empty,empty),validkey(dhexp_real(key_s(bob),g)),validkey(dhexp_real(key_m(bob),g)),empty,empty,true))) that may be in a table by 2 may be read at get {163}.
The event SendMsg(alice,bob,stagepack_a(sid_5),msg_a(alice,bob,sid_5)) may be executed at {160}.
So the message concat3(validkey(dhexp_real(key_e(alice,bob,sid_5),g)),empty,encrypt(hmac_hash2(hmac_hash1(hash(somename,empty),dhexp_real(key_e(alice,bob,sid_5),dhexp_real(key_s(bob),g))),dhexp_real(key_e(alice,bob,sid_5),dhexp_real(key_m(bob),g))),minnonce,hash(hash(hash(hash(hash(somename,empty),empty),validkey(dhexp_real(key_s(bob),g))),validkey(dhexp_real(key_m(bob),g))),validkey(dhexp_real(key_e(alice,bob,sid_5),g))),msg_a(alice,bob,sid_5))) may be sent on channel pub at output {162}.
mess(pub,concat3(validkey(dhexp_real(key_e(alice,bob,sid_5),g)),empty,encrypt(hmac_hash2(hmac_hash1(hash(somename,empty),dhexp_real(key_e(alice,bob,sid_5),dhexp_real(key_s(bob),g))),dhexp_real(key_e(alice,bob,sid_5),dhexp_real(key_m(bob),g))),minnonce,hash(hash(hash(hash(hash(somename,empty),empty),validkey(dhexp_real(key_s(bob),g))),validkey(dhexp_real(key_m(bob),g))),validkey(dhexp_real(key_e(alice,bob,sid_5),g))),msg_a(alice,bob,sid_5)))).

4. By 1, the attacker may have the channel pub.
By 3, the message concat3(validkey(dhexp_real(key_e(alice,bob,sid_5),g)),empty,encrypt(hmac_hash2(hmac_hash1(hash(somename,empty),dhexp_real(key_e(alice,bob,sid_5),dhexp_real(key_s(bob),g))),dhexp_real(key_e(alice,bob,sid_5),dhexp_real(key_m(bob),g))),minnonce,hash(hash(hash(hash(hash(somename,empty),empty),validkey(dhexp_real(key_s(bob),g))),validkey(dhexp_real(key_m(bob),g))),validkey(dhexp_real(key_e(alice,bob,sid_5),g))),msg_a(alice,bob,sid_5))) may be sent on this channel.
So the attacker may obtain the message concat3(validkey(dhexp_real(key_e(alice,bob,sid_5),g)),empty,encrypt(hmac_hash2(hmac_hash1(hash(somename,empty),dhexp_real(key_e(alice,bob,sid_5),dhexp_real(key_s(bob),g))),dhexp_real(key_e(alice,bob,sid_5),dhexp_real(key_m(bob),g))),minnonce,hash(hash(hash(hash(hash(somename,empty),empty),validkey(dhexp_real(key_s(bob),g))),validkey(dhexp_real(key_m(bob),g))),validkey(dhexp_real(key_e(alice,bob,sid_5),g))),msg_a(alice,bob,sid_5))) by listening on this channel.
attacker(concat3(validkey(dhexp_real(key_e(alice,bob,sid_5),g)),empty,encrypt(hmac_hash2(hmac_hash1(hash(somename,empty),dhexp_real(key_e(alice,bob,sid_5),dhexp_real(key_s(bob),g))),dhexp_real(key_e(alice,bob,sid_5),dhexp_real(key_m(bob),g))),minnonce,hash(hash(hash(hash(hash(somename,empty),empty),validkey(dhexp_real(key_s(bob),g))),validkey(dhexp_real(key_m(bob),g))),validkey(dhexp_real(key_e(alice,bob,sid_5),g))),msg_a(alice,bob,sid_5)))).

5. By 4, the attacker may know concat3(validkey(dhexp_real(key_e(alice,bob,sid_5),g)),empty,encrypt(hmac_hash2(hmac_hash1(hash(somename,empty),dhexp_real(key_e(alice,bob,sid_5),dhexp_real(key_s(bob),g))),dhexp_real(key_e(alice,bob,sid_5),dhexp_real(key_m(bob),g))),minnonce,hash(hash(hash(hash(hash(somename,empty),empty),validkey(dhexp_real(key_s(bob),g))),validkey(dhexp_real(key_m(bob),g))),validkey(dhexp_real(key_e(alice,bob,sid_5),g))),msg_a(alice,bob,sid_5))).
Using the function 3-proj-concat3 the attacker may obtain encrypt(hmac_hash2(hmac_hash1(hash(somename,empty),dhexp_real(key_e(alice,bob,sid_5),dhexp_real(key_s(bob),g))),dhexp_real(key_e(alice,bob,sid_5),dhexp_real(key_m(bob),g))),minnonce,hash(hash(hash(hash(hash(somename,empty),empty),validkey(dhexp_real(key_s(bob),g))),validkey(dhexp_real(key_m(bob),g))),validkey(dhexp_real(key_e(alice,bob,sid_5),g))),msg_a(alice,bob,sid_5)).
attacker(encrypt(hmac_hash2(hmac_hash1(hash(somename,empty),dhexp_real(key_e(alice,bob,sid_5),dhexp_real(key_s(bob),g))),dhexp_real(key_e(alice,bob,sid_5),dhexp_real(key_m(bob),g))),minnonce,hash(hash(hash(hash(hash(somename,empty),empty),validkey(dhexp_real(key_s(bob),g))),validkey(dhexp_real(key_m(bob),g))),validkey(dhexp_real(key_e(alice,bob,sid_5),g))),msg_a(alice,bob,sid_5))).

6. By 5, the attacker may know encrypt(hmac_hash2(hmac_hash1(hash(somename,empty),dhexp_real(key_e(alice,bob,sid_5),dhexp_real(key_s(bob),g))),dhexp_real(key_e(alice,bob,sid_5),dhexp_real(key_m(bob),g))),minnonce,hash(hash(hash(hash(hash(somename,empty),empty),validkey(dhexp_real(key_s(bob),g))),validkey(dhexp_real(key_m(bob),g))),validkey(dhexp_real(key_e(alice,bob,sid_5),g))),msg_a(alice,bob,sid_5)).
So the attacker may know encrypt(hmac_hash2(hmac_hash1(hash(somename,empty),dhexp_real(key_e(alice,bob,sid_5),dhexp_real(key_s(bob),g))),dhexp_real(key_e(alice,bob,sid_5),dhexp_real(key_m(bob),g))),minnonce,hash(hash(hash(hash(hash(somename,empty),empty),validkey(dhexp_real(key_s(bob),g))),validkey(dhexp_real(key_m(bob),g))),validkey(dhexp_real(key_e(alice,bob,sid_5),g))),msg_a(alice,bob,sid_5)) in phase 1.
attacker_p1(encrypt(hmac_hash2(hmac_hash1(hash(somename,empty),dhexp_real(key_e(alice,bob,sid_5),dhexp_real(key_s(bob),g))),dhexp_real(key_e(alice,bob,sid_5),dhexp_real(key_m(bob),g))),minnonce,hash(hash(hash(hash(hash(somename,empty),empty),validkey(dhexp_real(key_s(bob),g))),validkey(dhexp_real(key_m(bob),g))),validkey(dhexp_real(key_e(alice,bob,sid_5),g))),msg_a(alice,bob,sid_5))).

7. By 4, the attacker may know concat3(validkey(dhexp_real(key_e(alice,bob,sid_5),g)),empty,encrypt(hmac_hash2(hmac_hash1(hash(somename,empty),dhexp_real(key_e(alice,bob,sid_5),dhexp_real(key_s(bob),g))),dhexp_real(key_e(alice,bob,sid_5),dhexp_real(key_m(bob),g))),minnonce,hash(hash(hash(hash(hash(somename,empty),empty),validkey(dhexp_real(key_s(bob),g))),validkey(dhexp_real(key_m(bob),g))),validkey(dhexp_real(key_e(alice,bob,sid_5),g))),msg_a(alice,bob,sid_5))).
Using the function 1-proj-concat3 the attacker may obtain validkey(dhexp_real(key_e(alice,bob,sid_5),g)).
attacker(validkey(dhexp_real(key_e(alice,bob,sid_5),g))).

8. The message (validkey(dhexp_real(key_s(bob),g)),validkey(dhexp_real(key_m(bob),g))) may be sent on channel pub at output {1065}.
mess(pub,(validkey(dhexp_real(key_s(bob),g)),validkey(dhexp_real(key_m(bob),g)))).

9. By 1, the attacker may have the channel pub.
By 8, the message (validkey(dhexp_real(key_s(bob),g)),validkey(dhexp_real(key_m(bob),g))) may be sent on this channel.
So the attacker may obtain the message (validkey(dhexp_real(key_s(bob),g)),validkey(dhexp_real(key_m(bob),g))) by listening on this channel.
attacker((validkey(dhexp_real(key_s(bob),g)),validkey(dhexp_real(key_m(bob),g)))).

10. By 9, the attacker may know (validkey(dhexp_real(key_s(bob),g)),validkey(dhexp_real(key_m(bob),g))).
Using the function 2-proj-2-tuple the attacker may obtain validkey(dhexp_real(key_m(bob),g)).
attacker(validkey(dhexp_real(key_m(bob),g))).

11. By 9, the attacker may know (validkey(dhexp_real(key_s(bob),g)),validkey(dhexp_real(key_m(bob),g))).
Using the function 1-proj-2-tuple the attacker may obtain validkey(dhexp_real(key_s(bob),g)).
attacker(validkey(dhexp_real(key_s(bob),g))).

12. Using the function empty the attacker may obtain empty.
attacker(empty).

13. Using the function somename the attacker may obtain somename.
attacker(somename).

14. By 13, the attacker may know somename.
By 12, the attacker may know empty.
Using the function hash the attacker may obtain hash(somename,empty).
attacker(hash(somename,empty)).

15. By 14, the attacker may know hash(somename,empty).
By 12, the attacker may know empty.
Using the function hash the attacker may obtain hash(hash(somename,empty),empty).
attacker(hash(hash(somename,empty),empty)).

16. By 15, the attacker may know hash(hash(somename,empty),empty).
By 11, the attacker may know validkey(dhexp_real(key_s(bob),g)).
Using the function hash the attacker may obtain hash(hash(hash(somename,empty),empty),validkey(dhexp_real(key_s(bob),g))).
attacker(hash(hash(hash(somename,empty),empty),validkey(dhexp_real(key_s(bob),g)))).

17. By 16, the attacker may know hash(hash(hash(somename,empty),empty),validkey(dhexp_real(key_s(bob),g))).
By 10, the attacker may know validkey(dhexp_real(key_m(bob),g)).
Using the function hash the attacker may obtain hash(hash(hash(hash(somename,empty),empty),validkey(dhexp_real(key_s(bob),g))),validkey(dhexp_real(key_m(bob),g))).
attacker(hash(hash(hash(hash(somename,empty),empty),validkey(dhexp_real(key_s(bob),g))),validkey(dhexp_real(key_m(bob),g)))).

18. By 17, the attacker may know hash(hash(hash(hash(somename,empty),empty),validkey(dhexp_real(key_s(bob),g))),validkey(dhexp_real(key_m(bob),g))).
By 7, the attacker may know validkey(dhexp_real(key_e(alice,bob,sid_5),g)).
Using the function hash the attacker may obtain hash(hash(hash(hash(hash(somename,empty),empty),validkey(dhexp_real(key_s(bob),g))),validkey(dhexp_real(key_m(bob),g))),validkey(dhexp_real(key_e(alice,bob,sid_5),g))).
attacker(hash(hash(hash(hash(hash(somename,empty),empty),validkey(dhexp_real(key_s(bob),g))),validkey(dhexp_real(key_m(bob),g))),validkey(dhexp_real(key_e(alice,bob,sid_5),g)))).

19. By 18, the attacker may know hash(hash(hash(hash(hash(somename,empty),empty),validkey(dhexp_real(key_s(bob),g))),validkey(dhexp_real(key_m(bob),g))),validkey(dhexp_real(key_e(alice,bob,sid_5),g))).
So the attacker may know hash(hash(hash(hash(hash(somename,empty),empty),validkey(dhexp_real(key_s(bob),g))),validkey(dhexp_real(key_m(bob),g))),validkey(dhexp_real(key_e(alice,bob,sid_5),g))) in phase 1.
attacker_p1(hash(hash(hash(hash(hash(somename,empty),empty),validkey(dhexp_real(key_s(bob),g))),validkey(dhexp_real(key_m(bob),g))),validkey(dhexp_real(key_e(alice,bob,sid_5),g)))).

20. Using the function minnonce the attacker may obtain minnonce in phase 1.
attacker_p1(minnonce).

21. By 7, the attacker may know validkey(dhexp_real(key_e(alice,bob,sid_5),g)).
So the attacker may know validkey(dhexp_real(key_e(alice,bob,sid_5),g)) in phase 1.
attacker_p1(validkey(dhexp_real(key_e(alice,bob,sid_5),g))).

22. Using the function pub the attacker may obtain pub in phase 1.
attacker_p1(pub).

23. The event LeakS(phase1,bob) may be executed at {1594}.
The event LeakM(phase1,bob) may be executed at {1595}.
So the message (key_s(bob),key_m(bob)) may be sent on channel pub in phase 1 at output {1596}.
mess_p1(pub,(key_s(bob),key_m(bob))).

24. By 22, the attacker may have the channel pub in phase 1.
By 23, the message (key_s(bob),key_m(bob)) in phase 1 may be sent on this channel.
So the attacker may obtain the message (key_s(bob),key_m(bob)) in phase 1 by listening on this channel.
attacker_p1((key_s(bob),key_m(bob))).

25. By 24, the attacker may know (key_s(bob),key_m(bob)) in phase 1.
Using the function 2-proj-2-tuple the attacker may obtain key_m(bob) in phase 1.
attacker_p1(key_m(bob)).

26. By 25, the attacker may know key_m(bob) in phase 1.
By 21, the attacker may know validkey(dhexp_real(key_e(alice,bob,sid_5),g)) in phase 1.
Using the function dhexp the attacker may obtain dhexp_real(key_e(alice,bob,sid_5),dhexp_real(key_m(bob),g)) in phase 1.
attacker_p1(dhexp_real(key_e(alice,bob,sid_5),dhexp_real(key_m(bob),g))).

27. By 24, the attacker may know (key_s(bob),key_m(bob)) in phase 1.
Using the function 1-proj-2-tuple the attacker may obtain key_s(bob) in phase 1.
attacker_p1(key_s(bob)).

28. By 27, the attacker may know key_s(bob) in phase 1.
By 21, the attacker may know validkey(dhexp_real(key_e(alice,bob,sid_5),g)) in phase 1.
Using the function dhexp the attacker may obtain dhexp_real(key_e(alice,bob,sid_5),dhexp_real(key_s(bob),g)) in phase 1.
attacker_p1(dhexp_real(key_e(alice,bob,sid_5),dhexp_real(key_s(bob),g))).

29. Using the function empty the attacker may obtain empty in phase 1.
attacker_p1(empty).

30. Using the function somename the attacker may obtain somename in phase 1.
attacker_p1(somename).

31. By 30, the attacker may know somename in phase 1.
By 29, the attacker may know empty in phase 1.
Using the function hash the attacker may obtain hash(somename,empty) in phase 1.
attacker_p1(hash(somename,empty)).

32. By 31, the attacker may know hash(somename,empty) in phase 1.
By 28, the attacker may know dhexp_real(key_e(alice,bob,sid_5),dhexp_real(key_s(bob),g)) in phase 1.
Using the function hmac_hash1 the attacker may obtain hmac_hash1(hash(somename,empty),dhexp_real(key_e(alice,bob,sid_5),dhexp_real(key_s(bob),g))) in phase 1.
attacker_p1(hmac_hash1(hash(somename,empty),dhexp_real(key_e(alice,bob,sid_5),dhexp_real(key_s(bob),g)))).

33. By 32, the attacker may know hmac_hash1(hash(somename,empty),dhexp_real(key_e(alice,bob,sid_5),dhexp_real(key_s(bob),g))) in phase 1.
By 26, the attacker may know dhexp_real(key_e(alice,bob,sid_5),dhexp_real(key_m(bob),g)) in phase 1.
Using the function hmac_hash2 the attacker may obtain hmac_hash2(hmac_hash1(hash(somename,empty),dhexp_real(key_e(alice,bob,sid_5),dhexp_real(key_s(bob),g))),dhexp_real(key_e(alice,bob,sid_5),dhexp_real(key_m(bob),g))) in phase 1.
attacker_p1(hmac_hash2(hmac_hash1(hash(somename,empty),dhexp_real(key_e(alice,bob,sid_5),dhexp_real(key_s(bob),g))),dhexp_real(key_e(alice,bob,sid_5),dhexp_real(key_m(bob),g)))).

34. By 33, the attacker may know hmac_hash2(hmac_hash1(hash(somename,empty),dhexp_real(key_e(alice,bob,sid_5),dhexp_real(key_s(bob),g))),dhexp_real(key_e(alice,bob,sid_5),dhexp_real(key_m(bob),g))) in phase 1.
By 20, the attacker may know minnonce in phase 1.
By 19, the attacker may know hash(hash(hash(hash(hash(somename,empty),empty),validkey(dhexp_real(key_s(bob),g))),validkey(dhexp_real(key_m(bob),g))),validkey(dhexp_real(key_e(alice,bob,sid_5),g))) in phase 1.
By 6, the attacker may know encrypt(hmac_hash2(hmac_hash1(hash(somename,empty),dhexp_real(key_e(alice,bob,sid_5),dhexp_real(key_s(bob),g))),dhexp_real(key_e(alice,bob,sid_5),dhexp_real(key_m(bob),g))),minnonce,hash(hash(hash(hash(hash(somename,empty),empty),validkey(dhexp_real(key_s(bob),g))),validkey(dhexp_real(key_m(bob),g))),validkey(dhexp_real(key_e(alice,bob,sid_5),g))),msg_a(alice,bob,sid_5)) in phase 1.
Using the function decrypt the attacker may obtain aeadpack(true,hash(hash(hash(hash(hash(somename,empty),empty),validkey(dhexp_real(key_s(bob),g))),validkey(dhexp_real(key_m(bob),g))),validkey(dhexp_real(key_e(alice,bob,sid_5),g))),msg_a(alice,bob,sid_5)) in phase 1.
attacker_p1(aeadpack(true,hash(hash(hash(hash(hash(somename,empty),empty),validkey(dhexp_real(key_s(bob),g))),validkey(dhexp_real(key_m(bob),g))),validkey(dhexp_real(key_e(alice,bob,sid_5),g))),msg_a(alice,bob,sid_5))).

35. By 34, the attacker may know aeadpack(true,hash(hash(hash(hash(hash(somename,empty),empty),validkey(dhexp_real(key_s(bob),g))),validkey(dhexp_real(key_m(bob),g))),validkey(dhexp_real(key_e(alice,bob,sid_5),g))),msg_a(alice,bob,sid_5)) in phase 1.
Using the function 3-proj-aeadpack the attacker may obtain msg_a(alice,bob,sid_5) in phase 1.
attacker_p1(msg_a(alice,bob,sid_5)).

36. By 35, attacker_p1(msg_a(alice,bob,sid_5)).
The goal is reached, represented in the following fact:
attacker_p1(msg_a(alice,bob,sid_5)).


RESULT attacker_p1(msg_a(alice,bob,sid_a)) ==> event(LeakS(phase0,bob)) && event(LeakM(phase0,bob)) cannot be proved.
Starting query event(RecvMsg(alice,bob,stagepack_b(sid_a),m_26)) ==> event(SendMsg(bob,alice,stagepack_b(sid_b),m_26))
goal reachable: begin(SendMsg(bob,charlie,stagepack_b(sid_5),msg_b(bob,charlie,sid_5))) && begin(SendMsg(alice,bob,stagepack_a(sid_6),msg_a(alice,bob,sid_6))) -> end(RecvMsg(alice,bob,stagepack_b(sid_6),msg_b(bob,charlie,sid_5)))
Abbreviations:
sid_6 = sid[!1 = @sid]
sid_5 = sid[!1 = @sid_1]

Derivation:
Abbreviations:
sid_5 = sid[!1 = @sid]
sid_6 = sid[!1 = @sid_1]

1. The entry statestore(alice,bob,sid_5,statepack_a(handshakestatepack(symmetricstatepack(cipherstatepack(empty,minnonce),hash(somename,empty),hash(hash(hash(hash(somename,empty),empty),validkey(dhexp_real(key_s(bob),g))),validkey(dhexp_real(key_m(bob),g)))),keypairpack(empty,empty),keypairpack(empty,empty),keypairpack(empty,empty),validkey(dhexp_real(key_s(bob),g)),validkey(dhexp_real(key_m(bob),g)),empty,empty,true))) may be inserted in a table at insert {50}.
table(statestore(alice,bob,sid_5,statepack_a(handshakestatepack(symmetricstatepack(cipherstatepack(empty,minnonce),hash(somename,empty),hash(hash(hash(hash(somename,empty),empty),validkey(dhexp_real(key_s(bob),g))),validkey(dhexp_real(key_m(bob),g)))),keypairpack(empty,empty),keypairpack(empty,empty),keypairpack(empty,empty),validkey(dhexp_real(key_s(bob),g)),validkey(dhexp_real(key_m(bob),g)),empty,empty,true)))).

2. The entry statestore(alice,bob,sid_5,statepack_a(handshakestatepack(symmetricstatepack(cipherstatepack(empty,minnonce),hash(somename,empty),hash(hash(hash(hash(somename,empty),empty),validkey(dhexp_real(key_s(bob),g))),validkey(dhexp_real(key_m(bob),g)))),keypairpack(empty,empty),keypairpack(empty,empty),keypairpack(empty,empty),validkey(dhexp_real(key_s(bob),g)),validkey(dhexp_real(key_m(bob),g)),empty,empty,true))) that may be in a table by 1 may be read at get {163}.
The event SendMsg(alice,bob,stagepack_a(sid_5),msg_a(alice,bob,sid_5)) may be executed at {160}.
So the entry statestore(alice,bob,sid_5,statepack_b(handshakestatepack(symmetricstatepack(cipherstatepack(hmac_hash2(hmac_hash1(hash(somename,empty),dhexp_real(key_e(alice,bob,sid_5),dhexp_real(key_s(bob),g))),dhexp_real(key_e(alice,bob,sid_5),dhexp_real(key_m(bob),g))),increment_nonce(minnonce)),hmac_hash1(hmac_hash1(hash(somename,empty),dhexp_real(key_e(alice,bob,sid_5),dhexp_real(key_s(bob),g))),dhexp_real(key_e(alice,bob,sid_5),dhexp_real(key_m(bob),g))),hash(hash(hash(hash(hash(hash(somename,empty),empty),validkey(dhexp_real(key_s(bob),g))),validkey(dhexp_real(key_m(bob),g))),validkey(dhexp_real(key_e(alice,bob,sid_5),g))),encrypt(hmac_hash2(hmac_hash1(hash(somename,empty),dhexp_real(key_e(alice,bob,sid_5),dhexp_real(key_s(bob),g))),dhexp_real(key_e(alice,bob,sid_5),dhexp_real(key_m(bob),g))),minnonce,hash(hash(hash(hash(hash(somename,empty),empty),validkey(dhexp_real(key_s(bob),g))),validkey(dhexp_real(key_m(bob),g))),validkey(dhexp_real(key_e(alice,bob,sid_5),g))),msg_a(alice,bob,sid_5)))),keypairpack(empty,empty),keypairpack(empty,empty),keypairpack(validkey(dhexp_real(key_e(alice,bob,sid_5),g)),key_e(alice,bob,sid_5)),validkey(dhexp_real(key_s(bob),g)),validkey(dhexp_real(key_m(bob),g)),empty,empty,true))) may be inserted in a table at insert {161}.
table(statestore(alice,bob,sid_5,statepack_b(handshakestatepack(symmetricstatepack(cipherstatepack(hmac_hash2(hmac_hash1(hash(somename,empty),dhexp_real(key_e(alice,bob,sid_5),dhexp_real(key_s(bob),g))),dhexp_real(key_e(alice,bob,sid_5),dhexp_real(key_m(bob),g))),increment_nonce(minnonce)),hmac_hash1(hmac_hash1(hash(somename,empty),dhexp_real(key_e(alice,bob,sid_5),dhexp_real(key_s(bob),g))),dhexp_real(key_e(alice,bob,sid_5),dhexp_real(key_m(bob),g))),hash(hash(hash(hash(hash(hash(somename,empty),empty),validkey(dhexp_real(key_s(bob),g))),validkey(dhexp_real(key_m(bob),g))),validkey(dhexp_real(key_e(alice,bob,sid_5),g))),encrypt(hmac_hash2(hmac_hash1(hash(somename,empty),dhexp_real(key_e(alice,bob,sid_5),dhexp_real(key_s(bob),g))),dhexp_real(key_e(alice,bob,sid_5),dhexp_real(key_m(bob),g))),minnonce,hash(hash(hash(hash(hash(somename,empty),empty),validkey(dhexp_real(key_s(bob),g))),validkey(dhexp_real(key_m(bob),g))),validkey(dhexp_real(key_e(alice,bob,sid_5),g))),msg_a(alice,bob,sid_5)))),keypairpack(empty,empty),keypairpack(empty,empty),keypairpack(validkey(dhexp_real(key_e(alice,bob,sid_5),g)),key_e(alice,bob,sid_5)),validkey(dhexp_real(key_s(bob),g)),validkey(dhexp_real(key_m(bob),g)),empty,empty,true)))).

3. The entry statestore(bob,charlie,sid_6,statepack_a(handshakestatepack(symmetricstatepack(cipherstatepack(empty,minnonce),hash(somename,empty),hash(hash(hash(hash(somename,empty),empty),validkey(dhexp_real(key_s(bob),g))),validkey(dhexp_real(key_m(bob),g)))),keypairpack(validkey(dhexp_real(key_s(bob),g)),key_s(bob)),keypairpack(validkey(dhexp_real(key_m(bob),g)),key_m(bob)),keypairpack(empty,empty),empty,empty,empty,empty,false))) may be inserted in a table at insert {1647}.
table(statestore(bob,charlie,sid_6,statepack_a(handshakestatepack(symmetricstatepack(cipherstatepack(empty,minnonce),hash(somename,empty),hash(hash(hash(hash(somename,empty),empty),validkey(dhexp_real(key_s(bob),g))),validkey(dhexp_real(key_m(bob),g)))),keypairpack(validkey(dhexp_real(key_s(bob),g)),key_s(bob)),keypairpack(validkey(dhexp_real(key_m(bob),g)),key_m(bob)),keypairpack(empty,empty),empty,empty,empty,empty,false)))).

4. The entry statestore(alice,bob,sid_5,statepack_a(handshakestatepack(symmetricstatepack(cipherstatepack(empty,minnonce),hash(somename,empty),hash(hash(hash(hash(somename,empty),empty),validkey(dhexp_real(key_s(bob),g))),validkey(dhexp_real(key_m(bob),g)))),keypairpack(empty,empty),keypairpack(empty,empty),keypairpack(empty,empty),validkey(dhexp_real(key_s(bob),g)),validkey(dhexp_real(key_m(bob),g)),empty,empty,true))) that may be in a table by 1 may be read at get {163}.
The event SendMsg(alice,bob,stagepack_a(sid_5),msg_a(alice,bob,sid_5)) may be executed at {160}.
So the message concat3(validkey(dhexp_real(key_e(alice,bob,sid_5),g)),empty,encrypt(hmac_hash2(hmac_hash1(hash(somename,empty),dhexp_real(key_e(alice,bob,sid_5),dhexp_real(key_s(bob),g))),dhexp_real(key_e(alice,bob,sid_5),dhexp_real(key_m(bob),g))),minnonce,hash(hash(hash(hash(hash(somename,empty),empty),validkey(dhexp_real(key_s(bob),g))),validkey(dhexp_real(key_m(bob),g))),validkey(dhexp_real(key_e(alice,bob,sid_5),g))),msg_a(alice,bob,sid_5))) may be sent on channel pub at output {162}.
mess(pub,concat3(validkey(dhexp_real(key_e(alice,bob,sid_5),g)),empty,encrypt(hmac_hash2(hmac_hash1(hash(somename,empty),dhexp_real(key_e(alice,bob,sid_5),dhexp_real(key_s(bob),g))),dhexp_real(key_e(alice,bob,sid_5),dhexp_real(key_m(bob),g))),minnonce,hash(hash(hash(hash(hash(somename,empty),empty),validkey(dhexp_real(key_s(bob),g))),validkey(dhexp_real(key_m(bob),g))),validkey(dhexp_real(key_e(alice,bob,sid_5),g))),msg_a(alice,bob,sid_5)))).

5. The entry statestore(bob,charlie,sid_6,statepack_a(handshakestatepack(symmetricstatepack(cipherstatepack(empty,minnonce),hash(somename,empty),hash(hash(hash(hash(somename,empty),empty),validkey(dhexp_real(key_s(bob),g))),validkey(dhexp_real(key_m(bob),g)))),keypairpack(validkey(dhexp_real(key_s(bob),g)),key_s(bob)),keypairpack(validkey(dhexp_real(key_m(bob),g)),key_m(bob)),keypairpack(empty,empty),empty,empty,empty,empty,false))) that may be in a table by 3 may be read at get {1762}.
The message concat3(validkey(dhexp_real(key_e(alice,bob,sid_5),g)),empty,encrypt(hmac_hash2(hmac_hash1(hash(somename,empty),dhexp_real(key_e(alice,bob,sid_5),dhexp_real(key_s(bob),g))),dhexp_real(key_e(alice,bob,sid_5),dhexp_real(key_m(bob),g))),minnonce,hash(hash(hash(hash(hash(somename,empty),empty),validkey(dhexp_real(key_s(bob),g))),validkey(dhexp_real(key_m(bob),g))),validkey(dhexp_real(key_e(alice,bob,sid_5),g))),msg_a(alice,bob,sid_5))) that may be sent on channel pub by 4 may be received at input {1648}.
So the entry statestore(bob,charlie,sid_6,statepack_b(handshakestatepack(symmetricstatepack(cipherstatepack(hmac_hash2(hmac_hash1(hash(somename,empty),dhexp_real(key_e(alice,bob,sid_5),dhexp_real(key_s(bob),g))),dhexp_real(key_e(alice,bob,sid_5),dhexp_real(key_m(bob),g))),increment_nonce(minnonce)),hmac_hash1(hmac_hash1(hash(somename,empty),dhexp_real(key_e(alice,bob,sid_5),dhexp_real(key_s(bob),g))),dhexp_real(key_e(alice,bob,sid_5),dhexp_real(key_m(bob),g))),hash(hash(hash(hash(hash(hash(somename,empty),empty),validkey(dhexp_real(key_s(bob),g))),validkey(dhexp_real(key_m(bob),g))),validkey(dhexp_real(key_e(alice,bob,sid_5),g))),encrypt(hmac_hash2(hmac_hash1(hash(somename,empty),dhexp_real(key_e(alice,bob,sid_5),dhexp_real(key_s(bob),g))),dhexp_real(key_e(alice,bob,sid_5),dhexp_real(key_m(bob),g))),minnonce,hash(hash(hash(hash(hash(somename,empty),empty),validkey(dhexp_real(key_s(bob),g))),validkey(dhexp_real(key_m(bob),g))),validkey(dhexp_real(key_e(alice,bob,sid_5),g))),msg_a(alice,bob,sid_5)))),keypairpack(validkey(dhexp_real(key_s(bob),g)),key_s(bob)),keypairpack(validkey(dhexp_real(key_m(bob),g)),key_m(bob)),keypairpack(empty,empty),empty,empty,validkey(dhexp_real(key_e(alice,bob,sid_5),g)),empty,false))) may be inserted in a table at insert {1761}.
table(statestore(bob,charlie,sid_6,statepack_b(handshakestatepack(symmetricstatepack(cipherstatepack(hmac_hash2(hmac_hash1(hash(somename,empty),dhexp_real(key_e(alice,bob,sid_5),dhexp_real(key_s(bob),g))),dhexp_real(key_e(alice,bob,sid_5),dhexp_real(key_m(bob),g))),increment_nonce(minnonce)),hmac_hash1(hmac_hash1(hash(somename,empty),dhexp_real(key_e(alice,bob,sid_5),dhexp_real(key_s(bob),g))),dhexp_real(key_e(alice,bob,sid_5),dhexp_real(key_m(bob),g))),hash(hash(hash(hash(hash(hash(somename,empty),empty),validkey(dhexp_real(key_s(bob),g))),validkey(dhexp_real(key_m(bob),g))),validkey(dhexp_real(key_e(alice,bob,sid_5),g))),encrypt(hmac_hash2(hmac_hash1(hash(somename,empty),dhexp_real(key_e(alice,bob,sid_5),dhexp_real(key_s(bob),g))),dhexp_real(key_e(alice,bob,sid_5),dhexp_real(key_m(bob),g))),minnonce,hash(hash(hash(hash(hash(somename,empty),empty),validkey(dhexp_real(key_s(bob),g))),validkey(dhexp_real(key_m(bob),g))),validkey(dhexp_real(key_e(alice,bob,sid_5),g))),msg_a(alice,bob,sid_5)))),keypairpack(validkey(dhexp_real(key_s(bob),g)),key_s(bob)),keypairpack(validkey(dhexp_real(key_m(bob),g)),key_m(bob)),keypairpack(empty,empty),empty,empty,validkey(dhexp_real(key_e(alice,bob,sid_5),g)),empty,false)))).

6. The entry statestore(bob,charlie,sid_6,statepack_b(handshakestatepack(symmetricstatepack(cipherstatepack(hmac_hash2(hmac_hash1(hash(somename,empty),dhexp_real(key_e(alice,bob,sid_5),dhexp_real(key_s(bob),g))),dhexp_real(key_e(alice,bob,sid_5),dhexp_real(key_m(bob),g))),increment_nonce(minnonce)),hmac_hash1(hmac_hash1(hash(somename,empty),dhexp_real(key_e(alice,bob,sid_5),dhexp_real(key_s(bob),g))),dhexp_real(key_e(alice,bob,sid_5),dhexp_real(key_m(bob),g))),hash(hash(hash(hash(hash(hash(somename,empty),empty),validkey(dhexp_real(key_s(bob),g))),validkey(dhexp_real(key_m(bob),g))),validkey(dhexp_real(key_e(alice,bob,sid_5),g))),encrypt(hmac_hash2(hmac_hash1(hash(somename,empty),dhexp_real(key_e(alice,bob,sid_5),dhexp_real(key_s(bob),g))),dhexp_real(key_e(alice,bob,sid_5),dhexp_real(key_m(bob),g))),minnonce,hash(hash(hash(hash(hash(somename,empty),empty),validkey(dhexp_real(key_s(bob),g))),validkey(dhexp_real(key_m(bob),g))),validkey(dhexp_real(key_e(alice,bob,sid_5),g))),msg_a(alice,bob,sid_5)))),keypairpack(validkey(dhexp_real(key_s(bob),g)),key_s(bob)),keypairpack(validkey(dhexp_real(key_m(bob),g)),key_m(bob)),keypairpack(empty,empty),empty,empty,validkey(dhexp_real(key_e(alice,bob,sid_5),g)),empty,false))) that may be in a table by 5 may be read at get {1854}.
The event SendMsg(bob,charlie,stagepack_b(sid_6),msg_b(bob,charlie,sid_6)) may be executed at {1851}.
So the message concat3(validkey(dhexp_real(key_e(bob,charlie,sid_6),g)),empty,encrypt(hmac_hash2(hmac_hash1(hmac_hash1(hash(somename,empty),dhexp_real(key_e(alice,bob,sid_5),dhexp_real(key_s(bob),g))),dhexp_real(key_e(alice,bob,sid_5),dhexp_real(key_m(bob),g))),dhexp_real(key_e(alice,bob,sid_5),dhexp_real(key_e(bob,charlie,sid_6),g))),minnonce,hash(hash(hash(hash(hash(hash(hash(somename,empty),empty),validkey(dhexp_real(key_s(bob),g))),validkey(dhexp_real(key_m(bob),g))),validkey(dhexp_real(key_e(alice,bob,sid_5),g))),encrypt(hmac_hash2(hmac_hash1(hash(somename,empty),dhexp_real(key_e(alice,bob,sid_5),dhexp_real(key_s(bob),g))),dhexp_real(key_e(alice,bob,sid_5),dhexp_real(key_m(bob),g))),minnonce,hash(hash(hash(hash(hash(somename,empty),empty),validkey(dhexp_real(key_s(bob),g))),validkey(dhexp_real(key_m(bob),g))),validkey(dhexp_real(key_e(alice,bob,sid_5),g))),msg_a(alice,bob,sid_5))),validkey(dhexp_real(key_e(bob,charlie,sid_6),g))),msg_b(bob,charlie,sid_6))) may be sent on channel pub at output {1853}.
mess(pub,concat3(validkey(dhexp_real(key_e(bob,charlie,sid_6),g)),empty,encrypt(hmac_hash2(hmac_hash1(hmac_hash1(hash(somename,empty),dhexp_real(key_e(alice,bob,sid_5),dhexp_real(key_s(bob),g))),dhexp_real(key_e(alice,bob,sid_5),dhexp_real(key_m(bob),g))),dhexp_real(key_e(alice,bob,sid_5),dhexp_real(key_e(bob,charlie,sid_6),g))),minnonce,hash(hash(hash(hash(hash(hash(hash(somename,empty),empty),validkey(dhexp_real(key_s(bob),g))),validkey(dhexp_real(key_m(bob),g))),validkey(dhexp_real(key_e(alice,bob,sid_5),g))),encrypt(hmac_hash2(hmac_hash1(hash(somename,empty),dhexp_real(key_e(alice,bob,sid_5),dhexp_real(key_s(bob),g))),dhexp_real(key_e(alice,bob,sid_5),dhexp_real(key_m(bob),g))),minnonce,hash(hash(hash(hash(hash(somename,empty),empty),validkey(dhexp_real(key_s(bob),g))),validkey(dhexp_real(key_m(bob),g))),validkey(dhexp_real(key_e(alice,bob,sid_5),g))),msg_a(alice,bob,sid_5))),validkey(dhexp_real(key_e(bob,charlie,sid_6),g))),msg_b(bob,charlie,sid_6)))).

7. The entry statestore(alice,bob,sid_5,statepack_b(handshakestatepack(symmetricstatepack(cipherstatepack(hmac_hash2(hmac_hash1(hash(somename,empty),dhexp_real(key_e(alice,bob,sid_5),dhexp_real(key_s(bob),g))),dhexp_real(key_e(alice,bob,sid_5),dhexp_real(key_m(bob),g))),increment_nonce(minnonce)),hmac_hash1(hmac_hash1(hash(somename,empty),dhexp_real(key_e(alice,bob,sid_5),dhexp_real(key_s(bob),g))),dhexp_real(key_e(alice,bob,sid_5),dhexp_real(key_m(bob),g))),hash(hash(hash(hash(hash(hash(somename,empty),empty),validkey(dhexp_real(key_s(bob),g))),validkey(dhexp_real(key_m(bob),g))),validkey(dhexp_real(key_e(alice,bob,sid_5),g))),encrypt(hmac_hash2(hmac_hash1(hash(somename,empty),dhexp_real(key_e(alice,bob,sid_5),dhexp_real(key_s(bob),g))),dhexp_real(key_e(alice,bob,sid_5),dhexp_real(key_m(bob),g))),minnonce,hash(hash(hash(hash(hash(somename,empty),empty),validkey(dhexp_real(key_s(bob),g))),validkey(dhexp_real(key_m(bob),g))),validkey(dhexp_real(key_e(alice,bob,sid_5),g))),msg_a(alice,bob,sid_5)))),keypairpack(empty,empty),keypairpack(empty,empty),keypairpack(validkey(dhexp_real(key_e(alice,bob,sid_5),g)),key_e(alice,bob,sid_5)),validkey(dhexp_real(key_s(bob),g)),validkey(dhexp_real(key_m(bob),g)),empty,empty,true))) that may be in a table by 2 may be read at get {257}.
The message concat3(validkey(dhexp_real(key_e(bob,charlie,sid_6),g)),empty,encrypt(hmac_hash2(hmac_hash1(hmac_hash1(hash(somename,empty),dhexp_real(key_e(alice,bob,sid_5),dhexp_real(key_s(bob),g))),dhexp_real(key_e(alice,bob,sid_5),dhexp_real(key_m(bob),g))),dhexp_real(key_e(alice,bob,sid_5),dhexp_real(key_e(bob,charlie,sid_6),g))),minnonce,hash(hash(hash(hash(hash(hash(hash(somename,empty),empty),validkey(dhexp_real(key_s(bob),g))),validkey(dhexp_real(key_m(bob),g))),validkey(dhexp_real(key_e(alice,bob,sid_5),g))),encrypt(hmac_hash2(hmac_hash1(hash(somename,empty),dhexp_real(key_e(alice,bob,sid_5),dhexp_real(key_s(bob),g))),dhexp_real(key_e(alice,bob,sid_5),dhexp_real(key_m(bob),g))),minnonce,hash(hash(hash(hash(hash(somename,empty),empty),validkey(dhexp_real(key_s(bob),g))),validkey(dhexp_real(key_m(bob),g))),validkey(dhexp_real(key_e(alice,bob,sid_5),g))),msg_a(alice,bob,sid_5))),validkey(dhexp_real(key_e(bob,charlie,sid_6),g))),msg_b(bob,charlie,sid_6))) that may be sent on channel pub by 6 may be received at input {164}.
So event RecvMsg(alice,bob,stagepack_b(sid_5),msg_b(bob,charlie,sid_6)) may be executed at {255}.
end(RecvMsg(alice,bob,stagepack_b(sid_5),msg_b(bob,charlie,sid_6))).

8. By 7, end(RecvMsg(alice,bob,stagepack_b(sid_5),msg_b(bob,charlie,sid_6))).
The goal is reached, represented in the following fact:
end(RecvMsg(alice,bob,stagepack_b(sid_5),msg_b(bob,charlie,sid_6))).


RESULT event(RecvMsg(alice,bob,stagepack_b(sid_a),m_26)) ==> event(SendMsg(bob,alice,stagepack_b(sid_b),m_26)) cannot be proved.
Starting query event(RecvMsg(alice,bob,stagepack_b(sid_a),m_26)) ==> event(SendMsg(bob,c,stagepack_b(sid_b),m_26)) || (event(LeakS(phase0,bob)) && event(LeakM(phase0,bob))) || (event(LeakS(phase0,alice)) && event(LeakM(phase0,alice)))
goal reachable: begin(SendMsg(bob,alice,stagepack_b(sid_5),msg_b(bob,alice,sid_5))) && begin(SendMsg(alice,bob,stagepack_a(sid_6),msg_a(alice,bob,sid_6))) -> end(RecvMsg(alice,bob,stagepack_b(sid_6),msg_b(bob,alice,sid_5)))
Abbreviations:
sid_6 = sid[!1 = @sid]
sid_5 = sid[!1 = @sid_1]
goal reachable: begin(SendMsg(bob,charlie,stagepack_b(sid_5),msg_b(bob,charlie,sid_5))) && begin(SendMsg(alice,bob,stagepack_a(sid_6),msg_a(alice,bob,sid_6))) -> end(RecvMsg(alice,bob,stagepack_b(sid_6),msg_b(bob,charlie,sid_5)))
Abbreviations:
sid_6 = sid[!1 = @sid]
sid_5 = sid[!1 = @sid_1]
RESULT event(RecvMsg(alice,bob,stagepack_b(sid_a),m_26)) ==> event(SendMsg(bob,c,stagepack_b(sid_b),m_26)) || (event(LeakS(phase0,bob)) && event(LeakM(phase0,bob))) || (event(LeakS(phase0,alice)) && event(LeakM(phase0,alice))) is true.
Starting query event(RecvMsg(alice,bob,stagepack_b(sid_a),m_26)) ==> event(SendMsg(bob,c,stagepack_b(sid_b),m_26)) || (event(LeakS(phase0,bob)) && event(LeakM(phase0,bob)))
goal reachable: begin(SendMsg(bob,alice,stagepack_b(sid_5),msg_b(bob,alice,sid_5))) && begin(SendMsg(alice,bob,stagepack_a(sid_6),msg_a(alice,bob,sid_6))) -> end(RecvMsg(alice,bob,stagepack_b(sid_6),msg_b(bob,alice,sid_5)))
Abbreviations:
sid_6 = sid[!1 = @sid]
sid_5 = sid[!1 = @sid_1]
goal reachable: begin(SendMsg(bob,charlie,stagepack_b(sid_5),msg_b(bob,charlie,sid_5))) && begin(SendMsg(alice,bob,stagepack_a(sid_6),msg_a(alice,bob,sid_6))) -> end(RecvMsg(alice,bob,stagepack_b(sid_6),msg_b(bob,charlie,sid_5)))
Abbreviations:
sid_6 = sid[!1 = @sid]
sid_5 = sid[!1 = @sid_1]
RESULT event(RecvMsg(alice,bob,stagepack_b(sid_a),m_26)) ==> event(SendMsg(bob,c,stagepack_b(sid_b),m_26)) || (event(LeakS(phase0,bob)) && event(LeakM(phase0,bob))) is true.
Starting query event(RecvMsg(alice,bob,stagepack_b(sid_a),m_26)) ==> event(SendMsg(bob,alice,stagepack_b(sid_b),m_26)) || (event(LeakS(phase0,bob)) && event(LeakM(phase0,bob))) || (event(LeakS(phase0,alice)) && event(LeakM(phase0,alice)))
goal reachable: begin(SendMsg(bob,charlie,stagepack_b(sid_5),msg_b(bob,charlie,sid_5))) && begin(SendMsg(alice,bob,stagepack_a(sid_6),msg_a(alice,bob,sid_6))) -> end(RecvMsg(alice,bob,stagepack_b(sid_6),msg_b(bob,charlie,sid_5)))
Abbreviations:
sid_6 = sid[!1 = @sid]
sid_5 = sid[!1 = @sid_1]

Derivation:
Abbreviations:
sid_5 = sid[!1 = @sid]
sid_6 = sid[!1 = @sid_1]

1. The entry statestore(alice,bob,sid_5,statepack_a(handshakestatepack(symmetricstatepack(cipherstatepack(empty,minnonce),hash(somename,empty),hash(hash(hash(hash(somename,empty),empty),validkey(dhexp_real(key_s(bob),g))),validkey(dhexp_real(key_m(bob),g)))),keypairpack(empty,empty),keypairpack(empty,empty),keypairpack(empty,empty),validkey(dhexp_real(key_s(bob),g)),validkey(dhexp_real(key_m(bob),g)),empty,empty,true))) may be inserted in a table at insert {50}.
table(statestore(alice,bob,sid_5,statepack_a(handshakestatepack(symmetricstatepack(cipherstatepack(empty,minnonce),hash(somename,empty),hash(hash(hash(hash(somename,empty),empty),validkey(dhexp_real(key_s(bob),g))),validkey(dhexp_real(key_m(bob),g)))),keypairpack(empty,empty),keypairpack(empty,empty),keypairpack(empty,empty),validkey(dhexp_real(key_s(bob),g)),validkey(dhexp_real(key_m(bob),g)),empty,empty,true)))).

2. The entry statestore(alice,bob,sid_5,statepack_a(handshakestatepack(symmetricstatepack(cipherstatepack(empty,minnonce),hash(somename,empty),hash(hash(hash(hash(somename,empty),empty),validkey(dhexp_real(key_s(bob),g))),validkey(dhexp_real(key_m(bob),g)))),keypairpack(empty,empty),keypairpack(empty,empty),keypairpack(empty,empty),validkey(dhexp_real(key_s(bob),g)),validkey(dhexp_real(key_m(bob),g)),empty,empty,true))) that may be in a table by 1 may be read at get {163}.
The event SendMsg(alice,bob,stagepack_a(sid_5),msg_a(alice,bob,sid_5)) may be executed at {160}.
So the entry statestore(alice,bob,sid_5,statepack_b(handshakestatepack(symmetricstatepack(cipherstatepack(hmac_hash2(hmac_hash1(hash(somename,empty),dhexp_real(key_e(alice,bob,sid_5),dhexp_real(key_s(bob),g))),dhexp_real(key_e(alice,bob,sid_5),dhexp_real(key_m(bob),g))),increment_nonce(minnonce)),hmac_hash1(hmac_hash1(hash(somename,empty),dhexp_real(key_e(alice,bob,sid_5),dhexp_real(key_s(bob),g))),dhexp_real(key_e(alice,bob,sid_5),dhexp_real(key_m(bob),g))),hash(hash(hash(hash(hash(hash(somename,empty),empty),validkey(dhexp_real(key_s(bob),g))),validkey(dhexp_real(key_m(bob),g))),validkey(dhexp_real(key_e(alice,bob,sid_5),g))),encrypt(hmac_hash2(hmac_hash1(hash(somename,empty),dhexp_real(key_e(alice,bob,sid_5),dhexp_real(key_s(bob),g))),dhexp_real(key_e(alice,bob,sid_5),dhexp_real(key_m(bob),g))),minnonce,hash(hash(hash(hash(hash(somename,empty),empty),validkey(dhexp_real(key_s(bob),g))),validkey(dhexp_real(key_m(bob),g))),validkey(dhexp_real(key_e(alice,bob,sid_5),g))),msg_a(alice,bob,sid_5)))),keypairpack(empty,empty),keypairpack(empty,empty),keypairpack(validkey(dhexp_real(key_e(alice,bob,sid_5),g)),key_e(alice,bob,sid_5)),validkey(dhexp_real(key_s(bob),g)),validkey(dhexp_real(key_m(bob),g)),empty,empty,true))) may be inserted in a table at insert {161}.
table(statestore(alice,bob,sid_5,statepack_b(handshakestatepack(symmetricstatepack(cipherstatepack(hmac_hash2(hmac_hash1(hash(somename,empty),dhexp_real(key_e(alice,bob,sid_5),dhexp_real(key_s(bob),g))),dhexp_real(key_e(alice,bob,sid_5),dhexp_real(key_m(bob),g))),increment_nonce(minnonce)),hmac_hash1(hmac_hash1(hash(somename,empty),dhexp_real(key_e(alice,bob,sid_5),dhexp_real(key_s(bob),g))),dhexp_real(key_e(alice,bob,sid_5),dhexp_real(key_m(bob),g))),hash(hash(hash(hash(hash(hash(somename,empty),empty),validkey(dhexp_real(key_s(bob),g))),validkey(dhexp_real(key_m(bob),g))),validkey(dhexp_real(key_e(alice,bob,sid_5),g))),encrypt(hmac_hash2(hmac_hash1(hash(somename,empty),dhexp_real(key_e(alice,bob,sid_5),dhexp_real(key_s(bob),g))),dhexp_real(key_e(alice,bob,sid_5),dhexp_real(key_m(bob),g))),minnonce,hash(hash(hash(hash(hash(somename,empty),empty),validkey(dhexp_real(key_s(bob),g))),validkey(dhexp_real(key_m(bob),g))),validkey(dhexp_real(key_e(alice,bob,sid_5),g))),msg_a(alice,bob,sid_5)))),keypairpack(empty,empty),keypairpack(empty,empty),keypairpack(validkey(dhexp_real(key_e(alice,bob,sid_5),g)),key_e(alice,bob,sid_5)),validkey(dhexp_real(key_s(bob),g)),validkey(dhexp_real(key_m(bob),g)),empty,empty,true)))).

3. The entry statestore(bob,charlie,sid_6,statepack_a(handshakestatepack(symmetricstatepack(cipherstatepack(empty,minnonce),hash(somename,empty),hash(hash(hash(hash(somename,empty),empty),validkey(dhexp_real(key_s(bob),g))),validkey(dhexp_real(key_m(bob),g)))),keypairpack(validkey(dhexp_real(key_s(bob),g)),key_s(bob)),keypairpack(validkey(dhexp_real(key_m(bob),g)),key_m(bob)),keypairpack(empty,empty),empty,empty,empty,empty,false))) may be inserted in a table at insert {1647}.
table(statestore(bob,charlie,sid_6,statepack_a(handshakestatepack(symmetricstatepack(cipherstatepack(empty,minnonce),hash(somename,empty),hash(hash(hash(hash(somename,empty),empty),validkey(dhexp_real(key_s(bob),g))),validkey(dhexp_real(key_m(bob),g)))),keypairpack(validkey(dhexp_real(key_s(bob),g)),key_s(bob)),keypairpack(validkey(dhexp_real(key_m(bob),g)),key_m(bob)),keypairpack(empty,empty),empty,empty,empty,empty,false)))).

4. The entry statestore(alice,bob,sid_5,statepack_a(handshakestatepack(symmetricstatepack(cipherstatepack(empty,minnonce),hash(somename,empty),hash(hash(hash(hash(somename,empty),empty),validkey(dhexp_real(key_s(bob),g))),validkey(dhexp_real(key_m(bob),g)))),keypairpack(empty,empty),keypairpack(empty,empty),keypairpack(empty,empty),validkey(dhexp_real(key_s(bob),g)),validkey(dhexp_real(key_m(bob),g)),empty,empty,true))) that may be in a table by 1 may be read at get {163}.
The event SendMsg(alice,bob,stagepack_a(sid_5),msg_a(alice,bob,sid_5)) may be executed at {160}.
So the message concat3(validkey(dhexp_real(key_e(alice,bob,sid_5),g)),empty,encrypt(hmac_hash2(hmac_hash1(hash(somename,empty),dhexp_real(key_e(alice,bob,sid_5),dhexp_real(key_s(bob),g))),dhexp_real(key_e(alice,bob,sid_5),dhexp_real(key_m(bob),g))),minnonce,hash(hash(hash(hash(hash(somename,empty),empty),validkey(dhexp_real(key_s(bob),g))),validkey(dhexp_real(key_m(bob),g))),validkey(dhexp_real(key_e(alice,bob,sid_5),g))),msg_a(alice,bob,sid_5))) may be sent on channel pub at output {162}.
mess(pub,concat3(validkey(dhexp_real(key_e(alice,bob,sid_5),g)),empty,encrypt(hmac_hash2(hmac_hash1(hash(somename,empty),dhexp_real(key_e(alice,bob,sid_5),dhexp_real(key_s(bob),g))),dhexp_real(key_e(alice,bob,sid_5),dhexp_real(key_m(bob),g))),minnonce,hash(hash(hash(hash(hash(somename,empty),empty),validkey(dhexp_real(key_s(bob),g))),validkey(dhexp_real(key_m(bob),g))),validkey(dhexp_real(key_e(alice,bob,sid_5),g))),msg_a(alice,bob,sid_5)))).

5. The entry statestore(bob,charlie,sid_6,statepack_a(handshakestatepack(symmetricstatepack(cipherstatepack(empty,minnonce),hash(somename,empty),hash(hash(hash(hash(somename,empty),empty),validkey(dhexp_real(key_s(bob),g))),validkey(dhexp_real(key_m(bob),g)))),keypairpack(validkey(dhexp_real(key_s(bob),g)),key_s(bob)),keypairpack(validkey(dhexp_real(key_m(bob),g)),key_m(bob)),keypairpack(empty,empty),empty,empty,empty,empty,false))) that may be in a table by 3 may be read at get {1762}.
The message concat3(validkey(dhexp_real(key_e(alice,bob,sid_5),g)),empty,encrypt(hmac_hash2(hmac_hash1(hash(somename,empty),dhexp_real(key_e(alice,bob,sid_5),dhexp_real(key_s(bob),g))),dhexp_real(key_e(alice,bob,sid_5),dhexp_real(key_m(bob),g))),minnonce,hash(hash(hash(hash(hash(somename,empty),empty),validkey(dhexp_real(key_s(bob),g))),validkey(dhexp_real(key_m(bob),g))),validkey(dhexp_real(key_e(alice,bob,sid_5),g))),msg_a(alice,bob,sid_5))) that may be sent on channel pub by 4 may be received at input {1648}.
So the entry statestore(bob,charlie,sid_6,statepack_b(handshakestatepack(symmetricstatepack(cipherstatepack(hmac_hash2(hmac_hash1(hash(somename,empty),dhexp_real(key_e(alice,bob,sid_5),dhexp_real(key_s(bob),g))),dhexp_real(key_e(alice,bob,sid_5),dhexp_real(key_m(bob),g))),increment_nonce(minnonce)),hmac_hash1(hmac_hash1(hash(somename,empty),dhexp_real(key_e(alice,bob,sid_5),dhexp_real(key_s(bob),g))),dhexp_real(key_e(alice,bob,sid_5),dhexp_real(key_m(bob),g))),hash(hash(hash(hash(hash(hash(somename,empty),empty),validkey(dhexp_real(key_s(bob),g))),validkey(dhexp_real(key_m(bob),g))),validkey(dhexp_real(key_e(alice,bob,sid_5),g))),encrypt(hmac_hash2(hmac_hash1(hash(somename,empty),dhexp_real(key_e(alice,bob,sid_5),dhexp_real(key_s(bob),g))),dhexp_real(key_e(alice,bob,sid_5),dhexp_real(key_m(bob),g))),minnonce,hash(hash(hash(hash(hash(somename,empty),empty),validkey(dhexp_real(key_s(bob),g))),validkey(dhexp_real(key_m(bob),g))),validkey(dhexp_real(key_e(alice,bob,sid_5),g))),msg_a(alice,bob,sid_5)))),keypairpack(validkey(dhexp_real(key_s(bob),g)),key_s(bob)),keypairpack(validkey(dhexp_real(key_m(bob),g)),key_m(bob)),keypairpack(empty,empty),empty,empty,validkey(dhexp_real(key_e(alice,bob,sid_5),g)),empty,false))) may be inserted in a table at insert {1761}.
table(statestore(bob,charlie,sid_6,statepack_b(handshakestatepack(symmetricstatepack(cipherstatepack(hmac_hash2(hmac_hash1(hash(somename,empty),dhexp_real(key_e(alice,bob,sid_5),dhexp_real(key_s(bob),g))),dhexp_real(key_e(alice,bob,sid_5),dhexp_real(key_m(bob),g))),increment_nonce(minnonce)),hmac_hash1(hmac_hash1(hash(somename,empty),dhexp_real(key_e(alice,bob,sid_5),dhexp_real(key_s(bob),g))),dhexp_real(key_e(alice,bob,sid_5),dhexp_real(key_m(bob),g))),hash(hash(hash(hash(hash(hash(somename,empty),empty),validkey(dhexp_real(key_s(bob),g))),validkey(dhexp_real(key_m(bob),g))),validkey(dhexp_real(key_e(alice,bob,sid_5),g))),encrypt(hmac_hash2(hmac_hash1(hash(somename,empty),dhexp_real(key_e(alice,bob,sid_5),dhexp_real(key_s(bob),g))),dhexp_real(key_e(alice,bob,sid_5),dhexp_real(key_m(bob),g))),minnonce,hash(hash(hash(hash(hash(somename,empty),empty),validkey(dhexp_real(key_s(bob),g))),validkey(dhexp_real(key_m(bob),g))),validkey(dhexp_real(key_e(alice,bob,sid_5),g))),msg_a(alice,bob,sid_5)))),keypairpack(validkey(dhexp_real(key_s(bob),g)),key_s(bob)),keypairpack(validkey(dhexp_real(key_m(bob),g)),key_m(bob)),keypairpack(empty,empty),empty,empty,validkey(dhexp_real(key_e(alice,bob,sid_5),g)),empty,false)))).

6. The entry statestore(bob,charlie,sid_6,statepack_b(handshakestatepack(symmetricstatepack(cipherstatepack(hmac_hash2(hmac_hash1(hash(somename,empty),dhexp_real(key_e(alice,bob,sid_5),dhexp_real(key_s(bob),g))),dhexp_real(key_e(alice,bob,sid_5),dhexp_real(key_m(bob),g))),increment_nonce(minnonce)),hmac_hash1(hmac_hash1(hash(somename,empty),dhexp_real(key_e(alice,bob,sid_5),dhexp_real(key_s(bob),g))),dhexp_real(key_e(alice,bob,sid_5),dhexp_real(key_m(bob),g))),hash(hash(hash(hash(hash(hash(somename,empty),empty),validkey(dhexp_real(key_s(bob),g))),validkey(dhexp_real(key_m(bob),g))),validkey(dhexp_real(key_e(alice,bob,sid_5),g))),encrypt(hmac_hash2(hmac_hash1(hash(somename,empty),dhexp_real(key_e(alice,bob,sid_5),dhexp_real(key_s(bob),g))),dhexp_real(key_e(alice,bob,sid_5),dhexp_real(key_m(bob),g))),minnonce,hash(hash(hash(hash(hash(somename,empty),empty),validkey(dhexp_real(key_s(bob),g))),validkey(dhexp_real(key_m(bob),g))),validkey(dhexp_real(key_e(alice,bob,sid_5),g))),msg_a(alice,bob,sid_5)))),keypairpack(validkey(dhexp_real(key_s(bob),g)),key_s(bob)),keypairpack(validkey(dhexp_real(key_m(bob),g)),key_m(bob)),keypairpack(empty,empty),empty,empty,validkey(dhexp_real(key_e(alice,bob,sid_5),g)),empty,false))) that may be in a table by 5 may be read at get {1854}.
The event SendMsg(bob,charlie,stagepack_b(sid_6),msg_b(bob,charlie,sid_6)) may be executed at {1851}.
So the message concat3(validkey(dhexp_real(key_e(bob,charlie,sid_6),g)),empty,encrypt(hmac_hash2(hmac_hash1(hmac_hash1(hash(somename,empty),dhexp_real(key_e(alice,bob,sid_5),dhexp_real(key_s(bob),g))),dhexp_real(key_e(alice,bob,sid_5),dhexp_real(key_m(bob),g))),dhexp_real(key_e(alice,bob,sid_5),dhexp_real(key_e(bob,charlie,sid_6),g))),minnonce,hash(hash(hash(hash(hash(hash(hash(somename,empty),empty),validkey(dhexp_real(key_s(bob),g))),validkey(dhexp_real(key_m(bob),g))),validkey(dhexp_real(key_e(alice,bob,sid_5),g))),encrypt(hmac_hash2(hmac_hash1(hash(somename,empty),dhexp_real(key_e(alice,bob,sid_5),dhexp_real(key_s(bob),g))),dhexp_real(key_e(alice,bob,sid_5),dhexp_real(key_m(bob),g))),minnonce,hash(hash(hash(hash(hash(somename,empty),empty),validkey(dhexp_real(key_s(bob),g))),validkey(dhexp_real(key_m(bob),g))),validkey(dhexp_real(key_e(alice,bob,sid_5),g))),msg_a(alice,bob,sid_5))),validkey(dhexp_real(key_e(bob,charlie,sid_6),g))),msg_b(bob,charlie,sid_6))) may be sent on channel pub at output {1853}.
mess(pub,concat3(validkey(dhexp_real(key_e(bob,charlie,sid_6),g)),empty,encrypt(hmac_hash2(hmac_hash1(hmac_hash1(hash(somename,empty),dhexp_real(key_e(alice,bob,sid_5),dhexp_real(key_s(bob),g))),dhexp_real(key_e(alice,bob,sid_5),dhexp_real(key_m(bob),g))),dhexp_real(key_e(alice,bob,sid_5),dhexp_real(key_e(bob,charlie,sid_6),g))),minnonce,hash(hash(hash(hash(hash(hash(hash(somename,empty),empty),validkey(dhexp_real(key_s(bob),g))),validkey(dhexp_real(key_m(bob),g))),validkey(dhexp_real(key_e(alice,bob,sid_5),g))),encrypt(hmac_hash2(hmac_hash1(hash(somename,empty),dhexp_real(key_e(alice,bob,sid_5),dhexp_real(key_s(bob),g))),dhexp_real(key_e(alice,bob,sid_5),dhexp_real(key_m(bob),g))),minnonce,hash(hash(hash(hash(hash(somename,empty),empty),validkey(dhexp_real(key_s(bob),g))),validkey(dhexp_real(key_m(bob),g))),validkey(dhexp_real(key_e(alice,bob,sid_5),g))),msg_a(alice,bob,sid_5))),validkey(dhexp_real(key_e(bob,charlie,sid_6),g))),msg_b(bob,charlie,sid_6)))).

7. The entry statestore(alice,bob,sid_5,statepack_b(handshakestatepack(symmetricstatepack(cipherstatepack(hmac_hash2(hmac_hash1(hash(somename,empty),dhexp_real(key_e(alice,bob,sid_5),dhexp_real(key_s(bob),g))),dhexp_real(key_e(alice,bob,sid_5),dhexp_real(key_m(bob),g))),increment_nonce(minnonce)),hmac_hash1(hmac_hash1(hash(somename,empty),dhexp_real(key_e(alice,bob,sid_5),dhexp_real(key_s(bob),g))),dhexp_real(key_e(alice,bob,sid_5),dhexp_real(key_m(bob),g))),hash(hash(hash(hash(hash(hash(somename,empty),empty),validkey(dhexp_real(key_s(bob),g))),validkey(dhexp_real(key_m(bob),g))),validkey(dhexp_real(key_e(alice,bob,sid_5),g))),encrypt(hmac_hash2(hmac_hash1(hash(somename,empty),dhexp_real(key_e(alice,bob,sid_5),dhexp_real(key_s(bob),g))),dhexp_real(key_e(alice,bob,sid_5),dhexp_real(key_m(bob),g))),minnonce,hash(hash(hash(hash(hash(somename,empty),empty),validkey(dhexp_real(key_s(bob),g))),validkey(dhexp_real(key_m(bob),g))),validkey(dhexp_real(key_e(alice,bob,sid_5),g))),msg_a(alice,bob,sid_5)))),keypairpack(empty,empty),keypairpack(empty,empty),keypairpack(validkey(dhexp_real(key_e(alice,bob,sid_5),g)),key_e(alice,bob,sid_5)),validkey(dhexp_real(key_s(bob),g)),validkey(dhexp_real(key_m(bob),g)),empty,empty,true))) that may be in a table by 2 may be read at get {257}.
The message concat3(validkey(dhexp_real(key_e(bob,charlie,sid_6),g)),empty,encrypt(hmac_hash2(hmac_hash1(hmac_hash1(hash(somename,empty),dhexp_real(key_e(alice,bob,sid_5),dhexp_real(key_s(bob),g))),dhexp_real(key_e(alice,bob,sid_5),dhexp_real(key_m(bob),g))),dhexp_real(key_e(alice,bob,sid_5),dhexp_real(key_e(bob,charlie,sid_6),g))),minnonce,hash(hash(hash(hash(hash(hash(hash(somename,empty),empty),validkey(dhexp_real(key_s(bob),g))),validkey(dhexp_real(key_m(bob),g))),validkey(dhexp_real(key_e(alice,bob,sid_5),g))),encrypt(hmac_hash2(hmac_hash1(hash(somename,empty),dhexp_real(key_e(alice,bob,sid_5),dhexp_real(key_s(bob),g))),dhexp_real(key_e(alice,bob,sid_5),dhexp_real(key_m(bob),g))),minnonce,hash(hash(hash(hash(hash(somename,empty),empty),validkey(dhexp_real(key_s(bob),g))),validkey(dhexp_real(key_m(bob),g))),validkey(dhexp_real(key_e(alice,bob,sid_5),g))),msg_a(alice,bob,sid_5))),validkey(dhexp_real(key_e(bob,charlie,sid_6),g))),msg_b(bob,charlie,sid_6))) that may be sent on channel pub by 6 may be received at input {164}.
So event RecvMsg(alice,bob,stagepack_b(sid_5),msg_b(bob,charlie,sid_6)) may be executed at {255}.
end(RecvMsg(alice,bob,stagepack_b(sid_5),msg_b(bob,charlie,sid_6))).

8. By 7, end(RecvMsg(alice,bob,stagepack_b(sid_5),msg_b(bob,charlie,sid_6))).
The goal is reached, represented in the following fact:
end(RecvMsg(alice,bob,stagepack_b(sid_5),msg_b(bob,charlie,sid_6))).


RESULT event(RecvMsg(alice,bob,stagepack_b(sid_a),m_26)) ==> event(SendMsg(bob,alice,stagepack_b(sid_b),m_26)) || (event(LeakS(phase0,bob)) && event(LeakM(phase0,bob))) || (event(LeakS(phase0,alice)) && event(LeakM(phase0,alice))) cannot be proved.
Starting query event(RecvMsg(alice,bob,stagepack_b(sid_a),m_26)) ==> event(SendMsg(bob,alice,stagepack_b(sid_b),m_26)) || (event(LeakS(phase0,bob)) && event(LeakM(phase0,bob)))
goal reachable: begin(SendMsg(bob,charlie,stagepack_b(sid_5),msg_b(bob,charlie,sid_5))) && begin(SendMsg(alice,bob,stagepack_a(sid_6),msg_a(alice,bob,sid_6))) -> end(RecvMsg(alice,bob,stagepack_b(sid_6),msg_b(bob,charlie,sid_5)))
Abbreviations:
sid_6 = sid[!1 = @sid]
sid_5 = sid[!1 = @sid_1]

Derivation:
Abbreviations:
sid_5 = sid[!1 = @sid]
sid_6 = sid[!1 = @sid_1]

1. The entry statestore(alice,bob,sid_5,statepack_a(handshakestatepack(symmetricstatepack(cipherstatepack(empty,minnonce),hash(somename,empty),hash(hash(hash(hash(somename,empty),empty),validkey(dhexp_real(key_s(bob),g))),validkey(dhexp_real(key_m(bob),g)))),keypairpack(empty,empty),keypairpack(empty,empty),keypairpack(empty,empty),validkey(dhexp_real(key_s(bob),g)),validkey(dhexp_real(key_m(bob),g)),empty,empty,true))) may be inserted in a table at insert {50}.
table(statestore(alice,bob,sid_5,statepack_a(handshakestatepack(symmetricstatepack(cipherstatepack(empty,minnonce),hash(somename,empty),hash(hash(hash(hash(somename,empty),empty),validkey(dhexp_real(key_s(bob),g))),validkey(dhexp_real(key_m(bob),g)))),keypairpack(empty,empty),keypairpack(empty,empty),keypairpack(empty,empty),validkey(dhexp_real(key_s(bob),g)),validkey(dhexp_real(key_m(bob),g)),empty,empty,true)))).

2. The entry statestore(alice,bob,sid_5,statepack_a(handshakestatepack(symmetricstatepack(cipherstatepack(empty,minnonce),hash(somename,empty),hash(hash(hash(hash(somename,empty),empty),validkey(dhexp_real(key_s(bob),g))),validkey(dhexp_real(key_m(bob),g)))),keypairpack(empty,empty),keypairpack(empty,empty),keypairpack(empty,empty),validkey(dhexp_real(key_s(bob),g)),validkey(dhexp_real(key_m(bob),g)),empty,empty,true))) that may be in a table by 1 may be read at get {163}.
The event SendMsg(alice,bob,stagepack_a(sid_5),msg_a(alice,bob,sid_5)) may be executed at {160}.
So the entry statestore(alice,bob,sid_5,statepack_b(handshakestatepack(symmetricstatepack(cipherstatepack(hmac_hash2(hmac_hash1(hash(somename,empty),dhexp_real(key_e(alice,bob,sid_5),dhexp_real(key_s(bob),g))),dhexp_real(key_e(alice,bob,sid_5),dhexp_real(key_m(bob),g))),increment_nonce(minnonce)),hmac_hash1(hmac_hash1(hash(somename,empty),dhexp_real(key_e(alice,bob,sid_5),dhexp_real(key_s(bob),g))),dhexp_real(key_e(alice,bob,sid_5),dhexp_real(key_m(bob),g))),hash(hash(hash(hash(hash(hash(somename,empty),empty),validkey(dhexp_real(key_s(bob),g))),validkey(dhexp_real(key_m(bob),g))),validkey(dhexp_real(key_e(alice,bob,sid_5),g))),encrypt(hmac_hash2(hmac_hash1(hash(somename,empty),dhexp_real(key_e(alice,bob,sid_5),dhexp_real(key_s(bob),g))),dhexp_real(key_e(alice,bob,sid_5),dhexp_real(key_m(bob),g))),minnonce,hash(hash(hash(hash(hash(somename,empty),empty),validkey(dhexp_real(key_s(bob),g))),validkey(dhexp_real(key_m(bob),g))),validkey(dhexp_real(key_e(alice,bob,sid_5),g))),msg_a(alice,bob,sid_5)))),keypairpack(empty,empty),keypairpack(empty,empty),keypairpack(validkey(dhexp_real(key_e(alice,bob,sid_5),g)),key_e(alice,bob,sid_5)),validkey(dhexp_real(key_s(bob),g)),validkey(dhexp_real(key_m(bob),g)),empty,empty,true))) may be inserted in a table at insert {161}.
table(statestore(alice,bob,sid_5,statepack_b(handshakestatepack(symmetricstatepack(cipherstatepack(hmac_hash2(hmac_hash1(hash(somename,empty),dhexp_real(key_e(alice,bob,sid_5),dhexp_real(key_s(bob),g))),dhexp_real(key_e(alice,bob,sid_5),dhexp_real(key_m(bob),g))),increment_nonce(minnonce)),hmac_hash1(hmac_hash1(hash(somename,empty),dhexp_real(key_e(alice,bob,sid_5),dhexp_real(key_s(bob),g))),dhexp_real(key_e(alice,bob,sid_5),dhexp_real(key_m(bob),g))),hash(hash(hash(hash(hash(hash(somename,empty),empty),validkey(dhexp_real(key_s(bob),g))),validkey(dhexp_real(key_m(bob),g))),validkey(dhexp_real(key_e(alice,bob,sid_5),g))),encrypt(hmac_hash2(hmac_hash1(hash(somename,empty),dhexp_real(key_e(alice,bob,sid_5),dhexp_real(key_s(bob),g))),dhexp_real(key_e(alice,bob,sid_5),dhexp_real(key_m(bob),g))),minnonce,hash(hash(hash(hash(hash(somename,empty),empty),validkey(dhexp_real(key_s(bob),g))),validkey(dhexp_real(key_m(bob),g))),validkey(dhexp_real(key_e(alice,bob,sid_5),g))),msg_a(alice,bob,sid_5)))),keypairpack(empty,empty),keypairpack(empty,empty),keypairpack(validkey(dhexp_real(key_e(alice,bob,sid_5),g)),key_e(alice,bob,sid_5)),validkey(dhexp_real(key_s(bob),g)),validkey(dhexp_real(key_m(bob),g)),empty,empty,true)))).

3. The entry statestore(bob,charlie,sid_6,statepack_a(handshakestatepack(symmetricstatepack(cipherstatepack(empty,minnonce),hash(somename,empty),hash(hash(hash(hash(somename,empty),empty),validkey(dhexp_real(key_s(bob),g))),validkey(dhexp_real(key_m(bob),g)))),keypairpack(validkey(dhexp_real(key_s(bob),g)),key_s(bob)),keypairpack(validkey(dhexp_real(key_m(bob),g)),key_m(bob)),keypairpack(empty,empty),empty,empty,empty,empty,false))) may be inserted in a table at insert {1647}.
table(statestore(bob,charlie,sid_6,statepack_a(handshakestatepack(symmetricstatepack(cipherstatepack(empty,minnonce),hash(somename,empty),hash(hash(hash(hash(somename,empty),empty),validkey(dhexp_real(key_s(bob),g))),validkey(dhexp_real(key_m(bob),g)))),keypairpack(validkey(dhexp_real(key_s(bob),g)),key_s(bob)),keypairpack(validkey(dhexp_real(key_m(bob),g)),key_m(bob)),keypairpack(empty,empty),empty,empty,empty,empty,false)))).

4. The entry statestore(alice,bob,sid_5,statepack_a(handshakestatepack(symmetricstatepack(cipherstatepack(empty,minnonce),hash(somename,empty),hash(hash(hash(hash(somename,empty),empty),validkey(dhexp_real(key_s(bob),g))),validkey(dhexp_real(key_m(bob),g)))),keypairpack(empty,empty),keypairpack(empty,empty),keypairpack(empty,empty),validkey(dhexp_real(key_s(bob),g)),validkey(dhexp_real(key_m(bob),g)),empty,empty,true))) that may be in a table by 1 may be read at get {163}.
The event SendMsg(alice,bob,stagepack_a(sid_5),msg_a(alice,bob,sid_5)) may be executed at {160}.
So the message concat3(validkey(dhexp_real(key_e(alice,bob,sid_5),g)),empty,encrypt(hmac_hash2(hmac_hash1(hash(somename,empty),dhexp_real(key_e(alice,bob,sid_5),dhexp_real(key_s(bob),g))),dhexp_real(key_e(alice,bob,sid_5),dhexp_real(key_m(bob),g))),minnonce,hash(hash(hash(hash(hash(somename,empty),empty),validkey(dhexp_real(key_s(bob),g))),validkey(dhexp_real(key_m(bob),g))),validkey(dhexp_real(key_e(alice,bob,sid_5),g))),msg_a(alice,bob,sid_5))) may be sent on channel pub at output {162}.
mess(pub,concat3(validkey(dhexp_real(key_e(alice,bob,sid_5),g)),empty,encrypt(hmac_hash2(hmac_hash1(hash(somename,empty),dhexp_real(key_e(alice,bob,sid_5),dhexp_real(key_s(bob),g))),dhexp_real(key_e(alice,bob,sid_5),dhexp_real(key_m(bob),g))),minnonce,hash(hash(hash(hash(hash(somename,empty),empty),validkey(dhexp_real(key_s(bob),g))),validkey(dhexp_real(key_m(bob),g))),validkey(dhexp_real(key_e(alice,bob,sid_5),g))),msg_a(alice,bob,sid_5)))).

5. The entry statestore(bob,charlie,sid_6,statepack_a(handshakestatepack(symmetricstatepack(cipherstatepack(empty,minnonce),hash(somename,empty),hash(hash(hash(hash(somename,empty),empty),validkey(dhexp_real(key_s(bob),g))),validkey(dhexp_real(key_m(bob),g)))),keypairpack(validkey(dhexp_real(key_s(bob),g)),key_s(bob)),keypairpack(validkey(dhexp_real(key_m(bob),g)),key_m(bob)),keypairpack(empty,empty),empty,empty,empty,empty,false))) that may be in a table by 3 may be read at get {1762}.
The message concat3(validkey(dhexp_real(key_e(alice,bob,sid_5),g)),empty,encrypt(hmac_hash2(hmac_hash1(hash(somename,empty),dhexp_real(key_e(alice,bob,sid_5),dhexp_real(key_s(bob),g))),dhexp_real(key_e(alice,bob,sid_5),dhexp_real(key_m(bob),g))),minnonce,hash(hash(hash(hash(hash(somename,empty),empty),validkey(dhexp_real(key_s(bob),g))),validkey(dhexp_real(key_m(bob),g))),validkey(dhexp_real(key_e(alice,bob,sid_5),g))),msg_a(alice,bob,sid_5))) that may be sent on channel pub by 4 may be received at input {1648}.
So the entry statestore(bob,charlie,sid_6,statepack_b(handshakestatepack(symmetricstatepack(cipherstatepack(hmac_hash2(hmac_hash1(hash(somename,empty),dhexp_real(key_e(alice,bob,sid_5),dhexp_real(key_s(bob),g))),dhexp_real(key_e(alice,bob,sid_5),dhexp_real(key_m(bob),g))),increment_nonce(minnonce)),hmac_hash1(hmac_hash1(hash(somename,empty),dhexp_real(key_e(alice,bob,sid_5),dhexp_real(key_s(bob),g))),dhexp_real(key_e(alice,bob,sid_5),dhexp_real(key_m(bob),g))),hash(hash(hash(hash(hash(hash(somename,empty),empty),validkey(dhexp_real(key_s(bob),g))),validkey(dhexp_real(key_m(bob),g))),validkey(dhexp_real(key_e(alice,bob,sid_5),g))),encrypt(hmac_hash2(hmac_hash1(hash(somename,empty),dhexp_real(key_e(alice,bob,sid_5),dhexp_real(key_s(bob),g))),dhexp_real(key_e(alice,bob,sid_5),dhexp_real(key_m(bob),g))),minnonce,hash(hash(hash(hash(hash(somename,empty),empty),validkey(dhexp_real(key_s(bob),g))),validkey(dhexp_real(key_m(bob),g))),validkey(dhexp_real(key_e(alice,bob,sid_5),g))),msg_a(alice,bob,sid_5)))),keypairpack(validkey(dhexp_real(key_s(bob),g)),key_s(bob)),keypairpack(validkey(dhexp_real(key_m(bob),g)),key_m(bob)),keypairpack(empty,empty),empty,empty,validkey(dhexp_real(key_e(alice,bob,sid_5),g)),empty,false))) may be inserted in a table at insert {1761}.
table(statestore(bob,charlie,sid_6,statepack_b(handshakestatepack(symmetricstatepack(cipherstatepack(hmac_hash2(hmac_hash1(hash(somename,empty),dhexp_real(key_e(alice,bob,sid_5),dhexp_real(key_s(bob),g))),dhexp_real(key_e(alice,bob,sid_5),dhexp_real(key_m(bob),g))),increment_nonce(minnonce)),hmac_hash1(hmac_hash1(hash(somename,empty),dhexp_real(key_e(alice,bob,sid_5),dhexp_real(key_s(bob),g))),dhexp_real(key_e(alice,bob,sid_5),dhexp_real(key_m(bob),g))),hash(hash(hash(hash(hash(hash(somename,empty),empty),validkey(dhexp_real(key_s(bob),g))),validkey(dhexp_real(key_m(bob),g))),validkey(dhexp_real(key_e(alice,bob,sid_5),g))),encrypt(hmac_hash2(hmac_hash1(hash(somename,empty),dhexp_real(key_e(alice,bob,sid_5),dhexp_real(key_s(bob),g))),dhexp_real(key_e(alice,bob,sid_5),dhexp_real(key_m(bob),g))),minnonce,hash(hash(hash(hash(hash(somename,empty),empty),validkey(dhexp_real(key_s(bob),g))),validkey(dhexp_real(key_m(bob),g))),validkey(dhexp_real(key_e(alice,bob,sid_5),g))),msg_a(alice,bob,sid_5)))),keypairpack(validkey(dhexp_real(key_s(bob),g)),key_s(bob)),keypairpack(validkey(dhexp_real(key_m(bob),g)),key_m(bob)),keypairpack(empty,empty),empty,empty,validkey(dhexp_real(key_e(alice,bob,sid_5),g)),empty,false)))).

6. The entry statestore(bob,charlie,sid_6,statepack_b(handshakestatepack(symmetricstatepack(cipherstatepack(hmac_hash2(hmac_hash1(hash(somename,empty),dhexp_real(key_e(alice,bob,sid_5),dhexp_real(key_s(bob),g))),dhexp_real(key_e(alice,bob,sid_5),dhexp_real(key_m(bob),g))),increment_nonce(minnonce)),hmac_hash1(hmac_hash1(hash(somename,empty),dhexp_real(key_e(alice,bob,sid_5),dhexp_real(key_s(bob),g))),dhexp_real(key_e(alice,bob,sid_5),dhexp_real(key_m(bob),g))),hash(hash(hash(hash(hash(hash(somename,empty),empty),validkey(dhexp_real(key_s(bob),g))),validkey(dhexp_real(key_m(bob),g))),validkey(dhexp_real(key_e(alice,bob,sid_5),g))),encrypt(hmac_hash2(hmac_hash1(hash(somename,empty),dhexp_real(key_e(alice,bob,sid_5),dhexp_real(key_s(bob),g))),dhexp_real(key_e(alice,bob,sid_5),dhexp_real(key_m(bob),g))),minnonce,hash(hash(hash(hash(hash(somename,empty),empty),validkey(dhexp_real(key_s(bob),g))),validkey(dhexp_real(key_m(bob),g))),validkey(dhexp_real(key_e(alice,bob,sid_5),g))),msg_a(alice,bob,sid_5)))),keypairpack(validkey(dhexp_real(key_s(bob),g)),key_s(bob)),keypairpack(validkey(dhexp_real(key_m(bob),g)),key_m(bob)),keypairpack(empty,empty),empty,empty,validkey(dhexp_real(key_e(alice,bob,sid_5),g)),empty,false))) that may be in a table by 5 may be read at get {1854}.
The event SendMsg(bob,charlie,stagepack_b(sid_6),msg_b(bob,charlie,sid_6)) may be executed at {1851}.
So the message concat3(validkey(dhexp_real(key_e(bob,charlie,sid_6),g)),empty,encrypt(hmac_hash2(hmac_hash1(hmac_hash1(hash(somename,empty),dhexp_real(key_e(alice,bob,sid_5),dhexp_real(key_s(bob),g))),dhexp_real(key_e(alice,bob,sid_5),dhexp_real(key_m(bob),g))),dhexp_real(key_e(alice,bob,sid_5),dhexp_real(key_e(bob,charlie,sid_6),g))),minnonce,hash(hash(hash(hash(hash(hash(hash(somename,empty),empty),validkey(dhexp_real(key_s(bob),g))),validkey(dhexp_real(key_m(bob),g))),validkey(dhexp_real(key_e(alice,bob,sid_5),g))),encrypt(hmac_hash2(hmac_hash1(hash(somename,empty),dhexp_real(key_e(alice,bob,sid_5),dhexp_real(key_s(bob),g))),dhexp_real(key_e(alice,bob,sid_5),dhexp_real(key_m(bob),g))),minnonce,hash(hash(hash(hash(hash(somename,empty),empty),validkey(dhexp_real(key_s(bob),g))),validkey(dhexp_real(key_m(bob),g))),validkey(dhexp_real(key_e(alice,bob,sid_5),g))),msg_a(alice,bob,sid_5))),validkey(dhexp_real(key_e(bob,charlie,sid_6),g))),msg_b(bob,charlie,sid_6))) may be sent on channel pub at output {1853}.
mess(pub,concat3(validkey(dhexp_real(key_e(bob,charlie,sid_6),g)),empty,encrypt(hmac_hash2(hmac_hash1(hmac_hash1(hash(somename,empty),dhexp_real(key_e(alice,bob,sid_5),dhexp_real(key_s(bob),g))),dhexp_real(key_e(alice,bob,sid_5),dhexp_real(key_m(bob),g))),dhexp_real(key_e(alice,bob,sid_5),dhexp_real(key_e(bob,charlie,sid_6),g))),minnonce,hash(hash(hash(hash(hash(hash(hash(somename,empty),empty),validkey(dhexp_real(key_s(bob),g))),validkey(dhexp_real(key_m(bob),g))),validkey(dhexp_real(key_e(alice,bob,sid_5),g))),encrypt(hmac_hash2(hmac_hash1(hash(somename,empty),dhexp_real(key_e(alice,bob,sid_5),dhexp_real(key_s(bob),g))),dhexp_real(key_e(alice,bob,sid_5),dhexp_real(key_m(bob),g))),minnonce,hash(hash(hash(hash(hash(somename,empty),empty),validkey(dhexp_real(key_s(bob),g))),validkey(dhexp_real(key_m(bob),g))),validkey(dhexp_real(key_e(alice,bob,sid_5),g))),msg_a(alice,bob,sid_5))),validkey(dhexp_real(key_e(bob,charlie,sid_6),g))),msg_b(bob,charlie,sid_6)))).

7. The entry statestore(alice,bob,sid_5,statepack_b(handshakestatepack(symmetricstatepack(cipherstatepack(hmac_hash2(hmac_hash1(hash(somename,empty),dhexp_real(key_e(alice,bob,sid_5),dhexp_real(key_s(bob),g))),dhexp_real(key_e(alice,bob,sid_5),dhexp_real(key_m(bob),g))),increment_nonce(minnonce)),hmac_hash1(hmac_hash1(hash(somename,empty),dhexp_real(key_e(alice,bob,sid_5),dhexp_real(key_s(bob),g))),dhexp_real(key_e(alice,bob,sid_5),dhexp_real(key_m(bob),g))),hash(hash(hash(hash(hash(hash(somename,empty),empty),validkey(dhexp_real(key_s(bob),g))),validkey(dhexp_real(key_m(bob),g))),validkey(dhexp_real(key_e(alice,bob,sid_5),g))),encrypt(hmac_hash2(hmac_hash1(hash(somename,empty),dhexp_real(key_e(alice,bob,sid_5),dhexp_real(key_s(bob),g))),dhexp_real(key_e(alice,bob,sid_5),dhexp_real(key_m(bob),g))),minnonce,hash(hash(hash(hash(hash(somename,empty),empty),validkey(dhexp_real(key_s(bob),g))),validkey(dhexp_real(key_m(bob),g))),validkey(dhexp_real(key_e(alice,bob,sid_5),g))),msg_a(alice,bob,sid_5)))),keypairpack(empty,empty),keypairpack(empty,empty),keypairpack(validkey(dhexp_real(key_e(alice,bob,sid_5),g)),key_e(alice,bob,sid_5)),validkey(dhexp_real(key_s(bob),g)),validkey(dhexp_real(key_m(bob),g)),empty,empty,true))) that may be in a table by 2 may be read at get {257}.
The message concat3(validkey(dhexp_real(key_e(bob,charlie,sid_6),g)),empty,encrypt(hmac_hash2(hmac_hash1(hmac_hash1(hash(somename,empty),dhexp_real(key_e(alice,bob,sid_5),dhexp_real(key_s(bob),g))),dhexp_real(key_e(alice,bob,sid_5),dhexp_real(key_m(bob),g))),dhexp_real(key_e(alice,bob,sid_5),dhexp_real(key_e(bob,charlie,sid_6),g))),minnonce,hash(hash(hash(hash(hash(hash(hash(somename,empty),empty),validkey(dhexp_real(key_s(bob),g))),validkey(dhexp_real(key_m(bob),g))),validkey(dhexp_real(key_e(alice,bob,sid_5),g))),encrypt(hmac_hash2(hmac_hash1(hash(somename,empty),dhexp_real(key_e(alice,bob,sid_5),dhexp_real(key_s(bob),g))),dhexp_real(key_e(alice,bob,sid_5),dhexp_real(key_m(bob),g))),minnonce,hash(hash(hash(hash(hash(somename,empty),empty),validkey(dhexp_real(key_s(bob),g))),validkey(dhexp_real(key_m(bob),g))),validkey(dhexp_real(key_e(alice,bob,sid_5),g))),msg_a(alice,bob,sid_5))),validkey(dhexp_real(key_e(bob,charlie,sid_6),g))),msg_b(bob,charlie,sid_6))) that may be sent on channel pub by 6 may be received at input {164}.
So event RecvMsg(alice,bob,stagepack_b(sid_5),msg_b(bob,charlie,sid_6)) may be executed at {255}.
end(RecvMsg(alice,bob,stagepack_b(sid_5),msg_b(bob,charlie,sid_6))).

8. By 7, end(RecvMsg(alice,bob,stagepack_b(sid_5),msg_b(bob,charlie,sid_6))).
The goal is reached, represented in the following fact:
end(RecvMsg(alice,bob,stagepack_b(sid_5),msg_b(bob,charlie,sid_6))).


RESULT event(RecvMsg(alice,bob,stagepack_b(sid_a),m_26)) ==> event(SendMsg(bob,alice,stagepack_b(sid_b),m_26)) || (event(LeakS(phase0,bob)) && event(LeakM(phase0,bob))) cannot be proved.
Starting query not attacker_p1(msg_b(bob,alice,sid_b))
RESULT not attacker_p1(msg_b(bob,alice,sid_b)) is true.
Starting query attacker_p1(msg_b(bob,alice,sid_b)) ==> event(LeakS(px,alice)) && event(LeakM(px,alice))
RESULT attacker_p1(msg_b(bob,alice,sid_b)) ==> event(LeakS(px,alice)) && event(LeakM(px,alice)) is true.
Starting query attacker_p1(msg_b(bob,alice,sid_b)) ==> (event(LeakS(phase0,alice)) && event(LeakM(phase0,alice))) || (event(LeakS(px,alice)) && event(LeakM(px,alice)) && event(LeakS(pz,bob)) && event(LeakM(pz,bob)))
RESULT attacker_p1(msg_b(bob,alice,sid_b)) ==> (event(LeakS(phase0,alice)) && event(LeakM(phase0,alice))) || (event(LeakS(px,alice)) && event(LeakM(px,alice)) && event(LeakS(pz,bob)) && event(LeakM(pz,bob))) is true.
Starting query attacker_p1(msg_b(bob,alice,sid_b)) ==> event(LeakS(phase0,alice)) && event(LeakM(phase0,alice))
RESULT attacker_p1(msg_b(bob,alice,sid_b)) ==> event(LeakS(phase0,alice)) && event(LeakM(phase0,alice)) is true.
Starting query event(RecvMsg(bob,alice,stagepack_c(sid_b),m_26)) ==> event(SendMsg(alice,bob,stagepack_c(sid_a),m_26))
RESULT event(RecvMsg(bob,alice,stagepack_c(sid_b),m_26)) ==> event(SendMsg(alice,bob,stagepack_c(sid_a),m_26)) is true.
Starting query event(RecvMsg(bob,alice,stagepack_c(sid_b),m_26)) ==> event(SendMsg(alice,c,stagepack_c(sid_a),m_26)) || (event(LeakS(phase0,alice)) && event(LeakM(phase0,alice))) || (event(LeakS(phase0,bob)) && event(LeakM(phase0,bob)))
RESULT event(RecvMsg(bob,alice,stagepack_c(sid_b),m_26)) ==> event(SendMsg(alice,c,stagepack_c(sid_a),m_26)) || (event(LeakS(phase0,alice)) && event(LeakM(phase0,alice))) || (event(LeakS(phase0,bob)) && event(LeakM(phase0,bob))) is true.
Starting query event(RecvMsg(bob,alice,stagepack_c(sid_b),m_26)) ==> event(SendMsg(alice,c,stagepack_c(sid_a),m_26)) || (event(LeakS(phase0,alice)) && event(LeakM(phase0,alice)))
RESULT event(RecvMsg(bob,alice,stagepack_c(sid_b),m_26)) ==> event(SendMsg(alice,c,stagepack_c(sid_a),m_26)) || (event(LeakS(phase0,alice)) && event(LeakM(phase0,alice))) is true.
Starting query event(RecvMsg(bob,alice,stagepack_c(sid_b),m_26)) ==> event(SendMsg(alice,bob,stagepack_c(sid_a),m_26)) || (event(LeakS(phase0,alice)) && event(LeakM(phase0,alice))) || (event(LeakS(phase0,bob)) && event(LeakM(phase0,bob)))
RESULT event(RecvMsg(bob,alice,stagepack_c(sid_b),m_26)) ==> event(SendMsg(alice,bob,stagepack_c(sid_a),m_26)) || (event(LeakS(phase0,alice)) && event(LeakM(phase0,alice))) || (event(LeakS(phase0,bob)) && event(LeakM(phase0,bob))) is true.
Starting query event(RecvMsg(bob,alice,stagepack_c(sid_b),m_26)) ==> event(SendMsg(alice,bob,stagepack_c(sid_a),m_26)) || (event(LeakS(phase0,alice)) && event(LeakM(phase0,alice)))
RESULT event(RecvMsg(bob,alice,stagepack_c(sid_b),m_26)) ==> event(SendMsg(alice,bob,stagepack_c(sid_a),m_26)) || (event(LeakS(phase0,alice)) && event(LeakM(phase0,alice))) is true.
Starting query not attacker_p1(msg_c(alice,bob,sid_a))
RESULT not attacker_p1(msg_c(alice,bob,sid_a)) is true.
Starting query attacker_p1(msg_c(alice,bob,sid_a)) ==> event(LeakS(px,bob)) && event(LeakM(px,bob))
RESULT attacker_p1(msg_c(alice,bob,sid_a)) ==> event(LeakS(px,bob)) && event(LeakM(px,bob)) is true.
Starting query attacker_p1(msg_c(alice,bob,sid_a)) ==> (event(LeakS(phase0,bob)) && event(LeakM(phase0,bob))) || (event(LeakS(px,bob)) && event(LeakM(px,bob)) && event(LeakS(pz,alice)) && event(LeakM(pz,alice)))
RESULT attacker_p1(msg_c(alice,bob,sid_a)) ==> (event(LeakS(phase0,bob)) && event(LeakM(phase0,bob))) || (event(LeakS(px,bob)) && event(LeakM(px,bob)) && event(LeakS(pz,alice)) && event(LeakM(pz,alice))) is true.
Starting query attacker_p1(msg_c(alice,bob,sid_a)) ==> event(LeakS(phase0,bob)) && event(LeakM(phase0,bob))
RESULT attacker_p1(msg_c(alice,bob,sid_a)) ==> event(LeakS(phase0,bob)) && event(LeakM(phase0,bob)) is true.
Starting query event(RecvMsg(alice,bob,stagepack_d(sid_a),m_26)) ==> event(SendMsg(bob,alice,stagepack_d(sid_b),m_26))
RESULT event(RecvMsg(alice,bob,stagepack_d(sid_a),m_26)) ==> event(SendMsg(bob,alice,stagepack_d(sid_b),m_26)) is true.
Starting query event(RecvMsg(alice,bob,stagepack_d(sid_a),m_26)) ==> event(SendMsg(bob,c,stagepack_d(sid_b),m_26)) || (event(LeakS(phase0,bob)) && event(LeakM(phase0,bob))) || (event(LeakS(phase0,alice)) && event(LeakM(phase0,alice)))
RESULT event(RecvMsg(alice,bob,stagepack_d(sid_a),m_26)) ==> event(SendMsg(bob,c,stagepack_d(sid_b),m_26)) || (event(LeakS(phase0,bob)) && event(LeakM(phase0,bob))) || (event(LeakS(phase0,alice)) && event(LeakM(phase0,alice))) is true.
Starting query event(RecvMsg(alice,bob,stagepack_d(sid_a),m_26)) ==> event(SendMsg(bob,c,stagepack_d(sid_b),m_26)) || (event(LeakS(phase0,bob)) && event(LeakM(phase0,bob)))
RESULT event(RecvMsg(alice,bob,stagepack_d(sid_a),m_26)) ==> event(SendMsg(bob,c,stagepack_d(sid_b),m_26)) || (event(LeakS(phase0,bob)) && event(LeakM(phase0,bob))) is true.
Starting query event(RecvMsg(alice,bob,stagepack_d(sid_a),m_26)) ==> event(SendMsg(bob,alice,stagepack_d(sid_b),m_26)) || (event(LeakS(phase0,bob)) && event(LeakM(phase0,bob))) || (event(LeakS(phase0,alice)) && event(LeakM(phase0,alice)))
RESULT event(RecvMsg(alice,bob,stagepack_d(sid_a),m_26)) ==> event(SendMsg(bob,alice,stagepack_d(sid_b),m_26)) || (event(LeakS(phase0,bob)) && event(LeakM(phase0,bob))) || (event(LeakS(phase0,alice)) && event(LeakM(phase0,alice))) is true.
Starting query event(RecvMsg(alice,bob,stagepack_d(sid_a),m_26)) ==> event(SendMsg(bob,alice,stagepack_d(sid_b),m_26)) || (event(LeakS(phase0,bob)) && event(LeakM(phase0,bob)))
RESULT event(RecvMsg(alice,bob,stagepack_d(sid_a),m_26)) ==> event(SendMsg(bob,alice,stagepack_d(sid_b),m_26)) || (event(LeakS(phase0,bob)) && event(LeakM(phase0,bob))) is true.
Starting query not attacker_p1(msg_d(bob,alice,sid_b))
RESULT not attacker_p1(msg_d(bob,alice,sid_b)) is true.
Starting query attacker_p1(msg_d(bob,alice,sid_b)) ==> event(LeakS(px,alice)) && event(LeakM(px,alice))
RESULT attacker_p1(msg_d(bob,alice,sid_b)) ==> event(LeakS(px,alice)) && event(LeakM(px,alice)) is true.
Starting query attacker_p1(msg_d(bob,alice,sid_b)) ==> (event(LeakS(phase0,alice)) && event(LeakM(phase0,alice))) || (event(LeakS(px,alice)) && event(LeakM(px,alice)) && event(LeakS(pz,bob)) && event(LeakM(pz,bob)))
RESULT attacker_p1(msg_d(bob,alice,sid_b)) ==> (event(LeakS(phase0,alice)) && event(LeakM(phase0,alice))) || (event(LeakS(px,alice)) && event(LeakM(px,alice)) && event(LeakS(pz,bob)) && event(LeakM(pz,bob))) is true.
Starting query attacker_p1(msg_d(bob,alice,sid_b)) ==> event(LeakS(phase0,alice)) && event(LeakM(phase0,alice))
RESULT attacker_p1(msg_d(bob,alice,sid_b)) ==> event(LeakS(phase0,alice)) && event(LeakM(phase0,alice)) is true.
Starting query event(RecvMsg(bob,alice,stagepack_e(sid_b),m_26)) ==> event(SendMsg(alice,bob,stagepack_e(sid_a),m_26))
RESULT event(RecvMsg(bob,alice,stagepack_e(sid_b),m_26)) ==> event(SendMsg(alice,bob,stagepack_e(sid_a),m_26)) is true.
Starting query event(RecvMsg(bob,alice,stagepack_e(sid_b),m_26)) ==> event(SendMsg(alice,c,stagepack_e(sid_a),m_26)) || (event(LeakS(phase0,alice)) && event(LeakM(phase0,alice))) || (event(LeakS(phase0,bob)) && event(LeakM(phase0,bob)))
RESULT event(RecvMsg(bob,alice,stagepack_e(sid_b),m_26)) ==> event(SendMsg(alice,c,stagepack_e(sid_a),m_26)) || (event(LeakS(phase0,alice)) && event(LeakM(phase0,alice))) || (event(LeakS(phase0,bob)) && event(LeakM(phase0,bob))) is true.
Starting query event(RecvMsg(bob,alice,stagepack_e(sid_b),m_26)) ==> event(SendMsg(alice,c,stagepack_e(sid_a),m_26)) || (event(LeakS(phase0,alice)) && event(LeakM(phase0,alice)))
RESULT event(RecvMsg(bob,alice,stagepack_e(sid_b),m_26)) ==> event(SendMsg(alice,c,stagepack_e(sid_a),m_26)) || (event(LeakS(phase0,alice)) && event(LeakM(phase0,alice))) is true.
Starting query event(RecvMsg(bob,alice,stagepack_e(sid_b),m_26)) ==> event(SendMsg(alice,bob,stagepack_e(sid_a),m_26)) || (event(LeakS(phase0,alice)) && event(LeakM(phase0,alice))) || (event(LeakS(phase0,bob)) && event(LeakM(phase0,bob)))
RESULT event(RecvMsg(bob,alice,stagepack_e(sid_b),m_26)) ==> event(SendMsg(alice,bob,stagepack_e(sid_a),m_26)) || (event(LeakS(phase0,alice)) && event(LeakM(phase0,alice))) || (event(LeakS(phase0,bob)) && event(LeakM(phase0,bob))) is true.
Starting query event(RecvMsg(bob,alice,stagepack_e(sid_b),m_26)) ==> event(SendMsg(alice,bob,stagepack_e(sid_a),m_26)) || (event(LeakS(phase0,alice)) && event(LeakM(phase0,alice)))
RESULT event(RecvMsg(bob,alice,stagepack_e(sid_b),m_26)) ==> event(SendMsg(alice,bob,stagepack_e(sid_a),m_26)) || (event(LeakS(phase0,alice)) && event(LeakM(phase0,alice))) is true.
Starting query not attacker_p1(msg_e(alice,bob,sid_a))
RESULT not attacker_p1(msg_e(alice,bob,sid_a)) is true.
Starting query attacker_p1(msg_e(alice,bob,sid_a)) ==> event(LeakS(px,bob)) && event(LeakM(px,bob))
RESULT attacker_p1(msg_e(alice,bob,sid_a)) ==> event(LeakS(px,bob)) && event(LeakM(px,bob)) is true.
Starting query attacker_p1(msg_e(alice,bob,sid_a)) ==> event(LeakS(phase0,bob)) || (event(LeakS(px,bob)) && event(LeakM(px,bob)) && event(LeakS(pz,alice)) && event(LeakM(pz,alice)))
RESULT attacker_p1(msg_e(alice,bob,sid_a)) ==> event(LeakS(phase0,bob)) || (event(LeakS(px,bob)) && event(LeakM(px,bob)) && event(LeakS(pz,alice)) && event(LeakM(pz,alice))) is true.
Starting query attacker_p1(msg_e(alice,bob,sid_a)) ==> event(LeakS(phase0,bob)) && event(LeakM(phase0,bob))
RESULT attacker_p1(msg_e(alice,bob,sid_a)) ==> event(LeakS(phase0,bob)) && event(LeakM(phase0,bob)) is true.
Starting query not event(RecvEnd(true))
RESULT not event(RecvEnd(true)) is true.

--------------------------------------------------------------
Verification summary:

Query event(RecvMsg(bob,alice,stagepack_a(sid_b),m_26)) ==> event(SendMsg(alice,bob,stagepack_a(sid_a),m_26)) is true.

Query event(RecvMsg(bob,alice,stagepack_a(sid_b),m_26)) ==> event(SendMsg(alice,c,stagepack_a(sid_a),m_26)) || (event(LeakS(phase0,alice)) && event(LeakM(phase0,alice))) || (event(LeakS(phase0,bob)) && event(LeakM(phase0,bob))) is true.

Query event(RecvMsg(bob,alice,stagepack_a(sid_b),m_26)) ==> event(SendMsg(alice,c,stagepack_a(sid_a),m_26)) || (event(LeakS(phase0,alice)) && event(LeakM(phase0,alice))) is true.

Query event(RecvMsg(bob,alice,stagepack_a(sid_b),m_26)) ==> event(SendMsg(alice,bob,stagepack_a(sid_a),m_26)) || (event(LeakS(phase0,alice)) && event(LeakM(phase0,alice))) || (event(LeakS(phase0,bob)) && event(LeakM(phase0,bob))) is true.

Query event(RecvMsg(bob,alice,stagepack_a(sid_b),m_26)) ==> event(SendMsg(alice,bob,stagepack_a(sid_a),m_26)) || (event(LeakS(phase0,alice)) && event(LeakM(phase0,alice))) is true.

Query not attacker_p1(msg_a(alice,bob,sid_a)) cannot be proved.

Query attacker_p1(msg_a(alice,bob,sid_a)) ==> event(LeakS(px,bob)) && event(LeakM(px,bob)) is true.

Query attacker_p1(msg_a(alice,bob,sid_a)) ==> (event(LeakS(phase0,bob)) && event(LeakM(phase0,bob))) || (event(LeakS(px,bob)) && event(LeakM(px,bob)) && event(LeakS(pz,alice)) && event(LeakM(pz,alice))) cannot be proved.

Query attacker_p1(msg_a(alice,bob,sid_a)) ==> event(LeakS(phase0,bob)) && event(LeakM(phase0,bob)) cannot be proved.

Query event(RecvMsg(alice,bob,stagepack_b(sid_a),m_26)) ==> event(SendMsg(bob,alice,stagepack_b(sid_b),m_26)) cannot be proved.

Query event(RecvMsg(alice,bob,stagepack_b(sid_a),m_26)) ==> event(SendMsg(bob,c,stagepack_b(sid_b),m_26)) || (event(LeakS(phase0,bob)) && event(LeakM(phase0,bob))) || (event(LeakS(phase0,alice)) && event(LeakM(phase0,alice))) is true.

Query event(RecvMsg(alice,bob,stagepack_b(sid_a),m_26)) ==> event(SendMsg(bob,c,stagepack_b(sid_b),m_26)) || (event(LeakS(phase0,bob)) && event(LeakM(phase0,bob))) is true.

Query event(RecvMsg(alice,bob,stagepack_b(sid_a),m_26)) ==> event(SendMsg(bob,alice,stagepack_b(sid_b),m_26)) || (event(LeakS(phase0,bob)) && event(LeakM(phase0,bob))) || (event(LeakS(phase0,alice)) && event(LeakM(phase0,alice))) cannot be proved.

Query event(RecvMsg(alice,bob,stagepack_b(sid_a),m_26)) ==> event(SendMsg(bob,alice,stagepack_b(sid_b),m_26)) || (event(LeakS(phase0,bob)) && event(LeakM(phase0,bob))) cannot be proved.

Query not attacker_p1(msg_b(bob,alice,sid_b)) is true.

Query attacker_p1(msg_b(bob,alice,sid_b)) ==> event(LeakS(px,alice)) && event(LeakM(px,alice)) is true.

Query attacker_p1(msg_b(bob,alice,sid_b)) ==> (event(LeakS(phase0,alice)) && event(LeakM(phase0,alice))) || (event(LeakS(px,alice)) && event(LeakM(px,alice)) && event(LeakS(pz,bob)) && event(LeakM(pz,bob))) is true.

Query attacker_p1(msg_b(bob,alice,sid_b)) ==> event(LeakS(phase0,alice)) && event(LeakM(phase0,alice)) is true.

Query event(RecvMsg(bob,alice,stagepack_c(sid_b),m_26)) ==> event(SendMsg(alice,bob,stagepack_c(sid_a),m_26)) is true.

Query event(RecvMsg(bob,alice,stagepack_c(sid_b),m_26)) ==> event(SendMsg(alice,c,stagepack_c(sid_a),m_26)) || (event(LeakS(phase0,alice)) && event(LeakM(phase0,alice))) || (event(LeakS(phase0,bob)) && event(LeakM(phase0,bob))) is true.

Query event(RecvMsg(bob,alice,stagepack_c(sid_b),m_26)) ==> event(SendMsg(alice,c,stagepack_c(sid_a),m_26)) || (event(LeakS(phase0,alice)) && event(LeakM(phase0,alice))) is true.

Query event(RecvMsg(bob,alice,stagepack_c(sid_b),m_26)) ==> event(SendMsg(alice,bob,stagepack_c(sid_a),m_26)) || (event(LeakS(phase0,alice)) && event(LeakM(phase0,alice))) || (event(LeakS(phase0,bob)) && event(LeakM(phase0,bob))) is true.

Query event(RecvMsg(bob,alice,stagepack_c(sid_b),m_26)) ==> event(SendMsg(alice,bob,stagepack_c(sid_a),m_26)) || (event(LeakS(phase0,alice)) && event(LeakM(phase0,alice))) is true.

Query not attacker_p1(msg_c(alice,bob,sid_a)) is true.

Query attacker_p1(msg_c(alice,bob,sid_a)) ==> event(LeakS(px,bob)) && event(LeakM(px,bob)) is true.

Query attacker_p1(msg_c(alice,bob,sid_a)) ==> (event(LeakS(phase0,bob)) && event(LeakM(phase0,bob))) || (event(LeakS(px,bob)) && event(LeakM(px,bob)) && event(LeakS(pz,alice)) && event(LeakM(pz,alice))) is true.

Query attacker_p1(msg_c(alice,bob,sid_a)) ==> event(LeakS(phase0,bob)) && event(LeakM(phase0,bob)) is true.

Query event(RecvMsg(alice,bob,stagepack_d(sid_a),m_26)) ==> event(SendMsg(bob,alice,stagepack_d(sid_b),m_26)) is true.

Query event(RecvMsg(alice,bob,stagepack_d(sid_a),m_26)) ==> event(SendMsg(bob,c,stagepack_d(sid_b),m_26)) || (event(LeakS(phase0,bob)) && event(LeakM(phase0,bob))) || (event(LeakS(phase0,alice)) && event(LeakM(phase0,alice))) is true.

Query event(RecvMsg(alice,bob,stagepack_d(sid_a),m_26)) ==> event(SendMsg(bob,c,stagepack_d(sid_b),m_26)) || (event(LeakS(phase0,bob)) && event(LeakM(phase0,bob))) is true.

Query event(RecvMsg(alice,bob,stagepack_d(sid_a),m_26)) ==> event(SendMsg(bob,alice,stagepack_d(sid_b),m_26)) || (event(LeakS(phase0,bob)) && event(LeakM(phase0,bob))) || (event(LeakS(phase0,alice)) && event(LeakM(phase0,alice))) is true.

Query event(RecvMsg(alice,bob,stagepack_d(sid_a),m_26)) ==> event(SendMsg(bob,alice,stagepack_d(sid_b),m_26)) || (event(LeakS(phase0,bob)) && event(LeakM(phase0,bob))) is true.

Query not attacker_p1(msg_d(bob,alice,sid_b)) is true.

Query attacker_p1(msg_d(bob,alice,sid_b)) ==> event(LeakS(px,alice)) && event(LeakM(px,alice)) is true.

Query attacker_p1(msg_d(bob,alice,sid_b)) ==> (event(LeakS(phase0,alice)) && event(LeakM(phase0,alice))) || (event(LeakS(px,alice)) && event(LeakM(px,alice)) && event(LeakS(pz,bob)) && event(LeakM(pz,bob))) is true.

Query attacker_p1(msg_d(bob,alice,sid_b)) ==> event(LeakS(phase0,alice)) && event(LeakM(phase0,alice)) is true.

Query event(RecvMsg(bob,alice,stagepack_e(sid_b),m_26)) ==> event(SendMsg(alice,bob,stagepack_e(sid_a),m_26)) is true.

Query event(RecvMsg(bob,alice,stagepack_e(sid_b),m_26)) ==> event(SendMsg(alice,c,stagepack_e(sid_a),m_26)) || (event(LeakS(phase0,alice)) && event(LeakM(phase0,alice))) || (event(LeakS(phase0,bob)) && event(LeakM(phase0,bob))) is true.

Query event(RecvMsg(bob,alice,stagepack_e(sid_b),m_26)) ==> event(SendMsg(alice,c,stagepack_e(sid_a),m_26)) || (event(LeakS(phase0,alice)) && event(LeakM(phase0,alice))) is true.

Query event(RecvMsg(bob,alice,stagepack_e(sid_b),m_26)) ==> event(SendMsg(alice,bob,stagepack_e(sid_a),m_26)) || (event(LeakS(phase0,alice)) && event(LeakM(phase0,alice))) || (event(LeakS(phase0,bob)) && event(LeakM(phase0,bob))) is true.

Query event(RecvMsg(bob,alice,stagepack_e(sid_b),m_26)) ==> event(SendMsg(alice,bob,stagepack_e(sid_a),m_26)) || (event(LeakS(phase0,alice)) && event(LeakM(phase0,alice))) is true.

Query not attacker_p1(msg_e(alice,bob,sid_a)) is true.

Query attacker_p1(msg_e(alice,bob,sid_a)) ==> event(LeakS(px,bob)) && event(LeakM(px,bob)) is true.

Query attacker_p1(msg_e(alice,bob,sid_a)) ==> event(LeakS(phase0,bob)) || (event(LeakS(px,bob)) && event(LeakM(px,bob)) && event(LeakS(pz,alice)) && event(LeakM(pz,alice))) is true.

Query attacker_p1(msg_e(alice,bob,sid_a)) ==> event(LeakS(phase0,bob)) && event(LeakM(phase0,bob)) is true.

Query not event(RecvEnd(true)) is true.

--------------------------------------------------------------


File "pv/K-K'.xnoise.passive.pv", line 5, characters 5-24:
Warning: Setting expandIfTermsToTerms is deprecated.
File "pv/K-K'.xnoise.passive.pv", line 210, characters 7-8:
Warning: identifier ck rebound.
File "pv/K-K'.xnoise.passive.pv", line 219, characters 7-8:
Warning: identifier ck rebound.
File "pv/K-K'.xnoise.passive.pv", line 220, characters 7-8:
Warning: identifier cs rebound.
File "pv/K-K'.xnoise.passive.pv", line 220, character 36:
Warning: identifier h rebound.
File "pv/K-K'.xnoise.passive.pv", line 250, characters 6-7:
Warning: identifier ss rebound.
File "pv/K-K'.xnoise.passive.pv", line 251, characters 6-7:
Warning: identifier ss rebound.
File "pv/K-K'.xnoise.passive.pv", line 252, characters 6-7:
Warning: identifier ss rebound.
File "pv/K-K'.xnoise.passive.pv", line 253, characters 6-7:
Warning: identifier ss rebound.
File "pv/K-K'.xnoise.passive.pv", line 258, characters 6-7:
Warning: identifier ss rebound.
File "pv/K-K'.xnoise.passive.pv", line 259, characters 6-7:
Warning: identifier ss rebound.
File "pv/K-K'.xnoise.passive.pv", line 260, characters 6-7:
Warning: identifier ss rebound.
File "pv/K-K'.xnoise.passive.pv", line 261, characters 6-7:
Warning: identifier ss rebound.
File "pv/K-K'.xnoise.passive.pv", line 267, character 6:
Warning: identifier e rebound.
File "pv/K-K'.xnoise.passive.pv", line 268, characters 6-7:
Warning: identifier ne rebound.
File "pv/K-K'.xnoise.passive.pv", line 269, characters 6-7:
Warning: identifier ss rebound.
File "pv/K-K'.xnoise.passive.pv", line 271, characters 6-7:
Warning: identifier ss rebound.
File "pv/K-K'.xnoise.passive.pv", line 272, characters 6-7:
Warning: identifier ss rebound.
File "pv/K-K'.xnoise.passive.pv", line 273, characters 6-7:
Warning: identifier ss rebound.
File "pv/K-K'.xnoise.passive.pv", line 274, characters 6-7:
Warning: identifier ss rebound.
File "pv/K-K'.xnoise.passive.pv", line 275, characters 7-8:
Warning: identifier ss rebound.
File "pv/K-K'.xnoise.passive.pv", line 275, characters 26-35:
Warning: identifier ciphertext rebound.
File "pv/K-K'.xnoise.passive.pv", line 276, characters 6-7:
Warning: identifier hs rebound.
File "pv/K-K'.xnoise.passive.pv", line 285, characters 6-7:
Warning: identifier re rebound.
File "pv/K-K'.xnoise.passive.pv", line 286, characters 6-7:
Warning: identifier ss rebound.
File "pv/K-K'.xnoise.passive.pv", line 288, characters 6-7:
Warning: identifier ss rebound.
File "pv/K-K'.xnoise.passive.pv", line 289, characters 6-7:
Warning: identifier ss rebound.
File "pv/K-K'.xnoise.passive.pv", line 290, characters 6-7:
Warning: identifier ss rebound.
File "pv/K-K'.xnoise.passive.pv", line 291, characters 6-7:
Warning: identifier ss rebound.
File "pv/K-K'.xnoise.passive.pv", line 292, characters 7-8:
Warning: identifier ss rebound.
File "pv/K-K'.xnoise.passive.pv", line 294, characters 13-14:
Warning: identifier hs rebound.
File "pv/K-K'.xnoise.passive.pv", line 370, characters 8-9:
Warning: identifier hs rebound.
File "pv/K-K'.xnoise.passive.pv", line 399, characters 8-9:
Warning: identifier hs rebound.
Linear part:
dhexp_real(b,dhexp_real(a,g)) = dhexp_real(a,dhexp_real(b,g))
Completing equations...
Completed equations:
dhexp_real(b,dhexp_real(a,g)) = dhexp_real(a,dhexp_real(b,g))
Convergent part: No equation.
Process 0 (that is, the initial process):
{1}out(pub, (key_s(charlie),key_m(charlie)));
{2}!
{3}new sid: sessionid;
(
    {4}let me: principal = alice in
    {5}let them: principal = bob in
    {6}let sid_1: sessionid = sid in
    {7}let basis: key = key_s(me) in
    {8}let public_key: key = catch-fail(dhexp(basis,validkey(g))) in
    {9}let v: bool = not-caught-fail(public_key) in
    {10}let s: keypair = (if v then keypairpack(validkey(public_key),basis) else fail-any) in
    {11}let basis_1: key = key_m(me) in
    {12}let public_key_1: key = catch-fail(dhexp(basis_1,validkey(g))) in
    {13}let v_1: bool = not-caught-fail(public_key_1) in
    {14}let m: keypair = (if v_1 then keypairpack(validkey(public_key_1),basis_1) else fail-any) in
    {15}out(pub, (getpublickey(s),getpublickey(m)));
    (
        {16}let e: keypair = keypairpack(empty,empty) in
        {17}let basis_2: key = key_s(them) in
        {18}let public_key_2: key = catch-fail(dhexp(basis_2,validkey(g))) in
        {19}let v_2: bool = not-caught-fail(public_key_2) in
        {20}let rs: key = getpublickey((if v_2 then keypairpack(validkey(public_key_2),basis_2) else fail-any)) in
        {21}let basis_3: key = key_s(them) in
        {22}let public_key_3: key = catch-fail(dhexp(basis_3,validkey(g))) in
        {23}let v_3: bool = not-caught-fail(public_key_3) in
        {24}let rm: key = getpublickey((if v_3 then keypairpack(validkey(public_key_3),basis_3) else fail-any)) in
        {25}let re: key = empty in
        {26}let prologue: bitstring = empty in
        {27}let psk: key = empty in
        {28}let protocol_name: bitstring = somename in
        {29}let h: bitstring = hash(protocol_name,empty) in
        {30}let ck: key = h in
        {31}let k: key = empty in
        {32}let cs: cipherstate = cipherstatepack(k,minnonce) in
        {33}let ss: symmetricstate = symmetricstatepack(cs,ck,h) in
        {34}let v_4: bitstring = catch-fail(symmetricstateunpack(ss)) in
        {35}let v_5: bool = (not-caught-fail(v_4) && success?(1-proj-3-tuple(v_4))) in
        {36}let h_1: bitstring = (if v_5 then 3-proj-3-tuple(v_4) else caught-fail) in
        {37}let ck_1: key = (if v_5 then 2-proj-3-tuple(v_4) else caught-fail) in
        {38}let cs_1: cipherstate = (if v_5 then 1-proj-3-tuple(v_4) else caught-fail) in
        {39}let ss_1: symmetricstate = catch-fail((if v_5 then symmetricstatepack(cs_1,ck_1,hash(h_1,prologue)) else fail-any)) in
        {40}let v_6: bool = not-caught-fail(ss_1) in
        {41}let data: bitstring = (if v_6 then catch-fail(getpublickey(s)) else caught-fail) in
        {42}let v_7: bool = not-caught-fail(data) in
        {43}let v_8: bitstring = (if v_7 then catch-fail(symmetricstateunpack(ss_1)) else caught-fail) in
        {44}let v_9: bool = (not-caught-fail(v_8) && success?(1-proj-3-tuple(v_8))) in
        {45}let h_2: bitstring = (if v_9 then 3-proj-3-tuple(v_8) else caught-fail) in
        {46}let ck_2: key = (if v_9 then 2-proj-3-tuple(v_8) else caught-fail) in
        {47}let cs_2: cipherstate = (if v_9 then 1-proj-3-tuple(v_8) else caught-fail) in
        {48}let ss_2: symmetricstate = (if v_6 then catch-fail((if v_7 then (if v_9 then symmetricstatepack(cs_2,ck_2,hash(h_2,data)) else fail-any) else fail-any)) else caught-fail) in
        {49}let v_10: bool = not-caught-fail(ss_2) in
        {50}let data_1: bitstring = (if v_10 then catch-fail(getpublickey(m)) else caught-fail) in
        {51}let v_11: bool = not-caught-fail(data_1) in
        {52}let v_12: bitstring = (if v_11 then catch-fail(symmetricstateunpack(ss_2)) else caught-fail) in
        {53}let v_13: bool = (not-caught-fail(v_12) && success?(1-proj-3-tuple(v_12))) in
        {54}let h_3: bitstring = (if v_13 then 3-proj-3-tuple(v_12) else caught-fail) in
        {55}let ck_3: key = (if v_13 then 2-proj-3-tuple(v_12) else caught-fail) in
        {56}let cs_3: cipherstate = (if v_13 then 1-proj-3-tuple(v_12) else caught-fail) in
        {57}let ss_3: symmetricstate = (if v_10 then catch-fail((if v_11 then (if v_13 then symmetricstatepack(cs_3,ck_3,hash(h_3,data_1)) else fail-any) else fail-any)) else caught-fail) in
        {58}let v_14: bool = not-caught-fail(ss_3) in
        {59}let v_15: bitstring = (if v_14 then catch-fail(symmetricstateunpack(ss_3)) else caught-fail) in
        {60}let v_16: bool = (not-caught-fail(v_15) && success?(1-proj-3-tuple(v_15))) in
        {61}let h_4: bitstring = (if v_16 then 3-proj-3-tuple(v_15) else caught-fail) in
        {62}let ck_4: key = (if v_16 then 2-proj-3-tuple(v_15) else caught-fail) in
        {63}let cs_4: cipherstate = (if v_16 then 1-proj-3-tuple(v_15) else caught-fail) in
        {64}let ss_4: symmetricstate = (if v_14 then catch-fail((if v_16 then symmetricstatepack(cs_4,ck_4,hash(h_4,rs)) else fail-any)) else caught-fail) in
        {65}let v_17: bool = not-caught-fail(ss_4) in
        {66}let v_18: bitstring = (if v_17 then catch-fail(symmetricstateunpack(ss_4)) else caught-fail) in
        {67}let v_19: bool = (not-caught-fail(v_18) && success?(1-proj-3-tuple(v_18))) in
        {68}let h_5: bitstring = (if v_19 then 3-proj-3-tuple(v_18) else caught-fail) in
        {69}let ck_5: key = (if v_19 then 2-proj-3-tuple(v_18) else caught-fail) in
        {70}let cs_5: cipherstate = (if v_19 then 1-proj-3-tuple(v_18) else caught-fail) in
        {71}let ss_5: symmetricstate = (if v_17 then catch-fail((if v_19 then symmetricstatepack(cs_5,ck_5,hash(h_5,rm)) else fail-any)) else caught-fail) in
        {72}let v_20: bool = not-caught-fail(ss_5) in
        {73}let hs: handshakestate = (if v_6 then (if v_10 then (if v_14 then (if v_17 then (if v_20 then handshakestatepack(ss_5,s,m,e,rs,rm,re,psk,true) else fail-any) else fail-any) else fail-any) else fail-any) else fail-any) in
        {74}insert statestore(me,them,sid_1,statepack_a(hs))
    ) | (
        {249}get statestore(=me,=them,=sid_1,statepack_a(hs_1: handshakestate)) in
        {75}let payload: bitstring = msg_a(me,them,sid_1) in
        {76}let v_21: bitstring = catch-fail(handshakestateunpack(hs_1)) in
        {77}let v_22: bool = (not-caught-fail(v_21) && success?(1-proj-9-tuple(v_21))) in
        {78}let initiator_1: bool = (if v_22 then 9-proj-9-tuple(v_21) else caught-fail) in
        {79}let psk_1: key = (if v_22 then 8-proj-9-tuple(v_21) else caught-fail) in
        {80}let re_1: key = (if v_22 then 7-proj-9-tuple(v_21) else caught-fail) in
        {81}let rm_1: key = (if v_22 then 6-proj-9-tuple(v_21) else caught-fail) in
        {82}let rs_1: key = (if v_22 then 5-proj-9-tuple(v_21) else caught-fail) in
        {83}let e_1: keypair = (if v_22 then 4-proj-9-tuple(v_21) else caught-fail) in
        {84}let m_1: keypair = (if v_22 then 3-proj-9-tuple(v_21) else caught-fail) in
        {85}let s_1: keypair = (if v_22 then 2-proj-9-tuple(v_21) else caught-fail) in
        {86}let ss_6: symmetricstate = (if v_22 then 1-proj-9-tuple(v_21) else caught-fail) in
        {87}let v_23: bitstring = (if v_22 then catch-fail((empty,empty,empty)) else caught-fail) in
        {88}let v_24: bool = (not-caught-fail(v_23) && success?(1-proj-3-tuple(v_23))) in
        {89}let ciphertext: bitstring = (if v_24 then 3-proj-3-tuple(v_23) else caught-fail) in
        {90}let ns: bitstring = (if v_24 then 2-proj-3-tuple(v_23) else caught-fail) in
        {91}let ne: bitstring = (if v_24 then 1-proj-3-tuple(v_23) else caught-fail) in
        {92}let basis_4: key = (if v_24 then key_e(me,them,sid_1) else caught-fail) in
        {93}let public_key_4: key = (if v_24 then catch-fail(dhexp(basis_4,validkey(g))) else caught-fail) in
        {94}let v_25: bool = not-caught-fail(public_key_4) in
        {95}let e_2: keypair = (if v_24 then catch-fail((if v_25 then keypairpack(validkey(public_key_4),basis_4) else fail-any)) else caught-fail) in
        {96}let v_26: bool = not-caught-fail(e_2) in
        {97}let ne_1: bitstring = (if v_26 then catch-fail(getpublickey(e_2)) else caught-fail) in
        {98}let v_27: bool = not-caught-fail(ne_1) in
        {99}let v_28: bitstring = (if v_27 then catch-fail(symmetricstateunpack(ss_6)) else caught-fail) in
        {100}let v_29: bool = (not-caught-fail(v_28) && success?(1-proj-3-tuple(v_28))) in
        {101}let h_6: bitstring = (if v_29 then 3-proj-3-tuple(v_28) else caught-fail) in
        {102}let ck_6: key = (if v_29 then 2-proj-3-tuple(v_28) else caught-fail) in
        {103}let cs_6: cipherstate = (if v_29 then 1-proj-3-tuple(v_28) else caught-fail) in
        {104}let ss_7: symmetricstate = (if v_27 then catch-fail((if v_29 then symmetricstatepack(cs_6,ck_6,hash(h_6,ne_1)) else fail-any)) else caught-fail) in
        {105}let v_30: bool = not-caught-fail(ss_7) in
        {106}let v_31: bitstring = (if v_30 then catch-fail(keypairunpack(e_2)) else caught-fail) in
        {107}let v_32: bool = (not-caught-fail(v_31) && success?(1-proj-2-tuple(v_31))) in
        {108}let my_private_key: key = (if v_32 then 2-proj-2-tuple(v_31) else caught-fail) in
        {109}let my_public_key: key = (if v_32 then 1-proj-2-tuple(v_31) else caught-fail) in
        {110}let input_key_material: key = (if v_30 then catch-fail((if v_32 then dhexp(my_private_key,rs_1) else fail-any)) else caught-fail) in
        {111}let v_33: bool = not-caught-fail(input_key_material) in
        {112}let v_34: bitstring = (if v_33 then catch-fail(symmetricstateunpack(ss_7)) else caught-fail) in
        {113}let v_35: bool = (not-caught-fail(v_34) && success?(1-proj-3-tuple(v_34))) in
        {114}let h_7: bitstring = (if v_35 then 3-proj-3-tuple(v_34) else caught-fail) in
        {115}let ck_7: key = (if v_35 then 2-proj-3-tuple(v_34) else caught-fail) in
        {116}let cs_7: cipherstate = (if v_35 then 1-proj-3-tuple(v_34) else caught-fail) in
        {117}let output1: key = (if v_35 then hmac_hash1(ck_7,input_key_material) else caught-fail) in
        {118}let output2: key = (if v_35 then hmac_hash2(ck_7,input_key_material) else caught-fail) in
        {119}let output3: key = (if v_35 then hmac_hash3(ck_7,input_key_material) else caught-fail) in
        {120}let v_36: bitstring = (if v_35 then catch-fail((output1,output2,output3)) else caught-fail) in
        {121}let v_37: bool = (not-caught-fail(v_36) && success?(1-proj-3-tuple(v_36))) in
        {122}let output_3: key = (if v_37 then 3-proj-3-tuple(v_36) else caught-fail) in
        {123}let temp_k: key = (if v_37 then 2-proj-3-tuple(v_36) else caught-fail) in
        {124}let ck_8: key = (if v_37 then 1-proj-3-tuple(v_36) else caught-fail) in
        {125}let ss_8: symmetricstate = (if v_30 then catch-fail((if v_33 then (if v_35 then (if v_37 then symmetricstatepack(cipherstatepack(temp_k,minnonce),ck_8,h_7) else fail-any) else fail-any) else fail-any)) else caught-fail) in
        {126}let v_38: bool = not-caught-fail(ss_8) in
        {127}let v_39: bitstring = (if v_38 then catch-fail(keypairunpack(e_2)) else caught-fail) in
        {128}let v_40: bool = (not-caught-fail(v_39) && success?(1-proj-2-tuple(v_39))) in
        {129}let my_private_key_1: key = (if v_40 then 2-proj-2-tuple(v_39) else caught-fail) in
        {130}let my_public_key_1: key = (if v_40 then 1-proj-2-tuple(v_39) else caught-fail) in
        {131}let input_key_material_1: key = (if v_38 then catch-fail((if v_40 then dhexp(my_private_key_1,rm_1) else fail-any)) else caught-fail) in
        {132}let v_41: bool = not-caught-fail(input_key_material_1) in
        {133}let v_42: bitstring = (if v_41 then catch-fail(symmetricstateunpack(ss_8)) else caught-fail) in
        {134}let v_43: bool = (not-caught-fail(v_42) && success?(1-proj-3-tuple(v_42))) in
        {135}let h_8: bitstring = (if v_43 then 3-proj-3-tuple(v_42) else caught-fail) in
        {136}let ck_9: key = (if v_43 then 2-proj-3-tuple(v_42) else caught-fail) in
        {137}let cs_8: cipherstate = (if v_43 then 1-proj-3-tuple(v_42) else caught-fail) in
        {138}let output1_1: key = (if v_43 then hmac_hash1(ck_9,input_key_material_1) else caught-fail) in
        {139}let output2_1: key = (if v_43 then hmac_hash2(ck_9,input_key_material_1) else caught-fail) in
        {140}let output3_1: key = (if v_43 then hmac_hash3(ck_9,input_key_material_1) else caught-fail) in
        {141}let v_44: bitstring = (if v_43 then catch-fail((output1_1,output2_1,output3_1)) else caught-fail) in
        {142}let v_45: bool = (not-caught-fail(v_44) && success?(1-proj-3-tuple(v_44))) in
        {143}let output: key = (if v_45 then 3-proj-3-tuple(v_44) else caught-fail) in
        {144}let temp_k_1: key = (if v_45 then 2-proj-3-tuple(v_44) else caught-fail) in
        {145}let ck_10: key = (if v_45 then 1-proj-3-tuple(v_44) else caught-fail) in
        {146}let ss_9: symmetricstate = (if v_38 then catch-fail((if v_41 then (if v_43 then (if v_45 then symmetricstatepack(cipherstatepack(temp_k_1,minnonce),ck_10,h_8) else fail-any) else fail-any) else fail-any)) else caught-fail) in
        {147}let v_46: bool = not-caught-fail(ss_9) in
        {148}let v_47: bitstring = (if v_46 then catch-fail(keypairunpack(m_1)) else caught-fail) in
        {149}let v_48: bool = (not-caught-fail(v_47) && success?(1-proj-2-tuple(v_47))) in
        {150}let my_private_key_2: key = (if v_48 then 2-proj-2-tuple(v_47) else caught-fail) in
        {151}let my_public_key_2: key = (if v_48 then 1-proj-2-tuple(v_47) else caught-fail) in
        {152}let input_key_material_2: key = (if v_46 then catch-fail((if v_48 then dhexp(my_private_key_2,rs_1) else fail-any)) else caught-fail) in
        {153}let v_49: bool = not-caught-fail(input_key_material_2) in
        {154}let v_50: bitstring = (if v_49 then catch-fail(symmetricstateunpack(ss_9)) else caught-fail) in
        {155}let v_51: bool = (not-caught-fail(v_50) && success?(1-proj-3-tuple(v_50))) in
        {156}let h_9: bitstring = (if v_51 then 3-proj-3-tuple(v_50) else caught-fail) in
        {157}let ck_11: key = (if v_51 then 2-proj-3-tuple(v_50) else caught-fail) in
        {158}let cs_9: cipherstate = (if v_51 then 1-proj-3-tuple(v_50) else caught-fail) in
        {159}let output1_2: key = (if v_51 then hmac_hash1(ck_11,input_key_material_2) else caught-fail) in
        {160}let output2_2: key = (if v_51 then hmac_hash2(ck_11,input_key_material_2) else caught-fail) in
        {161}let output3_2: key = (if v_51 then hmac_hash3(ck_11,input_key_material_2) else caught-fail) in
        {162}let v_52: bitstring = (if v_51 then catch-fail((output1_2,output2_2,output3_2)) else caught-fail) in
        {163}let v_53: bool = (not-caught-fail(v_52) && success?(1-proj-3-tuple(v_52))) in
        {164}let output_1: key = (if v_53 then 3-proj-3-tuple(v_52) else caught-fail) in
        {165}let temp_k_2: key = (if v_53 then 2-proj-3-tuple(v_52) else caught-fail) in
        {166}let ck_12: key = (if v_53 then 1-proj-3-tuple(v_52) else caught-fail) in
        {167}let ss_10: symmetricstate = (if v_46 then catch-fail((if v_49 then (if v_51 then (if v_53 then symmetricstatepack(cipherstatepack(temp_k_2,minnonce),ck_12,h_9) else fail-any) else fail-any) else fail-any)) else caught-fail) in
        {168}let v_54: bool = not-caught-fail(ss_10) in
        {169}let v_55: bitstring = (if v_54 then catch-fail(keypairunpack(s_1)) else caught-fail) in
        {170}let v_56: bool = (not-caught-fail(v_55) && success?(1-proj-2-tuple(v_55))) in
        {171}let my_private_key_3: key = (if v_56 then 2-proj-2-tuple(v_55) else caught-fail) in
        {172}let my_public_key_3: key = (if v_56 then 1-proj-2-tuple(v_55) else caught-fail) in
        {173}let input_key_material_3: key = (if v_54 then catch-fail((if v_56 then dhexp(my_private_key_3,rm_1) else fail-any)) else caught-fail) in
        {174}let v_57: bool = not-caught-fail(input_key_material_3) in
        {175}let v_58: bitstring = (if v_57 then catch-fail(symmetricstateunpack(ss_10)) else caught-fail) in
        {176}let v_59: bool = (not-caught-fail(v_58) && success?(1-proj-3-tuple(v_58))) in
        {177}let h_10: bitstring = (if v_59 then 3-proj-3-tuple(v_58) else caught-fail) in
        {178}let ck_13: key = (if v_59 then 2-proj-3-tuple(v_58) else caught-fail) in
        {179}let cs_10: cipherstate = (if v_59 then 1-proj-3-tuple(v_58) else caught-fail) in
        {180}let output1_3: key = (if v_59 then hmac_hash1(ck_13,input_key_material_3) else caught-fail) in
        {181}let output2_3: key = (if v_59 then hmac_hash2(ck_13,input_key_material_3) else caught-fail) in
        {182}let output3_3: key = (if v_59 then hmac_hash3(ck_13,input_key_material_3) else caught-fail) in
        {183}let v_60: bitstring = (if v_59 then catch-fail((output1_3,output2_3,output3_3)) else caught-fail) in
        {184}let v_61: bool = (not-caught-fail(v_60) && success?(1-proj-3-tuple(v_60))) in
        {185}let output_2: key = (if v_61 then 3-proj-3-tuple(v_60) else caught-fail) in
        {186}let temp_k_3: key = (if v_61 then 2-proj-3-tuple(v_60) else caught-fail) in
        {187}let ck_14: key = (if v_61 then 1-proj-3-tuple(v_60) else caught-fail) in
        {188}let ss_11: symmetricstate = (if v_54 then catch-fail((if v_57 then (if v_59 then (if v_61 then symmetricstatepack(cipherstatepack(temp_k_3,minnonce),ck_14,h_10) else fail-any) else fail-any) else fail-any)) else caught-fail) in
        {189}let v_62: bool = not-caught-fail(ss_11) in
        {190}let v_63: bitstring = (if v_62 then catch-fail(symmetricstateunpack(ss_11)) else caught-fail) in
        {191}let v_64: bool = (not-caught-fail(v_63) && success?(1-proj-3-tuple(v_63))) in
        {192}let h_11: bitstring = (if v_64 then 3-proj-3-tuple(v_63) else caught-fail) in
        {193}let ck_15: key = (if v_64 then 2-proj-3-tuple(v_63) else caught-fail) in
        {194}let cs_11: cipherstate = (if v_64 then 1-proj-3-tuple(v_63) else caught-fail) in
        {195}let v_65: bitstring = (if v_64 then catch-fail(cipherstateunpack(cs_11)) else caught-fail) in
        {196}let v_66: bool = (not-caught-fail(v_65) && success?(1-proj-2-tuple(v_65))) in
        {197}let n: nonce = (if v_66 then 2-proj-2-tuple(v_65) else caught-fail) in
        {198}let k_1: key = (if v_66 then 1-proj-2-tuple(v_65) else caught-fail) in
        {199}let e_3: bitstring = (if v_66 then encrypt(k_1,n,h_11,payload) else caught-fail) in
        {200}let n_1: nonce = (if v_66 then increment_nonce(n) else caught-fail) in
        {201}let v_67: bitstring = (if v_66 then catch-fail(cipherstateunpack(cs_11)) else caught-fail) in
        {202}let v_68: bool = (not-caught-fail(v_67) && success?(1-proj-2-tuple(v_67))) in
        {203}let o: nonce = (if v_68 then 2-proj-2-tuple(v_67) else caught-fail) in
        {204}let k_2: key = (if v_68 then 1-proj-2-tuple(v_67) else caught-fail) in
        {205}let csi: cipherstate = (if v_66 then catch-fail((if v_68 then cipherstatepack(k_2,n_1) else fail-any)) else caught-fail) in
        {206}let v_69: bool = not-caught-fail(csi) in
        {207}let v_70: bitstring = (if v_64 then catch-fail((if v_66 then (if v_69 then (csi,e_3) else fail-any) else fail-any)) else caught-fail) in
        {208}let v_71: bool = (not-caught-fail(v_70) && success?(1-proj-2-tuple(v_70))) in
        {209}let ciphertext_1: bitstring = (if v_71 then 2-proj-2-tuple(v_70) else caught-fail) in
        {210}let csi_1: cipherstate = (if v_71 then 1-proj-2-tuple(v_70) else caught-fail) in
        {211}let ss_12: symmetricstate = (if v_71 then symmetricstatepack(csi_1,ck_15,h_11) else caught-fail) in
        {212}let v_72: bitstring = (if v_71 then catch-fail(symmetricstateunpack(ss_12)) else caught-fail) in
        {213}let v_73: bool = (not-caught-fail(v_72) && success?(1-proj-3-tuple(v_72))) in
        {214}let h_12: bitstring = (if v_73 then 3-proj-3-tuple(v_72) else caught-fail) in
        {215}let ck_16: key = (if v_73 then 2-proj-3-tuple(v_72) else caught-fail) in
        {216}let cs_12: cipherstate = (if v_73 then 1-proj-3-tuple(v_72) else caught-fail) in
        {217}let ssi: symmetricstate = (if v_71 then catch-fail((if v_73 then symmetricstatepack(cs_12,ck_16,hash(h_12,ciphertext_1)) else fail-any)) else caught-fail) in
        {218}let v_74: bool = not-caught-fail(ssi) in
        {219}let v_75: bitstring = (if v_62 then catch-fail((if v_64 then (if v_71 then (if v_74 then (ssi,ciphertext_1) else fail-any) else fail-any) else fail-any)) else caught-fail) in
        {220}let v_76: bool = (not-caught-fail(v_75) && success?(1-proj-2-tuple(v_75))) in
        {221}let ciphertext_2: bitstring = (if v_76 then 2-proj-2-tuple(v_75) else caught-fail) in
        {222}let ss_13: symmetricstate = (if v_76 then 1-proj-2-tuple(v_75) else caught-fail) in
        {223}let hs_2: handshakestate = (if v_76 then handshakestatepack(ss_13,s_1,m_1,e_2,rs_1,rm_1,re_1,psk_1,initiator_1) else caught-fail) in
        {224}let message_buffer: bitstring = (if v_76 then concat3(ne_1,ns,ciphertext_2) else caught-fail) in
        {225}let v_77: bitstring = (if v_76 then catch-fail(symmetricstateunpack(ss_13)) else caught-fail) in
        {226}let v_78: bool = (not-caught-fail(v_77) && success?(1-proj-3-tuple(v_77))) in
        {227}let h_13: bitstring = (if v_78 then 3-proj-3-tuple(v_77) else caught-fail) in
        {228}let ck_17: key = (if v_78 then 2-proj-3-tuple(v_77) else caught-fail) in
        {229}let cs_13: cipherstate = (if v_78 then 1-proj-3-tuple(v_77) else caught-fail) in
        {230}let input_key_material_4: key = (if v_78 then zero else caught-fail) in
        {231}let output1_4: key = (if v_78 then hmac_hash1(ck_17,input_key_material_4) else caught-fail) in
        {232}let output2_4: key = (if v_78 then hmac_hash2(ck_17,input_key_material_4) else caught-fail) in
        {233}let output3_4: key = (if v_78 then hmac_hash3(ck_17,input_key_material_4) else caught-fail) in
        {234}let v_79: bitstring = (if v_78 then catch-fail((output1_4,output2_4,output3_4)) else caught-fail) in
        {235}let v_80: bool = (not-caught-fail(v_79) && success?(1-proj-3-tuple(v_79))) in
        {236}let temp_k3: key = (if v_80 then 3-proj-3-tuple(v_79) else caught-fail) in
        {237}let temp_k2: key = (if v_80 then 2-proj-3-tuple(v_79) else caught-fail) in
        {238}let temp_k1: key = (if v_80 then 1-proj-3-tuple(v_79) else caught-fail) in
        {239}let cs1: cipherstate = (if v_80 then cipherstatepack(temp_k1,minnonce) else caught-fail) in
        {240}let cs2: cipherstate = (if v_80 then cipherstatepack(temp_k2,minnonce) else caught-fail) in
        {241}let v_81: bitstring = (if v_76 then catch-fail((if v_78 then (if v_80 then (ss_13,cs1,cs2) else fail-any) else fail-any)) else caught-fail) in
        {242}let v_82: bool = (not-caught-fail(v_81) && success?(1-proj-3-tuple(v_81))) in
        {243}let cs2_1: cipherstate = (if v_82 then 3-proj-3-tuple(v_81) else caught-fail) in
        {244}let cs1_1: cipherstate = (if v_82 then 2-proj-3-tuple(v_81) else caught-fail) in
        {245}let ssi_1: symmetricstate = (if v_82 then 1-proj-3-tuple(v_81) else caught-fail) in
        {246}let (hs_3: handshakestate,message_a: bitstring,cs1_2: cipherstate,cs2_2: cipherstate) = (if v_22 then (if v_24 then (if v_26 then (if v_27 then (if v_30 then (if v_38 then (if v_46 then (if v_54 then (if v_62 then (if v_76 then (if v_82 then (hs_2,message_buffer,cs1_1,cs2_1) else fail-any) else fail-any) else fail-any) else fail-any) else fail-any) else fail-any) else fail-any) else fail-any) else fail-any) else fail-any) else fail-any) in
        {247}event SendMsg(me,them,stagepack_a(sid_1),msg_a(me,them,sid_1));
        {248}out(pub, message_a)
    ) | (
        {250}event LeakS(phase0,me);
        {251}event LeakM(phase0,me);
        {252}out(pub, (key_s(me),key_m(me)))
    ) | (
        {253}phase 1;
        {254}event LeakS(phase1,me);
        {255}event LeakM(phase1,me);
        {256}out(pub, (key_s(me),key_m(me)))
    )
) | (
    {257}let me_1: principal = alice in
    {258}let them_1: principal = charlie in
    {259}let sid_2: sessionid = sid in
    {260}let basis_5: key = key_s(me_1) in
    {261}let public_key_5: key = catch-fail(dhexp(basis_5,validkey(g))) in
    {262}let v_83: bool = not-caught-fail(public_key_5) in
    {263}let s_2: keypair = (if v_83 then keypairpack(validkey(public_key_5),basis_5) else fail-any) in
    {264}let basis_6: key = key_m(me_1) in
    {265}let public_key_6: key = catch-fail(dhexp(basis_6,validkey(g))) in
    {266}let v_84: bool = not-caught-fail(public_key_6) in
    {267}let m_2: keypair = (if v_84 then keypairpack(validkey(public_key_6),basis_6) else fail-any) in
    {268}out(pub, (getpublickey(s_2),getpublickey(m_2)));
    (
        {269}let e_4: keypair = keypairpack(empty,empty) in
        {270}let basis_7: key = key_s(them_1) in
        {271}let public_key_7: key = catch-fail(dhexp(basis_7,validkey(g))) in
        {272}let v_85: bool = not-caught-fail(public_key_7) in
        {273}let rs_2: key = getpublickey((if v_85 then keypairpack(validkey(public_key_7),basis_7) else fail-any)) in
        {274}let basis_8: key = key_s(them_1) in
        {275}let public_key_8: key = catch-fail(dhexp(basis_8,validkey(g))) in
        {276}let v_86: bool = not-caught-fail(public_key_8) in
        {277}let rm_2: key = getpublickey((if v_86 then keypairpack(validkey(public_key_8),basis_8) else fail-any)) in
        {278}let re_2: key = empty in
        {279}let prologue_1: bitstring = empty in
        {280}let psk_2: key = empty in
        {281}let protocol_name_1: bitstring = somename in
        {282}let h_14: bitstring = hash(protocol_name_1,empty) in
        {283}let ck_18: key = h_14 in
        {284}let k_3: key = empty in
        {285}let cs_14: cipherstate = cipherstatepack(k_3,minnonce) in
        {286}let ss_14: symmetricstate = symmetricstatepack(cs_14,ck_18,h_14) in
        {287}let v_87: bitstring = catch-fail(symmetricstateunpack(ss_14)) in
        {288}let v_88: bool = (not-caught-fail(v_87) && success?(1-proj-3-tuple(v_87))) in
        {289}let h_15: bitstring = (if v_88 then 3-proj-3-tuple(v_87) else caught-fail) in
        {290}let ck_19: key = (if v_88 then 2-proj-3-tuple(v_87) else caught-fail) in
        {291}let cs_15: cipherstate = (if v_88 then 1-proj-3-tuple(v_87) else caught-fail) in
        {292}let ss_15: symmetricstate = catch-fail((if v_88 then symmetricstatepack(cs_15,ck_19,hash(h_15,prologue_1)) else fail-any)) in
        {293}let v_89: bool = not-caught-fail(ss_15) in
        {294}let data_2: bitstring = (if v_89 then catch-fail(getpublickey(s_2)) else caught-fail) in
        {295}let v_90: bool = not-caught-fail(data_2) in
        {296}let v_91: bitstring = (if v_90 then catch-fail(symmetricstateunpack(ss_15)) else caught-fail) in
        {297}let v_92: bool = (not-caught-fail(v_91) && success?(1-proj-3-tuple(v_91))) in
        {298}let h_16: bitstring = (if v_92 then 3-proj-3-tuple(v_91) else caught-fail) in
        {299}let ck_20: key = (if v_92 then 2-proj-3-tuple(v_91) else caught-fail) in
        {300}let cs_16: cipherstate = (if v_92 then 1-proj-3-tuple(v_91) else caught-fail) in
        {301}let ss_16: symmetricstate = (if v_89 then catch-fail((if v_90 then (if v_92 then symmetricstatepack(cs_16,ck_20,hash(h_16,data_2)) else fail-any) else fail-any)) else caught-fail) in
        {302}let v_93: bool = not-caught-fail(ss_16) in
        {303}let data_3: bitstring = (if v_93 then catch-fail(getpublickey(m_2)) else caught-fail) in
        {304}let v_94: bool = not-caught-fail(data_3) in
        {305}let v_95: bitstring = (if v_94 then catch-fail(symmetricstateunpack(ss_16)) else caught-fail) in
        {306}let v_96: bool = (not-caught-fail(v_95) && success?(1-proj-3-tuple(v_95))) in
        {307}let h_17: bitstring = (if v_96 then 3-proj-3-tuple(v_95) else caught-fail) in
        {308}let ck_21: key = (if v_96 then 2-proj-3-tuple(v_95) else caught-fail) in
        {309}let cs_17: cipherstate = (if v_96 then 1-proj-3-tuple(v_95) else caught-fail) in
        {310}let ss_17: symmetricstate = (if v_93 then catch-fail((if v_94 then (if v_96 then symmetricstatepack(cs_17,ck_21,hash(h_17,data_3)) else fail-any) else fail-any)) else caught-fail) in
        {311}let v_97: bool = not-caught-fail(ss_17) in
        {312}let v_98: bitstring = (if v_97 then catch-fail(symmetricstateunpack(ss_17)) else caught-fail) in
        {313}let v_99: bool = (not-caught-fail(v_98) && success?(1-proj-3-tuple(v_98))) in
        {314}let h_18: bitstring = (if v_99 then 3-proj-3-tuple(v_98) else caught-fail) in
        {315}let ck_22: key = (if v_99 then 2-proj-3-tuple(v_98) else caught-fail) in
        {316}let cs_18: cipherstate = (if v_99 then 1-proj-3-tuple(v_98) else caught-fail) in
        {317}let ss_18: symmetricstate = (if v_97 then catch-fail((if v_99 then symmetricstatepack(cs_18,ck_22,hash(h_18,rs_2)) else fail-any)) else caught-fail) in
        {318}let v_100: bool = not-caught-fail(ss_18) in
        {319}let v_101: bitstring = (if v_100 then catch-fail(symmetricstateunpack(ss_18)) else caught-fail) in
        {320}let v_102: bool = (not-caught-fail(v_101) && success?(1-proj-3-tuple(v_101))) in
        {321}let h_19: bitstring = (if v_102 then 3-proj-3-tuple(v_101) else caught-fail) in
        {322}let ck_23: key = (if v_102 then 2-proj-3-tuple(v_101) else caught-fail) in
        {323}let cs_19: cipherstate = (if v_102 then 1-proj-3-tuple(v_101) else caught-fail) in
        {324}let ss_19: symmetricstate = (if v_100 then catch-fail((if v_102 then symmetricstatepack(cs_19,ck_23,hash(h_19,rm_2)) else fail-any)) else caught-fail) in
        {325}let v_103: bool = not-caught-fail(ss_19) in
        {326}let hs_4: handshakestate = (if v_89 then (if v_93 then (if v_97 then (if v_100 then (if v_103 then handshakestatepack(ss_19,s_2,m_2,e_4,rs_2,rm_2,re_2,psk_2,true) else fail-any) else fail-any) else fail-any) else fail-any) else fail-any) in
        {327}insert statestore(me_1,them_1,sid_2,statepack_a(hs_4))
    ) | (
        {502}get statestore(=me_1,=them_1,=sid_2,statepack_a(hs_5: handshakestate)) in
        {328}let payload_1: bitstring = msg_a(me_1,them_1,sid_2) in
        {329}let v_104: bitstring = catch-fail(handshakestateunpack(hs_5)) in
        {330}let v_105: bool = (not-caught-fail(v_104) && success?(1-proj-9-tuple(v_104))) in
        {331}let initiator_2: bool = (if v_105 then 9-proj-9-tuple(v_104) else caught-fail) in
        {332}let psk_3: key = (if v_105 then 8-proj-9-tuple(v_104) else caught-fail) in
        {333}let re_3: key = (if v_105 then 7-proj-9-tuple(v_104) else caught-fail) in
        {334}let rm_3: key = (if v_105 then 6-proj-9-tuple(v_104) else caught-fail) in
        {335}let rs_3: key = (if v_105 then 5-proj-9-tuple(v_104) else caught-fail) in
        {336}let e_5: keypair = (if v_105 then 4-proj-9-tuple(v_104) else caught-fail) in
        {337}let m_3: keypair = (if v_105 then 3-proj-9-tuple(v_104) else caught-fail) in
        {338}let s_3: keypair = (if v_105 then 2-proj-9-tuple(v_104) else caught-fail) in
        {339}let ss_20: symmetricstate = (if v_105 then 1-proj-9-tuple(v_104) else caught-fail) in
        {340}let v_106: bitstring = (if v_105 then catch-fail((empty,empty,empty)) else caught-fail) in
        {341}let v_107: bool = (not-caught-fail(v_106) && success?(1-proj-3-tuple(v_106))) in
        {342}let ciphertext_3: bitstring = (if v_107 then 3-proj-3-tuple(v_106) else caught-fail) in
        {343}let ns_1: bitstring = (if v_107 then 2-proj-3-tuple(v_106) else caught-fail) in
        {344}let ne_2: bitstring = (if v_107 then 1-proj-3-tuple(v_106) else caught-fail) in
        {345}let basis_9: key = (if v_107 then key_e(me_1,them_1,sid_2) else caught-fail) in
        {346}let public_key_9: key = (if v_107 then catch-fail(dhexp(basis_9,validkey(g))) else caught-fail) in
        {347}let v_108: bool = not-caught-fail(public_key_9) in
        {348}let e_6: keypair = (if v_107 then catch-fail((if v_108 then keypairpack(validkey(public_key_9),basis_9) else fail-any)) else caught-fail) in
        {349}let v_109: bool = not-caught-fail(e_6) in
        {350}let ne_3: bitstring = (if v_109 then catch-fail(getpublickey(e_6)) else caught-fail) in
        {351}let v_110: bool = not-caught-fail(ne_3) in
        {352}let v_111: bitstring = (if v_110 then catch-fail(symmetricstateunpack(ss_20)) else caught-fail) in
        {353}let v_112: bool = (not-caught-fail(v_111) && success?(1-proj-3-tuple(v_111))) in
        {354}let h_20: bitstring = (if v_112 then 3-proj-3-tuple(v_111) else caught-fail) in
        {355}let ck_24: key = (if v_112 then 2-proj-3-tuple(v_111) else caught-fail) in
        {356}let cs_20: cipherstate = (if v_112 then 1-proj-3-tuple(v_111) else caught-fail) in
        {357}let ss_21: symmetricstate = (if v_110 then catch-fail((if v_112 then symmetricstatepack(cs_20,ck_24,hash(h_20,ne_3)) else fail-any)) else caught-fail) in
        {358}let v_113: bool = not-caught-fail(ss_21) in
        {359}let v_114: bitstring = (if v_113 then catch-fail(keypairunpack(e_6)) else caught-fail) in
        {360}let v_115: bool = (not-caught-fail(v_114) && success?(1-proj-2-tuple(v_114))) in
        {361}let my_private_key_4: key = (if v_115 then 2-proj-2-tuple(v_114) else caught-fail) in
        {362}let my_public_key_4: key = (if v_115 then 1-proj-2-tuple(v_114) else caught-fail) in
        {363}let input_key_material_5: key = (if v_113 then catch-fail((if v_115 then dhexp(my_private_key_4,rs_3) else fail-any)) else caught-fail) in
        {364}let v_116: bool = not-caught-fail(input_key_material_5) in
        {365}let v_117: bitstring = (if v_116 then catch-fail(symmetricstateunpack(ss_21)) else caught-fail) in
        {366}let v_118: bool = (not-caught-fail(v_117) && success?(1-proj-3-tuple(v_117))) in
        {367}let h_21: bitstring = (if v_118 then 3-proj-3-tuple(v_117) else caught-fail) in
        {368}let ck_25: key = (if v_118 then 2-proj-3-tuple(v_117) else caught-fail) in
        {369}let cs_21: cipherstate = (if v_118 then 1-proj-3-tuple(v_117) else caught-fail) in
        {370}let output1_5: key = (if v_118 then hmac_hash1(ck_25,input_key_material_5) else caught-fail) in
        {371}let output2_5: key = (if v_118 then hmac_hash2(ck_25,input_key_material_5) else caught-fail) in
        {372}let output3_5: key = (if v_118 then hmac_hash3(ck_25,input_key_material_5) else caught-fail) in
        {373}let v_119: bitstring = (if v_118 then catch-fail((output1_5,output2_5,output3_5)) else caught-fail) in
        {374}let v_120: bool = (not-caught-fail(v_119) && success?(1-proj-3-tuple(v_119))) in
        {375}let output_4: key = (if v_120 then 3-proj-3-tuple(v_119) else caught-fail) in
        {376}let temp_k_4: key = (if v_120 then 2-proj-3-tuple(v_119) else caught-fail) in
        {377}let ck_26: key = (if v_120 then 1-proj-3-tuple(v_119) else caught-fail) in
        {378}let ss_22: symmetricstate = (if v_113 then catch-fail((if v_116 then (if v_118 then (if v_120 then symmetricstatepack(cipherstatepack(temp_k_4,minnonce),ck_26,h_21) else fail-any) else fail-any) else fail-any)) else caught-fail) in
        {379}let v_121: bool = not-caught-fail(ss_22) in
        {380}let v_122: bitstring = (if v_121 then catch-fail(keypairunpack(e_6)) else caught-fail) in
        {381}let v_123: bool = (not-caught-fail(v_122) && success?(1-proj-2-tuple(v_122))) in
        {382}let my_private_key_5: key = (if v_123 then 2-proj-2-tuple(v_122) else caught-fail) in
        {383}let my_public_key_5: key = (if v_123 then 1-proj-2-tuple(v_122) else caught-fail) in
        {384}let input_key_material_6: key = (if v_121 then catch-fail((if v_123 then dhexp(my_private_key_5,rm_3) else fail-any)) else caught-fail) in
        {385}let v_124: bool = not-caught-fail(input_key_material_6) in
        {386}let v_125: bitstring = (if v_124 then catch-fail(symmetricstateunpack(ss_22)) else caught-fail) in
        {387}let v_126: bool = (not-caught-fail(v_125) && success?(1-proj-3-tuple(v_125))) in
        {388}let h_22: bitstring = (if v_126 then 3-proj-3-tuple(v_125) else caught-fail) in
        {389}let ck_27: key = (if v_126 then 2-proj-3-tuple(v_125) else caught-fail) in
        {390}let cs_22: cipherstate = (if v_126 then 1-proj-3-tuple(v_125) else caught-fail) in
        {391}let output1_6: key = (if v_126 then hmac_hash1(ck_27,input_key_material_6) else caught-fail) in
        {392}let output2_6: key = (if v_126 then hmac_hash2(ck_27,input_key_material_6) else caught-fail) in
        {393}let output3_6: key = (if v_126 then hmac_hash3(ck_27,input_key_material_6) else caught-fail) in
        {394}let v_127: bitstring = (if v_126 then catch-fail((output1_6,output2_6,output3_6)) else caught-fail) in
        {395}let v_128: bool = (not-caught-fail(v_127) && success?(1-proj-3-tuple(v_127))) in
        {396}let output_5: key = (if v_128 then 3-proj-3-tuple(v_127) else caught-fail) in
        {397}let temp_k_5: key = (if v_128 then 2-proj-3-tuple(v_127) else caught-fail) in
        {398}let ck_28: key = (if v_128 then 1-proj-3-tuple(v_127) else caught-fail) in
        {399}let ss_23: symmetricstate = (if v_121 then catch-fail((if v_124 then (if v_126 then (if v_128 then symmetricstatepack(cipherstatepack(temp_k_5,minnonce),ck_28,h_22) else fail-any) else fail-any) else fail-any)) else caught-fail) in
        {400}let v_129: bool = not-caught-fail(ss_23) in
        {401}let v_130: bitstring = (if v_129 then catch-fail(keypairunpack(m_3)) else caught-fail) in
        {402}let v_131: bool = (not-caught-fail(v_130) && success?(1-proj-2-tuple(v_130))) in
        {403}let my_private_key_6: key = (if v_131 then 2-proj-2-tuple(v_130) else caught-fail) in
        {404}let my_public_key_6: key = (if v_131 then 1-proj-2-tuple(v_130) else caught-fail) in
        {405}let input_key_material_7: key = (if v_129 then catch-fail((if v_131 then dhexp(my_private_key_6,rs_3) else fail-any)) else caught-fail) in
        {406}let v_132: bool = not-caught-fail(input_key_material_7) in
        {407}let v_133: bitstring = (if v_132 then catch-fail(symmetricstateunpack(ss_23)) else caught-fail) in
        {408}let v_134: bool = (not-caught-fail(v_133) && success?(1-proj-3-tuple(v_133))) in
        {409}let h_23: bitstring = (if v_134 then 3-proj-3-tuple(v_133) else caught-fail) in
        {410}let ck_29: key = (if v_134 then 2-proj-3-tuple(v_133) else caught-fail) in
        {411}let cs_23: cipherstate = (if v_134 then 1-proj-3-tuple(v_133) else caught-fail) in
        {412}let output1_7: key = (if v_134 then hmac_hash1(ck_29,input_key_material_7) else caught-fail) in
        {413}let output2_7: key = (if v_134 then hmac_hash2(ck_29,input_key_material_7) else caught-fail) in
        {414}let output3_7: key = (if v_134 then hmac_hash3(ck_29,input_key_material_7) else caught-fail) in
        {415}let v_135: bitstring = (if v_134 then catch-fail((output1_7,output2_7,output3_7)) else caught-fail) in
        {416}let v_136: bool = (not-caught-fail(v_135) && success?(1-proj-3-tuple(v_135))) in
        {417}let output_6: key = (if v_136 then 3-proj-3-tuple(v_135) else caught-fail) in
        {418}let temp_k_6: key = (if v_136 then 2-proj-3-tuple(v_135) else caught-fail) in
        {419}let ck_30: key = (if v_136 then 1-proj-3-tuple(v_135) else caught-fail) in
        {420}let ss_24: symmetricstate = (if v_129 then catch-fail((if v_132 then (if v_134 then (if v_136 then symmetricstatepack(cipherstatepack(temp_k_6,minnonce),ck_30,h_23) else fail-any) else fail-any) else fail-any)) else caught-fail) in
        {421}let v_137: bool = not-caught-fail(ss_24) in
        {422}let v_138: bitstring = (if v_137 then catch-fail(keypairunpack(s_3)) else caught-fail) in
        {423}let v_139: bool = (not-caught-fail(v_138) && success?(1-proj-2-tuple(v_138))) in
        {424}let my_private_key_7: key = (if v_139 then 2-proj-2-tuple(v_138) else caught-fail) in
        {425}let my_public_key_7: key = (if v_139 then 1-proj-2-tuple(v_138) else caught-fail) in
        {426}let input_key_material_8: key = (if v_137 then catch-fail((if v_139 then dhexp(my_private_key_7,rm_3) else fail-any)) else caught-fail) in
        {427}let v_140: bool = not-caught-fail(input_key_material_8) in
        {428}let v_141: bitstring = (if v_140 then catch-fail(symmetricstateunpack(ss_24)) else caught-fail) in
        {429}let v_142: bool = (not-caught-fail(v_141) && success?(1-proj-3-tuple(v_141))) in
        {430}let h_24: bitstring = (if v_142 then 3-proj-3-tuple(v_141) else caught-fail) in
        {431}let ck_31: key = (if v_142 then 2-proj-3-tuple(v_141) else caught-fail) in
        {432}let cs_24: cipherstate = (if v_142 then 1-proj-3-tuple(v_141) else caught-fail) in
        {433}let output1_8: key = (if v_142 then hmac_hash1(ck_31,input_key_material_8) else caught-fail) in
        {434}let output2_8: key = (if v_142 then hmac_hash2(ck_31,input_key_material_8) else caught-fail) in
        {435}let output3_8: key = (if v_142 then hmac_hash3(ck_31,input_key_material_8) else caught-fail) in
        {436}let v_143: bitstring = (if v_142 then catch-fail((output1_8,output2_8,output3_8)) else caught-fail) in
        {437}let v_144: bool = (not-caught-fail(v_143) && success?(1-proj-3-tuple(v_143))) in
        {438}let output_7: key = (if v_144 then 3-proj-3-tuple(v_143) else caught-fail) in
        {439}let temp_k_7: key = (if v_144 then 2-proj-3-tuple(v_143) else caught-fail) in
        {440}let ck_32: key = (if v_144 then 1-proj-3-tuple(v_143) else caught-fail) in
        {441}let ss_25: symmetricstate = (if v_137 then catch-fail((if v_140 then (if v_142 then (if v_144 then symmetricstatepack(cipherstatepack(temp_k_7,minnonce),ck_32,h_24) else fail-any) else fail-any) else fail-any)) else caught-fail) in
        {442}let v_145: bool = not-caught-fail(ss_25) in
        {443}let v_146: bitstring = (if v_145 then catch-fail(symmetricstateunpack(ss_25)) else caught-fail) in
        {444}let v_147: bool = (not-caught-fail(v_146) && success?(1-proj-3-tuple(v_146))) in
        {445}let h_25: bitstring = (if v_147 then 3-proj-3-tuple(v_146) else caught-fail) in
        {446}let ck_33: key = (if v_147 then 2-proj-3-tuple(v_146) else caught-fail) in
        {447}let cs_25: cipherstate = (if v_147 then 1-proj-3-tuple(v_146) else caught-fail) in
        {448}let v_148: bitstring = (if v_147 then catch-fail(cipherstateunpack(cs_25)) else caught-fail) in
        {449}let v_149: bool = (not-caught-fail(v_148) && success?(1-proj-2-tuple(v_148))) in
        {450}let n_2: nonce = (if v_149 then 2-proj-2-tuple(v_148) else caught-fail) in
        {451}let k_4: key = (if v_149 then 1-proj-2-tuple(v_148) else caught-fail) in
        {452}let e_7: bitstring = (if v_149 then encrypt(k_4,n_2,h_25,payload_1) else caught-fail) in
        {453}let n_3: nonce = (if v_149 then increment_nonce(n_2) else caught-fail) in
        {454}let v_150: bitstring = (if v_149 then catch-fail(cipherstateunpack(cs_25)) else caught-fail) in
        {455}let v_151: bool = (not-caught-fail(v_150) && success?(1-proj-2-tuple(v_150))) in
        {456}let o_1: nonce = (if v_151 then 2-proj-2-tuple(v_150) else caught-fail) in
        {457}let k_5: key = (if v_151 then 1-proj-2-tuple(v_150) else caught-fail) in
        {458}let csi_2: cipherstate = (if v_149 then catch-fail((if v_151 then cipherstatepack(k_5,n_3) else fail-any)) else caught-fail) in
        {459}let v_152: bool = not-caught-fail(csi_2) in
        {460}let v_153: bitstring = (if v_147 then catch-fail((if v_149 then (if v_152 then (csi_2,e_7) else fail-any) else fail-any)) else caught-fail) in
        {461}let v_154: bool = (not-caught-fail(v_153) && success?(1-proj-2-tuple(v_153))) in
        {462}let ciphertext_4: bitstring = (if v_154 then 2-proj-2-tuple(v_153) else caught-fail) in
        {463}let csi_3: cipherstate = (if v_154 then 1-proj-2-tuple(v_153) else caught-fail) in
        {464}let ss_26: symmetricstate = (if v_154 then symmetricstatepack(csi_3,ck_33,h_25) else caught-fail) in
        {465}let v_155: bitstring = (if v_154 then catch-fail(symmetricstateunpack(ss_26)) else caught-fail) in
        {466}let v_156: bool = (not-caught-fail(v_155) && success?(1-proj-3-tuple(v_155))) in
        {467}let h_26: bitstring = (if v_156 then 3-proj-3-tuple(v_155) else caught-fail) in
        {468}let ck_34: key = (if v_156 then 2-proj-3-tuple(v_155) else caught-fail) in
        {469}let cs_26: cipherstate = (if v_156 then 1-proj-3-tuple(v_155) else caught-fail) in
        {470}let ssi_2: symmetricstate = (if v_154 then catch-fail((if v_156 then symmetricstatepack(cs_26,ck_34,hash(h_26,ciphertext_4)) else fail-any)) else caught-fail) in
        {471}let v_157: bool = not-caught-fail(ssi_2) in
        {472}let v_158: bitstring = (if v_145 then catch-fail((if v_147 then (if v_154 then (if v_157 then (ssi_2,ciphertext_4) else fail-any) else fail-any) else fail-any)) else caught-fail) in
        {473}let v_159: bool = (not-caught-fail(v_158) && success?(1-proj-2-tuple(v_158))) in
        {474}let ciphertext_5: bitstring = (if v_159 then 2-proj-2-tuple(v_158) else caught-fail) in
        {475}let ss_27: symmetricstate = (if v_159 then 1-proj-2-tuple(v_158) else caught-fail) in
        {476}let hs_6: handshakestate = (if v_159 then handshakestatepack(ss_27,s_3,m_3,e_6,rs_3,rm_3,re_3,psk_3,initiator_2) else caught-fail) in
        {477}let message_buffer_1: bitstring = (if v_159 then concat3(ne_3,ns_1,ciphertext_5) else caught-fail) in
        {478}let v_160: bitstring = (if v_159 then catch-fail(symmetricstateunpack(ss_27)) else caught-fail) in
        {479}let v_161: bool = (not-caught-fail(v_160) && success?(1-proj-3-tuple(v_160))) in
        {480}let h_27: bitstring = (if v_161 then 3-proj-3-tuple(v_160) else caught-fail) in
        {481}let ck_35: key = (if v_161 then 2-proj-3-tuple(v_160) else caught-fail) in
        {482}let cs_27: cipherstate = (if v_161 then 1-proj-3-tuple(v_160) else caught-fail) in
        {483}let input_key_material_9: key = (if v_161 then zero else caught-fail) in
        {484}let output1_9: key = (if v_161 then hmac_hash1(ck_35,input_key_material_9) else caught-fail) in
        {485}let output2_9: key = (if v_161 then hmac_hash2(ck_35,input_key_material_9) else caught-fail) in
        {486}let output3_9: key = (if v_161 then hmac_hash3(ck_35,input_key_material_9) else caught-fail) in
        {487}let v_162: bitstring = (if v_161 then catch-fail((output1_9,output2_9,output3_9)) else caught-fail) in
        {488}let v_163: bool = (not-caught-fail(v_162) && success?(1-proj-3-tuple(v_162))) in
        {489}let temp_k3_1: key = (if v_163 then 3-proj-3-tuple(v_162) else caught-fail) in
        {490}let temp_k2_1: key = (if v_163 then 2-proj-3-tuple(v_162) else caught-fail) in
        {491}let temp_k1_1: key = (if v_163 then 1-proj-3-tuple(v_162) else caught-fail) in
        {492}let cs1_3: cipherstate = (if v_163 then cipherstatepack(temp_k1_1,minnonce) else caught-fail) in
        {493}let cs2_3: cipherstate = (if v_163 then cipherstatepack(temp_k2_1,minnonce) else caught-fail) in
        {494}let v_164: bitstring = (if v_159 then catch-fail((if v_161 then (if v_163 then (ss_27,cs1_3,cs2_3) else fail-any) else fail-any)) else caught-fail) in
        {495}let v_165: bool = (not-caught-fail(v_164) && success?(1-proj-3-tuple(v_164))) in
        {496}let cs2_4: cipherstate = (if v_165 then 3-proj-3-tuple(v_164) else caught-fail) in
        {497}let cs1_4: cipherstate = (if v_165 then 2-proj-3-tuple(v_164) else caught-fail) in
        {498}let ssi_3: symmetricstate = (if v_165 then 1-proj-3-tuple(v_164) else caught-fail) in
        {499}let (hs_7: handshakestate,message_a_1: bitstring,cs1_5: cipherstate,cs2_5: cipherstate) = (if v_105 then (if v_107 then (if v_109 then (if v_110 then (if v_113 then (if v_121 then (if v_129 then (if v_137 then (if v_145 then (if v_159 then (if v_165 then (hs_6,message_buffer_1,cs1_4,cs2_4) else fail-any) else fail-any) else fail-any) else fail-any) else fail-any) else fail-any) else fail-any) else fail-any) else fail-any) else fail-any) else fail-any) in
        {500}event SendMsg(me_1,them_1,stagepack_a(sid_2),msg_a(me_1,them_1,sid_2));
        {501}out(pub, message_a_1)
    ) | (
        {503}event LeakS(phase0,me_1);
        {504}event LeakM(phase0,me_1);
        {505}out(pub, (key_s(me_1),key_m(me_1)))
    ) | (
        {506}phase 1;
        {507}event LeakS(phase1,me_1);
        {508}event LeakM(phase1,me_1);
        {509}out(pub, (key_s(me_1),key_m(me_1)))
    )
) | (
    {510}let me_2: principal = bob in
    {511}let them_2: principal = alice in
    {512}let sid_3: sessionid = sid in
    {513}let basis_10: key = key_s(me_2) in
    {514}let public_key_10: key = catch-fail(dhexp(basis_10,validkey(g))) in
    {515}let v_166: bool = not-caught-fail(public_key_10) in
    {516}let s_4: keypair = (if v_166 then keypairpack(validkey(public_key_10),basis_10) else fail-any) in
    {517}let basis_11: key = key_m(me_2) in
    {518}let public_key_11: key = catch-fail(dhexp(basis_11,validkey(g))) in
    {519}let v_167: bool = not-caught-fail(public_key_11) in
    {520}let m_4: keypair = (if v_167 then keypairpack(validkey(public_key_11),basis_11) else fail-any) in
    {521}out(pub, (getpublickey(s_4),getpublickey(m_4)));
    (
        {522}let e_8: keypair = keypairpack(empty,empty) in
        {523}let basis_12: key = key_s(them_2) in
        {524}let public_key_12: key = catch-fail(dhexp(basis_12,validkey(g))) in
        {525}let v_168: bool = not-caught-fail(public_key_12) in
        {526}let rs_4: key = getpublickey((if v_168 then keypairpack(validkey(public_key_12),basis_12) else fail-any)) in
        {527}let basis_13: key = key_m(them_2) in
        {528}let public_key_13: key = catch-fail(dhexp(basis_13,validkey(g))) in
        {529}let v_169: bool = not-caught-fail(public_key_13) in
        {530}let rm_4: key = getpublickey((if v_169 then keypairpack(validkey(public_key_13),basis_13) else fail-any)) in
        {531}let re_4: key = empty in
        {532}let prologue_2: bitstring = empty in
        {533}let psk_4: key = empty in
        {534}let protocol_name_2: bitstring = somename in
        {535}let h_28: bitstring = hash(protocol_name_2,empty) in
        {536}let ck_36: key = h_28 in
        {537}let k_6: key = empty in
        {538}let cs_28: cipherstate = cipherstatepack(k_6,minnonce) in
        {539}let ss_28: symmetricstate = symmetricstatepack(cs_28,ck_36,h_28) in
        {540}let v_170: bitstring = catch-fail(symmetricstateunpack(ss_28)) in
        {541}let v_171: bool = (not-caught-fail(v_170) && success?(1-proj-3-tuple(v_170))) in
        {542}let h_29: bitstring = (if v_171 then 3-proj-3-tuple(v_170) else caught-fail) in
        {543}let ck_37: key = (if v_171 then 2-proj-3-tuple(v_170) else caught-fail) in
        {544}let cs_29: cipherstate = (if v_171 then 1-proj-3-tuple(v_170) else caught-fail) in
        {545}let ss_29: symmetricstate = catch-fail((if v_171 then symmetricstatepack(cs_29,ck_37,hash(h_29,prologue_2)) else fail-any)) in
        {546}let v_172: bool = not-caught-fail(ss_29) in
        {547}let v_173: bitstring = (if v_172 then catch-fail(symmetricstateunpack(ss_29)) else caught-fail) in
        {548}let v_174: bool = (not-caught-fail(v_173) && success?(1-proj-3-tuple(v_173))) in
        {549}let h_30: bitstring = (if v_174 then 3-proj-3-tuple(v_173) else caught-fail) in
        {550}let ck_38: key = (if v_174 then 2-proj-3-tuple(v_173) else caught-fail) in
        {551}let cs_30: cipherstate = (if v_174 then 1-proj-3-tuple(v_173) else caught-fail) in
        {552}let ss_30: symmetricstate = (if v_172 then catch-fail((if v_174 then symmetricstatepack(cs_30,ck_38,hash(h_30,rs_4)) else fail-any)) else caught-fail) in
        {553}let v_175: bool = not-caught-fail(ss_30) in
        {554}let v_176: bitstring = (if v_175 then catch-fail(symmetricstateunpack(ss_30)) else caught-fail) in
        {555}let v_177: bool = (not-caught-fail(v_176) && success?(1-proj-3-tuple(v_176))) in
        {556}let h_31: bitstring = (if v_177 then 3-proj-3-tuple(v_176) else caught-fail) in
        {557}let ck_39: key = (if v_177 then 2-proj-3-tuple(v_176) else caught-fail) in
        {558}let cs_31: cipherstate = (if v_177 then 1-proj-3-tuple(v_176) else caught-fail) in
        {559}let ss_31: symmetricstate = (if v_175 then catch-fail((if v_177 then symmetricstatepack(cs_31,ck_39,hash(h_31,rm_4)) else fail-any)) else caught-fail) in
        {560}let v_178: bool = not-caught-fail(ss_31) in
        {561}let data_4: bitstring = (if v_178 then catch-fail(getpublickey(s_4)) else caught-fail) in
        {562}let v_179: bool = not-caught-fail(data_4) in
        {563}let v_180: bitstring = (if v_179 then catch-fail(symmetricstateunpack(ss_31)) else caught-fail) in
        {564}let v_181: bool = (not-caught-fail(v_180) && success?(1-proj-3-tuple(v_180))) in
        {565}let h_32: bitstring = (if v_181 then 3-proj-3-tuple(v_180) else caught-fail) in
        {566}let ck_40: key = (if v_181 then 2-proj-3-tuple(v_180) else caught-fail) in
        {567}let cs_32: cipherstate = (if v_181 then 1-proj-3-tuple(v_180) else caught-fail) in
        {568}let ss_32: symmetricstate = (if v_178 then catch-fail((if v_179 then (if v_181 then symmetricstatepack(cs_32,ck_40,hash(h_32,data_4)) else fail-any) else fail-any)) else caught-fail) in
        {569}let v_182: bool = not-caught-fail(ss_32) in
        {570}let data_5: bitstring = (if v_182 then catch-fail(getpublickey(m_4)) else caught-fail) in
        {571}let v_183: bool = not-caught-fail(data_5) in
        {572}let v_184: bitstring = (if v_183 then catch-fail(symmetricstateunpack(ss_32)) else caught-fail) in
        {573}let v_185: bool = (not-caught-fail(v_184) && success?(1-proj-3-tuple(v_184))) in
        {574}let h_33: bitstring = (if v_185 then 3-proj-3-tuple(v_184) else caught-fail) in
        {575}let ck_41: key = (if v_185 then 2-proj-3-tuple(v_184) else caught-fail) in
        {576}let cs_33: cipherstate = (if v_185 then 1-proj-3-tuple(v_184) else caught-fail) in
        {577}let ss_33: symmetricstate = (if v_182 then catch-fail((if v_183 then (if v_185 then symmetricstatepack(cs_33,ck_41,hash(h_33,data_5)) else fail-any) else fail-any)) else caught-fail) in
        {578}let v_186: bool = not-caught-fail(ss_33) in
        {579}let hs_8: handshakestate = (if v_172 then (if v_175 then (if v_178 then (if v_182 then (if v_186 then handshakestatepack(ss_33,s_4,m_4,e_8,rs_4,rm_4,re_4,psk_4,false) else fail-any) else fail-any) else fail-any) else fail-any) else fail-any) in
        {580}insert statestore(me_2,them_2,sid_3,statepack_a(hs_8))
    ) | (
        {758}get statestore(=me_2,=them_2,=sid_3,statepack_a(hs_9: handshakestate)) in
        {581}in(pub, message_a_2: bitstring);
        {582}let v_187: bitstring = catch-fail(handshakestateunpack(hs_9)) in
        {583}let v_188: bool = (not-caught-fail(v_187) && success?(1-proj-9-tuple(v_187))) in
        {584}let initiator_3: bool = (if v_188 then 9-proj-9-tuple(v_187) else caught-fail) in
        {585}let psk_5: key = (if v_188 then 8-proj-9-tuple(v_187) else caught-fail) in
        {586}let re_5: key = (if v_188 then 7-proj-9-tuple(v_187) else caught-fail) in
        {587}let rm_5: key = (if v_188 then 6-proj-9-tuple(v_187) else caught-fail) in
        {588}let rs_5: key = (if v_188 then 5-proj-9-tuple(v_187) else caught-fail) in
        {589}let e_9: keypair = (if v_188 then 4-proj-9-tuple(v_187) else caught-fail) in
        {590}let m_5: keypair = (if v_188 then 3-proj-9-tuple(v_187) else caught-fail) in
        {591}let s_5: keypair = (if v_188 then 2-proj-9-tuple(v_187) else caught-fail) in
        {592}let ss_34: symmetricstate = (if v_188 then 1-proj-9-tuple(v_187) else caught-fail) in
        {593}let v_189: bitstring = (if v_188 then catch-fail(deconcat3(message_a_2)) else caught-fail) in
        {594}let v_190: bool = (not-caught-fail(v_189) && success?(1-proj-3-tuple(v_189))) in
        {595}let ciphertext_6: bitstring = (if v_190 then 3-proj-3-tuple(v_189) else caught-fail) in
        {596}let ns_2: bitstring = (if v_190 then 2-proj-3-tuple(v_189) else caught-fail) in
        {597}let ne_4: bitstring = (if v_190 then 1-proj-3-tuple(v_189) else caught-fail) in
        {598}let valid1: bool = (if v_190 then true else caught-fail) in
        {599}let re_6: key = (if v_190 then ne_4 else caught-fail) in
        {600}let v_191: bitstring = (if v_190 then catch-fail(symmetricstateunpack(ss_34)) else caught-fail) in
        {601}let v_192: bool = (not-caught-fail(v_191) && success?(1-proj-3-tuple(v_191))) in
        {602}let h_34: bitstring = (if v_192 then 3-proj-3-tuple(v_191) else caught-fail) in
        {603}let ck_42: key = (if v_192 then 2-proj-3-tuple(v_191) else caught-fail) in
        {604}let cs_34: cipherstate = (if v_192 then 1-proj-3-tuple(v_191) else caught-fail) in
        {605}let ss_35: symmetricstate = (if v_190 then catch-fail((if v_192 then symmetricstatepack(cs_34,ck_42,hash(h_34,re_6)) else fail-any)) else caught-fail) in
        {606}let v_193: bool = not-caught-fail(ss_35) in
        {607}let v_194: bitstring = (if v_193 then catch-fail(keypairunpack(s_5)) else caught-fail) in
        {608}let v_195: bool = (not-caught-fail(v_194) && success?(1-proj-2-tuple(v_194))) in
        {609}let my_private_key_8: key = (if v_195 then 2-proj-2-tuple(v_194) else caught-fail) in
        {610}let my_public_key_8: key = (if v_195 then 1-proj-2-tuple(v_194) else caught-fail) in
        {611}let input_key_material_10: key = (if v_193 then catch-fail((if v_195 then dhexp(my_private_key_8,re_6) else fail-any)) else caught-fail) in
        {612}let v_196: bool = not-caught-fail(input_key_material_10) in
        {613}let v_197: bitstring = (if v_196 then catch-fail(symmetricstateunpack(ss_35)) else caught-fail) in
        {614}let v_198: bool = (not-caught-fail(v_197) && success?(1-proj-3-tuple(v_197))) in
        {615}let h_35: bitstring = (if v_198 then 3-proj-3-tuple(v_197) else caught-fail) in
        {616}let ck_43: key = (if v_198 then 2-proj-3-tuple(v_197) else caught-fail) in
        {617}let cs_35: cipherstate = (if v_198 then 1-proj-3-tuple(v_197) else caught-fail) in
        {618}let output1_10: key = (if v_198 then hmac_hash1(ck_43,input_key_material_10) else caught-fail) in
        {619}let output2_10: key = (if v_198 then hmac_hash2(ck_43,input_key_material_10) else caught-fail) in
        {620}let output3_10: key = (if v_198 then hmac_hash3(ck_43,input_key_material_10) else caught-fail) in
        {621}let v_199: bitstring = (if v_198 then catch-fail((output1_10,output2_10,output3_10)) else caught-fail) in
        {622}let v_200: bool = (not-caught-fail(v_199) && success?(1-proj-3-tuple(v_199))) in
        {623}let output_8: key = (if v_200 then 3-proj-3-tuple(v_199) else caught-fail) in
        {624}let temp_k_8: key = (if v_200 then 2-proj-3-tuple(v_199) else caught-fail) in
        {625}let ck_44: key = (if v_200 then 1-proj-3-tuple(v_199) else caught-fail) in
        {626}let ss_36: symmetricstate = (if v_193 then catch-fail((if v_196 then (if v_198 then (if v_200 then symmetricstatepack(cipherstatepack(temp_k_8,minnonce),ck_44,h_35) else fail-any) else fail-any) else fail-any)) else caught-fail) in
        {627}let v_201: bool = not-caught-fail(ss_36) in
        {628}let v_202: bitstring = (if v_201 then catch-fail(keypairunpack(m_5)) else caught-fail) in
        {629}let v_203: bool = (not-caught-fail(v_202) && success?(1-proj-2-tuple(v_202))) in
        {630}let my_private_key_9: key = (if v_203 then 2-proj-2-tuple(v_202) else caught-fail) in
        {631}let my_public_key_9: key = (if v_203 then 1-proj-2-tuple(v_202) else caught-fail) in
        {632}let input_key_material_11: key = (if v_201 then catch-fail((if v_203 then dhexp(my_private_key_9,re_6) else fail-any)) else caught-fail) in
        {633}let v_204: bool = not-caught-fail(input_key_material_11) in
        {634}let v_205: bitstring = (if v_204 then catch-fail(symmetricstateunpack(ss_36)) else caught-fail) in
        {635}let v_206: bool = (not-caught-fail(v_205) && success?(1-proj-3-tuple(v_205))) in
        {636}let h_36: bitstring = (if v_206 then 3-proj-3-tuple(v_205) else caught-fail) in
        {637}let ck_45: key = (if v_206 then 2-proj-3-tuple(v_205) else caught-fail) in
        {638}let cs_36: cipherstate = (if v_206 then 1-proj-3-tuple(v_205) else caught-fail) in
        {639}let output1_11: key = (if v_206 then hmac_hash1(ck_45,input_key_material_11) else caught-fail) in
        {640}let output2_11: key = (if v_206 then hmac_hash2(ck_45,input_key_material_11) else caught-fail) in
        {641}let output3_11: key = (if v_206 then hmac_hash3(ck_45,input_key_material_11) else caught-fail) in
        {642}let v_207: bitstring = (if v_206 then catch-fail((output1_11,output2_11,output3_11)) else caught-fail) in
        {643}let v_208: bool = (not-caught-fail(v_207) && success?(1-proj-3-tuple(v_207))) in
        {644}let output_9: key = (if v_208 then 3-proj-3-tuple(v_207) else caught-fail) in
        {645}let temp_k_9: key = (if v_208 then 2-proj-3-tuple(v_207) else caught-fail) in
        {646}let ck_46: key = (if v_208 then 1-proj-3-tuple(v_207) else caught-fail) in
        {647}let ss_37: symmetricstate = (if v_201 then catch-fail((if v_204 then (if v_206 then (if v_208 then symmetricstatepack(cipherstatepack(temp_k_9,minnonce),ck_46,h_36) else fail-any) else fail-any) else fail-any)) else caught-fail) in
        {648}let v_209: bool = not-caught-fail(ss_37) in
        {649}let v_210: bitstring = (if v_209 then catch-fail(keypairunpack(s_5)) else caught-fail) in
        {650}let v_211: bool = (not-caught-fail(v_210) && success?(1-proj-2-tuple(v_210))) in
        {651}let my_private_key_10: key = (if v_211 then 2-proj-2-tuple(v_210) else caught-fail) in
        {652}let my_public_key_10: key = (if v_211 then 1-proj-2-tuple(v_210) else caught-fail) in
        {653}let input_key_material_12: key = (if v_209 then catch-fail((if v_211 then dhexp(my_private_key_10,rm_5) else fail-any)) else caught-fail) in
        {654}let v_212: bool = not-caught-fail(input_key_material_12) in
        {655}let v_213: bitstring = (if v_212 then catch-fail(symmetricstateunpack(ss_37)) else caught-fail) in
        {656}let v_214: bool = (not-caught-fail(v_213) && success?(1-proj-3-tuple(v_213))) in
        {657}let h_37: bitstring = (if v_214 then 3-proj-3-tuple(v_213) else caught-fail) in
        {658}let ck_47: key = (if v_214 then 2-proj-3-tuple(v_213) else caught-fail) in
        {659}let cs_37: cipherstate = (if v_214 then 1-proj-3-tuple(v_213) else caught-fail) in
        {660}let output1_12: key = (if v_214 then hmac_hash1(ck_47,input_key_material_12) else caught-fail) in
        {661}let output2_12: key = (if v_214 then hmac_hash2(ck_47,input_key_material_12) else caught-fail) in
        {662}let output3_12: key = (if v_214 then hmac_hash3(ck_47,input_key_material_12) else caught-fail) in
        {663}let v_215: bitstring = (if v_214 then catch-fail((output1_12,output2_12,output3_12)) else caught-fail) in
        {664}let v_216: bool = (not-caught-fail(v_215) && success?(1-proj-3-tuple(v_215))) in
        {665}let output_10: key = (if v_216 then 3-proj-3-tuple(v_215) else caught-fail) in
        {666}let temp_k_10: key = (if v_216 then 2-proj-3-tuple(v_215) else caught-fail) in
        {667}let ck_48: key = (if v_216 then 1-proj-3-tuple(v_215) else caught-fail) in
        {668}let ss_38: symmetricstate = (if v_209 then catch-fail((if v_212 then (if v_214 then (if v_216 then symmetricstatepack(cipherstatepack(temp_k_10,minnonce),ck_48,h_37) else fail-any) else fail-any) else fail-any)) else caught-fail) in
        {669}let v_217: bool = not-caught-fail(ss_38) in
        {670}let v_218: bitstring = (if v_217 then catch-fail(keypairunpack(m_5)) else caught-fail) in
        {671}let v_219: bool = (not-caught-fail(v_218) && success?(1-proj-2-tuple(v_218))) in
        {672}let my_private_key_11: key = (if v_219 then 2-proj-2-tuple(v_218) else caught-fail) in
        {673}let my_public_key_11: key = (if v_219 then 1-proj-2-tuple(v_218) else caught-fail) in
        {674}let input_key_material_13: key = (if v_217 then catch-fail((if v_219 then dhexp(my_private_key_11,rs_5) else fail-any)) else caught-fail) in
        {675}let v_220: bool = not-caught-fail(input_key_material_13) in
        {676}let v_221: bitstring = (if v_220 then catch-fail(symmetricstateunpack(ss_38)) else caught-fail) in
        {677}let v_222: bool = (not-caught-fail(v_221) && success?(1-proj-3-tuple(v_221))) in
        {678}let h_38: bitstring = (if v_222 then 3-proj-3-tuple(v_221) else caught-fail) in
        {679}let ck_49: key = (if v_222 then 2-proj-3-tuple(v_221) else caught-fail) in
        {680}let cs_38: cipherstate = (if v_222 then 1-proj-3-tuple(v_221) else caught-fail) in
        {681}let output1_13: key = (if v_222 then hmac_hash1(ck_49,input_key_material_13) else caught-fail) in
        {682}let output2_13: key = (if v_222 then hmac_hash2(ck_49,input_key_material_13) else caught-fail) in
        {683}let output3_13: key = (if v_222 then hmac_hash3(ck_49,input_key_material_13) else caught-fail) in
        {684}let v_223: bitstring = (if v_222 then catch-fail((output1_13,output2_13,output3_13)) else caught-fail) in
        {685}let v_224: bool = (not-caught-fail(v_223) && success?(1-proj-3-tuple(v_223))) in
        {686}let output_11: key = (if v_224 then 3-proj-3-tuple(v_223) else caught-fail) in
        {687}let temp_k_11: key = (if v_224 then 2-proj-3-tuple(v_223) else caught-fail) in
        {688}let ck_50: key = (if v_224 then 1-proj-3-tuple(v_223) else caught-fail) in
        {689}let ss_39: symmetricstate = (if v_217 then catch-fail((if v_220 then (if v_222 then (if v_224 then symmetricstatepack(cipherstatepack(temp_k_11,minnonce),ck_50,h_38) else fail-any) else fail-any) else fail-any)) else caught-fail) in
        {690}let v_225: bool = not-caught-fail(ss_39) in
        {691}let v_226: bitstring = (if v_225 then catch-fail(symmetricstateunpack(ss_39)) else caught-fail) in
        {692}let v_227: bool = (not-caught-fail(v_226) && success?(1-proj-3-tuple(v_226))) in
        {693}let h_39: bitstring = (if v_227 then 3-proj-3-tuple(v_226) else caught-fail) in
        {694}let ck_51: key = (if v_227 then 2-proj-3-tuple(v_226) else caught-fail) in
        {695}let cs_39: cipherstate = (if v_227 then 1-proj-3-tuple(v_226) else caught-fail) in
        {696}let v_228: bitstring = (if v_227 then catch-fail(cipherstateunpack(cs_39)) else caught-fail) in
        {697}let v_229: bool = (not-caught-fail(v_228) && success?(1-proj-2-tuple(v_228))) in
        {698}let n_4: nonce = (if v_229 then 2-proj-2-tuple(v_228) else caught-fail) in
        {699}let k_7: key = (if v_229 then 1-proj-2-tuple(v_228) else caught-fail) in
        {700}let d: aead = (if v_229 then catch-fail(decrypt(k_7,n_4,h_39,ciphertext_6)) else caught-fail) in
        {701}let v_230: bool = not-caught-fail(d) in
        {702}let v_231: bitstring = (if v_230 then catch-fail(aeadunpack(d)) else caught-fail) in
        {703}let v_232: bool = (not-caught-fail(v_231) && success?(1-proj-3-tuple(v_231))) in
        {704}let plaintext: bitstring = (if v_232 then 3-proj-3-tuple(v_231) else caught-fail) in
        {705}let adi: bitstring = (if v_232 then 2-proj-3-tuple(v_231) else caught-fail) in
        {706}let valid: bool = (if v_232 then 1-proj-3-tuple(v_231) else caught-fail) in
        {707}let n_5: nonce = (if v_232 then increment_nonce(n_4) else caught-fail) in
        {708}let v_233: bitstring = (if v_232 then catch-fail(cipherstateunpack(cs_39)) else caught-fail) in
        {709}let v_234: bool = (not-caught-fail(v_233) && success?(1-proj-2-tuple(v_233))) in
        {710}let o_2: nonce = (if v_234 then 2-proj-2-tuple(v_233) else caught-fail) in
        {711}let k_8: key = (if v_234 then 1-proj-2-tuple(v_233) else caught-fail) in
        {712}let csi_4: cipherstate = (if v_232 then catch-fail((if v_234 then cipherstatepack(k_8,n_5) else fail-any)) else caught-fail) in
        {713}let v_235: bool = not-caught-fail(csi_4) in
        {714}let v_236: bitstring = (if v_227 then catch-fail((if v_229 then (if v_230 then (if v_232 then (if v_235 then (csi_4,plaintext,valid) else fail-any) else fail-any) else fail-any) else fail-any)) else caught-fail) in
        {715}let v_237: bool = (not-caught-fail(v_236) && success?(1-proj-3-tuple(v_236))) in
        {716}let valid_1: bool = (if v_237 then 3-proj-3-tuple(v_236) else caught-fail) in
        {717}let plaintext_1: bitstring = (if v_237 then 2-proj-3-tuple(v_236) else caught-fail) in
        {718}let csi_5: cipherstate = (if v_237 then 1-proj-3-tuple(v_236) else caught-fail) in
        {719}let ss_40: symmetricstate = (if v_237 then symmetricstatepack(csi_5,ck_51,h_39) else caught-fail) in
        {720}let v_238: bitstring = (if v_237 then catch-fail(symmetricstateunpack(ss_40)) else caught-fail) in
        {721}let v_239: bool = (not-caught-fail(v_238) && success?(1-proj-3-tuple(v_238))) in
        {722}let h_40: bitstring = (if v_239 then 3-proj-3-tuple(v_238) else caught-fail) in
        {723}let ck_52: key = (if v_239 then 2-proj-3-tuple(v_238) else caught-fail) in
        {724}let cs_40: cipherstate = (if v_239 then 1-proj-3-tuple(v_238) else caught-fail) in
        {725}let ssi_4: symmetricstate = (if v_237 then catch-fail((if v_239 then symmetricstatepack(cs_40,ck_52,hash(h_40,ciphertext_6)) else fail-any)) else caught-fail) in
        {726}let v_240: bool = not-caught-fail(ssi_4) in
        {727}let v_241: bitstring = (if v_225 then catch-fail((if v_227 then (if v_237 then (if v_240 then (ssi_4,plaintext_1,valid_1) else fail-any) else fail-any) else fail-any)) else caught-fail) in
        {728}let v_242: bool = (not-caught-fail(v_241) && success?(1-proj-3-tuple(v_241))) in
        {729}let valid2: bool = (if v_242 then 3-proj-3-tuple(v_241) else caught-fail) in
        {730}let plaintext_2: bitstring = (if v_242 then 2-proj-3-tuple(v_241) else caught-fail) in
        {731}let ss_41: symmetricstate = (if v_242 then 1-proj-3-tuple(v_241) else caught-fail) in
        {732}let v_243: bool = (if v_242 then catch-fail((valid1 && valid2)) else caught-fail) in
        {733}let hs_10: handshakestate = (if v_243 then handshakestatepack(ss_41,s_5,m_5,e_9,rs_5,rm_5,re_6,psk_5,initiator_3) else caught-fail) in
        {734}let v_244: bitstring = (if v_243 then catch-fail(symmetricstateunpack(ss_41)) else caught-fail) in
        {735}let v_245: bool = (not-caught-fail(v_244) && success?(1-proj-3-tuple(v_244))) in
        {736}let h_41: bitstring = (if v_245 then 3-proj-3-tuple(v_244) else caught-fail) in
        {737}let ck_53: key = (if v_245 then 2-proj-3-tuple(v_244) else caught-fail) in
        {738}let cs_41: cipherstate = (if v_245 then 1-proj-3-tuple(v_244) else caught-fail) in
        {739}let input_key_material_14: key = (if v_245 then zero else caught-fail) in
        {740}let output1_14: key = (if v_245 then hmac_hash1(ck_53,input_key_material_14) else caught-fail) in
        {741}let output2_14: key = (if v_245 then hmac_hash2(ck_53,input_key_material_14) else caught-fail) in
        {742}let output3_14: key = (if v_245 then hmac_hash3(ck_53,input_key_material_14) else caught-fail) in
        {743}let v_246: bitstring = (if v_245 then catch-fail((output1_14,output2_14,output3_14)) else caught-fail) in
        {744}let v_247: bool = (not-caught-fail(v_246) && success?(1-proj-3-tuple(v_246))) in
        {745}let temp_k3_2: key = (if v_247 then 3-proj-3-tuple(v_246) else caught-fail) in
        {746}let temp_k2_2: key = (if v_247 then 2-proj-3-tuple(v_246) else caught-fail) in
        {747}let temp_k1_2: key = (if v_247 then 1-proj-3-tuple(v_246) else caught-fail) in
        {748}let cs1_6: cipherstate = (if v_247 then cipherstatepack(temp_k1_2,minnonce) else caught-fail) in
        {749}let cs2_6: cipherstate = (if v_247 then cipherstatepack(temp_k2_2,minnonce) else caught-fail) in
        {750}let v_248: bitstring = (if v_243 then catch-fail((if v_245 then (if v_247 then (ss_41,cs1_6,cs2_6) else fail-any) else fail-any)) else caught-fail) in
        {751}let v_249: bool = (not-caught-fail(v_248) && success?(1-proj-3-tuple(v_248))) in
        {752}let cs2_7: cipherstate = (if v_249 then 3-proj-3-tuple(v_248) else caught-fail) in
        {753}let cs1_7: cipherstate = (if v_249 then 2-proj-3-tuple(v_248) else caught-fail) in
        {754}let ssi_5: symmetricstate = (if v_249 then 1-proj-3-tuple(v_248) else caught-fail) in
        {755}let (hs_11: handshakestate,plaintext_a: bitstring,valid_2: bool,cs1_8: cipherstate,cs2_8: cipherstate) = (if v_188 then (if v_190 then (if v_193 then (if v_201 then (if v_209 then (if v_217 then (if v_225 then (if v_242 then (if undo-catch-fail(v_243) then (if v_249 then (hs_10,plaintext_2,true,cs1_7,cs2_7) else fail-any) else fail-any) else fail-any) else fail-any) else fail-any) else fail-any) else fail-any) else fail-any) else fail-any) else fail-any) in
        {756}event RecvMsg(me_2,them_2,stagepack_a(sid_3),plaintext_a);
        {757}event RecvEnd(valid_2)
    ) | (
        {759}event LeakS(phase0,me_2);
        {760}event LeakM(phase0,me_2);
        {761}out(pub, (key_s(me_2),key_m(me_2)))
    ) | (
        {762}phase 1;
        {763}event LeakS(phase1,me_2);
        {764}event LeakM(phase1,me_2);
        {765}out(pub, (key_s(me_2),key_m(me_2)))
    )
) | (
    {766}let me_3: principal = bob in
    {767}let them_3: principal = charlie in
    {768}let sid_4: sessionid = sid in
    {769}let basis_14: key = key_s(me_3) in
    {770}let public_key_14: key = catch-fail(dhexp(basis_14,validkey(g))) in
    {771}let v_250: bool = not-caught-fail(public_key_14) in
    {772}let s_6: keypair = (if v_250 then keypairpack(validkey(public_key_14),basis_14) else fail-any) in
    {773}let basis_15: key = key_m(me_3) in
    {774}let public_key_15: key = catch-fail(dhexp(basis_15,validkey(g))) in
    {775}let v_251: bool = not-caught-fail(public_key_15) in
    {776}let m_6: keypair = (if v_251 then keypairpack(validkey(public_key_15),basis_15) else fail-any) in
    {777}out(pub, (getpublickey(s_6),getpublickey(m_6)));
    (
        {778}let e_10: keypair = keypairpack(empty,empty) in
        {779}let basis_16: key = key_s(them_3) in
        {780}let public_key_16: key = catch-fail(dhexp(basis_16,validkey(g))) in
        {781}let v_252: bool = not-caught-fail(public_key_16) in
        {782}let rs_6: key = getpublickey((if v_252 then keypairpack(validkey(public_key_16),basis_16) else fail-any)) in
        {783}let basis_17: key = key_m(them_3) in
        {784}let public_key_17: key = catch-fail(dhexp(basis_17,validkey(g))) in
        {785}let v_253: bool = not-caught-fail(public_key_17) in
        {786}let rm_6: key = getpublickey((if v_253 then keypairpack(validkey(public_key_17),basis_17) else fail-any)) in
        {787}let re_7: key = empty in
        {788}let prologue_3: bitstring = empty in
        {789}let psk_6: key = empty in
        {790}let protocol_name_3: bitstring = somename in
        {791}let h_42: bitstring = hash(protocol_name_3,empty) in
        {792}let ck_54: key = h_42 in
        {793}let k_9: key = empty in
        {794}let cs_42: cipherstate = cipherstatepack(k_9,minnonce) in
        {795}let ss_42: symmetricstate = symmetricstatepack(cs_42,ck_54,h_42) in
        {796}let v_254: bitstring = catch-fail(symmetricstateunpack(ss_42)) in
        {797}let v_255: bool = (not-caught-fail(v_254) && success?(1-proj-3-tuple(v_254))) in
        {798}let h_43: bitstring = (if v_255 then 3-proj-3-tuple(v_254) else caught-fail) in
        {799}let ck_55: key = (if v_255 then 2-proj-3-tuple(v_254) else caught-fail) in
        {800}let cs_43: cipherstate = (if v_255 then 1-proj-3-tuple(v_254) else caught-fail) in
        {801}let ss_43: symmetricstate = catch-fail((if v_255 then symmetricstatepack(cs_43,ck_55,hash(h_43,prologue_3)) else fail-any)) in
        {802}let v_256: bool = not-caught-fail(ss_43) in
        {803}let v_257: bitstring = (if v_256 then catch-fail(symmetricstateunpack(ss_43)) else caught-fail) in
        {804}let v_258: bool = (not-caught-fail(v_257) && success?(1-proj-3-tuple(v_257))) in
        {805}let h_44: bitstring = (if v_258 then 3-proj-3-tuple(v_257) else caught-fail) in
        {806}let ck_56: key = (if v_258 then 2-proj-3-tuple(v_257) else caught-fail) in
        {807}let cs_44: cipherstate = (if v_258 then 1-proj-3-tuple(v_257) else caught-fail) in
        {808}let ss_44: symmetricstate = (if v_256 then catch-fail((if v_258 then symmetricstatepack(cs_44,ck_56,hash(h_44,rs_6)) else fail-any)) else caught-fail) in
        {809}let v_259: bool = not-caught-fail(ss_44) in
        {810}let v_260: bitstring = (if v_259 then catch-fail(symmetricstateunpack(ss_44)) else caught-fail) in
        {811}let v_261: bool = (not-caught-fail(v_260) && success?(1-proj-3-tuple(v_260))) in
        {812}let h_45: bitstring = (if v_261 then 3-proj-3-tuple(v_260) else caught-fail) in
        {813}let ck_57: key = (if v_261 then 2-proj-3-tuple(v_260) else caught-fail) in
        {814}let cs_45: cipherstate = (if v_261 then 1-proj-3-tuple(v_260) else caught-fail) in
        {815}let ss_45: symmetricstate = (if v_259 then catch-fail((if v_261 then symmetricstatepack(cs_45,ck_57,hash(h_45,rm_6)) else fail-any)) else caught-fail) in
        {816}let v_262: bool = not-caught-fail(ss_45) in
        {817}let data_6: bitstring = (if v_262 then catch-fail(getpublickey(s_6)) else caught-fail) in
        {818}let v_263: bool = not-caught-fail(data_6) in
        {819}let v_264: bitstring = (if v_263 then catch-fail(symmetricstateunpack(ss_45)) else caught-fail) in
        {820}let v_265: bool = (not-caught-fail(v_264) && success?(1-proj-3-tuple(v_264))) in
        {821}let h_46: bitstring = (if v_265 then 3-proj-3-tuple(v_264) else caught-fail) in
        {822}let ck_58: key = (if v_265 then 2-proj-3-tuple(v_264) else caught-fail) in
        {823}let cs_46: cipherstate = (if v_265 then 1-proj-3-tuple(v_264) else caught-fail) in
        {824}let ss_46: symmetricstate = (if v_262 then catch-fail((if v_263 then (if v_265 then symmetricstatepack(cs_46,ck_58,hash(h_46,data_6)) else fail-any) else fail-any)) else caught-fail) in
        {825}let v_266: bool = not-caught-fail(ss_46) in
        {826}let data_7: bitstring = (if v_266 then catch-fail(getpublickey(m_6)) else caught-fail) in
        {827}let v_267: bool = not-caught-fail(data_7) in
        {828}let v_268: bitstring = (if v_267 then catch-fail(symmetricstateunpack(ss_46)) else caught-fail) in
        {829}let v_269: bool = (not-caught-fail(v_268) && success?(1-proj-3-tuple(v_268))) in
        {830}let h_47: bitstring = (if v_269 then 3-proj-3-tuple(v_268) else caught-fail) in
        {831}let ck_59: key = (if v_269 then 2-proj-3-tuple(v_268) else caught-fail) in
        {832}let cs_47: cipherstate = (if v_269 then 1-proj-3-tuple(v_268) else caught-fail) in
        {833}let ss_47: symmetricstate = (if v_266 then catch-fail((if v_267 then (if v_269 then symmetricstatepack(cs_47,ck_59,hash(h_47,data_7)) else fail-any) else fail-any)) else caught-fail) in
        {834}let v_270: bool = not-caught-fail(ss_47) in
        {835}let hs_12: handshakestate = (if v_256 then (if v_259 then (if v_262 then (if v_266 then (if v_270 then handshakestatepack(ss_47,s_6,m_6,e_10,rs_6,rm_6,re_7,psk_6,false) else fail-any) else fail-any) else fail-any) else fail-any) else fail-any) in
        {836}insert statestore(me_3,them_3,sid_4,statepack_a(hs_12))
    ) | (
        {1014}get statestore(=me_3,=them_3,=sid_4,statepack_a(hs_13: handshakestate)) in
        {837}in(pub, message_a_3: bitstring);
        {838}let v_271: bitstring = catch-fail(handshakestateunpack(hs_13)) in
        {839}let v_272: bool = (not-caught-fail(v_271) && success?(1-proj-9-tuple(v_271))) in
        {840}let initiator_4: bool = (if v_272 then 9-proj-9-tuple(v_271) else caught-fail) in
        {841}let psk_7: key = (if v_272 then 8-proj-9-tuple(v_271) else caught-fail) in
        {842}let re_8: key = (if v_272 then 7-proj-9-tuple(v_271) else caught-fail) in
        {843}let rm_7: key = (if v_272 then 6-proj-9-tuple(v_271) else caught-fail) in
        {844}let rs_7: key = (if v_272 then 5-proj-9-tuple(v_271) else caught-fail) in
        {845}let e_11: keypair = (if v_272 then 4-proj-9-tuple(v_271) else caught-fail) in
        {846}let m_7: keypair = (if v_272 then 3-proj-9-tuple(v_271) else caught-fail) in
        {847}let s_7: keypair = (if v_272 then 2-proj-9-tuple(v_271) else caught-fail) in
        {848}let ss_48: symmetricstate = (if v_272 then 1-proj-9-tuple(v_271) else caught-fail) in
        {849}let v_273: bitstring = (if v_272 then catch-fail(deconcat3(message_a_3)) else caught-fail) in
        {850}let v_274: bool = (not-caught-fail(v_273) && success?(1-proj-3-tuple(v_273))) in
        {851}let ciphertext_7: bitstring = (if v_274 then 3-proj-3-tuple(v_273) else caught-fail) in
        {852}let ns_3: bitstring = (if v_274 then 2-proj-3-tuple(v_273) else caught-fail) in
        {853}let ne_5: bitstring = (if v_274 then 1-proj-3-tuple(v_273) else caught-fail) in
        {854}let valid1_1: bool = (if v_274 then true else caught-fail) in
        {855}let re_9: key = (if v_274 then ne_5 else caught-fail) in
        {856}let v_275: bitstring = (if v_274 then catch-fail(symmetricstateunpack(ss_48)) else caught-fail) in
        {857}let v_276: bool = (not-caught-fail(v_275) && success?(1-proj-3-tuple(v_275))) in
        {858}let h_48: bitstring = (if v_276 then 3-proj-3-tuple(v_275) else caught-fail) in
        {859}let ck_60: key = (if v_276 then 2-proj-3-tuple(v_275) else caught-fail) in
        {860}let cs_48: cipherstate = (if v_276 then 1-proj-3-tuple(v_275) else caught-fail) in
        {861}let ss_49: symmetricstate = (if v_274 then catch-fail((if v_276 then symmetricstatepack(cs_48,ck_60,hash(h_48,re_9)) else fail-any)) else caught-fail) in
        {862}let v_277: bool = not-caught-fail(ss_49) in
        {863}let v_278: bitstring = (if v_277 then catch-fail(keypairunpack(s_7)) else caught-fail) in
        {864}let v_279: bool = (not-caught-fail(v_278) && success?(1-proj-2-tuple(v_278))) in
        {865}let my_private_key_12: key = (if v_279 then 2-proj-2-tuple(v_278) else caught-fail) in
        {866}let my_public_key_12: key = (if v_279 then 1-proj-2-tuple(v_278) else caught-fail) in
        {867}let input_key_material_15: key = (if v_277 then catch-fail((if v_279 then dhexp(my_private_key_12,re_9) else fail-any)) else caught-fail) in
        {868}let v_280: bool = not-caught-fail(input_key_material_15) in
        {869}let v_281: bitstring = (if v_280 then catch-fail(symmetricstateunpack(ss_49)) else caught-fail) in
        {870}let v_282: bool = (not-caught-fail(v_281) && success?(1-proj-3-tuple(v_281))) in
        {871}let h_49: bitstring = (if v_282 then 3-proj-3-tuple(v_281) else caught-fail) in
        {872}let ck_61: key = (if v_282 then 2-proj-3-tuple(v_281) else caught-fail) in
        {873}let cs_49: cipherstate = (if v_282 then 1-proj-3-tuple(v_281) else caught-fail) in
        {874}let output1_15: key = (if v_282 then hmac_hash1(ck_61,input_key_material_15) else caught-fail) in
        {875}let output2_15: key = (if v_282 then hmac_hash2(ck_61,input_key_material_15) else caught-fail) in
        {876}let output3_15: key = (if v_282 then hmac_hash3(ck_61,input_key_material_15) else caught-fail) in
        {877}let v_283: bitstring = (if v_282 then catch-fail((output1_15,output2_15,output3_15)) else caught-fail) in
        {878}let v_284: bool = (not-caught-fail(v_283) && success?(1-proj-3-tuple(v_283))) in
        {879}let output_12: key = (if v_284 then 3-proj-3-tuple(v_283) else caught-fail) in
        {880}let temp_k_12: key = (if v_284 then 2-proj-3-tuple(v_283) else caught-fail) in
        {881}let ck_62: key = (if v_284 then 1-proj-3-tuple(v_283) else caught-fail) in
        {882}let ss_50: symmetricstate = (if v_277 then catch-fail((if v_280 then (if v_282 then (if v_284 then symmetricstatepack(cipherstatepack(temp_k_12,minnonce),ck_62,h_49) else fail-any) else fail-any) else fail-any)) else caught-fail) in
        {883}let v_285: bool = not-caught-fail(ss_50) in
        {884}let v_286: bitstring = (if v_285 then catch-fail(keypairunpack(m_7)) else caught-fail) in
        {885}let v_287: bool = (not-caught-fail(v_286) && success?(1-proj-2-tuple(v_286))) in
        {886}let my_private_key_13: key = (if v_287 then 2-proj-2-tuple(v_286) else caught-fail) in
        {887}let my_public_key_13: key = (if v_287 then 1-proj-2-tuple(v_286) else caught-fail) in
        {888}let input_key_material_16: key = (if v_285 then catch-fail((if v_287 then dhexp(my_private_key_13,re_9) else fail-any)) else caught-fail) in
        {889}let v_288: bool = not-caught-fail(input_key_material_16) in
        {890}let v_289: bitstring = (if v_288 then catch-fail(symmetricstateunpack(ss_50)) else caught-fail) in
        {891}let v_290: bool = (not-caught-fail(v_289) && success?(1-proj-3-tuple(v_289))) in
        {892}let h_50: bitstring = (if v_290 then 3-proj-3-tuple(v_289) else caught-fail) in
        {893}let ck_63: key = (if v_290 then 2-proj-3-tuple(v_289) else caught-fail) in
        {894}let cs_50: cipherstate = (if v_290 then 1-proj-3-tuple(v_289) else caught-fail) in
        {895}let output1_16: key = (if v_290 then hmac_hash1(ck_63,input_key_material_16) else caught-fail) in
        {896}let output2_16: key = (if v_290 then hmac_hash2(ck_63,input_key_material_16) else caught-fail) in
        {897}let output3_16: key = (if v_290 then hmac_hash3(ck_63,input_key_material_16) else caught-fail) in
        {898}let v_291: bitstring = (if v_290 then catch-fail((output1_16,output2_16,output3_16)) else caught-fail) in
        {899}let v_292: bool = (not-caught-fail(v_291) && success?(1-proj-3-tuple(v_291))) in
        {900}let output_13: key = (if v_292 then 3-proj-3-tuple(v_291) else caught-fail) in
        {901}let temp_k_13: key = (if v_292 then 2-proj-3-tuple(v_291) else caught-fail) in
        {902}let ck_64: key = (if v_292 then 1-proj-3-tuple(v_291) else caught-fail) in
        {903}let ss_51: symmetricstate = (if v_285 then catch-fail((if v_288 then (if v_290 then (if v_292 then symmetricstatepack(cipherstatepack(temp_k_13,minnonce),ck_64,h_50) else fail-any) else fail-any) else fail-any)) else caught-fail) in
        {904}let v_293: bool = not-caught-fail(ss_51) in
        {905}let v_294: bitstring = (if v_293 then catch-fail(keypairunpack(s_7)) else caught-fail) in
        {906}let v_295: bool = (not-caught-fail(v_294) && success?(1-proj-2-tuple(v_294))) in
        {907}let my_private_key_14: key = (if v_295 then 2-proj-2-tuple(v_294) else caught-fail) in
        {908}let my_public_key_14: key = (if v_295 then 1-proj-2-tuple(v_294) else caught-fail) in
        {909}let input_key_material_17: key = (if v_293 then catch-fail((if v_295 then dhexp(my_private_key_14,rm_7) else fail-any)) else caught-fail) in
        {910}let v_296: bool = not-caught-fail(input_key_material_17) in
        {911}let v_297: bitstring = (if v_296 then catch-fail(symmetricstateunpack(ss_51)) else caught-fail) in
        {912}let v_298: bool = (not-caught-fail(v_297) && success?(1-proj-3-tuple(v_297))) in
        {913}let h_51: bitstring = (if v_298 then 3-proj-3-tuple(v_297) else caught-fail) in
        {914}let ck_65: key = (if v_298 then 2-proj-3-tuple(v_297) else caught-fail) in
        {915}let cs_51: cipherstate = (if v_298 then 1-proj-3-tuple(v_297) else caught-fail) in
        {916}let output1_17: key = (if v_298 then hmac_hash1(ck_65,input_key_material_17) else caught-fail) in
        {917}let output2_17: key = (if v_298 then hmac_hash2(ck_65,input_key_material_17) else caught-fail) in
        {918}let output3_17: key = (if v_298 then hmac_hash3(ck_65,input_key_material_17) else caught-fail) in
        {919}let v_299: bitstring = (if v_298 then catch-fail((output1_17,output2_17,output3_17)) else caught-fail) in
        {920}let v_300: bool = (not-caught-fail(v_299) && success?(1-proj-3-tuple(v_299))) in
        {921}let output_14: key = (if v_300 then 3-proj-3-tuple(v_299) else caught-fail) in
        {922}let temp_k_14: key = (if v_300 then 2-proj-3-tuple(v_299) else caught-fail) in
        {923}let ck_66: key = (if v_300 then 1-proj-3-tuple(v_299) else caught-fail) in
        {924}let ss_52: symmetricstate = (if v_293 then catch-fail((if v_296 then (if v_298 then (if v_300 then symmetricstatepack(cipherstatepack(temp_k_14,minnonce),ck_66,h_51) else fail-any) else fail-any) else fail-any)) else caught-fail) in
        {925}let v_301: bool = not-caught-fail(ss_52) in
        {926}let v_302: bitstring = (if v_301 then catch-fail(keypairunpack(m_7)) else caught-fail) in
        {927}let v_303: bool = (not-caught-fail(v_302) && success?(1-proj-2-tuple(v_302))) in
        {928}let my_private_key_15: key = (if v_303 then 2-proj-2-tuple(v_302) else caught-fail) in
        {929}let my_public_key_15: key = (if v_303 then 1-proj-2-tuple(v_302) else caught-fail) in
        {930}let input_key_material_18: key = (if v_301 then catch-fail((if v_303 then dhexp(my_private_key_15,rs_7) else fail-any)) else caught-fail) in
        {931}let v_304: bool = not-caught-fail(input_key_material_18) in
        {932}let v_305: bitstring = (if v_304 then catch-fail(symmetricstateunpack(ss_52)) else caught-fail) in
        {933}let v_306: bool = (not-caught-fail(v_305) && success?(1-proj-3-tuple(v_305))) in
        {934}let h_52: bitstring = (if v_306 then 3-proj-3-tuple(v_305) else caught-fail) in
        {935}let ck_67: key = (if v_306 then 2-proj-3-tuple(v_305) else caught-fail) in
        {936}let cs_52: cipherstate = (if v_306 then 1-proj-3-tuple(v_305) else caught-fail) in
        {937}let output1_18: key = (if v_306 then hmac_hash1(ck_67,input_key_material_18) else caught-fail) in
        {938}let output2_18: key = (if v_306 then hmac_hash2(ck_67,input_key_material_18) else caught-fail) in
        {939}let output3_18: key = (if v_306 then hmac_hash3(ck_67,input_key_material_18) else caught-fail) in
        {940}let v_307: bitstring = (if v_306 then catch-fail((output1_18,output2_18,output3_18)) else caught-fail) in
        {941}let v_308: bool = (not-caught-fail(v_307) && success?(1-proj-3-tuple(v_307))) in
        {942}let output_15: key = (if v_308 then 3-proj-3-tuple(v_307) else caught-fail) in
        {943}let temp_k_15: key = (if v_308 then 2-proj-3-tuple(v_307) else caught-fail) in
        {944}let ck_68: key = (if v_308 then 1-proj-3-tuple(v_307) else caught-fail) in
        {945}let ss_53: symmetricstate = (if v_301 then catch-fail((if v_304 then (if v_306 then (if v_308 then symmetricstatepack(cipherstatepack(temp_k_15,minnonce),ck_68,h_52) else fail-any) else fail-any) else fail-any)) else caught-fail) in
        {946}let v_309: bool = not-caught-fail(ss_53) in
        {947}let v_310: bitstring = (if v_309 then catch-fail(symmetricstateunpack(ss_53)) else caught-fail) in
        {948}let v_311: bool = (not-caught-fail(v_310) && success?(1-proj-3-tuple(v_310))) in
        {949}let h_53: bitstring = (if v_311 then 3-proj-3-tuple(v_310) else caught-fail) in
        {950}let ck_69: key = (if v_311 then 2-proj-3-tuple(v_310) else caught-fail) in
        {951}let cs_53: cipherstate = (if v_311 then 1-proj-3-tuple(v_310) else caught-fail) in
        {952}let v_312: bitstring = (if v_311 then catch-fail(cipherstateunpack(cs_53)) else caught-fail) in
        {953}let v_313: bool = (not-caught-fail(v_312) && success?(1-proj-2-tuple(v_312))) in
        {954}let n_6: nonce = (if v_313 then 2-proj-2-tuple(v_312) else caught-fail) in
        {955}let k_10: key = (if v_313 then 1-proj-2-tuple(v_312) else caught-fail) in
        {956}let d_1: aead = (if v_313 then catch-fail(decrypt(k_10,n_6,h_53,ciphertext_7)) else caught-fail) in
        {957}let v_314: bool = not-caught-fail(d_1) in
        {958}let v_315: bitstring = (if v_314 then catch-fail(aeadunpack(d_1)) else caught-fail) in
        {959}let v_316: bool = (not-caught-fail(v_315) && success?(1-proj-3-tuple(v_315))) in
        {960}let plaintext_3: bitstring = (if v_316 then 3-proj-3-tuple(v_315) else caught-fail) in
        {961}let adi_1: bitstring = (if v_316 then 2-proj-3-tuple(v_315) else caught-fail) in
        {962}let valid_3: bool = (if v_316 then 1-proj-3-tuple(v_315) else caught-fail) in
        {963}let n_7: nonce = (if v_316 then increment_nonce(n_6) else caught-fail) in
        {964}let v_317: bitstring = (if v_316 then catch-fail(cipherstateunpack(cs_53)) else caught-fail) in
        {965}let v_318: bool = (not-caught-fail(v_317) && success?(1-proj-2-tuple(v_317))) in
        {966}let o_3: nonce = (if v_318 then 2-proj-2-tuple(v_317) else caught-fail) in
        {967}let k_11: key = (if v_318 then 1-proj-2-tuple(v_317) else caught-fail) in
        {968}let csi_6: cipherstate = (if v_316 then catch-fail((if v_318 then cipherstatepack(k_11,n_7) else fail-any)) else caught-fail) in
        {969}let v_319: bool = not-caught-fail(csi_6) in
        {970}let v_320: bitstring = (if v_311 then catch-fail((if v_313 then (if v_314 then (if v_316 then (if v_319 then (csi_6,plaintext_3,valid_3) else fail-any) else fail-any) else fail-any) else fail-any)) else caught-fail) in
        {971}let v_321: bool = (not-caught-fail(v_320) && success?(1-proj-3-tuple(v_320))) in
        {972}let valid_4: bool = (if v_321 then 3-proj-3-tuple(v_320) else caught-fail) in
        {973}let plaintext_4: bitstring = (if v_321 then 2-proj-3-tuple(v_320) else caught-fail) in
        {974}let csi_7: cipherstate = (if v_321 then 1-proj-3-tuple(v_320) else caught-fail) in
        {975}let ss_54: symmetricstate = (if v_321 then symmetricstatepack(csi_7,ck_69,h_53) else caught-fail) in
        {976}let v_322: bitstring = (if v_321 then catch-fail(symmetricstateunpack(ss_54)) else caught-fail) in
        {977}let v_323: bool = (not-caught-fail(v_322) && success?(1-proj-3-tuple(v_322))) in
        {978}let h_54: bitstring = (if v_323 then 3-proj-3-tuple(v_322) else caught-fail) in
        {979}let ck_70: key = (if v_323 then 2-proj-3-tuple(v_322) else caught-fail) in
        {980}let cs_54: cipherstate = (if v_323 then 1-proj-3-tuple(v_322) else caught-fail) in
        {981}let ssi_6: symmetricstate = (if v_321 then catch-fail((if v_323 then symmetricstatepack(cs_54,ck_70,hash(h_54,ciphertext_7)) else fail-any)) else caught-fail) in
        {982}let v_324: bool = not-caught-fail(ssi_6) in
        {983}let v_325: bitstring = (if v_309 then catch-fail((if v_311 then (if v_321 then (if v_324 then (ssi_6,plaintext_4,valid_4) else fail-any) else fail-any) else fail-any)) else caught-fail) in
        {984}let v_326: bool = (not-caught-fail(v_325) && success?(1-proj-3-tuple(v_325))) in
        {985}let valid2_1: bool = (if v_326 then 3-proj-3-tuple(v_325) else caught-fail) in
        {986}let plaintext_5: bitstring = (if v_326 then 2-proj-3-tuple(v_325) else caught-fail) in
        {987}let ss_55: symmetricstate = (if v_326 then 1-proj-3-tuple(v_325) else caught-fail) in
        {988}let v_327: bool = (if v_326 then catch-fail((valid1_1 && valid2_1)) else caught-fail) in
        {989}let hs_14: handshakestate = (if v_327 then handshakestatepack(ss_55,s_7,m_7,e_11,rs_7,rm_7,re_9,psk_7,initiator_4) else caught-fail) in
        {990}let v_328: bitstring = (if v_327 then catch-fail(symmetricstateunpack(ss_55)) else caught-fail) in
        {991}let v_329: bool = (not-caught-fail(v_328) && success?(1-proj-3-tuple(v_328))) in
        {992}let h_55: bitstring = (if v_329 then 3-proj-3-tuple(v_328) else caught-fail) in
        {993}let ck_71: key = (if v_329 then 2-proj-3-tuple(v_328) else caught-fail) in
        {994}let cs_55: cipherstate = (if v_329 then 1-proj-3-tuple(v_328) else caught-fail) in
        {995}let input_key_material_19: key = (if v_329 then zero else caught-fail) in
        {996}let output1_19: key = (if v_329 then hmac_hash1(ck_71,input_key_material_19) else caught-fail) in
        {997}let output2_19: key = (if v_329 then hmac_hash2(ck_71,input_key_material_19) else caught-fail) in
        {998}let output3_19: key = (if v_329 then hmac_hash3(ck_71,input_key_material_19) else caught-fail) in
        {999}let v_330: bitstring = (if v_329 then catch-fail((output1_19,output2_19,output3_19)) else caught-fail) in
        {1000}let v_331: bool = (not-caught-fail(v_330) && success?(1-proj-3-tuple(v_330))) in
        {1001}let temp_k3_3: key = (if v_331 then 3-proj-3-tuple(v_330) else caught-fail) in
        {1002}let temp_k2_3: key = (if v_331 then 2-proj-3-tuple(v_330) else caught-fail) in
        {1003}let temp_k1_3: key = (if v_331 then 1-proj-3-tuple(v_330) else caught-fail) in
        {1004}let cs1_9: cipherstate = (if v_331 then cipherstatepack(temp_k1_3,minnonce) else caught-fail) in
        {1005}let cs2_9: cipherstate = (if v_331 then cipherstatepack(temp_k2_3,minnonce) else caught-fail) in
        {1006}let v_332: bitstring = (if v_327 then catch-fail((if v_329 then (if v_331 then (ss_55,cs1_9,cs2_9) else fail-any) else fail-any)) else caught-fail) in
        {1007}let v_333: bool = (not-caught-fail(v_332) && success?(1-proj-3-tuple(v_332))) in
        {1008}let cs2_10: cipherstate = (if v_333 then 3-proj-3-tuple(v_332) else caught-fail) in
        {1009}let cs1_10: cipherstate = (if v_333 then 2-proj-3-tuple(v_332) else caught-fail) in
        {1010}let ssi_7: symmetricstate = (if v_333 then 1-proj-3-tuple(v_332) else caught-fail) in
        {1011}let (hs_15: handshakestate,plaintext_a_1: bitstring,valid_5: bool,cs1_11: cipherstate,cs2_11: cipherstate) = (if v_272 then (if v_274 then (if v_277 then (if v_285 then (if v_293 then (if v_301 then (if v_309 then (if v_326 then (if undo-catch-fail(v_327) then (if v_333 then (hs_14,plaintext_5,true,cs1_10,cs2_10) else fail-any) else fail-any) else fail-any) else fail-any) else fail-any) else fail-any) else fail-any) else fail-any) else fail-any) else fail-any) in
        {1012}event RecvMsg(me_3,them_3,stagepack_a(sid_4),plaintext_a_1);
        {1013}event RecvEnd(valid_5)
    ) | (
        {1015}event LeakS(phase0,me_3);
        {1016}event LeakM(phase0,me_3);
        {1017}out(pub, (key_s(me_3),key_m(me_3)))
    ) | (
        {1018}phase 1;
        {1019}event LeakS(phase1,me_3);
        {1020}event LeakM(phase1,me_3);
        {1021}out(pub, (key_s(me_3),key_m(me_3)))
    )
)

--  Process 1 (that is, process 0, with let moved downwards):
{1}out(pub, (key_s(charlie),key_m(charlie)));
{2}!
{3}new sid: sessionid;
(
    {4}let me: principal = alice in
    {7}let basis: key = key_s(me) in
    {8}let public_key: key = catch-fail(dhexp(basis,validkey(g))) in
    {9}let v: bool = not-caught-fail(public_key) in
    {10}let s: keypair = (if v then keypairpack(validkey(public_key),basis) else fail-any) in
    {11}let basis_1: key = key_m(me) in
    {12}let public_key_1: key = catch-fail(dhexp(basis_1,validkey(g))) in
    {13}let v_1: bool = not-caught-fail(public_key_1) in
    {14}let m: keypair = (if v_1 then keypairpack(validkey(public_key_1),basis_1) else fail-any) in
    {15}out(pub, (getpublickey(s),getpublickey(m)));
    {6}let sid_1: sessionid = sid in
    {5}let them: principal = bob in
    (
        {17}let basis_2: key = key_s(them) in
        {18}let public_key_2: key = catch-fail(dhexp(basis_2,validkey(g))) in
        {19}let v_2: bool = not-caught-fail(public_key_2) in
        {20}let rs: key = getpublickey((if v_2 then keypairpack(validkey(public_key_2),basis_2) else fail-any)) in
        {21}let basis_3: key = key_s(them) in
        {22}let public_key_3: key = catch-fail(dhexp(basis_3,validkey(g))) in
        {23}let v_3: bool = not-caught-fail(public_key_3) in
        {24}let rm: key = getpublickey((if v_3 then keypairpack(validkey(public_key_3),basis_3) else fail-any)) in
        {31}let k: key = empty in
        {32}let cs: cipherstate = cipherstatepack(k,minnonce) in
        {28}let protocol_name: bitstring = somename in
        {29}let h: bitstring = hash(protocol_name,empty) in
        {30}let ck: key = h in
        {33}let ss: symmetricstate = symmetricstatepack(cs,ck,h) in
        {34}let v_4: bitstring = catch-fail(symmetricstateunpack(ss)) in
        {35}let v_5: bool = (not-caught-fail(v_4) && success?(1-proj-3-tuple(v_4))) in
        {36}let h_1: bitstring = (if v_5 then 3-proj-3-tuple(v_4) else caught-fail) in
        {37}let ck_1: key = (if v_5 then 2-proj-3-tuple(v_4) else caught-fail) in
        {38}let cs_1: cipherstate = (if v_5 then 1-proj-3-tuple(v_4) else caught-fail) in
        {26}let prologue: bitstring = empty in
        {39}let ss_1: symmetricstate = catch-fail((if v_5 then symmetricstatepack(cs_1,ck_1,hash(h_1,prologue)) else fail-any)) in
        {40}let v_6: bool = not-caught-fail(ss_1) in
        {41}let data: bitstring = (if v_6 then catch-fail(getpublickey(s)) else caught-fail) in
        {42}let v_7: bool = not-caught-fail(data) in
        {43}let v_8: bitstring = (if v_7 then catch-fail(symmetricstateunpack(ss_1)) else caught-fail) in
        {44}let v_9: bool = (not-caught-fail(v_8) && success?(1-proj-3-tuple(v_8))) in
        {45}let h_2: bitstring = (if v_9 then 3-proj-3-tuple(v_8) else caught-fail) in
        {46}let ck_2: key = (if v_9 then 2-proj-3-tuple(v_8) else caught-fail) in
        {47}let cs_2: cipherstate = (if v_9 then 1-proj-3-tuple(v_8) else caught-fail) in
        {48}let ss_2: symmetricstate = (if v_6 then catch-fail((if v_7 then (if v_9 then symmetricstatepack(cs_2,ck_2,hash(h_2,data)) else fail-any) else fail-any)) else caught-fail) in
        {49}let v_10: bool = not-caught-fail(ss_2) in
        {50}let data_1: bitstring = (if v_10 then catch-fail(getpublickey(m)) else caught-fail) in
        {51}let v_11: bool = not-caught-fail(data_1) in
        {52}let v_12: bitstring = (if v_11 then catch-fail(symmetricstateunpack(ss_2)) else caught-fail) in
        {53}let v_13: bool = (not-caught-fail(v_12) && success?(1-proj-3-tuple(v_12))) in
        {54}let h_3: bitstring = (if v_13 then 3-proj-3-tuple(v_12) else caught-fail) in
        {55}let ck_3: key = (if v_13 then 2-proj-3-tuple(v_12) else caught-fail) in
        {56}let cs_3: cipherstate = (if v_13 then 1-proj-3-tuple(v_12) else caught-fail) in
        {57}let ss_3: symmetricstate = (if v_10 then catch-fail((if v_11 then (if v_13 then symmetricstatepack(cs_3,ck_3,hash(h_3,data_1)) else fail-any) else fail-any)) else caught-fail) in
        {58}let v_14: bool = not-caught-fail(ss_3) in
        {59}let v_15: bitstring = (if v_14 then catch-fail(symmetricstateunpack(ss_3)) else caught-fail) in
        {60}let v_16: bool = (not-caught-fail(v_15) && success?(1-proj-3-tuple(v_15))) in
        {61}let h_4: bitstring = (if v_16 then 3-proj-3-tuple(v_15) else caught-fail) in
        {62}let ck_4: key = (if v_16 then 2-proj-3-tuple(v_15) else caught-fail) in
        {63}let cs_4: cipherstate = (if v_16 then 1-proj-3-tuple(v_15) else caught-fail) in
        {64}let ss_4: symmetricstate = (if v_14 then catch-fail((if v_16 then symmetricstatepack(cs_4,ck_4,hash(h_4,rs)) else fail-any)) else caught-fail) in
        {65}let v_17: bool = not-caught-fail(ss_4) in
        {66}let v_18: bitstring = (if v_17 then catch-fail(symmetricstateunpack(ss_4)) else caught-fail) in
        {67}let v_19: bool = (not-caught-fail(v_18) && success?(1-proj-3-tuple(v_18))) in
        {68}let h_5: bitstring = (if v_19 then 3-proj-3-tuple(v_18) else caught-fail) in
        {69}let ck_5: key = (if v_19 then 2-proj-3-tuple(v_18) else caught-fail) in
        {70}let cs_5: cipherstate = (if v_19 then 1-proj-3-tuple(v_18) else caught-fail) in
        {71}let ss_5: symmetricstate = (if v_17 then catch-fail((if v_19 then symmetricstatepack(cs_5,ck_5,hash(h_5,rm)) else fail-any)) else caught-fail) in
        {72}let v_20: bool = not-caught-fail(ss_5) in
        {27}let psk: key = empty in
        {25}let re: key = empty in
        {16}let e: keypair = keypairpack(empty,empty) in
        {73}let hs: handshakestate = (if v_6 then (if v_10 then (if v_14 then (if v_17 then (if v_20 then handshakestatepack(ss_5,s,m,e,rs,rm,re,psk,true) else fail-any) else fail-any) else fail-any) else fail-any) else fail-any) in
        {74}insert statestore(me,them,sid_1,statepack_a(hs))
    ) | (
        {249}get statestore(=me,=them,=sid_1,statepack_a(hs_1: handshakestate)) in
        {76}let v_21: bitstring = catch-fail(handshakestateunpack(hs_1)) in
        {77}let v_22: bool = (not-caught-fail(v_21) && success?(1-proj-9-tuple(v_21))) in
        {78}let initiator_1: bool = (if v_22 then 9-proj-9-tuple(v_21) else caught-fail) in
        {79}let psk_1: key = (if v_22 then 8-proj-9-tuple(v_21) else caught-fail) in
        {80}let re_1: key = (if v_22 then 7-proj-9-tuple(v_21) else caught-fail) in
        {81}let rm_1: key = (if v_22 then 6-proj-9-tuple(v_21) else caught-fail) in
        {82}let rs_1: key = (if v_22 then 5-proj-9-tuple(v_21) else caught-fail) in
        {83}let e_1: keypair = (if v_22 then 4-proj-9-tuple(v_21) else caught-fail) in
        {84}let m_1: keypair = (if v_22 then 3-proj-9-tuple(v_21) else caught-fail) in
        {85}let s_1: keypair = (if v_22 then 2-proj-9-tuple(v_21) else caught-fail) in
        {86}let ss_6: symmetricstate = (if v_22 then 1-proj-9-tuple(v_21) else caught-fail) in
        {87}let v_23: bitstring = (if v_22 then catch-fail((empty,empty,empty)) else caught-fail) in
        {88}let v_24: bool = (not-caught-fail(v_23) && success?(1-proj-3-tuple(v_23))) in
        {89}let ciphertext: bitstring = (if v_24 then 3-proj-3-tuple(v_23) else caught-fail) in
        {90}let ns: bitstring = (if v_24 then 2-proj-3-tuple(v_23) else caught-fail) in
        {91}let ne: bitstring = (if v_24 then 1-proj-3-tuple(v_23) else caught-fail) in
        {92}let basis_4: key = (if v_24 then key_e(me,them,sid_1) else caught-fail) in
        {93}let public_key_4: key = (if v_24 then catch-fail(dhexp(basis_4,validkey(g))) else caught-fail) in
        {94}let v_25: bool = not-caught-fail(public_key_4) in
        {95}let e_2: keypair = (if v_24 then catch-fail((if v_25 then keypairpack(validkey(public_key_4),basis_4) else fail-any)) else caught-fail) in
        {96}let v_26: bool = not-caught-fail(e_2) in
        {97}let ne_1: bitstring = (if v_26 then catch-fail(getpublickey(e_2)) else caught-fail) in
        {98}let v_27: bool = not-caught-fail(ne_1) in
        {99}let v_28: bitstring = (if v_27 then catch-fail(symmetricstateunpack(ss_6)) else caught-fail) in
        {100}let v_29: bool = (not-caught-fail(v_28) && success?(1-proj-3-tuple(v_28))) in
        {101}let h_6: bitstring = (if v_29 then 3-proj-3-tuple(v_28) else caught-fail) in
        {102}let ck_6: key = (if v_29 then 2-proj-3-tuple(v_28) else caught-fail) in
        {103}let cs_6: cipherstate = (if v_29 then 1-proj-3-tuple(v_28) else caught-fail) in
        {104}let ss_7: symmetricstate = (if v_27 then catch-fail((if v_29 then symmetricstatepack(cs_6,ck_6,hash(h_6,ne_1)) else fail-any)) else caught-fail) in
        {105}let v_30: bool = not-caught-fail(ss_7) in
        {106}let v_31: bitstring = (if v_30 then catch-fail(keypairunpack(e_2)) else caught-fail) in
        {107}let v_32: bool = (not-caught-fail(v_31) && success?(1-proj-2-tuple(v_31))) in
        {108}let my_private_key: key = (if v_32 then 2-proj-2-tuple(v_31) else caught-fail) in
        {109}let my_public_key: key = (if v_32 then 1-proj-2-tuple(v_31) else caught-fail) in
        {110}let input_key_material: key = (if v_30 then catch-fail((if v_32 then dhexp(my_private_key,rs_1) else fail-any)) else caught-fail) in
        {111}let v_33: bool = not-caught-fail(input_key_material) in
        {112}let v_34: bitstring = (if v_33 then catch-fail(symmetricstateunpack(ss_7)) else caught-fail) in
        {113}let v_35: bool = (not-caught-fail(v_34) && success?(1-proj-3-tuple(v_34))) in
        {114}let h_7: bitstring = (if v_35 then 3-proj-3-tuple(v_34) else caught-fail) in
        {115}let ck_7: key = (if v_35 then 2-proj-3-tuple(v_34) else caught-fail) in
        {116}let cs_7: cipherstate = (if v_35 then 1-proj-3-tuple(v_34) else caught-fail) in
        {119}let output3: key = (if v_35 then hmac_hash3(ck_7,input_key_material) else caught-fail) in
        {118}let output2: key = (if v_35 then hmac_hash2(ck_7,input_key_material) else caught-fail) in
        {117}let output1: key = (if v_35 then hmac_hash1(ck_7,input_key_material) else caught-fail) in
        {120}let v_36: bitstring = (if v_35 then catch-fail((output1,output2,output3)) else caught-fail) in
        {121}let v_37: bool = (not-caught-fail(v_36) && success?(1-proj-3-tuple(v_36))) in
        {122}let output_3: key = (if v_37 then 3-proj-3-tuple(v_36) else caught-fail) in
        {123}let temp_k: key = (if v_37 then 2-proj-3-tuple(v_36) else caught-fail) in
        {124}let ck_8: key = (if v_37 then 1-proj-3-tuple(v_36) else caught-fail) in
        {125}let ss_8: symmetricstate = (if v_30 then catch-fail((if v_33 then (if v_35 then (if v_37 then symmetricstatepack(cipherstatepack(temp_k,minnonce),ck_8,h_7) else fail-any) else fail-any) else fail-any)) else caught-fail) in
        {126}let v_38: bool = not-caught-fail(ss_8) in
        {127}let v_39: bitstring = (if v_38 then catch-fail(keypairunpack(e_2)) else caught-fail) in
        {128}let v_40: bool = (not-caught-fail(v_39) && success?(1-proj-2-tuple(v_39))) in
        {129}let my_private_key_1: key = (if v_40 then 2-proj-2-tuple(v_39) else caught-fail) in
        {130}let my_public_key_1: key = (if v_40 then 1-proj-2-tuple(v_39) else caught-fail) in
        {131}let input_key_material_1: key = (if v_38 then catch-fail((if v_40 then dhexp(my_private_key_1,rm_1) else fail-any)) else caught-fail) in
        {132}let v_41: bool = not-caught-fail(input_key_material_1) in
        {133}let v_42: bitstring = (if v_41 then catch-fail(symmetricstateunpack(ss_8)) else caught-fail) in
        {134}let v_43: bool = (not-caught-fail(v_42) && success?(1-proj-3-tuple(v_42))) in
        {135}let h_8: bitstring = (if v_43 then 3-proj-3-tuple(v_42) else caught-fail) in
        {136}let ck_9: key = (if v_43 then 2-proj-3-tuple(v_42) else caught-fail) in
        {137}let cs_8: cipherstate = (if v_43 then 1-proj-3-tuple(v_42) else caught-fail) in
        {140}let output3_1: key = (if v_43 then hmac_hash3(ck_9,input_key_material_1) else caught-fail) in
        {139}let output2_1: key = (if v_43 then hmac_hash2(ck_9,input_key_material_1) else caught-fail) in
        {138}let output1_1: key = (if v_43 then hmac_hash1(ck_9,input_key_material_1) else caught-fail) in
        {141}let v_44: bitstring = (if v_43 then catch-fail((output1_1,output2_1,output3_1)) else caught-fail) in
        {142}let v_45: bool = (not-caught-fail(v_44) && success?(1-proj-3-tuple(v_44))) in
        {143}let output: key = (if v_45 then 3-proj-3-tuple(v_44) else caught-fail) in
        {144}let temp_k_1: key = (if v_45 then 2-proj-3-tuple(v_44) else caught-fail) in
        {145}let ck_10: key = (if v_45 then 1-proj-3-tuple(v_44) else caught-fail) in
        {146}let ss_9: symmetricstate = (if v_38 then catch-fail((if v_41 then (if v_43 then (if v_45 then symmetricstatepack(cipherstatepack(temp_k_1,minnonce),ck_10,h_8) else fail-any) else fail-any) else fail-any)) else caught-fail) in
        {147}let v_46: bool = not-caught-fail(ss_9) in
        {148}let v_47: bitstring = (if v_46 then catch-fail(keypairunpack(m_1)) else caught-fail) in
        {149}let v_48: bool = (not-caught-fail(v_47) && success?(1-proj-2-tuple(v_47))) in
        {150}let my_private_key_2: key = (if v_48 then 2-proj-2-tuple(v_47) else caught-fail) in
        {151}let my_public_key_2: key = (if v_48 then 1-proj-2-tuple(v_47) else caught-fail) in
        {152}let input_key_material_2: key = (if v_46 then catch-fail((if v_48 then dhexp(my_private_key_2,rs_1) else fail-any)) else caught-fail) in
        {153}let v_49: bool = not-caught-fail(input_key_material_2) in
        {154}let v_50: bitstring = (if v_49 then catch-fail(symmetricstateunpack(ss_9)) else caught-fail) in
        {155}let v_51: bool = (not-caught-fail(v_50) && success?(1-proj-3-tuple(v_50))) in
        {156}let h_9: bitstring = (if v_51 then 3-proj-3-tuple(v_50) else caught-fail) in
        {157}let ck_11: key = (if v_51 then 2-proj-3-tuple(v_50) else caught-fail) in
        {158}let cs_9: cipherstate = (if v_51 then 1-proj-3-tuple(v_50) else caught-fail) in
        {161}let output3_2: key = (if v_51 then hmac_hash3(ck_11,input_key_material_2) else caught-fail) in
        {160}let output2_2: key = (if v_51 then hmac_hash2(ck_11,input_key_material_2) else caught-fail) in
        {159}let output1_2: key = (if v_51 then hmac_hash1(ck_11,input_key_material_2) else caught-fail) in
        {162}let v_52: bitstring = (if v_51 then catch-fail((output1_2,output2_2,output3_2)) else caught-fail) in
        {163}let v_53: bool = (not-caught-fail(v_52) && success?(1-proj-3-tuple(v_52))) in
        {164}let output_1: key = (if v_53 then 3-proj-3-tuple(v_52) else caught-fail) in
        {165}let temp_k_2: key = (if v_53 then 2-proj-3-tuple(v_52) else caught-fail) in
        {166}let ck_12: key = (if v_53 then 1-proj-3-tuple(v_52) else caught-fail) in
        {167}let ss_10: symmetricstate = (if v_46 then catch-fail((if v_49 then (if v_51 then (if v_53 then symmetricstatepack(cipherstatepack(temp_k_2,minnonce),ck_12,h_9) else fail-any) else fail-any) else fail-any)) else caught-fail) in
        {168}let v_54: bool = not-caught-fail(ss_10) in
        {169}let v_55: bitstring = (if v_54 then catch-fail(keypairunpack(s_1)) else caught-fail) in
        {170}let v_56: bool = (not-caught-fail(v_55) && success?(1-proj-2-tuple(v_55))) in
        {171}let my_private_key_3: key = (if v_56 then 2-proj-2-tuple(v_55) else caught-fail) in
        {172}let my_public_key_3: key = (if v_56 then 1-proj-2-tuple(v_55) else caught-fail) in
        {173}let input_key_material_3: key = (if v_54 then catch-fail((if v_56 then dhexp(my_private_key_3,rm_1) else fail-any)) else caught-fail) in
        {174}let v_57: bool = not-caught-fail(input_key_material_3) in
        {175}let v_58: bitstring = (if v_57 then catch-fail(symmetricstateunpack(ss_10)) else caught-fail) in
        {176}let v_59: bool = (not-caught-fail(v_58) && success?(1-proj-3-tuple(v_58))) in
        {177}let h_10: bitstring = (if v_59 then 3-proj-3-tuple(v_58) else caught-fail) in
        {178}let ck_13: key = (if v_59 then 2-proj-3-tuple(v_58) else caught-fail) in
        {179}let cs_10: cipherstate = (if v_59 then 1-proj-3-tuple(v_58) else caught-fail) in
        {182}let output3_3: key = (if v_59 then hmac_hash3(ck_13,input_key_material_3) else caught-fail) in
        {181}let output2_3: key = (if v_59 then hmac_hash2(ck_13,input_key_material_3) else caught-fail) in
        {180}let output1_3: key = (if v_59 then hmac_hash1(ck_13,input_key_material_3) else caught-fail) in
        {183}let v_60: bitstring = (if v_59 then catch-fail((output1_3,output2_3,output3_3)) else caught-fail) in
        {184}let v_61: bool = (not-caught-fail(v_60) && success?(1-proj-3-tuple(v_60))) in
        {185}let output_2: key = (if v_61 then 3-proj-3-tuple(v_60) else caught-fail) in
        {186}let temp_k_3: key = (if v_61 then 2-proj-3-tuple(v_60) else caught-fail) in
        {187}let ck_14: key = (if v_61 then 1-proj-3-tuple(v_60) else caught-fail) in
        {188}let ss_11: symmetricstate = (if v_54 then catch-fail((if v_57 then (if v_59 then (if v_61 then symmetricstatepack(cipherstatepack(temp_k_3,minnonce),ck_14,h_10) else fail-any) else fail-any) else fail-any)) else caught-fail) in
        {189}let v_62: bool = not-caught-fail(ss_11) in
        {190}let v_63: bitstring = (if v_62 then catch-fail(symmetricstateunpack(ss_11)) else caught-fail) in
        {191}let v_64: bool = (not-caught-fail(v_63) && success?(1-proj-3-tuple(v_63))) in
        {192}let h_11: bitstring = (if v_64 then 3-proj-3-tuple(v_63) else caught-fail) in
        {193}let ck_15: key = (if v_64 then 2-proj-3-tuple(v_63) else caught-fail) in
        {194}let cs_11: cipherstate = (if v_64 then 1-proj-3-tuple(v_63) else caught-fail) in
        {195}let v_65: bitstring = (if v_64 then catch-fail(cipherstateunpack(cs_11)) else caught-fail) in
        {196}let v_66: bool = (not-caught-fail(v_65) && success?(1-proj-2-tuple(v_65))) in
        {197}let n: nonce = (if v_66 then 2-proj-2-tuple(v_65) else caught-fail) in
        {198}let k_1: key = (if v_66 then 1-proj-2-tuple(v_65) else caught-fail) in
        {201}let v_67: bitstring = (if v_66 then catch-fail(cipherstateunpack(cs_11)) else caught-fail) in
        {202}let v_68: bool = (not-caught-fail(v_67) && success?(1-proj-2-tuple(v_67))) in
        {203}let o: nonce = (if v_68 then 2-proj-2-tuple(v_67) else caught-fail) in
        {204}let k_2: key = (if v_68 then 1-proj-2-tuple(v_67) else caught-fail) in
        {200}let n_1: nonce = (if v_66 then increment_nonce(n) else caught-fail) in
        {205}let csi: cipherstate = (if v_66 then catch-fail((if v_68 then cipherstatepack(k_2,n_1) else fail-any)) else caught-fail) in
        {206}let v_69: bool = not-caught-fail(csi) in
        {75}let payload: bitstring = msg_a(me,them,sid_1) in
        {199}let e_3: bitstring = (if v_66 then encrypt(k_1,n,h_11,payload) else caught-fail) in
        {207}let v_70: bitstring = (if v_64 then catch-fail((if v_66 then (if v_69 then (csi,e_3) else fail-any) else fail-any)) else caught-fail) in
        {208}let v_71: bool = (not-caught-fail(v_70) && success?(1-proj-2-tuple(v_70))) in
        {209}let ciphertext_1: bitstring = (if v_71 then 2-proj-2-tuple(v_70) else caught-fail) in
        {210}let csi_1: cipherstate = (if v_71 then 1-proj-2-tuple(v_70) else caught-fail) in
        {211}let ss_12: symmetricstate = (if v_71 then symmetricstatepack(csi_1,ck_15,h_11) else caught-fail) in
        {212}let v_72: bitstring = (if v_71 then catch-fail(symmetricstateunpack(ss_12)) else caught-fail) in
        {213}let v_73: bool = (not-caught-fail(v_72) && success?(1-proj-3-tuple(v_72))) in
        {214}let h_12: bitstring = (if v_73 then 3-proj-3-tuple(v_72) else caught-fail) in
        {215}let ck_16: key = (if v_73 then 2-proj-3-tuple(v_72) else caught-fail) in
        {216}let cs_12: cipherstate = (if v_73 then 1-proj-3-tuple(v_72) else caught-fail) in
        {217}let ssi: symmetricstate = (if v_71 then catch-fail((if v_73 then symmetricstatepack(cs_12,ck_16,hash(h_12,ciphertext_1)) else fail-any)) else caught-fail) in
        {218}let v_74: bool = not-caught-fail(ssi) in
        {219}let v_75: bitstring = (if v_62 then catch-fail((if v_64 then (if v_71 then (if v_74 then (ssi,ciphertext_1) else fail-any) else fail-any) else fail-any)) else caught-fail) in
        {220}let v_76: bool = (not-caught-fail(v_75) && success?(1-proj-2-tuple(v_75))) in
        {221}let ciphertext_2: bitstring = (if v_76 then 2-proj-2-tuple(v_75) else caught-fail) in
        {222}let ss_13: symmetricstate = (if v_76 then 1-proj-2-tuple(v_75) else caught-fail) in
        {225}let v_77: bitstring = (if v_76 then catch-fail(symmetricstateunpack(ss_13)) else caught-fail) in
        {226}let v_78: bool = (not-caught-fail(v_77) && success?(1-proj-3-tuple(v_77))) in
        {227}let h_13: bitstring = (if v_78 then 3-proj-3-tuple(v_77) else caught-fail) in
        {228}let ck_17: key = (if v_78 then 2-proj-3-tuple(v_77) else caught-fail) in
        {229}let cs_13: cipherstate = (if v_78 then 1-proj-3-tuple(v_77) else caught-fail) in
        {230}let input_key_material_4: key = (if v_78 then zero else caught-fail) in
        {233}let output3_4: key = (if v_78 then hmac_hash3(ck_17,input_key_material_4) else caught-fail) in
        {232}let output2_4: key = (if v_78 then hmac_hash2(ck_17,input_key_material_4) else caught-fail) in
        {231}let output1_4: key = (if v_78 then hmac_hash1(ck_17,input_key_material_4) else caught-fail) in
        {234}let v_79: bitstring = (if v_78 then catch-fail((output1_4,output2_4,output3_4)) else caught-fail) in
        {235}let v_80: bool = (not-caught-fail(v_79) && success?(1-proj-3-tuple(v_79))) in
        {236}let temp_k3: key = (if v_80 then 3-proj-3-tuple(v_79) else caught-fail) in
        {237}let temp_k2: key = (if v_80 then 2-proj-3-tuple(v_79) else caught-fail) in
        {238}let temp_k1: key = (if v_80 then 1-proj-3-tuple(v_79) else caught-fail) in
        {240}let cs2: cipherstate = (if v_80 then cipherstatepack(temp_k2,minnonce) else caught-fail) in
        {239}let cs1: cipherstate = (if v_80 then cipherstatepack(temp_k1,minnonce) else caught-fail) in
        {241}let v_81: bitstring = (if v_76 then catch-fail((if v_78 then (if v_80 then (ss_13,cs1,cs2) else fail-any) else fail-any)) else caught-fail) in
        {242}let v_82: bool = (not-caught-fail(v_81) && success?(1-proj-3-tuple(v_81))) in
        {243}let cs2_1: cipherstate = (if v_82 then 3-proj-3-tuple(v_81) else caught-fail) in
        {244}let cs1_1: cipherstate = (if v_82 then 2-proj-3-tuple(v_81) else caught-fail) in
        {245}let ssi_1: symmetricstate = (if v_82 then 1-proj-3-tuple(v_81) else caught-fail) in
        {224}let message_buffer: bitstring = (if v_76 then concat3(ne_1,ns,ciphertext_2) else caught-fail) in
        {223}let hs_2: handshakestate = (if v_76 then handshakestatepack(ss_13,s_1,m_1,e_2,rs_1,rm_1,re_1,psk_1,initiator_1) else caught-fail) in
        {246}let (hs_3: handshakestate,message_a: bitstring,cs1_2: cipherstate,cs2_2: cipherstate) = (if v_22 then (if v_24 then (if v_26 then (if v_27 then (if v_30 then (if v_38 then (if v_46 then (if v_54 then (if v_62 then (if v_76 then (if v_82 then (hs_2,message_buffer,cs1_1,cs2_1) else fail-any) else fail-any) else fail-any) else fail-any) else fail-any) else fail-any) else fail-any) else fail-any) else fail-any) else fail-any) else fail-any) in
        {247}event SendMsg(me,them,stagepack_a(sid_1),msg_a(me,them,sid_1));
        {248}out(pub, message_a)
    ) | (
        {250}event LeakS(phase0,me);
        {251}event LeakM(phase0,me);
        {252}out(pub, (key_s(me),key_m(me)))
    ) | (
        {253}phase 1;
        {254}event LeakS(phase1,me);
        {255}event LeakM(phase1,me);
        {256}out(pub, (key_s(me),key_m(me)))
    )
) | (
    {257}let me_1: principal = alice in
    {260}let basis_5: key = key_s(me_1) in
    {261}let public_key_5: key = catch-fail(dhexp(basis_5,validkey(g))) in
    {262}let v_83: bool = not-caught-fail(public_key_5) in
    {263}let s_2: keypair = (if v_83 then keypairpack(validkey(public_key_5),basis_5) else fail-any) in
    {264}let basis_6: key = key_m(me_1) in
    {265}let public_key_6: key = catch-fail(dhexp(basis_6,validkey(g))) in
    {266}let v_84: bool = not-caught-fail(public_key_6) in
    {267}let m_2: keypair = (if v_84 then keypairpack(validkey(public_key_6),basis_6) else fail-any) in
    {268}out(pub, (getpublickey(s_2),getpublickey(m_2)));
    {259}let sid_2: sessionid = sid in
    {258}let them_1: principal = charlie in
    (
        {270}let basis_7: key = key_s(them_1) in
        {271}let public_key_7: key = catch-fail(dhexp(basis_7,validkey(g))) in
        {272}let v_85: bool = not-caught-fail(public_key_7) in
        {273}let rs_2: key = getpublickey((if v_85 then keypairpack(validkey(public_key_7),basis_7) else fail-any)) in
        {274}let basis_8: key = key_s(them_1) in
        {275}let public_key_8: key = catch-fail(dhexp(basis_8,validkey(g))) in
        {276}let v_86: bool = not-caught-fail(public_key_8) in
        {277}let rm_2: key = getpublickey((if v_86 then keypairpack(validkey(public_key_8),basis_8) else fail-any)) in
        {284}let k_3: key = empty in
        {285}let cs_14: cipherstate = cipherstatepack(k_3,minnonce) in
        {281}let protocol_name_1: bitstring = somename in
        {282}let h_14: bitstring = hash(protocol_name_1,empty) in
        {283}let ck_18: key = h_14 in
        {286}let ss_14: symmetricstate = symmetricstatepack(cs_14,ck_18,h_14) in
        {287}let v_87: bitstring = catch-fail(symmetricstateunpack(ss_14)) in
        {288}let v_88: bool = (not-caught-fail(v_87) && success?(1-proj-3-tuple(v_87))) in
        {289}let h_15: bitstring = (if v_88 then 3-proj-3-tuple(v_87) else caught-fail) in
        {290}let ck_19: key = (if v_88 then 2-proj-3-tuple(v_87) else caught-fail) in
        {291}let cs_15: cipherstate = (if v_88 then 1-proj-3-tuple(v_87) else caught-fail) in
        {279}let prologue_1: bitstring = empty in
        {292}let ss_15: symmetricstate = catch-fail((if v_88 then symmetricstatepack(cs_15,ck_19,hash(h_15,prologue_1)) else fail-any)) in
        {293}let v_89: bool = not-caught-fail(ss_15) in
        {294}let data_2: bitstring = (if v_89 then catch-fail(getpublickey(s_2)) else caught-fail) in
        {295}let v_90: bool = not-caught-fail(data_2) in
        {296}let v_91: bitstring = (if v_90 then catch-fail(symmetricstateunpack(ss_15)) else caught-fail) in
        {297}let v_92: bool = (not-caught-fail(v_91) && success?(1-proj-3-tuple(v_91))) in
        {298}let h_16: bitstring = (if v_92 then 3-proj-3-tuple(v_91) else caught-fail) in
        {299}let ck_20: key = (if v_92 then 2-proj-3-tuple(v_91) else caught-fail) in
        {300}let cs_16: cipherstate = (if v_92 then 1-proj-3-tuple(v_91) else caught-fail) in
        {301}let ss_16: symmetricstate = (if v_89 then catch-fail((if v_90 then (if v_92 then symmetricstatepack(cs_16,ck_20,hash(h_16,data_2)) else fail-any) else fail-any)) else caught-fail) in
        {302}let v_93: bool = not-caught-fail(ss_16) in
        {303}let data_3: bitstring = (if v_93 then catch-fail(getpublickey(m_2)) else caught-fail) in
        {304}let v_94: bool = not-caught-fail(data_3) in
        {305}let v_95: bitstring = (if v_94 then catch-fail(symmetricstateunpack(ss_16)) else caught-fail) in
        {306}let v_96: bool = (not-caught-fail(v_95) && success?(1-proj-3-tuple(v_95))) in
        {307}let h_17: bitstring = (if v_96 then 3-proj-3-tuple(v_95) else caught-fail) in
        {308}let ck_21: key = (if v_96 then 2-proj-3-tuple(v_95) else caught-fail) in
        {309}let cs_17: cipherstate = (if v_96 then 1-proj-3-tuple(v_95) else caught-fail) in
        {310}let ss_17: symmetricstate = (if v_93 then catch-fail((if v_94 then (if v_96 then symmetricstatepack(cs_17,ck_21,hash(h_17,data_3)) else fail-any) else fail-any)) else caught-fail) in
        {311}let v_97: bool = not-caught-fail(ss_17) in
        {312}let v_98: bitstring = (if v_97 then catch-fail(symmetricstateunpack(ss_17)) else caught-fail) in
        {313}let v_99: bool = (not-caught-fail(v_98) && success?(1-proj-3-tuple(v_98))) in
        {314}let h_18: bitstring = (if v_99 then 3-proj-3-tuple(v_98) else caught-fail) in
        {315}let ck_22: key = (if v_99 then 2-proj-3-tuple(v_98) else caught-fail) in
        {316}let cs_18: cipherstate = (if v_99 then 1-proj-3-tuple(v_98) else caught-fail) in
        {317}let ss_18: symmetricstate = (if v_97 then catch-fail((if v_99 then symmetricstatepack(cs_18,ck_22,hash(h_18,rs_2)) else fail-any)) else caught-fail) in
        {318}let v_100: bool = not-caught-fail(ss_18) in
        {319}let v_101: bitstring = (if v_100 then catch-fail(symmetricstateunpack(ss_18)) else caught-fail) in
        {320}let v_102: bool = (not-caught-fail(v_101) && success?(1-proj-3-tuple(v_101))) in
        {321}let h_19: bitstring = (if v_102 then 3-proj-3-tuple(v_101) else caught-fail) in
        {322}let ck_23: key = (if v_102 then 2-proj-3-tuple(v_101) else caught-fail) in
        {323}let cs_19: cipherstate = (if v_102 then 1-proj-3-tuple(v_101) else caught-fail) in
        {324}let ss_19: symmetricstate = (if v_100 then catch-fail((if v_102 then symmetricstatepack(cs_19,ck_23,hash(h_19,rm_2)) else fail-any)) else caught-fail) in
        {325}let v_103: bool = not-caught-fail(ss_19) in
        {280}let psk_2: key = empty in
        {278}let re_2: key = empty in
        {269}let e_4: keypair = keypairpack(empty,empty) in
        {326}let hs_4: handshakestate = (if v_89 then (if v_93 then (if v_97 then (if v_100 then (if v_103 then handshakestatepack(ss_19,s_2,m_2,e_4,rs_2,rm_2,re_2,psk_2,true) else fail-any) else fail-any) else fail-any) else fail-any) else fail-any) in
        {327}insert statestore(me_1,them_1,sid_2,statepack_a(hs_4))
    ) | (
        {502}get statestore(=me_1,=them_1,=sid_2,statepack_a(hs_5: handshakestate)) in
        {329}let v_104: bitstring = catch-fail(handshakestateunpack(hs_5)) in
        {330}let v_105: bool = (not-caught-fail(v_104) && success?(1-proj-9-tuple(v_104))) in
        {331}let initiator_2: bool = (if v_105 then 9-proj-9-tuple(v_104) else caught-fail) in
        {332}let psk_3: key = (if v_105 then 8-proj-9-tuple(v_104) else caught-fail) in
        {333}let re_3: key = (if v_105 then 7-proj-9-tuple(v_104) else caught-fail) in
        {334}let rm_3: key = (if v_105 then 6-proj-9-tuple(v_104) else caught-fail) in
        {335}let rs_3: key = (if v_105 then 5-proj-9-tuple(v_104) else caught-fail) in
        {336}let e_5: keypair = (if v_105 then 4-proj-9-tuple(v_104) else caught-fail) in
        {337}let m_3: keypair = (if v_105 then 3-proj-9-tuple(v_104) else caught-fail) in
        {338}let s_3: keypair = (if v_105 then 2-proj-9-tuple(v_104) else caught-fail) in
        {339}let ss_20: symmetricstate = (if v_105 then 1-proj-9-tuple(v_104) else caught-fail) in
        {340}let v_106: bitstring = (if v_105 then catch-fail((empty,empty,empty)) else caught-fail) in
        {341}let v_107: bool = (not-caught-fail(v_106) && success?(1-proj-3-tuple(v_106))) in
        {342}let ciphertext_3: bitstring = (if v_107 then 3-proj-3-tuple(v_106) else caught-fail) in
        {343}let ns_1: bitstring = (if v_107 then 2-proj-3-tuple(v_106) else caught-fail) in
        {344}let ne_2: bitstring = (if v_107 then 1-proj-3-tuple(v_106) else caught-fail) in
        {345}let basis_9: key = (if v_107 then key_e(me_1,them_1,sid_2) else caught-fail) in
        {346}let public_key_9: key = (if v_107 then catch-fail(dhexp(basis_9,validkey(g))) else caught-fail) in
        {347}let v_108: bool = not-caught-fail(public_key_9) in
        {348}let e_6: keypair = (if v_107 then catch-fail((if v_108 then keypairpack(validkey(public_key_9),basis_9) else fail-any)) else caught-fail) in
        {349}let v_109: bool = not-caught-fail(e_6) in
        {350}let ne_3: bitstring = (if v_109 then catch-fail(getpublickey(e_6)) else caught-fail) in
        {351}let v_110: bool = not-caught-fail(ne_3) in
        {352}let v_111: bitstring = (if v_110 then catch-fail(symmetricstateunpack(ss_20)) else caught-fail) in
        {353}let v_112: bool = (not-caught-fail(v_111) && success?(1-proj-3-tuple(v_111))) in
        {354}let h_20: bitstring = (if v_112 then 3-proj-3-tuple(v_111) else caught-fail) in
        {355}let ck_24: key = (if v_112 then 2-proj-3-tuple(v_111) else caught-fail) in
        {356}let cs_20: cipherstate = (if v_112 then 1-proj-3-tuple(v_111) else caught-fail) in
        {357}let ss_21: symmetricstate = (if v_110 then catch-fail((if v_112 then symmetricstatepack(cs_20,ck_24,hash(h_20,ne_3)) else fail-any)) else caught-fail) in
        {358}let v_113: bool = not-caught-fail(ss_21) in
        {359}let v_114: bitstring = (if v_113 then catch-fail(keypairunpack(e_6)) else caught-fail) in
        {360}let v_115: bool = (not-caught-fail(v_114) && success?(1-proj-2-tuple(v_114))) in
        {361}let my_private_key_4: key = (if v_115 then 2-proj-2-tuple(v_114) else caught-fail) in
        {362}let my_public_key_4: key = (if v_115 then 1-proj-2-tuple(v_114) else caught-fail) in
        {363}let input_key_material_5: key = (if v_113 then catch-fail((if v_115 then dhexp(my_private_key_4,rs_3) else fail-any)) else caught-fail) in
        {364}let v_116: bool = not-caught-fail(input_key_material_5) in
        {365}let v_117: bitstring = (if v_116 then catch-fail(symmetricstateunpack(ss_21)) else caught-fail) in
        {366}let v_118: bool = (not-caught-fail(v_117) && success?(1-proj-3-tuple(v_117))) in
        {367}let h_21: bitstring = (if v_118 then 3-proj-3-tuple(v_117) else caught-fail) in
        {368}let ck_25: key = (if v_118 then 2-proj-3-tuple(v_117) else caught-fail) in
        {369}let cs_21: cipherstate = (if v_118 then 1-proj-3-tuple(v_117) else caught-fail) in
        {372}let output3_5: key = (if v_118 then hmac_hash3(ck_25,input_key_material_5) else caught-fail) in
        {371}let output2_5: key = (if v_118 then hmac_hash2(ck_25,input_key_material_5) else caught-fail) in
        {370}let output1_5: key = (if v_118 then hmac_hash1(ck_25,input_key_material_5) else caught-fail) in
        {373}let v_119: bitstring = (if v_118 then catch-fail((output1_5,output2_5,output3_5)) else caught-fail) in
        {374}let v_120: bool = (not-caught-fail(v_119) && success?(1-proj-3-tuple(v_119))) in
        {375}let output_4: key = (if v_120 then 3-proj-3-tuple(v_119) else caught-fail) in
        {376}let temp_k_4: key = (if v_120 then 2-proj-3-tuple(v_119) else caught-fail) in
        {377}let ck_26: key = (if v_120 then 1-proj-3-tuple(v_119) else caught-fail) in
        {378}let ss_22: symmetricstate = (if v_113 then catch-fail((if v_116 then (if v_118 then (if v_120 then symmetricstatepack(cipherstatepack(temp_k_4,minnonce),ck_26,h_21) else fail-any) else fail-any) else fail-any)) else caught-fail) in
        {379}let v_121: bool = not-caught-fail(ss_22) in
        {380}let v_122: bitstring = (if v_121 then catch-fail(keypairunpack(e_6)) else caught-fail) in
        {381}let v_123: bool = (not-caught-fail(v_122) && success?(1-proj-2-tuple(v_122))) in
        {382}let my_private_key_5: key = (if v_123 then 2-proj-2-tuple(v_122) else caught-fail) in
        {383}let my_public_key_5: key = (if v_123 then 1-proj-2-tuple(v_122) else caught-fail) in
        {384}let input_key_material_6: key = (if v_121 then catch-fail((if v_123 then dhexp(my_private_key_5,rm_3) else fail-any)) else caught-fail) in
        {385}let v_124: bool = not-caught-fail(input_key_material_6) in
        {386}let v_125: bitstring = (if v_124 then catch-fail(symmetricstateunpack(ss_22)) else caught-fail) in
        {387}let v_126: bool = (not-caught-fail(v_125) && success?(1-proj-3-tuple(v_125))) in
        {388}let h_22: bitstring = (if v_126 then 3-proj-3-tuple(v_125) else caught-fail) in
        {389}let ck_27: key = (if v_126 then 2-proj-3-tuple(v_125) else caught-fail) in
        {390}let cs_22: cipherstate = (if v_126 then 1-proj-3-tuple(v_125) else caught-fail) in
        {393}let output3_6: key = (if v_126 then hmac_hash3(ck_27,input_key_material_6) else caught-fail) in
        {392}let output2_6: key = (if v_126 then hmac_hash2(ck_27,input_key_material_6) else caught-fail) in
        {391}let output1_6: key = (if v_126 then hmac_hash1(ck_27,input_key_material_6) else caught-fail) in
        {394}let v_127: bitstring = (if v_126 then catch-fail((output1_6,output2_6,output3_6)) else caught-fail) in
        {395}let v_128: bool = (not-caught-fail(v_127) && success?(1-proj-3-tuple(v_127))) in
        {396}let output_5: key = (if v_128 then 3-proj-3-tuple(v_127) else caught-fail) in
        {397}let temp_k_5: key = (if v_128 then 2-proj-3-tuple(v_127) else caught-fail) in
        {398}let ck_28: key = (if v_128 then 1-proj-3-tuple(v_127) else caught-fail) in
        {399}let ss_23: symmetricstate = (if v_121 then catch-fail((if v_124 then (if v_126 then (if v_128 then symmetricstatepack(cipherstatepack(temp_k_5,minnonce),ck_28,h_22) else fail-any) else fail-any) else fail-any)) else caught-fail) in
        {400}let v_129: bool = not-caught-fail(ss_23) in
        {401}let v_130: bitstring = (if v_129 then catch-fail(keypairunpack(m_3)) else caught-fail) in
        {402}let v_131: bool = (not-caught-fail(v_130) && success?(1-proj-2-tuple(v_130))) in
        {403}let my_private_key_6: key = (if v_131 then 2-proj-2-tuple(v_130) else caught-fail) in
        {404}let my_public_key_6: key = (if v_131 then 1-proj-2-tuple(v_130) else caught-fail) in
        {405}let input_key_material_7: key = (if v_129 then catch-fail((if v_131 then dhexp(my_private_key_6,rs_3) else fail-any)) else caught-fail) in
        {406}let v_132: bool = not-caught-fail(input_key_material_7) in
        {407}let v_133: bitstring = (if v_132 then catch-fail(symmetricstateunpack(ss_23)) else caught-fail) in
        {408}let v_134: bool = (not-caught-fail(v_133) && success?(1-proj-3-tuple(v_133))) in
        {409}let h_23: bitstring = (if v_134 then 3-proj-3-tuple(v_133) else caught-fail) in
        {410}let ck_29: key = (if v_134 then 2-proj-3-tuple(v_133) else caught-fail) in
        {411}let cs_23: cipherstate = (if v_134 then 1-proj-3-tuple(v_133) else caught-fail) in
        {414}let output3_7: key = (if v_134 then hmac_hash3(ck_29,input_key_material_7) else caught-fail) in
        {413}let output2_7: key = (if v_134 then hmac_hash2(ck_29,input_key_material_7) else caught-fail) in
        {412}let output1_7: key = (if v_134 then hmac_hash1(ck_29,input_key_material_7) else caught-fail) in
        {415}let v_135: bitstring = (if v_134 then catch-fail((output1_7,output2_7,output3_7)) else caught-fail) in
        {416}let v_136: bool = (not-caught-fail(v_135) && success?(1-proj-3-tuple(v_135))) in
        {417}let output_6: key = (if v_136 then 3-proj-3-tuple(v_135) else caught-fail) in
        {418}let temp_k_6: key = (if v_136 then 2-proj-3-tuple(v_135) else caught-fail) in
        {419}let ck_30: key = (if v_136 then 1-proj-3-tuple(v_135) else caught-fail) in
        {420}let ss_24: symmetricstate = (if v_129 then catch-fail((if v_132 then (if v_134 then (if v_136 then symmetricstatepack(cipherstatepack(temp_k_6,minnonce),ck_30,h_23) else fail-any) else fail-any) else fail-any)) else caught-fail) in
        {421}let v_137: bool = not-caught-fail(ss_24) in
        {422}let v_138: bitstring = (if v_137 then catch-fail(keypairunpack(s_3)) else caught-fail) in
        {423}let v_139: bool = (not-caught-fail(v_138) && success?(1-proj-2-tuple(v_138))) in
        {424}let my_private_key_7: key = (if v_139 then 2-proj-2-tuple(v_138) else caught-fail) in
        {425}let my_public_key_7: key = (if v_139 then 1-proj-2-tuple(v_138) else caught-fail) in
        {426}let input_key_material_8: key = (if v_137 then catch-fail((if v_139 then dhexp(my_private_key_7,rm_3) else fail-any)) else caught-fail) in
        {427}let v_140: bool = not-caught-fail(input_key_material_8) in
        {428}let v_141: bitstring = (if v_140 then catch-fail(symmetricstateunpack(ss_24)) else caught-fail) in
        {429}let v_142: bool = (not-caught-fail(v_141) && success?(1-proj-3-tuple(v_141))) in
        {430}let h_24: bitstring = (if v_142 then 3-proj-3-tuple(v_141) else caught-fail) in
        {431}let ck_31: key = (if v_142 then 2-proj-3-tuple(v_141) else caught-fail) in
        {432}let cs_24: cipherstate = (if v_142 then 1-proj-3-tuple(v_141) else caught-fail) in
        {435}let output3_8: key = (if v_142 then hmac_hash3(ck_31,input_key_material_8) else caught-fail) in
        {434}let output2_8: key = (if v_142 then hmac_hash2(ck_31,input_key_material_8) else caught-fail) in
        {433}let output1_8: key = (if v_142 then hmac_hash1(ck_31,input_key_material_8) else caught-fail) in
        {436}let v_143: bitstring = (if v_142 then catch-fail((output1_8,output2_8,output3_8)) else caught-fail) in
        {437}let v_144: bool = (not-caught-fail(v_143) && success?(1-proj-3-tuple(v_143))) in
        {438}let output_7: key = (if v_144 then 3-proj-3-tuple(v_143) else caught-fail) in
        {439}let temp_k_7: key = (if v_144 then 2-proj-3-tuple(v_143) else caught-fail) in
        {440}let ck_32: key = (if v_144 then 1-proj-3-tuple(v_143) else caught-fail) in
        {441}let ss_25: symmetricstate = (if v_137 then catch-fail((if v_140 then (if v_142 then (if v_144 then symmetricstatepack(cipherstatepack(temp_k_7,minnonce),ck_32,h_24) else fail-any) else fail-any) else fail-any)) else caught-fail) in
        {442}let v_145: bool = not-caught-fail(ss_25) in
        {443}let v_146: bitstring = (if v_145 then catch-fail(symmetricstateunpack(ss_25)) else caught-fail) in
        {444}let v_147: bool = (not-caught-fail(v_146) && success?(1-proj-3-tuple(v_146))) in
        {445}let h_25: bitstring = (if v_147 then 3-proj-3-tuple(v_146) else caught-fail) in
        {446}let ck_33: key = (if v_147 then 2-proj-3-tuple(v_146) else caught-fail) in
        {447}let cs_25: cipherstate = (if v_147 then 1-proj-3-tuple(v_146) else caught-fail) in
        {448}let v_148: bitstring = (if v_147 then catch-fail(cipherstateunpack(cs_25)) else caught-fail) in
        {449}let v_149: bool = (not-caught-fail(v_148) && success?(1-proj-2-tuple(v_148))) in
        {450}let n_2: nonce = (if v_149 then 2-proj-2-tuple(v_148) else caught-fail) in
        {451}let k_4: key = (if v_149 then 1-proj-2-tuple(v_148) else caught-fail) in
        {454}let v_150: bitstring = (if v_149 then catch-fail(cipherstateunpack(cs_25)) else caught-fail) in
        {455}let v_151: bool = (not-caught-fail(v_150) && success?(1-proj-2-tuple(v_150))) in
        {456}let o_1: nonce = (if v_151 then 2-proj-2-tuple(v_150) else caught-fail) in
        {457}let k_5: key = (if v_151 then 1-proj-2-tuple(v_150) else caught-fail) in
        {453}let n_3: nonce = (if v_149 then increment_nonce(n_2) else caught-fail) in
        {458}let csi_2: cipherstate = (if v_149 then catch-fail((if v_151 then cipherstatepack(k_5,n_3) else fail-any)) else caught-fail) in
        {459}let v_152: bool = not-caught-fail(csi_2) in
        {328}let payload_1: bitstring = msg_a(me_1,them_1,sid_2) in
        {452}let e_7: bitstring = (if v_149 then encrypt(k_4,n_2,h_25,payload_1) else caught-fail) in
        {460}let v_153: bitstring = (if v_147 then catch-fail((if v_149 then (if v_152 then (csi_2,e_7) else fail-any) else fail-any)) else caught-fail) in
        {461}let v_154: bool = (not-caught-fail(v_153) && success?(1-proj-2-tuple(v_153))) in
        {462}let ciphertext_4: bitstring = (if v_154 then 2-proj-2-tuple(v_153) else caught-fail) in
        {463}let csi_3: cipherstate = (if v_154 then 1-proj-2-tuple(v_153) else caught-fail) in
        {464}let ss_26: symmetricstate = (if v_154 then symmetricstatepack(csi_3,ck_33,h_25) else caught-fail) in
        {465}let v_155: bitstring = (if v_154 then catch-fail(symmetricstateunpack(ss_26)) else caught-fail) in
        {466}let v_156: bool = (not-caught-fail(v_155) && success?(1-proj-3-tuple(v_155))) in
        {467}let h_26: bitstring = (if v_156 then 3-proj-3-tuple(v_155) else caught-fail) in
        {468}let ck_34: key = (if v_156 then 2-proj-3-tuple(v_155) else caught-fail) in
        {469}let cs_26: cipherstate = (if v_156 then 1-proj-3-tuple(v_155) else caught-fail) in
        {470}let ssi_2: symmetricstate = (if v_154 then catch-fail((if v_156 then symmetricstatepack(cs_26,ck_34,hash(h_26,ciphertext_4)) else fail-any)) else caught-fail) in
        {471}let v_157: bool = not-caught-fail(ssi_2) in
        {472}let v_158: bitstring = (if v_145 then catch-fail((if v_147 then (if v_154 then (if v_157 then (ssi_2,ciphertext_4) else fail-any) else fail-any) else fail-any)) else caught-fail) in
        {473}let v_159: bool = (not-caught-fail(v_158) && success?(1-proj-2-tuple(v_158))) in
        {474}let ciphertext_5: bitstring = (if v_159 then 2-proj-2-tuple(v_158) else caught-fail) in
        {475}let ss_27: symmetricstate = (if v_159 then 1-proj-2-tuple(v_158) else caught-fail) in
        {478}let v_160: bitstring = (if v_159 then catch-fail(symmetricstateunpack(ss_27)) else caught-fail) in
        {479}let v_161: bool = (not-caught-fail(v_160) && success?(1-proj-3-tuple(v_160))) in
        {480}let h_27: bitstring = (if v_161 then 3-proj-3-tuple(v_160) else caught-fail) in
        {481}let ck_35: key = (if v_161 then 2-proj-3-tuple(v_160) else caught-fail) in
        {482}let cs_27: cipherstate = (if v_161 then 1-proj-3-tuple(v_160) else caught-fail) in
        {483}let input_key_material_9: key = (if v_161 then zero else caught-fail) in
        {486}let output3_9: key = (if v_161 then hmac_hash3(ck_35,input_key_material_9) else caught-fail) in
        {485}let output2_9: key = (if v_161 then hmac_hash2(ck_35,input_key_material_9) else caught-fail) in
        {484}let output1_9: key = (if v_161 then hmac_hash1(ck_35,input_key_material_9) else caught-fail) in
        {487}let v_162: bitstring = (if v_161 then catch-fail((output1_9,output2_9,output3_9)) else caught-fail) in
        {488}let v_163: bool = (not-caught-fail(v_162) && success?(1-proj-3-tuple(v_162))) in
        {489}let temp_k3_1: key = (if v_163 then 3-proj-3-tuple(v_162) else caught-fail) in
        {490}let temp_k2_1: key = (if v_163 then 2-proj-3-tuple(v_162) else caught-fail) in
        {491}let temp_k1_1: key = (if v_163 then 1-proj-3-tuple(v_162) else caught-fail) in
        {493}let cs2_3: cipherstate = (if v_163 then cipherstatepack(temp_k2_1,minnonce) else caught-fail) in
        {492}let cs1_3: cipherstate = (if v_163 then cipherstatepack(temp_k1_1,minnonce) else caught-fail) in
        {494}let v_164: bitstring = (if v_159 then catch-fail((if v_161 then (if v_163 then (ss_27,cs1_3,cs2_3) else fail-any) else fail-any)) else caught-fail) in
        {495}let v_165: bool = (not-caught-fail(v_164) && success?(1-proj-3-tuple(v_164))) in
        {496}let cs2_4: cipherstate = (if v_165 then 3-proj-3-tuple(v_164) else caught-fail) in
        {497}let cs1_4: cipherstate = (if v_165 then 2-proj-3-tuple(v_164) else caught-fail) in
        {498}let ssi_3: symmetricstate = (if v_165 then 1-proj-3-tuple(v_164) else caught-fail) in
        {477}let message_buffer_1: bitstring = (if v_159 then concat3(ne_3,ns_1,ciphertext_5) else caught-fail) in
        {476}let hs_6: handshakestate = (if v_159 then handshakestatepack(ss_27,s_3,m_3,e_6,rs_3,rm_3,re_3,psk_3,initiator_2) else caught-fail) in
        {499}let (hs_7: handshakestate,message_a_1: bitstring,cs1_5: cipherstate,cs2_5: cipherstate) = (if v_105 then (if v_107 then (if v_109 then (if v_110 then (if v_113 then (if v_121 then (if v_129 then (if v_137 then (if v_145 then (if v_159 then (if v_165 then (hs_6,message_buffer_1,cs1_4,cs2_4) else fail-any) else fail-any) else fail-any) else fail-any) else fail-any) else fail-any) else fail-any) else fail-any) else fail-any) else fail-any) else fail-any) in
        {500}event SendMsg(me_1,them_1,stagepack_a(sid_2),msg_a(me_1,them_1,sid_2));
        {501}out(pub, message_a_1)
    ) | (
        {503}event LeakS(phase0,me_1);
        {504}event LeakM(phase0,me_1);
        {505}out(pub, (key_s(me_1),key_m(me_1)))
    ) | (
        {506}phase 1;
        {507}event LeakS(phase1,me_1);
        {508}event LeakM(phase1,me_1);
        {509}out(pub, (key_s(me_1),key_m(me_1)))
    )
) | (
    {510}let me_2: principal = bob in
    {513}let basis_10: key = key_s(me_2) in
    {514}let public_key_10: key = catch-fail(dhexp(basis_10,validkey(g))) in
    {515}let v_166: bool = not-caught-fail(public_key_10) in
    {516}let s_4: keypair = (if v_166 then keypairpack(validkey(public_key_10),basis_10) else fail-any) in
    {517}let basis_11: key = key_m(me_2) in
    {518}let public_key_11: key = catch-fail(dhexp(basis_11,validkey(g))) in
    {519}let v_167: bool = not-caught-fail(public_key_11) in
    {520}let m_4: keypair = (if v_167 then keypairpack(validkey(public_key_11),basis_11) else fail-any) in
    {521}out(pub, (getpublickey(s_4),getpublickey(m_4)));
    {512}let sid_3: sessionid = sid in
    {511}let them_2: principal = alice in
    (
        {523}let basis_12: key = key_s(them_2) in
        {524}let public_key_12: key = catch-fail(dhexp(basis_12,validkey(g))) in
        {525}let v_168: bool = not-caught-fail(public_key_12) in
        {526}let rs_4: key = getpublickey((if v_168 then keypairpack(validkey(public_key_12),basis_12) else fail-any)) in
        {527}let basis_13: key = key_m(them_2) in
        {528}let public_key_13: key = catch-fail(dhexp(basis_13,validkey(g))) in
        {529}let v_169: bool = not-caught-fail(public_key_13) in
        {530}let rm_4: key = getpublickey((if v_169 then keypairpack(validkey(public_key_13),basis_13) else fail-any)) in
        {537}let k_6: key = empty in
        {538}let cs_28: cipherstate = cipherstatepack(k_6,minnonce) in
        {534}let protocol_name_2: bitstring = somename in
        {535}let h_28: bitstring = hash(protocol_name_2,empty) in
        {536}let ck_36: key = h_28 in
        {539}let ss_28: symmetricstate = symmetricstatepack(cs_28,ck_36,h_28) in
        {540}let v_170: bitstring = catch-fail(symmetricstateunpack(ss_28)) in
        {541}let v_171: bool = (not-caught-fail(v_170) && success?(1-proj-3-tuple(v_170))) in
        {542}let h_29: bitstring = (if v_171 then 3-proj-3-tuple(v_170) else caught-fail) in
        {543}let ck_37: key = (if v_171 then 2-proj-3-tuple(v_170) else caught-fail) in
        {544}let cs_29: cipherstate = (if v_171 then 1-proj-3-tuple(v_170) else caught-fail) in
        {532}let prologue_2: bitstring = empty in
        {545}let ss_29: symmetricstate = catch-fail((if v_171 then symmetricstatepack(cs_29,ck_37,hash(h_29,prologue_2)) else fail-any)) in
        {546}let v_172: bool = not-caught-fail(ss_29) in
        {547}let v_173: bitstring = (if v_172 then catch-fail(symmetricstateunpack(ss_29)) else caught-fail) in
        {548}let v_174: bool = (not-caught-fail(v_173) && success?(1-proj-3-tuple(v_173))) in
        {549}let h_30: bitstring = (if v_174 then 3-proj-3-tuple(v_173) else caught-fail) in
        {550}let ck_38: key = (if v_174 then 2-proj-3-tuple(v_173) else caught-fail) in
        {551}let cs_30: cipherstate = (if v_174 then 1-proj-3-tuple(v_173) else caught-fail) in
        {552}let ss_30: symmetricstate = (if v_172 then catch-fail((if v_174 then symmetricstatepack(cs_30,ck_38,hash(h_30,rs_4)) else fail-any)) else caught-fail) in
        {553}let v_175: bool = not-caught-fail(ss_30) in
        {554}let v_176: bitstring = (if v_175 then catch-fail(symmetricstateunpack(ss_30)) else caught-fail) in
        {555}let v_177: bool = (not-caught-fail(v_176) && success?(1-proj-3-tuple(v_176))) in
        {556}let h_31: bitstring = (if v_177 then 3-proj-3-tuple(v_176) else caught-fail) in
        {557}let ck_39: key = (if v_177 then 2-proj-3-tuple(v_176) else caught-fail) in
        {558}let cs_31: cipherstate = (if v_177 then 1-proj-3-tuple(v_176) else caught-fail) in
        {559}let ss_31: symmetricstate = (if v_175 then catch-fail((if v_177 then symmetricstatepack(cs_31,ck_39,hash(h_31,rm_4)) else fail-any)) else caught-fail) in
        {560}let v_178: bool = not-caught-fail(ss_31) in
        {561}let data_4: bitstring = (if v_178 then catch-fail(getpublickey(s_4)) else caught-fail) in
        {562}let v_179: bool = not-caught-fail(data_4) in
        {563}let v_180: bitstring = (if v_179 then catch-fail(symmetricstateunpack(ss_31)) else caught-fail) in
        {564}let v_181: bool = (not-caught-fail(v_180) && success?(1-proj-3-tuple(v_180))) in
        {565}let h_32: bitstring = (if v_181 then 3-proj-3-tuple(v_180) else caught-fail) in
        {566}let ck_40: key = (if v_181 then 2-proj-3-tuple(v_180) else caught-fail) in
        {567}let cs_32: cipherstate = (if v_181 then 1-proj-3-tuple(v_180) else caught-fail) in
        {568}let ss_32: symmetricstate = (if v_178 then catch-fail((if v_179 then (if v_181 then symmetricstatepack(cs_32,ck_40,hash(h_32,data_4)) else fail-any) else fail-any)) else caught-fail) in
        {569}let v_182: bool = not-caught-fail(ss_32) in
        {570}let data_5: bitstring = (if v_182 then catch-fail(getpublickey(m_4)) else caught-fail) in
        {571}let v_183: bool = not-caught-fail(data_5) in
        {572}let v_184: bitstring = (if v_183 then catch-fail(symmetricstateunpack(ss_32)) else caught-fail) in
        {573}let v_185: bool = (not-caught-fail(v_184) && success?(1-proj-3-tuple(v_184))) in
        {574}let h_33: bitstring = (if v_185 then 3-proj-3-tuple(v_184) else caught-fail) in
        {575}let ck_41: key = (if v_185 then 2-proj-3-tuple(v_184) else caught-fail) in
        {576}let cs_33: cipherstate = (if v_185 then 1-proj-3-tuple(v_184) else caught-fail) in
        {577}let ss_33: symmetricstate = (if v_182 then catch-fail((if v_183 then (if v_185 then symmetricstatepack(cs_33,ck_41,hash(h_33,data_5)) else fail-any) else fail-any)) else caught-fail) in
        {578}let v_186: bool = not-caught-fail(ss_33) in
        {533}let psk_4: key = empty in
        {531}let re_4: key = empty in
        {522}let e_8: keypair = keypairpack(empty,empty) in
        {579}let hs_8: handshakestate = (if v_172 then (if v_175 then (if v_178 then (if v_182 then (if v_186 then handshakestatepack(ss_33,s_4,m_4,e_8,rs_4,rm_4,re_4,psk_4,false) else fail-any) else fail-any) else fail-any) else fail-any) else fail-any) in
        {580}insert statestore(me_2,them_2,sid_3,statepack_a(hs_8))
    ) | (
        {758}get statestore(=me_2,=them_2,=sid_3,statepack_a(hs_9: handshakestate)) in
        {581}in(pub, message_a_2: bitstring);
        {582}let v_187: bitstring = catch-fail(handshakestateunpack(hs_9)) in
        {583}let v_188: bool = (not-caught-fail(v_187) && success?(1-proj-9-tuple(v_187))) in
        {584}let initiator_3: bool = (if v_188 then 9-proj-9-tuple(v_187) else caught-fail) in
        {585}let psk_5: key = (if v_188 then 8-proj-9-tuple(v_187) else caught-fail) in
        {586}let re_5: key = (if v_188 then 7-proj-9-tuple(v_187) else caught-fail) in
        {587}let rm_5: key = (if v_188 then 6-proj-9-tuple(v_187) else caught-fail) in
        {588}let rs_5: key = (if v_188 then 5-proj-9-tuple(v_187) else caught-fail) in
        {589}let e_9: keypair = (if v_188 then 4-proj-9-tuple(v_187) else caught-fail) in
        {590}let m_5: keypair = (if v_188 then 3-proj-9-tuple(v_187) else caught-fail) in
        {591}let s_5: keypair = (if v_188 then 2-proj-9-tuple(v_187) else caught-fail) in
        {592}let ss_34: symmetricstate = (if v_188 then 1-proj-9-tuple(v_187) else caught-fail) in
        {593}let v_189: bitstring = (if v_188 then catch-fail(deconcat3(message_a_2)) else caught-fail) in
        {594}let v_190: bool = (not-caught-fail(v_189) && success?(1-proj-3-tuple(v_189))) in
        {595}let ciphertext_6: bitstring = (if v_190 then 3-proj-3-tuple(v_189) else caught-fail) in
        {596}let ns_2: bitstring = (if v_190 then 2-proj-3-tuple(v_189) else caught-fail) in
        {597}let ne_4: bitstring = (if v_190 then 1-proj-3-tuple(v_189) else caught-fail) in
        {600}let v_191: bitstring = (if v_190 then catch-fail(symmetricstateunpack(ss_34)) else caught-fail) in
        {601}let v_192: bool = (not-caught-fail(v_191) && success?(1-proj-3-tuple(v_191))) in
        {602}let h_34: bitstring = (if v_192 then 3-proj-3-tuple(v_191) else caught-fail) in
        {603}let ck_42: key = (if v_192 then 2-proj-3-tuple(v_191) else caught-fail) in
        {604}let cs_34: cipherstate = (if v_192 then 1-proj-3-tuple(v_191) else caught-fail) in
        {599}let re_6: key = (if v_190 then ne_4 else caught-fail) in
        {605}let ss_35: symmetricstate = (if v_190 then catch-fail((if v_192 then symmetricstatepack(cs_34,ck_42,hash(h_34,re_6)) else fail-any)) else caught-fail) in
        {606}let v_193: bool = not-caught-fail(ss_35) in
        {607}let v_194: bitstring = (if v_193 then catch-fail(keypairunpack(s_5)) else caught-fail) in
        {608}let v_195: bool = (not-caught-fail(v_194) && success?(1-proj-2-tuple(v_194))) in
        {609}let my_private_key_8: key = (if v_195 then 2-proj-2-tuple(v_194) else caught-fail) in
        {610}let my_public_key_8: key = (if v_195 then 1-proj-2-tuple(v_194) else caught-fail) in
        {611}let input_key_material_10: key = (if v_193 then catch-fail((if v_195 then dhexp(my_private_key_8,re_6) else fail-any)) else caught-fail) in
        {612}let v_196: bool = not-caught-fail(input_key_material_10) in
        {613}let v_197: bitstring = (if v_196 then catch-fail(symmetricstateunpack(ss_35)) else caught-fail) in
        {614}let v_198: bool = (not-caught-fail(v_197) && success?(1-proj-3-tuple(v_197))) in
        {615}let h_35: bitstring = (if v_198 then 3-proj-3-tuple(v_197) else caught-fail) in
        {616}let ck_43: key = (if v_198 then 2-proj-3-tuple(v_197) else caught-fail) in
        {617}let cs_35: cipherstate = (if v_198 then 1-proj-3-tuple(v_197) else caught-fail) in
        {620}let output3_10: key = (if v_198 then hmac_hash3(ck_43,input_key_material_10) else caught-fail) in
        {619}let output2_10: key = (if v_198 then hmac_hash2(ck_43,input_key_material_10) else caught-fail) in
        {618}let output1_10: key = (if v_198 then hmac_hash1(ck_43,input_key_material_10) else caught-fail) in
        {621}let v_199: bitstring = (if v_198 then catch-fail((output1_10,output2_10,output3_10)) else caught-fail) in
        {622}let v_200: bool = (not-caught-fail(v_199) && success?(1-proj-3-tuple(v_199))) in
        {623}let output_8: key = (if v_200 then 3-proj-3-tuple(v_199) else caught-fail) in
        {624}let temp_k_8: key = (if v_200 then 2-proj-3-tuple(v_199) else caught-fail) in
        {625}let ck_44: key = (if v_200 then 1-proj-3-tuple(v_199) else caught-fail) in
        {626}let ss_36: symmetricstate = (if v_193 then catch-fail((if v_196 then (if v_198 then (if v_200 then symmetricstatepack(cipherstatepack(temp_k_8,minnonce),ck_44,h_35) else fail-any) else fail-any) else fail-any)) else caught-fail) in
        {627}let v_201: bool = not-caught-fail(ss_36) in
        {628}let v_202: bitstring = (if v_201 then catch-fail(keypairunpack(m_5)) else caught-fail) in
        {629}let v_203: bool = (not-caught-fail(v_202) && success?(1-proj-2-tuple(v_202))) in
        {630}let my_private_key_9: key = (if v_203 then 2-proj-2-tuple(v_202) else caught-fail) in
        {631}let my_public_key_9: key = (if v_203 then 1-proj-2-tuple(v_202) else caught-fail) in
        {632}let input_key_material_11: key = (if v_201 then catch-fail((if v_203 then dhexp(my_private_key_9,re_6) else fail-any)) else caught-fail) in
        {633}let v_204: bool = not-caught-fail(input_key_material_11) in
        {634}let v_205: bitstring = (if v_204 then catch-fail(symmetricstateunpack(ss_36)) else caught-fail) in
        {635}let v_206: bool = (not-caught-fail(v_205) && success?(1-proj-3-tuple(v_205))) in
        {636}let h_36: bitstring = (if v_206 then 3-proj-3-tuple(v_205) else caught-fail) in
        {637}let ck_45: key = (if v_206 then 2-proj-3-tuple(v_205) else caught-fail) in
        {638}let cs_36: cipherstate = (if v_206 then 1-proj-3-tuple(v_205) else caught-fail) in
        {641}let output3_11: key = (if v_206 then hmac_hash3(ck_45,input_key_material_11) else caught-fail) in
        {640}let output2_11: key = (if v_206 then hmac_hash2(ck_45,input_key_material_11) else caught-fail) in
        {639}let output1_11: key = (if v_206 then hmac_hash1(ck_45,input_key_material_11) else caught-fail) in
        {642}let v_207: bitstring = (if v_206 then catch-fail((output1_11,output2_11,output3_11)) else caught-fail) in
        {643}let v_208: bool = (not-caught-fail(v_207) && success?(1-proj-3-tuple(v_207))) in
        {644}let output_9: key = (if v_208 then 3-proj-3-tuple(v_207) else caught-fail) in
        {645}let temp_k_9: key = (if v_208 then 2-proj-3-tuple(v_207) else caught-fail) in
        {646}let ck_46: key = (if v_208 then 1-proj-3-tuple(v_207) else caught-fail) in
        {647}let ss_37: symmetricstate = (if v_201 then catch-fail((if v_204 then (if v_206 then (if v_208 then symmetricstatepack(cipherstatepack(temp_k_9,minnonce),ck_46,h_36) else fail-any) else fail-any) else fail-any)) else caught-fail) in
        {648}let v_209: bool = not-caught-fail(ss_37) in
        {649}let v_210: bitstring = (if v_209 then catch-fail(keypairunpack(s_5)) else caught-fail) in
        {650}let v_211: bool = (not-caught-fail(v_210) && success?(1-proj-2-tuple(v_210))) in
        {651}let my_private_key_10: key = (if v_211 then 2-proj-2-tuple(v_210) else caught-fail) in
        {652}let my_public_key_10: key = (if v_211 then 1-proj-2-tuple(v_210) else caught-fail) in
        {653}let input_key_material_12: key = (if v_209 then catch-fail((if v_211 then dhexp(my_private_key_10,rm_5) else fail-any)) else caught-fail) in
        {654}let v_212: bool = not-caught-fail(input_key_material_12) in
        {655}let v_213: bitstring = (if v_212 then catch-fail(symmetricstateunpack(ss_37)) else caught-fail) in
        {656}let v_214: bool = (not-caught-fail(v_213) && success?(1-proj-3-tuple(v_213))) in
        {657}let h_37: bitstring = (if v_214 then 3-proj-3-tuple(v_213) else caught-fail) in
        {658}let ck_47: key = (if v_214 then 2-proj-3-tuple(v_213) else caught-fail) in
        {659}let cs_37: cipherstate = (if v_214 then 1-proj-3-tuple(v_213) else caught-fail) in
        {662}let output3_12: key = (if v_214 then hmac_hash3(ck_47,input_key_material_12) else caught-fail) in
        {661}let output2_12: key = (if v_214 then hmac_hash2(ck_47,input_key_material_12) else caught-fail) in
        {660}let output1_12: key = (if v_214 then hmac_hash1(ck_47,input_key_material_12) else caught-fail) in
        {663}let v_215: bitstring = (if v_214 then catch-fail((output1_12,output2_12,output3_12)) else caught-fail) in
        {664}let v_216: bool = (not-caught-fail(v_215) && success?(1-proj-3-tuple(v_215))) in
        {665}let output_10: key = (if v_216 then 3-proj-3-tuple(v_215) else caught-fail) in
        {666}let temp_k_10: key = (if v_216 then 2-proj-3-tuple(v_215) else caught-fail) in
        {667}let ck_48: key = (if v_216 then 1-proj-3-tuple(v_215) else caught-fail) in
        {668}let ss_38: symmetricstate = (if v_209 then catch-fail((if v_212 then (if v_214 then (if v_216 then symmetricstatepack(cipherstatepack(temp_k_10,minnonce),ck_48,h_37) else fail-any) else fail-any) else fail-any)) else caught-fail) in
        {669}let v_217: bool = not-caught-fail(ss_38) in
        {670}let v_218: bitstring = (if v_217 then catch-fail(keypairunpack(m_5)) else caught-fail) in
        {671}let v_219: bool = (not-caught-fail(v_218) && success?(1-proj-2-tuple(v_218))) in
        {672}let my_private_key_11: key = (if v_219 then 2-proj-2-tuple(v_218) else caught-fail) in
        {673}let my_public_key_11: key = (if v_219 then 1-proj-2-tuple(v_218) else caught-fail) in
        {674}let input_key_material_13: key = (if v_217 then catch-fail((if v_219 then dhexp(my_private_key_11,rs_5) else fail-any)) else caught-fail) in
        {675}let v_220: bool = not-caught-fail(input_key_material_13) in
        {676}let v_221: bitstring = (if v_220 then catch-fail(symmetricstateunpack(ss_38)) else caught-fail) in
        {677}let v_222: bool = (not-caught-fail(v_221) && success?(1-proj-3-tuple(v_221))) in
        {678}let h_38: bitstring = (if v_222 then 3-proj-3-tuple(v_221) else caught-fail) in
        {679}let ck_49: key = (if v_222 then 2-proj-3-tuple(v_221) else caught-fail) in
        {680}let cs_38: cipherstate = (if v_222 then 1-proj-3-tuple(v_221) else caught-fail) in
        {683}let output3_13: key = (if v_222 then hmac_hash3(ck_49,input_key_material_13) else caught-fail) in
        {682}let output2_13: key = (if v_222 then hmac_hash2(ck_49,input_key_material_13) else caught-fail) in
        {681}let output1_13: key = (if v_222 then hmac_hash1(ck_49,input_key_material_13) else caught-fail) in
        {684}let v_223: bitstring = (if v_222 then catch-fail((output1_13,output2_13,output3_13)) else caught-fail) in
        {685}let v_224: bool = (not-caught-fail(v_223) && success?(1-proj-3-tuple(v_223))) in
        {686}let output_11: key = (if v_224 then 3-proj-3-tuple(v_223) else caught-fail) in
        {687}let temp_k_11: key = (if v_224 then 2-proj-3-tuple(v_223) else caught-fail) in
        {688}let ck_50: key = (if v_224 then 1-proj-3-tuple(v_223) else caught-fail) in
        {689}let ss_39: symmetricstate = (if v_217 then catch-fail((if v_220 then (if v_222 then (if v_224 then symmetricstatepack(cipherstatepack(temp_k_11,minnonce),ck_50,h_38) else fail-any) else fail-any) else fail-any)) else caught-fail) in
        {690}let v_225: bool = not-caught-fail(ss_39) in
        {691}let v_226: bitstring = (if v_225 then catch-fail(symmetricstateunpack(ss_39)) else caught-fail) in
        {692}let v_227: bool = (not-caught-fail(v_226) && success?(1-proj-3-tuple(v_226))) in
        {693}let h_39: bitstring = (if v_227 then 3-proj-3-tuple(v_226) else caught-fail) in
        {694}let ck_51: key = (if v_227 then 2-proj-3-tuple(v_226) else caught-fail) in
        {695}let cs_39: cipherstate = (if v_227 then 1-proj-3-tuple(v_226) else caught-fail) in
        {696}let v_228: bitstring = (if v_227 then catch-fail(cipherstateunpack(cs_39)) else caught-fail) in
        {697}let v_229: bool = (not-caught-fail(v_228) && success?(1-proj-2-tuple(v_228))) in
        {698}let n_4: nonce = (if v_229 then 2-proj-2-tuple(v_228) else caught-fail) in
        {699}let k_7: key = (if v_229 then 1-proj-2-tuple(v_228) else caught-fail) in
        {700}let d: aead = (if v_229 then catch-fail(decrypt(k_7,n_4,h_39,ciphertext_6)) else caught-fail) in
        {701}let v_230: bool = not-caught-fail(d) in
        {702}let v_231: bitstring = (if v_230 then catch-fail(aeadunpack(d)) else caught-fail) in
        {703}let v_232: bool = (not-caught-fail(v_231) && success?(1-proj-3-tuple(v_231))) in
        {704}let plaintext: bitstring = (if v_232 then 3-proj-3-tuple(v_231) else caught-fail) in
        {705}let adi: bitstring = (if v_232 then 2-proj-3-tuple(v_231) else caught-fail) in
        {706}let valid: bool = (if v_232 then 1-proj-3-tuple(v_231) else caught-fail) in
        {708}let v_233: bitstring = (if v_232 then catch-fail(cipherstateunpack(cs_39)) else caught-fail) in
        {709}let v_234: bool = (not-caught-fail(v_233) && success?(1-proj-2-tuple(v_233))) in
        {710}let o_2: nonce = (if v_234 then 2-proj-2-tuple(v_233) else caught-fail) in
        {711}let k_8: key = (if v_234 then 1-proj-2-tuple(v_233) else caught-fail) in
        {707}let n_5: nonce = (if v_232 then increment_nonce(n_4) else caught-fail) in
        {712}let csi_4: cipherstate = (if v_232 then catch-fail((if v_234 then cipherstatepack(k_8,n_5) else fail-any)) else caught-fail) in
        {713}let v_235: bool = not-caught-fail(csi_4) in
        {714}let v_236: bitstring = (if v_227 then catch-fail((if v_229 then (if v_230 then (if v_232 then (if v_235 then (csi_4,plaintext,valid) else fail-any) else fail-any) else fail-any) else fail-any)) else caught-fail) in
        {715}let v_237: bool = (not-caught-fail(v_236) && success?(1-proj-3-tuple(v_236))) in
        {716}let valid_1: bool = (if v_237 then 3-proj-3-tuple(v_236) else caught-fail) in
        {717}let plaintext_1: bitstring = (if v_237 then 2-proj-3-tuple(v_236) else caught-fail) in
        {718}let csi_5: cipherstate = (if v_237 then 1-proj-3-tuple(v_236) else caught-fail) in
        {719}let ss_40: symmetricstate = (if v_237 then symmetricstatepack(csi_5,ck_51,h_39) else caught-fail) in
        {720}let v_238: bitstring = (if v_237 then catch-fail(symmetricstateunpack(ss_40)) else caught-fail) in
        {721}let v_239: bool = (not-caught-fail(v_238) && success?(1-proj-3-tuple(v_238))) in
        {722}let h_40: bitstring = (if v_239 then 3-proj-3-tuple(v_238) else caught-fail) in
        {723}let ck_52: key = (if v_239 then 2-proj-3-tuple(v_238) else caught-fail) in
        {724}let cs_40: cipherstate = (if v_239 then 1-proj-3-tuple(v_238) else caught-fail) in
        {725}let ssi_4: symmetricstate = (if v_237 then catch-fail((if v_239 then symmetricstatepack(cs_40,ck_52,hash(h_40,ciphertext_6)) else fail-any)) else caught-fail) in
        {726}let v_240: bool = not-caught-fail(ssi_4) in
        {727}let v_241: bitstring = (if v_225 then catch-fail((if v_227 then (if v_237 then (if v_240 then (ssi_4,plaintext_1,valid_1) else fail-any) else fail-any) else fail-any)) else caught-fail) in
        {728}let v_242: bool = (not-caught-fail(v_241) && success?(1-proj-3-tuple(v_241))) in
        {729}let valid2: bool = (if v_242 then 3-proj-3-tuple(v_241) else caught-fail) in
        {730}let plaintext_2: bitstring = (if v_242 then 2-proj-3-tuple(v_241) else caught-fail) in
        {731}let ss_41: symmetricstate = (if v_242 then 1-proj-3-tuple(v_241) else caught-fail) in
        {598}let valid1: bool = (if v_190 then true else caught-fail) in
        {732}let v_243: bool = (if v_242 then catch-fail((valid1 && valid2)) else caught-fail) in
        {734}let v_244: bitstring = (if v_243 then catch-fail(symmetricstateunpack(ss_41)) else caught-fail) in
        {735}let v_245: bool = (not-caught-fail(v_244) && success?(1-proj-3-tuple(v_244))) in
        {736}let h_41: bitstring = (if v_245 then 3-proj-3-tuple(v_244) else caught-fail) in
        {737}let ck_53: key = (if v_245 then 2-proj-3-tuple(v_244) else caught-fail) in
        {738}let cs_41: cipherstate = (if v_245 then 1-proj-3-tuple(v_244) else caught-fail) in
        {739}let input_key_material_14: key = (if v_245 then zero else caught-fail) in
        {742}let output3_14: key = (if v_245 then hmac_hash3(ck_53,input_key_material_14) else caught-fail) in
        {741}let output2_14: key = (if v_245 then hmac_hash2(ck_53,input_key_material_14) else caught-fail) in
        {740}let output1_14: key = (if v_245 then hmac_hash1(ck_53,input_key_material_14) else caught-fail) in
        {743}let v_246: bitstring = (if v_245 then catch-fail((output1_14,output2_14,output3_14)) else caught-fail) in
        {744}let v_247: bool = (not-caught-fail(v_246) && success?(1-proj-3-tuple(v_246))) in
        {745}let temp_k3_2: key = (if v_247 then 3-proj-3-tuple(v_246) else caught-fail) in
        {746}let temp_k2_2: key = (if v_247 then 2-proj-3-tuple(v_246) else caught-fail) in
        {747}let temp_k1_2: key = (if v_247 then 1-proj-3-tuple(v_246) else caught-fail) in
        {749}let cs2_6: cipherstate = (if v_247 then cipherstatepack(temp_k2_2,minnonce) else caught-fail) in
        {748}let cs1_6: cipherstate = (if v_247 then cipherstatepack(temp_k1_2,minnonce) else caught-fail) in
        {750}let v_248: bitstring = (if v_243 then catch-fail((if v_245 then (if v_247 then (ss_41,cs1_6,cs2_6) else fail-any) else fail-any)) else caught-fail) in
        {751}let v_249: bool = (not-caught-fail(v_248) && success?(1-proj-3-tuple(v_248))) in
        {752}let cs2_7: cipherstate = (if v_249 then 3-proj-3-tuple(v_248) else caught-fail) in
        {753}let cs1_7: cipherstate = (if v_249 then 2-proj-3-tuple(v_248) else caught-fail) in
        {754}let ssi_5: symmetricstate = (if v_249 then 1-proj-3-tuple(v_248) else caught-fail) in
        {733}let hs_10: handshakestate = (if v_243 then handshakestatepack(ss_41,s_5,m_5,e_9,rs_5,rm_5,re_6,psk_5,initiator_3) else caught-fail) in
        {755}let (hs_11: handshakestate,plaintext_a: bitstring,valid_2: bool,cs1_8: cipherstate,cs2_8: cipherstate) = (if v_188 then (if v_190 then (if v_193 then (if v_201 then (if v_209 then (if v_217 then (if v_225 then (if v_242 then (if undo-catch-fail(v_243) then (if v_249 then (hs_10,plaintext_2,true,cs1_7,cs2_7) else fail-any) else fail-any) else fail-any) else fail-any) else fail-any) else fail-any) else fail-any) else fail-any) else fail-any) else fail-any) in
        {756}event RecvMsg(me_2,them_2,stagepack_a(sid_3),plaintext_a);
        {757}event RecvEnd(valid_2)
    ) | (
        {759}event LeakS(phase0,me_2);
        {760}event LeakM(phase0,me_2);
        {761}out(pub, (key_s(me_2),key_m(me_2)))
    ) | (
        {762}phase 1;
        {763}event LeakS(phase1,me_2);
        {764}event LeakM(phase1,me_2);
        {765}out(pub, (key_s(me_2),key_m(me_2)))
    )
) | (
    {766}let me_3: principal = bob in
    {769}let basis_14: key = key_s(me_3) in
    {770}let public_key_14: key = catch-fail(dhexp(basis_14,validkey(g))) in
    {771}let v_250: bool = not-caught-fail(public_key_14) in
    {772}let s_6: keypair = (if v_250 then keypairpack(validkey(public_key_14),basis_14) else fail-any) in
    {773}let basis_15: key = key_m(me_3) in
    {774}let public_key_15: key = catch-fail(dhexp(basis_15,validkey(g))) in
    {775}let v_251: bool = not-caught-fail(public_key_15) in
    {776}let m_6: keypair = (if v_251 then keypairpack(validkey(public_key_15),basis_15) else fail-any) in
    {777}out(pub, (getpublickey(s_6),getpublickey(m_6)));
    {768}let sid_4: sessionid = sid in
    {767}let them_3: principal = charlie in
    (
        {779}let basis_16: key = key_s(them_3) in
        {780}let public_key_16: key = catch-fail(dhexp(basis_16,validkey(g))) in
        {781}let v_252: bool = not-caught-fail(public_key_16) in
        {782}let rs_6: key = getpublickey((if v_252 then keypairpack(validkey(public_key_16),basis_16) else fail-any)) in
        {783}let basis_17: key = key_m(them_3) in
        {784}let public_key_17: key = catch-fail(dhexp(basis_17,validkey(g))) in
        {785}let v_253: bool = not-caught-fail(public_key_17) in
        {786}let rm_6: key = getpublickey((if v_253 then keypairpack(validkey(public_key_17),basis_17) else fail-any)) in
        {793}let k_9: key = empty in
        {794}let cs_42: cipherstate = cipherstatepack(k_9,minnonce) in
        {790}let protocol_name_3: bitstring = somename in
        {791}let h_42: bitstring = hash(protocol_name_3,empty) in
        {792}let ck_54: key = h_42 in
        {795}let ss_42: symmetricstate = symmetricstatepack(cs_42,ck_54,h_42) in
        {796}let v_254: bitstring = catch-fail(symmetricstateunpack(ss_42)) in
        {797}let v_255: bool = (not-caught-fail(v_254) && success?(1-proj-3-tuple(v_254))) in
        {798}let h_43: bitstring = (if v_255 then 3-proj-3-tuple(v_254) else caught-fail) in
        {799}let ck_55: key = (if v_255 then 2-proj-3-tuple(v_254) else caught-fail) in
        {800}let cs_43: cipherstate = (if v_255 then 1-proj-3-tuple(v_254) else caught-fail) in
        {788}let prologue_3: bitstring = empty in
        {801}let ss_43: symmetricstate = catch-fail((if v_255 then symmetricstatepack(cs_43,ck_55,hash(h_43,prologue_3)) else fail-any)) in
        {802}let v_256: bool = not-caught-fail(ss_43) in
        {803}let v_257: bitstring = (if v_256 then catch-fail(symmetricstateunpack(ss_43)) else caught-fail) in
        {804}let v_258: bool = (not-caught-fail(v_257) && success?(1-proj-3-tuple(v_257))) in
        {805}let h_44: bitstring = (if v_258 then 3-proj-3-tuple(v_257) else caught-fail) in
        {806}let ck_56: key = (if v_258 then 2-proj-3-tuple(v_257) else caught-fail) in
        {807}let cs_44: cipherstate = (if v_258 then 1-proj-3-tuple(v_257) else caught-fail) in
        {808}let ss_44: symmetricstate = (if v_256 then catch-fail((if v_258 then symmetricstatepack(cs_44,ck_56,hash(h_44,rs_6)) else fail-any)) else caught-fail) in
        {809}let v_259: bool = not-caught-fail(ss_44) in
        {810}let v_260: bitstring = (if v_259 then catch-fail(symmetricstateunpack(ss_44)) else caught-fail) in
        {811}let v_261: bool = (not-caught-fail(v_260) && success?(1-proj-3-tuple(v_260))) in
        {812}let h_45: bitstring = (if v_261 then 3-proj-3-tuple(v_260) else caught-fail) in
        {813}let ck_57: key = (if v_261 then 2-proj-3-tuple(v_260) else caught-fail) in
        {814}let cs_45: cipherstate = (if v_261 then 1-proj-3-tuple(v_260) else caught-fail) in
        {815}let ss_45: symmetricstate = (if v_259 then catch-fail((if v_261 then symmetricstatepack(cs_45,ck_57,hash(h_45,rm_6)) else fail-any)) else caught-fail) in
        {816}let v_262: bool = not-caught-fail(ss_45) in
        {817}let data_6: bitstring = (if v_262 then catch-fail(getpublickey(s_6)) else caught-fail) in
        {818}let v_263: bool = not-caught-fail(data_6) in
        {819}let v_264: bitstring = (if v_263 then catch-fail(symmetricstateunpack(ss_45)) else caught-fail) in
        {820}let v_265: bool = (not-caught-fail(v_264) && success?(1-proj-3-tuple(v_264))) in
        {821}let h_46: bitstring = (if v_265 then 3-proj-3-tuple(v_264) else caught-fail) in
        {822}let ck_58: key = (if v_265 then 2-proj-3-tuple(v_264) else caught-fail) in
        {823}let cs_46: cipherstate = (if v_265 then 1-proj-3-tuple(v_264) else caught-fail) in
        {824}let ss_46: symmetricstate = (if v_262 then catch-fail((if v_263 then (if v_265 then symmetricstatepack(cs_46,ck_58,hash(h_46,data_6)) else fail-any) else fail-any)) else caught-fail) in
        {825}let v_266: bool = not-caught-fail(ss_46) in
        {826}let data_7: bitstring = (if v_266 then catch-fail(getpublickey(m_6)) else caught-fail) in
        {827}let v_267: bool = not-caught-fail(data_7) in
        {828}let v_268: bitstring = (if v_267 then catch-fail(symmetricstateunpack(ss_46)) else caught-fail) in
        {829}let v_269: bool = (not-caught-fail(v_268) && success?(1-proj-3-tuple(v_268))) in
        {830}let h_47: bitstring = (if v_269 then 3-proj-3-tuple(v_268) else caught-fail) in
        {831}let ck_59: key = (if v_269 then 2-proj-3-tuple(v_268) else caught-fail) in
        {832}let cs_47: cipherstate = (if v_269 then 1-proj-3-tuple(v_268) else caught-fail) in
        {833}let ss_47: symmetricstate = (if v_266 then catch-fail((if v_267 then (if v_269 then symmetricstatepack(cs_47,ck_59,hash(h_47,data_7)) else fail-any) else fail-any)) else caught-fail) in
        {834}let v_270: bool = not-caught-fail(ss_47) in
        {789}let psk_6: key = empty in
        {787}let re_7: key = empty in
        {778}let e_10: keypair = keypairpack(empty,empty) in
        {835}let hs_12: handshakestate = (if v_256 then (if v_259 then (if v_262 then (if v_266 then (if v_270 then handshakestatepack(ss_47,s_6,m_6,e_10,rs_6,rm_6,re_7,psk_6,false) else fail-any) else fail-any) else fail-any) else fail-any) else fail-any) in
        {836}insert statestore(me_3,them_3,sid_4,statepack_a(hs_12))
    ) | (
        {1014}get statestore(=me_3,=them_3,=sid_4,statepack_a(hs_13: handshakestate)) in
        {837}in(pub, message_a_3: bitstring);
        {838}let v_271: bitstring = catch-fail(handshakestateunpack(hs_13)) in
        {839}let v_272: bool = (not-caught-fail(v_271) && success?(1-proj-9-tuple(v_271))) in
        {840}let initiator_4: bool = (if v_272 then 9-proj-9-tuple(v_271) else caught-fail) in
        {841}let psk_7: key = (if v_272 then 8-proj-9-tuple(v_271) else caught-fail) in
        {842}let re_8: key = (if v_272 then 7-proj-9-tuple(v_271) else caught-fail) in
        {843}let rm_7: key = (if v_272 then 6-proj-9-tuple(v_271) else caught-fail) in
        {844}let rs_7: key = (if v_272 then 5-proj-9-tuple(v_271) else caught-fail) in
        {845}let e_11: keypair = (if v_272 then 4-proj-9-tuple(v_271) else caught-fail) in
        {846}let m_7: keypair = (if v_272 then 3-proj-9-tuple(v_271) else caught-fail) in
        {847}let s_7: keypair = (if v_272 then 2-proj-9-tuple(v_271) else caught-fail) in
        {848}let ss_48: symmetricstate = (if v_272 then 1-proj-9-tuple(v_271) else caught-fail) in
        {849}let v_273: bitstring = (if v_272 then catch-fail(deconcat3(message_a_3)) else caught-fail) in
        {850}let v_274: bool = (not-caught-fail(v_273) && success?(1-proj-3-tuple(v_273))) in
        {851}let ciphertext_7: bitstring = (if v_274 then 3-proj-3-tuple(v_273) else caught-fail) in
        {852}let ns_3: bitstring = (if v_274 then 2-proj-3-tuple(v_273) else caught-fail) in
        {853}let ne_5: bitstring = (if v_274 then 1-proj-3-tuple(v_273) else caught-fail) in
        {856}let v_275: bitstring = (if v_274 then catch-fail(symmetricstateunpack(ss_48)) else caught-fail) in
        {857}let v_276: bool = (not-caught-fail(v_275) && success?(1-proj-3-tuple(v_275))) in
        {858}let h_48: bitstring = (if v_276 then 3-proj-3-tuple(v_275) else caught-fail) in
        {859}let ck_60: key = (if v_276 then 2-proj-3-tuple(v_275) else caught-fail) in
        {860}let cs_48: cipherstate = (if v_276 then 1-proj-3-tuple(v_275) else caught-fail) in
        {855}let re_9: key = (if v_274 then ne_5 else caught-fail) in
        {861}let ss_49: symmetricstate = (if v_274 then catch-fail((if v_276 then symmetricstatepack(cs_48,ck_60,hash(h_48,re_9)) else fail-any)) else caught-fail) in
        {862}let v_277: bool = not-caught-fail(ss_49) in
        {863}let v_278: bitstring = (if v_277 then catch-fail(keypairunpack(s_7)) else caught-fail) in
        {864}let v_279: bool = (not-caught-fail(v_278) && success?(1-proj-2-tuple(v_278))) in
        {865}let my_private_key_12: key = (if v_279 then 2-proj-2-tuple(v_278) else caught-fail) in
        {866}let my_public_key_12: key = (if v_279 then 1-proj-2-tuple(v_278) else caught-fail) in
        {867}let input_key_material_15: key = (if v_277 then catch-fail((if v_279 then dhexp(my_private_key_12,re_9) else fail-any)) else caught-fail) in
        {868}let v_280: bool = not-caught-fail(input_key_material_15) in
        {869}let v_281: bitstring = (if v_280 then catch-fail(symmetricstateunpack(ss_49)) else caught-fail) in
        {870}let v_282: bool = (not-caught-fail(v_281) && success?(1-proj-3-tuple(v_281))) in
        {871}let h_49: bitstring = (if v_282 then 3-proj-3-tuple(v_281) else caught-fail) in
        {872}let ck_61: key = (if v_282 then 2-proj-3-tuple(v_281) else caught-fail) in
        {873}let cs_49: cipherstate = (if v_282 then 1-proj-3-tuple(v_281) else caught-fail) in
        {876}let output3_15: key = (if v_282 then hmac_hash3(ck_61,input_key_material_15) else caught-fail) in
        {875}let output2_15: key = (if v_282 then hmac_hash2(ck_61,input_key_material_15) else caught-fail) in
        {874}let output1_15: key = (if v_282 then hmac_hash1(ck_61,input_key_material_15) else caught-fail) in
        {877}let v_283: bitstring = (if v_282 then catch-fail((output1_15,output2_15,output3_15)) else caught-fail) in
        {878}let v_284: bool = (not-caught-fail(v_283) && success?(1-proj-3-tuple(v_283))) in
        {879}let output_12: key = (if v_284 then 3-proj-3-tuple(v_283) else caught-fail) in
        {880}let temp_k_12: key = (if v_284 then 2-proj-3-tuple(v_283) else caught-fail) in
        {881}let ck_62: key = (if v_284 then 1-proj-3-tuple(v_283) else caught-fail) in
        {882}let ss_50: symmetricstate = (if v_277 then catch-fail((if v_280 then (if v_282 then (if v_284 then symmetricstatepack(cipherstatepack(temp_k_12,minnonce),ck_62,h_49) else fail-any) else fail-any) else fail-any)) else caught-fail) in
        {883}let v_285: bool = not-caught-fail(ss_50) in
        {884}let v_286: bitstring = (if v_285 then catch-fail(keypairunpack(m_7)) else caught-fail) in
        {885}let v_287: bool = (not-caught-fail(v_286) && success?(1-proj-2-tuple(v_286))) in
        {886}let my_private_key_13: key = (if v_287 then 2-proj-2-tuple(v_286) else caught-fail) in
        {887}let my_public_key_13: key = (if v_287 then 1-proj-2-tuple(v_286) else caught-fail) in
        {888}let input_key_material_16: key = (if v_285 then catch-fail((if v_287 then dhexp(my_private_key_13,re_9) else fail-any)) else caught-fail) in
        {889}let v_288: bool = not-caught-fail(input_key_material_16) in
        {890}let v_289: bitstring = (if v_288 then catch-fail(symmetricstateunpack(ss_50)) else caught-fail) in
        {891}let v_290: bool = (not-caught-fail(v_289) && success?(1-proj-3-tuple(v_289))) in
        {892}let h_50: bitstring = (if v_290 then 3-proj-3-tuple(v_289) else caught-fail) in
        {893}let ck_63: key = (if v_290 then 2-proj-3-tuple(v_289) else caught-fail) in
        {894}let cs_50: cipherstate = (if v_290 then 1-proj-3-tuple(v_289) else caught-fail) in
        {897}let output3_16: key = (if v_290 then hmac_hash3(ck_63,input_key_material_16) else caught-fail) in
        {896}let output2_16: key = (if v_290 then hmac_hash2(ck_63,input_key_material_16) else caught-fail) in
        {895}let output1_16: key = (if v_290 then hmac_hash1(ck_63,input_key_material_16) else caught-fail) in
        {898}let v_291: bitstring = (if v_290 then catch-fail((output1_16,output2_16,output3_16)) else caught-fail) in
        {899}let v_292: bool = (not-caught-fail(v_291) && success?(1-proj-3-tuple(v_291))) in
        {900}let output_13: key = (if v_292 then 3-proj-3-tuple(v_291) else caught-fail) in
        {901}let temp_k_13: key = (if v_292 then 2-proj-3-tuple(v_291) else caught-fail) in
        {902}let ck_64: key = (if v_292 then 1-proj-3-tuple(v_291) else caught-fail) in
        {903}let ss_51: symmetricstate = (if v_285 then catch-fail((if v_288 then (if v_290 then (if v_292 then symmetricstatepack(cipherstatepack(temp_k_13,minnonce),ck_64,h_50) else fail-any) else fail-any) else fail-any)) else caught-fail) in
        {904}let v_293: bool = not-caught-fail(ss_51) in
        {905}let v_294: bitstring = (if v_293 then catch-fail(keypairunpack(s_7)) else caught-fail) in
        {906}let v_295: bool = (not-caught-fail(v_294) && success?(1-proj-2-tuple(v_294))) in
        {907}let my_private_key_14: key = (if v_295 then 2-proj-2-tuple(v_294) else caught-fail) in
        {908}let my_public_key_14: key = (if v_295 then 1-proj-2-tuple(v_294) else caught-fail) in
        {909}let input_key_material_17: key = (if v_293 then catch-fail((if v_295 then dhexp(my_private_key_14,rm_7) else fail-any)) else caught-fail) in
        {910}let v_296: bool = not-caught-fail(input_key_material_17) in
        {911}let v_297: bitstring = (if v_296 then catch-fail(symmetricstateunpack(ss_51)) else caught-fail) in
        {912}let v_298: bool = (not-caught-fail(v_297) && success?(1-proj-3-tuple(v_297))) in
        {913}let h_51: bitstring = (if v_298 then 3-proj-3-tuple(v_297) else caught-fail) in
        {914}let ck_65: key = (if v_298 then 2-proj-3-tuple(v_297) else caught-fail) in
        {915}let cs_51: cipherstate = (if v_298 then 1-proj-3-tuple(v_297) else caught-fail) in
        {918}let output3_17: key = (if v_298 then hmac_hash3(ck_65,input_key_material_17) else caught-fail) in
        {917}let output2_17: key = (if v_298 then hmac_hash2(ck_65,input_key_material_17) else caught-fail) in
        {916}let output1_17: key = (if v_298 then hmac_hash1(ck_65,input_key_material_17) else caught-fail) in
        {919}let v_299: bitstring = (if v_298 then catch-fail((output1_17,output2_17,output3_17)) else caught-fail) in
        {920}let v_300: bool = (not-caught-fail(v_299) && success?(1-proj-3-tuple(v_299))) in
        {921}let output_14: key = (if v_300 then 3-proj-3-tuple(v_299) else caught-fail) in
        {922}let temp_k_14: key = (if v_300 then 2-proj-3-tuple(v_299) else caught-fail) in
        {923}let ck_66: key = (if v_300 then 1-proj-3-tuple(v_299) else caught-fail) in
        {924}let ss_52: symmetricstate = (if v_293 then catch-fail((if v_296 then (if v_298 then (if v_300 then symmetricstatepack(cipherstatepack(temp_k_14,minnonce),ck_66,h_51) else fail-any) else fail-any) else fail-any)) else caught-fail) in
        {925}let v_301: bool = not-caught-fail(ss_52) in
        {926}let v_302: bitstring = (if v_301 then catch-fail(keypairunpack(m_7)) else caught-fail) in
        {927}let v_303: bool = (not-caught-fail(v_302) && success?(1-proj-2-tuple(v_302))) in
        {928}let my_private_key_15: key = (if v_303 then 2-proj-2-tuple(v_302) else caught-fail) in
        {929}let my_public_key_15: key = (if v_303 then 1-proj-2-tuple(v_302) else caught-fail) in
        {930}let input_key_material_18: key = (if v_301 then catch-fail((if v_303 then dhexp(my_private_key_15,rs_7) else fail-any)) else caught-fail) in
        {931}let v_304: bool = not-caught-fail(input_key_material_18) in
        {932}let v_305: bitstring = (if v_304 then catch-fail(symmetricstateunpack(ss_52)) else caught-fail) in
        {933}let v_306: bool = (not-caught-fail(v_305) && success?(1-proj-3-tuple(v_305))) in
        {934}let h_52: bitstring = (if v_306 then 3-proj-3-tuple(v_305) else caught-fail) in
        {935}let ck_67: key = (if v_306 then 2-proj-3-tuple(v_305) else caught-fail) in
        {936}let cs_52: cipherstate = (if v_306 then 1-proj-3-tuple(v_305) else caught-fail) in
        {939}let output3_18: key = (if v_306 then hmac_hash3(ck_67,input_key_material_18) else caught-fail) in
        {938}let output2_18: key = (if v_306 then hmac_hash2(ck_67,input_key_material_18) else caught-fail) in
        {937}let output1_18: key = (if v_306 then hmac_hash1(ck_67,input_key_material_18) else caught-fail) in
        {940}let v_307: bitstring = (if v_306 then catch-fail((output1_18,output2_18,output3_18)) else caught-fail) in
        {941}let v_308: bool = (not-caught-fail(v_307) && success?(1-proj-3-tuple(v_307))) in
        {942}let output_15: key = (if v_308 then 3-proj-3-tuple(v_307) else caught-fail) in
        {943}let temp_k_15: key = (if v_308 then 2-proj-3-tuple(v_307) else caught-fail) in
        {944}let ck_68: key = (if v_308 then 1-proj-3-tuple(v_307) else caught-fail) in
        {945}let ss_53: symmetricstate = (if v_301 then catch-fail((if v_304 then (if v_306 then (if v_308 then symmetricstatepack(cipherstatepack(temp_k_15,minnonce),ck_68,h_52) else fail-any) else fail-any) else fail-any)) else caught-fail) in
        {946}let v_309: bool = not-caught-fail(ss_53) in
        {947}let v_310: bitstring = (if v_309 then catch-fail(symmetricstateunpack(ss_53)) else caught-fail) in
        {948}let v_311: bool = (not-caught-fail(v_310) && success?(1-proj-3-tuple(v_310))) in
        {949}let h_53: bitstring = (if v_311 then 3-proj-3-tuple(v_310) else caught-fail) in
        {950}let ck_69: key = (if v_311 then 2-proj-3-tuple(v_310) else caught-fail) in
        {951}let cs_53: cipherstate = (if v_311 then 1-proj-3-tuple(v_310) else caught-fail) in
        {952}let v_312: bitstring = (if v_311 then catch-fail(cipherstateunpack(cs_53)) else caught-fail) in
        {953}let v_313: bool = (not-caught-fail(v_312) && success?(1-proj-2-tuple(v_312))) in
        {954}let n_6: nonce = (if v_313 then 2-proj-2-tuple(v_312) else caught-fail) in
        {955}let k_10: key = (if v_313 then 1-proj-2-tuple(v_312) else caught-fail) in
        {956}let d_1: aead = (if v_313 then catch-fail(decrypt(k_10,n_6,h_53,ciphertext_7)) else caught-fail) in
        {957}let v_314: bool = not-caught-fail(d_1) in
        {958}let v_315: bitstring = (if v_314 then catch-fail(aeadunpack(d_1)) else caught-fail) in
        {959}let v_316: bool = (not-caught-fail(v_315) && success?(1-proj-3-tuple(v_315))) in
        {960}let plaintext_3: bitstring = (if v_316 then 3-proj-3-tuple(v_315) else caught-fail) in
        {961}let adi_1: bitstring = (if v_316 then 2-proj-3-tuple(v_315) else caught-fail) in
        {962}let valid_3: bool = (if v_316 then 1-proj-3-tuple(v_315) else caught-fail) in
        {964}let v_317: bitstring = (if v_316 then catch-fail(cipherstateunpack(cs_53)) else caught-fail) in
        {965}let v_318: bool = (not-caught-fail(v_317) && success?(1-proj-2-tuple(v_317))) in
        {966}let o_3: nonce = (if v_318 then 2-proj-2-tuple(v_317) else caught-fail) in
        {967}let k_11: key = (if v_318 then 1-proj-2-tuple(v_317) else caught-fail) in
        {963}let n_7: nonce = (if v_316 then increment_nonce(n_6) else caught-fail) in
        {968}let csi_6: cipherstate = (if v_316 then catch-fail((if v_318 then cipherstatepack(k_11,n_7) else fail-any)) else caught-fail) in
        {969}let v_319: bool = not-caught-fail(csi_6) in
        {970}let v_320: bitstring = (if v_311 then catch-fail((if v_313 then (if v_314 then (if v_316 then (if v_319 then (csi_6,plaintext_3,valid_3) else fail-any) else fail-any) else fail-any) else fail-any)) else caught-fail) in
        {971}let v_321: bool = (not-caught-fail(v_320) && success?(1-proj-3-tuple(v_320))) in
        {972}let valid_4: bool = (if v_321 then 3-proj-3-tuple(v_320) else caught-fail) in
        {973}let plaintext_4: bitstring = (if v_321 then 2-proj-3-tuple(v_320) else caught-fail) in
        {974}let csi_7: cipherstate = (if v_321 then 1-proj-3-tuple(v_320) else caught-fail) in
        {975}let ss_54: symmetricstate = (if v_321 then symmetricstatepack(csi_7,ck_69,h_53) else caught-fail) in
        {976}let v_322: bitstring = (if v_321 then catch-fail(symmetricstateunpack(ss_54)) else caught-fail) in
        {977}let v_323: bool = (not-caught-fail(v_322) && success?(1-proj-3-tuple(v_322))) in
        {978}let h_54: bitstring = (if v_323 then 3-proj-3-tuple(v_322) else caught-fail) in
        {979}let ck_70: key = (if v_323 then 2-proj-3-tuple(v_322) else caught-fail) in
        {980}let cs_54: cipherstate = (if v_323 then 1-proj-3-tuple(v_322) else caught-fail) in
        {981}let ssi_6: symmetricstate = (if v_321 then catch-fail((if v_323 then symmetricstatepack(cs_54,ck_70,hash(h_54,ciphertext_7)) else fail-any)) else caught-fail) in
        {982}let v_324: bool = not-caught-fail(ssi_6) in
        {983}let v_325: bitstring = (if v_309 then catch-fail((if v_311 then (if v_321 then (if v_324 then (ssi_6,plaintext_4,valid_4) else fail-any) else fail-any) else fail-any)) else caught-fail) in
        {984}let v_326: bool = (not-caught-fail(v_325) && success?(1-proj-3-tuple(v_325))) in
        {985}let valid2_1: bool = (if v_326 then 3-proj-3-tuple(v_325) else caught-fail) in
        {986}let plaintext_5: bitstring = (if v_326 then 2-proj-3-tuple(v_325) else caught-fail) in
        {987}let ss_55: symmetricstate = (if v_326 then 1-proj-3-tuple(v_325) else caught-fail) in
        {854}let valid1_1: bool = (if v_274 then true else caught-fail) in
        {988}let v_327: bool = (if v_326 then catch-fail((valid1_1 && valid2_1)) else caught-fail) in
        {990}let v_328: bitstring = (if v_327 then catch-fail(symmetricstateunpack(ss_55)) else caught-fail) in
        {991}let v_329: bool = (not-caught-fail(v_328) && success?(1-proj-3-tuple(v_328))) in
        {992}let h_55: bitstring = (if v_329 then 3-proj-3-tuple(v_328) else caught-fail) in
        {993}let ck_71: key = (if v_329 then 2-proj-3-tuple(v_328) else caught-fail) in
        {994}let cs_55: cipherstate = (if v_329 then 1-proj-3-tuple(v_328) else caught-fail) in
        {995}let input_key_material_19: key = (if v_329 then zero else caught-fail) in
        {998}let output3_19: key = (if v_329 then hmac_hash3(ck_71,input_key_material_19) else caught-fail) in
        {997}let output2_19: key = (if v_329 then hmac_hash2(ck_71,input_key_material_19) else caught-fail) in
        {996}let output1_19: key = (if v_329 then hmac_hash1(ck_71,input_key_material_19) else caught-fail) in
        {999}let v_330: bitstring = (if v_329 then catch-fail((output1_19,output2_19,output3_19)) else caught-fail) in
        {1000}let v_331: bool = (not-caught-fail(v_330) && success?(1-proj-3-tuple(v_330))) in
        {1001}let temp_k3_3: key = (if v_331 then 3-proj-3-tuple(v_330) else caught-fail) in
        {1002}let temp_k2_3: key = (if v_331 then 2-proj-3-tuple(v_330) else caught-fail) in
        {1003}let temp_k1_3: key = (if v_331 then 1-proj-3-tuple(v_330) else caught-fail) in
        {1005}let cs2_9: cipherstate = (if v_331 then cipherstatepack(temp_k2_3,minnonce) else caught-fail) in
        {1004}let cs1_9: cipherstate = (if v_331 then cipherstatepack(temp_k1_3,minnonce) else caught-fail) in
        {1006}let v_332: bitstring = (if v_327 then catch-fail((if v_329 then (if v_331 then (ss_55,cs1_9,cs2_9) else fail-any) else fail-any)) else caught-fail) in
        {1007}let v_333: bool = (not-caught-fail(v_332) && success?(1-proj-3-tuple(v_332))) in
        {1008}let cs2_10: cipherstate = (if v_333 then 3-proj-3-tuple(v_332) else caught-fail) in
        {1009}let cs1_10: cipherstate = (if v_333 then 2-proj-3-tuple(v_332) else caught-fail) in
        {1010}let ssi_7: symmetricstate = (if v_333 then 1-proj-3-tuple(v_332) else caught-fail) in
        {989}let hs_14: handshakestate = (if v_327 then handshakestatepack(ss_55,s_7,m_7,e_11,rs_7,rm_7,re_9,psk_7,initiator_4) else caught-fail) in
        {1011}let (hs_15: handshakestate,plaintext_a_1: bitstring,valid_5: bool,cs1_11: cipherstate,cs2_11: cipherstate) = (if v_272 then (if v_274 then (if v_277 then (if v_285 then (if v_293 then (if v_301 then (if v_309 then (if v_326 then (if undo-catch-fail(v_327) then (if v_333 then (hs_14,plaintext_5,true,cs1_10,cs2_10) else fail-any) else fail-any) else fail-any) else fail-any) else fail-any) else fail-any) else fail-any) else fail-any) else fail-any) else fail-any) in
        {1012}event RecvMsg(me_3,them_3,stagepack_a(sid_4),plaintext_a_1);
        {1013}event RecvEnd(valid_5)
    ) | (
        {1015}event LeakS(phase0,me_3);
        {1016}event LeakM(phase0,me_3);
        {1017}out(pub, (key_s(me_3),key_m(me_3)))
    ) | (
        {1018}phase 1;
        {1019}event LeakS(phase1,me_3);
        {1020}event LeakM(phase1,me_3);
        {1021}out(pub, (key_s(me_3),key_m(me_3)))
    )
)

-- Query event(RecvMsg(bob,alice,stagepack_a(sid_b),m_8)) ==> event(SendMsg(alice,bob,stagepack_a(sid_a),m_8)); event(RecvMsg(bob,alice,stagepack_a(sid_b),m_8)) ==> event(SendMsg(alice,c,stagepack_a(sid_a),m_8)) || (event(LeakS(phase0,alice)) && event(LeakM(phase0,alice))) || (event(LeakS(phase0,bob)) && event(LeakM(phase0,bob))); event(RecvMsg(bob,alice,stagepack_a(sid_b),m_8)) ==> event(SendMsg(alice,c,stagepack_a(sid_a),m_8)) || (event(LeakS(phase0,alice)) && event(LeakM(phase0,alice))); event(RecvMsg(bob,alice,stagepack_a(sid_b),m_8)) ==> event(SendMsg(alice,bob,stagepack_a(sid_a),m_8)) || (event(LeakS(phase0,alice)) && event(LeakM(phase0,alice))) || (event(LeakS(phase0,bob)) && event(LeakM(phase0,bob))); event(RecvMsg(bob,alice,stagepack_a(sid_b),m_8)) ==> event(SendMsg(alice,bob,stagepack_a(sid_a),m_8)) || (event(LeakS(phase0,alice)) && event(LeakM(phase0,alice))); not attacker_p1(msg_a(alice,bob,sid_a)); attacker_p1(msg_a(alice,bob,sid_a)) ==> event(LeakS(px,bob)) && event(LeakM(px,bob)); attacker_p1(msg_a(alice,bob,sid_a)) ==> (event(LeakS(phase0,bob)) && event(LeakM(phase0,bob))) || (event(LeakS(px,bob)) && event(LeakM(px,bob)) && event(LeakS(pz,alice)) && event(LeakM(pz,alice))); attacker_p1(msg_a(alice,bob,sid_a)) ==> event(LeakS(phase0,bob)) && event(LeakM(phase0,bob)); not event(RecvEnd(true)) in process 1.
Translating the process into Horn clauses...
Completing...
200 rules inserted. Base: 200 rules (84 with conclusion selected). Queue: 243 rules.
400 rules inserted. Base: 400 rules (92 with conclusion selected). Queue: 86 rules.
600 rules inserted. Base: 597 rules (202 with conclusion selected). Queue: 87 rules.
800 rules inserted. Base: 797 rules (202 with conclusion selected). Queue: 171 rules.
1000 rules inserted. Base: 997 rules (202 with conclusion selected). Queue: 245 rules.
1200 rules inserted. Base: 1197 rules (202 with conclusion selected). Queue: 318 rules.
1400 rules inserted. Base: 1397 rules (202 with conclusion selected). Queue: 382 rules.
1600 rules inserted. Base: 1597 rules (202 with conclusion selected). Queue: 437 rules.
1800 rules inserted. Base: 1797 rules (202 with conclusion selected). Queue: 482 rules.
2000 rules inserted. Base: 1997 rules (202 with conclusion selected). Queue: 525 rules.
2200 rules inserted. Base: 2189 rules (202 with conclusion selected). Queue: 535 rules.
2400 rules inserted. Base: 2368 rules (202 with conclusion selected). Queue: 523 rules.
2600 rules inserted. Base: 2555 rules (202 with conclusion selected). Queue: 513 rules.
2800 rules inserted. Base: 2713 rules (202 with conclusion selected). Queue: 478 rules.
3000 rules inserted. Base: 2853 rules (202 with conclusion selected). Queue: 440 rules.
3200 rules inserted. Base: 2963 rules (202 with conclusion selected). Queue: 381 rules.
3400 rules inserted. Base: 3035 rules (202 with conclusion selected). Queue: 340 rules.
3600 rules inserted. Base: 3185 rules (202 with conclusion selected). Queue: 342 rules.
3800 rules inserted. Base: 3373 rules (202 with conclusion selected). Queue: 370 rules.
4000 rules inserted. Base: 3549 rules (202 with conclusion selected). Queue: 358 rules.
4200 rules inserted. Base: 3717 rules (202 with conclusion selected). Queue: 262 rules.
4400 rules inserted. Base: 3867 rules (202 with conclusion selected). Queue: 176 rules.
4600 rules inserted. Base: 3984 rules (202 with conclusion selected). Queue: 132 rules.
4800 rules inserted. Base: 3970 rules (202 with conclusion selected). Queue: 76 rules.
Starting query event(RecvMsg(bob,alice,stagepack_a(sid_b),m_8)) ==> event(SendMsg(alice,bob,stagepack_a(sid_a),m_8))
RESULT event(RecvMsg(bob,alice,stagepack_a(sid_b),m_8)) ==> event(SendMsg(alice,bob,stagepack_a(sid_a),m_8)) is true.
Starting query event(RecvMsg(bob,alice,stagepack_a(sid_b),m_8)) ==> event(SendMsg(alice,c,stagepack_a(sid_a),m_8)) || (event(LeakS(phase0,alice)) && event(LeakM(phase0,alice))) || (event(LeakS(phase0,bob)) && event(LeakM(phase0,bob)))
RESULT event(RecvMsg(bob,alice,stagepack_a(sid_b),m_8)) ==> event(SendMsg(alice,c,stagepack_a(sid_a),m_8)) || (event(LeakS(phase0,alice)) && event(LeakM(phase0,alice))) || (event(LeakS(phase0,bob)) && event(LeakM(phase0,bob))) is true.
Starting query event(RecvMsg(bob,alice,stagepack_a(sid_b),m_8)) ==> event(SendMsg(alice,c,stagepack_a(sid_a),m_8)) || (event(LeakS(phase0,alice)) && event(LeakM(phase0,alice)))
RESULT event(RecvMsg(bob,alice,stagepack_a(sid_b),m_8)) ==> event(SendMsg(alice,c,stagepack_a(sid_a),m_8)) || (event(LeakS(phase0,alice)) && event(LeakM(phase0,alice))) is true.
Starting query event(RecvMsg(bob,alice,stagepack_a(sid_b),m_8)) ==> event(SendMsg(alice,bob,stagepack_a(sid_a),m_8)) || (event(LeakS(phase0,alice)) && event(LeakM(phase0,alice))) || (event(LeakS(phase0,bob)) && event(LeakM(phase0,bob)))
RESULT event(RecvMsg(bob,alice,stagepack_a(sid_b),m_8)) ==> event(SendMsg(alice,bob,stagepack_a(sid_a),m_8)) || (event(LeakS(phase0,alice)) && event(LeakM(phase0,alice))) || (event(LeakS(phase0,bob)) && event(LeakM(phase0,bob))) is true.
Starting query event(RecvMsg(bob,alice,stagepack_a(sid_b),m_8)) ==> event(SendMsg(alice,bob,stagepack_a(sid_a),m_8)) || (event(LeakS(phase0,alice)) && event(LeakM(phase0,alice)))
RESULT event(RecvMsg(bob,alice,stagepack_a(sid_b),m_8)) ==> event(SendMsg(alice,bob,stagepack_a(sid_a),m_8)) || (event(LeakS(phase0,alice)) && event(LeakM(phase0,alice))) is true.
Starting query not attacker_p1(msg_a(alice,bob,sid_a))
goal reachable: begin(LeakM(phase1,bob)) && begin(LeakS(phase1,bob)) && begin(SendMsg(alice,bob,stagepack_a(sid_5),msg_a(alice,bob,sid_5))) -> attacker_p1(msg_a(alice,bob,sid_5))
Abbreviations:
sid_5 = sid[!1 = @sid]

Derivation:
Abbreviations:
sid_5 = sid[!1 = @sid]

1. Using the function pub the attacker may obtain pub.
attacker(pub).

2. The entry statestore(alice,bob,sid_5,statepack_a(handshakestatepack(symmetricstatepack(cipherstatepack(empty,minnonce),hash(somename,empty),hash(hash(hash(hash(hash(hash(somename,empty),empty),validkey(dhexp_real(key_s(alice),g))),validkey(dhexp_real(key_m(alice),g))),validkey(dhexp_real(key_s(bob),g))),validkey(dhexp_real(key_s(bob),g)))),keypairpack(validkey(dhexp_real(key_s(alice),g)),key_s(alice)),keypairpack(validkey(dhexp_real(key_m(alice),g)),key_m(alice)),keypairpack(empty,empty),validkey(dhexp_real(key_s(bob),g)),validkey(dhexp_real(key_s(bob),g)),empty,empty,true))) may be inserted in a table at insert {74}.
table(statestore(alice,bob,sid_5,statepack_a(handshakestatepack(symmetricstatepack(cipherstatepack(empty,minnonce),hash(somename,empty),hash(hash(hash(hash(hash(hash(somename,empty),empty),validkey(dhexp_real(key_s(alice),g))),validkey(dhexp_real(key_m(alice),g))),validkey(dhexp_real(key_s(bob),g))),validkey(dhexp_real(key_s(bob),g)))),keypairpack(validkey(dhexp_real(key_s(alice),g)),key_s(alice)),keypairpack(validkey(dhexp_real(key_m(alice),g)),key_m(alice)),keypairpack(empty,empty),validkey(dhexp_real(key_s(bob),g)),validkey(dhexp_real(key_s(bob),g)),empty,empty,true)))).

3. The entry statestore(alice,bob,sid_5,statepack_a(handshakestatepack(symmetricstatepack(cipherstatepack(empty,minnonce),hash(somename,empty),hash(hash(hash(hash(hash(hash(somename,empty),empty),validkey(dhexp_real(key_s(alice),g))),validkey(dhexp_real(key_m(alice),g))),validkey(dhexp_real(key_s(bob),g))),validkey(dhexp_real(key_s(bob),g)))),keypairpack(validkey(dhexp_real(key_s(alice),g)),key_s(alice)),keypairpack(validkey(dhexp_real(key_m(alice),g)),key_m(alice)),keypairpack(empty,empty),validkey(dhexp_real(key_s(bob),g)),validkey(dhexp_real(key_s(bob),g)),empty,empty,true))) that may be in a table by 2 may be read at get {249}.
The event SendMsg(alice,bob,stagepack_a(sid_5),msg_a(alice,bob,sid_5)) may be executed at {247}.
So the message concat3(validkey(dhexp_real(key_e(alice,bob,sid_5),g)),empty,encrypt(hmac_hash2(hmac_hash1(hmac_hash1(hmac_hash1(hash(somename,empty),dhexp_real(key_e(alice,bob,sid_5),dhexp_real(key_s(bob),g))),dhexp_real(key_e(alice,bob,sid_5),dhexp_real(key_s(bob),g))),dhexp_real(key_m(alice),dhexp_real(key_s(bob),g))),dhexp_real(key_s(alice),dhexp_real(key_s(bob),g))),minnonce,hash(hash(hash(hash(hash(hash(hash(somename,empty),empty),validkey(dhexp_real(key_s(alice),g))),validkey(dhexp_real(key_m(alice),g))),validkey(dhexp_real(key_s(bob),g))),validkey(dhexp_real(key_s(bob),g))),validkey(dhexp_real(key_e(alice,bob,sid_5),g))),msg_a(alice,bob,sid_5))) may be sent on channel pub at output {248}.
mess(pub,concat3(validkey(dhexp_real(key_e(alice,bob,sid_5),g)),empty,encrypt(hmac_hash2(hmac_hash1(hmac_hash1(hmac_hash1(hash(somename,empty),dhexp_real(key_e(alice,bob,sid_5),dhexp_real(key_s(bob),g))),dhexp_real(key_e(alice,bob,sid_5),dhexp_real(key_s(bob),g))),dhexp_real(key_m(alice),dhexp_real(key_s(bob),g))),dhexp_real(key_s(alice),dhexp_real(key_s(bob),g))),minnonce,hash(hash(hash(hash(hash(hash(hash(somename,empty),empty),validkey(dhexp_real(key_s(alice),g))),validkey(dhexp_real(key_m(alice),g))),validkey(dhexp_real(key_s(bob),g))),validkey(dhexp_real(key_s(bob),g))),validkey(dhexp_real(key_e(alice,bob,sid_5),g))),msg_a(alice,bob,sid_5)))).

4. By 1, the attacker may have the channel pub.
By 3, the message concat3(validkey(dhexp_real(key_e(alice,bob,sid_5),g)),empty,encrypt(hmac_hash2(hmac_hash1(hmac_hash1(hmac_hash1(hash(somename,empty),dhexp_real(key_e(alice,bob,sid_5),dhexp_real(key_s(bob),g))),dhexp_real(key_e(alice,bob,sid_5),dhexp_real(key_s(bob),g))),dhexp_real(key_m(alice),dhexp_real(key_s(bob),g))),dhexp_real(key_s(alice),dhexp_real(key_s(bob),g))),minnonce,hash(hash(hash(hash(hash(hash(hash(somename,empty),empty),validkey(dhexp_real(key_s(alice),g))),validkey(dhexp_real(key_m(alice),g))),validkey(dhexp_real(key_s(bob),g))),validkey(dhexp_real(key_s(bob),g))),validkey(dhexp_real(key_e(alice,bob,sid_5),g))),msg_a(alice,bob,sid_5))) may be sent on this channel.
So the attacker may obtain the message concat3(validkey(dhexp_real(key_e(alice,bob,sid_5),g)),empty,encrypt(hmac_hash2(hmac_hash1(hmac_hash1(hmac_hash1(hash(somename,empty),dhexp_real(key_e(alice,bob,sid_5),dhexp_real(key_s(bob),g))),dhexp_real(key_e(alice,bob,sid_5),dhexp_real(key_s(bob),g))),dhexp_real(key_m(alice),dhexp_real(key_s(bob),g))),dhexp_real(key_s(alice),dhexp_real(key_s(bob),g))),minnonce,hash(hash(hash(hash(hash(hash(hash(somename,empty),empty),validkey(dhexp_real(key_s(alice),g))),validkey(dhexp_real(key_m(alice),g))),validkey(dhexp_real(key_s(bob),g))),validkey(dhexp_real(key_s(bob),g))),validkey(dhexp_real(key_e(alice,bob,sid_5),g))),msg_a(alice,bob,sid_5))) by listening on this channel.
attacker(concat3(validkey(dhexp_real(key_e(alice,bob,sid_5),g)),empty,encrypt(hmac_hash2(hmac_hash1(hmac_hash1(hmac_hash1(hash(somename,empty),dhexp_real(key_e(alice,bob,sid_5),dhexp_real(key_s(bob),g))),dhexp_real(key_e(alice,bob,sid_5),dhexp_real(key_s(bob),g))),dhexp_real(key_m(alice),dhexp_real(key_s(bob),g))),dhexp_real(key_s(alice),dhexp_real(key_s(bob),g))),minnonce,hash(hash(hash(hash(hash(hash(hash(somename,empty),empty),validkey(dhexp_real(key_s(alice),g))),validkey(dhexp_real(key_m(alice),g))),validkey(dhexp_real(key_s(bob),g))),validkey(dhexp_real(key_s(bob),g))),validkey(dhexp_real(key_e(alice,bob,sid_5),g))),msg_a(alice,bob,sid_5)))).

5. By 4, the attacker may know concat3(validkey(dhexp_real(key_e(alice,bob,sid_5),g)),empty,encrypt(hmac_hash2(hmac_hash1(hmac_hash1(hmac_hash1(hash(somename,empty),dhexp_real(key_e(alice,bob,sid_5),dhexp_real(key_s(bob),g))),dhexp_real(key_e(alice,bob,sid_5),dhexp_real(key_s(bob),g))),dhexp_real(key_m(alice),dhexp_real(key_s(bob),g))),dhexp_real(key_s(alice),dhexp_real(key_s(bob),g))),minnonce,hash(hash(hash(hash(hash(hash(hash(somename,empty),empty),validkey(dhexp_real(key_s(alice),g))),validkey(dhexp_real(key_m(alice),g))),validkey(dhexp_real(key_s(bob),g))),validkey(dhexp_real(key_s(bob),g))),validkey(dhexp_real(key_e(alice,bob,sid_5),g))),msg_a(alice,bob,sid_5))).
Using the function 3-proj-concat3 the attacker may obtain encrypt(hmac_hash2(hmac_hash1(hmac_hash1(hmac_hash1(hash(somename,empty),dhexp_real(key_e(alice,bob,sid_5),dhexp_real(key_s(bob),g))),dhexp_real(key_e(alice,bob,sid_5),dhexp_real(key_s(bob),g))),dhexp_real(key_m(alice),dhexp_real(key_s(bob),g))),dhexp_real(key_s(alice),dhexp_real(key_s(bob),g))),minnonce,hash(hash(hash(hash(hash(hash(hash(somename,empty),empty),validkey(dhexp_real(key_s(alice),g))),validkey(dhexp_real(key_m(alice),g))),validkey(dhexp_real(key_s(bob),g))),validkey(dhexp_real(key_s(bob),g))),validkey(dhexp_real(key_e(alice,bob,sid_5),g))),msg_a(alice,bob,sid_5)).
attacker(encrypt(hmac_hash2(hmac_hash1(hmac_hash1(hmac_hash1(hash(somename,empty),dhexp_real(key_e(alice,bob,sid_5),dhexp_real(key_s(bob),g))),dhexp_real(key_e(alice,bob,sid_5),dhexp_real(key_s(bob),g))),dhexp_real(key_m(alice),dhexp_real(key_s(bob),g))),dhexp_real(key_s(alice),dhexp_real(key_s(bob),g))),minnonce,hash(hash(hash(hash(hash(hash(hash(somename,empty),empty),validkey(dhexp_real(key_s(alice),g))),validkey(dhexp_real(key_m(alice),g))),validkey(dhexp_real(key_s(bob),g))),validkey(dhexp_real(key_s(bob),g))),validkey(dhexp_real(key_e(alice,bob,sid_5),g))),msg_a(alice,bob,sid_5))).

6. By 5, the attacker may know encrypt(hmac_hash2(hmac_hash1(hmac_hash1(hmac_hash1(hash(somename,empty),dhexp_real(key_e(alice,bob,sid_5),dhexp_real(key_s(bob),g))),dhexp_real(key_e(alice,bob,sid_5),dhexp_real(key_s(bob),g))),dhexp_real(key_m(alice),dhexp_real(key_s(bob),g))),dhexp_real(key_s(alice),dhexp_real(key_s(bob),g))),minnonce,hash(hash(hash(hash(hash(hash(hash(somename,empty),empty),validkey(dhexp_real(key_s(alice),g))),validkey(dhexp_real(key_m(alice),g))),validkey(dhexp_real(key_s(bob),g))),validkey(dhexp_real(key_s(bob),g))),validkey(dhexp_real(key_e(alice,bob,sid_5),g))),msg_a(alice,bob,sid_5)).
So the attacker may know encrypt(hmac_hash2(hmac_hash1(hmac_hash1(hmac_hash1(hash(somename,empty),dhexp_real(key_e(alice,bob,sid_5),dhexp_real(key_s(bob),g))),dhexp_real(key_e(alice,bob,sid_5),dhexp_real(key_s(bob),g))),dhexp_real(key_m(alice),dhexp_real(key_s(bob),g))),dhexp_real(key_s(alice),dhexp_real(key_s(bob),g))),minnonce,hash(hash(hash(hash(hash(hash(hash(somename,empty),empty),validkey(dhexp_real(key_s(alice),g))),validkey(dhexp_real(key_m(alice),g))),validkey(dhexp_real(key_s(bob),g))),validkey(dhexp_real(key_s(bob),g))),validkey(dhexp_real(key_e(alice,bob,sid_5),g))),msg_a(alice,bob,sid_5)) in phase 1.
attacker_p1(encrypt(hmac_hash2(hmac_hash1(hmac_hash1(hmac_hash1(hash(somename,empty),dhexp_real(key_e(alice,bob,sid_5),dhexp_real(key_s(bob),g))),dhexp_real(key_e(alice,bob,sid_5),dhexp_real(key_s(bob),g))),dhexp_real(key_m(alice),dhexp_real(key_s(bob),g))),dhexp_real(key_s(alice),dhexp_real(key_s(bob),g))),minnonce,hash(hash(hash(hash(hash(hash(hash(somename,empty),empty),validkey(dhexp_real(key_s(alice),g))),validkey(dhexp_real(key_m(alice),g))),validkey(dhexp_real(key_s(bob),g))),validkey(dhexp_real(key_s(bob),g))),validkey(dhexp_real(key_e(alice,bob,sid_5),g))),msg_a(alice,bob,sid_5))).

7. By 4, the attacker may know concat3(validkey(dhexp_real(key_e(alice,bob,sid_5),g)),empty,encrypt(hmac_hash2(hmac_hash1(hmac_hash1(hmac_hash1(hash(somename,empty),dhexp_real(key_e(alice,bob,sid_5),dhexp_real(key_s(bob),g))),dhexp_real(key_e(alice,bob,sid_5),dhexp_real(key_s(bob),g))),dhexp_real(key_m(alice),dhexp_real(key_s(bob),g))),dhexp_real(key_s(alice),dhexp_real(key_s(bob),g))),minnonce,hash(hash(hash(hash(hash(hash(hash(somename,empty),empty),validkey(dhexp_real(key_s(alice),g))),validkey(dhexp_real(key_m(alice),g))),validkey(dhexp_real(key_s(bob),g))),validkey(dhexp_real(key_s(bob),g))),validkey(dhexp_real(key_e(alice,bob,sid_5),g))),msg_a(alice,bob,sid_5))).
Using the function 1-proj-concat3 the attacker may obtain validkey(dhexp_real(key_e(alice,bob,sid_5),g)).
attacker(validkey(dhexp_real(key_e(alice,bob,sid_5),g))).

8. The message (validkey(dhexp_real(key_s(bob),g)),validkey(dhexp_real(key_m(bob),g))) may be sent on channel pub at output {521}.
mess(pub,(validkey(dhexp_real(key_s(bob),g)),validkey(dhexp_real(key_m(bob),g)))).

9. By 1, the attacker may have the channel pub.
By 8, the message (validkey(dhexp_real(key_s(bob),g)),validkey(dhexp_real(key_m(bob),g))) may be sent on this channel.
So the attacker may obtain the message (validkey(dhexp_real(key_s(bob),g)),validkey(dhexp_real(key_m(bob),g))) by listening on this channel.
attacker((validkey(dhexp_real(key_s(bob),g)),validkey(dhexp_real(key_m(bob),g)))).

10. By 9, the attacker may know (validkey(dhexp_real(key_s(bob),g)),validkey(dhexp_real(key_m(bob),g))).
Using the function 1-proj-2-tuple the attacker may obtain validkey(dhexp_real(key_s(bob),g)).
attacker(validkey(dhexp_real(key_s(bob),g))).

11. The message (validkey(dhexp_real(key_s(alice),g)),validkey(dhexp_real(key_m(alice),g))) may be sent on channel pub at output {15}.
mess(pub,(validkey(dhexp_real(key_s(alice),g)),validkey(dhexp_real(key_m(alice),g)))).

12. By 1, the attacker may have the channel pub.
By 11, the message (validkey(dhexp_real(key_s(alice),g)),validkey(dhexp_real(key_m(alice),g))) may be sent on this channel.
So the attacker may obtain the message (validkey(dhexp_real(key_s(alice),g)),validkey(dhexp_real(key_m(alice),g))) by listening on this channel.
attacker((validkey(dhexp_real(key_s(alice),g)),validkey(dhexp_real(key_m(alice),g)))).

13. By 12, the attacker may know (validkey(dhexp_real(key_s(alice),g)),validkey(dhexp_real(key_m(alice),g))).
Using the function 2-proj-2-tuple the attacker may obtain validkey(dhexp_real(key_m(alice),g)).
attacker(validkey(dhexp_real(key_m(alice),g))).

14. By 12, the attacker may know (validkey(dhexp_real(key_s(alice),g)),validkey(dhexp_real(key_m(alice),g))).
Using the function 1-proj-2-tuple the attacker may obtain validkey(dhexp_real(key_s(alice),g)).
attacker(validkey(dhexp_real(key_s(alice),g))).

15. Using the function empty the attacker may obtain empty.
attacker(empty).

16. Using the function somename the attacker may obtain somename.
attacker(somename).

17. By 16, the attacker may know somename.
By 15, the attacker may know empty.
Using the function hash the attacker may obtain hash(somename,empty).
attacker(hash(somename,empty)).

18. By 17, the attacker may know hash(somename,empty).
By 15, the attacker may know empty.
Using the function hash the attacker may obtain hash(hash(somename,empty),empty).
attacker(hash(hash(somename,empty),empty)).

19. By 18, the attacker may know hash(hash(somename,empty),empty).
By 14, the attacker may know validkey(dhexp_real(key_s(alice),g)).
Using the function hash the attacker may obtain hash(hash(hash(somename,empty),empty),validkey(dhexp_real(key_s(alice),g))).
attacker(hash(hash(hash(somename,empty),empty),validkey(dhexp_real(key_s(alice),g)))).

20. By 19, the attacker may know hash(hash(hash(somename,empty),empty),validkey(dhexp_real(key_s(alice),g))).
By 13, the attacker may know validkey(dhexp_real(key_m(alice),g)).
Using the function hash the attacker may obtain hash(hash(hash(hash(somename,empty),empty),validkey(dhexp_real(key_s(alice),g))),validkey(dhexp_real(key_m(alice),g))).
attacker(hash(hash(hash(hash(somename,empty),empty),validkey(dhexp_real(key_s(alice),g))),validkey(dhexp_real(key_m(alice),g)))).

21. By 20, the attacker may know hash(hash(hash(hash(somename,empty),empty),validkey(dhexp_real(key_s(alice),g))),validkey(dhexp_real(key_m(alice),g))).
By 10, the attacker may know validkey(dhexp_real(key_s(bob),g)).
Using the function hash the attacker may obtain hash(hash(hash(hash(hash(somename,empty),empty),validkey(dhexp_real(key_s(alice),g))),validkey(dhexp_real(key_m(alice),g))),validkey(dhexp_real(key_s(bob),g))).
attacker(hash(hash(hash(hash(hash(somename,empty),empty),validkey(dhexp_real(key_s(alice),g))),validkey(dhexp_real(key_m(alice),g))),validkey(dhexp_real(key_s(bob),g)))).

22. By 21, the attacker may know hash(hash(hash(hash(hash(somename,empty),empty),validkey(dhexp_real(key_s(alice),g))),validkey(dhexp_real(key_m(alice),g))),validkey(dhexp_real(key_s(bob),g))).
By 10, the attacker may know validkey(dhexp_real(key_s(bob),g)).
Using the function hash the attacker may obtain hash(hash(hash(hash(hash(hash(somename,empty),empty),validkey(dhexp_real(key_s(alice),g))),validkey(dhexp_real(key_m(alice),g))),validkey(dhexp_real(key_s(bob),g))),validkey(dhexp_real(key_s(bob),g))).
attacker(hash(hash(hash(hash(hash(hash(somename,empty),empty),validkey(dhexp_real(key_s(alice),g))),validkey(dhexp_real(key_m(alice),g))),validkey(dhexp_real(key_s(bob),g))),validkey(dhexp_real(key_s(bob),g)))).

23. By 22, the attacker may know hash(hash(hash(hash(hash(hash(somename,empty),empty),validkey(dhexp_real(key_s(alice),g))),validkey(dhexp_real(key_m(alice),g))),validkey(dhexp_real(key_s(bob),g))),validkey(dhexp_real(key_s(bob),g))).
By 7, the attacker may know validkey(dhexp_real(key_e(alice,bob,sid_5),g)).
Using the function hash the attacker may obtain hash(hash(hash(hash(hash(hash(hash(somename,empty),empty),validkey(dhexp_real(key_s(alice),g))),validkey(dhexp_real(key_m(alice),g))),validkey(dhexp_real(key_s(bob),g))),validkey(dhexp_real(key_s(bob),g))),validkey(dhexp_real(key_e(alice,bob,sid_5),g))).
attacker(hash(hash(hash(hash(hash(hash(hash(somename,empty),empty),validkey(dhexp_real(key_s(alice),g))),validkey(dhexp_real(key_m(alice),g))),validkey(dhexp_real(key_s(bob),g))),validkey(dhexp_real(key_s(bob),g))),validkey(dhexp_real(key_e(alice,bob,sid_5),g)))).

24. By 23, the attacker may know hash(hash(hash(hash(hash(hash(hash(somename,empty),empty),validkey(dhexp_real(key_s(alice),g))),validkey(dhexp_real(key_m(alice),g))),validkey(dhexp_real(key_s(bob),g))),validkey(dhexp_real(key_s(bob),g))),validkey(dhexp_real(key_e(alice,bob,sid_5),g))).
So the attacker may know hash(hash(hash(hash(hash(hash(hash(somename,empty),empty),validkey(dhexp_real(key_s(alice),g))),validkey(dhexp_real(key_m(alice),g))),validkey(dhexp_real(key_s(bob),g))),validkey(dhexp_real(key_s(bob),g))),validkey(dhexp_real(key_e(alice,bob,sid_5),g))) in phase 1.
attacker_p1(hash(hash(hash(hash(hash(hash(hash(somename,empty),empty),validkey(dhexp_real(key_s(alice),g))),validkey(dhexp_real(key_m(alice),g))),validkey(dhexp_real(key_s(bob),g))),validkey(dhexp_real(key_s(bob),g))),validkey(dhexp_real(key_e(alice,bob,sid_5),g)))).

25. Using the function minnonce the attacker may obtain minnonce in phase 1.
attacker_p1(minnonce).

26. By 14, the attacker may know validkey(dhexp_real(key_s(alice),g)).
So the attacker may know validkey(dhexp_real(key_s(alice),g)) in phase 1.
attacker_p1(validkey(dhexp_real(key_s(alice),g))).

27. Using the function pub the attacker may obtain pub in phase 1.
attacker_p1(pub).

28. The event LeakS(phase1,bob) may be executed at {763}.
The event LeakM(phase1,bob) may be executed at {764}.
So the message (key_s(bob),key_m(bob)) may be sent on channel pub in phase 1 at output {765}.
mess_p1(pub,(key_s(bob),key_m(bob))).

29. By 27, the attacker may have the channel pub in phase 1.
By 28, the message (key_s(bob),key_m(bob)) in phase 1 may be sent on this channel.
So the attacker may obtain the message (key_s(bob),key_m(bob)) in phase 1 by listening on this channel.
attacker_p1((key_s(bob),key_m(bob))).

30. By 29, the attacker may know (key_s(bob),key_m(bob)) in phase 1.
Using the function 1-proj-2-tuple the attacker may obtain key_s(bob) in phase 1.
attacker_p1(key_s(bob)).

31. By 30, the attacker may know key_s(bob) in phase 1.
By 26, the attacker may know validkey(dhexp_real(key_s(alice),g)) in phase 1.
Using the function dhexp the attacker may obtain dhexp_real(key_s(alice),dhexp_real(key_s(bob),g)) in phase 1.
attacker_p1(dhexp_real(key_s(alice),dhexp_real(key_s(bob),g))).

32. By 13, the attacker may know validkey(dhexp_real(key_m(alice),g)).
So the attacker may know validkey(dhexp_real(key_m(alice),g)) in phase 1.
attacker_p1(validkey(dhexp_real(key_m(alice),g))).

33. By 30, the attacker may know key_s(bob) in phase 1.
By 32, the attacker may know validkey(dhexp_real(key_m(alice),g)) in phase 1.
Using the function dhexp the attacker may obtain dhexp_real(key_m(alice),dhexp_real(key_s(bob),g)) in phase 1.
attacker_p1(dhexp_real(key_m(alice),dhexp_real(key_s(bob),g))).

34. By 7, the attacker may know validkey(dhexp_real(key_e(alice,bob,sid_5),g)).
So the attacker may know validkey(dhexp_real(key_e(alice,bob,sid_5),g)) in phase 1.
attacker_p1(validkey(dhexp_real(key_e(alice,bob,sid_5),g))).

35. By 30, the attacker may know key_s(bob) in phase 1.
By 34, the attacker may know validkey(dhexp_real(key_e(alice,bob,sid_5),g)) in phase 1.
Using the function dhexp the attacker may obtain dhexp_real(key_e(alice,bob,sid_5),dhexp_real(key_s(bob),g)) in phase 1.
attacker_p1(dhexp_real(key_e(alice,bob,sid_5),dhexp_real(key_s(bob),g))).

36. Using the function empty the attacker may obtain empty in phase 1.
attacker_p1(empty).

37. Using the function somename the attacker may obtain somename in phase 1.
attacker_p1(somename).

38. By 37, the attacker may know somename in phase 1.
By 36, the attacker may know empty in phase 1.
Using the function hash the attacker may obtain hash(somename,empty) in phase 1.
attacker_p1(hash(somename,empty)).

39. By 38, the attacker may know hash(somename,empty) in phase 1.
By 35, the attacker may know dhexp_real(key_e(alice,bob,sid_5),dhexp_real(key_s(bob),g)) in phase 1.
Using the function hmac_hash1 the attacker may obtain hmac_hash1(hash(somename,empty),dhexp_real(key_e(alice,bob,sid_5),dhexp_real(key_s(bob),g))) in phase 1.
attacker_p1(hmac_hash1(hash(somename,empty),dhexp_real(key_e(alice,bob,sid_5),dhexp_real(key_s(bob),g)))).

40. By 39, the attacker may know hmac_hash1(hash(somename,empty),dhexp_real(key_e(alice,bob,sid_5),dhexp_real(key_s(bob),g))) in phase 1.
By 35, the attacker may know dhexp_real(key_e(alice,bob,sid_5),dhexp_real(key_s(bob),g)) in phase 1.
Using the function hmac_hash1 the attacker may obtain hmac_hash1(hmac_hash1(hash(somename,empty),dhexp_real(key_e(alice,bob,sid_5),dhexp_real(key_s(bob),g))),dhexp_real(key_e(alice,bob,sid_5),dhexp_real(key_s(bob),g))) in phase 1.
attacker_p1(hmac_hash1(hmac_hash1(hash(somename,empty),dhexp_real(key_e(alice,bob,sid_5),dhexp_real(key_s(bob),g))),dhexp_real(key_e(alice,bob,sid_5),dhexp_real(key_s(bob),g)))).

41. By 40, the attacker may know hmac_hash1(hmac_hash1(hash(somename,empty),dhexp_real(key_e(alice,bob,sid_5),dhexp_real(key_s(bob),g))),dhexp_real(key_e(alice,bob,sid_5),dhexp_real(key_s(bob),g))) in phase 1.
By 33, the attacker may know dhexp_real(key_m(alice),dhexp_real(key_s(bob),g)) in phase 1.
Using the function hmac_hash1 the attacker may obtain hmac_hash1(hmac_hash1(hmac_hash1(hash(somename,empty),dhexp_real(key_e(alice,bob,sid_5),dhexp_real(key_s(bob),g))),dhexp_real(key_e(alice,bob,sid_5),dhexp_real(key_s(bob),g))),dhexp_real(key_m(alice),dhexp_real(key_s(bob),g))) in phase 1.
attacker_p1(hmac_hash1(hmac_hash1(hmac_hash1(hash(somename,empty),dhexp_real(key_e(alice,bob,sid_5),dhexp_real(key_s(bob),g))),dhexp_real(key_e(alice,bob,sid_5),dhexp_real(key_s(bob),g))),dhexp_real(key_m(alice),dhexp_real(key_s(bob),g)))).

42. By 41, the attacker may know hmac_hash1(hmac_hash1(hmac_hash1(hash(somename,empty),dhexp_real(key_e(alice,bob,sid_5),dhexp_real(key_s(bob),g))),dhexp_real(key_e(alice,bob,sid_5),dhexp_real(key_s(bob),g))),dhexp_real(key_m(alice),dhexp_real(key_s(bob),g))) in phase 1.
By 31, the attacker may know dhexp_real(key_s(alice),dhexp_real(key_s(bob),g)) in phase 1.
Using the function hmac_hash2 the attacker may obtain hmac_hash2(hmac_hash1(hmac_hash1(hmac_hash1(hash(somename,empty),dhexp_real(key_e(alice,bob,sid_5),dhexp_real(key_s(bob),g))),dhexp_real(key_e(alice,bob,sid_5),dhexp_real(key_s(bob),g))),dhexp_real(key_m(alice),dhexp_real(key_s(bob),g))),dhexp_real(key_s(alice),dhexp_real(key_s(bob),g))) in phase 1.
attacker_p1(hmac_hash2(hmac_hash1(hmac_hash1(hmac_hash1(hash(somename,empty),dhexp_real(key_e(alice,bob,sid_5),dhexp_real(key_s(bob),g))),dhexp_real(key_e(alice,bob,sid_5),dhexp_real(key_s(bob),g))),dhexp_real(key_m(alice),dhexp_real(key_s(bob),g))),dhexp_real(key_s(alice),dhexp_real(key_s(bob),g)))).

43. By 42, the attacker may know hmac_hash2(hmac_hash1(hmac_hash1(hmac_hash1(hash(somename,empty),dhexp_real(key_e(alice,bob,sid_5),dhexp_real(key_s(bob),g))),dhexp_real(key_e(alice,bob,sid_5),dhexp_real(key_s(bob),g))),dhexp_real(key_m(alice),dhexp_real(key_s(bob),g))),dhexp_real(key_s(alice),dhexp_real(key_s(bob),g))) in phase 1.
By 25, the attacker may know minnonce in phase 1.
By 24, the attacker may know hash(hash(hash(hash(hash(hash(hash(somename,empty),empty),validkey(dhexp_real(key_s(alice),g))),validkey(dhexp_real(key_m(alice),g))),validkey(dhexp_real(key_s(bob),g))),validkey(dhexp_real(key_s(bob),g))),validkey(dhexp_real(key_e(alice,bob,sid_5),g))) in phase 1.
By 6, the attacker may know encrypt(hmac_hash2(hmac_hash1(hmac_hash1(hmac_hash1(hash(somename,empty),dhexp_real(key_e(alice,bob,sid_5),dhexp_real(key_s(bob),g))),dhexp_real(key_e(alice,bob,sid_5),dhexp_real(key_s(bob),g))),dhexp_real(key_m(alice),dhexp_real(key_s(bob),g))),dhexp_real(key_s(alice),dhexp_real(key_s(bob),g))),minnonce,hash(hash(hash(hash(hash(hash(hash(somename,empty),empty),validkey(dhexp_real(key_s(alice),g))),validkey(dhexp_real(key_m(alice),g))),validkey(dhexp_real(key_s(bob),g))),validkey(dhexp_real(key_s(bob),g))),validkey(dhexp_real(key_e(alice,bob,sid_5),g))),msg_a(alice,bob,sid_5)) in phase 1.
Using the function decrypt the attacker may obtain aeadpack(true,hash(hash(hash(hash(hash(hash(hash(somename,empty),empty),validkey(dhexp_real(key_s(alice),g))),validkey(dhexp_real(key_m(alice),g))),validkey(dhexp_real(key_s(bob),g))),validkey(dhexp_real(key_s(bob),g))),validkey(dhexp_real(key_e(alice,bob,sid_5),g))),msg_a(alice,bob,sid_5)) in phase 1.
attacker_p1(aeadpack(true,hash(hash(hash(hash(hash(hash(hash(somename,empty),empty),validkey(dhexp_real(key_s(alice),g))),validkey(dhexp_real(key_m(alice),g))),validkey(dhexp_real(key_s(bob),g))),validkey(dhexp_real(key_s(bob),g))),validkey(dhexp_real(key_e(alice,bob,sid_5),g))),msg_a(alice,bob,sid_5))).

44. By 43, the attacker may know aeadpack(true,hash(hash(hash(hash(hash(hash(hash(somename,empty),empty),validkey(dhexp_real(key_s(alice),g))),validkey(dhexp_real(key_m(alice),g))),validkey(dhexp_real(key_s(bob),g))),validkey(dhexp_real(key_s(bob),g))),validkey(dhexp_real(key_e(alice,bob,sid_5),g))),msg_a(alice,bob,sid_5)) in phase 1.
Using the function 3-proj-aeadpack the attacker may obtain msg_a(alice,bob,sid_5) in phase 1.
attacker_p1(msg_a(alice,bob,sid_5)).

45. By 44, attacker_p1(msg_a(alice,bob,sid_5)).
The goal is reached, represented in the following fact:
attacker_p1(msg_a(alice,bob,sid_5)).


RESULT not attacker_p1(msg_a(alice,bob,sid_a)) cannot be proved.
Starting query attacker_p1(msg_a(alice,bob,sid_a)) ==> event(LeakS(px,bob)) && event(LeakM(px,bob))
goal reachable: begin(LeakM(phase1,bob)) && begin(LeakS(phase1,bob)) && begin(SendMsg(alice,bob,stagepack_a(sid_5),msg_a(alice,bob,sid_5))) -> attacker_p1(msg_a(alice,bob,sid_5))
Abbreviations:
sid_5 = sid[!1 = @sid]
goal reachable: begin(LeakM(phase0,bob)) && begin(LeakS(phase0,bob)) && begin(SendMsg(alice,bob,stagepack_a(sid_5),msg_a(alice,bob,sid_5))) -> attacker_p1(msg_a(alice,bob,sid_5))
Abbreviations:
sid_5 = sid[!1 = @sid]
RESULT attacker_p1(msg_a(alice,bob,sid_a)) ==> event(LeakS(px,bob)) && event(LeakM(px,bob)) is true.
Starting query attacker_p1(msg_a(alice,bob,sid_a)) ==> (event(LeakS(phase0,bob)) && event(LeakM(phase0,bob))) || (event(LeakS(px,bob)) && event(LeakM(px,bob)) && event(LeakS(pz,alice)) && event(LeakM(pz,alice)))
goal reachable: begin(LeakM(phase1,bob)) && begin(LeakS(phase1,bob)) && begin(SendMsg(alice,bob,stagepack_a(sid_5),msg_a(alice,bob,sid_5))) -> attacker_p1(msg_a(alice,bob,sid_5))
Abbreviations:
sid_5 = sid[!1 = @sid]

Derivation:
Abbreviations:
sid_5 = sid[!1 = @sid]

1. Using the function pub the attacker may obtain pub.
attacker(pub).

2. The entry statestore(alice,bob,sid_5,statepack_a(handshakestatepack(symmetricstatepack(cipherstatepack(empty,minnonce),hash(somename,empty),hash(hash(hash(hash(hash(hash(somename,empty),empty),validkey(dhexp_real(key_s(alice),g))),validkey(dhexp_real(key_m(alice),g))),validkey(dhexp_real(key_s(bob),g))),validkey(dhexp_real(key_s(bob),g)))),keypairpack(validkey(dhexp_real(key_s(alice),g)),key_s(alice)),keypairpack(validkey(dhexp_real(key_m(alice),g)),key_m(alice)),keypairpack(empty,empty),validkey(dhexp_real(key_s(bob),g)),validkey(dhexp_real(key_s(bob),g)),empty,empty,true))) may be inserted in a table at insert {74}.
table(statestore(alice,bob,sid_5,statepack_a(handshakestatepack(symmetricstatepack(cipherstatepack(empty,minnonce),hash(somename,empty),hash(hash(hash(hash(hash(hash(somename,empty),empty),validkey(dhexp_real(key_s(alice),g))),validkey(dhexp_real(key_m(alice),g))),validkey(dhexp_real(key_s(bob),g))),validkey(dhexp_real(key_s(bob),g)))),keypairpack(validkey(dhexp_real(key_s(alice),g)),key_s(alice)),keypairpack(validkey(dhexp_real(key_m(alice),g)),key_m(alice)),keypairpack(empty,empty),validkey(dhexp_real(key_s(bob),g)),validkey(dhexp_real(key_s(bob),g)),empty,empty,true)))).

3. The entry statestore(alice,bob,sid_5,statepack_a(handshakestatepack(symmetricstatepack(cipherstatepack(empty,minnonce),hash(somename,empty),hash(hash(hash(hash(hash(hash(somename,empty),empty),validkey(dhexp_real(key_s(alice),g))),validkey(dhexp_real(key_m(alice),g))),validkey(dhexp_real(key_s(bob),g))),validkey(dhexp_real(key_s(bob),g)))),keypairpack(validkey(dhexp_real(key_s(alice),g)),key_s(alice)),keypairpack(validkey(dhexp_real(key_m(alice),g)),key_m(alice)),keypairpack(empty,empty),validkey(dhexp_real(key_s(bob),g)),validkey(dhexp_real(key_s(bob),g)),empty,empty,true))) that may be in a table by 2 may be read at get {249}.
The event SendMsg(alice,bob,stagepack_a(sid_5),msg_a(alice,bob,sid_5)) may be executed at {247}.
So the message concat3(validkey(dhexp_real(key_e(alice,bob,sid_5),g)),empty,encrypt(hmac_hash2(hmac_hash1(hmac_hash1(hmac_hash1(hash(somename,empty),dhexp_real(key_e(alice,bob,sid_5),dhexp_real(key_s(bob),g))),dhexp_real(key_e(alice,bob,sid_5),dhexp_real(key_s(bob),g))),dhexp_real(key_m(alice),dhexp_real(key_s(bob),g))),dhexp_real(key_s(alice),dhexp_real(key_s(bob),g))),minnonce,hash(hash(hash(hash(hash(hash(hash(somename,empty),empty),validkey(dhexp_real(key_s(alice),g))),validkey(dhexp_real(key_m(alice),g))),validkey(dhexp_real(key_s(bob),g))),validkey(dhexp_real(key_s(bob),g))),validkey(dhexp_real(key_e(alice,bob,sid_5),g))),msg_a(alice,bob,sid_5))) may be sent on channel pub at output {248}.
mess(pub,concat3(validkey(dhexp_real(key_e(alice,bob,sid_5),g)),empty,encrypt(hmac_hash2(hmac_hash1(hmac_hash1(hmac_hash1(hash(somename,empty),dhexp_real(key_e(alice,bob,sid_5),dhexp_real(key_s(bob),g))),dhexp_real(key_e(alice,bob,sid_5),dhexp_real(key_s(bob),g))),dhexp_real(key_m(alice),dhexp_real(key_s(bob),g))),dhexp_real(key_s(alice),dhexp_real(key_s(bob),g))),minnonce,hash(hash(hash(hash(hash(hash(hash(somename,empty),empty),validkey(dhexp_real(key_s(alice),g))),validkey(dhexp_real(key_m(alice),g))),validkey(dhexp_real(key_s(bob),g))),validkey(dhexp_real(key_s(bob),g))),validkey(dhexp_real(key_e(alice,bob,sid_5),g))),msg_a(alice,bob,sid_5)))).

4. By 1, the attacker may have the channel pub.
By 3, the message concat3(validkey(dhexp_real(key_e(alice,bob,sid_5),g)),empty,encrypt(hmac_hash2(hmac_hash1(hmac_hash1(hmac_hash1(hash(somename,empty),dhexp_real(key_e(alice,bob,sid_5),dhexp_real(key_s(bob),g))),dhexp_real(key_e(alice,bob,sid_5),dhexp_real(key_s(bob),g))),dhexp_real(key_m(alice),dhexp_real(key_s(bob),g))),dhexp_real(key_s(alice),dhexp_real(key_s(bob),g))),minnonce,hash(hash(hash(hash(hash(hash(hash(somename,empty),empty),validkey(dhexp_real(key_s(alice),g))),validkey(dhexp_real(key_m(alice),g))),validkey(dhexp_real(key_s(bob),g))),validkey(dhexp_real(key_s(bob),g))),validkey(dhexp_real(key_e(alice,bob,sid_5),g))),msg_a(alice,bob,sid_5))) may be sent on this channel.
So the attacker may obtain the message concat3(validkey(dhexp_real(key_e(alice,bob,sid_5),g)),empty,encrypt(hmac_hash2(hmac_hash1(hmac_hash1(hmac_hash1(hash(somename,empty),dhexp_real(key_e(alice,bob,sid_5),dhexp_real(key_s(bob),g))),dhexp_real(key_e(alice,bob,sid_5),dhexp_real(key_s(bob),g))),dhexp_real(key_m(alice),dhexp_real(key_s(bob),g))),dhexp_real(key_s(alice),dhexp_real(key_s(bob),g))),minnonce,hash(hash(hash(hash(hash(hash(hash(somename,empty),empty),validkey(dhexp_real(key_s(alice),g))),validkey(dhexp_real(key_m(alice),g))),validkey(dhexp_real(key_s(bob),g))),validkey(dhexp_real(key_s(bob),g))),validkey(dhexp_real(key_e(alice,bob,sid_5),g))),msg_a(alice,bob,sid_5))) by listening on this channel.
attacker(concat3(validkey(dhexp_real(key_e(alice,bob,sid_5),g)),empty,encrypt(hmac_hash2(hmac_hash1(hmac_hash1(hmac_hash1(hash(somename,empty),dhexp_real(key_e(alice,bob,sid_5),dhexp_real(key_s(bob),g))),dhexp_real(key_e(alice,bob,sid_5),dhexp_real(key_s(bob),g))),dhexp_real(key_m(alice),dhexp_real(key_s(bob),g))),dhexp_real(key_s(alice),dhexp_real(key_s(bob),g))),minnonce,hash(hash(hash(hash(hash(hash(hash(somename,empty),empty),validkey(dhexp_real(key_s(alice),g))),validkey(dhexp_real(key_m(alice),g))),validkey(dhexp_real(key_s(bob),g))),validkey(dhexp_real(key_s(bob),g))),validkey(dhexp_real(key_e(alice,bob,sid_5),g))),msg_a(alice,bob,sid_5)))).

5. By 4, the attacker may know concat3(validkey(dhexp_real(key_e(alice,bob,sid_5),g)),empty,encrypt(hmac_hash2(hmac_hash1(hmac_hash1(hmac_hash1(hash(somename,empty),dhexp_real(key_e(alice,bob,sid_5),dhexp_real(key_s(bob),g))),dhexp_real(key_e(alice,bob,sid_5),dhexp_real(key_s(bob),g))),dhexp_real(key_m(alice),dhexp_real(key_s(bob),g))),dhexp_real(key_s(alice),dhexp_real(key_s(bob),g))),minnonce,hash(hash(hash(hash(hash(hash(hash(somename,empty),empty),validkey(dhexp_real(key_s(alice),g))),validkey(dhexp_real(key_m(alice),g))),validkey(dhexp_real(key_s(bob),g))),validkey(dhexp_real(key_s(bob),g))),validkey(dhexp_real(key_e(alice,bob,sid_5),g))),msg_a(alice,bob,sid_5))).
Using the function 3-proj-concat3 the attacker may obtain encrypt(hmac_hash2(hmac_hash1(hmac_hash1(hmac_hash1(hash(somename,empty),dhexp_real(key_e(alice,bob,sid_5),dhexp_real(key_s(bob),g))),dhexp_real(key_e(alice,bob,sid_5),dhexp_real(key_s(bob),g))),dhexp_real(key_m(alice),dhexp_real(key_s(bob),g))),dhexp_real(key_s(alice),dhexp_real(key_s(bob),g))),minnonce,hash(hash(hash(hash(hash(hash(hash(somename,empty),empty),validkey(dhexp_real(key_s(alice),g))),validkey(dhexp_real(key_m(alice),g))),validkey(dhexp_real(key_s(bob),g))),validkey(dhexp_real(key_s(bob),g))),validkey(dhexp_real(key_e(alice,bob,sid_5),g))),msg_a(alice,bob,sid_5)).
attacker(encrypt(hmac_hash2(hmac_hash1(hmac_hash1(hmac_hash1(hash(somename,empty),dhexp_real(key_e(alice,bob,sid_5),dhexp_real(key_s(bob),g))),dhexp_real(key_e(alice,bob,sid_5),dhexp_real(key_s(bob),g))),dhexp_real(key_m(alice),dhexp_real(key_s(bob),g))),dhexp_real(key_s(alice),dhexp_real(key_s(bob),g))),minnonce,hash(hash(hash(hash(hash(hash(hash(somename,empty),empty),validkey(dhexp_real(key_s(alice),g))),validkey(dhexp_real(key_m(alice),g))),validkey(dhexp_real(key_s(bob),g))),validkey(dhexp_real(key_s(bob),g))),validkey(dhexp_real(key_e(alice,bob,sid_5),g))),msg_a(alice,bob,sid_5))).

6. By 5, the attacker may know encrypt(hmac_hash2(hmac_hash1(hmac_hash1(hmac_hash1(hash(somename,empty),dhexp_real(key_e(alice,bob,sid_5),dhexp_real(key_s(bob),g))),dhexp_real(key_e(alice,bob,sid_5),dhexp_real(key_s(bob),g))),dhexp_real(key_m(alice),dhexp_real(key_s(bob),g))),dhexp_real(key_s(alice),dhexp_real(key_s(bob),g))),minnonce,hash(hash(hash(hash(hash(hash(hash(somename,empty),empty),validkey(dhexp_real(key_s(alice),g))),validkey(dhexp_real(key_m(alice),g))),validkey(dhexp_real(key_s(bob),g))),validkey(dhexp_real(key_s(bob),g))),validkey(dhexp_real(key_e(alice,bob,sid_5),g))),msg_a(alice,bob,sid_5)).
So the attacker may know encrypt(hmac_hash2(hmac_hash1(hmac_hash1(hmac_hash1(hash(somename,empty),dhexp_real(key_e(alice,bob,sid_5),dhexp_real(key_s(bob),g))),dhexp_real(key_e(alice,bob,sid_5),dhexp_real(key_s(bob),g))),dhexp_real(key_m(alice),dhexp_real(key_s(bob),g))),dhexp_real(key_s(alice),dhexp_real(key_s(bob),g))),minnonce,hash(hash(hash(hash(hash(hash(hash(somename,empty),empty),validkey(dhexp_real(key_s(alice),g))),validkey(dhexp_real(key_m(alice),g))),validkey(dhexp_real(key_s(bob),g))),validkey(dhexp_real(key_s(bob),g))),validkey(dhexp_real(key_e(alice,bob,sid_5),g))),msg_a(alice,bob,sid_5)) in phase 1.
attacker_p1(encrypt(hmac_hash2(hmac_hash1(hmac_hash1(hmac_hash1(hash(somename,empty),dhexp_real(key_e(alice,bob,sid_5),dhexp_real(key_s(bob),g))),dhexp_real(key_e(alice,bob,sid_5),dhexp_real(key_s(bob),g))),dhexp_real(key_m(alice),dhexp_real(key_s(bob),g))),dhexp_real(key_s(alice),dhexp_real(key_s(bob),g))),minnonce,hash(hash(hash(hash(hash(hash(hash(somename,empty),empty),validkey(dhexp_real(key_s(alice),g))),validkey(dhexp_real(key_m(alice),g))),validkey(dhexp_real(key_s(bob),g))),validkey(dhexp_real(key_s(bob),g))),validkey(dhexp_real(key_e(alice,bob,sid_5),g))),msg_a(alice,bob,sid_5))).

7. By 4, the attacker may know concat3(validkey(dhexp_real(key_e(alice,bob,sid_5),g)),empty,encrypt(hmac_hash2(hmac_hash1(hmac_hash1(hmac_hash1(hash(somename,empty),dhexp_real(key_e(alice,bob,sid_5),dhexp_real(key_s(bob),g))),dhexp_real(key_e(alice,bob,sid_5),dhexp_real(key_s(bob),g))),dhexp_real(key_m(alice),dhexp_real(key_s(bob),g))),dhexp_real(key_s(alice),dhexp_real(key_s(bob),g))),minnonce,hash(hash(hash(hash(hash(hash(hash(somename,empty),empty),validkey(dhexp_real(key_s(alice),g))),validkey(dhexp_real(key_m(alice),g))),validkey(dhexp_real(key_s(bob),g))),validkey(dhexp_real(key_s(bob),g))),validkey(dhexp_real(key_e(alice,bob,sid_5),g))),msg_a(alice,bob,sid_5))).
Using the function 1-proj-concat3 the attacker may obtain validkey(dhexp_real(key_e(alice,bob,sid_5),g)).
attacker(validkey(dhexp_real(key_e(alice,bob,sid_5),g))).

8. The message (validkey(dhexp_real(key_s(bob),g)),validkey(dhexp_real(key_m(bob),g))) may be sent on channel pub at output {521}.
mess(pub,(validkey(dhexp_real(key_s(bob),g)),validkey(dhexp_real(key_m(bob),g)))).

9. By 1, the attacker may have the channel pub.
By 8, the message (validkey(dhexp_real(key_s(bob),g)),validkey(dhexp_real(key_m(bob),g))) may be sent on this channel.
So the attacker may obtain the message (validkey(dhexp_real(key_s(bob),g)),validkey(dhexp_real(key_m(bob),g))) by listening on this channel.
attacker((validkey(dhexp_real(key_s(bob),g)),validkey(dhexp_real(key_m(bob),g)))).

10. By 9, the attacker may know (validkey(dhexp_real(key_s(bob),g)),validkey(dhexp_real(key_m(bob),g))).
Using the function 1-proj-2-tuple the attacker may obtain validkey(dhexp_real(key_s(bob),g)).
attacker(validkey(dhexp_real(key_s(bob),g))).

11. The message (validkey(dhexp_real(key_s(alice),g)),validkey(dhexp_real(key_m(alice),g))) may be sent on channel pub at output {15}.
mess(pub,(validkey(dhexp_real(key_s(alice),g)),validkey(dhexp_real(key_m(alice),g)))).

12. By 1, the attacker may have the channel pub.
By 11, the message (validkey(dhexp_real(key_s(alice),g)),validkey(dhexp_real(key_m(alice),g))) may be sent on this channel.
So the attacker may obtain the message (validkey(dhexp_real(key_s(alice),g)),validkey(dhexp_real(key_m(alice),g))) by listening on this channel.
attacker((validkey(dhexp_real(key_s(alice),g)),validkey(dhexp_real(key_m(alice),g)))).

13. By 12, the attacker may know (validkey(dhexp_real(key_s(alice),g)),validkey(dhexp_real(key_m(alice),g))).
Using the function 2-proj-2-tuple the attacker may obtain validkey(dhexp_real(key_m(alice),g)).
attacker(validkey(dhexp_real(key_m(alice),g))).

14. By 12, the attacker may know (validkey(dhexp_real(key_s(alice),g)),validkey(dhexp_real(key_m(alice),g))).
Using the function 1-proj-2-tuple the attacker may obtain validkey(dhexp_real(key_s(alice),g)).
attacker(validkey(dhexp_real(key_s(alice),g))).

15. Using the function empty the attacker may obtain empty.
attacker(empty).

16. Using the function somename the attacker may obtain somename.
attacker(somename).

17. By 16, the attacker may know somename.
By 15, the attacker may know empty.
Using the function hash the attacker may obtain hash(somename,empty).
attacker(hash(somename,empty)).

18. By 17, the attacker may know hash(somename,empty).
By 15, the attacker may know empty.
Using the function hash the attacker may obtain hash(hash(somename,empty),empty).
attacker(hash(hash(somename,empty),empty)).

19. By 18, the attacker may know hash(hash(somename,empty),empty).
By 14, the attacker may know validkey(dhexp_real(key_s(alice),g)).
Using the function hash the attacker may obtain hash(hash(hash(somename,empty),empty),validkey(dhexp_real(key_s(alice),g))).
attacker(hash(hash(hash(somename,empty),empty),validkey(dhexp_real(key_s(alice),g)))).

20. By 19, the attacker may know hash(hash(hash(somename,empty),empty),validkey(dhexp_real(key_s(alice),g))).
By 13, the attacker may know validkey(dhexp_real(key_m(alice),g)).
Using the function hash the attacker may obtain hash(hash(hash(hash(somename,empty),empty),validkey(dhexp_real(key_s(alice),g))),validkey(dhexp_real(key_m(alice),g))).
attacker(hash(hash(hash(hash(somename,empty),empty),validkey(dhexp_real(key_s(alice),g))),validkey(dhexp_real(key_m(alice),g)))).

21. By 20, the attacker may know hash(hash(hash(hash(somename,empty),empty),validkey(dhexp_real(key_s(alice),g))),validkey(dhexp_real(key_m(alice),g))).
By 10, the attacker may know validkey(dhexp_real(key_s(bob),g)).
Using the function hash the attacker may obtain hash(hash(hash(hash(hash(somename,empty),empty),validkey(dhexp_real(key_s(alice),g))),validkey(dhexp_real(key_m(alice),g))),validkey(dhexp_real(key_s(bob),g))).
attacker(hash(hash(hash(hash(hash(somename,empty),empty),validkey(dhexp_real(key_s(alice),g))),validkey(dhexp_real(key_m(alice),g))),validkey(dhexp_real(key_s(bob),g)))).

22. By 21, the attacker may know hash(hash(hash(hash(hash(somename,empty),empty),validkey(dhexp_real(key_s(alice),g))),validkey(dhexp_real(key_m(alice),g))),validkey(dhexp_real(key_s(bob),g))).
By 10, the attacker may know validkey(dhexp_real(key_s(bob),g)).
Using the function hash the attacker may obtain hash(hash(hash(hash(hash(hash(somename,empty),empty),validkey(dhexp_real(key_s(alice),g))),validkey(dhexp_real(key_m(alice),g))),validkey(dhexp_real(key_s(bob),g))),validkey(dhexp_real(key_s(bob),g))).
attacker(hash(hash(hash(hash(hash(hash(somename,empty),empty),validkey(dhexp_real(key_s(alice),g))),validkey(dhexp_real(key_m(alice),g))),validkey(dhexp_real(key_s(bob),g))),validkey(dhexp_real(key_s(bob),g)))).

23. By 22, the attacker may know hash(hash(hash(hash(hash(hash(somename,empty),empty),validkey(dhexp_real(key_s(alice),g))),validkey(dhexp_real(key_m(alice),g))),validkey(dhexp_real(key_s(bob),g))),validkey(dhexp_real(key_s(bob),g))).
By 7, the attacker may know validkey(dhexp_real(key_e(alice,bob,sid_5),g)).
Using the function hash the attacker may obtain hash(hash(hash(hash(hash(hash(hash(somename,empty),empty),validkey(dhexp_real(key_s(alice),g))),validkey(dhexp_real(key_m(alice),g))),validkey(dhexp_real(key_s(bob),g))),validkey(dhexp_real(key_s(bob),g))),validkey(dhexp_real(key_e(alice,bob,sid_5),g))).
attacker(hash(hash(hash(hash(hash(hash(hash(somename,empty),empty),validkey(dhexp_real(key_s(alice),g))),validkey(dhexp_real(key_m(alice),g))),validkey(dhexp_real(key_s(bob),g))),validkey(dhexp_real(key_s(bob),g))),validkey(dhexp_real(key_e(alice,bob,sid_5),g)))).

24. By 23, the attacker may know hash(hash(hash(hash(hash(hash(hash(somename,empty),empty),validkey(dhexp_real(key_s(alice),g))),validkey(dhexp_real(key_m(alice),g))),validkey(dhexp_real(key_s(bob),g))),validkey(dhexp_real(key_s(bob),g))),validkey(dhexp_real(key_e(alice,bob,sid_5),g))).
So the attacker may know hash(hash(hash(hash(hash(hash(hash(somename,empty),empty),validkey(dhexp_real(key_s(alice),g))),validkey(dhexp_real(key_m(alice),g))),validkey(dhexp_real(key_s(bob),g))),validkey(dhexp_real(key_s(bob),g))),validkey(dhexp_real(key_e(alice,bob,sid_5),g))) in phase 1.
attacker_p1(hash(hash(hash(hash(hash(hash(hash(somename,empty),empty),validkey(dhexp_real(key_s(alice),g))),validkey(dhexp_real(key_m(alice),g))),validkey(dhexp_real(key_s(bob),g))),validkey(dhexp_real(key_s(bob),g))),validkey(dhexp_real(key_e(alice,bob,sid_5),g)))).

25. Using the function minnonce the attacker may obtain minnonce in phase 1.
attacker_p1(minnonce).

26. By 14, the attacker may know validkey(dhexp_real(key_s(alice),g)).
So the attacker may know validkey(dhexp_real(key_s(alice),g)) in phase 1.
attacker_p1(validkey(dhexp_real(key_s(alice),g))).

27. Using the function pub the attacker may obtain pub in phase 1.
attacker_p1(pub).

28. The event LeakS(phase1,bob) may be executed at {763}.
The event LeakM(phase1,bob) may be executed at {764}.
So the message (key_s(bob),key_m(bob)) may be sent on channel pub in phase 1 at output {765}.
mess_p1(pub,(key_s(bob),key_m(bob))).

29. By 27, the attacker may have the channel pub in phase 1.
By 28, the message (key_s(bob),key_m(bob)) in phase 1 may be sent on this channel.
So the attacker may obtain the message (key_s(bob),key_m(bob)) in phase 1 by listening on this channel.
attacker_p1((key_s(bob),key_m(bob))).

30. By 29, the attacker may know (key_s(bob),key_m(bob)) in phase 1.
Using the function 1-proj-2-tuple the attacker may obtain key_s(bob) in phase 1.
attacker_p1(key_s(bob)).

31. By 30, the attacker may know key_s(bob) in phase 1.
By 26, the attacker may know validkey(dhexp_real(key_s(alice),g)) in phase 1.
Using the function dhexp the attacker may obtain dhexp_real(key_s(alice),dhexp_real(key_s(bob),g)) in phase 1.
attacker_p1(dhexp_real(key_s(alice),dhexp_real(key_s(bob),g))).

32. By 13, the attacker may know validkey(dhexp_real(key_m(alice),g)).
So the attacker may know validkey(dhexp_real(key_m(alice),g)) in phase 1.
attacker_p1(validkey(dhexp_real(key_m(alice),g))).

33. By 30, the attacker may know key_s(bob) in phase 1.
By 32, the attacker may know validkey(dhexp_real(key_m(alice),g)) in phase 1.
Using the function dhexp the attacker may obtain dhexp_real(key_m(alice),dhexp_real(key_s(bob),g)) in phase 1.
attacker_p1(dhexp_real(key_m(alice),dhexp_real(key_s(bob),g))).

34. By 7, the attacker may know validkey(dhexp_real(key_e(alice,bob,sid_5),g)).
So the attacker may know validkey(dhexp_real(key_e(alice,bob,sid_5),g)) in phase 1.
attacker_p1(validkey(dhexp_real(key_e(alice,bob,sid_5),g))).

35. By 30, the attacker may know key_s(bob) in phase 1.
By 34, the attacker may know validkey(dhexp_real(key_e(alice,bob,sid_5),g)) in phase 1.
Using the function dhexp the attacker may obtain dhexp_real(key_e(alice,bob,sid_5),dhexp_real(key_s(bob),g)) in phase 1.
attacker_p1(dhexp_real(key_e(alice,bob,sid_5),dhexp_real(key_s(bob),g))).

36. Using the function empty the attacker may obtain empty in phase 1.
attacker_p1(empty).

37. Using the function somename the attacker may obtain somename in phase 1.
attacker_p1(somename).

38. By 37, the attacker may know somename in phase 1.
By 36, the attacker may know empty in phase 1.
Using the function hash the attacker may obtain hash(somename,empty) in phase 1.
attacker_p1(hash(somename,empty)).

39. By 38, the attacker may know hash(somename,empty) in phase 1.
By 35, the attacker may know dhexp_real(key_e(alice,bob,sid_5),dhexp_real(key_s(bob),g)) in phase 1.
Using the function hmac_hash1 the attacker may obtain hmac_hash1(hash(somename,empty),dhexp_real(key_e(alice,bob,sid_5),dhexp_real(key_s(bob),g))) in phase 1.
attacker_p1(hmac_hash1(hash(somename,empty),dhexp_real(key_e(alice,bob,sid_5),dhexp_real(key_s(bob),g)))).

40. By 39, the attacker may know hmac_hash1(hash(somename,empty),dhexp_real(key_e(alice,bob,sid_5),dhexp_real(key_s(bob),g))) in phase 1.
By 35, the attacker may know dhexp_real(key_e(alice,bob,sid_5),dhexp_real(key_s(bob),g)) in phase 1.
Using the function hmac_hash1 the attacker may obtain hmac_hash1(hmac_hash1(hash(somename,empty),dhexp_real(key_e(alice,bob,sid_5),dhexp_real(key_s(bob),g))),dhexp_real(key_e(alice,bob,sid_5),dhexp_real(key_s(bob),g))) in phase 1.
attacker_p1(hmac_hash1(hmac_hash1(hash(somename,empty),dhexp_real(key_e(alice,bob,sid_5),dhexp_real(key_s(bob),g))),dhexp_real(key_e(alice,bob,sid_5),dhexp_real(key_s(bob),g)))).

41. By 40, the attacker may know hmac_hash1(hmac_hash1(hash(somename,empty),dhexp_real(key_e(alice,bob,sid_5),dhexp_real(key_s(bob),g))),dhexp_real(key_e(alice,bob,sid_5),dhexp_real(key_s(bob),g))) in phase 1.
By 33, the attacker may know dhexp_real(key_m(alice),dhexp_real(key_s(bob),g)) in phase 1.
Using the function hmac_hash1 the attacker may obtain hmac_hash1(hmac_hash1(hmac_hash1(hash(somename,empty),dhexp_real(key_e(alice,bob,sid_5),dhexp_real(key_s(bob),g))),dhexp_real(key_e(alice,bob,sid_5),dhexp_real(key_s(bob),g))),dhexp_real(key_m(alice),dhexp_real(key_s(bob),g))) in phase 1.
attacker_p1(hmac_hash1(hmac_hash1(hmac_hash1(hash(somename,empty),dhexp_real(key_e(alice,bob,sid_5),dhexp_real(key_s(bob),g))),dhexp_real(key_e(alice,bob,sid_5),dhexp_real(key_s(bob),g))),dhexp_real(key_m(alice),dhexp_real(key_s(bob),g)))).

42. By 41, the attacker may know hmac_hash1(hmac_hash1(hmac_hash1(hash(somename,empty),dhexp_real(key_e(alice,bob,sid_5),dhexp_real(key_s(bob),g))),dhexp_real(key_e(alice,bob,sid_5),dhexp_real(key_s(bob),g))),dhexp_real(key_m(alice),dhexp_real(key_s(bob),g))) in phase 1.
By 31, the attacker may know dhexp_real(key_s(alice),dhexp_real(key_s(bob),g)) in phase 1.
Using the function hmac_hash2 the attacker may obtain hmac_hash2(hmac_hash1(hmac_hash1(hmac_hash1(hash(somename,empty),dhexp_real(key_e(alice,bob,sid_5),dhexp_real(key_s(bob),g))),dhexp_real(key_e(alice,bob,sid_5),dhexp_real(key_s(bob),g))),dhexp_real(key_m(alice),dhexp_real(key_s(bob),g))),dhexp_real(key_s(alice),dhexp_real(key_s(bob),g))) in phase 1.
attacker_p1(hmac_hash2(hmac_hash1(hmac_hash1(hmac_hash1(hash(somename,empty),dhexp_real(key_e(alice,bob,sid_5),dhexp_real(key_s(bob),g))),dhexp_real(key_e(alice,bob,sid_5),dhexp_real(key_s(bob),g))),dhexp_real(key_m(alice),dhexp_real(key_s(bob),g))),dhexp_real(key_s(alice),dhexp_real(key_s(bob),g)))).

43. By 42, the attacker may know hmac_hash2(hmac_hash1(hmac_hash1(hmac_hash1(hash(somename,empty),dhexp_real(key_e(alice,bob,sid_5),dhexp_real(key_s(bob),g))),dhexp_real(key_e(alice,bob,sid_5),dhexp_real(key_s(bob),g))),dhexp_real(key_m(alice),dhexp_real(key_s(bob),g))),dhexp_real(key_s(alice),dhexp_real(key_s(bob),g))) in phase 1.
By 25, the attacker may know minnonce in phase 1.
By 24, the attacker may know hash(hash(hash(hash(hash(hash(hash(somename,empty),empty),validkey(dhexp_real(key_s(alice),g))),validkey(dhexp_real(key_m(alice),g))),validkey(dhexp_real(key_s(bob),g))),validkey(dhexp_real(key_s(bob),g))),validkey(dhexp_real(key_e(alice,bob,sid_5),g))) in phase 1.
By 6, the attacker may know encrypt(hmac_hash2(hmac_hash1(hmac_hash1(hmac_hash1(hash(somename,empty),dhexp_real(key_e(alice,bob,sid_5),dhexp_real(key_s(bob),g))),dhexp_real(key_e(alice,bob,sid_5),dhexp_real(key_s(bob),g))),dhexp_real(key_m(alice),dhexp_real(key_s(bob),g))),dhexp_real(key_s(alice),dhexp_real(key_s(bob),g))),minnonce,hash(hash(hash(hash(hash(hash(hash(somename,empty),empty),validkey(dhexp_real(key_s(alice),g))),validkey(dhexp_real(key_m(alice),g))),validkey(dhexp_real(key_s(bob),g))),validkey(dhexp_real(key_s(bob),g))),validkey(dhexp_real(key_e(alice,bob,sid_5),g))),msg_a(alice,bob,sid_5)) in phase 1.
Using the function decrypt the attacker may obtain aeadpack(true,hash(hash(hash(hash(hash(hash(hash(somename,empty),empty),validkey(dhexp_real(key_s(alice),g))),validkey(dhexp_real(key_m(alice),g))),validkey(dhexp_real(key_s(bob),g))),validkey(dhexp_real(key_s(bob),g))),validkey(dhexp_real(key_e(alice,bob,sid_5),g))),msg_a(alice,bob,sid_5)) in phase 1.
attacker_p1(aeadpack(true,hash(hash(hash(hash(hash(hash(hash(somename,empty),empty),validkey(dhexp_real(key_s(alice),g))),validkey(dhexp_real(key_m(alice),g))),validkey(dhexp_real(key_s(bob),g))),validkey(dhexp_real(key_s(bob),g))),validkey(dhexp_real(key_e(alice,bob,sid_5),g))),msg_a(alice,bob,sid_5))).

44. By 43, the attacker may know aeadpack(true,hash(hash(hash(hash(hash(hash(hash(somename,empty),empty),validkey(dhexp_real(key_s(alice),g))),validkey(dhexp_real(key_m(alice),g))),validkey(dhexp_real(key_s(bob),g))),validkey(dhexp_real(key_s(bob),g))),validkey(dhexp_real(key_e(alice,bob,sid_5),g))),msg_a(alice,bob,sid_5)) in phase 1.
Using the function 3-proj-aeadpack the attacker may obtain msg_a(alice,bob,sid_5) in phase 1.
attacker_p1(msg_a(alice,bob,sid_5)).

45. By 44, attacker_p1(msg_a(alice,bob,sid_5)).
The goal is reached, represented in the following fact:
attacker_p1(msg_a(alice,bob,sid_5)).


RESULT attacker_p1(msg_a(alice,bob,sid_a)) ==> (event(LeakS(phase0,bob)) && event(LeakM(phase0,bob))) || (event(LeakS(px,bob)) && event(LeakM(px,bob)) && event(LeakS(pz,alice)) && event(LeakM(pz,alice))) cannot be proved.
Starting query attacker_p1(msg_a(alice,bob,sid_a)) ==> event(LeakS(phase0,bob)) && event(LeakM(phase0,bob))
goal reachable: begin(LeakM(phase1,bob)) && begin(LeakS(phase1,bob)) && begin(SendMsg(alice,bob,stagepack_a(sid_5),msg_a(alice,bob,sid_5))) -> attacker_p1(msg_a(alice,bob,sid_5))
Abbreviations:
sid_5 = sid[!1 = @sid]

Derivation:
Abbreviations:
sid_5 = sid[!1 = @sid]

1. Using the function pub the attacker may obtain pub.
attacker(pub).

2. The entry statestore(alice,bob,sid_5,statepack_a(handshakestatepack(symmetricstatepack(cipherstatepack(empty,minnonce),hash(somename,empty),hash(hash(hash(hash(hash(hash(somename,empty),empty),validkey(dhexp_real(key_s(alice),g))),validkey(dhexp_real(key_m(alice),g))),validkey(dhexp_real(key_s(bob),g))),validkey(dhexp_real(key_s(bob),g)))),keypairpack(validkey(dhexp_real(key_s(alice),g)),key_s(alice)),keypairpack(validkey(dhexp_real(key_m(alice),g)),key_m(alice)),keypairpack(empty,empty),validkey(dhexp_real(key_s(bob),g)),validkey(dhexp_real(key_s(bob),g)),empty,empty,true))) may be inserted in a table at insert {74}.
table(statestore(alice,bob,sid_5,statepack_a(handshakestatepack(symmetricstatepack(cipherstatepack(empty,minnonce),hash(somename,empty),hash(hash(hash(hash(hash(hash(somename,empty),empty),validkey(dhexp_real(key_s(alice),g))),validkey(dhexp_real(key_m(alice),g))),validkey(dhexp_real(key_s(bob),g))),validkey(dhexp_real(key_s(bob),g)))),keypairpack(validkey(dhexp_real(key_s(alice),g)),key_s(alice)),keypairpack(validkey(dhexp_real(key_m(alice),g)),key_m(alice)),keypairpack(empty,empty),validkey(dhexp_real(key_s(bob),g)),validkey(dhexp_real(key_s(bob),g)),empty,empty,true)))).

3. The entry statestore(alice,bob,sid_5,statepack_a(handshakestatepack(symmetricstatepack(cipherstatepack(empty,minnonce),hash(somename,empty),hash(hash(hash(hash(hash(hash(somename,empty),empty),validkey(dhexp_real(key_s(alice),g))),validkey(dhexp_real(key_m(alice),g))),validkey(dhexp_real(key_s(bob),g))),validkey(dhexp_real(key_s(bob),g)))),keypairpack(validkey(dhexp_real(key_s(alice),g)),key_s(alice)),keypairpack(validkey(dhexp_real(key_m(alice),g)),key_m(alice)),keypairpack(empty,empty),validkey(dhexp_real(key_s(bob),g)),validkey(dhexp_real(key_s(bob),g)),empty,empty,true))) that may be in a table by 2 may be read at get {249}.
The event SendMsg(alice,bob,stagepack_a(sid_5),msg_a(alice,bob,sid_5)) may be executed at {247}.
So the message concat3(validkey(dhexp_real(key_e(alice,bob,sid_5),g)),empty,encrypt(hmac_hash2(hmac_hash1(hmac_hash1(hmac_hash1(hash(somename,empty),dhexp_real(key_e(alice,bob,sid_5),dhexp_real(key_s(bob),g))),dhexp_real(key_e(alice,bob,sid_5),dhexp_real(key_s(bob),g))),dhexp_real(key_m(alice),dhexp_real(key_s(bob),g))),dhexp_real(key_s(alice),dhexp_real(key_s(bob),g))),minnonce,hash(hash(hash(hash(hash(hash(hash(somename,empty),empty),validkey(dhexp_real(key_s(alice),g))),validkey(dhexp_real(key_m(alice),g))),validkey(dhexp_real(key_s(bob),g))),validkey(dhexp_real(key_s(bob),g))),validkey(dhexp_real(key_e(alice,bob,sid_5),g))),msg_a(alice,bob,sid_5))) may be sent on channel pub at output {248}.
mess(pub,concat3(validkey(dhexp_real(key_e(alice,bob,sid_5),g)),empty,encrypt(hmac_hash2(hmac_hash1(hmac_hash1(hmac_hash1(hash(somename,empty),dhexp_real(key_e(alice,bob,sid_5),dhexp_real(key_s(bob),g))),dhexp_real(key_e(alice,bob,sid_5),dhexp_real(key_s(bob),g))),dhexp_real(key_m(alice),dhexp_real(key_s(bob),g))),dhexp_real(key_s(alice),dhexp_real(key_s(bob),g))),minnonce,hash(hash(hash(hash(hash(hash(hash(somename,empty),empty),validkey(dhexp_real(key_s(alice),g))),validkey(dhexp_real(key_m(alice),g))),validkey(dhexp_real(key_s(bob),g))),validkey(dhexp_real(key_s(bob),g))),validkey(dhexp_real(key_e(alice,bob,sid_5),g))),msg_a(alice,bob,sid_5)))).

4. By 1, the attacker may have the channel pub.
By 3, the message concat3(validkey(dhexp_real(key_e(alice,bob,sid_5),g)),empty,encrypt(hmac_hash2(hmac_hash1(hmac_hash1(hmac_hash1(hash(somename,empty),dhexp_real(key_e(alice,bob,sid_5),dhexp_real(key_s(bob),g))),dhexp_real(key_e(alice,bob,sid_5),dhexp_real(key_s(bob),g))),dhexp_real(key_m(alice),dhexp_real(key_s(bob),g))),dhexp_real(key_s(alice),dhexp_real(key_s(bob),g))),minnonce,hash(hash(hash(hash(hash(hash(hash(somename,empty),empty),validkey(dhexp_real(key_s(alice),g))),validkey(dhexp_real(key_m(alice),g))),validkey(dhexp_real(key_s(bob),g))),validkey(dhexp_real(key_s(bob),g))),validkey(dhexp_real(key_e(alice,bob,sid_5),g))),msg_a(alice,bob,sid_5))) may be sent on this channel.
So the attacker may obtain the message concat3(validkey(dhexp_real(key_e(alice,bob,sid_5),g)),empty,encrypt(hmac_hash2(hmac_hash1(hmac_hash1(hmac_hash1(hash(somename,empty),dhexp_real(key_e(alice,bob,sid_5),dhexp_real(key_s(bob),g))),dhexp_real(key_e(alice,bob,sid_5),dhexp_real(key_s(bob),g))),dhexp_real(key_m(alice),dhexp_real(key_s(bob),g))),dhexp_real(key_s(alice),dhexp_real(key_s(bob),g))),minnonce,hash(hash(hash(hash(hash(hash(hash(somename,empty),empty),validkey(dhexp_real(key_s(alice),g))),validkey(dhexp_real(key_m(alice),g))),validkey(dhexp_real(key_s(bob),g))),validkey(dhexp_real(key_s(bob),g))),validkey(dhexp_real(key_e(alice,bob,sid_5),g))),msg_a(alice,bob,sid_5))) by listening on this channel.
attacker(concat3(validkey(dhexp_real(key_e(alice,bob,sid_5),g)),empty,encrypt(hmac_hash2(hmac_hash1(hmac_hash1(hmac_hash1(hash(somename,empty),dhexp_real(key_e(alice,bob,sid_5),dhexp_real(key_s(bob),g))),dhexp_real(key_e(alice,bob,sid_5),dhexp_real(key_s(bob),g))),dhexp_real(key_m(alice),dhexp_real(key_s(bob),g))),dhexp_real(key_s(alice),dhexp_real(key_s(bob),g))),minnonce,hash(hash(hash(hash(hash(hash(hash(somename,empty),empty),validkey(dhexp_real(key_s(alice),g))),validkey(dhexp_real(key_m(alice),g))),validkey(dhexp_real(key_s(bob),g))),validkey(dhexp_real(key_s(bob),g))),validkey(dhexp_real(key_e(alice,bob,sid_5),g))),msg_a(alice,bob,sid_5)))).

5. By 4, the attacker may know concat3(validkey(dhexp_real(key_e(alice,bob,sid_5),g)),empty,encrypt(hmac_hash2(hmac_hash1(hmac_hash1(hmac_hash1(hash(somename,empty),dhexp_real(key_e(alice,bob,sid_5),dhexp_real(key_s(bob),g))),dhexp_real(key_e(alice,bob,sid_5),dhexp_real(key_s(bob),g))),dhexp_real(key_m(alice),dhexp_real(key_s(bob),g))),dhexp_real(key_s(alice),dhexp_real(key_s(bob),g))),minnonce,hash(hash(hash(hash(hash(hash(hash(somename,empty),empty),validkey(dhexp_real(key_s(alice),g))),validkey(dhexp_real(key_m(alice),g))),validkey(dhexp_real(key_s(bob),g))),validkey(dhexp_real(key_s(bob),g))),validkey(dhexp_real(key_e(alice,bob,sid_5),g))),msg_a(alice,bob,sid_5))).
Using the function 3-proj-concat3 the attacker may obtain encrypt(hmac_hash2(hmac_hash1(hmac_hash1(hmac_hash1(hash(somename,empty),dhexp_real(key_e(alice,bob,sid_5),dhexp_real(key_s(bob),g))),dhexp_real(key_e(alice,bob,sid_5),dhexp_real(key_s(bob),g))),dhexp_real(key_m(alice),dhexp_real(key_s(bob),g))),dhexp_real(key_s(alice),dhexp_real(key_s(bob),g))),minnonce,hash(hash(hash(hash(hash(hash(hash(somename,empty),empty),validkey(dhexp_real(key_s(alice),g))),validkey(dhexp_real(key_m(alice),g))),validkey(dhexp_real(key_s(bob),g))),validkey(dhexp_real(key_s(bob),g))),validkey(dhexp_real(key_e(alice,bob,sid_5),g))),msg_a(alice,bob,sid_5)).
attacker(encrypt(hmac_hash2(hmac_hash1(hmac_hash1(hmac_hash1(hash(somename,empty),dhexp_real(key_e(alice,bob,sid_5),dhexp_real(key_s(bob),g))),dhexp_real(key_e(alice,bob,sid_5),dhexp_real(key_s(bob),g))),dhexp_real(key_m(alice),dhexp_real(key_s(bob),g))),dhexp_real(key_s(alice),dhexp_real(key_s(bob),g))),minnonce,hash(hash(hash(hash(hash(hash(hash(somename,empty),empty),validkey(dhexp_real(key_s(alice),g))),validkey(dhexp_real(key_m(alice),g))),validkey(dhexp_real(key_s(bob),g))),validkey(dhexp_real(key_s(bob),g))),validkey(dhexp_real(key_e(alice,bob,sid_5),g))),msg_a(alice,bob,sid_5))).

6. By 5, the attacker may know encrypt(hmac_hash2(hmac_hash1(hmac_hash1(hmac_hash1(hash(somename,empty),dhexp_real(key_e(alice,bob,sid_5),dhexp_real(key_s(bob),g))),dhexp_real(key_e(alice,bob,sid_5),dhexp_real(key_s(bob),g))),dhexp_real(key_m(alice),dhexp_real(key_s(bob),g))),dhexp_real(key_s(alice),dhexp_real(key_s(bob),g))),minnonce,hash(hash(hash(hash(hash(hash(hash(somename,empty),empty),validkey(dhexp_real(key_s(alice),g))),validkey(dhexp_real(key_m(alice),g))),validkey(dhexp_real(key_s(bob),g))),validkey(dhexp_real(key_s(bob),g))),validkey(dhexp_real(key_e(alice,bob,sid_5),g))),msg_a(alice,bob,sid_5)).
So the attacker may know encrypt(hmac_hash2(hmac_hash1(hmac_hash1(hmac_hash1(hash(somename,empty),dhexp_real(key_e(alice,bob,sid_5),dhexp_real(key_s(bob),g))),dhexp_real(key_e(alice,bob,sid_5),dhexp_real(key_s(bob),g))),dhexp_real(key_m(alice),dhexp_real(key_s(bob),g))),dhexp_real(key_s(alice),dhexp_real(key_s(bob),g))),minnonce,hash(hash(hash(hash(hash(hash(hash(somename,empty),empty),validkey(dhexp_real(key_s(alice),g))),validkey(dhexp_real(key_m(alice),g))),validkey(dhexp_real(key_s(bob),g))),validkey(dhexp_real(key_s(bob),g))),validkey(dhexp_real(key_e(alice,bob,sid_5),g))),msg_a(alice,bob,sid_5)) in phase 1.
attacker_p1(encrypt(hmac_hash2(hmac_hash1(hmac_hash1(hmac_hash1(hash(somename,empty),dhexp_real(key_e(alice,bob,sid_5),dhexp_real(key_s(bob),g))),dhexp_real(key_e(alice,bob,sid_5),dhexp_real(key_s(bob),g))),dhexp_real(key_m(alice),dhexp_real(key_s(bob),g))),dhexp_real(key_s(alice),dhexp_real(key_s(bob),g))),minnonce,hash(hash(hash(hash(hash(hash(hash(somename,empty),empty),validkey(dhexp_real(key_s(alice),g))),validkey(dhexp_real(key_m(alice),g))),validkey(dhexp_real(key_s(bob),g))),validkey(dhexp_real(key_s(bob),g))),validkey(dhexp_real(key_e(alice,bob,sid_5),g))),msg_a(alice,bob,sid_5))).

7. By 4, the attacker may know concat3(validkey(dhexp_real(key_e(alice,bob,sid_5),g)),empty,encrypt(hmac_hash2(hmac_hash1(hmac_hash1(hmac_hash1(hash(somename,empty),dhexp_real(key_e(alice,bob,sid_5),dhexp_real(key_s(bob),g))),dhexp_real(key_e(alice,bob,sid_5),dhexp_real(key_s(bob),g))),dhexp_real(key_m(alice),dhexp_real(key_s(bob),g))),dhexp_real(key_s(alice),dhexp_real(key_s(bob),g))),minnonce,hash(hash(hash(hash(hash(hash(hash(somename,empty),empty),validkey(dhexp_real(key_s(alice),g))),validkey(dhexp_real(key_m(alice),g))),validkey(dhexp_real(key_s(bob),g))),validkey(dhexp_real(key_s(bob),g))),validkey(dhexp_real(key_e(alice,bob,sid_5),g))),msg_a(alice,bob,sid_5))).
Using the function 1-proj-concat3 the attacker may obtain validkey(dhexp_real(key_e(alice,bob,sid_5),g)).
attacker(validkey(dhexp_real(key_e(alice,bob,sid_5),g))).

8. The message (validkey(dhexp_real(key_s(bob),g)),validkey(dhexp_real(key_m(bob),g))) may be sent on channel pub at output {521}.
mess(pub,(validkey(dhexp_real(key_s(bob),g)),validkey(dhexp_real(key_m(bob),g)))).

9. By 1, the attacker may have the channel pub.
By 8, the message (validkey(dhexp_real(key_s(bob),g)),validkey(dhexp_real(key_m(bob),g))) may be sent on this channel.
So the attacker may obtain the message (validkey(dhexp_real(key_s(bob),g)),validkey(dhexp_real(key_m(bob),g))) by listening on this channel.
attacker((validkey(dhexp_real(key_s(bob),g)),validkey(dhexp_real(key_m(bob),g)))).

10. By 9, the attacker may know (validkey(dhexp_real(key_s(bob),g)),validkey(dhexp_real(key_m(bob),g))).
Using the function 1-proj-2-tuple the attacker may obtain validkey(dhexp_real(key_s(bob),g)).
attacker(validkey(dhexp_real(key_s(bob),g))).

11. The message (validkey(dhexp_real(key_s(alice),g)),validkey(dhexp_real(key_m(alice),g))) may be sent on channel pub at output {15}.
mess(pub,(validkey(dhexp_real(key_s(alice),g)),validkey(dhexp_real(key_m(alice),g)))).

12. By 1, the attacker may have the channel pub.
By 11, the message (validkey(dhexp_real(key_s(alice),g)),validkey(dhexp_real(key_m(alice),g))) may be sent on this channel.
So the attacker may obtain the message (validkey(dhexp_real(key_s(alice),g)),validkey(dhexp_real(key_m(alice),g))) by listening on this channel.
attacker((validkey(dhexp_real(key_s(alice),g)),validkey(dhexp_real(key_m(alice),g)))).

13. By 12, the attacker may know (validkey(dhexp_real(key_s(alice),g)),validkey(dhexp_real(key_m(alice),g))).
Using the function 2-proj-2-tuple the attacker may obtain validkey(dhexp_real(key_m(alice),g)).
attacker(validkey(dhexp_real(key_m(alice),g))).

14. By 12, the attacker may know (validkey(dhexp_real(key_s(alice),g)),validkey(dhexp_real(key_m(alice),g))).
Using the function 1-proj-2-tuple the attacker may obtain validkey(dhexp_real(key_s(alice),g)).
attacker(validkey(dhexp_real(key_s(alice),g))).

15. Using the function empty the attacker may obtain empty.
attacker(empty).

16. Using the function somename the attacker may obtain somename.
attacker(somename).

17. By 16, the attacker may know somename.
By 15, the attacker may know empty.
Using the function hash the attacker may obtain hash(somename,empty).
attacker(hash(somename,empty)).

18. By 17, the attacker may know hash(somename,empty).
By 15, the attacker may know empty.
Using the function hash the attacker may obtain hash(hash(somename,empty),empty).
attacker(hash(hash(somename,empty),empty)).

19. By 18, the attacker may know hash(hash(somename,empty),empty).
By 14, the attacker may know validkey(dhexp_real(key_s(alice),g)).
Using the function hash the attacker may obtain hash(hash(hash(somename,empty),empty),validkey(dhexp_real(key_s(alice),g))).
attacker(hash(hash(hash(somename,empty),empty),validkey(dhexp_real(key_s(alice),g)))).

20. By 19, the attacker may know hash(hash(hash(somename,empty),empty),validkey(dhexp_real(key_s(alice),g))).
By 13, the attacker may know validkey(dhexp_real(key_m(alice),g)).
Using the function hash the attacker may obtain hash(hash(hash(hash(somename,empty),empty),validkey(dhexp_real(key_s(alice),g))),validkey(dhexp_real(key_m(alice),g))).
attacker(hash(hash(hash(hash(somename,empty),empty),validkey(dhexp_real(key_s(alice),g))),validkey(dhexp_real(key_m(alice),g)))).

21. By 20, the attacker may know hash(hash(hash(hash(somename,empty),empty),validkey(dhexp_real(key_s(alice),g))),validkey(dhexp_real(key_m(alice),g))).
By 10, the attacker may know validkey(dhexp_real(key_s(bob),g)).
Using the function hash the attacker may obtain hash(hash(hash(hash(hash(somename,empty),empty),validkey(dhexp_real(key_s(alice),g))),validkey(dhexp_real(key_m(alice),g))),validkey(dhexp_real(key_s(bob),g))).
attacker(hash(hash(hash(hash(hash(somename,empty),empty),validkey(dhexp_real(key_s(alice),g))),validkey(dhexp_real(key_m(alice),g))),validkey(dhexp_real(key_s(bob),g)))).

22. By 21, the attacker may know hash(hash(hash(hash(hash(somename,empty),empty),validkey(dhexp_real(key_s(alice),g))),validkey(dhexp_real(key_m(alice),g))),validkey(dhexp_real(key_s(bob),g))).
By 10, the attacker may know validkey(dhexp_real(key_s(bob),g)).
Using the function hash the attacker may obtain hash(hash(hash(hash(hash(hash(somename,empty),empty),validkey(dhexp_real(key_s(alice),g))),validkey(dhexp_real(key_m(alice),g))),validkey(dhexp_real(key_s(bob),g))),validkey(dhexp_real(key_s(bob),g))).
attacker(hash(hash(hash(hash(hash(hash(somename,empty),empty),validkey(dhexp_real(key_s(alice),g))),validkey(dhexp_real(key_m(alice),g))),validkey(dhexp_real(key_s(bob),g))),validkey(dhexp_real(key_s(bob),g)))).

23. By 22, the attacker may know hash(hash(hash(hash(hash(hash(somename,empty),empty),validkey(dhexp_real(key_s(alice),g))),validkey(dhexp_real(key_m(alice),g))),validkey(dhexp_real(key_s(bob),g))),validkey(dhexp_real(key_s(bob),g))).
By 7, the attacker may know validkey(dhexp_real(key_e(alice,bob,sid_5),g)).
Using the function hash the attacker may obtain hash(hash(hash(hash(hash(hash(hash(somename,empty),empty),validkey(dhexp_real(key_s(alice),g))),validkey(dhexp_real(key_m(alice),g))),validkey(dhexp_real(key_s(bob),g))),validkey(dhexp_real(key_s(bob),g))),validkey(dhexp_real(key_e(alice,bob,sid_5),g))).
attacker(hash(hash(hash(hash(hash(hash(hash(somename,empty),empty),validkey(dhexp_real(key_s(alice),g))),validkey(dhexp_real(key_m(alice),g))),validkey(dhexp_real(key_s(bob),g))),validkey(dhexp_real(key_s(bob),g))),validkey(dhexp_real(key_e(alice,bob,sid_5),g)))).

24. By 23, the attacker may know hash(hash(hash(hash(hash(hash(hash(somename,empty),empty),validkey(dhexp_real(key_s(alice),g))),validkey(dhexp_real(key_m(alice),g))),validkey(dhexp_real(key_s(bob),g))),validkey(dhexp_real(key_s(bob),g))),validkey(dhexp_real(key_e(alice,bob,sid_5),g))).
So the attacker may know hash(hash(hash(hash(hash(hash(hash(somename,empty),empty),validkey(dhexp_real(key_s(alice),g))),validkey(dhexp_real(key_m(alice),g))),validkey(dhexp_real(key_s(bob),g))),validkey(dhexp_real(key_s(bob),g))),validkey(dhexp_real(key_e(alice,bob,sid_5),g))) in phase 1.
attacker_p1(hash(hash(hash(hash(hash(hash(hash(somename,empty),empty),validkey(dhexp_real(key_s(alice),g))),validkey(dhexp_real(key_m(alice),g))),validkey(dhexp_real(key_s(bob),g))),validkey(dhexp_real(key_s(bob),g))),validkey(dhexp_real(key_e(alice,bob,sid_5),g)))).

25. Using the function minnonce the attacker may obtain minnonce in phase 1.
attacker_p1(minnonce).

26. By 14, the attacker may know validkey(dhexp_real(key_s(alice),g)).
So the attacker may know validkey(dhexp_real(key_s(alice),g)) in phase 1.
attacker_p1(validkey(dhexp_real(key_s(alice),g))).

27. Using the function pub the attacker may obtain pub in phase 1.
attacker_p1(pub).

28. The event LeakS(phase1,bob) may be executed at {763}.
The event LeakM(phase1,bob) may be executed at {764}.
So the message (key_s(bob),key_m(bob)) may be sent on channel pub in phase 1 at output {765}.
mess_p1(pub,(key_s(bob),key_m(bob))).

29. By 27, the attacker may have the channel pub in phase 1.
By 28, the message (key_s(bob),key_m(bob)) in phase 1 may be sent on this channel.
So the attacker may obtain the message (key_s(bob),key_m(bob)) in phase 1 by listening on this channel.
attacker_p1((key_s(bob),key_m(bob))).

30. By 29, the attacker may know (key_s(bob),key_m(bob)) in phase 1.
Using the function 1-proj-2-tuple the attacker may obtain key_s(bob) in phase 1.
attacker_p1(key_s(bob)).

31. By 30, the attacker may know key_s(bob) in phase 1.
By 26, the attacker may know validkey(dhexp_real(key_s(alice),g)) in phase 1.
Using the function dhexp the attacker may obtain dhexp_real(key_s(alice),dhexp_real(key_s(bob),g)) in phase 1.
attacker_p1(dhexp_real(key_s(alice),dhexp_real(key_s(bob),g))).

32. By 13, the attacker may know validkey(dhexp_real(key_m(alice),g)).
So the attacker may know validkey(dhexp_real(key_m(alice),g)) in phase 1.
attacker_p1(validkey(dhexp_real(key_m(alice),g))).

33. By 30, the attacker may know key_s(bob) in phase 1.
By 32, the attacker may know validkey(dhexp_real(key_m(alice),g)) in phase 1.
Using the function dhexp the attacker may obtain dhexp_real(key_m(alice),dhexp_real(key_s(bob),g)) in phase 1.
attacker_p1(dhexp_real(key_m(alice),dhexp_real(key_s(bob),g))).

34. By 7, the attacker may know validkey(dhexp_real(key_e(alice,bob,sid_5),g)).
So the attacker may know validkey(dhexp_real(key_e(alice,bob,sid_5),g)) in phase 1.
attacker_p1(validkey(dhexp_real(key_e(alice,bob,sid_5),g))).

35. By 30, the attacker may know key_s(bob) in phase 1.
By 34, the attacker may know validkey(dhexp_real(key_e(alice,bob,sid_5),g)) in phase 1.
Using the function dhexp the attacker may obtain dhexp_real(key_e(alice,bob,sid_5),dhexp_real(key_s(bob),g)) in phase 1.
attacker_p1(dhexp_real(key_e(alice,bob,sid_5),dhexp_real(key_s(bob),g))).

36. Using the function empty the attacker may obtain empty in phase 1.
attacker_p1(empty).

37. Using the function somename the attacker may obtain somename in phase 1.
attacker_p1(somename).

38. By 37, the attacker may know somename in phase 1.
By 36, the attacker may know empty in phase 1.
Using the function hash the attacker may obtain hash(somename,empty) in phase 1.
attacker_p1(hash(somename,empty)).

39. By 38, the attacker may know hash(somename,empty) in phase 1.
By 35, the attacker may know dhexp_real(key_e(alice,bob,sid_5),dhexp_real(key_s(bob),g)) in phase 1.
Using the function hmac_hash1 the attacker may obtain hmac_hash1(hash(somename,empty),dhexp_real(key_e(alice,bob,sid_5),dhexp_real(key_s(bob),g))) in phase 1.
attacker_p1(hmac_hash1(hash(somename,empty),dhexp_real(key_e(alice,bob,sid_5),dhexp_real(key_s(bob),g)))).

40. By 39, the attacker may know hmac_hash1(hash(somename,empty),dhexp_real(key_e(alice,bob,sid_5),dhexp_real(key_s(bob),g))) in phase 1.
By 35, the attacker may know dhexp_real(key_e(alice,bob,sid_5),dhexp_real(key_s(bob),g)) in phase 1.
Using the function hmac_hash1 the attacker may obtain hmac_hash1(hmac_hash1(hash(somename,empty),dhexp_real(key_e(alice,bob,sid_5),dhexp_real(key_s(bob),g))),dhexp_real(key_e(alice,bob,sid_5),dhexp_real(key_s(bob),g))) in phase 1.
attacker_p1(hmac_hash1(hmac_hash1(hash(somename,empty),dhexp_real(key_e(alice,bob,sid_5),dhexp_real(key_s(bob),g))),dhexp_real(key_e(alice,bob,sid_5),dhexp_real(key_s(bob),g)))).

41. By 40, the attacker may know hmac_hash1(hmac_hash1(hash(somename,empty),dhexp_real(key_e(alice,bob,sid_5),dhexp_real(key_s(bob),g))),dhexp_real(key_e(alice,bob,sid_5),dhexp_real(key_s(bob),g))) in phase 1.
By 33, the attacker may know dhexp_real(key_m(alice),dhexp_real(key_s(bob),g)) in phase 1.
Using the function hmac_hash1 the attacker may obtain hmac_hash1(hmac_hash1(hmac_hash1(hash(somename,empty),dhexp_real(key_e(alice,bob,sid_5),dhexp_real(key_s(bob),g))),dhexp_real(key_e(alice,bob,sid_5),dhexp_real(key_s(bob),g))),dhexp_real(key_m(alice),dhexp_real(key_s(bob),g))) in phase 1.
attacker_p1(hmac_hash1(hmac_hash1(hmac_hash1(hash(somename,empty),dhexp_real(key_e(alice,bob,sid_5),dhexp_real(key_s(bob),g))),dhexp_real(key_e(alice,bob,sid_5),dhexp_real(key_s(bob),g))),dhexp_real(key_m(alice),dhexp_real(key_s(bob),g)))).

42. By 41, the attacker may know hmac_hash1(hmac_hash1(hmac_hash1(hash(somename,empty),dhexp_real(key_e(alice,bob,sid_5),dhexp_real(key_s(bob),g))),dhexp_real(key_e(alice,bob,sid_5),dhexp_real(key_s(bob),g))),dhexp_real(key_m(alice),dhexp_real(key_s(bob),g))) in phase 1.
By 31, the attacker may know dhexp_real(key_s(alice),dhexp_real(key_s(bob),g)) in phase 1.
Using the function hmac_hash2 the attacker may obtain hmac_hash2(hmac_hash1(hmac_hash1(hmac_hash1(hash(somename,empty),dhexp_real(key_e(alice,bob,sid_5),dhexp_real(key_s(bob),g))),dhexp_real(key_e(alice,bob,sid_5),dhexp_real(key_s(bob),g))),dhexp_real(key_m(alice),dhexp_real(key_s(bob),g))),dhexp_real(key_s(alice),dhexp_real(key_s(bob),g))) in phase 1.
attacker_p1(hmac_hash2(hmac_hash1(hmac_hash1(hmac_hash1(hash(somename,empty),dhexp_real(key_e(alice,bob,sid_5),dhexp_real(key_s(bob),g))),dhexp_real(key_e(alice,bob,sid_5),dhexp_real(key_s(bob),g))),dhexp_real(key_m(alice),dhexp_real(key_s(bob),g))),dhexp_real(key_s(alice),dhexp_real(key_s(bob),g)))).

43. By 42, the attacker may know hmac_hash2(hmac_hash1(hmac_hash1(hmac_hash1(hash(somename,empty),dhexp_real(key_e(alice,bob,sid_5),dhexp_real(key_s(bob),g))),dhexp_real(key_e(alice,bob,sid_5),dhexp_real(key_s(bob),g))),dhexp_real(key_m(alice),dhexp_real(key_s(bob),g))),dhexp_real(key_s(alice),dhexp_real(key_s(bob),g))) in phase 1.
By 25, the attacker may know minnonce in phase 1.
By 24, the attacker may know hash(hash(hash(hash(hash(hash(hash(somename,empty),empty),validkey(dhexp_real(key_s(alice),g))),validkey(dhexp_real(key_m(alice),g))),validkey(dhexp_real(key_s(bob),g))),validkey(dhexp_real(key_s(bob),g))),validkey(dhexp_real(key_e(alice,bob,sid_5),g))) in phase 1.
By 6, the attacker may know encrypt(hmac_hash2(hmac_hash1(hmac_hash1(hmac_hash1(hash(somename,empty),dhexp_real(key_e(alice,bob,sid_5),dhexp_real(key_s(bob),g))),dhexp_real(key_e(alice,bob,sid_5),dhexp_real(key_s(bob),g))),dhexp_real(key_m(alice),dhexp_real(key_s(bob),g))),dhexp_real(key_s(alice),dhexp_real(key_s(bob),g))),minnonce,hash(hash(hash(hash(hash(hash(hash(somename,empty),empty),validkey(dhexp_real(key_s(alice),g))),validkey(dhexp_real(key_m(alice),g))),validkey(dhexp_real(key_s(bob),g))),validkey(dhexp_real(key_s(bob),g))),validkey(dhexp_real(key_e(alice,bob,sid_5),g))),msg_a(alice,bob,sid_5)) in phase 1.
Using the function decrypt the attacker may obtain aeadpack(true,hash(hash(hash(hash(hash(hash(hash(somename,empty),empty),validkey(dhexp_real(key_s(alice),g))),validkey(dhexp_real(key_m(alice),g))),validkey(dhexp_real(key_s(bob),g))),validkey(dhexp_real(key_s(bob),g))),validkey(dhexp_real(key_e(alice,bob,sid_5),g))),msg_a(alice,bob,sid_5)) in phase 1.
attacker_p1(aeadpack(true,hash(hash(hash(hash(hash(hash(hash(somename,empty),empty),validkey(dhexp_real(key_s(alice),g))),validkey(dhexp_real(key_m(alice),g))),validkey(dhexp_real(key_s(bob),g))),validkey(dhexp_real(key_s(bob),g))),validkey(dhexp_real(key_e(alice,bob,sid_5),g))),msg_a(alice,bob,sid_5))).

44. By 43, the attacker may know aeadpack(true,hash(hash(hash(hash(hash(hash(hash(somename,empty),empty),validkey(dhexp_real(key_s(alice),g))),validkey(dhexp_real(key_m(alice),g))),validkey(dhexp_real(key_s(bob),g))),validkey(dhexp_real(key_s(bob),g))),validkey(dhexp_real(key_e(alice,bob,sid_5),g))),msg_a(alice,bob,sid_5)) in phase 1.
Using the function 3-proj-aeadpack the attacker may obtain msg_a(alice,bob,sid_5) in phase 1.
attacker_p1(msg_a(alice,bob,sid_5)).

45. By 44, attacker_p1(msg_a(alice,bob,sid_5)).
The goal is reached, represented in the following fact:
attacker_p1(msg_a(alice,bob,sid_5)).


RESULT attacker_p1(msg_a(alice,bob,sid_a)) ==> event(LeakS(phase0,bob)) && event(LeakM(phase0,bob)) cannot be proved.
Starting query not event(RecvEnd(true))
RESULT not event(RecvEnd(true)) is true.

--------------------------------------------------------------
Verification summary:

Query event(RecvMsg(bob,alice,stagepack_a(sid_b),m_8)) ==> event(SendMsg(alice,bob,stagepack_a(sid_a),m_8)) is true.

Query event(RecvMsg(bob,alice,stagepack_a(sid_b),m_8)) ==> event(SendMsg(alice,c,stagepack_a(sid_a),m_8)) || (event(LeakS(phase0,alice)) && event(LeakM(phase0,alice))) || (event(LeakS(phase0,bob)) && event(LeakM(phase0,bob))) is true.

Query event(RecvMsg(bob,alice,stagepack_a(sid_b),m_8)) ==> event(SendMsg(alice,c,stagepack_a(sid_a),m_8)) || (event(LeakS(phase0,alice)) && event(LeakM(phase0,alice))) is true.

Query event(RecvMsg(bob,alice,stagepack_a(sid_b),m_8)) ==> event(SendMsg(alice,bob,stagepack_a(sid_a),m_8)) || (event(LeakS(phase0,alice)) && event(LeakM(phase0,alice))) || (event(LeakS(phase0,bob)) && event(LeakM(phase0,bob))) is true.

Query event(RecvMsg(bob,alice,stagepack_a(sid_b),m_8)) ==> event(SendMsg(alice,bob,stagepack_a(sid_a),m_8)) || (event(LeakS(phase0,alice)) && event(LeakM(phase0,alice))) is true.

Query not attacker_p1(msg_a(alice,bob,sid_a)) cannot be proved.

Query attacker_p1(msg_a(alice,bob,sid_a)) ==> event(LeakS(px,bob)) && event(LeakM(px,bob)) is true.

Query attacker_p1(msg_a(alice,bob,sid_a)) ==> (event(LeakS(phase0,bob)) && event(LeakM(phase0,bob))) || (event(LeakS(px,bob)) && event(LeakM(px,bob)) && event(LeakS(pz,alice)) && event(LeakM(pz,alice))) cannot be proved.

Query attacker_p1(msg_a(alice,bob,sid_a)) ==> event(LeakS(phase0,bob)) && event(LeakM(phase0,bob)) cannot be proved.

Query not event(RecvEnd(true)) is true.

--------------------------------------------------------------


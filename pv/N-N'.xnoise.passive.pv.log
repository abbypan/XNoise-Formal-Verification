File "pv/N-N'.xnoise.passive.pv", line 210, characters 7-8:
Warning: identifier ck rebound.
File "pv/N-N'.xnoise.passive.pv", line 219, characters 7-8:
Warning: identifier ck rebound.
File "pv/N-N'.xnoise.passive.pv", line 220, characters 7-8:
Warning: identifier cs rebound.
File "pv/N-N'.xnoise.passive.pv", line 220, character 36:
Warning: identifier h rebound.
File "pv/N-N'.xnoise.passive.pv", line 250, characters 6-7:
Warning: identifier ss rebound.
File "pv/N-N'.xnoise.passive.pv", line 251, characters 6-7:
Warning: identifier ss rebound.
File "pv/N-N'.xnoise.passive.pv", line 256, characters 6-7:
Warning: identifier ss rebound.
File "pv/N-N'.xnoise.passive.pv", line 257, characters 6-7:
Warning: identifier ss rebound.
File "pv/N-N'.xnoise.passive.pv", line 263, character 6:
Warning: identifier e rebound.
File "pv/N-N'.xnoise.passive.pv", line 264, characters 6-7:
Warning: identifier ne rebound.
File "pv/N-N'.xnoise.passive.pv", line 265, characters 6-7:
Warning: identifier ss rebound.
File "pv/N-N'.xnoise.passive.pv", line 267, characters 6-7:
Warning: identifier ss rebound.
File "pv/N-N'.xnoise.passive.pv", line 268, characters 6-7:
Warning: identifier ss rebound.
File "pv/N-N'.xnoise.passive.pv", line 269, characters 7-8:
Warning: identifier ss rebound.
File "pv/N-N'.xnoise.passive.pv", line 269, characters 26-35:
Warning: identifier ciphertext rebound.
File "pv/N-N'.xnoise.passive.pv", line 270, characters 6-7:
Warning: identifier hs rebound.
File "pv/N-N'.xnoise.passive.pv", line 279, characters 6-7:
Warning: identifier re rebound.
File "pv/N-N'.xnoise.passive.pv", line 280, characters 6-7:
Warning: identifier ss rebound.
File "pv/N-N'.xnoise.passive.pv", line 282, characters 6-7:
Warning: identifier ss rebound.
File "pv/N-N'.xnoise.passive.pv", line 283, characters 6-7:
Warning: identifier ss rebound.
File "pv/N-N'.xnoise.passive.pv", line 284, characters 7-8:
Warning: identifier ss rebound.
File "pv/N-N'.xnoise.passive.pv", line 286, characters 7-8:
Warning: identifier hs rebound.
File "pv/N-N'.xnoise.passive.pv", line 361, characters 8-9:
Warning: identifier hs rebound.
File "pv/N-N'.xnoise.passive.pv", line 382, characters 8-9:
Warning: identifier hs rebound.
Linear part:
dhexp_real(b,dhexp_real(a,g)) = dhexp_real(a,dhexp_real(b,g))
Completing equations...
Completed equations:
dhexp_real(b,dhexp_real(a,g)) = dhexp_real(a,dhexp_real(b,g))
Convergent part: No equation.
Process 0 (that is, the initial process):
{1}out(pub, (key_s(charlie),key_m(charlie)));
{2}!
{3}new sid: sessionid;
(
    {4}let me: principal = alice in
    {5}let them: principal = bob in
    {6}let sid_1: sessionid = sid in
    {7}let s: keypair = keypairpack(empty,empty) in
    {8}let m: keypair = keypairpack(empty,empty) in
    (
        {9}let e: keypair = keypairpack(empty,empty) in
        {10}let basis: key = key_s(them) in
        {11}let public_key: key = catch-fail(dhexp(basis,validkey(g))) in
        {12}let v: bool = not-caught-fail(public_key) in
        {13}let rs: key = getpublickey((if v then keypairpack(validkey(public_key),basis) else fail-any)) in
        {14}let basis_1: key = key_m(them) in
        {15}let public_key_1: key = catch-fail(dhexp(basis_1,validkey(g))) in
        {16}let v_1: bool = not-caught-fail(public_key_1) in
        {17}let rm: key = getpublickey((if v_1 then keypairpack(validkey(public_key_1),basis_1) else fail-any)) in
        {18}let re: key = empty in
        {19}let prologue: bitstring = empty in
        {20}let psk: key = empty in
        {21}let protocol_name: bitstring = somename in
        {22}let h: bitstring = hash(protocol_name,empty) in
        {23}let ck: key = h in
        {24}let k: key = empty in
        {25}let cs: cipherstate = cipherstatepack(k,minnonce) in
        {26}let ss: symmetricstate = symmetricstatepack(cs,ck,h) in
        {27}let v_2: bitstring = catch-fail(symmetricstateunpack(ss)) in
        {28}let v_3: bool = (not-caught-fail(v_2) && success?(1-proj-3-tuple(v_2))) in
        {29}let h_1: bitstring = (if v_3 then 3-proj-3-tuple(v_2) else caught-fail) in
        {30}let ck_1: key = (if v_3 then 2-proj-3-tuple(v_2) else caught-fail) in
        {31}let cs_1: cipherstate = (if v_3 then 1-proj-3-tuple(v_2) else caught-fail) in
        {32}let ss_1: symmetricstate = catch-fail((if v_3 then symmetricstatepack(cs_1,ck_1,hash(h_1,prologue)) else fail-any)) in
        {33}let v_4: bool = not-caught-fail(ss_1) in
        {34}let v_5: bitstring = (if v_4 then catch-fail(symmetricstateunpack(ss_1)) else caught-fail) in
        {35}let v_6: bool = (not-caught-fail(v_5) && success?(1-proj-3-tuple(v_5))) in
        {36}let h_2: bitstring = (if v_6 then 3-proj-3-tuple(v_5) else caught-fail) in
        {37}let ck_2: key = (if v_6 then 2-proj-3-tuple(v_5) else caught-fail) in
        {38}let cs_2: cipherstate = (if v_6 then 1-proj-3-tuple(v_5) else caught-fail) in
        {39}let ss_2: symmetricstate = (if v_4 then catch-fail((if v_6 then symmetricstatepack(cs_2,ck_2,hash(h_2,rs)) else fail-any)) else caught-fail) in
        {40}let v_7: bool = not-caught-fail(ss_2) in
        {41}let v_8: bitstring = (if v_7 then catch-fail(symmetricstateunpack(ss_2)) else caught-fail) in
        {42}let v_9: bool = (not-caught-fail(v_8) && success?(1-proj-3-tuple(v_8))) in
        {43}let h_3: bitstring = (if v_9 then 3-proj-3-tuple(v_8) else caught-fail) in
        {44}let ck_3: key = (if v_9 then 2-proj-3-tuple(v_8) else caught-fail) in
        {45}let cs_3: cipherstate = (if v_9 then 1-proj-3-tuple(v_8) else caught-fail) in
        {46}let ss_3: symmetricstate = (if v_7 then catch-fail((if v_9 then symmetricstatepack(cs_3,ck_3,hash(h_3,rm)) else fail-any)) else caught-fail) in
        {47}let v_10: bool = not-caught-fail(ss_3) in
        {48}let hs: handshakestate = (if v_4 then (if v_7 then (if v_10 then handshakestatepack(ss_3,s,m,e,rs,rm,re,psk,true) else fail-any) else fail-any) else fail-any) in
        {49}insert statestore(me,them,sid_1,statepack_a(hs))
    ) | (
        {182}get statestore(=me,=them,=sid_1,statepack_a(hs_1: handshakestate)) in
        {50}let payload: bitstring = msg_a(me,them,sid_1) in
        {51}let v_11: bitstring = catch-fail(handshakestateunpack(hs_1)) in
        {52}let v_12: bool = (not-caught-fail(v_11) && success?(1-proj-9-tuple(v_11))) in
        {53}let initiator_1: bool = (if v_12 then 9-proj-9-tuple(v_11) else caught-fail) in
        {54}let psk_1: key = (if v_12 then 8-proj-9-tuple(v_11) else caught-fail) in
        {55}let re_1: key = (if v_12 then 7-proj-9-tuple(v_11) else caught-fail) in
        {56}let rm_1: key = (if v_12 then 6-proj-9-tuple(v_11) else caught-fail) in
        {57}let rs_1: key = (if v_12 then 5-proj-9-tuple(v_11) else caught-fail) in
        {58}let e_1: keypair = (if v_12 then 4-proj-9-tuple(v_11) else caught-fail) in
        {59}let m_1: keypair = (if v_12 then 3-proj-9-tuple(v_11) else caught-fail) in
        {60}let s_1: keypair = (if v_12 then 2-proj-9-tuple(v_11) else caught-fail) in
        {61}let ss_4: symmetricstate = (if v_12 then 1-proj-9-tuple(v_11) else caught-fail) in
        {62}let v_13: bitstring = (if v_12 then catch-fail((empty,empty,empty)) else caught-fail) in
        {63}let v_14: bool = (not-caught-fail(v_13) && success?(1-proj-3-tuple(v_13))) in
        {64}let ciphertext: bitstring = (if v_14 then 3-proj-3-tuple(v_13) else caught-fail) in
        {65}let ns: bitstring = (if v_14 then 2-proj-3-tuple(v_13) else caught-fail) in
        {66}let ne: bitstring = (if v_14 then 1-proj-3-tuple(v_13) else caught-fail) in
        {67}let basis_2: key = (if v_14 then key_e(me,them,sid_1) else caught-fail) in
        {68}let public_key_2: key = (if v_14 then catch-fail(dhexp(basis_2,validkey(g))) else caught-fail) in
        {69}let v_15: bool = not-caught-fail(public_key_2) in
        {70}let e_2: keypair = (if v_14 then catch-fail((if v_15 then keypairpack(validkey(public_key_2),basis_2) else fail-any)) else caught-fail) in
        {71}let v_16: bool = not-caught-fail(e_2) in
        {72}let ne_1: bitstring = (if v_16 then catch-fail(getpublickey(e_2)) else caught-fail) in
        {73}let v_17: bool = not-caught-fail(ne_1) in
        {74}let v_18: bitstring = (if v_17 then catch-fail(symmetricstateunpack(ss_4)) else caught-fail) in
        {75}let v_19: bool = (not-caught-fail(v_18) && success?(1-proj-3-tuple(v_18))) in
        {76}let h_4: bitstring = (if v_19 then 3-proj-3-tuple(v_18) else caught-fail) in
        {77}let ck_4: key = (if v_19 then 2-proj-3-tuple(v_18) else caught-fail) in
        {78}let cs_4: cipherstate = (if v_19 then 1-proj-3-tuple(v_18) else caught-fail) in
        {79}let ss_5: symmetricstate = (if v_17 then catch-fail((if v_19 then symmetricstatepack(cs_4,ck_4,hash(h_4,ne_1)) else fail-any)) else caught-fail) in
        {80}let v_20: bool = not-caught-fail(ss_5) in
        {81}let v_21: bitstring = (if v_20 then catch-fail(keypairunpack(e_2)) else caught-fail) in
        {82}let v_22: bool = (not-caught-fail(v_21) && success?(1-proj-2-tuple(v_21))) in
        {83}let my_private_key: key = (if v_22 then 2-proj-2-tuple(v_21) else caught-fail) in
        {84}let my_public_key: key = (if v_22 then 1-proj-2-tuple(v_21) else caught-fail) in
        {85}let input_key_material: key = (if v_20 then catch-fail((if v_22 then dhexp(my_private_key,rs_1) else fail-any)) else caught-fail) in
        {86}let v_23: bool = not-caught-fail(input_key_material) in
        {87}let v_24: bitstring = (if v_23 then catch-fail(symmetricstateunpack(ss_5)) else caught-fail) in
        {88}let v_25: bool = (not-caught-fail(v_24) && success?(1-proj-3-tuple(v_24))) in
        {89}let h_5: bitstring = (if v_25 then 3-proj-3-tuple(v_24) else caught-fail) in
        {90}let ck_5: key = (if v_25 then 2-proj-3-tuple(v_24) else caught-fail) in
        {91}let cs_5: cipherstate = (if v_25 then 1-proj-3-tuple(v_24) else caught-fail) in
        {92}let output1: key = (if v_25 then hmac_hash1(ck_5,input_key_material) else caught-fail) in
        {93}let output2: key = (if v_25 then hmac_hash2(ck_5,input_key_material) else caught-fail) in
        {94}let output3: key = (if v_25 then hmac_hash3(ck_5,input_key_material) else caught-fail) in
        {95}let v_26: bitstring = (if v_25 then catch-fail((output1,output2,output3)) else caught-fail) in
        {96}let v_27: bool = (not-caught-fail(v_26) && success?(1-proj-3-tuple(v_26))) in
        {97}let output_3: key = (if v_27 then 3-proj-3-tuple(v_26) else caught-fail) in
        {98}let temp_k: key = (if v_27 then 2-proj-3-tuple(v_26) else caught-fail) in
        {99}let ck_6: key = (if v_27 then 1-proj-3-tuple(v_26) else caught-fail) in
        {100}let ss_6: symmetricstate = (if v_20 then catch-fail((if v_23 then (if v_25 then (if v_27 then symmetricstatepack(cipherstatepack(temp_k,minnonce),ck_6,h_5) else fail-any) else fail-any) else fail-any)) else caught-fail) in
        {101}let v_28: bool = not-caught-fail(ss_6) in
        {102}let v_29: bitstring = (if v_28 then catch-fail(keypairunpack(e_2)) else caught-fail) in
        {103}let v_30: bool = (not-caught-fail(v_29) && success?(1-proj-2-tuple(v_29))) in
        {104}let my_private_key_1: key = (if v_30 then 2-proj-2-tuple(v_29) else caught-fail) in
        {105}let my_public_key_1: key = (if v_30 then 1-proj-2-tuple(v_29) else caught-fail) in
        {106}let input_key_material_1: key = (if v_28 then catch-fail((if v_30 then dhexp(my_private_key_1,rm_1) else fail-any)) else caught-fail) in
        {107}let v_31: bool = not-caught-fail(input_key_material_1) in
        {108}let v_32: bitstring = (if v_31 then catch-fail(symmetricstateunpack(ss_6)) else caught-fail) in
        {109}let v_33: bool = (not-caught-fail(v_32) && success?(1-proj-3-tuple(v_32))) in
        {110}let h_6: bitstring = (if v_33 then 3-proj-3-tuple(v_32) else caught-fail) in
        {111}let ck_7: key = (if v_33 then 2-proj-3-tuple(v_32) else caught-fail) in
        {112}let cs_6: cipherstate = (if v_33 then 1-proj-3-tuple(v_32) else caught-fail) in
        {113}let output1_1: key = (if v_33 then hmac_hash1(ck_7,input_key_material_1) else caught-fail) in
        {114}let output2_1: key = (if v_33 then hmac_hash2(ck_7,input_key_material_1) else caught-fail) in
        {115}let output3_1: key = (if v_33 then hmac_hash3(ck_7,input_key_material_1) else caught-fail) in
        {116}let v_34: bitstring = (if v_33 then catch-fail((output1_1,output2_1,output3_1)) else caught-fail) in
        {117}let v_35: bool = (not-caught-fail(v_34) && success?(1-proj-3-tuple(v_34))) in
        {118}let output: key = (if v_35 then 3-proj-3-tuple(v_34) else caught-fail) in
        {119}let temp_k_1: key = (if v_35 then 2-proj-3-tuple(v_34) else caught-fail) in
        {120}let ck_8: key = (if v_35 then 1-proj-3-tuple(v_34) else caught-fail) in
        {121}let ss_7: symmetricstate = (if v_28 then catch-fail((if v_31 then (if v_33 then (if v_35 then symmetricstatepack(cipherstatepack(temp_k_1,minnonce),ck_8,h_6) else fail-any) else fail-any) else fail-any)) else caught-fail) in
        {122}let v_36: bool = not-caught-fail(ss_7) in
        {123}let v_37: bitstring = (if v_36 then catch-fail(symmetricstateunpack(ss_7)) else caught-fail) in
        {124}let v_38: bool = (not-caught-fail(v_37) && success?(1-proj-3-tuple(v_37))) in
        {125}let h_7: bitstring = (if v_38 then 3-proj-3-tuple(v_37) else caught-fail) in
        {126}let ck_9: key = (if v_38 then 2-proj-3-tuple(v_37) else caught-fail) in
        {127}let cs_7: cipherstate = (if v_38 then 1-proj-3-tuple(v_37) else caught-fail) in
        {128}let v_39: bitstring = (if v_38 then catch-fail(cipherstateunpack(cs_7)) else caught-fail) in
        {129}let v_40: bool = (not-caught-fail(v_39) && success?(1-proj-2-tuple(v_39))) in
        {130}let n: nonce = (if v_40 then 2-proj-2-tuple(v_39) else caught-fail) in
        {131}let k_1: key = (if v_40 then 1-proj-2-tuple(v_39) else caught-fail) in
        {132}let e_3: bitstring = (if v_40 then encrypt(k_1,n,h_7,payload) else caught-fail) in
        {133}let n_1: nonce = (if v_40 then increment_nonce(n) else caught-fail) in
        {134}let v_41: bitstring = (if v_40 then catch-fail(cipherstateunpack(cs_7)) else caught-fail) in
        {135}let v_42: bool = (not-caught-fail(v_41) && success?(1-proj-2-tuple(v_41))) in
        {136}let o: nonce = (if v_42 then 2-proj-2-tuple(v_41) else caught-fail) in
        {137}let k_2: key = (if v_42 then 1-proj-2-tuple(v_41) else caught-fail) in
        {138}let csi: cipherstate = (if v_40 then catch-fail((if v_42 then cipherstatepack(k_2,n_1) else fail-any)) else caught-fail) in
        {139}let v_43: bool = not-caught-fail(csi) in
        {140}let v_44: bitstring = (if v_38 then catch-fail((if v_40 then (if v_43 then (csi,e_3) else fail-any) else fail-any)) else caught-fail) in
        {141}let v_45: bool = (not-caught-fail(v_44) && success?(1-proj-2-tuple(v_44))) in
        {142}let ciphertext_1: bitstring = (if v_45 then 2-proj-2-tuple(v_44) else caught-fail) in
        {143}let csi_1: cipherstate = (if v_45 then 1-proj-2-tuple(v_44) else caught-fail) in
        {144}let ss_8: symmetricstate = (if v_45 then symmetricstatepack(csi_1,ck_9,h_7) else caught-fail) in
        {145}let v_46: bitstring = (if v_45 then catch-fail(symmetricstateunpack(ss_8)) else caught-fail) in
        {146}let v_47: bool = (not-caught-fail(v_46) && success?(1-proj-3-tuple(v_46))) in
        {147}let h_8: bitstring = (if v_47 then 3-proj-3-tuple(v_46) else caught-fail) in
        {148}let ck_10: key = (if v_47 then 2-proj-3-tuple(v_46) else caught-fail) in
        {149}let cs_8: cipherstate = (if v_47 then 1-proj-3-tuple(v_46) else caught-fail) in
        {150}let ssi: symmetricstate = (if v_45 then catch-fail((if v_47 then symmetricstatepack(cs_8,ck_10,hash(h_8,ciphertext_1)) else fail-any)) else caught-fail) in
        {151}let v_48: bool = not-caught-fail(ssi) in
        {152}let v_49: bitstring = (if v_36 then catch-fail((if v_38 then (if v_45 then (if v_48 then (ssi,ciphertext_1) else fail-any) else fail-any) else fail-any)) else caught-fail) in
        {153}let v_50: bool = (not-caught-fail(v_49) && success?(1-proj-2-tuple(v_49))) in
        {154}let ciphertext_2: bitstring = (if v_50 then 2-proj-2-tuple(v_49) else caught-fail) in
        {155}let ss_9: symmetricstate = (if v_50 then 1-proj-2-tuple(v_49) else caught-fail) in
        {156}let hs_2: handshakestate = (if v_50 then handshakestatepack(ss_9,s_1,m_1,e_2,rs_1,rm_1,re_1,psk_1,initiator_1) else caught-fail) in
        {157}let message_buffer: bitstring = (if v_50 then concat3(ne_1,ns,ciphertext_2) else caught-fail) in
        {158}let v_51: bitstring = (if v_50 then catch-fail(symmetricstateunpack(ss_9)) else caught-fail) in
        {159}let v_52: bool = (not-caught-fail(v_51) && success?(1-proj-3-tuple(v_51))) in
        {160}let h_9: bitstring = (if v_52 then 3-proj-3-tuple(v_51) else caught-fail) in
        {161}let ck_11: key = (if v_52 then 2-proj-3-tuple(v_51) else caught-fail) in
        {162}let cs_9: cipherstate = (if v_52 then 1-proj-3-tuple(v_51) else caught-fail) in
        {163}let input_key_material_2: key = (if v_52 then zero else caught-fail) in
        {164}let output1_2: key = (if v_52 then hmac_hash1(ck_11,input_key_material_2) else caught-fail) in
        {165}let output2_2: key = (if v_52 then hmac_hash2(ck_11,input_key_material_2) else caught-fail) in
        {166}let output3_2: key = (if v_52 then hmac_hash3(ck_11,input_key_material_2) else caught-fail) in
        {167}let v_53: bitstring = (if v_52 then catch-fail((output1_2,output2_2,output3_2)) else caught-fail) in
        {168}let v_54: bool = (not-caught-fail(v_53) && success?(1-proj-3-tuple(v_53))) in
        {169}let temp_k3: key = (if v_54 then 3-proj-3-tuple(v_53) else caught-fail) in
        {170}let temp_k2: key = (if v_54 then 2-proj-3-tuple(v_53) else caught-fail) in
        {171}let temp_k1: key = (if v_54 then 1-proj-3-tuple(v_53) else caught-fail) in
        {172}let cs1: cipherstate = (if v_54 then cipherstatepack(temp_k1,minnonce) else caught-fail) in
        {173}let cs2: cipherstate = (if v_54 then cipherstatepack(temp_k2,minnonce) else caught-fail) in
        {174}let v_55: bitstring = (if v_50 then catch-fail((if v_52 then (if v_54 then (ss_9,cs1,cs2) else fail-any) else fail-any)) else caught-fail) in
        {175}let v_56: bool = (not-caught-fail(v_55) && success?(1-proj-3-tuple(v_55))) in
        {176}let cs2_1: cipherstate = (if v_56 then 3-proj-3-tuple(v_55) else caught-fail) in
        {177}let cs1_1: cipherstate = (if v_56 then 2-proj-3-tuple(v_55) else caught-fail) in
        {178}let ssi_1: symmetricstate = (if v_56 then 1-proj-3-tuple(v_55) else caught-fail) in
        {179}let (hs_3: handshakestate,message_a: bitstring,cs1_2: cipherstate,cs2_2: cipherstate) = (if v_12 then (if v_14 then (if v_16 then (if v_17 then (if v_20 then (if v_28 then (if v_36 then (if v_50 then (if v_56 then (hs_2,message_buffer,cs1_1,cs2_1) else fail-any) else fail-any) else fail-any) else fail-any) else fail-any) else fail-any) else fail-any) else fail-any) else fail-any) in
        {180}event SendMsg(me,them,stagepack_a(sid_1),msg_a(me,them,sid_1));
        {181}out(pub, message_a)
    ) | (
        0
    )
) | (
    {183}let me_1: principal = alice in
    {184}let them_1: principal = charlie in
    {185}let sid_2: sessionid = sid in
    {186}let s_2: keypair = keypairpack(empty,empty) in
    {187}let m_2: keypair = keypairpack(empty,empty) in
    (
        {188}let e_4: keypair = keypairpack(empty,empty) in
        {189}let basis_3: key = key_s(them_1) in
        {190}let public_key_3: key = catch-fail(dhexp(basis_3,validkey(g))) in
        {191}let v_57: bool = not-caught-fail(public_key_3) in
        {192}let rs_2: key = getpublickey((if v_57 then keypairpack(validkey(public_key_3),basis_3) else fail-any)) in
        {193}let basis_4: key = key_m(them_1) in
        {194}let public_key_4: key = catch-fail(dhexp(basis_4,validkey(g))) in
        {195}let v_58: bool = not-caught-fail(public_key_4) in
        {196}let rm_2: key = getpublickey((if v_58 then keypairpack(validkey(public_key_4),basis_4) else fail-any)) in
        {197}let re_2: key = empty in
        {198}let prologue_1: bitstring = empty in
        {199}let psk_2: key = empty in
        {200}let protocol_name_1: bitstring = somename in
        {201}let h_10: bitstring = hash(protocol_name_1,empty) in
        {202}let ck_12: key = h_10 in
        {203}let k_3: key = empty in
        {204}let cs_10: cipherstate = cipherstatepack(k_3,minnonce) in
        {205}let ss_10: symmetricstate = symmetricstatepack(cs_10,ck_12,h_10) in
        {206}let v_59: bitstring = catch-fail(symmetricstateunpack(ss_10)) in
        {207}let v_60: bool = (not-caught-fail(v_59) && success?(1-proj-3-tuple(v_59))) in
        {208}let h_11: bitstring = (if v_60 then 3-proj-3-tuple(v_59) else caught-fail) in
        {209}let ck_13: key = (if v_60 then 2-proj-3-tuple(v_59) else caught-fail) in
        {210}let cs_11: cipherstate = (if v_60 then 1-proj-3-tuple(v_59) else caught-fail) in
        {211}let ss_11: symmetricstate = catch-fail((if v_60 then symmetricstatepack(cs_11,ck_13,hash(h_11,prologue_1)) else fail-any)) in
        {212}let v_61: bool = not-caught-fail(ss_11) in
        {213}let v_62: bitstring = (if v_61 then catch-fail(symmetricstateunpack(ss_11)) else caught-fail) in
        {214}let v_63: bool = (not-caught-fail(v_62) && success?(1-proj-3-tuple(v_62))) in
        {215}let h_12: bitstring = (if v_63 then 3-proj-3-tuple(v_62) else caught-fail) in
        {216}let ck_14: key = (if v_63 then 2-proj-3-tuple(v_62) else caught-fail) in
        {217}let cs_12: cipherstate = (if v_63 then 1-proj-3-tuple(v_62) else caught-fail) in
        {218}let ss_12: symmetricstate = (if v_61 then catch-fail((if v_63 then symmetricstatepack(cs_12,ck_14,hash(h_12,rs_2)) else fail-any)) else caught-fail) in
        {219}let v_64: bool = not-caught-fail(ss_12) in
        {220}let v_65: bitstring = (if v_64 then catch-fail(symmetricstateunpack(ss_12)) else caught-fail) in
        {221}let v_66: bool = (not-caught-fail(v_65) && success?(1-proj-3-tuple(v_65))) in
        {222}let h_13: bitstring = (if v_66 then 3-proj-3-tuple(v_65) else caught-fail) in
        {223}let ck_15: key = (if v_66 then 2-proj-3-tuple(v_65) else caught-fail) in
        {224}let cs_13: cipherstate = (if v_66 then 1-proj-3-tuple(v_65) else caught-fail) in
        {225}let ss_13: symmetricstate = (if v_64 then catch-fail((if v_66 then symmetricstatepack(cs_13,ck_15,hash(h_13,rm_2)) else fail-any)) else caught-fail) in
        {226}let v_67: bool = not-caught-fail(ss_13) in
        {227}let hs_4: handshakestate = (if v_61 then (if v_64 then (if v_67 then handshakestatepack(ss_13,s_2,m_2,e_4,rs_2,rm_2,re_2,psk_2,true) else fail-any) else fail-any) else fail-any) in
        {228}insert statestore(me_1,them_1,sid_2,statepack_a(hs_4))
    ) | (
        {361}get statestore(=me_1,=them_1,=sid_2,statepack_a(hs_5: handshakestate)) in
        {229}let payload_1: bitstring = msg_a(me_1,them_1,sid_2) in
        {230}let v_68: bitstring = catch-fail(handshakestateunpack(hs_5)) in
        {231}let v_69: bool = (not-caught-fail(v_68) && success?(1-proj-9-tuple(v_68))) in
        {232}let initiator_2: bool = (if v_69 then 9-proj-9-tuple(v_68) else caught-fail) in
        {233}let psk_3: key = (if v_69 then 8-proj-9-tuple(v_68) else caught-fail) in
        {234}let re_3: key = (if v_69 then 7-proj-9-tuple(v_68) else caught-fail) in
        {235}let rm_3: key = (if v_69 then 6-proj-9-tuple(v_68) else caught-fail) in
        {236}let rs_3: key = (if v_69 then 5-proj-9-tuple(v_68) else caught-fail) in
        {237}let e_5: keypair = (if v_69 then 4-proj-9-tuple(v_68) else caught-fail) in
        {238}let m_3: keypair = (if v_69 then 3-proj-9-tuple(v_68) else caught-fail) in
        {239}let s_3: keypair = (if v_69 then 2-proj-9-tuple(v_68) else caught-fail) in
        {240}let ss_14: symmetricstate = (if v_69 then 1-proj-9-tuple(v_68) else caught-fail) in
        {241}let v_70: bitstring = (if v_69 then catch-fail((empty,empty,empty)) else caught-fail) in
        {242}let v_71: bool = (not-caught-fail(v_70) && success?(1-proj-3-tuple(v_70))) in
        {243}let ciphertext_3: bitstring = (if v_71 then 3-proj-3-tuple(v_70) else caught-fail) in
        {244}let ns_1: bitstring = (if v_71 then 2-proj-3-tuple(v_70) else caught-fail) in
        {245}let ne_2: bitstring = (if v_71 then 1-proj-3-tuple(v_70) else caught-fail) in
        {246}let basis_5: key = (if v_71 then key_e(me_1,them_1,sid_2) else caught-fail) in
        {247}let public_key_5: key = (if v_71 then catch-fail(dhexp(basis_5,validkey(g))) else caught-fail) in
        {248}let v_72: bool = not-caught-fail(public_key_5) in
        {249}let e_6: keypair = (if v_71 then catch-fail((if v_72 then keypairpack(validkey(public_key_5),basis_5) else fail-any)) else caught-fail) in
        {250}let v_73: bool = not-caught-fail(e_6) in
        {251}let ne_3: bitstring = (if v_73 then catch-fail(getpublickey(e_6)) else caught-fail) in
        {252}let v_74: bool = not-caught-fail(ne_3) in
        {253}let v_75: bitstring = (if v_74 then catch-fail(symmetricstateunpack(ss_14)) else caught-fail) in
        {254}let v_76: bool = (not-caught-fail(v_75) && success?(1-proj-3-tuple(v_75))) in
        {255}let h_14: bitstring = (if v_76 then 3-proj-3-tuple(v_75) else caught-fail) in
        {256}let ck_16: key = (if v_76 then 2-proj-3-tuple(v_75) else caught-fail) in
        {257}let cs_14: cipherstate = (if v_76 then 1-proj-3-tuple(v_75) else caught-fail) in
        {258}let ss_15: symmetricstate = (if v_74 then catch-fail((if v_76 then symmetricstatepack(cs_14,ck_16,hash(h_14,ne_3)) else fail-any)) else caught-fail) in
        {259}let v_77: bool = not-caught-fail(ss_15) in
        {260}let v_78: bitstring = (if v_77 then catch-fail(keypairunpack(e_6)) else caught-fail) in
        {261}let v_79: bool = (not-caught-fail(v_78) && success?(1-proj-2-tuple(v_78))) in
        {262}let my_private_key_2: key = (if v_79 then 2-proj-2-tuple(v_78) else caught-fail) in
        {263}let my_public_key_2: key = (if v_79 then 1-proj-2-tuple(v_78) else caught-fail) in
        {264}let input_key_material_3: key = (if v_77 then catch-fail((if v_79 then dhexp(my_private_key_2,rs_3) else fail-any)) else caught-fail) in
        {265}let v_80: bool = not-caught-fail(input_key_material_3) in
        {266}let v_81: bitstring = (if v_80 then catch-fail(symmetricstateunpack(ss_15)) else caught-fail) in
        {267}let v_82: bool = (not-caught-fail(v_81) && success?(1-proj-3-tuple(v_81))) in
        {268}let h_15: bitstring = (if v_82 then 3-proj-3-tuple(v_81) else caught-fail) in
        {269}let ck_17: key = (if v_82 then 2-proj-3-tuple(v_81) else caught-fail) in
        {270}let cs_15: cipherstate = (if v_82 then 1-proj-3-tuple(v_81) else caught-fail) in
        {271}let output1_3: key = (if v_82 then hmac_hash1(ck_17,input_key_material_3) else caught-fail) in
        {272}let output2_3: key = (if v_82 then hmac_hash2(ck_17,input_key_material_3) else caught-fail) in
        {273}let output3_3: key = (if v_82 then hmac_hash3(ck_17,input_key_material_3) else caught-fail) in
        {274}let v_83: bitstring = (if v_82 then catch-fail((output1_3,output2_3,output3_3)) else caught-fail) in
        {275}let v_84: bool = (not-caught-fail(v_83) && success?(1-proj-3-tuple(v_83))) in
        {276}let output_1: key = (if v_84 then 3-proj-3-tuple(v_83) else caught-fail) in
        {277}let temp_k_2: key = (if v_84 then 2-proj-3-tuple(v_83) else caught-fail) in
        {278}let ck_18: key = (if v_84 then 1-proj-3-tuple(v_83) else caught-fail) in
        {279}let ss_16: symmetricstate = (if v_77 then catch-fail((if v_80 then (if v_82 then (if v_84 then symmetricstatepack(cipherstatepack(temp_k_2,minnonce),ck_18,h_15) else fail-any) else fail-any) else fail-any)) else caught-fail) in
        {280}let v_85: bool = not-caught-fail(ss_16) in
        {281}let v_86: bitstring = (if v_85 then catch-fail(keypairunpack(e_6)) else caught-fail) in
        {282}let v_87: bool = (not-caught-fail(v_86) && success?(1-proj-2-tuple(v_86))) in
        {283}let my_private_key_3: key = (if v_87 then 2-proj-2-tuple(v_86) else caught-fail) in
        {284}let my_public_key_3: key = (if v_87 then 1-proj-2-tuple(v_86) else caught-fail) in
        {285}let input_key_material_4: key = (if v_85 then catch-fail((if v_87 then dhexp(my_private_key_3,rm_3) else fail-any)) else caught-fail) in
        {286}let v_88: bool = not-caught-fail(input_key_material_4) in
        {287}let v_89: bitstring = (if v_88 then catch-fail(symmetricstateunpack(ss_16)) else caught-fail) in
        {288}let v_90: bool = (not-caught-fail(v_89) && success?(1-proj-3-tuple(v_89))) in
        {289}let h_16: bitstring = (if v_90 then 3-proj-3-tuple(v_89) else caught-fail) in
        {290}let ck_19: key = (if v_90 then 2-proj-3-tuple(v_89) else caught-fail) in
        {291}let cs_16: cipherstate = (if v_90 then 1-proj-3-tuple(v_89) else caught-fail) in
        {292}let output1_4: key = (if v_90 then hmac_hash1(ck_19,input_key_material_4) else caught-fail) in
        {293}let output2_4: key = (if v_90 then hmac_hash2(ck_19,input_key_material_4) else caught-fail) in
        {294}let output3_4: key = (if v_90 then hmac_hash3(ck_19,input_key_material_4) else caught-fail) in
        {295}let v_91: bitstring = (if v_90 then catch-fail((output1_4,output2_4,output3_4)) else caught-fail) in
        {296}let v_92: bool = (not-caught-fail(v_91) && success?(1-proj-3-tuple(v_91))) in
        {297}let output_2: key = (if v_92 then 3-proj-3-tuple(v_91) else caught-fail) in
        {298}let temp_k_3: key = (if v_92 then 2-proj-3-tuple(v_91) else caught-fail) in
        {299}let ck_20: key = (if v_92 then 1-proj-3-tuple(v_91) else caught-fail) in
        {300}let ss_17: symmetricstate = (if v_85 then catch-fail((if v_88 then (if v_90 then (if v_92 then symmetricstatepack(cipherstatepack(temp_k_3,minnonce),ck_20,h_16) else fail-any) else fail-any) else fail-any)) else caught-fail) in
        {301}let v_93: bool = not-caught-fail(ss_17) in
        {302}let v_94: bitstring = (if v_93 then catch-fail(symmetricstateunpack(ss_17)) else caught-fail) in
        {303}let v_95: bool = (not-caught-fail(v_94) && success?(1-proj-3-tuple(v_94))) in
        {304}let h_17: bitstring = (if v_95 then 3-proj-3-tuple(v_94) else caught-fail) in
        {305}let ck_21: key = (if v_95 then 2-proj-3-tuple(v_94) else caught-fail) in
        {306}let cs_17: cipherstate = (if v_95 then 1-proj-3-tuple(v_94) else caught-fail) in
        {307}let v_96: bitstring = (if v_95 then catch-fail(cipherstateunpack(cs_17)) else caught-fail) in
        {308}let v_97: bool = (not-caught-fail(v_96) && success?(1-proj-2-tuple(v_96))) in
        {309}let n_2: nonce = (if v_97 then 2-proj-2-tuple(v_96) else caught-fail) in
        {310}let k_4: key = (if v_97 then 1-proj-2-tuple(v_96) else caught-fail) in
        {311}let e_7: bitstring = (if v_97 then encrypt(k_4,n_2,h_17,payload_1) else caught-fail) in
        {312}let n_3: nonce = (if v_97 then increment_nonce(n_2) else caught-fail) in
        {313}let v_98: bitstring = (if v_97 then catch-fail(cipherstateunpack(cs_17)) else caught-fail) in
        {314}let v_99: bool = (not-caught-fail(v_98) && success?(1-proj-2-tuple(v_98))) in
        {315}let o_1: nonce = (if v_99 then 2-proj-2-tuple(v_98) else caught-fail) in
        {316}let k_5: key = (if v_99 then 1-proj-2-tuple(v_98) else caught-fail) in
        {317}let csi_2: cipherstate = (if v_97 then catch-fail((if v_99 then cipherstatepack(k_5,n_3) else fail-any)) else caught-fail) in
        {318}let v_100: bool = not-caught-fail(csi_2) in
        {319}let v_101: bitstring = (if v_95 then catch-fail((if v_97 then (if v_100 then (csi_2,e_7) else fail-any) else fail-any)) else caught-fail) in
        {320}let v_102: bool = (not-caught-fail(v_101) && success?(1-proj-2-tuple(v_101))) in
        {321}let ciphertext_4: bitstring = (if v_102 then 2-proj-2-tuple(v_101) else caught-fail) in
        {322}let csi_3: cipherstate = (if v_102 then 1-proj-2-tuple(v_101) else caught-fail) in
        {323}let ss_18: symmetricstate = (if v_102 then symmetricstatepack(csi_3,ck_21,h_17) else caught-fail) in
        {324}let v_103: bitstring = (if v_102 then catch-fail(symmetricstateunpack(ss_18)) else caught-fail) in
        {325}let v_104: bool = (not-caught-fail(v_103) && success?(1-proj-3-tuple(v_103))) in
        {326}let h_18: bitstring = (if v_104 then 3-proj-3-tuple(v_103) else caught-fail) in
        {327}let ck_22: key = (if v_104 then 2-proj-3-tuple(v_103) else caught-fail) in
        {328}let cs_18: cipherstate = (if v_104 then 1-proj-3-tuple(v_103) else caught-fail) in
        {329}let ssi_2: symmetricstate = (if v_102 then catch-fail((if v_104 then symmetricstatepack(cs_18,ck_22,hash(h_18,ciphertext_4)) else fail-any)) else caught-fail) in
        {330}let v_105: bool = not-caught-fail(ssi_2) in
        {331}let v_106: bitstring = (if v_93 then catch-fail((if v_95 then (if v_102 then (if v_105 then (ssi_2,ciphertext_4) else fail-any) else fail-any) else fail-any)) else caught-fail) in
        {332}let v_107: bool = (not-caught-fail(v_106) && success?(1-proj-2-tuple(v_106))) in
        {333}let ciphertext_5: bitstring = (if v_107 then 2-proj-2-tuple(v_106) else caught-fail) in
        {334}let ss_19: symmetricstate = (if v_107 then 1-proj-2-tuple(v_106) else caught-fail) in
        {335}let hs_6: handshakestate = (if v_107 then handshakestatepack(ss_19,s_3,m_3,e_6,rs_3,rm_3,re_3,psk_3,initiator_2) else caught-fail) in
        {336}let message_buffer_1: bitstring = (if v_107 then concat3(ne_3,ns_1,ciphertext_5) else caught-fail) in
        {337}let v_108: bitstring = (if v_107 then catch-fail(symmetricstateunpack(ss_19)) else caught-fail) in
        {338}let v_109: bool = (not-caught-fail(v_108) && success?(1-proj-3-tuple(v_108))) in
        {339}let h_19: bitstring = (if v_109 then 3-proj-3-tuple(v_108) else caught-fail) in
        {340}let ck_23: key = (if v_109 then 2-proj-3-tuple(v_108) else caught-fail) in
        {341}let cs_19: cipherstate = (if v_109 then 1-proj-3-tuple(v_108) else caught-fail) in
        {342}let input_key_material_5: key = (if v_109 then zero else caught-fail) in
        {343}let output1_5: key = (if v_109 then hmac_hash1(ck_23,input_key_material_5) else caught-fail) in
        {344}let output2_5: key = (if v_109 then hmac_hash2(ck_23,input_key_material_5) else caught-fail) in
        {345}let output3_5: key = (if v_109 then hmac_hash3(ck_23,input_key_material_5) else caught-fail) in
        {346}let v_110: bitstring = (if v_109 then catch-fail((output1_5,output2_5,output3_5)) else caught-fail) in
        {347}let v_111: bool = (not-caught-fail(v_110) && success?(1-proj-3-tuple(v_110))) in
        {348}let temp_k3_1: key = (if v_111 then 3-proj-3-tuple(v_110) else caught-fail) in
        {349}let temp_k2_1: key = (if v_111 then 2-proj-3-tuple(v_110) else caught-fail) in
        {350}let temp_k1_1: key = (if v_111 then 1-proj-3-tuple(v_110) else caught-fail) in
        {351}let cs1_3: cipherstate = (if v_111 then cipherstatepack(temp_k1_1,minnonce) else caught-fail) in
        {352}let cs2_3: cipherstate = (if v_111 then cipherstatepack(temp_k2_1,minnonce) else caught-fail) in
        {353}let v_112: bitstring = (if v_107 then catch-fail((if v_109 then (if v_111 then (ss_19,cs1_3,cs2_3) else fail-any) else fail-any)) else caught-fail) in
        {354}let v_113: bool = (not-caught-fail(v_112) && success?(1-proj-3-tuple(v_112))) in
        {355}let cs2_4: cipherstate = (if v_113 then 3-proj-3-tuple(v_112) else caught-fail) in
        {356}let cs1_4: cipherstate = (if v_113 then 2-proj-3-tuple(v_112) else caught-fail) in
        {357}let ssi_3: symmetricstate = (if v_113 then 1-proj-3-tuple(v_112) else caught-fail) in
        {358}let (hs_7: handshakestate,message_a_1: bitstring,cs1_5: cipherstate,cs2_5: cipherstate) = (if v_69 then (if v_71 then (if v_73 then (if v_74 then (if v_77 then (if v_85 then (if v_93 then (if v_107 then (if v_113 then (hs_6,message_buffer_1,cs1_4,cs2_4) else fail-any) else fail-any) else fail-any) else fail-any) else fail-any) else fail-any) else fail-any) else fail-any) else fail-any) in
        {359}event SendMsg(me_1,them_1,stagepack_a(sid_2),msg_a(me_1,them_1,sid_2));
        {360}out(pub, message_a_1)
    ) | (
        0
    )
) | (
    {362}let me_2: principal = bob in
    {363}let them_2: principal = alice in
    {364}let sid_3: sessionid = sid in
    {365}let basis_6: key = key_s(me_2) in
    {366}let public_key_6: key = catch-fail(dhexp(basis_6,validkey(g))) in
    {367}let v_114: bool = not-caught-fail(public_key_6) in
    {368}let s_4: keypair = (if v_114 then keypairpack(validkey(public_key_6),basis_6) else fail-any) in
    {369}let basis_7: key = key_m(me_2) in
    {370}let public_key_7: key = catch-fail(dhexp(basis_7,validkey(g))) in
    {371}let v_115: bool = not-caught-fail(public_key_7) in
    {372}let m_4: keypair = (if v_115 then keypairpack(validkey(public_key_7),basis_7) else fail-any) in
    {373}out(pub, (getpublickey(s_4),getpublickey(m_4)));
    (
        {374}let e_8: keypair = keypairpack(empty,empty) in
        {375}let rs_4: key = empty in
        {376}let rm_4: key = empty in
        {377}let re_4: key = empty in
        {378}let prologue_2: bitstring = empty in
        {379}let psk_4: key = empty in
        {380}let protocol_name_2: bitstring = somename in
        {381}let h_20: bitstring = hash(protocol_name_2,empty) in
        {382}let ck_24: key = h_20 in
        {383}let k_6: key = empty in
        {384}let cs_20: cipherstate = cipherstatepack(k_6,minnonce) in
        {385}let ss_20: symmetricstate = symmetricstatepack(cs_20,ck_24,h_20) in
        {386}let v_116: bitstring = catch-fail(symmetricstateunpack(ss_20)) in
        {387}let v_117: bool = (not-caught-fail(v_116) && success?(1-proj-3-tuple(v_116))) in
        {388}let h_21: bitstring = (if v_117 then 3-proj-3-tuple(v_116) else caught-fail) in
        {389}let ck_25: key = (if v_117 then 2-proj-3-tuple(v_116) else caught-fail) in
        {390}let cs_21: cipherstate = (if v_117 then 1-proj-3-tuple(v_116) else caught-fail) in
        {391}let ss_21: symmetricstate = catch-fail((if v_117 then symmetricstatepack(cs_21,ck_25,hash(h_21,prologue_2)) else fail-any)) in
        {392}let v_118: bool = not-caught-fail(ss_21) in
        {393}let data: bitstring = (if v_118 then catch-fail(getpublickey(s_4)) else caught-fail) in
        {394}let v_119: bool = not-caught-fail(data) in
        {395}let v_120: bitstring = (if v_119 then catch-fail(symmetricstateunpack(ss_21)) else caught-fail) in
        {396}let v_121: bool = (not-caught-fail(v_120) && success?(1-proj-3-tuple(v_120))) in
        {397}let h_22: bitstring = (if v_121 then 3-proj-3-tuple(v_120) else caught-fail) in
        {398}let ck_26: key = (if v_121 then 2-proj-3-tuple(v_120) else caught-fail) in
        {399}let cs_22: cipherstate = (if v_121 then 1-proj-3-tuple(v_120) else caught-fail) in
        {400}let ss_22: symmetricstate = (if v_118 then catch-fail((if v_119 then (if v_121 then symmetricstatepack(cs_22,ck_26,hash(h_22,data)) else fail-any) else fail-any)) else caught-fail) in
        {401}let v_122: bool = not-caught-fail(ss_22) in
        {402}let data_1: bitstring = (if v_122 then catch-fail(getpublickey(m_4)) else caught-fail) in
        {403}let v_123: bool = not-caught-fail(data_1) in
        {404}let v_124: bitstring = (if v_123 then catch-fail(symmetricstateunpack(ss_22)) else caught-fail) in
        {405}let v_125: bool = (not-caught-fail(v_124) && success?(1-proj-3-tuple(v_124))) in
        {406}let h_23: bitstring = (if v_125 then 3-proj-3-tuple(v_124) else caught-fail) in
        {407}let ck_27: key = (if v_125 then 2-proj-3-tuple(v_124) else caught-fail) in
        {408}let cs_23: cipherstate = (if v_125 then 1-proj-3-tuple(v_124) else caught-fail) in
        {409}let ss_23: symmetricstate = (if v_122 then catch-fail((if v_123 then (if v_125 then symmetricstatepack(cs_23,ck_27,hash(h_23,data_1)) else fail-any) else fail-any)) else caught-fail) in
        {410}let v_126: bool = not-caught-fail(ss_23) in
        {411}let hs_8: handshakestate = (if v_118 then (if v_122 then (if v_126 then handshakestatepack(ss_23,s_4,m_4,e_8,rs_4,rm_4,re_4,psk_4,false) else fail-any) else fail-any) else fail-any) in
        {412}insert statestore(me_2,them_2,sid_3,statepack_a(hs_8))
    ) | (
        {548}get statestore(=me_2,=them_2,=sid_3,statepack_a(hs_9: handshakestate)) in
        {413}in(pub, message_a_2: bitstring);
        {414}let v_127: bitstring = catch-fail(handshakestateunpack(hs_9)) in
        {415}let v_128: bool = (not-caught-fail(v_127) && success?(1-proj-9-tuple(v_127))) in
        {416}let initiator_3: bool = (if v_128 then 9-proj-9-tuple(v_127) else caught-fail) in
        {417}let psk_5: key = (if v_128 then 8-proj-9-tuple(v_127) else caught-fail) in
        {418}let re_5: key = (if v_128 then 7-proj-9-tuple(v_127) else caught-fail) in
        {419}let rm_5: key = (if v_128 then 6-proj-9-tuple(v_127) else caught-fail) in
        {420}let rs_5: key = (if v_128 then 5-proj-9-tuple(v_127) else caught-fail) in
        {421}let e_9: keypair = (if v_128 then 4-proj-9-tuple(v_127) else caught-fail) in
        {422}let m_5: keypair = (if v_128 then 3-proj-9-tuple(v_127) else caught-fail) in
        {423}let s_5: keypair = (if v_128 then 2-proj-9-tuple(v_127) else caught-fail) in
        {424}let ss_24: symmetricstate = (if v_128 then 1-proj-9-tuple(v_127) else caught-fail) in
        {425}let v_129: bitstring = (if v_128 then catch-fail(deconcat3(message_a_2)) else caught-fail) in
        {426}let v_130: bool = (not-caught-fail(v_129) && success?(1-proj-3-tuple(v_129))) in
        {427}let ciphertext_6: bitstring = (if v_130 then 3-proj-3-tuple(v_129) else caught-fail) in
        {428}let ns_2: bitstring = (if v_130 then 2-proj-3-tuple(v_129) else caught-fail) in
        {429}let ne_4: bitstring = (if v_130 then 1-proj-3-tuple(v_129) else caught-fail) in
        {430}let valid1: bool = (if v_130 then true else caught-fail) in
        {431}let re_6: key = (if v_130 then ne_4 else caught-fail) in
        {432}let v_131: bitstring = (if v_130 then catch-fail(symmetricstateunpack(ss_24)) else caught-fail) in
        {433}let v_132: bool = (not-caught-fail(v_131) && success?(1-proj-3-tuple(v_131))) in
        {434}let h_24: bitstring = (if v_132 then 3-proj-3-tuple(v_131) else caught-fail) in
        {435}let ck_28: key = (if v_132 then 2-proj-3-tuple(v_131) else caught-fail) in
        {436}let cs_24: cipherstate = (if v_132 then 1-proj-3-tuple(v_131) else caught-fail) in
        {437}let ss_25: symmetricstate = (if v_130 then catch-fail((if v_132 then symmetricstatepack(cs_24,ck_28,hash(h_24,re_6)) else fail-any)) else caught-fail) in
        {438}let v_133: bool = not-caught-fail(ss_25) in
        {439}let v_134: bitstring = (if v_133 then catch-fail(keypairunpack(s_5)) else caught-fail) in
        {440}let v_135: bool = (not-caught-fail(v_134) && success?(1-proj-2-tuple(v_134))) in
        {441}let my_private_key_4: key = (if v_135 then 2-proj-2-tuple(v_134) else caught-fail) in
        {442}let my_public_key_4: key = (if v_135 then 1-proj-2-tuple(v_134) else caught-fail) in
        {443}let input_key_material_6: key = (if v_133 then catch-fail((if v_135 then dhexp(my_private_key_4,re_6) else fail-any)) else caught-fail) in
        {444}let v_136: bool = not-caught-fail(input_key_material_6) in
        {445}let v_137: bitstring = (if v_136 then catch-fail(symmetricstateunpack(ss_25)) else caught-fail) in
        {446}let v_138: bool = (not-caught-fail(v_137) && success?(1-proj-3-tuple(v_137))) in
        {447}let h_25: bitstring = (if v_138 then 3-proj-3-tuple(v_137) else caught-fail) in
        {448}let ck_29: key = (if v_138 then 2-proj-3-tuple(v_137) else caught-fail) in
        {449}let cs_25: cipherstate = (if v_138 then 1-proj-3-tuple(v_137) else caught-fail) in
        {450}let output1_6: key = (if v_138 then hmac_hash1(ck_29,input_key_material_6) else caught-fail) in
        {451}let output2_6: key = (if v_138 then hmac_hash2(ck_29,input_key_material_6) else caught-fail) in
        {452}let output3_6: key = (if v_138 then hmac_hash3(ck_29,input_key_material_6) else caught-fail) in
        {453}let v_139: bitstring = (if v_138 then catch-fail((output1_6,output2_6,output3_6)) else caught-fail) in
        {454}let v_140: bool = (not-caught-fail(v_139) && success?(1-proj-3-tuple(v_139))) in
        {455}let output_4: key = (if v_140 then 3-proj-3-tuple(v_139) else caught-fail) in
        {456}let temp_k_4: key = (if v_140 then 2-proj-3-tuple(v_139) else caught-fail) in
        {457}let ck_30: key = (if v_140 then 1-proj-3-tuple(v_139) else caught-fail) in
        {458}let ss_26: symmetricstate = (if v_133 then catch-fail((if v_136 then (if v_138 then (if v_140 then symmetricstatepack(cipherstatepack(temp_k_4,minnonce),ck_30,h_25) else fail-any) else fail-any) else fail-any)) else caught-fail) in
        {459}let v_141: bool = not-caught-fail(ss_26) in
        {460}let v_142: bitstring = (if v_141 then catch-fail(keypairunpack(m_5)) else caught-fail) in
        {461}let v_143: bool = (not-caught-fail(v_142) && success?(1-proj-2-tuple(v_142))) in
        {462}let my_private_key_5: key = (if v_143 then 2-proj-2-tuple(v_142) else caught-fail) in
        {463}let my_public_key_5: key = (if v_143 then 1-proj-2-tuple(v_142) else caught-fail) in
        {464}let input_key_material_7: key = (if v_141 then catch-fail((if v_143 then dhexp(my_private_key_5,re_6) else fail-any)) else caught-fail) in
        {465}let v_144: bool = not-caught-fail(input_key_material_7) in
        {466}let v_145: bitstring = (if v_144 then catch-fail(symmetricstateunpack(ss_26)) else caught-fail) in
        {467}let v_146: bool = (not-caught-fail(v_145) && success?(1-proj-3-tuple(v_145))) in
        {468}let h_26: bitstring = (if v_146 then 3-proj-3-tuple(v_145) else caught-fail) in
        {469}let ck_31: key = (if v_146 then 2-proj-3-tuple(v_145) else caught-fail) in
        {470}let cs_26: cipherstate = (if v_146 then 1-proj-3-tuple(v_145) else caught-fail) in
        {471}let output1_7: key = (if v_146 then hmac_hash1(ck_31,input_key_material_7) else caught-fail) in
        {472}let output2_7: key = (if v_146 then hmac_hash2(ck_31,input_key_material_7) else caught-fail) in
        {473}let output3_7: key = (if v_146 then hmac_hash3(ck_31,input_key_material_7) else caught-fail) in
        {474}let v_147: bitstring = (if v_146 then catch-fail((output1_7,output2_7,output3_7)) else caught-fail) in
        {475}let v_148: bool = (not-caught-fail(v_147) && success?(1-proj-3-tuple(v_147))) in
        {476}let output_5: key = (if v_148 then 3-proj-3-tuple(v_147) else caught-fail) in
        {477}let temp_k_5: key = (if v_148 then 2-proj-3-tuple(v_147) else caught-fail) in
        {478}let ck_32: key = (if v_148 then 1-proj-3-tuple(v_147) else caught-fail) in
        {479}let ss_27: symmetricstate = (if v_141 then catch-fail((if v_144 then (if v_146 then (if v_148 then symmetricstatepack(cipherstatepack(temp_k_5,minnonce),ck_32,h_26) else fail-any) else fail-any) else fail-any)) else caught-fail) in
        {480}let v_149: bool = not-caught-fail(ss_27) in
        {481}let v_150: bitstring = (if v_149 then catch-fail(symmetricstateunpack(ss_27)) else caught-fail) in
        {482}let v_151: bool = (not-caught-fail(v_150) && success?(1-proj-3-tuple(v_150))) in
        {483}let h_27: bitstring = (if v_151 then 3-proj-3-tuple(v_150) else caught-fail) in
        {484}let ck_33: key = (if v_151 then 2-proj-3-tuple(v_150) else caught-fail) in
        {485}let cs_27: cipherstate = (if v_151 then 1-proj-3-tuple(v_150) else caught-fail) in
        {486}let v_152: bitstring = (if v_151 then catch-fail(cipherstateunpack(cs_27)) else caught-fail) in
        {487}let v_153: bool = (not-caught-fail(v_152) && success?(1-proj-2-tuple(v_152))) in
        {488}let n_4: nonce = (if v_153 then 2-proj-2-tuple(v_152) else caught-fail) in
        {489}let k_7: key = (if v_153 then 1-proj-2-tuple(v_152) else caught-fail) in
        {490}let d: aead = (if v_153 then catch-fail(decrypt(k_7,n_4,h_27,ciphertext_6)) else caught-fail) in
        {491}let v_154: bool = not-caught-fail(d) in
        {492}let v_155: bitstring = (if v_154 then catch-fail(aeadunpack(d)) else caught-fail) in
        {493}let v_156: bool = (not-caught-fail(v_155) && success?(1-proj-3-tuple(v_155))) in
        {494}let plaintext: bitstring = (if v_156 then 3-proj-3-tuple(v_155) else caught-fail) in
        {495}let adi: bitstring = (if v_156 then 2-proj-3-tuple(v_155) else caught-fail) in
        {496}let valid: bool = (if v_156 then 1-proj-3-tuple(v_155) else caught-fail) in
        {497}let n_5: nonce = (if v_156 then increment_nonce(n_4) else caught-fail) in
        {498}let v_157: bitstring = (if v_156 then catch-fail(cipherstateunpack(cs_27)) else caught-fail) in
        {499}let v_158: bool = (not-caught-fail(v_157) && success?(1-proj-2-tuple(v_157))) in
        {500}let o_2: nonce = (if v_158 then 2-proj-2-tuple(v_157) else caught-fail) in
        {501}let k_8: key = (if v_158 then 1-proj-2-tuple(v_157) else caught-fail) in
        {502}let csi_4: cipherstate = (if v_156 then catch-fail((if v_158 then cipherstatepack(k_8,n_5) else fail-any)) else caught-fail) in
        {503}let v_159: bool = not-caught-fail(csi_4) in
        {504}let v_160: bitstring = (if v_151 then catch-fail((if v_153 then (if v_154 then (if v_156 then (if v_159 then (csi_4,plaintext,valid) else fail-any) else fail-any) else fail-any) else fail-any)) else caught-fail) in
        {505}let v_161: bool = (not-caught-fail(v_160) && success?(1-proj-3-tuple(v_160))) in
        {506}let valid_1: bool = (if v_161 then 3-proj-3-tuple(v_160) else caught-fail) in
        {507}let plaintext_1: bitstring = (if v_161 then 2-proj-3-tuple(v_160) else caught-fail) in
        {508}let csi_5: cipherstate = (if v_161 then 1-proj-3-tuple(v_160) else caught-fail) in
        {509}let ss_28: symmetricstate = (if v_161 then symmetricstatepack(csi_5,ck_33,h_27) else caught-fail) in
        {510}let v_162: bitstring = (if v_161 then catch-fail(symmetricstateunpack(ss_28)) else caught-fail) in
        {511}let v_163: bool = (not-caught-fail(v_162) && success?(1-proj-3-tuple(v_162))) in
        {512}let h_28: bitstring = (if v_163 then 3-proj-3-tuple(v_162) else caught-fail) in
        {513}let ck_34: key = (if v_163 then 2-proj-3-tuple(v_162) else caught-fail) in
        {514}let cs_28: cipherstate = (if v_163 then 1-proj-3-tuple(v_162) else caught-fail) in
        {515}let ssi_4: symmetricstate = (if v_161 then catch-fail((if v_163 then symmetricstatepack(cs_28,ck_34,hash(h_28,ciphertext_6)) else fail-any)) else caught-fail) in
        {516}let v_164: bool = not-caught-fail(ssi_4) in
        {517}let v_165: bitstring = (if v_149 then catch-fail((if v_151 then (if v_161 then (if v_164 then (ssi_4,plaintext_1,valid_1) else fail-any) else fail-any) else fail-any)) else caught-fail) in
        {518}let v_166: bool = (not-caught-fail(v_165) && success?(1-proj-3-tuple(v_165))) in
        {519}let valid2: bool = (if v_166 then 3-proj-3-tuple(v_165) else caught-fail) in
        {520}let plaintext_2: bitstring = (if v_166 then 2-proj-3-tuple(v_165) else caught-fail) in
        {521}let ss_29: symmetricstate = (if v_166 then 1-proj-3-tuple(v_165) else caught-fail) in
        {522}let v_167: bool = (if v_166 then catch-fail((valid1 && valid2)) else caught-fail) in
        {523}let hs_10: handshakestate = (if v_167 then handshakestatepack(ss_29,s_5,m_5,e_9,rs_5,rm_5,re_6,psk_5,initiator_3) else caught-fail) in
        {524}let v_168: bitstring = (if v_167 then catch-fail(symmetricstateunpack(ss_29)) else caught-fail) in
        {525}let v_169: bool = (not-caught-fail(v_168) && success?(1-proj-3-tuple(v_168))) in
        {526}let h_29: bitstring = (if v_169 then 3-proj-3-tuple(v_168) else caught-fail) in
        {527}let ck_35: key = (if v_169 then 2-proj-3-tuple(v_168) else caught-fail) in
        {528}let cs_29: cipherstate = (if v_169 then 1-proj-3-tuple(v_168) else caught-fail) in
        {529}let input_key_material_8: key = (if v_169 then zero else caught-fail) in
        {530}let output1_8: key = (if v_169 then hmac_hash1(ck_35,input_key_material_8) else caught-fail) in
        {531}let output2_8: key = (if v_169 then hmac_hash2(ck_35,input_key_material_8) else caught-fail) in
        {532}let output3_8: key = (if v_169 then hmac_hash3(ck_35,input_key_material_8) else caught-fail) in
        {533}let v_170: bitstring = (if v_169 then catch-fail((output1_8,output2_8,output3_8)) else caught-fail) in
        {534}let v_171: bool = (not-caught-fail(v_170) && success?(1-proj-3-tuple(v_170))) in
        {535}let temp_k3_2: key = (if v_171 then 3-proj-3-tuple(v_170) else caught-fail) in
        {536}let temp_k2_2: key = (if v_171 then 2-proj-3-tuple(v_170) else caught-fail) in
        {537}let temp_k1_2: key = (if v_171 then 1-proj-3-tuple(v_170) else caught-fail) in
        {538}let cs1_6: cipherstate = (if v_171 then cipherstatepack(temp_k1_2,minnonce) else caught-fail) in
        {539}let cs2_6: cipherstate = (if v_171 then cipherstatepack(temp_k2_2,minnonce) else caught-fail) in
        {540}let v_172: bitstring = (if v_167 then catch-fail((if v_169 then (if v_171 then (ss_29,cs1_6,cs2_6) else fail-any) else fail-any)) else caught-fail) in
        {541}let v_173: bool = (not-caught-fail(v_172) && success?(1-proj-3-tuple(v_172))) in
        {542}let cs2_7: cipherstate = (if v_173 then 3-proj-3-tuple(v_172) else caught-fail) in
        {543}let cs1_7: cipherstate = (if v_173 then 2-proj-3-tuple(v_172) else caught-fail) in
        {544}let ssi_5: symmetricstate = (if v_173 then 1-proj-3-tuple(v_172) else caught-fail) in
        {545}let (hs_11: handshakestate,plaintext_a: bitstring,valid_2: bool,cs1_8: cipherstate,cs2_8: cipherstate) = (if v_128 then (if v_130 then (if v_133 then (if v_141 then (if v_149 then (if v_166 then (if undo-catch-fail(v_167) then (if v_173 then (hs_10,plaintext_2,true,cs1_7,cs2_7) else fail-any) else fail-any) else fail-any) else fail-any) else fail-any) else fail-any) else fail-any) else fail-any) in
        {546}event RecvMsg(me_2,them_2,stagepack_a(sid_3),plaintext_a);
        {547}event RecvEnd(valid_2)
    ) | (
        {549}event LeakS(phase0,me_2);
        {550}event LeakM(phase0,me_2);
        {551}out(pub, (key_s(me_2),key_m(me_2)))
    ) | (
        {552}phase 1;
        {553}event LeakS(phase1,me_2);
        {554}event LeakM(phase1,me_2);
        {555}out(pub, (key_s(me_2),key_m(me_2)))
    )
) | (
    {556}let me_3: principal = bob in
    {557}let them_3: principal = charlie in
    {558}let sid_4: sessionid = sid in
    {559}let basis_8: key = key_s(me_3) in
    {560}let public_key_8: key = catch-fail(dhexp(basis_8,validkey(g))) in
    {561}let v_174: bool = not-caught-fail(public_key_8) in
    {562}let s_6: keypair = (if v_174 then keypairpack(validkey(public_key_8),basis_8) else fail-any) in
    {563}let basis_9: key = key_m(me_3) in
    {564}let public_key_9: key = catch-fail(dhexp(basis_9,validkey(g))) in
    {565}let v_175: bool = not-caught-fail(public_key_9) in
    {566}let m_6: keypair = (if v_175 then keypairpack(validkey(public_key_9),basis_9) else fail-any) in
    {567}out(pub, (getpublickey(s_6),getpublickey(m_6)));
    (
        {568}let e_10: keypair = keypairpack(empty,empty) in
        {569}let rs_6: key = empty in
        {570}let rm_6: key = empty in
        {571}let re_7: key = empty in
        {572}let prologue_3: bitstring = empty in
        {573}let psk_6: key = empty in
        {574}let protocol_name_3: bitstring = somename in
        {575}let h_30: bitstring = hash(protocol_name_3,empty) in
        {576}let ck_36: key = h_30 in
        {577}let k_9: key = empty in
        {578}let cs_30: cipherstate = cipherstatepack(k_9,minnonce) in
        {579}let ss_30: symmetricstate = symmetricstatepack(cs_30,ck_36,h_30) in
        {580}let v_176: bitstring = catch-fail(symmetricstateunpack(ss_30)) in
        {581}let v_177: bool = (not-caught-fail(v_176) && success?(1-proj-3-tuple(v_176))) in
        {582}let h_31: bitstring = (if v_177 then 3-proj-3-tuple(v_176) else caught-fail) in
        {583}let ck_37: key = (if v_177 then 2-proj-3-tuple(v_176) else caught-fail) in
        {584}let cs_31: cipherstate = (if v_177 then 1-proj-3-tuple(v_176) else caught-fail) in
        {585}let ss_31: symmetricstate = catch-fail((if v_177 then symmetricstatepack(cs_31,ck_37,hash(h_31,prologue_3)) else fail-any)) in
        {586}let v_178: bool = not-caught-fail(ss_31) in
        {587}let data_2: bitstring = (if v_178 then catch-fail(getpublickey(s_6)) else caught-fail) in
        {588}let v_179: bool = not-caught-fail(data_2) in
        {589}let v_180: bitstring = (if v_179 then catch-fail(symmetricstateunpack(ss_31)) else caught-fail) in
        {590}let v_181: bool = (not-caught-fail(v_180) && success?(1-proj-3-tuple(v_180))) in
        {591}let h_32: bitstring = (if v_181 then 3-proj-3-tuple(v_180) else caught-fail) in
        {592}let ck_38: key = (if v_181 then 2-proj-3-tuple(v_180) else caught-fail) in
        {593}let cs_32: cipherstate = (if v_181 then 1-proj-3-tuple(v_180) else caught-fail) in
        {594}let ss_32: symmetricstate = (if v_178 then catch-fail((if v_179 then (if v_181 then symmetricstatepack(cs_32,ck_38,hash(h_32,data_2)) else fail-any) else fail-any)) else caught-fail) in
        {595}let v_182: bool = not-caught-fail(ss_32) in
        {596}let data_3: bitstring = (if v_182 then catch-fail(getpublickey(m_6)) else caught-fail) in
        {597}let v_183: bool = not-caught-fail(data_3) in
        {598}let v_184: bitstring = (if v_183 then catch-fail(symmetricstateunpack(ss_32)) else caught-fail) in
        {599}let v_185: bool = (not-caught-fail(v_184) && success?(1-proj-3-tuple(v_184))) in
        {600}let h_33: bitstring = (if v_185 then 3-proj-3-tuple(v_184) else caught-fail) in
        {601}let ck_39: key = (if v_185 then 2-proj-3-tuple(v_184) else caught-fail) in
        {602}let cs_33: cipherstate = (if v_185 then 1-proj-3-tuple(v_184) else caught-fail) in
        {603}let ss_33: symmetricstate = (if v_182 then catch-fail((if v_183 then (if v_185 then symmetricstatepack(cs_33,ck_39,hash(h_33,data_3)) else fail-any) else fail-any)) else caught-fail) in
        {604}let v_186: bool = not-caught-fail(ss_33) in
        {605}let hs_12: handshakestate = (if v_178 then (if v_182 then (if v_186 then handshakestatepack(ss_33,s_6,m_6,e_10,rs_6,rm_6,re_7,psk_6,false) else fail-any) else fail-any) else fail-any) in
        {606}insert statestore(me_3,them_3,sid_4,statepack_a(hs_12))
    ) | (
        {742}get statestore(=me_3,=them_3,=sid_4,statepack_a(hs_13: handshakestate)) in
        {607}in(pub, message_a_3: bitstring);
        {608}let v_187: bitstring = catch-fail(handshakestateunpack(hs_13)) in
        {609}let v_188: bool = (not-caught-fail(v_187) && success?(1-proj-9-tuple(v_187))) in
        {610}let initiator_4: bool = (if v_188 then 9-proj-9-tuple(v_187) else caught-fail) in
        {611}let psk_7: key = (if v_188 then 8-proj-9-tuple(v_187) else caught-fail) in
        {612}let re_8: key = (if v_188 then 7-proj-9-tuple(v_187) else caught-fail) in
        {613}let rm_7: key = (if v_188 then 6-proj-9-tuple(v_187) else caught-fail) in
        {614}let rs_7: key = (if v_188 then 5-proj-9-tuple(v_187) else caught-fail) in
        {615}let e_11: keypair = (if v_188 then 4-proj-9-tuple(v_187) else caught-fail) in
        {616}let m_7: keypair = (if v_188 then 3-proj-9-tuple(v_187) else caught-fail) in
        {617}let s_7: keypair = (if v_188 then 2-proj-9-tuple(v_187) else caught-fail) in
        {618}let ss_34: symmetricstate = (if v_188 then 1-proj-9-tuple(v_187) else caught-fail) in
        {619}let v_189: bitstring = (if v_188 then catch-fail(deconcat3(message_a_3)) else caught-fail) in
        {620}let v_190: bool = (not-caught-fail(v_189) && success?(1-proj-3-tuple(v_189))) in
        {621}let ciphertext_7: bitstring = (if v_190 then 3-proj-3-tuple(v_189) else caught-fail) in
        {622}let ns_3: bitstring = (if v_190 then 2-proj-3-tuple(v_189) else caught-fail) in
        {623}let ne_5: bitstring = (if v_190 then 1-proj-3-tuple(v_189) else caught-fail) in
        {624}let valid1_1: bool = (if v_190 then true else caught-fail) in
        {625}let re_9: key = (if v_190 then ne_5 else caught-fail) in
        {626}let v_191: bitstring = (if v_190 then catch-fail(symmetricstateunpack(ss_34)) else caught-fail) in
        {627}let v_192: bool = (not-caught-fail(v_191) && success?(1-proj-3-tuple(v_191))) in
        {628}let h_34: bitstring = (if v_192 then 3-proj-3-tuple(v_191) else caught-fail) in
        {629}let ck_40: key = (if v_192 then 2-proj-3-tuple(v_191) else caught-fail) in
        {630}let cs_34: cipherstate = (if v_192 then 1-proj-3-tuple(v_191) else caught-fail) in
        {631}let ss_35: symmetricstate = (if v_190 then catch-fail((if v_192 then symmetricstatepack(cs_34,ck_40,hash(h_34,re_9)) else fail-any)) else caught-fail) in
        {632}let v_193: bool = not-caught-fail(ss_35) in
        {633}let v_194: bitstring = (if v_193 then catch-fail(keypairunpack(s_7)) else caught-fail) in
        {634}let v_195: bool = (not-caught-fail(v_194) && success?(1-proj-2-tuple(v_194))) in
        {635}let my_private_key_6: key = (if v_195 then 2-proj-2-tuple(v_194) else caught-fail) in
        {636}let my_public_key_6: key = (if v_195 then 1-proj-2-tuple(v_194) else caught-fail) in
        {637}let input_key_material_9: key = (if v_193 then catch-fail((if v_195 then dhexp(my_private_key_6,re_9) else fail-any)) else caught-fail) in
        {638}let v_196: bool = not-caught-fail(input_key_material_9) in
        {639}let v_197: bitstring = (if v_196 then catch-fail(symmetricstateunpack(ss_35)) else caught-fail) in
        {640}let v_198: bool = (not-caught-fail(v_197) && success?(1-proj-3-tuple(v_197))) in
        {641}let h_35: bitstring = (if v_198 then 3-proj-3-tuple(v_197) else caught-fail) in
        {642}let ck_41: key = (if v_198 then 2-proj-3-tuple(v_197) else caught-fail) in
        {643}let cs_35: cipherstate = (if v_198 then 1-proj-3-tuple(v_197) else caught-fail) in
        {644}let output1_9: key = (if v_198 then hmac_hash1(ck_41,input_key_material_9) else caught-fail) in
        {645}let output2_9: key = (if v_198 then hmac_hash2(ck_41,input_key_material_9) else caught-fail) in
        {646}let output3_9: key = (if v_198 then hmac_hash3(ck_41,input_key_material_9) else caught-fail) in
        {647}let v_199: bitstring = (if v_198 then catch-fail((output1_9,output2_9,output3_9)) else caught-fail) in
        {648}let v_200: bool = (not-caught-fail(v_199) && success?(1-proj-3-tuple(v_199))) in
        {649}let output_6: key = (if v_200 then 3-proj-3-tuple(v_199) else caught-fail) in
        {650}let temp_k_6: key = (if v_200 then 2-proj-3-tuple(v_199) else caught-fail) in
        {651}let ck_42: key = (if v_200 then 1-proj-3-tuple(v_199) else caught-fail) in
        {652}let ss_36: symmetricstate = (if v_193 then catch-fail((if v_196 then (if v_198 then (if v_200 then symmetricstatepack(cipherstatepack(temp_k_6,minnonce),ck_42,h_35) else fail-any) else fail-any) else fail-any)) else caught-fail) in
        {653}let v_201: bool = not-caught-fail(ss_36) in
        {654}let v_202: bitstring = (if v_201 then catch-fail(keypairunpack(m_7)) else caught-fail) in
        {655}let v_203: bool = (not-caught-fail(v_202) && success?(1-proj-2-tuple(v_202))) in
        {656}let my_private_key_7: key = (if v_203 then 2-proj-2-tuple(v_202) else caught-fail) in
        {657}let my_public_key_7: key = (if v_203 then 1-proj-2-tuple(v_202) else caught-fail) in
        {658}let input_key_material_10: key = (if v_201 then catch-fail((if v_203 then dhexp(my_private_key_7,re_9) else fail-any)) else caught-fail) in
        {659}let v_204: bool = not-caught-fail(input_key_material_10) in
        {660}let v_205: bitstring = (if v_204 then catch-fail(symmetricstateunpack(ss_36)) else caught-fail) in
        {661}let v_206: bool = (not-caught-fail(v_205) && success?(1-proj-3-tuple(v_205))) in
        {662}let h_36: bitstring = (if v_206 then 3-proj-3-tuple(v_205) else caught-fail) in
        {663}let ck_43: key = (if v_206 then 2-proj-3-tuple(v_205) else caught-fail) in
        {664}let cs_36: cipherstate = (if v_206 then 1-proj-3-tuple(v_205) else caught-fail) in
        {665}let output1_10: key = (if v_206 then hmac_hash1(ck_43,input_key_material_10) else caught-fail) in
        {666}let output2_10: key = (if v_206 then hmac_hash2(ck_43,input_key_material_10) else caught-fail) in
        {667}let output3_10: key = (if v_206 then hmac_hash3(ck_43,input_key_material_10) else caught-fail) in
        {668}let v_207: bitstring = (if v_206 then catch-fail((output1_10,output2_10,output3_10)) else caught-fail) in
        {669}let v_208: bool = (not-caught-fail(v_207) && success?(1-proj-3-tuple(v_207))) in
        {670}let output_7: key = (if v_208 then 3-proj-3-tuple(v_207) else caught-fail) in
        {671}let temp_k_7: key = (if v_208 then 2-proj-3-tuple(v_207) else caught-fail) in
        {672}let ck_44: key = (if v_208 then 1-proj-3-tuple(v_207) else caught-fail) in
        {673}let ss_37: symmetricstate = (if v_201 then catch-fail((if v_204 then (if v_206 then (if v_208 then symmetricstatepack(cipherstatepack(temp_k_7,minnonce),ck_44,h_36) else fail-any) else fail-any) else fail-any)) else caught-fail) in
        {674}let v_209: bool = not-caught-fail(ss_37) in
        {675}let v_210: bitstring = (if v_209 then catch-fail(symmetricstateunpack(ss_37)) else caught-fail) in
        {676}let v_211: bool = (not-caught-fail(v_210) && success?(1-proj-3-tuple(v_210))) in
        {677}let h_37: bitstring = (if v_211 then 3-proj-3-tuple(v_210) else caught-fail) in
        {678}let ck_45: key = (if v_211 then 2-proj-3-tuple(v_210) else caught-fail) in
        {679}let cs_37: cipherstate = (if v_211 then 1-proj-3-tuple(v_210) else caught-fail) in
        {680}let v_212: bitstring = (if v_211 then catch-fail(cipherstateunpack(cs_37)) else caught-fail) in
        {681}let v_213: bool = (not-caught-fail(v_212) && success?(1-proj-2-tuple(v_212))) in
        {682}let n_6: nonce = (if v_213 then 2-proj-2-tuple(v_212) else caught-fail) in
        {683}let k_10: key = (if v_213 then 1-proj-2-tuple(v_212) else caught-fail) in
        {684}let d_1: aead = (if v_213 then catch-fail(decrypt(k_10,n_6,h_37,ciphertext_7)) else caught-fail) in
        {685}let v_214: bool = not-caught-fail(d_1) in
        {686}let v_215: bitstring = (if v_214 then catch-fail(aeadunpack(d_1)) else caught-fail) in
        {687}let v_216: bool = (not-caught-fail(v_215) && success?(1-proj-3-tuple(v_215))) in
        {688}let plaintext_3: bitstring = (if v_216 then 3-proj-3-tuple(v_215) else caught-fail) in
        {689}let adi_1: bitstring = (if v_216 then 2-proj-3-tuple(v_215) else caught-fail) in
        {690}let valid_3: bool = (if v_216 then 1-proj-3-tuple(v_215) else caught-fail) in
        {691}let n_7: nonce = (if v_216 then increment_nonce(n_6) else caught-fail) in
        {692}let v_217: bitstring = (if v_216 then catch-fail(cipherstateunpack(cs_37)) else caught-fail) in
        {693}let v_218: bool = (not-caught-fail(v_217) && success?(1-proj-2-tuple(v_217))) in
        {694}let o_3: nonce = (if v_218 then 2-proj-2-tuple(v_217) else caught-fail) in
        {695}let k_11: key = (if v_218 then 1-proj-2-tuple(v_217) else caught-fail) in
        {696}let csi_6: cipherstate = (if v_216 then catch-fail((if v_218 then cipherstatepack(k_11,n_7) else fail-any)) else caught-fail) in
        {697}let v_219: bool = not-caught-fail(csi_6) in
        {698}let v_220: bitstring = (if v_211 then catch-fail((if v_213 then (if v_214 then (if v_216 then (if v_219 then (csi_6,plaintext_3,valid_3) else fail-any) else fail-any) else fail-any) else fail-any)) else caught-fail) in
        {699}let v_221: bool = (not-caught-fail(v_220) && success?(1-proj-3-tuple(v_220))) in
        {700}let valid_4: bool = (if v_221 then 3-proj-3-tuple(v_220) else caught-fail) in
        {701}let plaintext_4: bitstring = (if v_221 then 2-proj-3-tuple(v_220) else caught-fail) in
        {702}let csi_7: cipherstate = (if v_221 then 1-proj-3-tuple(v_220) else caught-fail) in
        {703}let ss_38: symmetricstate = (if v_221 then symmetricstatepack(csi_7,ck_45,h_37) else caught-fail) in
        {704}let v_222: bitstring = (if v_221 then catch-fail(symmetricstateunpack(ss_38)) else caught-fail) in
        {705}let v_223: bool = (not-caught-fail(v_222) && success?(1-proj-3-tuple(v_222))) in
        {706}let h_38: bitstring = (if v_223 then 3-proj-3-tuple(v_222) else caught-fail) in
        {707}let ck_46: key = (if v_223 then 2-proj-3-tuple(v_222) else caught-fail) in
        {708}let cs_38: cipherstate = (if v_223 then 1-proj-3-tuple(v_222) else caught-fail) in
        {709}let ssi_6: symmetricstate = (if v_221 then catch-fail((if v_223 then symmetricstatepack(cs_38,ck_46,hash(h_38,ciphertext_7)) else fail-any)) else caught-fail) in
        {710}let v_224: bool = not-caught-fail(ssi_6) in
        {711}let v_225: bitstring = (if v_209 then catch-fail((if v_211 then (if v_221 then (if v_224 then (ssi_6,plaintext_4,valid_4) else fail-any) else fail-any) else fail-any)) else caught-fail) in
        {712}let v_226: bool = (not-caught-fail(v_225) && success?(1-proj-3-tuple(v_225))) in
        {713}let valid2_1: bool = (if v_226 then 3-proj-3-tuple(v_225) else caught-fail) in
        {714}let plaintext_5: bitstring = (if v_226 then 2-proj-3-tuple(v_225) else caught-fail) in
        {715}let ss_39: symmetricstate = (if v_226 then 1-proj-3-tuple(v_225) else caught-fail) in
        {716}let v_227: bool = (if v_226 then catch-fail((valid1_1 && valid2_1)) else caught-fail) in
        {717}let hs_14: handshakestate = (if v_227 then handshakestatepack(ss_39,s_7,m_7,e_11,rs_7,rm_7,re_9,psk_7,initiator_4) else caught-fail) in
        {718}let v_228: bitstring = (if v_227 then catch-fail(symmetricstateunpack(ss_39)) else caught-fail) in
        {719}let v_229: bool = (not-caught-fail(v_228) && success?(1-proj-3-tuple(v_228))) in
        {720}let h_39: bitstring = (if v_229 then 3-proj-3-tuple(v_228) else caught-fail) in
        {721}let ck_47: key = (if v_229 then 2-proj-3-tuple(v_228) else caught-fail) in
        {722}let cs_39: cipherstate = (if v_229 then 1-proj-3-tuple(v_228) else caught-fail) in
        {723}let input_key_material_11: key = (if v_229 then zero else caught-fail) in
        {724}let output1_11: key = (if v_229 then hmac_hash1(ck_47,input_key_material_11) else caught-fail) in
        {725}let output2_11: key = (if v_229 then hmac_hash2(ck_47,input_key_material_11) else caught-fail) in
        {726}let output3_11: key = (if v_229 then hmac_hash3(ck_47,input_key_material_11) else caught-fail) in
        {727}let v_230: bitstring = (if v_229 then catch-fail((output1_11,output2_11,output3_11)) else caught-fail) in
        {728}let v_231: bool = (not-caught-fail(v_230) && success?(1-proj-3-tuple(v_230))) in
        {729}let temp_k3_3: key = (if v_231 then 3-proj-3-tuple(v_230) else caught-fail) in
        {730}let temp_k2_3: key = (if v_231 then 2-proj-3-tuple(v_230) else caught-fail) in
        {731}let temp_k1_3: key = (if v_231 then 1-proj-3-tuple(v_230) else caught-fail) in
        {732}let cs1_9: cipherstate = (if v_231 then cipherstatepack(temp_k1_3,minnonce) else caught-fail) in
        {733}let cs2_9: cipherstate = (if v_231 then cipherstatepack(temp_k2_3,minnonce) else caught-fail) in
        {734}let v_232: bitstring = (if v_227 then catch-fail((if v_229 then (if v_231 then (ss_39,cs1_9,cs2_9) else fail-any) else fail-any)) else caught-fail) in
        {735}let v_233: bool = (not-caught-fail(v_232) && success?(1-proj-3-tuple(v_232))) in
        {736}let cs2_10: cipherstate = (if v_233 then 3-proj-3-tuple(v_232) else caught-fail) in
        {737}let cs1_10: cipherstate = (if v_233 then 2-proj-3-tuple(v_232) else caught-fail) in
        {738}let ssi_7: symmetricstate = (if v_233 then 1-proj-3-tuple(v_232) else caught-fail) in
        {739}let (hs_15: handshakestate,plaintext_a_1: bitstring,valid_5: bool,cs1_11: cipherstate,cs2_11: cipherstate) = (if v_188 then (if v_190 then (if v_193 then (if v_201 then (if v_209 then (if v_226 then (if undo-catch-fail(v_227) then (if v_233 then (hs_14,plaintext_5,true,cs1_10,cs2_10) else fail-any) else fail-any) else fail-any) else fail-any) else fail-any) else fail-any) else fail-any) else fail-any) in
        {740}event RecvMsg(me_3,them_3,stagepack_a(sid_4),plaintext_a_1);
        {741}event RecvEnd(valid_5)
    ) | (
        {743}event LeakS(phase0,me_3);
        {744}event LeakM(phase0,me_3);
        {745}out(pub, (key_s(me_3),key_m(me_3)))
    ) | (
        {746}phase 1;
        {747}event LeakS(phase1,me_3);
        {748}event LeakM(phase1,me_3);
        {749}out(pub, (key_s(me_3),key_m(me_3)))
    )
)

--  Process 1 (that is, process 0, with let moved downwards):
{1}out(pub, (key_s(charlie),key_m(charlie)));
{2}!
{3}new sid: sessionid;
(
    {6}let sid_1: sessionid = sid in
    {5}let them: principal = bob in
    {4}let me: principal = alice in
    (
        {10}let basis: key = key_s(them) in
        {11}let public_key: key = catch-fail(dhexp(basis,validkey(g))) in
        {12}let v: bool = not-caught-fail(public_key) in
        {13}let rs: key = getpublickey((if v then keypairpack(validkey(public_key),basis) else fail-any)) in
        {14}let basis_1: key = key_m(them) in
        {15}let public_key_1: key = catch-fail(dhexp(basis_1,validkey(g))) in
        {16}let v_1: bool = not-caught-fail(public_key_1) in
        {17}let rm: key = getpublickey((if v_1 then keypairpack(validkey(public_key_1),basis_1) else fail-any)) in
        {24}let k: key = empty in
        {25}let cs: cipherstate = cipherstatepack(k,minnonce) in
        {21}let protocol_name: bitstring = somename in
        {22}let h: bitstring = hash(protocol_name,empty) in
        {23}let ck: key = h in
        {26}let ss: symmetricstate = symmetricstatepack(cs,ck,h) in
        {27}let v_2: bitstring = catch-fail(symmetricstateunpack(ss)) in
        {28}let v_3: bool = (not-caught-fail(v_2) && success?(1-proj-3-tuple(v_2))) in
        {29}let h_1: bitstring = (if v_3 then 3-proj-3-tuple(v_2) else caught-fail) in
        {30}let ck_1: key = (if v_3 then 2-proj-3-tuple(v_2) else caught-fail) in
        {31}let cs_1: cipherstate = (if v_3 then 1-proj-3-tuple(v_2) else caught-fail) in
        {19}let prologue: bitstring = empty in
        {32}let ss_1: symmetricstate = catch-fail((if v_3 then symmetricstatepack(cs_1,ck_1,hash(h_1,prologue)) else fail-any)) in
        {33}let v_4: bool = not-caught-fail(ss_1) in
        {34}let v_5: bitstring = (if v_4 then catch-fail(symmetricstateunpack(ss_1)) else caught-fail) in
        {35}let v_6: bool = (not-caught-fail(v_5) && success?(1-proj-3-tuple(v_5))) in
        {36}let h_2: bitstring = (if v_6 then 3-proj-3-tuple(v_5) else caught-fail) in
        {37}let ck_2: key = (if v_6 then 2-proj-3-tuple(v_5) else caught-fail) in
        {38}let cs_2: cipherstate = (if v_6 then 1-proj-3-tuple(v_5) else caught-fail) in
        {39}let ss_2: symmetricstate = (if v_4 then catch-fail((if v_6 then symmetricstatepack(cs_2,ck_2,hash(h_2,rs)) else fail-any)) else caught-fail) in
        {40}let v_7: bool = not-caught-fail(ss_2) in
        {41}let v_8: bitstring = (if v_7 then catch-fail(symmetricstateunpack(ss_2)) else caught-fail) in
        {42}let v_9: bool = (not-caught-fail(v_8) && success?(1-proj-3-tuple(v_8))) in
        {43}let h_3: bitstring = (if v_9 then 3-proj-3-tuple(v_8) else caught-fail) in
        {44}let ck_3: key = (if v_9 then 2-proj-3-tuple(v_8) else caught-fail) in
        {45}let cs_3: cipherstate = (if v_9 then 1-proj-3-tuple(v_8) else caught-fail) in
        {46}let ss_3: symmetricstate = (if v_7 then catch-fail((if v_9 then symmetricstatepack(cs_3,ck_3,hash(h_3,rm)) else fail-any)) else caught-fail) in
        {47}let v_10: bool = not-caught-fail(ss_3) in
        {20}let psk: key = empty in
        {18}let re: key = empty in
        {9}let e: keypair = keypairpack(empty,empty) in
        {8}let m: keypair = keypairpack(empty,empty) in
        {7}let s: keypair = keypairpack(empty,empty) in
        {48}let hs: handshakestate = (if v_4 then (if v_7 then (if v_10 then handshakestatepack(ss_3,s,m,e,rs,rm,re,psk,true) else fail-any) else fail-any) else fail-any) in
        {49}insert statestore(me,them,sid_1,statepack_a(hs))
    ) | (
        {182}get statestore(=me,=them,=sid_1,statepack_a(hs_1: handshakestate)) in
        {51}let v_11: bitstring = catch-fail(handshakestateunpack(hs_1)) in
        {52}let v_12: bool = (not-caught-fail(v_11) && success?(1-proj-9-tuple(v_11))) in
        {53}let initiator_1: bool = (if v_12 then 9-proj-9-tuple(v_11) else caught-fail) in
        {54}let psk_1: key = (if v_12 then 8-proj-9-tuple(v_11) else caught-fail) in
        {55}let re_1: key = (if v_12 then 7-proj-9-tuple(v_11) else caught-fail) in
        {56}let rm_1: key = (if v_12 then 6-proj-9-tuple(v_11) else caught-fail) in
        {57}let rs_1: key = (if v_12 then 5-proj-9-tuple(v_11) else caught-fail) in
        {58}let e_1: keypair = (if v_12 then 4-proj-9-tuple(v_11) else caught-fail) in
        {59}let m_1: keypair = (if v_12 then 3-proj-9-tuple(v_11) else caught-fail) in
        {60}let s_1: keypair = (if v_12 then 2-proj-9-tuple(v_11) else caught-fail) in
        {61}let ss_4: symmetricstate = (if v_12 then 1-proj-9-tuple(v_11) else caught-fail) in
        {62}let v_13: bitstring = (if v_12 then catch-fail((empty,empty,empty)) else caught-fail) in
        {63}let v_14: bool = (not-caught-fail(v_13) && success?(1-proj-3-tuple(v_13))) in
        {64}let ciphertext: bitstring = (if v_14 then 3-proj-3-tuple(v_13) else caught-fail) in
        {65}let ns: bitstring = (if v_14 then 2-proj-3-tuple(v_13) else caught-fail) in
        {66}let ne: bitstring = (if v_14 then 1-proj-3-tuple(v_13) else caught-fail) in
        {67}let basis_2: key = (if v_14 then key_e(me,them,sid_1) else caught-fail) in
        {68}let public_key_2: key = (if v_14 then catch-fail(dhexp(basis_2,validkey(g))) else caught-fail) in
        {69}let v_15: bool = not-caught-fail(public_key_2) in
        {70}let e_2: keypair = (if v_14 then catch-fail((if v_15 then keypairpack(validkey(public_key_2),basis_2) else fail-any)) else caught-fail) in
        {71}let v_16: bool = not-caught-fail(e_2) in
        {72}let ne_1: bitstring = (if v_16 then catch-fail(getpublickey(e_2)) else caught-fail) in
        {73}let v_17: bool = not-caught-fail(ne_1) in
        {74}let v_18: bitstring = (if v_17 then catch-fail(symmetricstateunpack(ss_4)) else caught-fail) in
        {75}let v_19: bool = (not-caught-fail(v_18) && success?(1-proj-3-tuple(v_18))) in
        {76}let h_4: bitstring = (if v_19 then 3-proj-3-tuple(v_18) else caught-fail) in
        {77}let ck_4: key = (if v_19 then 2-proj-3-tuple(v_18) else caught-fail) in
        {78}let cs_4: cipherstate = (if v_19 then 1-proj-3-tuple(v_18) else caught-fail) in
        {79}let ss_5: symmetricstate = (if v_17 then catch-fail((if v_19 then symmetricstatepack(cs_4,ck_4,hash(h_4,ne_1)) else fail-any)) else caught-fail) in
        {80}let v_20: bool = not-caught-fail(ss_5) in
        {81}let v_21: bitstring = (if v_20 then catch-fail(keypairunpack(e_2)) else caught-fail) in
        {82}let v_22: bool = (not-caught-fail(v_21) && success?(1-proj-2-tuple(v_21))) in
        {83}let my_private_key: key = (if v_22 then 2-proj-2-tuple(v_21) else caught-fail) in
        {84}let my_public_key: key = (if v_22 then 1-proj-2-tuple(v_21) else caught-fail) in
        {85}let input_key_material: key = (if v_20 then catch-fail((if v_22 then dhexp(my_private_key,rs_1) else fail-any)) else caught-fail) in
        {86}let v_23: bool = not-caught-fail(input_key_material) in
        {87}let v_24: bitstring = (if v_23 then catch-fail(symmetricstateunpack(ss_5)) else caught-fail) in
        {88}let v_25: bool = (not-caught-fail(v_24) && success?(1-proj-3-tuple(v_24))) in
        {89}let h_5: bitstring = (if v_25 then 3-proj-3-tuple(v_24) else caught-fail) in
        {90}let ck_5: key = (if v_25 then 2-proj-3-tuple(v_24) else caught-fail) in
        {91}let cs_5: cipherstate = (if v_25 then 1-proj-3-tuple(v_24) else caught-fail) in
        {94}let output3: key = (if v_25 then hmac_hash3(ck_5,input_key_material) else caught-fail) in
        {93}let output2: key = (if v_25 then hmac_hash2(ck_5,input_key_material) else caught-fail) in
        {92}let output1: key = (if v_25 then hmac_hash1(ck_5,input_key_material) else caught-fail) in
        {95}let v_26: bitstring = (if v_25 then catch-fail((output1,output2,output3)) else caught-fail) in
        {96}let v_27: bool = (not-caught-fail(v_26) && success?(1-proj-3-tuple(v_26))) in
        {97}let output_3: key = (if v_27 then 3-proj-3-tuple(v_26) else caught-fail) in
        {98}let temp_k: key = (if v_27 then 2-proj-3-tuple(v_26) else caught-fail) in
        {99}let ck_6: key = (if v_27 then 1-proj-3-tuple(v_26) else caught-fail) in
        {100}let ss_6: symmetricstate = (if v_20 then catch-fail((if v_23 then (if v_25 then (if v_27 then symmetricstatepack(cipherstatepack(temp_k,minnonce),ck_6,h_5) else fail-any) else fail-any) else fail-any)) else caught-fail) in
        {101}let v_28: bool = not-caught-fail(ss_6) in
        {102}let v_29: bitstring = (if v_28 then catch-fail(keypairunpack(e_2)) else caught-fail) in
        {103}let v_30: bool = (not-caught-fail(v_29) && success?(1-proj-2-tuple(v_29))) in
        {104}let my_private_key_1: key = (if v_30 then 2-proj-2-tuple(v_29) else caught-fail) in
        {105}let my_public_key_1: key = (if v_30 then 1-proj-2-tuple(v_29) else caught-fail) in
        {106}let input_key_material_1: key = (if v_28 then catch-fail((if v_30 then dhexp(my_private_key_1,rm_1) else fail-any)) else caught-fail) in
        {107}let v_31: bool = not-caught-fail(input_key_material_1) in
        {108}let v_32: bitstring = (if v_31 then catch-fail(symmetricstateunpack(ss_6)) else caught-fail) in
        {109}let v_33: bool = (not-caught-fail(v_32) && success?(1-proj-3-tuple(v_32))) in
        {110}let h_6: bitstring = (if v_33 then 3-proj-3-tuple(v_32) else caught-fail) in
        {111}let ck_7: key = (if v_33 then 2-proj-3-tuple(v_32) else caught-fail) in
        {112}let cs_6: cipherstate = (if v_33 then 1-proj-3-tuple(v_32) else caught-fail) in
        {115}let output3_1: key = (if v_33 then hmac_hash3(ck_7,input_key_material_1) else caught-fail) in
        {114}let output2_1: key = (if v_33 then hmac_hash2(ck_7,input_key_material_1) else caught-fail) in
        {113}let output1_1: key = (if v_33 then hmac_hash1(ck_7,input_key_material_1) else caught-fail) in
        {116}let v_34: bitstring = (if v_33 then catch-fail((output1_1,output2_1,output3_1)) else caught-fail) in
        {117}let v_35: bool = (not-caught-fail(v_34) && success?(1-proj-3-tuple(v_34))) in
        {118}let output: key = (if v_35 then 3-proj-3-tuple(v_34) else caught-fail) in
        {119}let temp_k_1: key = (if v_35 then 2-proj-3-tuple(v_34) else caught-fail) in
        {120}let ck_8: key = (if v_35 then 1-proj-3-tuple(v_34) else caught-fail) in
        {121}let ss_7: symmetricstate = (if v_28 then catch-fail((if v_31 then (if v_33 then (if v_35 then symmetricstatepack(cipherstatepack(temp_k_1,minnonce),ck_8,h_6) else fail-any) else fail-any) else fail-any)) else caught-fail) in
        {122}let v_36: bool = not-caught-fail(ss_7) in
        {123}let v_37: bitstring = (if v_36 then catch-fail(symmetricstateunpack(ss_7)) else caught-fail) in
        {124}let v_38: bool = (not-caught-fail(v_37) && success?(1-proj-3-tuple(v_37))) in
        {125}let h_7: bitstring = (if v_38 then 3-proj-3-tuple(v_37) else caught-fail) in
        {126}let ck_9: key = (if v_38 then 2-proj-3-tuple(v_37) else caught-fail) in
        {127}let cs_7: cipherstate = (if v_38 then 1-proj-3-tuple(v_37) else caught-fail) in
        {128}let v_39: bitstring = (if v_38 then catch-fail(cipherstateunpack(cs_7)) else caught-fail) in
        {129}let v_40: bool = (not-caught-fail(v_39) && success?(1-proj-2-tuple(v_39))) in
        {130}let n: nonce = (if v_40 then 2-proj-2-tuple(v_39) else caught-fail) in
        {131}let k_1: key = (if v_40 then 1-proj-2-tuple(v_39) else caught-fail) in
        {134}let v_41: bitstring = (if v_40 then catch-fail(cipherstateunpack(cs_7)) else caught-fail) in
        {135}let v_42: bool = (not-caught-fail(v_41) && success?(1-proj-2-tuple(v_41))) in
        {136}let o: nonce = (if v_42 then 2-proj-2-tuple(v_41) else caught-fail) in
        {137}let k_2: key = (if v_42 then 1-proj-2-tuple(v_41) else caught-fail) in
        {133}let n_1: nonce = (if v_40 then increment_nonce(n) else caught-fail) in
        {138}let csi: cipherstate = (if v_40 then catch-fail((if v_42 then cipherstatepack(k_2,n_1) else fail-any)) else caught-fail) in
        {139}let v_43: bool = not-caught-fail(csi) in
        {50}let payload: bitstring = msg_a(me,them,sid_1) in
        {132}let e_3: bitstring = (if v_40 then encrypt(k_1,n,h_7,payload) else caught-fail) in
        {140}let v_44: bitstring = (if v_38 then catch-fail((if v_40 then (if v_43 then (csi,e_3) else fail-any) else fail-any)) else caught-fail) in
        {141}let v_45: bool = (not-caught-fail(v_44) && success?(1-proj-2-tuple(v_44))) in
        {142}let ciphertext_1: bitstring = (if v_45 then 2-proj-2-tuple(v_44) else caught-fail) in
        {143}let csi_1: cipherstate = (if v_45 then 1-proj-2-tuple(v_44) else caught-fail) in
        {144}let ss_8: symmetricstate = (if v_45 then symmetricstatepack(csi_1,ck_9,h_7) else caught-fail) in
        {145}let v_46: bitstring = (if v_45 then catch-fail(symmetricstateunpack(ss_8)) else caught-fail) in
        {146}let v_47: bool = (not-caught-fail(v_46) && success?(1-proj-3-tuple(v_46))) in
        {147}let h_8: bitstring = (if v_47 then 3-proj-3-tuple(v_46) else caught-fail) in
        {148}let ck_10: key = (if v_47 then 2-proj-3-tuple(v_46) else caught-fail) in
        {149}let cs_8: cipherstate = (if v_47 then 1-proj-3-tuple(v_46) else caught-fail) in
        {150}let ssi: symmetricstate = (if v_45 then catch-fail((if v_47 then symmetricstatepack(cs_8,ck_10,hash(h_8,ciphertext_1)) else fail-any)) else caught-fail) in
        {151}let v_48: bool = not-caught-fail(ssi) in
        {152}let v_49: bitstring = (if v_36 then catch-fail((if v_38 then (if v_45 then (if v_48 then (ssi,ciphertext_1) else fail-any) else fail-any) else fail-any)) else caught-fail) in
        {153}let v_50: bool = (not-caught-fail(v_49) && success?(1-proj-2-tuple(v_49))) in
        {154}let ciphertext_2: bitstring = (if v_50 then 2-proj-2-tuple(v_49) else caught-fail) in
        {155}let ss_9: symmetricstate = (if v_50 then 1-proj-2-tuple(v_49) else caught-fail) in
        {158}let v_51: bitstring = (if v_50 then catch-fail(symmetricstateunpack(ss_9)) else caught-fail) in
        {159}let v_52: bool = (not-caught-fail(v_51) && success?(1-proj-3-tuple(v_51))) in
        {160}let h_9: bitstring = (if v_52 then 3-proj-3-tuple(v_51) else caught-fail) in
        {161}let ck_11: key = (if v_52 then 2-proj-3-tuple(v_51) else caught-fail) in
        {162}let cs_9: cipherstate = (if v_52 then 1-proj-3-tuple(v_51) else caught-fail) in
        {163}let input_key_material_2: key = (if v_52 then zero else caught-fail) in
        {166}let output3_2: key = (if v_52 then hmac_hash3(ck_11,input_key_material_2) else caught-fail) in
        {165}let output2_2: key = (if v_52 then hmac_hash2(ck_11,input_key_material_2) else caught-fail) in
        {164}let output1_2: key = (if v_52 then hmac_hash1(ck_11,input_key_material_2) else caught-fail) in
        {167}let v_53: bitstring = (if v_52 then catch-fail((output1_2,output2_2,output3_2)) else caught-fail) in
        {168}let v_54: bool = (not-caught-fail(v_53) && success?(1-proj-3-tuple(v_53))) in
        {169}let temp_k3: key = (if v_54 then 3-proj-3-tuple(v_53) else caught-fail) in
        {170}let temp_k2: key = (if v_54 then 2-proj-3-tuple(v_53) else caught-fail) in
        {171}let temp_k1: key = (if v_54 then 1-proj-3-tuple(v_53) else caught-fail) in
        {173}let cs2: cipherstate = (if v_54 then cipherstatepack(temp_k2,minnonce) else caught-fail) in
        {172}let cs1: cipherstate = (if v_54 then cipherstatepack(temp_k1,minnonce) else caught-fail) in
        {174}let v_55: bitstring = (if v_50 then catch-fail((if v_52 then (if v_54 then (ss_9,cs1,cs2) else fail-any) else fail-any)) else caught-fail) in
        {175}let v_56: bool = (not-caught-fail(v_55) && success?(1-proj-3-tuple(v_55))) in
        {176}let cs2_1: cipherstate = (if v_56 then 3-proj-3-tuple(v_55) else caught-fail) in
        {177}let cs1_1: cipherstate = (if v_56 then 2-proj-3-tuple(v_55) else caught-fail) in
        {178}let ssi_1: symmetricstate = (if v_56 then 1-proj-3-tuple(v_55) else caught-fail) in
        {157}let message_buffer: bitstring = (if v_50 then concat3(ne_1,ns,ciphertext_2) else caught-fail) in
        {156}let hs_2: handshakestate = (if v_50 then handshakestatepack(ss_9,s_1,m_1,e_2,rs_1,rm_1,re_1,psk_1,initiator_1) else caught-fail) in
        {179}let (hs_3: handshakestate,message_a: bitstring,cs1_2: cipherstate,cs2_2: cipherstate) = (if v_12 then (if v_14 then (if v_16 then (if v_17 then (if v_20 then (if v_28 then (if v_36 then (if v_50 then (if v_56 then (hs_2,message_buffer,cs1_1,cs2_1) else fail-any) else fail-any) else fail-any) else fail-any) else fail-any) else fail-any) else fail-any) else fail-any) else fail-any) in
        {180}event SendMsg(me,them,stagepack_a(sid_1),msg_a(me,them,sid_1));
        {181}out(pub, message_a)
    ) | (
        0
    )
) | (
    {185}let sid_2: sessionid = sid in
    {184}let them_1: principal = charlie in
    {183}let me_1: principal = alice in
    (
        {189}let basis_3: key = key_s(them_1) in
        {190}let public_key_3: key = catch-fail(dhexp(basis_3,validkey(g))) in
        {191}let v_57: bool = not-caught-fail(public_key_3) in
        {192}let rs_2: key = getpublickey((if v_57 then keypairpack(validkey(public_key_3),basis_3) else fail-any)) in
        {193}let basis_4: key = key_m(them_1) in
        {194}let public_key_4: key = catch-fail(dhexp(basis_4,validkey(g))) in
        {195}let v_58: bool = not-caught-fail(public_key_4) in
        {196}let rm_2: key = getpublickey((if v_58 then keypairpack(validkey(public_key_4),basis_4) else fail-any)) in
        {203}let k_3: key = empty in
        {204}let cs_10: cipherstate = cipherstatepack(k_3,minnonce) in
        {200}let protocol_name_1: bitstring = somename in
        {201}let h_10: bitstring = hash(protocol_name_1,empty) in
        {202}let ck_12: key = h_10 in
        {205}let ss_10: symmetricstate = symmetricstatepack(cs_10,ck_12,h_10) in
        {206}let v_59: bitstring = catch-fail(symmetricstateunpack(ss_10)) in
        {207}let v_60: bool = (not-caught-fail(v_59) && success?(1-proj-3-tuple(v_59))) in
        {208}let h_11: bitstring = (if v_60 then 3-proj-3-tuple(v_59) else caught-fail) in
        {209}let ck_13: key = (if v_60 then 2-proj-3-tuple(v_59) else caught-fail) in
        {210}let cs_11: cipherstate = (if v_60 then 1-proj-3-tuple(v_59) else caught-fail) in
        {198}let prologue_1: bitstring = empty in
        {211}let ss_11: symmetricstate = catch-fail((if v_60 then symmetricstatepack(cs_11,ck_13,hash(h_11,prologue_1)) else fail-any)) in
        {212}let v_61: bool = not-caught-fail(ss_11) in
        {213}let v_62: bitstring = (if v_61 then catch-fail(symmetricstateunpack(ss_11)) else caught-fail) in
        {214}let v_63: bool = (not-caught-fail(v_62) && success?(1-proj-3-tuple(v_62))) in
        {215}let h_12: bitstring = (if v_63 then 3-proj-3-tuple(v_62) else caught-fail) in
        {216}let ck_14: key = (if v_63 then 2-proj-3-tuple(v_62) else caught-fail) in
        {217}let cs_12: cipherstate = (if v_63 then 1-proj-3-tuple(v_62) else caught-fail) in
        {218}let ss_12: symmetricstate = (if v_61 then catch-fail((if v_63 then symmetricstatepack(cs_12,ck_14,hash(h_12,rs_2)) else fail-any)) else caught-fail) in
        {219}let v_64: bool = not-caught-fail(ss_12) in
        {220}let v_65: bitstring = (if v_64 then catch-fail(symmetricstateunpack(ss_12)) else caught-fail) in
        {221}let v_66: bool = (not-caught-fail(v_65) && success?(1-proj-3-tuple(v_65))) in
        {222}let h_13: bitstring = (if v_66 then 3-proj-3-tuple(v_65) else caught-fail) in
        {223}let ck_15: key = (if v_66 then 2-proj-3-tuple(v_65) else caught-fail) in
        {224}let cs_13: cipherstate = (if v_66 then 1-proj-3-tuple(v_65) else caught-fail) in
        {225}let ss_13: symmetricstate = (if v_64 then catch-fail((if v_66 then symmetricstatepack(cs_13,ck_15,hash(h_13,rm_2)) else fail-any)) else caught-fail) in
        {226}let v_67: bool = not-caught-fail(ss_13) in
        {199}let psk_2: key = empty in
        {197}let re_2: key = empty in
        {188}let e_4: keypair = keypairpack(empty,empty) in
        {187}let m_2: keypair = keypairpack(empty,empty) in
        {186}let s_2: keypair = keypairpack(empty,empty) in
        {227}let hs_4: handshakestate = (if v_61 then (if v_64 then (if v_67 then handshakestatepack(ss_13,s_2,m_2,e_4,rs_2,rm_2,re_2,psk_2,true) else fail-any) else fail-any) else fail-any) in
        {228}insert statestore(me_1,them_1,sid_2,statepack_a(hs_4))
    ) | (
        {361}get statestore(=me_1,=them_1,=sid_2,statepack_a(hs_5: handshakestate)) in
        {230}let v_68: bitstring = catch-fail(handshakestateunpack(hs_5)) in
        {231}let v_69: bool = (not-caught-fail(v_68) && success?(1-proj-9-tuple(v_68))) in
        {232}let initiator_2: bool = (if v_69 then 9-proj-9-tuple(v_68) else caught-fail) in
        {233}let psk_3: key = (if v_69 then 8-proj-9-tuple(v_68) else caught-fail) in
        {234}let re_3: key = (if v_69 then 7-proj-9-tuple(v_68) else caught-fail) in
        {235}let rm_3: key = (if v_69 then 6-proj-9-tuple(v_68) else caught-fail) in
        {236}let rs_3: key = (if v_69 then 5-proj-9-tuple(v_68) else caught-fail) in
        {237}let e_5: keypair = (if v_69 then 4-proj-9-tuple(v_68) else caught-fail) in
        {238}let m_3: keypair = (if v_69 then 3-proj-9-tuple(v_68) else caught-fail) in
        {239}let s_3: keypair = (if v_69 then 2-proj-9-tuple(v_68) else caught-fail) in
        {240}let ss_14: symmetricstate = (if v_69 then 1-proj-9-tuple(v_68) else caught-fail) in
        {241}let v_70: bitstring = (if v_69 then catch-fail((empty,empty,empty)) else caught-fail) in
        {242}let v_71: bool = (not-caught-fail(v_70) && success?(1-proj-3-tuple(v_70))) in
        {243}let ciphertext_3: bitstring = (if v_71 then 3-proj-3-tuple(v_70) else caught-fail) in
        {244}let ns_1: bitstring = (if v_71 then 2-proj-3-tuple(v_70) else caught-fail) in
        {245}let ne_2: bitstring = (if v_71 then 1-proj-3-tuple(v_70) else caught-fail) in
        {246}let basis_5: key = (if v_71 then key_e(me_1,them_1,sid_2) else caught-fail) in
        {247}let public_key_5: key = (if v_71 then catch-fail(dhexp(basis_5,validkey(g))) else caught-fail) in
        {248}let v_72: bool = not-caught-fail(public_key_5) in
        {249}let e_6: keypair = (if v_71 then catch-fail((if v_72 then keypairpack(validkey(public_key_5),basis_5) else fail-any)) else caught-fail) in
        {250}let v_73: bool = not-caught-fail(e_6) in
        {251}let ne_3: bitstring = (if v_73 then catch-fail(getpublickey(e_6)) else caught-fail) in
        {252}let v_74: bool = not-caught-fail(ne_3) in
        {253}let v_75: bitstring = (if v_74 then catch-fail(symmetricstateunpack(ss_14)) else caught-fail) in
        {254}let v_76: bool = (not-caught-fail(v_75) && success?(1-proj-3-tuple(v_75))) in
        {255}let h_14: bitstring = (if v_76 then 3-proj-3-tuple(v_75) else caught-fail) in
        {256}let ck_16: key = (if v_76 then 2-proj-3-tuple(v_75) else caught-fail) in
        {257}let cs_14: cipherstate = (if v_76 then 1-proj-3-tuple(v_75) else caught-fail) in
        {258}let ss_15: symmetricstate = (if v_74 then catch-fail((if v_76 then symmetricstatepack(cs_14,ck_16,hash(h_14,ne_3)) else fail-any)) else caught-fail) in
        {259}let v_77: bool = not-caught-fail(ss_15) in
        {260}let v_78: bitstring = (if v_77 then catch-fail(keypairunpack(e_6)) else caught-fail) in
        {261}let v_79: bool = (not-caught-fail(v_78) && success?(1-proj-2-tuple(v_78))) in
        {262}let my_private_key_2: key = (if v_79 then 2-proj-2-tuple(v_78) else caught-fail) in
        {263}let my_public_key_2: key = (if v_79 then 1-proj-2-tuple(v_78) else caught-fail) in
        {264}let input_key_material_3: key = (if v_77 then catch-fail((if v_79 then dhexp(my_private_key_2,rs_3) else fail-any)) else caught-fail) in
        {265}let v_80: bool = not-caught-fail(input_key_material_3) in
        {266}let v_81: bitstring = (if v_80 then catch-fail(symmetricstateunpack(ss_15)) else caught-fail) in
        {267}let v_82: bool = (not-caught-fail(v_81) && success?(1-proj-3-tuple(v_81))) in
        {268}let h_15: bitstring = (if v_82 then 3-proj-3-tuple(v_81) else caught-fail) in
        {269}let ck_17: key = (if v_82 then 2-proj-3-tuple(v_81) else caught-fail) in
        {270}let cs_15: cipherstate = (if v_82 then 1-proj-3-tuple(v_81) else caught-fail) in
        {273}let output3_3: key = (if v_82 then hmac_hash3(ck_17,input_key_material_3) else caught-fail) in
        {272}let output2_3: key = (if v_82 then hmac_hash2(ck_17,input_key_material_3) else caught-fail) in
        {271}let output1_3: key = (if v_82 then hmac_hash1(ck_17,input_key_material_3) else caught-fail) in
        {274}let v_83: bitstring = (if v_82 then catch-fail((output1_3,output2_3,output3_3)) else caught-fail) in
        {275}let v_84: bool = (not-caught-fail(v_83) && success?(1-proj-3-tuple(v_83))) in
        {276}let output_1: key = (if v_84 then 3-proj-3-tuple(v_83) else caught-fail) in
        {277}let temp_k_2: key = (if v_84 then 2-proj-3-tuple(v_83) else caught-fail) in
        {278}let ck_18: key = (if v_84 then 1-proj-3-tuple(v_83) else caught-fail) in
        {279}let ss_16: symmetricstate = (if v_77 then catch-fail((if v_80 then (if v_82 then (if v_84 then symmetricstatepack(cipherstatepack(temp_k_2,minnonce),ck_18,h_15) else fail-any) else fail-any) else fail-any)) else caught-fail) in
        {280}let v_85: bool = not-caught-fail(ss_16) in
        {281}let v_86: bitstring = (if v_85 then catch-fail(keypairunpack(e_6)) else caught-fail) in
        {282}let v_87: bool = (not-caught-fail(v_86) && success?(1-proj-2-tuple(v_86))) in
        {283}let my_private_key_3: key = (if v_87 then 2-proj-2-tuple(v_86) else caught-fail) in
        {284}let my_public_key_3: key = (if v_87 then 1-proj-2-tuple(v_86) else caught-fail) in
        {285}let input_key_material_4: key = (if v_85 then catch-fail((if v_87 then dhexp(my_private_key_3,rm_3) else fail-any)) else caught-fail) in
        {286}let v_88: bool = not-caught-fail(input_key_material_4) in
        {287}let v_89: bitstring = (if v_88 then catch-fail(symmetricstateunpack(ss_16)) else caught-fail) in
        {288}let v_90: bool = (not-caught-fail(v_89) && success?(1-proj-3-tuple(v_89))) in
        {289}let h_16: bitstring = (if v_90 then 3-proj-3-tuple(v_89) else caught-fail) in
        {290}let ck_19: key = (if v_90 then 2-proj-3-tuple(v_89) else caught-fail) in
        {291}let cs_16: cipherstate = (if v_90 then 1-proj-3-tuple(v_89) else caught-fail) in
        {294}let output3_4: key = (if v_90 then hmac_hash3(ck_19,input_key_material_4) else caught-fail) in
        {293}let output2_4: key = (if v_90 then hmac_hash2(ck_19,input_key_material_4) else caught-fail) in
        {292}let output1_4: key = (if v_90 then hmac_hash1(ck_19,input_key_material_4) else caught-fail) in
        {295}let v_91: bitstring = (if v_90 then catch-fail((output1_4,output2_4,output3_4)) else caught-fail) in
        {296}let v_92: bool = (not-caught-fail(v_91) && success?(1-proj-3-tuple(v_91))) in
        {297}let output_2: key = (if v_92 then 3-proj-3-tuple(v_91) else caught-fail) in
        {298}let temp_k_3: key = (if v_92 then 2-proj-3-tuple(v_91) else caught-fail) in
        {299}let ck_20: key = (if v_92 then 1-proj-3-tuple(v_91) else caught-fail) in
        {300}let ss_17: symmetricstate = (if v_85 then catch-fail((if v_88 then (if v_90 then (if v_92 then symmetricstatepack(cipherstatepack(temp_k_3,minnonce),ck_20,h_16) else fail-any) else fail-any) else fail-any)) else caught-fail) in
        {301}let v_93: bool = not-caught-fail(ss_17) in
        {302}let v_94: bitstring = (if v_93 then catch-fail(symmetricstateunpack(ss_17)) else caught-fail) in
        {303}let v_95: bool = (not-caught-fail(v_94) && success?(1-proj-3-tuple(v_94))) in
        {304}let h_17: bitstring = (if v_95 then 3-proj-3-tuple(v_94) else caught-fail) in
        {305}let ck_21: key = (if v_95 then 2-proj-3-tuple(v_94) else caught-fail) in
        {306}let cs_17: cipherstate = (if v_95 then 1-proj-3-tuple(v_94) else caught-fail) in
        {307}let v_96: bitstring = (if v_95 then catch-fail(cipherstateunpack(cs_17)) else caught-fail) in
        {308}let v_97: bool = (not-caught-fail(v_96) && success?(1-proj-2-tuple(v_96))) in
        {309}let n_2: nonce = (if v_97 then 2-proj-2-tuple(v_96) else caught-fail) in
        {310}let k_4: key = (if v_97 then 1-proj-2-tuple(v_96) else caught-fail) in
        {313}let v_98: bitstring = (if v_97 then catch-fail(cipherstateunpack(cs_17)) else caught-fail) in
        {314}let v_99: bool = (not-caught-fail(v_98) && success?(1-proj-2-tuple(v_98))) in
        {315}let o_1: nonce = (if v_99 then 2-proj-2-tuple(v_98) else caught-fail) in
        {316}let k_5: key = (if v_99 then 1-proj-2-tuple(v_98) else caught-fail) in
        {312}let n_3: nonce = (if v_97 then increment_nonce(n_2) else caught-fail) in
        {317}let csi_2: cipherstate = (if v_97 then catch-fail((if v_99 then cipherstatepack(k_5,n_3) else fail-any)) else caught-fail) in
        {318}let v_100: bool = not-caught-fail(csi_2) in
        {229}let payload_1: bitstring = msg_a(me_1,them_1,sid_2) in
        {311}let e_7: bitstring = (if v_97 then encrypt(k_4,n_2,h_17,payload_1) else caught-fail) in
        {319}let v_101: bitstring = (if v_95 then catch-fail((if v_97 then (if v_100 then (csi_2,e_7) else fail-any) else fail-any)) else caught-fail) in
        {320}let v_102: bool = (not-caught-fail(v_101) && success?(1-proj-2-tuple(v_101))) in
        {321}let ciphertext_4: bitstring = (if v_102 then 2-proj-2-tuple(v_101) else caught-fail) in
        {322}let csi_3: cipherstate = (if v_102 then 1-proj-2-tuple(v_101) else caught-fail) in
        {323}let ss_18: symmetricstate = (if v_102 then symmetricstatepack(csi_3,ck_21,h_17) else caught-fail) in
        {324}let v_103: bitstring = (if v_102 then catch-fail(symmetricstateunpack(ss_18)) else caught-fail) in
        {325}let v_104: bool = (not-caught-fail(v_103) && success?(1-proj-3-tuple(v_103))) in
        {326}let h_18: bitstring = (if v_104 then 3-proj-3-tuple(v_103) else caught-fail) in
        {327}let ck_22: key = (if v_104 then 2-proj-3-tuple(v_103) else caught-fail) in
        {328}let cs_18: cipherstate = (if v_104 then 1-proj-3-tuple(v_103) else caught-fail) in
        {329}let ssi_2: symmetricstate = (if v_102 then catch-fail((if v_104 then symmetricstatepack(cs_18,ck_22,hash(h_18,ciphertext_4)) else fail-any)) else caught-fail) in
        {330}let v_105: bool = not-caught-fail(ssi_2) in
        {331}let v_106: bitstring = (if v_93 then catch-fail((if v_95 then (if v_102 then (if v_105 then (ssi_2,ciphertext_4) else fail-any) else fail-any) else fail-any)) else caught-fail) in
        {332}let v_107: bool = (not-caught-fail(v_106) && success?(1-proj-2-tuple(v_106))) in
        {333}let ciphertext_5: bitstring = (if v_107 then 2-proj-2-tuple(v_106) else caught-fail) in
        {334}let ss_19: symmetricstate = (if v_107 then 1-proj-2-tuple(v_106) else caught-fail) in
        {337}let v_108: bitstring = (if v_107 then catch-fail(symmetricstateunpack(ss_19)) else caught-fail) in
        {338}let v_109: bool = (not-caught-fail(v_108) && success?(1-proj-3-tuple(v_108))) in
        {339}let h_19: bitstring = (if v_109 then 3-proj-3-tuple(v_108) else caught-fail) in
        {340}let ck_23: key = (if v_109 then 2-proj-3-tuple(v_108) else caught-fail) in
        {341}let cs_19: cipherstate = (if v_109 then 1-proj-3-tuple(v_108) else caught-fail) in
        {342}let input_key_material_5: key = (if v_109 then zero else caught-fail) in
        {345}let output3_5: key = (if v_109 then hmac_hash3(ck_23,input_key_material_5) else caught-fail) in
        {344}let output2_5: key = (if v_109 then hmac_hash2(ck_23,input_key_material_5) else caught-fail) in
        {343}let output1_5: key = (if v_109 then hmac_hash1(ck_23,input_key_material_5) else caught-fail) in
        {346}let v_110: bitstring = (if v_109 then catch-fail((output1_5,output2_5,output3_5)) else caught-fail) in
        {347}let v_111: bool = (not-caught-fail(v_110) && success?(1-proj-3-tuple(v_110))) in
        {348}let temp_k3_1: key = (if v_111 then 3-proj-3-tuple(v_110) else caught-fail) in
        {349}let temp_k2_1: key = (if v_111 then 2-proj-3-tuple(v_110) else caught-fail) in
        {350}let temp_k1_1: key = (if v_111 then 1-proj-3-tuple(v_110) else caught-fail) in
        {352}let cs2_3: cipherstate = (if v_111 then cipherstatepack(temp_k2_1,minnonce) else caught-fail) in
        {351}let cs1_3: cipherstate = (if v_111 then cipherstatepack(temp_k1_1,minnonce) else caught-fail) in
        {353}let v_112: bitstring = (if v_107 then catch-fail((if v_109 then (if v_111 then (ss_19,cs1_3,cs2_3) else fail-any) else fail-any)) else caught-fail) in
        {354}let v_113: bool = (not-caught-fail(v_112) && success?(1-proj-3-tuple(v_112))) in
        {355}let cs2_4: cipherstate = (if v_113 then 3-proj-3-tuple(v_112) else caught-fail) in
        {356}let cs1_4: cipherstate = (if v_113 then 2-proj-3-tuple(v_112) else caught-fail) in
        {357}let ssi_3: symmetricstate = (if v_113 then 1-proj-3-tuple(v_112) else caught-fail) in
        {336}let message_buffer_1: bitstring = (if v_107 then concat3(ne_3,ns_1,ciphertext_5) else caught-fail) in
        {335}let hs_6: handshakestate = (if v_107 then handshakestatepack(ss_19,s_3,m_3,e_6,rs_3,rm_3,re_3,psk_3,initiator_2) else caught-fail) in
        {358}let (hs_7: handshakestate,message_a_1: bitstring,cs1_5: cipherstate,cs2_5: cipherstate) = (if v_69 then (if v_71 then (if v_73 then (if v_74 then (if v_77 then (if v_85 then (if v_93 then (if v_107 then (if v_113 then (hs_6,message_buffer_1,cs1_4,cs2_4) else fail-any) else fail-any) else fail-any) else fail-any) else fail-any) else fail-any) else fail-any) else fail-any) else fail-any) in
        {359}event SendMsg(me_1,them_1,stagepack_a(sid_2),msg_a(me_1,them_1,sid_2));
        {360}out(pub, message_a_1)
    ) | (
        0
    )
) | (
    {362}let me_2: principal = bob in
    {365}let basis_6: key = key_s(me_2) in
    {366}let public_key_6: key = catch-fail(dhexp(basis_6,validkey(g))) in
    {367}let v_114: bool = not-caught-fail(public_key_6) in
    {368}let s_4: keypair = (if v_114 then keypairpack(validkey(public_key_6),basis_6) else fail-any) in
    {369}let basis_7: key = key_m(me_2) in
    {370}let public_key_7: key = catch-fail(dhexp(basis_7,validkey(g))) in
    {371}let v_115: bool = not-caught-fail(public_key_7) in
    {372}let m_4: keypair = (if v_115 then keypairpack(validkey(public_key_7),basis_7) else fail-any) in
    {373}out(pub, (getpublickey(s_4),getpublickey(m_4)));
    {364}let sid_3: sessionid = sid in
    {363}let them_2: principal = alice in
    (
        {383}let k_6: key = empty in
        {384}let cs_20: cipherstate = cipherstatepack(k_6,minnonce) in
        {380}let protocol_name_2: bitstring = somename in
        {381}let h_20: bitstring = hash(protocol_name_2,empty) in
        {382}let ck_24: key = h_20 in
        {385}let ss_20: symmetricstate = symmetricstatepack(cs_20,ck_24,h_20) in
        {386}let v_116: bitstring = catch-fail(symmetricstateunpack(ss_20)) in
        {387}let v_117: bool = (not-caught-fail(v_116) && success?(1-proj-3-tuple(v_116))) in
        {388}let h_21: bitstring = (if v_117 then 3-proj-3-tuple(v_116) else caught-fail) in
        {389}let ck_25: key = (if v_117 then 2-proj-3-tuple(v_116) else caught-fail) in
        {390}let cs_21: cipherstate = (if v_117 then 1-proj-3-tuple(v_116) else caught-fail) in
        {378}let prologue_2: bitstring = empty in
        {391}let ss_21: symmetricstate = catch-fail((if v_117 then symmetricstatepack(cs_21,ck_25,hash(h_21,prologue_2)) else fail-any)) in
        {392}let v_118: bool = not-caught-fail(ss_21) in
        {393}let data: bitstring = (if v_118 then catch-fail(getpublickey(s_4)) else caught-fail) in
        {394}let v_119: bool = not-caught-fail(data) in
        {395}let v_120: bitstring = (if v_119 then catch-fail(symmetricstateunpack(ss_21)) else caught-fail) in
        {396}let v_121: bool = (not-caught-fail(v_120) && success?(1-proj-3-tuple(v_120))) in
        {397}let h_22: bitstring = (if v_121 then 3-proj-3-tuple(v_120) else caught-fail) in
        {398}let ck_26: key = (if v_121 then 2-proj-3-tuple(v_120) else caught-fail) in
        {399}let cs_22: cipherstate = (if v_121 then 1-proj-3-tuple(v_120) else caught-fail) in
        {400}let ss_22: symmetricstate = (if v_118 then catch-fail((if v_119 then (if v_121 then symmetricstatepack(cs_22,ck_26,hash(h_22,data)) else fail-any) else fail-any)) else caught-fail) in
        {401}let v_122: bool = not-caught-fail(ss_22) in
        {402}let data_1: bitstring = (if v_122 then catch-fail(getpublickey(m_4)) else caught-fail) in
        {403}let v_123: bool = not-caught-fail(data_1) in
        {404}let v_124: bitstring = (if v_123 then catch-fail(symmetricstateunpack(ss_22)) else caught-fail) in
        {405}let v_125: bool = (not-caught-fail(v_124) && success?(1-proj-3-tuple(v_124))) in
        {406}let h_23: bitstring = (if v_125 then 3-proj-3-tuple(v_124) else caught-fail) in
        {407}let ck_27: key = (if v_125 then 2-proj-3-tuple(v_124) else caught-fail) in
        {408}let cs_23: cipherstate = (if v_125 then 1-proj-3-tuple(v_124) else caught-fail) in
        {409}let ss_23: symmetricstate = (if v_122 then catch-fail((if v_123 then (if v_125 then symmetricstatepack(cs_23,ck_27,hash(h_23,data_1)) else fail-any) else fail-any)) else caught-fail) in
        {410}let v_126: bool = not-caught-fail(ss_23) in
        {379}let psk_4: key = empty in
        {377}let re_4: key = empty in
        {376}let rm_4: key = empty in
        {375}let rs_4: key = empty in
        {374}let e_8: keypair = keypairpack(empty,empty) in
        {411}let hs_8: handshakestate = (if v_118 then (if v_122 then (if v_126 then handshakestatepack(ss_23,s_4,m_4,e_8,rs_4,rm_4,re_4,psk_4,false) else fail-any) else fail-any) else fail-any) in
        {412}insert statestore(me_2,them_2,sid_3,statepack_a(hs_8))
    ) | (
        {548}get statestore(=me_2,=them_2,=sid_3,statepack_a(hs_9: handshakestate)) in
        {413}in(pub, message_a_2: bitstring);
        {414}let v_127: bitstring = catch-fail(handshakestateunpack(hs_9)) in
        {415}let v_128: bool = (not-caught-fail(v_127) && success?(1-proj-9-tuple(v_127))) in
        {416}let initiator_3: bool = (if v_128 then 9-proj-9-tuple(v_127) else caught-fail) in
        {417}let psk_5: key = (if v_128 then 8-proj-9-tuple(v_127) else caught-fail) in
        {418}let re_5: key = (if v_128 then 7-proj-9-tuple(v_127) else caught-fail) in
        {419}let rm_5: key = (if v_128 then 6-proj-9-tuple(v_127) else caught-fail) in
        {420}let rs_5: key = (if v_128 then 5-proj-9-tuple(v_127) else caught-fail) in
        {421}let e_9: keypair = (if v_128 then 4-proj-9-tuple(v_127) else caught-fail) in
        {422}let m_5: keypair = (if v_128 then 3-proj-9-tuple(v_127) else caught-fail) in
        {423}let s_5: keypair = (if v_128 then 2-proj-9-tuple(v_127) else caught-fail) in
        {424}let ss_24: symmetricstate = (if v_128 then 1-proj-9-tuple(v_127) else caught-fail) in
        {425}let v_129: bitstring = (if v_128 then catch-fail(deconcat3(message_a_2)) else caught-fail) in
        {426}let v_130: bool = (not-caught-fail(v_129) && success?(1-proj-3-tuple(v_129))) in
        {427}let ciphertext_6: bitstring = (if v_130 then 3-proj-3-tuple(v_129) else caught-fail) in
        {428}let ns_2: bitstring = (if v_130 then 2-proj-3-tuple(v_129) else caught-fail) in
        {429}let ne_4: bitstring = (if v_130 then 1-proj-3-tuple(v_129) else caught-fail) in
        {432}let v_131: bitstring = (if v_130 then catch-fail(symmetricstateunpack(ss_24)) else caught-fail) in
        {433}let v_132: bool = (not-caught-fail(v_131) && success?(1-proj-3-tuple(v_131))) in
        {434}let h_24: bitstring = (if v_132 then 3-proj-3-tuple(v_131) else caught-fail) in
        {435}let ck_28: key = (if v_132 then 2-proj-3-tuple(v_131) else caught-fail) in
        {436}let cs_24: cipherstate = (if v_132 then 1-proj-3-tuple(v_131) else caught-fail) in
        {431}let re_6: key = (if v_130 then ne_4 else caught-fail) in
        {437}let ss_25: symmetricstate = (if v_130 then catch-fail((if v_132 then symmetricstatepack(cs_24,ck_28,hash(h_24,re_6)) else fail-any)) else caught-fail) in
        {438}let v_133: bool = not-caught-fail(ss_25) in
        {439}let v_134: bitstring = (if v_133 then catch-fail(keypairunpack(s_5)) else caught-fail) in
        {440}let v_135: bool = (not-caught-fail(v_134) && success?(1-proj-2-tuple(v_134))) in
        {441}let my_private_key_4: key = (if v_135 then 2-proj-2-tuple(v_134) else caught-fail) in
        {442}let my_public_key_4: key = (if v_135 then 1-proj-2-tuple(v_134) else caught-fail) in
        {443}let input_key_material_6: key = (if v_133 then catch-fail((if v_135 then dhexp(my_private_key_4,re_6) else fail-any)) else caught-fail) in
        {444}let v_136: bool = not-caught-fail(input_key_material_6) in
        {445}let v_137: bitstring = (if v_136 then catch-fail(symmetricstateunpack(ss_25)) else caught-fail) in
        {446}let v_138: bool = (not-caught-fail(v_137) && success?(1-proj-3-tuple(v_137))) in
        {447}let h_25: bitstring = (if v_138 then 3-proj-3-tuple(v_137) else caught-fail) in
        {448}let ck_29: key = (if v_138 then 2-proj-3-tuple(v_137) else caught-fail) in
        {449}let cs_25: cipherstate = (if v_138 then 1-proj-3-tuple(v_137) else caught-fail) in
        {452}let output3_6: key = (if v_138 then hmac_hash3(ck_29,input_key_material_6) else caught-fail) in
        {451}let output2_6: key = (if v_138 then hmac_hash2(ck_29,input_key_material_6) else caught-fail) in
        {450}let output1_6: key = (if v_138 then hmac_hash1(ck_29,input_key_material_6) else caught-fail) in
        {453}let v_139: bitstring = (if v_138 then catch-fail((output1_6,output2_6,output3_6)) else caught-fail) in
        {454}let v_140: bool = (not-caught-fail(v_139) && success?(1-proj-3-tuple(v_139))) in
        {455}let output_4: key = (if v_140 then 3-proj-3-tuple(v_139) else caught-fail) in
        {456}let temp_k_4: key = (if v_140 then 2-proj-3-tuple(v_139) else caught-fail) in
        {457}let ck_30: key = (if v_140 then 1-proj-3-tuple(v_139) else caught-fail) in
        {458}let ss_26: symmetricstate = (if v_133 then catch-fail((if v_136 then (if v_138 then (if v_140 then symmetricstatepack(cipherstatepack(temp_k_4,minnonce),ck_30,h_25) else fail-any) else fail-any) else fail-any)) else caught-fail) in
        {459}let v_141: bool = not-caught-fail(ss_26) in
        {460}let v_142: bitstring = (if v_141 then catch-fail(keypairunpack(m_5)) else caught-fail) in
        {461}let v_143: bool = (not-caught-fail(v_142) && success?(1-proj-2-tuple(v_142))) in
        {462}let my_private_key_5: key = (if v_143 then 2-proj-2-tuple(v_142) else caught-fail) in
        {463}let my_public_key_5: key = (if v_143 then 1-proj-2-tuple(v_142) else caught-fail) in
        {464}let input_key_material_7: key = (if v_141 then catch-fail((if v_143 then dhexp(my_private_key_5,re_6) else fail-any)) else caught-fail) in
        {465}let v_144: bool = not-caught-fail(input_key_material_7) in
        {466}let v_145: bitstring = (if v_144 then catch-fail(symmetricstateunpack(ss_26)) else caught-fail) in
        {467}let v_146: bool = (not-caught-fail(v_145) && success?(1-proj-3-tuple(v_145))) in
        {468}let h_26: bitstring = (if v_146 then 3-proj-3-tuple(v_145) else caught-fail) in
        {469}let ck_31: key = (if v_146 then 2-proj-3-tuple(v_145) else caught-fail) in
        {470}let cs_26: cipherstate = (if v_146 then 1-proj-3-tuple(v_145) else caught-fail) in
        {473}let output3_7: key = (if v_146 then hmac_hash3(ck_31,input_key_material_7) else caught-fail) in
        {472}let output2_7: key = (if v_146 then hmac_hash2(ck_31,input_key_material_7) else caught-fail) in
        {471}let output1_7: key = (if v_146 then hmac_hash1(ck_31,input_key_material_7) else caught-fail) in
        {474}let v_147: bitstring = (if v_146 then catch-fail((output1_7,output2_7,output3_7)) else caught-fail) in
        {475}let v_148: bool = (not-caught-fail(v_147) && success?(1-proj-3-tuple(v_147))) in
        {476}let output_5: key = (if v_148 then 3-proj-3-tuple(v_147) else caught-fail) in
        {477}let temp_k_5: key = (if v_148 then 2-proj-3-tuple(v_147) else caught-fail) in
        {478}let ck_32: key = (if v_148 then 1-proj-3-tuple(v_147) else caught-fail) in
        {479}let ss_27: symmetricstate = (if v_141 then catch-fail((if v_144 then (if v_146 then (if v_148 then symmetricstatepack(cipherstatepack(temp_k_5,minnonce),ck_32,h_26) else fail-any) else fail-any) else fail-any)) else caught-fail) in
        {480}let v_149: bool = not-caught-fail(ss_27) in
        {481}let v_150: bitstring = (if v_149 then catch-fail(symmetricstateunpack(ss_27)) else caught-fail) in
        {482}let v_151: bool = (not-caught-fail(v_150) && success?(1-proj-3-tuple(v_150))) in
        {483}let h_27: bitstring = (if v_151 then 3-proj-3-tuple(v_150) else caught-fail) in
        {484}let ck_33: key = (if v_151 then 2-proj-3-tuple(v_150) else caught-fail) in
        {485}let cs_27: cipherstate = (if v_151 then 1-proj-3-tuple(v_150) else caught-fail) in
        {486}let v_152: bitstring = (if v_151 then catch-fail(cipherstateunpack(cs_27)) else caught-fail) in
        {487}let v_153: bool = (not-caught-fail(v_152) && success?(1-proj-2-tuple(v_152))) in
        {488}let n_4: nonce = (if v_153 then 2-proj-2-tuple(v_152) else caught-fail) in
        {489}let k_7: key = (if v_153 then 1-proj-2-tuple(v_152) else caught-fail) in
        {490}let d: aead = (if v_153 then catch-fail(decrypt(k_7,n_4,h_27,ciphertext_6)) else caught-fail) in
        {491}let v_154: bool = not-caught-fail(d) in
        {492}let v_155: bitstring = (if v_154 then catch-fail(aeadunpack(d)) else caught-fail) in
        {493}let v_156: bool = (not-caught-fail(v_155) && success?(1-proj-3-tuple(v_155))) in
        {494}let plaintext: bitstring = (if v_156 then 3-proj-3-tuple(v_155) else caught-fail) in
        {495}let adi: bitstring = (if v_156 then 2-proj-3-tuple(v_155) else caught-fail) in
        {496}let valid: bool = (if v_156 then 1-proj-3-tuple(v_155) else caught-fail) in
        {498}let v_157: bitstring = (if v_156 then catch-fail(cipherstateunpack(cs_27)) else caught-fail) in
        {499}let v_158: bool = (not-caught-fail(v_157) && success?(1-proj-2-tuple(v_157))) in
        {500}let o_2: nonce = (if v_158 then 2-proj-2-tuple(v_157) else caught-fail) in
        {501}let k_8: key = (if v_158 then 1-proj-2-tuple(v_157) else caught-fail) in
        {497}let n_5: nonce = (if v_156 then increment_nonce(n_4) else caught-fail) in
        {502}let csi_4: cipherstate = (if v_156 then catch-fail((if v_158 then cipherstatepack(k_8,n_5) else fail-any)) else caught-fail) in
        {503}let v_159: bool = not-caught-fail(csi_4) in
        {504}let v_160: bitstring = (if v_151 then catch-fail((if v_153 then (if v_154 then (if v_156 then (if v_159 then (csi_4,plaintext,valid) else fail-any) else fail-any) else fail-any) else fail-any)) else caught-fail) in
        {505}let v_161: bool = (not-caught-fail(v_160) && success?(1-proj-3-tuple(v_160))) in
        {506}let valid_1: bool = (if v_161 then 3-proj-3-tuple(v_160) else caught-fail) in
        {507}let plaintext_1: bitstring = (if v_161 then 2-proj-3-tuple(v_160) else caught-fail) in
        {508}let csi_5: cipherstate = (if v_161 then 1-proj-3-tuple(v_160) else caught-fail) in
        {509}let ss_28: symmetricstate = (if v_161 then symmetricstatepack(csi_5,ck_33,h_27) else caught-fail) in
        {510}let v_162: bitstring = (if v_161 then catch-fail(symmetricstateunpack(ss_28)) else caught-fail) in
        {511}let v_163: bool = (not-caught-fail(v_162) && success?(1-proj-3-tuple(v_162))) in
        {512}let h_28: bitstring = (if v_163 then 3-proj-3-tuple(v_162) else caught-fail) in
        {513}let ck_34: key = (if v_163 then 2-proj-3-tuple(v_162) else caught-fail) in
        {514}let cs_28: cipherstate = (if v_163 then 1-proj-3-tuple(v_162) else caught-fail) in
        {515}let ssi_4: symmetricstate = (if v_161 then catch-fail((if v_163 then symmetricstatepack(cs_28,ck_34,hash(h_28,ciphertext_6)) else fail-any)) else caught-fail) in
        {516}let v_164: bool = not-caught-fail(ssi_4) in
        {517}let v_165: bitstring = (if v_149 then catch-fail((if v_151 then (if v_161 then (if v_164 then (ssi_4,plaintext_1,valid_1) else fail-any) else fail-any) else fail-any)) else caught-fail) in
        {518}let v_166: bool = (not-caught-fail(v_165) && success?(1-proj-3-tuple(v_165))) in
        {519}let valid2: bool = (if v_166 then 3-proj-3-tuple(v_165) else caught-fail) in
        {520}let plaintext_2: bitstring = (if v_166 then 2-proj-3-tuple(v_165) else caught-fail) in
        {521}let ss_29: symmetricstate = (if v_166 then 1-proj-3-tuple(v_165) else caught-fail) in
        {430}let valid1: bool = (if v_130 then true else caught-fail) in
        {522}let v_167: bool = (if v_166 then catch-fail((valid1 && valid2)) else caught-fail) in
        {524}let v_168: bitstring = (if v_167 then catch-fail(symmetricstateunpack(ss_29)) else caught-fail) in
        {525}let v_169: bool = (not-caught-fail(v_168) && success?(1-proj-3-tuple(v_168))) in
        {526}let h_29: bitstring = (if v_169 then 3-proj-3-tuple(v_168) else caught-fail) in
        {527}let ck_35: key = (if v_169 then 2-proj-3-tuple(v_168) else caught-fail) in
        {528}let cs_29: cipherstate = (if v_169 then 1-proj-3-tuple(v_168) else caught-fail) in
        {529}let input_key_material_8: key = (if v_169 then zero else caught-fail) in
        {532}let output3_8: key = (if v_169 then hmac_hash3(ck_35,input_key_material_8) else caught-fail) in
        {531}let output2_8: key = (if v_169 then hmac_hash2(ck_35,input_key_material_8) else caught-fail) in
        {530}let output1_8: key = (if v_169 then hmac_hash1(ck_35,input_key_material_8) else caught-fail) in
        {533}let v_170: bitstring = (if v_169 then catch-fail((output1_8,output2_8,output3_8)) else caught-fail) in
        {534}let v_171: bool = (not-caught-fail(v_170) && success?(1-proj-3-tuple(v_170))) in
        {535}let temp_k3_2: key = (if v_171 then 3-proj-3-tuple(v_170) else caught-fail) in
        {536}let temp_k2_2: key = (if v_171 then 2-proj-3-tuple(v_170) else caught-fail) in
        {537}let temp_k1_2: key = (if v_171 then 1-proj-3-tuple(v_170) else caught-fail) in
        {539}let cs2_6: cipherstate = (if v_171 then cipherstatepack(temp_k2_2,minnonce) else caught-fail) in
        {538}let cs1_6: cipherstate = (if v_171 then cipherstatepack(temp_k1_2,minnonce) else caught-fail) in
        {540}let v_172: bitstring = (if v_167 then catch-fail((if v_169 then (if v_171 then (ss_29,cs1_6,cs2_6) else fail-any) else fail-any)) else caught-fail) in
        {541}let v_173: bool = (not-caught-fail(v_172) && success?(1-proj-3-tuple(v_172))) in
        {542}let cs2_7: cipherstate = (if v_173 then 3-proj-3-tuple(v_172) else caught-fail) in
        {543}let cs1_7: cipherstate = (if v_173 then 2-proj-3-tuple(v_172) else caught-fail) in
        {544}let ssi_5: symmetricstate = (if v_173 then 1-proj-3-tuple(v_172) else caught-fail) in
        {523}let hs_10: handshakestate = (if v_167 then handshakestatepack(ss_29,s_5,m_5,e_9,rs_5,rm_5,re_6,psk_5,initiator_3) else caught-fail) in
        {545}let (hs_11: handshakestate,plaintext_a: bitstring,valid_2: bool,cs1_8: cipherstate,cs2_8: cipherstate) = (if v_128 then (if v_130 then (if v_133 then (if v_141 then (if v_149 then (if v_166 then (if undo-catch-fail(v_167) then (if v_173 then (hs_10,plaintext_2,true,cs1_7,cs2_7) else fail-any) else fail-any) else fail-any) else fail-any) else fail-any) else fail-any) else fail-any) else fail-any) in
        {546}event RecvMsg(me_2,them_2,stagepack_a(sid_3),plaintext_a);
        {547}event RecvEnd(valid_2)
    ) | (
        {549}event LeakS(phase0,me_2);
        {550}event LeakM(phase0,me_2);
        {551}out(pub, (key_s(me_2),key_m(me_2)))
    ) | (
        {552}phase 1;
        {553}event LeakS(phase1,me_2);
        {554}event LeakM(phase1,me_2);
        {555}out(pub, (key_s(me_2),key_m(me_2)))
    )
) | (
    {556}let me_3: principal = bob in
    {559}let basis_8: key = key_s(me_3) in
    {560}let public_key_8: key = catch-fail(dhexp(basis_8,validkey(g))) in
    {561}let v_174: bool = not-caught-fail(public_key_8) in
    {562}let s_6: keypair = (if v_174 then keypairpack(validkey(public_key_8),basis_8) else fail-any) in
    {563}let basis_9: key = key_m(me_3) in
    {564}let public_key_9: key = catch-fail(dhexp(basis_9,validkey(g))) in
    {565}let v_175: bool = not-caught-fail(public_key_9) in
    {566}let m_6: keypair = (if v_175 then keypairpack(validkey(public_key_9),basis_9) else fail-any) in
    {567}out(pub, (getpublickey(s_6),getpublickey(m_6)));
    {558}let sid_4: sessionid = sid in
    {557}let them_3: principal = charlie in
    (
        {577}let k_9: key = empty in
        {578}let cs_30: cipherstate = cipherstatepack(k_9,minnonce) in
        {574}let protocol_name_3: bitstring = somename in
        {575}let h_30: bitstring = hash(protocol_name_3,empty) in
        {576}let ck_36: key = h_30 in
        {579}let ss_30: symmetricstate = symmetricstatepack(cs_30,ck_36,h_30) in
        {580}let v_176: bitstring = catch-fail(symmetricstateunpack(ss_30)) in
        {581}let v_177: bool = (not-caught-fail(v_176) && success?(1-proj-3-tuple(v_176))) in
        {582}let h_31: bitstring = (if v_177 then 3-proj-3-tuple(v_176) else caught-fail) in
        {583}let ck_37: key = (if v_177 then 2-proj-3-tuple(v_176) else caught-fail) in
        {584}let cs_31: cipherstate = (if v_177 then 1-proj-3-tuple(v_176) else caught-fail) in
        {572}let prologue_3: bitstring = empty in
        {585}let ss_31: symmetricstate = catch-fail((if v_177 then symmetricstatepack(cs_31,ck_37,hash(h_31,prologue_3)) else fail-any)) in
        {586}let v_178: bool = not-caught-fail(ss_31) in
        {587}let data_2: bitstring = (if v_178 then catch-fail(getpublickey(s_6)) else caught-fail) in
        {588}let v_179: bool = not-caught-fail(data_2) in
        {589}let v_180: bitstring = (if v_179 then catch-fail(symmetricstateunpack(ss_31)) else caught-fail) in
        {590}let v_181: bool = (not-caught-fail(v_180) && success?(1-proj-3-tuple(v_180))) in
        {591}let h_32: bitstring = (if v_181 then 3-proj-3-tuple(v_180) else caught-fail) in
        {592}let ck_38: key = (if v_181 then 2-proj-3-tuple(v_180) else caught-fail) in
        {593}let cs_32: cipherstate = (if v_181 then 1-proj-3-tuple(v_180) else caught-fail) in
        {594}let ss_32: symmetricstate = (if v_178 then catch-fail((if v_179 then (if v_181 then symmetricstatepack(cs_32,ck_38,hash(h_32,data_2)) else fail-any) else fail-any)) else caught-fail) in
        {595}let v_182: bool = not-caught-fail(ss_32) in
        {596}let data_3: bitstring = (if v_182 then catch-fail(getpublickey(m_6)) else caught-fail) in
        {597}let v_183: bool = not-caught-fail(data_3) in
        {598}let v_184: bitstring = (if v_183 then catch-fail(symmetricstateunpack(ss_32)) else caught-fail) in
        {599}let v_185: bool = (not-caught-fail(v_184) && success?(1-proj-3-tuple(v_184))) in
        {600}let h_33: bitstring = (if v_185 then 3-proj-3-tuple(v_184) else caught-fail) in
        {601}let ck_39: key = (if v_185 then 2-proj-3-tuple(v_184) else caught-fail) in
        {602}let cs_33: cipherstate = (if v_185 then 1-proj-3-tuple(v_184) else caught-fail) in
        {603}let ss_33: symmetricstate = (if v_182 then catch-fail((if v_183 then (if v_185 then symmetricstatepack(cs_33,ck_39,hash(h_33,data_3)) else fail-any) else fail-any)) else caught-fail) in
        {604}let v_186: bool = not-caught-fail(ss_33) in
        {573}let psk_6: key = empty in
        {571}let re_7: key = empty in
        {570}let rm_6: key = empty in
        {569}let rs_6: key = empty in
        {568}let e_10: keypair = keypairpack(empty,empty) in
        {605}let hs_12: handshakestate = (if v_178 then (if v_182 then (if v_186 then handshakestatepack(ss_33,s_6,m_6,e_10,rs_6,rm_6,re_7,psk_6,false) else fail-any) else fail-any) else fail-any) in
        {606}insert statestore(me_3,them_3,sid_4,statepack_a(hs_12))
    ) | (
        {742}get statestore(=me_3,=them_3,=sid_4,statepack_a(hs_13: handshakestate)) in
        {607}in(pub, message_a_3: bitstring);
        {608}let v_187: bitstring = catch-fail(handshakestateunpack(hs_13)) in
        {609}let v_188: bool = (not-caught-fail(v_187) && success?(1-proj-9-tuple(v_187))) in
        {610}let initiator_4: bool = (if v_188 then 9-proj-9-tuple(v_187) else caught-fail) in
        {611}let psk_7: key = (if v_188 then 8-proj-9-tuple(v_187) else caught-fail) in
        {612}let re_8: key = (if v_188 then 7-proj-9-tuple(v_187) else caught-fail) in
        {613}let rm_7: key = (if v_188 then 6-proj-9-tuple(v_187) else caught-fail) in
        {614}let rs_7: key = (if v_188 then 5-proj-9-tuple(v_187) else caught-fail) in
        {615}let e_11: keypair = (if v_188 then 4-proj-9-tuple(v_187) else caught-fail) in
        {616}let m_7: keypair = (if v_188 then 3-proj-9-tuple(v_187) else caught-fail) in
        {617}let s_7: keypair = (if v_188 then 2-proj-9-tuple(v_187) else caught-fail) in
        {618}let ss_34: symmetricstate = (if v_188 then 1-proj-9-tuple(v_187) else caught-fail) in
        {619}let v_189: bitstring = (if v_188 then catch-fail(deconcat3(message_a_3)) else caught-fail) in
        {620}let v_190: bool = (not-caught-fail(v_189) && success?(1-proj-3-tuple(v_189))) in
        {621}let ciphertext_7: bitstring = (if v_190 then 3-proj-3-tuple(v_189) else caught-fail) in
        {622}let ns_3: bitstring = (if v_190 then 2-proj-3-tuple(v_189) else caught-fail) in
        {623}let ne_5: bitstring = (if v_190 then 1-proj-3-tuple(v_189) else caught-fail) in
        {626}let v_191: bitstring = (if v_190 then catch-fail(symmetricstateunpack(ss_34)) else caught-fail) in
        {627}let v_192: bool = (not-caught-fail(v_191) && success?(1-proj-3-tuple(v_191))) in
        {628}let h_34: bitstring = (if v_192 then 3-proj-3-tuple(v_191) else caught-fail) in
        {629}let ck_40: key = (if v_192 then 2-proj-3-tuple(v_191) else caught-fail) in
        {630}let cs_34: cipherstate = (if v_192 then 1-proj-3-tuple(v_191) else caught-fail) in
        {625}let re_9: key = (if v_190 then ne_5 else caught-fail) in
        {631}let ss_35: symmetricstate = (if v_190 then catch-fail((if v_192 then symmetricstatepack(cs_34,ck_40,hash(h_34,re_9)) else fail-any)) else caught-fail) in
        {632}let v_193: bool = not-caught-fail(ss_35) in
        {633}let v_194: bitstring = (if v_193 then catch-fail(keypairunpack(s_7)) else caught-fail) in
        {634}let v_195: bool = (not-caught-fail(v_194) && success?(1-proj-2-tuple(v_194))) in
        {635}let my_private_key_6: key = (if v_195 then 2-proj-2-tuple(v_194) else caught-fail) in
        {636}let my_public_key_6: key = (if v_195 then 1-proj-2-tuple(v_194) else caught-fail) in
        {637}let input_key_material_9: key = (if v_193 then catch-fail((if v_195 then dhexp(my_private_key_6,re_9) else fail-any)) else caught-fail) in
        {638}let v_196: bool = not-caught-fail(input_key_material_9) in
        {639}let v_197: bitstring = (if v_196 then catch-fail(symmetricstateunpack(ss_35)) else caught-fail) in
        {640}let v_198: bool = (not-caught-fail(v_197) && success?(1-proj-3-tuple(v_197))) in
        {641}let h_35: bitstring = (if v_198 then 3-proj-3-tuple(v_197) else caught-fail) in
        {642}let ck_41: key = (if v_198 then 2-proj-3-tuple(v_197) else caught-fail) in
        {643}let cs_35: cipherstate = (if v_198 then 1-proj-3-tuple(v_197) else caught-fail) in
        {646}let output3_9: key = (if v_198 then hmac_hash3(ck_41,input_key_material_9) else caught-fail) in
        {645}let output2_9: key = (if v_198 then hmac_hash2(ck_41,input_key_material_9) else caught-fail) in
        {644}let output1_9: key = (if v_198 then hmac_hash1(ck_41,input_key_material_9) else caught-fail) in
        {647}let v_199: bitstring = (if v_198 then catch-fail((output1_9,output2_9,output3_9)) else caught-fail) in
        {648}let v_200: bool = (not-caught-fail(v_199) && success?(1-proj-3-tuple(v_199))) in
        {649}let output_6: key = (if v_200 then 3-proj-3-tuple(v_199) else caught-fail) in
        {650}let temp_k_6: key = (if v_200 then 2-proj-3-tuple(v_199) else caught-fail) in
        {651}let ck_42: key = (if v_200 then 1-proj-3-tuple(v_199) else caught-fail) in
        {652}let ss_36: symmetricstate = (if v_193 then catch-fail((if v_196 then (if v_198 then (if v_200 then symmetricstatepack(cipherstatepack(temp_k_6,minnonce),ck_42,h_35) else fail-any) else fail-any) else fail-any)) else caught-fail) in
        {653}let v_201: bool = not-caught-fail(ss_36) in
        {654}let v_202: bitstring = (if v_201 then catch-fail(keypairunpack(m_7)) else caught-fail) in
        {655}let v_203: bool = (not-caught-fail(v_202) && success?(1-proj-2-tuple(v_202))) in
        {656}let my_private_key_7: key = (if v_203 then 2-proj-2-tuple(v_202) else caught-fail) in
        {657}let my_public_key_7: key = (if v_203 then 1-proj-2-tuple(v_202) else caught-fail) in
        {658}let input_key_material_10: key = (if v_201 then catch-fail((if v_203 then dhexp(my_private_key_7,re_9) else fail-any)) else caught-fail) in
        {659}let v_204: bool = not-caught-fail(input_key_material_10) in
        {660}let v_205: bitstring = (if v_204 then catch-fail(symmetricstateunpack(ss_36)) else caught-fail) in
        {661}let v_206: bool = (not-caught-fail(v_205) && success?(1-proj-3-tuple(v_205))) in
        {662}let h_36: bitstring = (if v_206 then 3-proj-3-tuple(v_205) else caught-fail) in
        {663}let ck_43: key = (if v_206 then 2-proj-3-tuple(v_205) else caught-fail) in
        {664}let cs_36: cipherstate = (if v_206 then 1-proj-3-tuple(v_205) else caught-fail) in
        {667}let output3_10: key = (if v_206 then hmac_hash3(ck_43,input_key_material_10) else caught-fail) in
        {666}let output2_10: key = (if v_206 then hmac_hash2(ck_43,input_key_material_10) else caught-fail) in
        {665}let output1_10: key = (if v_206 then hmac_hash1(ck_43,input_key_material_10) else caught-fail) in
        {668}let v_207: bitstring = (if v_206 then catch-fail((output1_10,output2_10,output3_10)) else caught-fail) in
        {669}let v_208: bool = (not-caught-fail(v_207) && success?(1-proj-3-tuple(v_207))) in
        {670}let output_7: key = (if v_208 then 3-proj-3-tuple(v_207) else caught-fail) in
        {671}let temp_k_7: key = (if v_208 then 2-proj-3-tuple(v_207) else caught-fail) in
        {672}let ck_44: key = (if v_208 then 1-proj-3-tuple(v_207) else caught-fail) in
        {673}let ss_37: symmetricstate = (if v_201 then catch-fail((if v_204 then (if v_206 then (if v_208 then symmetricstatepack(cipherstatepack(temp_k_7,minnonce),ck_44,h_36) else fail-any) else fail-any) else fail-any)) else caught-fail) in
        {674}let v_209: bool = not-caught-fail(ss_37) in
        {675}let v_210: bitstring = (if v_209 then catch-fail(symmetricstateunpack(ss_37)) else caught-fail) in
        {676}let v_211: bool = (not-caught-fail(v_210) && success?(1-proj-3-tuple(v_210))) in
        {677}let h_37: bitstring = (if v_211 then 3-proj-3-tuple(v_210) else caught-fail) in
        {678}let ck_45: key = (if v_211 then 2-proj-3-tuple(v_210) else caught-fail) in
        {679}let cs_37: cipherstate = (if v_211 then 1-proj-3-tuple(v_210) else caught-fail) in
        {680}let v_212: bitstring = (if v_211 then catch-fail(cipherstateunpack(cs_37)) else caught-fail) in
        {681}let v_213: bool = (not-caught-fail(v_212) && success?(1-proj-2-tuple(v_212))) in
        {682}let n_6: nonce = (if v_213 then 2-proj-2-tuple(v_212) else caught-fail) in
        {683}let k_10: key = (if v_213 then 1-proj-2-tuple(v_212) else caught-fail) in
        {684}let d_1: aead = (if v_213 then catch-fail(decrypt(k_10,n_6,h_37,ciphertext_7)) else caught-fail) in
        {685}let v_214: bool = not-caught-fail(d_1) in
        {686}let v_215: bitstring = (if v_214 then catch-fail(aeadunpack(d_1)) else caught-fail) in
        {687}let v_216: bool = (not-caught-fail(v_215) && success?(1-proj-3-tuple(v_215))) in
        {688}let plaintext_3: bitstring = (if v_216 then 3-proj-3-tuple(v_215) else caught-fail) in
        {689}let adi_1: bitstring = (if v_216 then 2-proj-3-tuple(v_215) else caught-fail) in
        {690}let valid_3: bool = (if v_216 then 1-proj-3-tuple(v_215) else caught-fail) in
        {692}let v_217: bitstring = (if v_216 then catch-fail(cipherstateunpack(cs_37)) else caught-fail) in
        {693}let v_218: bool = (not-caught-fail(v_217) && success?(1-proj-2-tuple(v_217))) in
        {694}let o_3: nonce = (if v_218 then 2-proj-2-tuple(v_217) else caught-fail) in
        {695}let k_11: key = (if v_218 then 1-proj-2-tuple(v_217) else caught-fail) in
        {691}let n_7: nonce = (if v_216 then increment_nonce(n_6) else caught-fail) in
        {696}let csi_6: cipherstate = (if v_216 then catch-fail((if v_218 then cipherstatepack(k_11,n_7) else fail-any)) else caught-fail) in
        {697}let v_219: bool = not-caught-fail(csi_6) in
        {698}let v_220: bitstring = (if v_211 then catch-fail((if v_213 then (if v_214 then (if v_216 then (if v_219 then (csi_6,plaintext_3,valid_3) else fail-any) else fail-any) else fail-any) else fail-any)) else caught-fail) in
        {699}let v_221: bool = (not-caught-fail(v_220) && success?(1-proj-3-tuple(v_220))) in
        {700}let valid_4: bool = (if v_221 then 3-proj-3-tuple(v_220) else caught-fail) in
        {701}let plaintext_4: bitstring = (if v_221 then 2-proj-3-tuple(v_220) else caught-fail) in
        {702}let csi_7: cipherstate = (if v_221 then 1-proj-3-tuple(v_220) else caught-fail) in
        {703}let ss_38: symmetricstate = (if v_221 then symmetricstatepack(csi_7,ck_45,h_37) else caught-fail) in
        {704}let v_222: bitstring = (if v_221 then catch-fail(symmetricstateunpack(ss_38)) else caught-fail) in
        {705}let v_223: bool = (not-caught-fail(v_222) && success?(1-proj-3-tuple(v_222))) in
        {706}let h_38: bitstring = (if v_223 then 3-proj-3-tuple(v_222) else caught-fail) in
        {707}let ck_46: key = (if v_223 then 2-proj-3-tuple(v_222) else caught-fail) in
        {708}let cs_38: cipherstate = (if v_223 then 1-proj-3-tuple(v_222) else caught-fail) in
        {709}let ssi_6: symmetricstate = (if v_221 then catch-fail((if v_223 then symmetricstatepack(cs_38,ck_46,hash(h_38,ciphertext_7)) else fail-any)) else caught-fail) in
        {710}let v_224: bool = not-caught-fail(ssi_6) in
        {711}let v_225: bitstring = (if v_209 then catch-fail((if v_211 then (if v_221 then (if v_224 then (ssi_6,plaintext_4,valid_4) else fail-any) else fail-any) else fail-any)) else caught-fail) in
        {712}let v_226: bool = (not-caught-fail(v_225) && success?(1-proj-3-tuple(v_225))) in
        {713}let valid2_1: bool = (if v_226 then 3-proj-3-tuple(v_225) else caught-fail) in
        {714}let plaintext_5: bitstring = (if v_226 then 2-proj-3-tuple(v_225) else caught-fail) in
        {715}let ss_39: symmetricstate = (if v_226 then 1-proj-3-tuple(v_225) else caught-fail) in
        {624}let valid1_1: bool = (if v_190 then true else caught-fail) in
        {716}let v_227: bool = (if v_226 then catch-fail((valid1_1 && valid2_1)) else caught-fail) in
        {718}let v_228: bitstring = (if v_227 then catch-fail(symmetricstateunpack(ss_39)) else caught-fail) in
        {719}let v_229: bool = (not-caught-fail(v_228) && success?(1-proj-3-tuple(v_228))) in
        {720}let h_39: bitstring = (if v_229 then 3-proj-3-tuple(v_228) else caught-fail) in
        {721}let ck_47: key = (if v_229 then 2-proj-3-tuple(v_228) else caught-fail) in
        {722}let cs_39: cipherstate = (if v_229 then 1-proj-3-tuple(v_228) else caught-fail) in
        {723}let input_key_material_11: key = (if v_229 then zero else caught-fail) in
        {726}let output3_11: key = (if v_229 then hmac_hash3(ck_47,input_key_material_11) else caught-fail) in
        {725}let output2_11: key = (if v_229 then hmac_hash2(ck_47,input_key_material_11) else caught-fail) in
        {724}let output1_11: key = (if v_229 then hmac_hash1(ck_47,input_key_material_11) else caught-fail) in
        {727}let v_230: bitstring = (if v_229 then catch-fail((output1_11,output2_11,output3_11)) else caught-fail) in
        {728}let v_231: bool = (not-caught-fail(v_230) && success?(1-proj-3-tuple(v_230))) in
        {729}let temp_k3_3: key = (if v_231 then 3-proj-3-tuple(v_230) else caught-fail) in
        {730}let temp_k2_3: key = (if v_231 then 2-proj-3-tuple(v_230) else caught-fail) in
        {731}let temp_k1_3: key = (if v_231 then 1-proj-3-tuple(v_230) else caught-fail) in
        {733}let cs2_9: cipherstate = (if v_231 then cipherstatepack(temp_k2_3,minnonce) else caught-fail) in
        {732}let cs1_9: cipherstate = (if v_231 then cipherstatepack(temp_k1_3,minnonce) else caught-fail) in
        {734}let v_232: bitstring = (if v_227 then catch-fail((if v_229 then (if v_231 then (ss_39,cs1_9,cs2_9) else fail-any) else fail-any)) else caught-fail) in
        {735}let v_233: bool = (not-caught-fail(v_232) && success?(1-proj-3-tuple(v_232))) in
        {736}let cs2_10: cipherstate = (if v_233 then 3-proj-3-tuple(v_232) else caught-fail) in
        {737}let cs1_10: cipherstate = (if v_233 then 2-proj-3-tuple(v_232) else caught-fail) in
        {738}let ssi_7: symmetricstate = (if v_233 then 1-proj-3-tuple(v_232) else caught-fail) in
        {717}let hs_14: handshakestate = (if v_227 then handshakestatepack(ss_39,s_7,m_7,e_11,rs_7,rm_7,re_9,psk_7,initiator_4) else caught-fail) in
        {739}let (hs_15: handshakestate,plaintext_a_1: bitstring,valid_5: bool,cs1_11: cipherstate,cs2_11: cipherstate) = (if v_188 then (if v_190 then (if v_193 then (if v_201 then (if v_209 then (if v_226 then (if undo-catch-fail(v_227) then (if v_233 then (hs_14,plaintext_5,true,cs1_10,cs2_10) else fail-any) else fail-any) else fail-any) else fail-any) else fail-any) else fail-any) else fail-any) else fail-any) in
        {740}event RecvMsg(me_3,them_3,stagepack_a(sid_4),plaintext_a_1);
        {741}event RecvEnd(valid_5)
    ) | (
        {743}event LeakS(phase0,me_3);
        {744}event LeakM(phase0,me_3);
        {745}out(pub, (key_s(me_3),key_m(me_3)))
    ) | (
        {746}phase 1;
        {747}event LeakS(phase1,me_3);
        {748}event LeakM(phase1,me_3);
        {749}out(pub, (key_s(me_3),key_m(me_3)))
    )
)

-- Query event(RecvMsg(bob,alice,stagepack_a(sid_b),msg)) ==> event(SendMsg(alice,bob,stagepack_a(sid_a),msg)); event(RecvMsg(bob,alice,stagepack_a(sid_b),msg)) ==> event(SendMsg(alice,c,stagepack_a(sid_a),msg)) || (event(LeakS(phase0,bob)) && event(LeakM(phase0,bob))); event(RecvMsg(bob,alice,stagepack_a(sid_b),msg)) ==> event(SendMsg(alice,c,stagepack_a(sid_a),msg)); event(RecvMsg(bob,alice,stagepack_a(sid_b),msg)) ==> event(SendMsg(alice,bob,stagepack_a(sid_a),msg)) || (event(LeakS(phase0,bob)) && event(LeakM(phase0,bob))); event(RecvMsg(bob,alice,stagepack_a(sid_b),msg)) ==> event(SendMsg(alice,bob,stagepack_a(sid_a),msg)); not attacker_p1(msg_a(alice,bob,sid_a)); attacker_p1(msg_a(alice,bob,sid_a)) ==> event(LeakS(px,bob)) && event(LeakM(px,bob)); attacker_p1(msg_a(alice,bob,sid_a)) ==> (event(LeakS(phase0,bob)) && event(LeakM(phase0,bob))) || (event(LeakS(px,bob)) && event(LeakM(px,bob)) && event(LeakS(pz,alice)) && event(LeakM(pz,alice))); attacker_p1(msg_a(alice,bob,sid_a)) ==> event(LeakS(phase0,bob)) && event(LeakM(phase0,bob)); not event(RecvEnd(true)) in process 1.
Translating the process into Horn clauses...
Completing...
200 rules inserted. Base: 200 rules (84 with conclusion selected). Queue: 49 rules.
400 rules inserted. Base: 394 rules (140 with conclusion selected). Queue: 58 rules.
600 rules inserted. Base: 592 rules (140 with conclusion selected). Queue: 116 rules.
800 rules inserted. Base: 776 rules (140 with conclusion selected). Queue: 163 rules.
1000 rules inserted. Base: 851 rules (140 with conclusion selected). Queue: 103 rules.
Starting query event(RecvMsg(bob,alice,stagepack_a(sid_b),msg)) ==> event(SendMsg(alice,bob,stagepack_a(sid_a),msg))
goal reachable: begin(SendMsg(alice,bob,stagepack_a(sid_5),msg_a(alice,bob,sid_5))) -> end(RecvMsg(bob,alice,stagepack_a(sid_6),msg_a(alice,bob,sid_5)))
Abbreviations:
sid_6 = sid[!1 = @sid]
sid_5 = sid[!1 = @sid_1]
RESULT event(RecvMsg(bob,alice,stagepack_a(sid_b),msg)) ==> event(SendMsg(alice,bob,stagepack_a(sid_a),msg)) is true.
Starting query event(RecvMsg(bob,alice,stagepack_a(sid_b),msg)) ==> event(SendMsg(alice,c,stagepack_a(sid_a),msg)) || (event(LeakS(phase0,bob)) && event(LeakM(phase0,bob)))
goal reachable: begin(SendMsg(alice,bob,stagepack_a(sid_5),msg_a(alice,bob,sid_5))) -> end(RecvMsg(bob,alice,stagepack_a(sid_6),msg_a(alice,bob,sid_5)))
Abbreviations:
sid_6 = sid[!1 = @sid]
sid_5 = sid[!1 = @sid_1]
RESULT event(RecvMsg(bob,alice,stagepack_a(sid_b),msg)) ==> event(SendMsg(alice,c,stagepack_a(sid_a),msg)) || (event(LeakS(phase0,bob)) && event(LeakM(phase0,bob))) is true.
Starting query event(RecvMsg(bob,alice,stagepack_a(sid_b),msg)) ==> event(SendMsg(alice,c,stagepack_a(sid_a),msg))
goal reachable: begin(SendMsg(alice,bob,stagepack_a(sid_5),msg_a(alice,bob,sid_5))) -> end(RecvMsg(bob,alice,stagepack_a(sid_6),msg_a(alice,bob,sid_5)))
Abbreviations:
sid_6 = sid[!1 = @sid]
sid_5 = sid[!1 = @sid_1]
RESULT event(RecvMsg(bob,alice,stagepack_a(sid_b),msg)) ==> event(SendMsg(alice,c,stagepack_a(sid_a),msg)) is true.
Starting query event(RecvMsg(bob,alice,stagepack_a(sid_b),msg)) ==> event(SendMsg(alice,bob,stagepack_a(sid_a),msg)) || (event(LeakS(phase0,bob)) && event(LeakM(phase0,bob)))
goal reachable: begin(SendMsg(alice,bob,stagepack_a(sid_5),msg_a(alice,bob,sid_5))) -> end(RecvMsg(bob,alice,stagepack_a(sid_6),msg_a(alice,bob,sid_5)))
Abbreviations:
sid_6 = sid[!1 = @sid]
sid_5 = sid[!1 = @sid_1]
RESULT event(RecvMsg(bob,alice,stagepack_a(sid_b),msg)) ==> event(SendMsg(alice,bob,stagepack_a(sid_a),msg)) || (event(LeakS(phase0,bob)) && event(LeakM(phase0,bob))) is true.
Starting query event(RecvMsg(bob,alice,stagepack_a(sid_b),msg)) ==> event(SendMsg(alice,bob,stagepack_a(sid_a),msg))
goal reachable: begin(SendMsg(alice,bob,stagepack_a(sid_5),msg_a(alice,bob,sid_5))) -> end(RecvMsg(bob,alice,stagepack_a(sid_6),msg_a(alice,bob,sid_5)))
Abbreviations:
sid_6 = sid[!1 = @sid]
sid_5 = sid[!1 = @sid_1]
RESULT event(RecvMsg(bob,alice,stagepack_a(sid_b),msg)) ==> event(SendMsg(alice,bob,stagepack_a(sid_a),msg)) is true.
Starting query not attacker_p1(msg_a(alice,bob,sid_a))
goal reachable: begin(LeakM(phase1,bob)) && begin(LeakS(phase1,bob)) && begin(SendMsg(alice,bob,stagepack_a(sid_5),msg_a(alice,bob,sid_5))) -> attacker_p1(msg_a(alice,bob,sid_5))
Abbreviations:
sid_5 = sid[!1 = @sid]

Derivation:
Abbreviations:
sid_5 = sid[!1 = @sid]

1. Using the function pub the attacker may obtain pub.
attacker(pub).

2. The entry statestore(alice,bob,sid_5,statepack_a(handshakestatepack(symmetricstatepack(cipherstatepack(empty,minnonce),hash(somename,empty),hash(hash(hash(hash(somename,empty),empty),validkey(dhexp_real(key_s(bob),g))),validkey(dhexp_real(key_m(bob),g)))),keypairpack(empty,empty),keypairpack(empty,empty),keypairpack(empty,empty),validkey(dhexp_real(key_s(bob),g)),validkey(dhexp_real(key_m(bob),g)),empty,empty,true))) may be inserted in a table at insert {49}.
table(statestore(alice,bob,sid_5,statepack_a(handshakestatepack(symmetricstatepack(cipherstatepack(empty,minnonce),hash(somename,empty),hash(hash(hash(hash(somename,empty),empty),validkey(dhexp_real(key_s(bob),g))),validkey(dhexp_real(key_m(bob),g)))),keypairpack(empty,empty),keypairpack(empty,empty),keypairpack(empty,empty),validkey(dhexp_real(key_s(bob),g)),validkey(dhexp_real(key_m(bob),g)),empty,empty,true)))).

3. The entry statestore(alice,bob,sid_5,statepack_a(handshakestatepack(symmetricstatepack(cipherstatepack(empty,minnonce),hash(somename,empty),hash(hash(hash(hash(somename,empty),empty),validkey(dhexp_real(key_s(bob),g))),validkey(dhexp_real(key_m(bob),g)))),keypairpack(empty,empty),keypairpack(empty,empty),keypairpack(empty,empty),validkey(dhexp_real(key_s(bob),g)),validkey(dhexp_real(key_m(bob),g)),empty,empty,true))) that may be in a table by 2 may be read at get {182}.
The event SendMsg(alice,bob,stagepack_a(sid_5),msg_a(alice,bob,sid_5)) may be executed at {180}.
So the message concat3(validkey(dhexp_real(key_e(alice,bob,sid_5),g)),empty,encrypt(hmac_hash2(hmac_hash1(hash(somename,empty),dhexp_real(key_e(alice,bob,sid_5),dhexp_real(key_s(bob),g))),dhexp_real(key_e(alice,bob,sid_5),dhexp_real(key_m(bob),g))),minnonce,hash(hash(hash(hash(hash(somename,empty),empty),validkey(dhexp_real(key_s(bob),g))),validkey(dhexp_real(key_m(bob),g))),validkey(dhexp_real(key_e(alice,bob,sid_5),g))),msg_a(alice,bob,sid_5))) may be sent on channel pub at output {181}.
mess(pub,concat3(validkey(dhexp_real(key_e(alice,bob,sid_5),g)),empty,encrypt(hmac_hash2(hmac_hash1(hash(somename,empty),dhexp_real(key_e(alice,bob,sid_5),dhexp_real(key_s(bob),g))),dhexp_real(key_e(alice,bob,sid_5),dhexp_real(key_m(bob),g))),minnonce,hash(hash(hash(hash(hash(somename,empty),empty),validkey(dhexp_real(key_s(bob),g))),validkey(dhexp_real(key_m(bob),g))),validkey(dhexp_real(key_e(alice,bob,sid_5),g))),msg_a(alice,bob,sid_5)))).

4. By 1, the attacker may have the channel pub.
By 3, the message concat3(validkey(dhexp_real(key_e(alice,bob,sid_5),g)),empty,encrypt(hmac_hash2(hmac_hash1(hash(somename,empty),dhexp_real(key_e(alice,bob,sid_5),dhexp_real(key_s(bob),g))),dhexp_real(key_e(alice,bob,sid_5),dhexp_real(key_m(bob),g))),minnonce,hash(hash(hash(hash(hash(somename,empty),empty),validkey(dhexp_real(key_s(bob),g))),validkey(dhexp_real(key_m(bob),g))),validkey(dhexp_real(key_e(alice,bob,sid_5),g))),msg_a(alice,bob,sid_5))) may be sent on this channel.
So the attacker may obtain the message concat3(validkey(dhexp_real(key_e(alice,bob,sid_5),g)),empty,encrypt(hmac_hash2(hmac_hash1(hash(somename,empty),dhexp_real(key_e(alice,bob,sid_5),dhexp_real(key_s(bob),g))),dhexp_real(key_e(alice,bob,sid_5),dhexp_real(key_m(bob),g))),minnonce,hash(hash(hash(hash(hash(somename,empty),empty),validkey(dhexp_real(key_s(bob),g))),validkey(dhexp_real(key_m(bob),g))),validkey(dhexp_real(key_e(alice,bob,sid_5),g))),msg_a(alice,bob,sid_5))) by listening on this channel.
attacker(concat3(validkey(dhexp_real(key_e(alice,bob,sid_5),g)),empty,encrypt(hmac_hash2(hmac_hash1(hash(somename,empty),dhexp_real(key_e(alice,bob,sid_5),dhexp_real(key_s(bob),g))),dhexp_real(key_e(alice,bob,sid_5),dhexp_real(key_m(bob),g))),minnonce,hash(hash(hash(hash(hash(somename,empty),empty),validkey(dhexp_real(key_s(bob),g))),validkey(dhexp_real(key_m(bob),g))),validkey(dhexp_real(key_e(alice,bob,sid_5),g))),msg_a(alice,bob,sid_5)))).

5. By 4, the attacker may know concat3(validkey(dhexp_real(key_e(alice,bob,sid_5),g)),empty,encrypt(hmac_hash2(hmac_hash1(hash(somename,empty),dhexp_real(key_e(alice,bob,sid_5),dhexp_real(key_s(bob),g))),dhexp_real(key_e(alice,bob,sid_5),dhexp_real(key_m(bob),g))),minnonce,hash(hash(hash(hash(hash(somename,empty),empty),validkey(dhexp_real(key_s(bob),g))),validkey(dhexp_real(key_m(bob),g))),validkey(dhexp_real(key_e(alice,bob,sid_5),g))),msg_a(alice,bob,sid_5))).
Using the function 3-proj-concat3 the attacker may obtain encrypt(hmac_hash2(hmac_hash1(hash(somename,empty),dhexp_real(key_e(alice,bob,sid_5),dhexp_real(key_s(bob),g))),dhexp_real(key_e(alice,bob,sid_5),dhexp_real(key_m(bob),g))),minnonce,hash(hash(hash(hash(hash(somename,empty),empty),validkey(dhexp_real(key_s(bob),g))),validkey(dhexp_real(key_m(bob),g))),validkey(dhexp_real(key_e(alice,bob,sid_5),g))),msg_a(alice,bob,sid_5)).
attacker(encrypt(hmac_hash2(hmac_hash1(hash(somename,empty),dhexp_real(key_e(alice,bob,sid_5),dhexp_real(key_s(bob),g))),dhexp_real(key_e(alice,bob,sid_5),dhexp_real(key_m(bob),g))),minnonce,hash(hash(hash(hash(hash(somename,empty),empty),validkey(dhexp_real(key_s(bob),g))),validkey(dhexp_real(key_m(bob),g))),validkey(dhexp_real(key_e(alice,bob,sid_5),g))),msg_a(alice,bob,sid_5))).

6. By 5, the attacker may know encrypt(hmac_hash2(hmac_hash1(hash(somename,empty),dhexp_real(key_e(alice,bob,sid_5),dhexp_real(key_s(bob),g))),dhexp_real(key_e(alice,bob,sid_5),dhexp_real(key_m(bob),g))),minnonce,hash(hash(hash(hash(hash(somename,empty),empty),validkey(dhexp_real(key_s(bob),g))),validkey(dhexp_real(key_m(bob),g))),validkey(dhexp_real(key_e(alice,bob,sid_5),g))),msg_a(alice,bob,sid_5)).
So the attacker may know encrypt(hmac_hash2(hmac_hash1(hash(somename,empty),dhexp_real(key_e(alice,bob,sid_5),dhexp_real(key_s(bob),g))),dhexp_real(key_e(alice,bob,sid_5),dhexp_real(key_m(bob),g))),minnonce,hash(hash(hash(hash(hash(somename,empty),empty),validkey(dhexp_real(key_s(bob),g))),validkey(dhexp_real(key_m(bob),g))),validkey(dhexp_real(key_e(alice,bob,sid_5),g))),msg_a(alice,bob,sid_5)) in phase 1.
attacker_p1(encrypt(hmac_hash2(hmac_hash1(hash(somename,empty),dhexp_real(key_e(alice,bob,sid_5),dhexp_real(key_s(bob),g))),dhexp_real(key_e(alice,bob,sid_5),dhexp_real(key_m(bob),g))),minnonce,hash(hash(hash(hash(hash(somename,empty),empty),validkey(dhexp_real(key_s(bob),g))),validkey(dhexp_real(key_m(bob),g))),validkey(dhexp_real(key_e(alice,bob,sid_5),g))),msg_a(alice,bob,sid_5))).

7. By 4, the attacker may know concat3(validkey(dhexp_real(key_e(alice,bob,sid_5),g)),empty,encrypt(hmac_hash2(hmac_hash1(hash(somename,empty),dhexp_real(key_e(alice,bob,sid_5),dhexp_real(key_s(bob),g))),dhexp_real(key_e(alice,bob,sid_5),dhexp_real(key_m(bob),g))),minnonce,hash(hash(hash(hash(hash(somename,empty),empty),validkey(dhexp_real(key_s(bob),g))),validkey(dhexp_real(key_m(bob),g))),validkey(dhexp_real(key_e(alice,bob,sid_5),g))),msg_a(alice,bob,sid_5))).
Using the function 1-proj-concat3 the attacker may obtain validkey(dhexp_real(key_e(alice,bob,sid_5),g)).
attacker(validkey(dhexp_real(key_e(alice,bob,sid_5),g))).

8. The message (validkey(dhexp_real(key_s(bob),g)),validkey(dhexp_real(key_m(bob),g))) may be sent on channel pub at output {373}.
mess(pub,(validkey(dhexp_real(key_s(bob),g)),validkey(dhexp_real(key_m(bob),g)))).

9. By 1, the attacker may have the channel pub.
By 8, the message (validkey(dhexp_real(key_s(bob),g)),validkey(dhexp_real(key_m(bob),g))) may be sent on this channel.
So the attacker may obtain the message (validkey(dhexp_real(key_s(bob),g)),validkey(dhexp_real(key_m(bob),g))) by listening on this channel.
attacker((validkey(dhexp_real(key_s(bob),g)),validkey(dhexp_real(key_m(bob),g)))).

10. By 9, the attacker may know (validkey(dhexp_real(key_s(bob),g)),validkey(dhexp_real(key_m(bob),g))).
Using the function 2-proj-2-tuple the attacker may obtain validkey(dhexp_real(key_m(bob),g)).
attacker(validkey(dhexp_real(key_m(bob),g))).

11. By 9, the attacker may know (validkey(dhexp_real(key_s(bob),g)),validkey(dhexp_real(key_m(bob),g))).
Using the function 1-proj-2-tuple the attacker may obtain validkey(dhexp_real(key_s(bob),g)).
attacker(validkey(dhexp_real(key_s(bob),g))).

12. Using the function empty the attacker may obtain empty.
attacker(empty).

13. Using the function somename the attacker may obtain somename.
attacker(somename).

14. By 13, the attacker may know somename.
By 12, the attacker may know empty.
Using the function hash the attacker may obtain hash(somename,empty).
attacker(hash(somename,empty)).

15. By 14, the attacker may know hash(somename,empty).
By 12, the attacker may know empty.
Using the function hash the attacker may obtain hash(hash(somename,empty),empty).
attacker(hash(hash(somename,empty),empty)).

16. By 15, the attacker may know hash(hash(somename,empty),empty).
By 11, the attacker may know validkey(dhexp_real(key_s(bob),g)).
Using the function hash the attacker may obtain hash(hash(hash(somename,empty),empty),validkey(dhexp_real(key_s(bob),g))).
attacker(hash(hash(hash(somename,empty),empty),validkey(dhexp_real(key_s(bob),g)))).

17. By 16, the attacker may know hash(hash(hash(somename,empty),empty),validkey(dhexp_real(key_s(bob),g))).
By 10, the attacker may know validkey(dhexp_real(key_m(bob),g)).
Using the function hash the attacker may obtain hash(hash(hash(hash(somename,empty),empty),validkey(dhexp_real(key_s(bob),g))),validkey(dhexp_real(key_m(bob),g))).
attacker(hash(hash(hash(hash(somename,empty),empty),validkey(dhexp_real(key_s(bob),g))),validkey(dhexp_real(key_m(bob),g)))).

18. By 17, the attacker may know hash(hash(hash(hash(somename,empty),empty),validkey(dhexp_real(key_s(bob),g))),validkey(dhexp_real(key_m(bob),g))).
By 7, the attacker may know validkey(dhexp_real(key_e(alice,bob,sid_5),g)).
Using the function hash the attacker may obtain hash(hash(hash(hash(hash(somename,empty),empty),validkey(dhexp_real(key_s(bob),g))),validkey(dhexp_real(key_m(bob),g))),validkey(dhexp_real(key_e(alice,bob,sid_5),g))).
attacker(hash(hash(hash(hash(hash(somename,empty),empty),validkey(dhexp_real(key_s(bob),g))),validkey(dhexp_real(key_m(bob),g))),validkey(dhexp_real(key_e(alice,bob,sid_5),g)))).

19. By 18, the attacker may know hash(hash(hash(hash(hash(somename,empty),empty),validkey(dhexp_real(key_s(bob),g))),validkey(dhexp_real(key_m(bob),g))),validkey(dhexp_real(key_e(alice,bob,sid_5),g))).
So the attacker may know hash(hash(hash(hash(hash(somename,empty),empty),validkey(dhexp_real(key_s(bob),g))),validkey(dhexp_real(key_m(bob),g))),validkey(dhexp_real(key_e(alice,bob,sid_5),g))) in phase 1.
attacker_p1(hash(hash(hash(hash(hash(somename,empty),empty),validkey(dhexp_real(key_s(bob),g))),validkey(dhexp_real(key_m(bob),g))),validkey(dhexp_real(key_e(alice,bob,sid_5),g)))).

20. Using the function minnonce the attacker may obtain minnonce in phase 1.
attacker_p1(minnonce).

21. By 7, the attacker may know validkey(dhexp_real(key_e(alice,bob,sid_5),g)).
So the attacker may know validkey(dhexp_real(key_e(alice,bob,sid_5),g)) in phase 1.
attacker_p1(validkey(dhexp_real(key_e(alice,bob,sid_5),g))).

22. Using the function pub the attacker may obtain pub in phase 1.
attacker_p1(pub).

23. The event LeakS(phase1,bob) may be executed at {553}.
The event LeakM(phase1,bob) may be executed at {554}.
So the message (key_s(bob),key_m(bob)) may be sent on channel pub in phase 1 at output {555}.
mess_p1(pub,(key_s(bob),key_m(bob))).

24. By 22, the attacker may have the channel pub in phase 1.
By 23, the message (key_s(bob),key_m(bob)) in phase 1 may be sent on this channel.
So the attacker may obtain the message (key_s(bob),key_m(bob)) in phase 1 by listening on this channel.
attacker_p1((key_s(bob),key_m(bob))).

25. By 24, the attacker may know (key_s(bob),key_m(bob)) in phase 1.
Using the function 2-proj-2-tuple the attacker may obtain key_m(bob) in phase 1.
attacker_p1(key_m(bob)).

26. By 25, the attacker may know key_m(bob) in phase 1.
By 21, the attacker may know validkey(dhexp_real(key_e(alice,bob,sid_5),g)) in phase 1.
Using the function dhexp the attacker may obtain dhexp_real(key_e(alice,bob,sid_5),dhexp_real(key_m(bob),g)) in phase 1.
attacker_p1(dhexp_real(key_e(alice,bob,sid_5),dhexp_real(key_m(bob),g))).

27. By 24, the attacker may know (key_s(bob),key_m(bob)) in phase 1.
Using the function 1-proj-2-tuple the attacker may obtain key_s(bob) in phase 1.
attacker_p1(key_s(bob)).

28. By 27, the attacker may know key_s(bob) in phase 1.
By 21, the attacker may know validkey(dhexp_real(key_e(alice,bob,sid_5),g)) in phase 1.
Using the function dhexp the attacker may obtain dhexp_real(key_e(alice,bob,sid_5),dhexp_real(key_s(bob),g)) in phase 1.
attacker_p1(dhexp_real(key_e(alice,bob,sid_5),dhexp_real(key_s(bob),g))).

29. Using the function empty the attacker may obtain empty in phase 1.
attacker_p1(empty).

30. Using the function somename the attacker may obtain somename in phase 1.
attacker_p1(somename).

31. By 30, the attacker may know somename in phase 1.
By 29, the attacker may know empty in phase 1.
Using the function hash the attacker may obtain hash(somename,empty) in phase 1.
attacker_p1(hash(somename,empty)).

32. By 31, the attacker may know hash(somename,empty) in phase 1.
By 28, the attacker may know dhexp_real(key_e(alice,bob,sid_5),dhexp_real(key_s(bob),g)) in phase 1.
Using the function hmac_hash1 the attacker may obtain hmac_hash1(hash(somename,empty),dhexp_real(key_e(alice,bob,sid_5),dhexp_real(key_s(bob),g))) in phase 1.
attacker_p1(hmac_hash1(hash(somename,empty),dhexp_real(key_e(alice,bob,sid_5),dhexp_real(key_s(bob),g)))).

33. By 32, the attacker may know hmac_hash1(hash(somename,empty),dhexp_real(key_e(alice,bob,sid_5),dhexp_real(key_s(bob),g))) in phase 1.
By 26, the attacker may know dhexp_real(key_e(alice,bob,sid_5),dhexp_real(key_m(bob),g)) in phase 1.
Using the function hmac_hash2 the attacker may obtain hmac_hash2(hmac_hash1(hash(somename,empty),dhexp_real(key_e(alice,bob,sid_5),dhexp_real(key_s(bob),g))),dhexp_real(key_e(alice,bob,sid_5),dhexp_real(key_m(bob),g))) in phase 1.
attacker_p1(hmac_hash2(hmac_hash1(hash(somename,empty),dhexp_real(key_e(alice,bob,sid_5),dhexp_real(key_s(bob),g))),dhexp_real(key_e(alice,bob,sid_5),dhexp_real(key_m(bob),g)))).

34. By 33, the attacker may know hmac_hash2(hmac_hash1(hash(somename,empty),dhexp_real(key_e(alice,bob,sid_5),dhexp_real(key_s(bob),g))),dhexp_real(key_e(alice,bob,sid_5),dhexp_real(key_m(bob),g))) in phase 1.
By 20, the attacker may know minnonce in phase 1.
By 19, the attacker may know hash(hash(hash(hash(hash(somename,empty),empty),validkey(dhexp_real(key_s(bob),g))),validkey(dhexp_real(key_m(bob),g))),validkey(dhexp_real(key_e(alice,bob,sid_5),g))) in phase 1.
By 6, the attacker may know encrypt(hmac_hash2(hmac_hash1(hash(somename,empty),dhexp_real(key_e(alice,bob,sid_5),dhexp_real(key_s(bob),g))),dhexp_real(key_e(alice,bob,sid_5),dhexp_real(key_m(bob),g))),minnonce,hash(hash(hash(hash(hash(somename,empty),empty),validkey(dhexp_real(key_s(bob),g))),validkey(dhexp_real(key_m(bob),g))),validkey(dhexp_real(key_e(alice,bob,sid_5),g))),msg_a(alice,bob,sid_5)) in phase 1.
Using the function decrypt the attacker may obtain aeadpack(true,hash(hash(hash(hash(hash(somename,empty),empty),validkey(dhexp_real(key_s(bob),g))),validkey(dhexp_real(key_m(bob),g))),validkey(dhexp_real(key_e(alice,bob,sid_5),g))),msg_a(alice,bob,sid_5)) in phase 1.
attacker_p1(aeadpack(true,hash(hash(hash(hash(hash(somename,empty),empty),validkey(dhexp_real(key_s(bob),g))),validkey(dhexp_real(key_m(bob),g))),validkey(dhexp_real(key_e(alice,bob,sid_5),g))),msg_a(alice,bob,sid_5))).

35. By 34, the attacker may know aeadpack(true,hash(hash(hash(hash(hash(somename,empty),empty),validkey(dhexp_real(key_s(bob),g))),validkey(dhexp_real(key_m(bob),g))),validkey(dhexp_real(key_e(alice,bob,sid_5),g))),msg_a(alice,bob,sid_5)) in phase 1.
Using the function 3-proj-aeadpack the attacker may obtain msg_a(alice,bob,sid_5) in phase 1.
attacker_p1(msg_a(alice,bob,sid_5)).

36. By 35, attacker_p1(msg_a(alice,bob,sid_5)).
The goal is reached, represented in the following fact:
attacker_p1(msg_a(alice,bob,sid_5)).


RESULT not attacker_p1(msg_a(alice,bob,sid_a)) cannot be proved.
Starting query attacker_p1(msg_a(alice,bob,sid_a)) ==> event(LeakS(px,bob)) && event(LeakM(px,bob))
goal reachable: begin(LeakM(phase1,bob)) && begin(LeakS(phase1,bob)) && begin(SendMsg(alice,bob,stagepack_a(sid_5),msg_a(alice,bob,sid_5))) -> attacker_p1(msg_a(alice,bob,sid_5))
Abbreviations:
sid_5 = sid[!1 = @sid]
goal reachable: begin(LeakM(phase0,bob)) && begin(LeakS(phase0,bob)) && begin(SendMsg(alice,bob,stagepack_a(sid_5),msg_a(alice,bob,sid_5))) -> attacker_p1(msg_a(alice,bob,sid_5))
Abbreviations:
sid_5 = sid[!1 = @sid]
RESULT attacker_p1(msg_a(alice,bob,sid_a)) ==> event(LeakS(px,bob)) && event(LeakM(px,bob)) is true.
Starting query attacker_p1(msg_a(alice,bob,sid_a)) ==> (event(LeakS(phase0,bob)) && event(LeakM(phase0,bob))) || (event(LeakS(px,bob)) && event(LeakM(px,bob)) && event(LeakS(pz,alice)) && event(LeakM(pz,alice)))
goal reachable: begin(LeakM(phase1,bob)) && begin(LeakS(phase1,bob)) && begin(SendMsg(alice,bob,stagepack_a(sid_5),msg_a(alice,bob,sid_5))) -> attacker_p1(msg_a(alice,bob,sid_5))
Abbreviations:
sid_5 = sid[!1 = @sid]

Derivation:
Abbreviations:
sid_5 = sid[!1 = @sid]

1. Using the function pub the attacker may obtain pub.
attacker(pub).

2. The entry statestore(alice,bob,sid_5,statepack_a(handshakestatepack(symmetricstatepack(cipherstatepack(empty,minnonce),hash(somename,empty),hash(hash(hash(hash(somename,empty),empty),validkey(dhexp_real(key_s(bob),g))),validkey(dhexp_real(key_m(bob),g)))),keypairpack(empty,empty),keypairpack(empty,empty),keypairpack(empty,empty),validkey(dhexp_real(key_s(bob),g)),validkey(dhexp_real(key_m(bob),g)),empty,empty,true))) may be inserted in a table at insert {49}.
table(statestore(alice,bob,sid_5,statepack_a(handshakestatepack(symmetricstatepack(cipherstatepack(empty,minnonce),hash(somename,empty),hash(hash(hash(hash(somename,empty),empty),validkey(dhexp_real(key_s(bob),g))),validkey(dhexp_real(key_m(bob),g)))),keypairpack(empty,empty),keypairpack(empty,empty),keypairpack(empty,empty),validkey(dhexp_real(key_s(bob),g)),validkey(dhexp_real(key_m(bob),g)),empty,empty,true)))).

3. The entry statestore(alice,bob,sid_5,statepack_a(handshakestatepack(symmetricstatepack(cipherstatepack(empty,minnonce),hash(somename,empty),hash(hash(hash(hash(somename,empty),empty),validkey(dhexp_real(key_s(bob),g))),validkey(dhexp_real(key_m(bob),g)))),keypairpack(empty,empty),keypairpack(empty,empty),keypairpack(empty,empty),validkey(dhexp_real(key_s(bob),g)),validkey(dhexp_real(key_m(bob),g)),empty,empty,true))) that may be in a table by 2 may be read at get {182}.
The event SendMsg(alice,bob,stagepack_a(sid_5),msg_a(alice,bob,sid_5)) may be executed at {180}.
So the message concat3(validkey(dhexp_real(key_e(alice,bob,sid_5),g)),empty,encrypt(hmac_hash2(hmac_hash1(hash(somename,empty),dhexp_real(key_e(alice,bob,sid_5),dhexp_real(key_s(bob),g))),dhexp_real(key_e(alice,bob,sid_5),dhexp_real(key_m(bob),g))),minnonce,hash(hash(hash(hash(hash(somename,empty),empty),validkey(dhexp_real(key_s(bob),g))),validkey(dhexp_real(key_m(bob),g))),validkey(dhexp_real(key_e(alice,bob,sid_5),g))),msg_a(alice,bob,sid_5))) may be sent on channel pub at output {181}.
mess(pub,concat3(validkey(dhexp_real(key_e(alice,bob,sid_5),g)),empty,encrypt(hmac_hash2(hmac_hash1(hash(somename,empty),dhexp_real(key_e(alice,bob,sid_5),dhexp_real(key_s(bob),g))),dhexp_real(key_e(alice,bob,sid_5),dhexp_real(key_m(bob),g))),minnonce,hash(hash(hash(hash(hash(somename,empty),empty),validkey(dhexp_real(key_s(bob),g))),validkey(dhexp_real(key_m(bob),g))),validkey(dhexp_real(key_e(alice,bob,sid_5),g))),msg_a(alice,bob,sid_5)))).

4. By 1, the attacker may have the channel pub.
By 3, the message concat3(validkey(dhexp_real(key_e(alice,bob,sid_5),g)),empty,encrypt(hmac_hash2(hmac_hash1(hash(somename,empty),dhexp_real(key_e(alice,bob,sid_5),dhexp_real(key_s(bob),g))),dhexp_real(key_e(alice,bob,sid_5),dhexp_real(key_m(bob),g))),minnonce,hash(hash(hash(hash(hash(somename,empty),empty),validkey(dhexp_real(key_s(bob),g))),validkey(dhexp_real(key_m(bob),g))),validkey(dhexp_real(key_e(alice,bob,sid_5),g))),msg_a(alice,bob,sid_5))) may be sent on this channel.
So the attacker may obtain the message concat3(validkey(dhexp_real(key_e(alice,bob,sid_5),g)),empty,encrypt(hmac_hash2(hmac_hash1(hash(somename,empty),dhexp_real(key_e(alice,bob,sid_5),dhexp_real(key_s(bob),g))),dhexp_real(key_e(alice,bob,sid_5),dhexp_real(key_m(bob),g))),minnonce,hash(hash(hash(hash(hash(somename,empty),empty),validkey(dhexp_real(key_s(bob),g))),validkey(dhexp_real(key_m(bob),g))),validkey(dhexp_real(key_e(alice,bob,sid_5),g))),msg_a(alice,bob,sid_5))) by listening on this channel.
attacker(concat3(validkey(dhexp_real(key_e(alice,bob,sid_5),g)),empty,encrypt(hmac_hash2(hmac_hash1(hash(somename,empty),dhexp_real(key_e(alice,bob,sid_5),dhexp_real(key_s(bob),g))),dhexp_real(key_e(alice,bob,sid_5),dhexp_real(key_m(bob),g))),minnonce,hash(hash(hash(hash(hash(somename,empty),empty),validkey(dhexp_real(key_s(bob),g))),validkey(dhexp_real(key_m(bob),g))),validkey(dhexp_real(key_e(alice,bob,sid_5),g))),msg_a(alice,bob,sid_5)))).

5. By 4, the attacker may know concat3(validkey(dhexp_real(key_e(alice,bob,sid_5),g)),empty,encrypt(hmac_hash2(hmac_hash1(hash(somename,empty),dhexp_real(key_e(alice,bob,sid_5),dhexp_real(key_s(bob),g))),dhexp_real(key_e(alice,bob,sid_5),dhexp_real(key_m(bob),g))),minnonce,hash(hash(hash(hash(hash(somename,empty),empty),validkey(dhexp_real(key_s(bob),g))),validkey(dhexp_real(key_m(bob),g))),validkey(dhexp_real(key_e(alice,bob,sid_5),g))),msg_a(alice,bob,sid_5))).
Using the function 3-proj-concat3 the attacker may obtain encrypt(hmac_hash2(hmac_hash1(hash(somename,empty),dhexp_real(key_e(alice,bob,sid_5),dhexp_real(key_s(bob),g))),dhexp_real(key_e(alice,bob,sid_5),dhexp_real(key_m(bob),g))),minnonce,hash(hash(hash(hash(hash(somename,empty),empty),validkey(dhexp_real(key_s(bob),g))),validkey(dhexp_real(key_m(bob),g))),validkey(dhexp_real(key_e(alice,bob,sid_5),g))),msg_a(alice,bob,sid_5)).
attacker(encrypt(hmac_hash2(hmac_hash1(hash(somename,empty),dhexp_real(key_e(alice,bob,sid_5),dhexp_real(key_s(bob),g))),dhexp_real(key_e(alice,bob,sid_5),dhexp_real(key_m(bob),g))),minnonce,hash(hash(hash(hash(hash(somename,empty),empty),validkey(dhexp_real(key_s(bob),g))),validkey(dhexp_real(key_m(bob),g))),validkey(dhexp_real(key_e(alice,bob,sid_5),g))),msg_a(alice,bob,sid_5))).

6. By 5, the attacker may know encrypt(hmac_hash2(hmac_hash1(hash(somename,empty),dhexp_real(key_e(alice,bob,sid_5),dhexp_real(key_s(bob),g))),dhexp_real(key_e(alice,bob,sid_5),dhexp_real(key_m(bob),g))),minnonce,hash(hash(hash(hash(hash(somename,empty),empty),validkey(dhexp_real(key_s(bob),g))),validkey(dhexp_real(key_m(bob),g))),validkey(dhexp_real(key_e(alice,bob,sid_5),g))),msg_a(alice,bob,sid_5)).
So the attacker may know encrypt(hmac_hash2(hmac_hash1(hash(somename,empty),dhexp_real(key_e(alice,bob,sid_5),dhexp_real(key_s(bob),g))),dhexp_real(key_e(alice,bob,sid_5),dhexp_real(key_m(bob),g))),minnonce,hash(hash(hash(hash(hash(somename,empty),empty),validkey(dhexp_real(key_s(bob),g))),validkey(dhexp_real(key_m(bob),g))),validkey(dhexp_real(key_e(alice,bob,sid_5),g))),msg_a(alice,bob,sid_5)) in phase 1.
attacker_p1(encrypt(hmac_hash2(hmac_hash1(hash(somename,empty),dhexp_real(key_e(alice,bob,sid_5),dhexp_real(key_s(bob),g))),dhexp_real(key_e(alice,bob,sid_5),dhexp_real(key_m(bob),g))),minnonce,hash(hash(hash(hash(hash(somename,empty),empty),validkey(dhexp_real(key_s(bob),g))),validkey(dhexp_real(key_m(bob),g))),validkey(dhexp_real(key_e(alice,bob,sid_5),g))),msg_a(alice,bob,sid_5))).

7. By 4, the attacker may know concat3(validkey(dhexp_real(key_e(alice,bob,sid_5),g)),empty,encrypt(hmac_hash2(hmac_hash1(hash(somename,empty),dhexp_real(key_e(alice,bob,sid_5),dhexp_real(key_s(bob),g))),dhexp_real(key_e(alice,bob,sid_5),dhexp_real(key_m(bob),g))),minnonce,hash(hash(hash(hash(hash(somename,empty),empty),validkey(dhexp_real(key_s(bob),g))),validkey(dhexp_real(key_m(bob),g))),validkey(dhexp_real(key_e(alice,bob,sid_5),g))),msg_a(alice,bob,sid_5))).
Using the function 1-proj-concat3 the attacker may obtain validkey(dhexp_real(key_e(alice,bob,sid_5),g)).
attacker(validkey(dhexp_real(key_e(alice,bob,sid_5),g))).

8. The message (validkey(dhexp_real(key_s(bob),g)),validkey(dhexp_real(key_m(bob),g))) may be sent on channel pub at output {373}.
mess(pub,(validkey(dhexp_real(key_s(bob),g)),validkey(dhexp_real(key_m(bob),g)))).

9. By 1, the attacker may have the channel pub.
By 8, the message (validkey(dhexp_real(key_s(bob),g)),validkey(dhexp_real(key_m(bob),g))) may be sent on this channel.
So the attacker may obtain the message (validkey(dhexp_real(key_s(bob),g)),validkey(dhexp_real(key_m(bob),g))) by listening on this channel.
attacker((validkey(dhexp_real(key_s(bob),g)),validkey(dhexp_real(key_m(bob),g)))).

10. By 9, the attacker may know (validkey(dhexp_real(key_s(bob),g)),validkey(dhexp_real(key_m(bob),g))).
Using the function 2-proj-2-tuple the attacker may obtain validkey(dhexp_real(key_m(bob),g)).
attacker(validkey(dhexp_real(key_m(bob),g))).

11. By 9, the attacker may know (validkey(dhexp_real(key_s(bob),g)),validkey(dhexp_real(key_m(bob),g))).
Using the function 1-proj-2-tuple the attacker may obtain validkey(dhexp_real(key_s(bob),g)).
attacker(validkey(dhexp_real(key_s(bob),g))).

12. Using the function empty the attacker may obtain empty.
attacker(empty).

13. Using the function somename the attacker may obtain somename.
attacker(somename).

14. By 13, the attacker may know somename.
By 12, the attacker may know empty.
Using the function hash the attacker may obtain hash(somename,empty).
attacker(hash(somename,empty)).

15. By 14, the attacker may know hash(somename,empty).
By 12, the attacker may know empty.
Using the function hash the attacker may obtain hash(hash(somename,empty),empty).
attacker(hash(hash(somename,empty),empty)).

16. By 15, the attacker may know hash(hash(somename,empty),empty).
By 11, the attacker may know validkey(dhexp_real(key_s(bob),g)).
Using the function hash the attacker may obtain hash(hash(hash(somename,empty),empty),validkey(dhexp_real(key_s(bob),g))).
attacker(hash(hash(hash(somename,empty),empty),validkey(dhexp_real(key_s(bob),g)))).

17. By 16, the attacker may know hash(hash(hash(somename,empty),empty),validkey(dhexp_real(key_s(bob),g))).
By 10, the attacker may know validkey(dhexp_real(key_m(bob),g)).
Using the function hash the attacker may obtain hash(hash(hash(hash(somename,empty),empty),validkey(dhexp_real(key_s(bob),g))),validkey(dhexp_real(key_m(bob),g))).
attacker(hash(hash(hash(hash(somename,empty),empty),validkey(dhexp_real(key_s(bob),g))),validkey(dhexp_real(key_m(bob),g)))).

18. By 17, the attacker may know hash(hash(hash(hash(somename,empty),empty),validkey(dhexp_real(key_s(bob),g))),validkey(dhexp_real(key_m(bob),g))).
By 7, the attacker may know validkey(dhexp_real(key_e(alice,bob,sid_5),g)).
Using the function hash the attacker may obtain hash(hash(hash(hash(hash(somename,empty),empty),validkey(dhexp_real(key_s(bob),g))),validkey(dhexp_real(key_m(bob),g))),validkey(dhexp_real(key_e(alice,bob,sid_5),g))).
attacker(hash(hash(hash(hash(hash(somename,empty),empty),validkey(dhexp_real(key_s(bob),g))),validkey(dhexp_real(key_m(bob),g))),validkey(dhexp_real(key_e(alice,bob,sid_5),g)))).

19. By 18, the attacker may know hash(hash(hash(hash(hash(somename,empty),empty),validkey(dhexp_real(key_s(bob),g))),validkey(dhexp_real(key_m(bob),g))),validkey(dhexp_real(key_e(alice,bob,sid_5),g))).
So the attacker may know hash(hash(hash(hash(hash(somename,empty),empty),validkey(dhexp_real(key_s(bob),g))),validkey(dhexp_real(key_m(bob),g))),validkey(dhexp_real(key_e(alice,bob,sid_5),g))) in phase 1.
attacker_p1(hash(hash(hash(hash(hash(somename,empty),empty),validkey(dhexp_real(key_s(bob),g))),validkey(dhexp_real(key_m(bob),g))),validkey(dhexp_real(key_e(alice,bob,sid_5),g)))).

20. Using the function minnonce the attacker may obtain minnonce in phase 1.
attacker_p1(minnonce).

21. By 7, the attacker may know validkey(dhexp_real(key_e(alice,bob,sid_5),g)).
So the attacker may know validkey(dhexp_real(key_e(alice,bob,sid_5),g)) in phase 1.
attacker_p1(validkey(dhexp_real(key_e(alice,bob,sid_5),g))).

22. Using the function pub the attacker may obtain pub in phase 1.
attacker_p1(pub).

23. The event LeakS(phase1,bob) may be executed at {553}.
The event LeakM(phase1,bob) may be executed at {554}.
So the message (key_s(bob),key_m(bob)) may be sent on channel pub in phase 1 at output {555}.
mess_p1(pub,(key_s(bob),key_m(bob))).

24. By 22, the attacker may have the channel pub in phase 1.
By 23, the message (key_s(bob),key_m(bob)) in phase 1 may be sent on this channel.
So the attacker may obtain the message (key_s(bob),key_m(bob)) in phase 1 by listening on this channel.
attacker_p1((key_s(bob),key_m(bob))).

25. By 24, the attacker may know (key_s(bob),key_m(bob)) in phase 1.
Using the function 2-proj-2-tuple the attacker may obtain key_m(bob) in phase 1.
attacker_p1(key_m(bob)).

26. By 25, the attacker may know key_m(bob) in phase 1.
By 21, the attacker may know validkey(dhexp_real(key_e(alice,bob,sid_5),g)) in phase 1.
Using the function dhexp the attacker may obtain dhexp_real(key_e(alice,bob,sid_5),dhexp_real(key_m(bob),g)) in phase 1.
attacker_p1(dhexp_real(key_e(alice,bob,sid_5),dhexp_real(key_m(bob),g))).

27. By 24, the attacker may know (key_s(bob),key_m(bob)) in phase 1.
Using the function 1-proj-2-tuple the attacker may obtain key_s(bob) in phase 1.
attacker_p1(key_s(bob)).

28. By 27, the attacker may know key_s(bob) in phase 1.
By 21, the attacker may know validkey(dhexp_real(key_e(alice,bob,sid_5),g)) in phase 1.
Using the function dhexp the attacker may obtain dhexp_real(key_e(alice,bob,sid_5),dhexp_real(key_s(bob),g)) in phase 1.
attacker_p1(dhexp_real(key_e(alice,bob,sid_5),dhexp_real(key_s(bob),g))).

29. Using the function empty the attacker may obtain empty in phase 1.
attacker_p1(empty).

30. Using the function somename the attacker may obtain somename in phase 1.
attacker_p1(somename).

31. By 30, the attacker may know somename in phase 1.
By 29, the attacker may know empty in phase 1.
Using the function hash the attacker may obtain hash(somename,empty) in phase 1.
attacker_p1(hash(somename,empty)).

32. By 31, the attacker may know hash(somename,empty) in phase 1.
By 28, the attacker may know dhexp_real(key_e(alice,bob,sid_5),dhexp_real(key_s(bob),g)) in phase 1.
Using the function hmac_hash1 the attacker may obtain hmac_hash1(hash(somename,empty),dhexp_real(key_e(alice,bob,sid_5),dhexp_real(key_s(bob),g))) in phase 1.
attacker_p1(hmac_hash1(hash(somename,empty),dhexp_real(key_e(alice,bob,sid_5),dhexp_real(key_s(bob),g)))).

33. By 32, the attacker may know hmac_hash1(hash(somename,empty),dhexp_real(key_e(alice,bob,sid_5),dhexp_real(key_s(bob),g))) in phase 1.
By 26, the attacker may know dhexp_real(key_e(alice,bob,sid_5),dhexp_real(key_m(bob),g)) in phase 1.
Using the function hmac_hash2 the attacker may obtain hmac_hash2(hmac_hash1(hash(somename,empty),dhexp_real(key_e(alice,bob,sid_5),dhexp_real(key_s(bob),g))),dhexp_real(key_e(alice,bob,sid_5),dhexp_real(key_m(bob),g))) in phase 1.
attacker_p1(hmac_hash2(hmac_hash1(hash(somename,empty),dhexp_real(key_e(alice,bob,sid_5),dhexp_real(key_s(bob),g))),dhexp_real(key_e(alice,bob,sid_5),dhexp_real(key_m(bob),g)))).

34. By 33, the attacker may know hmac_hash2(hmac_hash1(hash(somename,empty),dhexp_real(key_e(alice,bob,sid_5),dhexp_real(key_s(bob),g))),dhexp_real(key_e(alice,bob,sid_5),dhexp_real(key_m(bob),g))) in phase 1.
By 20, the attacker may know minnonce in phase 1.
By 19, the attacker may know hash(hash(hash(hash(hash(somename,empty),empty),validkey(dhexp_real(key_s(bob),g))),validkey(dhexp_real(key_m(bob),g))),validkey(dhexp_real(key_e(alice,bob,sid_5),g))) in phase 1.
By 6, the attacker may know encrypt(hmac_hash2(hmac_hash1(hash(somename,empty),dhexp_real(key_e(alice,bob,sid_5),dhexp_real(key_s(bob),g))),dhexp_real(key_e(alice,bob,sid_5),dhexp_real(key_m(bob),g))),minnonce,hash(hash(hash(hash(hash(somename,empty),empty),validkey(dhexp_real(key_s(bob),g))),validkey(dhexp_real(key_m(bob),g))),validkey(dhexp_real(key_e(alice,bob,sid_5),g))),msg_a(alice,bob,sid_5)) in phase 1.
Using the function decrypt the attacker may obtain aeadpack(true,hash(hash(hash(hash(hash(somename,empty),empty),validkey(dhexp_real(key_s(bob),g))),validkey(dhexp_real(key_m(bob),g))),validkey(dhexp_real(key_e(alice,bob,sid_5),g))),msg_a(alice,bob,sid_5)) in phase 1.
attacker_p1(aeadpack(true,hash(hash(hash(hash(hash(somename,empty),empty),validkey(dhexp_real(key_s(bob),g))),validkey(dhexp_real(key_m(bob),g))),validkey(dhexp_real(key_e(alice,bob,sid_5),g))),msg_a(alice,bob,sid_5))).

35. By 34, the attacker may know aeadpack(true,hash(hash(hash(hash(hash(somename,empty),empty),validkey(dhexp_real(key_s(bob),g))),validkey(dhexp_real(key_m(bob),g))),validkey(dhexp_real(key_e(alice,bob,sid_5),g))),msg_a(alice,bob,sid_5)) in phase 1.
Using the function 3-proj-aeadpack the attacker may obtain msg_a(alice,bob,sid_5) in phase 1.
attacker_p1(msg_a(alice,bob,sid_5)).

36. By 35, attacker_p1(msg_a(alice,bob,sid_5)).
The goal is reached, represented in the following fact:
attacker_p1(msg_a(alice,bob,sid_5)).


RESULT attacker_p1(msg_a(alice,bob,sid_a)) ==> (event(LeakS(phase0,bob)) && event(LeakM(phase0,bob))) || (event(LeakS(px,bob)) && event(LeakM(px,bob)) && event(LeakS(pz,alice)) && event(LeakM(pz,alice))) cannot be proved.
Starting query attacker_p1(msg_a(alice,bob,sid_a)) ==> event(LeakS(phase0,bob)) && event(LeakM(phase0,bob))
goal reachable: begin(LeakM(phase1,bob)) && begin(LeakS(phase1,bob)) && begin(SendMsg(alice,bob,stagepack_a(sid_5),msg_a(alice,bob,sid_5))) -> attacker_p1(msg_a(alice,bob,sid_5))
Abbreviations:
sid_5 = sid[!1 = @sid]

Derivation:
Abbreviations:
sid_5 = sid[!1 = @sid]

1. Using the function pub the attacker may obtain pub.
attacker(pub).

2. The entry statestore(alice,bob,sid_5,statepack_a(handshakestatepack(symmetricstatepack(cipherstatepack(empty,minnonce),hash(somename,empty),hash(hash(hash(hash(somename,empty),empty),validkey(dhexp_real(key_s(bob),g))),validkey(dhexp_real(key_m(bob),g)))),keypairpack(empty,empty),keypairpack(empty,empty),keypairpack(empty,empty),validkey(dhexp_real(key_s(bob),g)),validkey(dhexp_real(key_m(bob),g)),empty,empty,true))) may be inserted in a table at insert {49}.
table(statestore(alice,bob,sid_5,statepack_a(handshakestatepack(symmetricstatepack(cipherstatepack(empty,minnonce),hash(somename,empty),hash(hash(hash(hash(somename,empty),empty),validkey(dhexp_real(key_s(bob),g))),validkey(dhexp_real(key_m(bob),g)))),keypairpack(empty,empty),keypairpack(empty,empty),keypairpack(empty,empty),validkey(dhexp_real(key_s(bob),g)),validkey(dhexp_real(key_m(bob),g)),empty,empty,true)))).

3. The entry statestore(alice,bob,sid_5,statepack_a(handshakestatepack(symmetricstatepack(cipherstatepack(empty,minnonce),hash(somename,empty),hash(hash(hash(hash(somename,empty),empty),validkey(dhexp_real(key_s(bob),g))),validkey(dhexp_real(key_m(bob),g)))),keypairpack(empty,empty),keypairpack(empty,empty),keypairpack(empty,empty),validkey(dhexp_real(key_s(bob),g)),validkey(dhexp_real(key_m(bob),g)),empty,empty,true))) that may be in a table by 2 may be read at get {182}.
The event SendMsg(alice,bob,stagepack_a(sid_5),msg_a(alice,bob,sid_5)) may be executed at {180}.
So the message concat3(validkey(dhexp_real(key_e(alice,bob,sid_5),g)),empty,encrypt(hmac_hash2(hmac_hash1(hash(somename,empty),dhexp_real(key_e(alice,bob,sid_5),dhexp_real(key_s(bob),g))),dhexp_real(key_e(alice,bob,sid_5),dhexp_real(key_m(bob),g))),minnonce,hash(hash(hash(hash(hash(somename,empty),empty),validkey(dhexp_real(key_s(bob),g))),validkey(dhexp_real(key_m(bob),g))),validkey(dhexp_real(key_e(alice,bob,sid_5),g))),msg_a(alice,bob,sid_5))) may be sent on channel pub at output {181}.
mess(pub,concat3(validkey(dhexp_real(key_e(alice,bob,sid_5),g)),empty,encrypt(hmac_hash2(hmac_hash1(hash(somename,empty),dhexp_real(key_e(alice,bob,sid_5),dhexp_real(key_s(bob),g))),dhexp_real(key_e(alice,bob,sid_5),dhexp_real(key_m(bob),g))),minnonce,hash(hash(hash(hash(hash(somename,empty),empty),validkey(dhexp_real(key_s(bob),g))),validkey(dhexp_real(key_m(bob),g))),validkey(dhexp_real(key_e(alice,bob,sid_5),g))),msg_a(alice,bob,sid_5)))).

4. By 1, the attacker may have the channel pub.
By 3, the message concat3(validkey(dhexp_real(key_e(alice,bob,sid_5),g)),empty,encrypt(hmac_hash2(hmac_hash1(hash(somename,empty),dhexp_real(key_e(alice,bob,sid_5),dhexp_real(key_s(bob),g))),dhexp_real(key_e(alice,bob,sid_5),dhexp_real(key_m(bob),g))),minnonce,hash(hash(hash(hash(hash(somename,empty),empty),validkey(dhexp_real(key_s(bob),g))),validkey(dhexp_real(key_m(bob),g))),validkey(dhexp_real(key_e(alice,bob,sid_5),g))),msg_a(alice,bob,sid_5))) may be sent on this channel.
So the attacker may obtain the message concat3(validkey(dhexp_real(key_e(alice,bob,sid_5),g)),empty,encrypt(hmac_hash2(hmac_hash1(hash(somename,empty),dhexp_real(key_e(alice,bob,sid_5),dhexp_real(key_s(bob),g))),dhexp_real(key_e(alice,bob,sid_5),dhexp_real(key_m(bob),g))),minnonce,hash(hash(hash(hash(hash(somename,empty),empty),validkey(dhexp_real(key_s(bob),g))),validkey(dhexp_real(key_m(bob),g))),validkey(dhexp_real(key_e(alice,bob,sid_5),g))),msg_a(alice,bob,sid_5))) by listening on this channel.
attacker(concat3(validkey(dhexp_real(key_e(alice,bob,sid_5),g)),empty,encrypt(hmac_hash2(hmac_hash1(hash(somename,empty),dhexp_real(key_e(alice,bob,sid_5),dhexp_real(key_s(bob),g))),dhexp_real(key_e(alice,bob,sid_5),dhexp_real(key_m(bob),g))),minnonce,hash(hash(hash(hash(hash(somename,empty),empty),validkey(dhexp_real(key_s(bob),g))),validkey(dhexp_real(key_m(bob),g))),validkey(dhexp_real(key_e(alice,bob,sid_5),g))),msg_a(alice,bob,sid_5)))).

5. By 4, the attacker may know concat3(validkey(dhexp_real(key_e(alice,bob,sid_5),g)),empty,encrypt(hmac_hash2(hmac_hash1(hash(somename,empty),dhexp_real(key_e(alice,bob,sid_5),dhexp_real(key_s(bob),g))),dhexp_real(key_e(alice,bob,sid_5),dhexp_real(key_m(bob),g))),minnonce,hash(hash(hash(hash(hash(somename,empty),empty),validkey(dhexp_real(key_s(bob),g))),validkey(dhexp_real(key_m(bob),g))),validkey(dhexp_real(key_e(alice,bob,sid_5),g))),msg_a(alice,bob,sid_5))).
Using the function 3-proj-concat3 the attacker may obtain encrypt(hmac_hash2(hmac_hash1(hash(somename,empty),dhexp_real(key_e(alice,bob,sid_5),dhexp_real(key_s(bob),g))),dhexp_real(key_e(alice,bob,sid_5),dhexp_real(key_m(bob),g))),minnonce,hash(hash(hash(hash(hash(somename,empty),empty),validkey(dhexp_real(key_s(bob),g))),validkey(dhexp_real(key_m(bob),g))),validkey(dhexp_real(key_e(alice,bob,sid_5),g))),msg_a(alice,bob,sid_5)).
attacker(encrypt(hmac_hash2(hmac_hash1(hash(somename,empty),dhexp_real(key_e(alice,bob,sid_5),dhexp_real(key_s(bob),g))),dhexp_real(key_e(alice,bob,sid_5),dhexp_real(key_m(bob),g))),minnonce,hash(hash(hash(hash(hash(somename,empty),empty),validkey(dhexp_real(key_s(bob),g))),validkey(dhexp_real(key_m(bob),g))),validkey(dhexp_real(key_e(alice,bob,sid_5),g))),msg_a(alice,bob,sid_5))).

6. By 5, the attacker may know encrypt(hmac_hash2(hmac_hash1(hash(somename,empty),dhexp_real(key_e(alice,bob,sid_5),dhexp_real(key_s(bob),g))),dhexp_real(key_e(alice,bob,sid_5),dhexp_real(key_m(bob),g))),minnonce,hash(hash(hash(hash(hash(somename,empty),empty),validkey(dhexp_real(key_s(bob),g))),validkey(dhexp_real(key_m(bob),g))),validkey(dhexp_real(key_e(alice,bob,sid_5),g))),msg_a(alice,bob,sid_5)).
So the attacker may know encrypt(hmac_hash2(hmac_hash1(hash(somename,empty),dhexp_real(key_e(alice,bob,sid_5),dhexp_real(key_s(bob),g))),dhexp_real(key_e(alice,bob,sid_5),dhexp_real(key_m(bob),g))),minnonce,hash(hash(hash(hash(hash(somename,empty),empty),validkey(dhexp_real(key_s(bob),g))),validkey(dhexp_real(key_m(bob),g))),validkey(dhexp_real(key_e(alice,bob,sid_5),g))),msg_a(alice,bob,sid_5)) in phase 1.
attacker_p1(encrypt(hmac_hash2(hmac_hash1(hash(somename,empty),dhexp_real(key_e(alice,bob,sid_5),dhexp_real(key_s(bob),g))),dhexp_real(key_e(alice,bob,sid_5),dhexp_real(key_m(bob),g))),minnonce,hash(hash(hash(hash(hash(somename,empty),empty),validkey(dhexp_real(key_s(bob),g))),validkey(dhexp_real(key_m(bob),g))),validkey(dhexp_real(key_e(alice,bob,sid_5),g))),msg_a(alice,bob,sid_5))).

7. By 4, the attacker may know concat3(validkey(dhexp_real(key_e(alice,bob,sid_5),g)),empty,encrypt(hmac_hash2(hmac_hash1(hash(somename,empty),dhexp_real(key_e(alice,bob,sid_5),dhexp_real(key_s(bob),g))),dhexp_real(key_e(alice,bob,sid_5),dhexp_real(key_m(bob),g))),minnonce,hash(hash(hash(hash(hash(somename,empty),empty),validkey(dhexp_real(key_s(bob),g))),validkey(dhexp_real(key_m(bob),g))),validkey(dhexp_real(key_e(alice,bob,sid_5),g))),msg_a(alice,bob,sid_5))).
Using the function 1-proj-concat3 the attacker may obtain validkey(dhexp_real(key_e(alice,bob,sid_5),g)).
attacker(validkey(dhexp_real(key_e(alice,bob,sid_5),g))).

8. The message (validkey(dhexp_real(key_s(bob),g)),validkey(dhexp_real(key_m(bob),g))) may be sent on channel pub at output {373}.
mess(pub,(validkey(dhexp_real(key_s(bob),g)),validkey(dhexp_real(key_m(bob),g)))).

9. By 1, the attacker may have the channel pub.
By 8, the message (validkey(dhexp_real(key_s(bob),g)),validkey(dhexp_real(key_m(bob),g))) may be sent on this channel.
So the attacker may obtain the message (validkey(dhexp_real(key_s(bob),g)),validkey(dhexp_real(key_m(bob),g))) by listening on this channel.
attacker((validkey(dhexp_real(key_s(bob),g)),validkey(dhexp_real(key_m(bob),g)))).

10. By 9, the attacker may know (validkey(dhexp_real(key_s(bob),g)),validkey(dhexp_real(key_m(bob),g))).
Using the function 2-proj-2-tuple the attacker may obtain validkey(dhexp_real(key_m(bob),g)).
attacker(validkey(dhexp_real(key_m(bob),g))).

11. By 9, the attacker may know (validkey(dhexp_real(key_s(bob),g)),validkey(dhexp_real(key_m(bob),g))).
Using the function 1-proj-2-tuple the attacker may obtain validkey(dhexp_real(key_s(bob),g)).
attacker(validkey(dhexp_real(key_s(bob),g))).

12. Using the function empty the attacker may obtain empty.
attacker(empty).

13. Using the function somename the attacker may obtain somename.
attacker(somename).

14. By 13, the attacker may know somename.
By 12, the attacker may know empty.
Using the function hash the attacker may obtain hash(somename,empty).
attacker(hash(somename,empty)).

15. By 14, the attacker may know hash(somename,empty).
By 12, the attacker may know empty.
Using the function hash the attacker may obtain hash(hash(somename,empty),empty).
attacker(hash(hash(somename,empty),empty)).

16. By 15, the attacker may know hash(hash(somename,empty),empty).
By 11, the attacker may know validkey(dhexp_real(key_s(bob),g)).
Using the function hash the attacker may obtain hash(hash(hash(somename,empty),empty),validkey(dhexp_real(key_s(bob),g))).
attacker(hash(hash(hash(somename,empty),empty),validkey(dhexp_real(key_s(bob),g)))).

17. By 16, the attacker may know hash(hash(hash(somename,empty),empty),validkey(dhexp_real(key_s(bob),g))).
By 10, the attacker may know validkey(dhexp_real(key_m(bob),g)).
Using the function hash the attacker may obtain hash(hash(hash(hash(somename,empty),empty),validkey(dhexp_real(key_s(bob),g))),validkey(dhexp_real(key_m(bob),g))).
attacker(hash(hash(hash(hash(somename,empty),empty),validkey(dhexp_real(key_s(bob),g))),validkey(dhexp_real(key_m(bob),g)))).

18. By 17, the attacker may know hash(hash(hash(hash(somename,empty),empty),validkey(dhexp_real(key_s(bob),g))),validkey(dhexp_real(key_m(bob),g))).
By 7, the attacker may know validkey(dhexp_real(key_e(alice,bob,sid_5),g)).
Using the function hash the attacker may obtain hash(hash(hash(hash(hash(somename,empty),empty),validkey(dhexp_real(key_s(bob),g))),validkey(dhexp_real(key_m(bob),g))),validkey(dhexp_real(key_e(alice,bob,sid_5),g))).
attacker(hash(hash(hash(hash(hash(somename,empty),empty),validkey(dhexp_real(key_s(bob),g))),validkey(dhexp_real(key_m(bob),g))),validkey(dhexp_real(key_e(alice,bob,sid_5),g)))).

19. By 18, the attacker may know hash(hash(hash(hash(hash(somename,empty),empty),validkey(dhexp_real(key_s(bob),g))),validkey(dhexp_real(key_m(bob),g))),validkey(dhexp_real(key_e(alice,bob,sid_5),g))).
So the attacker may know hash(hash(hash(hash(hash(somename,empty),empty),validkey(dhexp_real(key_s(bob),g))),validkey(dhexp_real(key_m(bob),g))),validkey(dhexp_real(key_e(alice,bob,sid_5),g))) in phase 1.
attacker_p1(hash(hash(hash(hash(hash(somename,empty),empty),validkey(dhexp_real(key_s(bob),g))),validkey(dhexp_real(key_m(bob),g))),validkey(dhexp_real(key_e(alice,bob,sid_5),g)))).

20. Using the function minnonce the attacker may obtain minnonce in phase 1.
attacker_p1(minnonce).

21. By 7, the attacker may know validkey(dhexp_real(key_e(alice,bob,sid_5),g)).
So the attacker may know validkey(dhexp_real(key_e(alice,bob,sid_5),g)) in phase 1.
attacker_p1(validkey(dhexp_real(key_e(alice,bob,sid_5),g))).

22. Using the function pub the attacker may obtain pub in phase 1.
attacker_p1(pub).

23. The event LeakS(phase1,bob) may be executed at {553}.
The event LeakM(phase1,bob) may be executed at {554}.
So the message (key_s(bob),key_m(bob)) may be sent on channel pub in phase 1 at output {555}.
mess_p1(pub,(key_s(bob),key_m(bob))).

24. By 22, the attacker may have the channel pub in phase 1.
By 23, the message (key_s(bob),key_m(bob)) in phase 1 may be sent on this channel.
So the attacker may obtain the message (key_s(bob),key_m(bob)) in phase 1 by listening on this channel.
attacker_p1((key_s(bob),key_m(bob))).

25. By 24, the attacker may know (key_s(bob),key_m(bob)) in phase 1.
Using the function 2-proj-2-tuple the attacker may obtain key_m(bob) in phase 1.
attacker_p1(key_m(bob)).

26. By 25, the attacker may know key_m(bob) in phase 1.
By 21, the attacker may know validkey(dhexp_real(key_e(alice,bob,sid_5),g)) in phase 1.
Using the function dhexp the attacker may obtain dhexp_real(key_e(alice,bob,sid_5),dhexp_real(key_m(bob),g)) in phase 1.
attacker_p1(dhexp_real(key_e(alice,bob,sid_5),dhexp_real(key_m(bob),g))).

27. By 24, the attacker may know (key_s(bob),key_m(bob)) in phase 1.
Using the function 1-proj-2-tuple the attacker may obtain key_s(bob) in phase 1.
attacker_p1(key_s(bob)).

28. By 27, the attacker may know key_s(bob) in phase 1.
By 21, the attacker may know validkey(dhexp_real(key_e(alice,bob,sid_5),g)) in phase 1.
Using the function dhexp the attacker may obtain dhexp_real(key_e(alice,bob,sid_5),dhexp_real(key_s(bob),g)) in phase 1.
attacker_p1(dhexp_real(key_e(alice,bob,sid_5),dhexp_real(key_s(bob),g))).

29. Using the function empty the attacker may obtain empty in phase 1.
attacker_p1(empty).

30. Using the function somename the attacker may obtain somename in phase 1.
attacker_p1(somename).

31. By 30, the attacker may know somename in phase 1.
By 29, the attacker may know empty in phase 1.
Using the function hash the attacker may obtain hash(somename,empty) in phase 1.
attacker_p1(hash(somename,empty)).

32. By 31, the attacker may know hash(somename,empty) in phase 1.
By 28, the attacker may know dhexp_real(key_e(alice,bob,sid_5),dhexp_real(key_s(bob),g)) in phase 1.
Using the function hmac_hash1 the attacker may obtain hmac_hash1(hash(somename,empty),dhexp_real(key_e(alice,bob,sid_5),dhexp_real(key_s(bob),g))) in phase 1.
attacker_p1(hmac_hash1(hash(somename,empty),dhexp_real(key_e(alice,bob,sid_5),dhexp_real(key_s(bob),g)))).

33. By 32, the attacker may know hmac_hash1(hash(somename,empty),dhexp_real(key_e(alice,bob,sid_5),dhexp_real(key_s(bob),g))) in phase 1.
By 26, the attacker may know dhexp_real(key_e(alice,bob,sid_5),dhexp_real(key_m(bob),g)) in phase 1.
Using the function hmac_hash2 the attacker may obtain hmac_hash2(hmac_hash1(hash(somename,empty),dhexp_real(key_e(alice,bob,sid_5),dhexp_real(key_s(bob),g))),dhexp_real(key_e(alice,bob,sid_5),dhexp_real(key_m(bob),g))) in phase 1.
attacker_p1(hmac_hash2(hmac_hash1(hash(somename,empty),dhexp_real(key_e(alice,bob,sid_5),dhexp_real(key_s(bob),g))),dhexp_real(key_e(alice,bob,sid_5),dhexp_real(key_m(bob),g)))).

34. By 33, the attacker may know hmac_hash2(hmac_hash1(hash(somename,empty),dhexp_real(key_e(alice,bob,sid_5),dhexp_real(key_s(bob),g))),dhexp_real(key_e(alice,bob,sid_5),dhexp_real(key_m(bob),g))) in phase 1.
By 20, the attacker may know minnonce in phase 1.
By 19, the attacker may know hash(hash(hash(hash(hash(somename,empty),empty),validkey(dhexp_real(key_s(bob),g))),validkey(dhexp_real(key_m(bob),g))),validkey(dhexp_real(key_e(alice,bob,sid_5),g))) in phase 1.
By 6, the attacker may know encrypt(hmac_hash2(hmac_hash1(hash(somename,empty),dhexp_real(key_e(alice,bob,sid_5),dhexp_real(key_s(bob),g))),dhexp_real(key_e(alice,bob,sid_5),dhexp_real(key_m(bob),g))),minnonce,hash(hash(hash(hash(hash(somename,empty),empty),validkey(dhexp_real(key_s(bob),g))),validkey(dhexp_real(key_m(bob),g))),validkey(dhexp_real(key_e(alice,bob,sid_5),g))),msg_a(alice,bob,sid_5)) in phase 1.
Using the function decrypt the attacker may obtain aeadpack(true,hash(hash(hash(hash(hash(somename,empty),empty),validkey(dhexp_real(key_s(bob),g))),validkey(dhexp_real(key_m(bob),g))),validkey(dhexp_real(key_e(alice,bob,sid_5),g))),msg_a(alice,bob,sid_5)) in phase 1.
attacker_p1(aeadpack(true,hash(hash(hash(hash(hash(somename,empty),empty),validkey(dhexp_real(key_s(bob),g))),validkey(dhexp_real(key_m(bob),g))),validkey(dhexp_real(key_e(alice,bob,sid_5),g))),msg_a(alice,bob,sid_5))).

35. By 34, the attacker may know aeadpack(true,hash(hash(hash(hash(hash(somename,empty),empty),validkey(dhexp_real(key_s(bob),g))),validkey(dhexp_real(key_m(bob),g))),validkey(dhexp_real(key_e(alice,bob,sid_5),g))),msg_a(alice,bob,sid_5)) in phase 1.
Using the function 3-proj-aeadpack the attacker may obtain msg_a(alice,bob,sid_5) in phase 1.
attacker_p1(msg_a(alice,bob,sid_5)).

36. By 35, attacker_p1(msg_a(alice,bob,sid_5)).
The goal is reached, represented in the following fact:
attacker_p1(msg_a(alice,bob,sid_5)).


RESULT attacker_p1(msg_a(alice,bob,sid_a)) ==> event(LeakS(phase0,bob)) && event(LeakM(phase0,bob)) cannot be proved.
Starting query not event(RecvEnd(true))
goal reachable: begin(SendMsg(alice,bob,stagepack_a(sid_5),msg_a(alice,bob,sid_5))) -> end(RecvEnd(true))
Abbreviations:
sid_5 = sid[!1 = @sid]

Derivation:
Abbreviations:
sid_5 = sid[!1 = @sid]
sid_6 = sid[!1 = @sid_1]

1. The entry statestore(bob,charlie,sid_6,statepack_a(handshakestatepack(symmetricstatepack(cipherstatepack(empty,minnonce),hash(somename,empty),hash(hash(hash(hash(somename,empty),empty),validkey(dhexp_real(key_s(bob),g))),validkey(dhexp_real(key_m(bob),g)))),keypairpack(validkey(dhexp_real(key_s(bob),g)),key_s(bob)),keypairpack(validkey(dhexp_real(key_m(bob),g)),key_m(bob)),keypairpack(empty,empty),empty,empty,empty,empty,false))) may be inserted in a table at insert {606}.
table(statestore(bob,charlie,sid_6,statepack_a(handshakestatepack(symmetricstatepack(cipherstatepack(empty,minnonce),hash(somename,empty),hash(hash(hash(hash(somename,empty),empty),validkey(dhexp_real(key_s(bob),g))),validkey(dhexp_real(key_m(bob),g)))),keypairpack(validkey(dhexp_real(key_s(bob),g)),key_s(bob)),keypairpack(validkey(dhexp_real(key_m(bob),g)),key_m(bob)),keypairpack(empty,empty),empty,empty,empty,empty,false)))).

2. The entry statestore(alice,bob,sid_5,statepack_a(handshakestatepack(symmetricstatepack(cipherstatepack(empty,minnonce),hash(somename,empty),hash(hash(hash(hash(somename,empty),empty),validkey(dhexp_real(key_s(bob),g))),validkey(dhexp_real(key_m(bob),g)))),keypairpack(empty,empty),keypairpack(empty,empty),keypairpack(empty,empty),validkey(dhexp_real(key_s(bob),g)),validkey(dhexp_real(key_m(bob),g)),empty,empty,true))) may be inserted in a table at insert {49}.
table(statestore(alice,bob,sid_5,statepack_a(handshakestatepack(symmetricstatepack(cipherstatepack(empty,minnonce),hash(somename,empty),hash(hash(hash(hash(somename,empty),empty),validkey(dhexp_real(key_s(bob),g))),validkey(dhexp_real(key_m(bob),g)))),keypairpack(empty,empty),keypairpack(empty,empty),keypairpack(empty,empty),validkey(dhexp_real(key_s(bob),g)),validkey(dhexp_real(key_m(bob),g)),empty,empty,true)))).

3. The entry statestore(alice,bob,sid_5,statepack_a(handshakestatepack(symmetricstatepack(cipherstatepack(empty,minnonce),hash(somename,empty),hash(hash(hash(hash(somename,empty),empty),validkey(dhexp_real(key_s(bob),g))),validkey(dhexp_real(key_m(bob),g)))),keypairpack(empty,empty),keypairpack(empty,empty),keypairpack(empty,empty),validkey(dhexp_real(key_s(bob),g)),validkey(dhexp_real(key_m(bob),g)),empty,empty,true))) that may be in a table by 2 may be read at get {182}.
The event SendMsg(alice,bob,stagepack_a(sid_5),msg_a(alice,bob,sid_5)) may be executed at {180}.
So the message concat3(validkey(dhexp_real(key_e(alice,bob,sid_5),g)),empty,encrypt(hmac_hash2(hmac_hash1(hash(somename,empty),dhexp_real(key_e(alice,bob,sid_5),dhexp_real(key_s(bob),g))),dhexp_real(key_e(alice,bob,sid_5),dhexp_real(key_m(bob),g))),minnonce,hash(hash(hash(hash(hash(somename,empty),empty),validkey(dhexp_real(key_s(bob),g))),validkey(dhexp_real(key_m(bob),g))),validkey(dhexp_real(key_e(alice,bob,sid_5),g))),msg_a(alice,bob,sid_5))) may be sent on channel pub at output {181}.
mess(pub,concat3(validkey(dhexp_real(key_e(alice,bob,sid_5),g)),empty,encrypt(hmac_hash2(hmac_hash1(hash(somename,empty),dhexp_real(key_e(alice,bob,sid_5),dhexp_real(key_s(bob),g))),dhexp_real(key_e(alice,bob,sid_5),dhexp_real(key_m(bob),g))),minnonce,hash(hash(hash(hash(hash(somename,empty),empty),validkey(dhexp_real(key_s(bob),g))),validkey(dhexp_real(key_m(bob),g))),validkey(dhexp_real(key_e(alice,bob,sid_5),g))),msg_a(alice,bob,sid_5)))).

4. The entry statestore(bob,charlie,sid_6,statepack_a(handshakestatepack(symmetricstatepack(cipherstatepack(empty,minnonce),hash(somename,empty),hash(hash(hash(hash(somename,empty),empty),validkey(dhexp_real(key_s(bob),g))),validkey(dhexp_real(key_m(bob),g)))),keypairpack(validkey(dhexp_real(key_s(bob),g)),key_s(bob)),keypairpack(validkey(dhexp_real(key_m(bob),g)),key_m(bob)),keypairpack(empty,empty),empty,empty,empty,empty,false))) that may be in a table by 1 may be read at get {742}.
The message concat3(validkey(dhexp_real(key_e(alice,bob,sid_5),g)),empty,encrypt(hmac_hash2(hmac_hash1(hash(somename,empty),dhexp_real(key_e(alice,bob,sid_5),dhexp_real(key_s(bob),g))),dhexp_real(key_e(alice,bob,sid_5),dhexp_real(key_m(bob),g))),minnonce,hash(hash(hash(hash(hash(somename,empty),empty),validkey(dhexp_real(key_s(bob),g))),validkey(dhexp_real(key_m(bob),g))),validkey(dhexp_real(key_e(alice,bob,sid_5),g))),msg_a(alice,bob,sid_5))) that may be sent on channel pub by 3 may be received at input {607}.
So event RecvEnd(true) may be executed at {741}.
end(RecvEnd(true)).

5. By 4, end(RecvEnd(true)).
The goal is reached, represented in the following fact:
end(RecvEnd(true)).


RESULT not event(RecvEnd(true)) cannot be proved.

--------------------------------------------------------------
Verification summary:

Query event(RecvMsg(bob,alice,stagepack_a(sid_b),msg)) ==> event(SendMsg(alice,bob,stagepack_a(sid_a),msg)) is true.

Query event(RecvMsg(bob,alice,stagepack_a(sid_b),msg)) ==> event(SendMsg(alice,c,stagepack_a(sid_a),msg)) || (event(LeakS(phase0,bob)) && event(LeakM(phase0,bob))) is true.

Query event(RecvMsg(bob,alice,stagepack_a(sid_b),msg)) ==> event(SendMsg(alice,c,stagepack_a(sid_a),msg)) is true.

Query event(RecvMsg(bob,alice,stagepack_a(sid_b),msg)) ==> event(SendMsg(alice,bob,stagepack_a(sid_a),msg)) || (event(LeakS(phase0,bob)) && event(LeakM(phase0,bob))) is true.

Query event(RecvMsg(bob,alice,stagepack_a(sid_b),msg)) ==> event(SendMsg(alice,bob,stagepack_a(sid_a),msg)) is true.

Query not attacker_p1(msg_a(alice,bob,sid_a)) cannot be proved.

Query attacker_p1(msg_a(alice,bob,sid_a)) ==> event(LeakS(px,bob)) && event(LeakM(px,bob)) is true.

Query attacker_p1(msg_a(alice,bob,sid_a)) ==> (event(LeakS(phase0,bob)) && event(LeakM(phase0,bob))) || (event(LeakS(px,bob)) && event(LeakM(px,bob)) && event(LeakS(pz,alice)) && event(LeakM(pz,alice))) cannot be proved.

Query attacker_p1(msg_a(alice,bob,sid_a)) ==> event(LeakS(phase0,bob)) && event(LeakM(phase0,bob)) cannot be proved.

Query not event(RecvEnd(true)) cannot be proved.

--------------------------------------------------------------


File "pv/X-X'.xnoise.passive.pv", line 218, characters 7-8:
Warning: identifier ck rebound.
File "pv/X-X'.xnoise.passive.pv", line 227, characters 7-8:
Warning: identifier ck rebound.
File "pv/X-X'.xnoise.passive.pv", line 228, characters 7-8:
Warning: identifier cs rebound.
File "pv/X-X'.xnoise.passive.pv", line 228, character 36:
Warning: identifier h rebound.
File "pv/X-X'.xnoise.passive.pv", line 258, characters 6-7:
Warning: identifier ss rebound.
File "pv/X-X'.xnoise.passive.pv", line 259, characters 6-7:
Warning: identifier ss rebound.
File "pv/X-X'.xnoise.passive.pv", line 264, characters 6-7:
Warning: identifier ss rebound.
File "pv/X-X'.xnoise.passive.pv", line 265, characters 6-7:
Warning: identifier ss rebound.
File "pv/X-X'.xnoise.passive.pv", line 271, character 6:
Warning: identifier e rebound.
File "pv/X-X'.xnoise.passive.pv", line 272, characters 6-7:
Warning: identifier ne rebound.
File "pv/X-X'.xnoise.passive.pv", line 273, characters 6-7:
Warning: identifier ss rebound.
File "pv/X-X'.xnoise.passive.pv", line 275, characters 6-7:
Warning: identifier ss rebound.
File "pv/X-X'.xnoise.passive.pv", line 276, characters 6-7:
Warning: identifier ss rebound.
File "pv/X-X'.xnoise.passive.pv", line 278, character 6:
Warning: identifier s rebound.
File "pv/X-X'.xnoise.passive.pv", line 279, characters 7-8:
Warning: identifier ss rebound.
File "pv/X-X'.xnoise.passive.pv", line 279, characters 26-27:
Warning: identifier ns rebound.
File "pv/X-X'.xnoise.passive.pv", line 281, character 6:
Warning: identifier m rebound.
File "pv/X-X'.xnoise.passive.pv", line 282, characters 7-8:
Warning: identifier ss rebound.
File "pv/X-X'.xnoise.passive.pv", line 282, characters 26-27:
Warning: identifier nm rebound.
File "pv/X-X'.xnoise.passive.pv", line 284, characters 6-7:
Warning: identifier ss rebound.
File "pv/X-X'.xnoise.passive.pv", line 285, characters 6-7:
Warning: identifier ss rebound.
File "pv/X-X'.xnoise.passive.pv", line 287, characters 7-8:
Warning: identifier ss rebound.
File "pv/X-X'.xnoise.passive.pv", line 287, characters 26-35:
Warning: identifier ciphertext rebound.
File "pv/X-X'.xnoise.passive.pv", line 289, characters 6-7:
Warning: identifier hs rebound.
File "pv/X-X'.xnoise.passive.pv", line 301, characters 6-7:
Warning: identifier re rebound.
File "pv/X-X'.xnoise.passive.pv", line 302, characters 6-7:
Warning: identifier ss rebound.
File "pv/X-X'.xnoise.passive.pv", line 304, characters 6-7:
Warning: identifier ss rebound.
File "pv/X-X'.xnoise.passive.pv", line 305, characters 6-7:
Warning: identifier ss rebound.
File "pv/X-X'.xnoise.passive.pv", line 307, characters 7-8:
Warning: identifier ss rebound.
File "pv/X-X'.xnoise.passive.pv", line 307, characters 40-45:
Warning: identifier valid1 rebound.
File "pv/X-X'.xnoise.passive.pv", line 308, characters 6-7:
Warning: identifier rs rebound.
File "pv/X-X'.xnoise.passive.pv", line 310, characters 7-8:
Warning: identifier ss rebound.
File "pv/X-X'.xnoise.passive.pv", line 310, characters 26-27:
Warning: identifier me rebound.
File "pv/X-X'.xnoise.passive.pv", line 310, characters 40-45:
Warning: identifier valid2 rebound.
File "pv/X-X'.xnoise.passive.pv", line 311, characters 6-7:
Warning: identifier rm rebound.
File "pv/X-X'.xnoise.passive.pv", line 313, characters 6-7:
Warning: identifier ss rebound.
File "pv/X-X'.xnoise.passive.pv", line 314, characters 6-7:
Warning: identifier ss rebound.
File "pv/X-X'.xnoise.passive.pv", line 316, characters 7-8:
Warning: identifier ss rebound.
File "pv/X-X'.xnoise.passive.pv", line 319, characters 13-14:
Warning: identifier hs rebound.
File "pv/X-X'.xnoise.passive.pv", line 394, characters 8-9:
Warning: identifier hs rebound.
File "pv/X-X'.xnoise.passive.pv", line 423, characters 8-9:
Warning: identifier hs rebound.
Linear part:
dhexp_real(b,dhexp_real(a,g)) = dhexp_real(a,dhexp_real(b,g))
Completing equations...
Completed equations:
dhexp_real(b,dhexp_real(a,g)) = dhexp_real(a,dhexp_real(b,g))
Convergent part: No equation.
Process 0 (that is, the initial process):
{1}out(pub, (key_s(charlie),key_m(charlie)));
{2}!
{3}new sid: sessionid;
(
    {4}let me: principal = alice in
    {5}let them: principal = bob in
    {6}let sid_1: sessionid = sid in
    {7}let s: keypair = keypairpack(empty,empty) in
    {8}let m: keypair = keypairpack(empty,empty) in
    {9}out(pub, (getpublickey(s),getpublickey(m)));
    (
        {10}let e: keypair = keypairpack(empty,empty) in
        {11}let basis: key = key_s(them) in
        {12}let public_key: key = catch-fail(dhexp(basis,validkey(g))) in
        {13}let v: bool = not-caught-fail(public_key) in
        {14}let rs: key = getpublickey((if v then keypairpack(validkey(public_key),basis) else fail-any)) in
        {15}let basis_1: key = key_m(them) in
        {16}let public_key_1: key = catch-fail(dhexp(basis_1,validkey(g))) in
        {17}let v_1: bool = not-caught-fail(public_key_1) in
        {18}let rm: key = getpublickey((if v_1 then keypairpack(validkey(public_key_1),basis_1) else fail-any)) in
        {19}let re: key = empty in
        {20}let prologue: bitstring = empty in
        {21}let psk: key = empty in
        {22}let protocol_name: bitstring = somename in
        {23}let h: bitstring = hash(protocol_name,empty) in
        {24}let ck: key = h in
        {25}let k: key = empty in
        {26}let cs: cipherstate = cipherstatepack(k,minnonce) in
        {27}let ss: symmetricstate = symmetricstatepack(cs,ck,h) in
        {28}let v_2: bitstring = catch-fail(symmetricstateunpack(ss)) in
        {29}let v_3: bool = (not-caught-fail(v_2) && success?(1-proj-3-tuple(v_2))) in
        {30}let h_1: bitstring = (if v_3 then 3-proj-3-tuple(v_2) else caught-fail) in
        {31}let ck_1: key = (if v_3 then 2-proj-3-tuple(v_2) else caught-fail) in
        {32}let cs_1: cipherstate = (if v_3 then 1-proj-3-tuple(v_2) else caught-fail) in
        {33}let ss_1: symmetricstate = catch-fail((if v_3 then symmetricstatepack(cs_1,ck_1,hash(h_1,prologue)) else fail-any)) in
        {34}let v_4: bool = not-caught-fail(ss_1) in
        {35}let v_5: bitstring = (if v_4 then catch-fail(symmetricstateunpack(ss_1)) else caught-fail) in
        {36}let v_6: bool = (not-caught-fail(v_5) && success?(1-proj-3-tuple(v_5))) in
        {37}let h_2: bitstring = (if v_6 then 3-proj-3-tuple(v_5) else caught-fail) in
        {38}let ck_2: key = (if v_6 then 2-proj-3-tuple(v_5) else caught-fail) in
        {39}let cs_2: cipherstate = (if v_6 then 1-proj-3-tuple(v_5) else caught-fail) in
        {40}let ss_2: symmetricstate = (if v_4 then catch-fail((if v_6 then symmetricstatepack(cs_2,ck_2,hash(h_2,rs)) else fail-any)) else caught-fail) in
        {41}let v_7: bool = not-caught-fail(ss_2) in
        {42}let v_8: bitstring = (if v_7 then catch-fail(symmetricstateunpack(ss_2)) else caught-fail) in
        {43}let v_9: bool = (not-caught-fail(v_8) && success?(1-proj-3-tuple(v_8))) in
        {44}let h_3: bitstring = (if v_9 then 3-proj-3-tuple(v_8) else caught-fail) in
        {45}let ck_3: key = (if v_9 then 2-proj-3-tuple(v_8) else caught-fail) in
        {46}let cs_3: cipherstate = (if v_9 then 1-proj-3-tuple(v_8) else caught-fail) in
        {47}let ss_3: symmetricstate = (if v_7 then catch-fail((if v_9 then symmetricstatepack(cs_3,ck_3,hash(h_3,rm)) else fail-any)) else caught-fail) in
        {48}let v_10: bool = not-caught-fail(ss_3) in
        {49}let hs: handshakestate = (if v_4 then (if v_7 then (if v_10 then handshakestatepack(ss_3,s,m,e,rs,rm,re,psk,true) else fail-any) else fail-any) else fail-any) in
        {50}insert statestore(me,them,sid_1,statepack_a(hs))
    ) | (
        {306}get statestore(=me,=them,=sid_1,statepack_a(hs_1: handshakestate)) in
        {51}let payload: bitstring = msg_a(me,them,sid_1) in
        {52}let v_11: bitstring = catch-fail(handshakestateunpack(hs_1)) in
        {53}let v_12: bool = (not-caught-fail(v_11) && success?(1-proj-9-tuple(v_11))) in
        {54}let initiator_1: bool = (if v_12 then 9-proj-9-tuple(v_11) else caught-fail) in
        {55}let psk_1: key = (if v_12 then 8-proj-9-tuple(v_11) else caught-fail) in
        {56}let re_1: key = (if v_12 then 7-proj-9-tuple(v_11) else caught-fail) in
        {57}let rm_1: key = (if v_12 then 6-proj-9-tuple(v_11) else caught-fail) in
        {58}let rs_1: key = (if v_12 then 5-proj-9-tuple(v_11) else caught-fail) in
        {59}let e_1: keypair = (if v_12 then 4-proj-9-tuple(v_11) else caught-fail) in
        {60}let m_1: keypair = (if v_12 then 3-proj-9-tuple(v_11) else caught-fail) in
        {61}let s_1: keypair = (if v_12 then 2-proj-9-tuple(v_11) else caught-fail) in
        {62}let ss_4: symmetricstate = (if v_12 then 1-proj-9-tuple(v_11) else caught-fail) in
        {63}let v_13: bitstring = (if v_12 then catch-fail((empty,empty,empty,empty)) else caught-fail) in
        {64}let v_14: bool = (not-caught-fail(v_13) && success?(1-proj-4-tuple(v_13))) in
        {65}let ciphertext: bitstring = (if v_14 then 4-proj-4-tuple(v_13) else caught-fail) in
        {66}let nm: bitstring = (if v_14 then 3-proj-4-tuple(v_13) else caught-fail) in
        {67}let ns: bitstring = (if v_14 then 2-proj-4-tuple(v_13) else caught-fail) in
        {68}let ne: bitstring = (if v_14 then 1-proj-4-tuple(v_13) else caught-fail) in
        {69}let basis_2: key = (if v_14 then key_e(me,them,sid_1) else caught-fail) in
        {70}let public_key_2: key = (if v_14 then catch-fail(dhexp(basis_2,validkey(g))) else caught-fail) in
        {71}let v_15: bool = not-caught-fail(public_key_2) in
        {72}let e_2: keypair = (if v_14 then catch-fail((if v_15 then keypairpack(validkey(public_key_2),basis_2) else fail-any)) else caught-fail) in
        {73}let v_16: bool = not-caught-fail(e_2) in
        {74}let ne_1: bitstring = (if v_16 then catch-fail(getpublickey(e_2)) else caught-fail) in
        {75}let v_17: bool = not-caught-fail(ne_1) in
        {76}let v_18: bitstring = (if v_17 then catch-fail(symmetricstateunpack(ss_4)) else caught-fail) in
        {77}let v_19: bool = (not-caught-fail(v_18) && success?(1-proj-3-tuple(v_18))) in
        {78}let h_4: bitstring = (if v_19 then 3-proj-3-tuple(v_18) else caught-fail) in
        {79}let ck_4: key = (if v_19 then 2-proj-3-tuple(v_18) else caught-fail) in
        {80}let cs_4: cipherstate = (if v_19 then 1-proj-3-tuple(v_18) else caught-fail) in
        {81}let ss_5: symmetricstate = (if v_17 then catch-fail((if v_19 then symmetricstatepack(cs_4,ck_4,hash(h_4,ne_1)) else fail-any)) else caught-fail) in
        {82}let v_20: bool = not-caught-fail(ss_5) in
        {83}let v_21: bitstring = (if v_20 then catch-fail(keypairunpack(e_2)) else caught-fail) in
        {84}let v_22: bool = (not-caught-fail(v_21) && success?(1-proj-2-tuple(v_21))) in
        {85}let my_private_key: key = (if v_22 then 2-proj-2-tuple(v_21) else caught-fail) in
        {86}let my_public_key: key = (if v_22 then 1-proj-2-tuple(v_21) else caught-fail) in
        {87}let input_key_material: key = (if v_20 then catch-fail((if v_22 then dhexp(my_private_key,rs_1) else fail-any)) else caught-fail) in
        {88}let v_23: bool = not-caught-fail(input_key_material) in
        {89}let v_24: bitstring = (if v_23 then catch-fail(symmetricstateunpack(ss_5)) else caught-fail) in
        {90}let v_25: bool = (not-caught-fail(v_24) && success?(1-proj-3-tuple(v_24))) in
        {91}let h_5: bitstring = (if v_25 then 3-proj-3-tuple(v_24) else caught-fail) in
        {92}let ck_5: key = (if v_25 then 2-proj-3-tuple(v_24) else caught-fail) in
        {93}let cs_5: cipherstate = (if v_25 then 1-proj-3-tuple(v_24) else caught-fail) in
        {94}let output1: key = (if v_25 then hmac_hash1(ck_5,input_key_material) else caught-fail) in
        {95}let output2: key = (if v_25 then hmac_hash2(ck_5,input_key_material) else caught-fail) in
        {96}let output3: key = (if v_25 then hmac_hash3(ck_5,input_key_material) else caught-fail) in
        {97}let v_26: bitstring = (if v_25 then catch-fail((output1,output2,output3)) else caught-fail) in
        {98}let v_27: bool = (not-caught-fail(v_26) && success?(1-proj-3-tuple(v_26))) in
        {99}let output_3: key = (if v_27 then 3-proj-3-tuple(v_26) else caught-fail) in
        {100}let temp_k: key = (if v_27 then 2-proj-3-tuple(v_26) else caught-fail) in
        {101}let ck_6: key = (if v_27 then 1-proj-3-tuple(v_26) else caught-fail) in
        {102}let ss_6: symmetricstate = (if v_20 then catch-fail((if v_23 then (if v_25 then (if v_27 then symmetricstatepack(cipherstatepack(temp_k,minnonce),ck_6,h_5) else fail-any) else fail-any) else fail-any)) else caught-fail) in
        {103}let v_28: bool = not-caught-fail(ss_6) in
        {104}let v_29: bitstring = (if v_28 then catch-fail(keypairunpack(e_2)) else caught-fail) in
        {105}let v_30: bool = (not-caught-fail(v_29) && success?(1-proj-2-tuple(v_29))) in
        {106}let my_private_key_1: key = (if v_30 then 2-proj-2-tuple(v_29) else caught-fail) in
        {107}let my_public_key_1: key = (if v_30 then 1-proj-2-tuple(v_29) else caught-fail) in
        {108}let input_key_material_1: key = (if v_28 then catch-fail((if v_30 then dhexp(my_private_key_1,rm_1) else fail-any)) else caught-fail) in
        {109}let v_31: bool = not-caught-fail(input_key_material_1) in
        {110}let v_32: bitstring = (if v_31 then catch-fail(symmetricstateunpack(ss_6)) else caught-fail) in
        {111}let v_33: bool = (not-caught-fail(v_32) && success?(1-proj-3-tuple(v_32))) in
        {112}let h_6: bitstring = (if v_33 then 3-proj-3-tuple(v_32) else caught-fail) in
        {113}let ck_7: key = (if v_33 then 2-proj-3-tuple(v_32) else caught-fail) in
        {114}let cs_6: cipherstate = (if v_33 then 1-proj-3-tuple(v_32) else caught-fail) in
        {115}let output1_1: key = (if v_33 then hmac_hash1(ck_7,input_key_material_1) else caught-fail) in
        {116}let output2_1: key = (if v_33 then hmac_hash2(ck_7,input_key_material_1) else caught-fail) in
        {117}let output3_1: key = (if v_33 then hmac_hash3(ck_7,input_key_material_1) else caught-fail) in
        {118}let v_34: bitstring = (if v_33 then catch-fail((output1_1,output2_1,output3_1)) else caught-fail) in
        {119}let v_35: bool = (not-caught-fail(v_34) && success?(1-proj-3-tuple(v_34))) in
        {120}let output: key = (if v_35 then 3-proj-3-tuple(v_34) else caught-fail) in
        {121}let temp_k_1: key = (if v_35 then 2-proj-3-tuple(v_34) else caught-fail) in
        {122}let ck_8: key = (if v_35 then 1-proj-3-tuple(v_34) else caught-fail) in
        {123}let ss_7: symmetricstate = (if v_28 then catch-fail((if v_31 then (if v_33 then (if v_35 then symmetricstatepack(cipherstatepack(temp_k_1,minnonce),ck_8,h_6) else fail-any) else fail-any) else fail-any)) else caught-fail) in
        {124}let v_36: bool = not-caught-fail(ss_7) in
        {125}let basis_3: key = (if v_36 then key_s(me) else caught-fail) in
        {126}let public_key_3: key = (if v_36 then catch-fail(dhexp(basis_3,validkey(g))) else caught-fail) in
        {127}let v_37: bool = not-caught-fail(public_key_3) in
        {128}let s_2: keypair = (if v_36 then catch-fail((if v_37 then keypairpack(validkey(public_key_3),basis_3) else fail-any)) else caught-fail) in
        {129}let v_38: bool = not-caught-fail(s_2) in
        {130}let plaintext: bitstring = (if v_38 then catch-fail(getpublickey(s_2)) else caught-fail) in
        {131}let v_39: bool = not-caught-fail(plaintext) in
        {132}let v_40: bitstring = (if v_39 then catch-fail(symmetricstateunpack(ss_7)) else caught-fail) in
        {133}let v_41: bool = (not-caught-fail(v_40) && success?(1-proj-3-tuple(v_40))) in
        {134}let h_7: bitstring = (if v_41 then 3-proj-3-tuple(v_40) else caught-fail) in
        {135}let ck_9: key = (if v_41 then 2-proj-3-tuple(v_40) else caught-fail) in
        {136}let cs_7: cipherstate = (if v_41 then 1-proj-3-tuple(v_40) else caught-fail) in
        {137}let v_42: bitstring = (if v_41 then catch-fail(cipherstateunpack(cs_7)) else caught-fail) in
        {138}let v_43: bool = (not-caught-fail(v_42) && success?(1-proj-2-tuple(v_42))) in
        {139}let n: nonce = (if v_43 then 2-proj-2-tuple(v_42) else caught-fail) in
        {140}let k_1: key = (if v_43 then 1-proj-2-tuple(v_42) else caught-fail) in
        {141}let e_3: bitstring = (if v_43 then encrypt(k_1,n,h_7,plaintext) else caught-fail) in
        {142}let n_1: nonce = (if v_43 then increment_nonce(n) else caught-fail) in
        {143}let v_44: bitstring = (if v_43 then catch-fail(cipherstateunpack(cs_7)) else caught-fail) in
        {144}let v_45: bool = (not-caught-fail(v_44) && success?(1-proj-2-tuple(v_44))) in
        {145}let o: nonce = (if v_45 then 2-proj-2-tuple(v_44) else caught-fail) in
        {146}let k_2: key = (if v_45 then 1-proj-2-tuple(v_44) else caught-fail) in
        {147}let csi: cipherstate = (if v_43 then catch-fail((if v_45 then cipherstatepack(k_2,n_1) else fail-any)) else caught-fail) in
        {148}let v_46: bool = not-caught-fail(csi) in
        {149}let v_47: bitstring = (if v_41 then catch-fail((if v_43 then (if v_46 then (csi,e_3) else fail-any) else fail-any)) else caught-fail) in
        {150}let v_48: bool = (not-caught-fail(v_47) && success?(1-proj-2-tuple(v_47))) in
        {151}let ciphertext_1: bitstring = (if v_48 then 2-proj-2-tuple(v_47) else caught-fail) in
        {152}let csi_1: cipherstate = (if v_48 then 1-proj-2-tuple(v_47) else caught-fail) in
        {153}let ss_8: symmetricstate = (if v_48 then symmetricstatepack(csi_1,ck_9,h_7) else caught-fail) in
        {154}let v_49: bitstring = (if v_48 then catch-fail(symmetricstateunpack(ss_8)) else caught-fail) in
        {155}let v_50: bool = (not-caught-fail(v_49) && success?(1-proj-3-tuple(v_49))) in
        {156}let h_8: bitstring = (if v_50 then 3-proj-3-tuple(v_49) else caught-fail) in
        {157}let ck_10: key = (if v_50 then 2-proj-3-tuple(v_49) else caught-fail) in
        {158}let cs_8: cipherstate = (if v_50 then 1-proj-3-tuple(v_49) else caught-fail) in
        {159}let ssi: symmetricstate = (if v_48 then catch-fail((if v_50 then symmetricstatepack(cs_8,ck_10,hash(h_8,ciphertext_1)) else fail-any)) else caught-fail) in
        {160}let v_51: bool = not-caught-fail(ssi) in
        {161}let v_52: bitstring = (if v_38 then catch-fail((if v_39 then (if v_41 then (if v_48 then (if v_51 then (ssi,ciphertext_1) else fail-any) else fail-any) else fail-any) else fail-any)) else caught-fail) in
        {162}let v_53: bool = (not-caught-fail(v_52) && success?(1-proj-2-tuple(v_52))) in
        {163}let ns_1: bitstring = (if v_53 then 2-proj-2-tuple(v_52) else caught-fail) in
        {164}let ss_9: symmetricstate = (if v_53 then 1-proj-2-tuple(v_52) else caught-fail) in
        {165}let basis_4: key = (if v_53 then key_m(me) else caught-fail) in
        {166}let public_key_4: key = (if v_53 then catch-fail(dhexp(basis_4,validkey(g))) else caught-fail) in
        {167}let v_54: bool = not-caught-fail(public_key_4) in
        {168}let m_2: keypair = (if v_53 then catch-fail((if v_54 then keypairpack(validkey(public_key_4),basis_4) else fail-any)) else caught-fail) in
        {169}let v_55: bool = not-caught-fail(m_2) in
        {170}let plaintext_1: bitstring = (if v_55 then catch-fail(getpublickey(m_2)) else caught-fail) in
        {171}let v_56: bool = not-caught-fail(plaintext_1) in
        {172}let v_57: bitstring = (if v_56 then catch-fail(symmetricstateunpack(ss_9)) else caught-fail) in
        {173}let v_58: bool = (not-caught-fail(v_57) && success?(1-proj-3-tuple(v_57))) in
        {174}let h_9: bitstring = (if v_58 then 3-proj-3-tuple(v_57) else caught-fail) in
        {175}let ck_11: key = (if v_58 then 2-proj-3-tuple(v_57) else caught-fail) in
        {176}let cs_9: cipherstate = (if v_58 then 1-proj-3-tuple(v_57) else caught-fail) in
        {177}let v_59: bitstring = (if v_58 then catch-fail(cipherstateunpack(cs_9)) else caught-fail) in
        {178}let v_60: bool = (not-caught-fail(v_59) && success?(1-proj-2-tuple(v_59))) in
        {179}let n_2: nonce = (if v_60 then 2-proj-2-tuple(v_59) else caught-fail) in
        {180}let k_3: key = (if v_60 then 1-proj-2-tuple(v_59) else caught-fail) in
        {181}let e_4: bitstring = (if v_60 then encrypt(k_3,n_2,h_9,plaintext_1) else caught-fail) in
        {182}let n_3: nonce = (if v_60 then increment_nonce(n_2) else caught-fail) in
        {183}let v_61: bitstring = (if v_60 then catch-fail(cipherstateunpack(cs_9)) else caught-fail) in
        {184}let v_62: bool = (not-caught-fail(v_61) && success?(1-proj-2-tuple(v_61))) in
        {185}let o_1: nonce = (if v_62 then 2-proj-2-tuple(v_61) else caught-fail) in
        {186}let k_4: key = (if v_62 then 1-proj-2-tuple(v_61) else caught-fail) in
        {187}let csi_2: cipherstate = (if v_60 then catch-fail((if v_62 then cipherstatepack(k_4,n_3) else fail-any)) else caught-fail) in
        {188}let v_63: bool = not-caught-fail(csi_2) in
        {189}let v_64: bitstring = (if v_58 then catch-fail((if v_60 then (if v_63 then (csi_2,e_4) else fail-any) else fail-any)) else caught-fail) in
        {190}let v_65: bool = (not-caught-fail(v_64) && success?(1-proj-2-tuple(v_64))) in
        {191}let ciphertext_2: bitstring = (if v_65 then 2-proj-2-tuple(v_64) else caught-fail) in
        {192}let csi_3: cipherstate = (if v_65 then 1-proj-2-tuple(v_64) else caught-fail) in
        {193}let ss_10: symmetricstate = (if v_65 then symmetricstatepack(csi_3,ck_11,h_9) else caught-fail) in
        {194}let v_66: bitstring = (if v_65 then catch-fail(symmetricstateunpack(ss_10)) else caught-fail) in
        {195}let v_67: bool = (not-caught-fail(v_66) && success?(1-proj-3-tuple(v_66))) in
        {196}let h_10: bitstring = (if v_67 then 3-proj-3-tuple(v_66) else caught-fail) in
        {197}let ck_12: key = (if v_67 then 2-proj-3-tuple(v_66) else caught-fail) in
        {198}let cs_10: cipherstate = (if v_67 then 1-proj-3-tuple(v_66) else caught-fail) in
        {199}let ssi_1: symmetricstate = (if v_65 then catch-fail((if v_67 then symmetricstatepack(cs_10,ck_12,hash(h_10,ciphertext_2)) else fail-any)) else caught-fail) in
        {200}let v_68: bool = not-caught-fail(ssi_1) in
        {201}let v_69: bitstring = (if v_55 then catch-fail((if v_56 then (if v_58 then (if v_65 then (if v_68 then (ssi_1,ciphertext_2) else fail-any) else fail-any) else fail-any) else fail-any)) else caught-fail) in
        {202}let v_70: bool = (not-caught-fail(v_69) && success?(1-proj-2-tuple(v_69))) in
        {203}let nm_1: bitstring = (if v_70 then 2-proj-2-tuple(v_69) else caught-fail) in
        {204}let ss_11: symmetricstate = (if v_70 then 1-proj-2-tuple(v_69) else caught-fail) in
        {205}let v_71: bitstring = (if v_70 then catch-fail(keypairunpack(m_2)) else caught-fail) in
        {206}let v_72: bool = (not-caught-fail(v_71) && success?(1-proj-2-tuple(v_71))) in
        {207}let my_private_key_2: key = (if v_72 then 2-proj-2-tuple(v_71) else caught-fail) in
        {208}let my_public_key_2: key = (if v_72 then 1-proj-2-tuple(v_71) else caught-fail) in
        {209}let input_key_material_2: key = (if v_70 then catch-fail((if v_72 then dhexp(my_private_key_2,rs_1) else fail-any)) else caught-fail) in
        {210}let v_73: bool = not-caught-fail(input_key_material_2) in
        {211}let v_74: bitstring = (if v_73 then catch-fail(symmetricstateunpack(ss_11)) else caught-fail) in
        {212}let v_75: bool = (not-caught-fail(v_74) && success?(1-proj-3-tuple(v_74))) in
        {213}let h_11: bitstring = (if v_75 then 3-proj-3-tuple(v_74) else caught-fail) in
        {214}let ck_13: key = (if v_75 then 2-proj-3-tuple(v_74) else caught-fail) in
        {215}let cs_11: cipherstate = (if v_75 then 1-proj-3-tuple(v_74) else caught-fail) in
        {216}let output1_2: key = (if v_75 then hmac_hash1(ck_13,input_key_material_2) else caught-fail) in
        {217}let output2_2: key = (if v_75 then hmac_hash2(ck_13,input_key_material_2) else caught-fail) in
        {218}let output3_2: key = (if v_75 then hmac_hash3(ck_13,input_key_material_2) else caught-fail) in
        {219}let v_76: bitstring = (if v_75 then catch-fail((output1_2,output2_2,output3_2)) else caught-fail) in
        {220}let v_77: bool = (not-caught-fail(v_76) && success?(1-proj-3-tuple(v_76))) in
        {221}let output_1: key = (if v_77 then 3-proj-3-tuple(v_76) else caught-fail) in
        {222}let temp_k_2: key = (if v_77 then 2-proj-3-tuple(v_76) else caught-fail) in
        {223}let ck_14: key = (if v_77 then 1-proj-3-tuple(v_76) else caught-fail) in
        {224}let ss_12: symmetricstate = (if v_70 then catch-fail((if v_73 then (if v_75 then (if v_77 then symmetricstatepack(cipherstatepack(temp_k_2,minnonce),ck_14,h_11) else fail-any) else fail-any) else fail-any)) else caught-fail) in
        {225}let v_78: bool = not-caught-fail(ss_12) in
        {226}let v_79: bitstring = (if v_78 then catch-fail(keypairunpack(s_2)) else caught-fail) in
        {227}let v_80: bool = (not-caught-fail(v_79) && success?(1-proj-2-tuple(v_79))) in
        {228}let my_private_key_3: key = (if v_80 then 2-proj-2-tuple(v_79) else caught-fail) in
        {229}let my_public_key_3: key = (if v_80 then 1-proj-2-tuple(v_79) else caught-fail) in
        {230}let input_key_material_3: key = (if v_78 then catch-fail((if v_80 then dhexp(my_private_key_3,rm_1) else fail-any)) else caught-fail) in
        {231}let v_81: bool = not-caught-fail(input_key_material_3) in
        {232}let v_82: bitstring = (if v_81 then catch-fail(symmetricstateunpack(ss_12)) else caught-fail) in
        {233}let v_83: bool = (not-caught-fail(v_82) && success?(1-proj-3-tuple(v_82))) in
        {234}let h_12: bitstring = (if v_83 then 3-proj-3-tuple(v_82) else caught-fail) in
        {235}let ck_15: key = (if v_83 then 2-proj-3-tuple(v_82) else caught-fail) in
        {236}let cs_12: cipherstate = (if v_83 then 1-proj-3-tuple(v_82) else caught-fail) in
        {237}let output1_3: key = (if v_83 then hmac_hash1(ck_15,input_key_material_3) else caught-fail) in
        {238}let output2_3: key = (if v_83 then hmac_hash2(ck_15,input_key_material_3) else caught-fail) in
        {239}let output3_3: key = (if v_83 then hmac_hash3(ck_15,input_key_material_3) else caught-fail) in
        {240}let v_84: bitstring = (if v_83 then catch-fail((output1_3,output2_3,output3_3)) else caught-fail) in
        {241}let v_85: bool = (not-caught-fail(v_84) && success?(1-proj-3-tuple(v_84))) in
        {242}let output_2: key = (if v_85 then 3-proj-3-tuple(v_84) else caught-fail) in
        {243}let temp_k_3: key = (if v_85 then 2-proj-3-tuple(v_84) else caught-fail) in
        {244}let ck_16: key = (if v_85 then 1-proj-3-tuple(v_84) else caught-fail) in
        {245}let ss_13: symmetricstate = (if v_78 then catch-fail((if v_81 then (if v_83 then (if v_85 then symmetricstatepack(cipherstatepack(temp_k_3,minnonce),ck_16,h_12) else fail-any) else fail-any) else fail-any)) else caught-fail) in
        {246}let v_86: bool = not-caught-fail(ss_13) in
        {247}let v_87: bitstring = (if v_86 then catch-fail(symmetricstateunpack(ss_13)) else caught-fail) in
        {248}let v_88: bool = (not-caught-fail(v_87) && success?(1-proj-3-tuple(v_87))) in
        {249}let h_13: bitstring = (if v_88 then 3-proj-3-tuple(v_87) else caught-fail) in
        {250}let ck_17: key = (if v_88 then 2-proj-3-tuple(v_87) else caught-fail) in
        {251}let cs_13: cipherstate = (if v_88 then 1-proj-3-tuple(v_87) else caught-fail) in
        {252}let v_89: bitstring = (if v_88 then catch-fail(cipherstateunpack(cs_13)) else caught-fail) in
        {253}let v_90: bool = (not-caught-fail(v_89) && success?(1-proj-2-tuple(v_89))) in
        {254}let n_4: nonce = (if v_90 then 2-proj-2-tuple(v_89) else caught-fail) in
        {255}let k_5: key = (if v_90 then 1-proj-2-tuple(v_89) else caught-fail) in
        {256}let e_5: bitstring = (if v_90 then encrypt(k_5,n_4,h_13,payload) else caught-fail) in
        {257}let n_5: nonce = (if v_90 then increment_nonce(n_4) else caught-fail) in
        {258}let v_91: bitstring = (if v_90 then catch-fail(cipherstateunpack(cs_13)) else caught-fail) in
        {259}let v_92: bool = (not-caught-fail(v_91) && success?(1-proj-2-tuple(v_91))) in
        {260}let o_2: nonce = (if v_92 then 2-proj-2-tuple(v_91) else caught-fail) in
        {261}let k_6: key = (if v_92 then 1-proj-2-tuple(v_91) else caught-fail) in
        {262}let csi_4: cipherstate = (if v_90 then catch-fail((if v_92 then cipherstatepack(k_6,n_5) else fail-any)) else caught-fail) in
        {263}let v_93: bool = not-caught-fail(csi_4) in
        {264}let v_94: bitstring = (if v_88 then catch-fail((if v_90 then (if v_93 then (csi_4,e_5) else fail-any) else fail-any)) else caught-fail) in
        {265}let v_95: bool = (not-caught-fail(v_94) && success?(1-proj-2-tuple(v_94))) in
        {266}let ciphertext_3: bitstring = (if v_95 then 2-proj-2-tuple(v_94) else caught-fail) in
        {267}let csi_5: cipherstate = (if v_95 then 1-proj-2-tuple(v_94) else caught-fail) in
        {268}let ss_14: symmetricstate = (if v_95 then symmetricstatepack(csi_5,ck_17,h_13) else caught-fail) in
        {269}let v_96: bitstring = (if v_95 then catch-fail(symmetricstateunpack(ss_14)) else caught-fail) in
        {270}let v_97: bool = (not-caught-fail(v_96) && success?(1-proj-3-tuple(v_96))) in
        {271}let h_14: bitstring = (if v_97 then 3-proj-3-tuple(v_96) else caught-fail) in
        {272}let ck_18: key = (if v_97 then 2-proj-3-tuple(v_96) else caught-fail) in
        {273}let cs_14: cipherstate = (if v_97 then 1-proj-3-tuple(v_96) else caught-fail) in
        {274}let ssi_2: symmetricstate = (if v_95 then catch-fail((if v_97 then symmetricstatepack(cs_14,ck_18,hash(h_14,ciphertext_3)) else fail-any)) else caught-fail) in
        {275}let v_98: bool = not-caught-fail(ssi_2) in
        {276}let v_99: bitstring = (if v_86 then catch-fail((if v_88 then (if v_95 then (if v_98 then (ssi_2,ciphertext_3) else fail-any) else fail-any) else fail-any)) else caught-fail) in
        {277}let v_100: bool = (not-caught-fail(v_99) && success?(1-proj-2-tuple(v_99))) in
        {278}let ciphertext_4: bitstring = (if v_100 then 2-proj-2-tuple(v_99) else caught-fail) in
        {279}let ss_15: symmetricstate = (if v_100 then 1-proj-2-tuple(v_99) else caught-fail) in
        {280}let hs_2: handshakestate = (if v_100 then handshakestatepack(ss_15,s_2,m_2,e_2,rs_1,rm_1,re_1,psk_1,initiator_1) else caught-fail) in
        {281}let message_buffer: bitstring = (if v_100 then concat4(ne_1,ns_1,nm_1,ciphertext_4) else caught-fail) in
        {282}let v_101: bitstring = (if v_100 then catch-fail(symmetricstateunpack(ss_15)) else caught-fail) in
        {283}let v_102: bool = (not-caught-fail(v_101) && success?(1-proj-3-tuple(v_101))) in
        {284}let h_15: bitstring = (if v_102 then 3-proj-3-tuple(v_101) else caught-fail) in
        {285}let ck_19: key = (if v_102 then 2-proj-3-tuple(v_101) else caught-fail) in
        {286}let cs_15: cipherstate = (if v_102 then 1-proj-3-tuple(v_101) else caught-fail) in
        {287}let input_key_material_4: key = (if v_102 then zero else caught-fail) in
        {288}let output1_4: key = (if v_102 then hmac_hash1(ck_19,input_key_material_4) else caught-fail) in
        {289}let output2_4: key = (if v_102 then hmac_hash2(ck_19,input_key_material_4) else caught-fail) in
        {290}let output3_4: key = (if v_102 then hmac_hash3(ck_19,input_key_material_4) else caught-fail) in
        {291}let v_103: bitstring = (if v_102 then catch-fail((output1_4,output2_4,output3_4)) else caught-fail) in
        {292}let v_104: bool = (not-caught-fail(v_103) && success?(1-proj-3-tuple(v_103))) in
        {293}let temp_k3: key = (if v_104 then 3-proj-3-tuple(v_103) else caught-fail) in
        {294}let temp_k2: key = (if v_104 then 2-proj-3-tuple(v_103) else caught-fail) in
        {295}let temp_k1: key = (if v_104 then 1-proj-3-tuple(v_103) else caught-fail) in
        {296}let cs1: cipherstate = (if v_104 then cipherstatepack(temp_k1,minnonce) else caught-fail) in
        {297}let cs2: cipherstate = (if v_104 then cipherstatepack(temp_k2,minnonce) else caught-fail) in
        {298}let v_105: bitstring = (if v_100 then catch-fail((if v_102 then (if v_104 then (ss_15,cs1,cs2) else fail-any) else fail-any)) else caught-fail) in
        {299}let v_106: bool = (not-caught-fail(v_105) && success?(1-proj-3-tuple(v_105))) in
        {300}let cs2_1: cipherstate = (if v_106 then 3-proj-3-tuple(v_105) else caught-fail) in
        {301}let cs1_1: cipherstate = (if v_106 then 2-proj-3-tuple(v_105) else caught-fail) in
        {302}let ssi_3: symmetricstate = (if v_106 then 1-proj-3-tuple(v_105) else caught-fail) in
        {303}let (hs_3: handshakestate,message_a: bitstring,cs1_2: cipherstate,cs2_2: cipherstate) = (if v_12 then (if v_14 then (if v_16 then (if v_17 then (if v_20 then (if v_28 then (if v_36 then (if v_38 then (if v_53 then (if v_55 then (if v_70 then (if v_78 then (if v_86 then (if v_100 then (if v_106 then (hs_2,message_buffer,cs1_1,cs2_1) else fail-any) else fail-any) else fail-any) else fail-any) else fail-any) else fail-any) else fail-any) else fail-any) else fail-any) else fail-any) else fail-any) else fail-any) else fail-any) else fail-any) else fail-any) in
        {304}event SendMsg(me,them,stagepack_a(sid_1),msg_a(me,them,sid_1));
        {305}out(pub, message_a)
    ) | (
        {307}event LeakS(phase0,me);
        {308}event LeakM(phase0,me);
        {309}out(pub, (key_s(me),key_m(me)))
    ) | (
        {310}phase 1;
        {311}event LeakS(phase1,me);
        {312}event LeakM(phase1,me);
        {313}out(pub, (key_s(me),key_m(me)))
    )
) | (
    {314}let me_1: principal = alice in
    {315}let them_1: principal = charlie in
    {316}let sid_2: sessionid = sid in
    {317}let s_3: keypair = keypairpack(empty,empty) in
    {318}let m_3: keypair = keypairpack(empty,empty) in
    {319}out(pub, (getpublickey(s_3),getpublickey(m_3)));
    (
        {320}let e_6: keypair = keypairpack(empty,empty) in
        {321}let basis_5: key = key_s(them_1) in
        {322}let public_key_5: key = catch-fail(dhexp(basis_5,validkey(g))) in
        {323}let v_107: bool = not-caught-fail(public_key_5) in
        {324}let rs_2: key = getpublickey((if v_107 then keypairpack(validkey(public_key_5),basis_5) else fail-any)) in
        {325}let basis_6: key = key_m(them_1) in
        {326}let public_key_6: key = catch-fail(dhexp(basis_6,validkey(g))) in
        {327}let v_108: bool = not-caught-fail(public_key_6) in
        {328}let rm_2: key = getpublickey((if v_108 then keypairpack(validkey(public_key_6),basis_6) else fail-any)) in
        {329}let re_2: key = empty in
        {330}let prologue_1: bitstring = empty in
        {331}let psk_2: key = empty in
        {332}let protocol_name_1: bitstring = somename in
        {333}let h_16: bitstring = hash(protocol_name_1,empty) in
        {334}let ck_20: key = h_16 in
        {335}let k_7: key = empty in
        {336}let cs_16: cipherstate = cipherstatepack(k_7,minnonce) in
        {337}let ss_16: symmetricstate = symmetricstatepack(cs_16,ck_20,h_16) in
        {338}let v_109: bitstring = catch-fail(symmetricstateunpack(ss_16)) in
        {339}let v_110: bool = (not-caught-fail(v_109) && success?(1-proj-3-tuple(v_109))) in
        {340}let h_17: bitstring = (if v_110 then 3-proj-3-tuple(v_109) else caught-fail) in
        {341}let ck_21: key = (if v_110 then 2-proj-3-tuple(v_109) else caught-fail) in
        {342}let cs_17: cipherstate = (if v_110 then 1-proj-3-tuple(v_109) else caught-fail) in
        {343}let ss_17: symmetricstate = catch-fail((if v_110 then symmetricstatepack(cs_17,ck_21,hash(h_17,prologue_1)) else fail-any)) in
        {344}let v_111: bool = not-caught-fail(ss_17) in
        {345}let v_112: bitstring = (if v_111 then catch-fail(symmetricstateunpack(ss_17)) else caught-fail) in
        {346}let v_113: bool = (not-caught-fail(v_112) && success?(1-proj-3-tuple(v_112))) in
        {347}let h_18: bitstring = (if v_113 then 3-proj-3-tuple(v_112) else caught-fail) in
        {348}let ck_22: key = (if v_113 then 2-proj-3-tuple(v_112) else caught-fail) in
        {349}let cs_18: cipherstate = (if v_113 then 1-proj-3-tuple(v_112) else caught-fail) in
        {350}let ss_18: symmetricstate = (if v_111 then catch-fail((if v_113 then symmetricstatepack(cs_18,ck_22,hash(h_18,rs_2)) else fail-any)) else caught-fail) in
        {351}let v_114: bool = not-caught-fail(ss_18) in
        {352}let v_115: bitstring = (if v_114 then catch-fail(symmetricstateunpack(ss_18)) else caught-fail) in
        {353}let v_116: bool = (not-caught-fail(v_115) && success?(1-proj-3-tuple(v_115))) in
        {354}let h_19: bitstring = (if v_116 then 3-proj-3-tuple(v_115) else caught-fail) in
        {355}let ck_23: key = (if v_116 then 2-proj-3-tuple(v_115) else caught-fail) in
        {356}let cs_19: cipherstate = (if v_116 then 1-proj-3-tuple(v_115) else caught-fail) in
        {357}let ss_19: symmetricstate = (if v_114 then catch-fail((if v_116 then symmetricstatepack(cs_19,ck_23,hash(h_19,rm_2)) else fail-any)) else caught-fail) in
        {358}let v_117: bool = not-caught-fail(ss_19) in
        {359}let hs_4: handshakestate = (if v_111 then (if v_114 then (if v_117 then handshakestatepack(ss_19,s_3,m_3,e_6,rs_2,rm_2,re_2,psk_2,true) else fail-any) else fail-any) else fail-any) in
        {360}insert statestore(me_1,them_1,sid_2,statepack_a(hs_4))
    ) | (
        {616}get statestore(=me_1,=them_1,=sid_2,statepack_a(hs_5: handshakestate)) in
        {361}let payload_1: bitstring = msg_a(me_1,them_1,sid_2) in
        {362}let v_118: bitstring = catch-fail(handshakestateunpack(hs_5)) in
        {363}let v_119: bool = (not-caught-fail(v_118) && success?(1-proj-9-tuple(v_118))) in
        {364}let initiator_2: bool = (if v_119 then 9-proj-9-tuple(v_118) else caught-fail) in
        {365}let psk_3: key = (if v_119 then 8-proj-9-tuple(v_118) else caught-fail) in
        {366}let re_3: key = (if v_119 then 7-proj-9-tuple(v_118) else caught-fail) in
        {367}let rm_3: key = (if v_119 then 6-proj-9-tuple(v_118) else caught-fail) in
        {368}let rs_3: key = (if v_119 then 5-proj-9-tuple(v_118) else caught-fail) in
        {369}let e_7: keypair = (if v_119 then 4-proj-9-tuple(v_118) else caught-fail) in
        {370}let m_4: keypair = (if v_119 then 3-proj-9-tuple(v_118) else caught-fail) in
        {371}let s_4: keypair = (if v_119 then 2-proj-9-tuple(v_118) else caught-fail) in
        {372}let ss_20: symmetricstate = (if v_119 then 1-proj-9-tuple(v_118) else caught-fail) in
        {373}let v_120: bitstring = (if v_119 then catch-fail((empty,empty,empty,empty)) else caught-fail) in
        {374}let v_121: bool = (not-caught-fail(v_120) && success?(1-proj-4-tuple(v_120))) in
        {375}let ciphertext_5: bitstring = (if v_121 then 4-proj-4-tuple(v_120) else caught-fail) in
        {376}let nm_2: bitstring = (if v_121 then 3-proj-4-tuple(v_120) else caught-fail) in
        {377}let ns_2: bitstring = (if v_121 then 2-proj-4-tuple(v_120) else caught-fail) in
        {378}let ne_2: bitstring = (if v_121 then 1-proj-4-tuple(v_120) else caught-fail) in
        {379}let basis_7: key = (if v_121 then key_e(me_1,them_1,sid_2) else caught-fail) in
        {380}let public_key_7: key = (if v_121 then catch-fail(dhexp(basis_7,validkey(g))) else caught-fail) in
        {381}let v_122: bool = not-caught-fail(public_key_7) in
        {382}let e_8: keypair = (if v_121 then catch-fail((if v_122 then keypairpack(validkey(public_key_7),basis_7) else fail-any)) else caught-fail) in
        {383}let v_123: bool = not-caught-fail(e_8) in
        {384}let ne_3: bitstring = (if v_123 then catch-fail(getpublickey(e_8)) else caught-fail) in
        {385}let v_124: bool = not-caught-fail(ne_3) in
        {386}let v_125: bitstring = (if v_124 then catch-fail(symmetricstateunpack(ss_20)) else caught-fail) in
        {387}let v_126: bool = (not-caught-fail(v_125) && success?(1-proj-3-tuple(v_125))) in
        {388}let h_20: bitstring = (if v_126 then 3-proj-3-tuple(v_125) else caught-fail) in
        {389}let ck_24: key = (if v_126 then 2-proj-3-tuple(v_125) else caught-fail) in
        {390}let cs_20: cipherstate = (if v_126 then 1-proj-3-tuple(v_125) else caught-fail) in
        {391}let ss_21: symmetricstate = (if v_124 then catch-fail((if v_126 then symmetricstatepack(cs_20,ck_24,hash(h_20,ne_3)) else fail-any)) else caught-fail) in
        {392}let v_127: bool = not-caught-fail(ss_21) in
        {393}let v_128: bitstring = (if v_127 then catch-fail(keypairunpack(e_8)) else caught-fail) in
        {394}let v_129: bool = (not-caught-fail(v_128) && success?(1-proj-2-tuple(v_128))) in
        {395}let my_private_key_4: key = (if v_129 then 2-proj-2-tuple(v_128) else caught-fail) in
        {396}let my_public_key_4: key = (if v_129 then 1-proj-2-tuple(v_128) else caught-fail) in
        {397}let input_key_material_5: key = (if v_127 then catch-fail((if v_129 then dhexp(my_private_key_4,rs_3) else fail-any)) else caught-fail) in
        {398}let v_130: bool = not-caught-fail(input_key_material_5) in
        {399}let v_131: bitstring = (if v_130 then catch-fail(symmetricstateunpack(ss_21)) else caught-fail) in
        {400}let v_132: bool = (not-caught-fail(v_131) && success?(1-proj-3-tuple(v_131))) in
        {401}let h_21: bitstring = (if v_132 then 3-proj-3-tuple(v_131) else caught-fail) in
        {402}let ck_25: key = (if v_132 then 2-proj-3-tuple(v_131) else caught-fail) in
        {403}let cs_21: cipherstate = (if v_132 then 1-proj-3-tuple(v_131) else caught-fail) in
        {404}let output1_5: key = (if v_132 then hmac_hash1(ck_25,input_key_material_5) else caught-fail) in
        {405}let output2_5: key = (if v_132 then hmac_hash2(ck_25,input_key_material_5) else caught-fail) in
        {406}let output3_5: key = (if v_132 then hmac_hash3(ck_25,input_key_material_5) else caught-fail) in
        {407}let v_133: bitstring = (if v_132 then catch-fail((output1_5,output2_5,output3_5)) else caught-fail) in
        {408}let v_134: bool = (not-caught-fail(v_133) && success?(1-proj-3-tuple(v_133))) in
        {409}let output_4: key = (if v_134 then 3-proj-3-tuple(v_133) else caught-fail) in
        {410}let temp_k_4: key = (if v_134 then 2-proj-3-tuple(v_133) else caught-fail) in
        {411}let ck_26: key = (if v_134 then 1-proj-3-tuple(v_133) else caught-fail) in
        {412}let ss_22: symmetricstate = (if v_127 then catch-fail((if v_130 then (if v_132 then (if v_134 then symmetricstatepack(cipherstatepack(temp_k_4,minnonce),ck_26,h_21) else fail-any) else fail-any) else fail-any)) else caught-fail) in
        {413}let v_135: bool = not-caught-fail(ss_22) in
        {414}let v_136: bitstring = (if v_135 then catch-fail(keypairunpack(e_8)) else caught-fail) in
        {415}let v_137: bool = (not-caught-fail(v_136) && success?(1-proj-2-tuple(v_136))) in
        {416}let my_private_key_5: key = (if v_137 then 2-proj-2-tuple(v_136) else caught-fail) in
        {417}let my_public_key_5: key = (if v_137 then 1-proj-2-tuple(v_136) else caught-fail) in
        {418}let input_key_material_6: key = (if v_135 then catch-fail((if v_137 then dhexp(my_private_key_5,rm_3) else fail-any)) else caught-fail) in
        {419}let v_138: bool = not-caught-fail(input_key_material_6) in
        {420}let v_139: bitstring = (if v_138 then catch-fail(symmetricstateunpack(ss_22)) else caught-fail) in
        {421}let v_140: bool = (not-caught-fail(v_139) && success?(1-proj-3-tuple(v_139))) in
        {422}let h_22: bitstring = (if v_140 then 3-proj-3-tuple(v_139) else caught-fail) in
        {423}let ck_27: key = (if v_140 then 2-proj-3-tuple(v_139) else caught-fail) in
        {424}let cs_22: cipherstate = (if v_140 then 1-proj-3-tuple(v_139) else caught-fail) in
        {425}let output1_6: key = (if v_140 then hmac_hash1(ck_27,input_key_material_6) else caught-fail) in
        {426}let output2_6: key = (if v_140 then hmac_hash2(ck_27,input_key_material_6) else caught-fail) in
        {427}let output3_6: key = (if v_140 then hmac_hash3(ck_27,input_key_material_6) else caught-fail) in
        {428}let v_141: bitstring = (if v_140 then catch-fail((output1_6,output2_6,output3_6)) else caught-fail) in
        {429}let v_142: bool = (not-caught-fail(v_141) && success?(1-proj-3-tuple(v_141))) in
        {430}let output_5: key = (if v_142 then 3-proj-3-tuple(v_141) else caught-fail) in
        {431}let temp_k_5: key = (if v_142 then 2-proj-3-tuple(v_141) else caught-fail) in
        {432}let ck_28: key = (if v_142 then 1-proj-3-tuple(v_141) else caught-fail) in
        {433}let ss_23: symmetricstate = (if v_135 then catch-fail((if v_138 then (if v_140 then (if v_142 then symmetricstatepack(cipherstatepack(temp_k_5,minnonce),ck_28,h_22) else fail-any) else fail-any) else fail-any)) else caught-fail) in
        {434}let v_143: bool = not-caught-fail(ss_23) in
        {435}let basis_8: key = (if v_143 then key_s(me_1) else caught-fail) in
        {436}let public_key_8: key = (if v_143 then catch-fail(dhexp(basis_8,validkey(g))) else caught-fail) in
        {437}let v_144: bool = not-caught-fail(public_key_8) in
        {438}let s_5: keypair = (if v_143 then catch-fail((if v_144 then keypairpack(validkey(public_key_8),basis_8) else fail-any)) else caught-fail) in
        {439}let v_145: bool = not-caught-fail(s_5) in
        {440}let plaintext_2: bitstring = (if v_145 then catch-fail(getpublickey(s_5)) else caught-fail) in
        {441}let v_146: bool = not-caught-fail(plaintext_2) in
        {442}let v_147: bitstring = (if v_146 then catch-fail(symmetricstateunpack(ss_23)) else caught-fail) in
        {443}let v_148: bool = (not-caught-fail(v_147) && success?(1-proj-3-tuple(v_147))) in
        {444}let h_23: bitstring = (if v_148 then 3-proj-3-tuple(v_147) else caught-fail) in
        {445}let ck_29: key = (if v_148 then 2-proj-3-tuple(v_147) else caught-fail) in
        {446}let cs_23: cipherstate = (if v_148 then 1-proj-3-tuple(v_147) else caught-fail) in
        {447}let v_149: bitstring = (if v_148 then catch-fail(cipherstateunpack(cs_23)) else caught-fail) in
        {448}let v_150: bool = (not-caught-fail(v_149) && success?(1-proj-2-tuple(v_149))) in
        {449}let n_6: nonce = (if v_150 then 2-proj-2-tuple(v_149) else caught-fail) in
        {450}let k_8: key = (if v_150 then 1-proj-2-tuple(v_149) else caught-fail) in
        {451}let e_9: bitstring = (if v_150 then encrypt(k_8,n_6,h_23,plaintext_2) else caught-fail) in
        {452}let n_7: nonce = (if v_150 then increment_nonce(n_6) else caught-fail) in
        {453}let v_151: bitstring = (if v_150 then catch-fail(cipherstateunpack(cs_23)) else caught-fail) in
        {454}let v_152: bool = (not-caught-fail(v_151) && success?(1-proj-2-tuple(v_151))) in
        {455}let o_3: nonce = (if v_152 then 2-proj-2-tuple(v_151) else caught-fail) in
        {456}let k_9: key = (if v_152 then 1-proj-2-tuple(v_151) else caught-fail) in
        {457}let csi_6: cipherstate = (if v_150 then catch-fail((if v_152 then cipherstatepack(k_9,n_7) else fail-any)) else caught-fail) in
        {458}let v_153: bool = not-caught-fail(csi_6) in
        {459}let v_154: bitstring = (if v_148 then catch-fail((if v_150 then (if v_153 then (csi_6,e_9) else fail-any) else fail-any)) else caught-fail) in
        {460}let v_155: bool = (not-caught-fail(v_154) && success?(1-proj-2-tuple(v_154))) in
        {461}let ciphertext_6: bitstring = (if v_155 then 2-proj-2-tuple(v_154) else caught-fail) in
        {462}let csi_7: cipherstate = (if v_155 then 1-proj-2-tuple(v_154) else caught-fail) in
        {463}let ss_24: symmetricstate = (if v_155 then symmetricstatepack(csi_7,ck_29,h_23) else caught-fail) in
        {464}let v_156: bitstring = (if v_155 then catch-fail(symmetricstateunpack(ss_24)) else caught-fail) in
        {465}let v_157: bool = (not-caught-fail(v_156) && success?(1-proj-3-tuple(v_156))) in
        {466}let h_24: bitstring = (if v_157 then 3-proj-3-tuple(v_156) else caught-fail) in
        {467}let ck_30: key = (if v_157 then 2-proj-3-tuple(v_156) else caught-fail) in
        {468}let cs_24: cipherstate = (if v_157 then 1-proj-3-tuple(v_156) else caught-fail) in
        {469}let ssi_4: symmetricstate = (if v_155 then catch-fail((if v_157 then symmetricstatepack(cs_24,ck_30,hash(h_24,ciphertext_6)) else fail-any)) else caught-fail) in
        {470}let v_158: bool = not-caught-fail(ssi_4) in
        {471}let v_159: bitstring = (if v_145 then catch-fail((if v_146 then (if v_148 then (if v_155 then (if v_158 then (ssi_4,ciphertext_6) else fail-any) else fail-any) else fail-any) else fail-any)) else caught-fail) in
        {472}let v_160: bool = (not-caught-fail(v_159) && success?(1-proj-2-tuple(v_159))) in
        {473}let ns_3: bitstring = (if v_160 then 2-proj-2-tuple(v_159) else caught-fail) in
        {474}let ss_25: symmetricstate = (if v_160 then 1-proj-2-tuple(v_159) else caught-fail) in
        {475}let basis_9: key = (if v_160 then key_m(me_1) else caught-fail) in
        {476}let public_key_9: key = (if v_160 then catch-fail(dhexp(basis_9,validkey(g))) else caught-fail) in
        {477}let v_161: bool = not-caught-fail(public_key_9) in
        {478}let m_5: keypair = (if v_160 then catch-fail((if v_161 then keypairpack(validkey(public_key_9),basis_9) else fail-any)) else caught-fail) in
        {479}let v_162: bool = not-caught-fail(m_5) in
        {480}let plaintext_3: bitstring = (if v_162 then catch-fail(getpublickey(m_5)) else caught-fail) in
        {481}let v_163: bool = not-caught-fail(plaintext_3) in
        {482}let v_164: bitstring = (if v_163 then catch-fail(symmetricstateunpack(ss_25)) else caught-fail) in
        {483}let v_165: bool = (not-caught-fail(v_164) && success?(1-proj-3-tuple(v_164))) in
        {484}let h_25: bitstring = (if v_165 then 3-proj-3-tuple(v_164) else caught-fail) in
        {485}let ck_31: key = (if v_165 then 2-proj-3-tuple(v_164) else caught-fail) in
        {486}let cs_25: cipherstate = (if v_165 then 1-proj-3-tuple(v_164) else caught-fail) in
        {487}let v_166: bitstring = (if v_165 then catch-fail(cipherstateunpack(cs_25)) else caught-fail) in
        {488}let v_167: bool = (not-caught-fail(v_166) && success?(1-proj-2-tuple(v_166))) in
        {489}let n_8: nonce = (if v_167 then 2-proj-2-tuple(v_166) else caught-fail) in
        {490}let k_10: key = (if v_167 then 1-proj-2-tuple(v_166) else caught-fail) in
        {491}let e_10: bitstring = (if v_167 then encrypt(k_10,n_8,h_25,plaintext_3) else caught-fail) in
        {492}let n_9: nonce = (if v_167 then increment_nonce(n_8) else caught-fail) in
        {493}let v_168: bitstring = (if v_167 then catch-fail(cipherstateunpack(cs_25)) else caught-fail) in
        {494}let v_169: bool = (not-caught-fail(v_168) && success?(1-proj-2-tuple(v_168))) in
        {495}let o_4: nonce = (if v_169 then 2-proj-2-tuple(v_168) else caught-fail) in
        {496}let k_11: key = (if v_169 then 1-proj-2-tuple(v_168) else caught-fail) in
        {497}let csi_8: cipherstate = (if v_167 then catch-fail((if v_169 then cipherstatepack(k_11,n_9) else fail-any)) else caught-fail) in
        {498}let v_170: bool = not-caught-fail(csi_8) in
        {499}let v_171: bitstring = (if v_165 then catch-fail((if v_167 then (if v_170 then (csi_8,e_10) else fail-any) else fail-any)) else caught-fail) in
        {500}let v_172: bool = (not-caught-fail(v_171) && success?(1-proj-2-tuple(v_171))) in
        {501}let ciphertext_7: bitstring = (if v_172 then 2-proj-2-tuple(v_171) else caught-fail) in
        {502}let csi_9: cipherstate = (if v_172 then 1-proj-2-tuple(v_171) else caught-fail) in
        {503}let ss_26: symmetricstate = (if v_172 then symmetricstatepack(csi_9,ck_31,h_25) else caught-fail) in
        {504}let v_173: bitstring = (if v_172 then catch-fail(symmetricstateunpack(ss_26)) else caught-fail) in
        {505}let v_174: bool = (not-caught-fail(v_173) && success?(1-proj-3-tuple(v_173))) in
        {506}let h_26: bitstring = (if v_174 then 3-proj-3-tuple(v_173) else caught-fail) in
        {507}let ck_32: key = (if v_174 then 2-proj-3-tuple(v_173) else caught-fail) in
        {508}let cs_26: cipherstate = (if v_174 then 1-proj-3-tuple(v_173) else caught-fail) in
        {509}let ssi_5: symmetricstate = (if v_172 then catch-fail((if v_174 then symmetricstatepack(cs_26,ck_32,hash(h_26,ciphertext_7)) else fail-any)) else caught-fail) in
        {510}let v_175: bool = not-caught-fail(ssi_5) in
        {511}let v_176: bitstring = (if v_162 then catch-fail((if v_163 then (if v_165 then (if v_172 then (if v_175 then (ssi_5,ciphertext_7) else fail-any) else fail-any) else fail-any) else fail-any)) else caught-fail) in
        {512}let v_177: bool = (not-caught-fail(v_176) && success?(1-proj-2-tuple(v_176))) in
        {513}let nm_3: bitstring = (if v_177 then 2-proj-2-tuple(v_176) else caught-fail) in
        {514}let ss_27: symmetricstate = (if v_177 then 1-proj-2-tuple(v_176) else caught-fail) in
        {515}let v_178: bitstring = (if v_177 then catch-fail(keypairunpack(m_5)) else caught-fail) in
        {516}let v_179: bool = (not-caught-fail(v_178) && success?(1-proj-2-tuple(v_178))) in
        {517}let my_private_key_6: key = (if v_179 then 2-proj-2-tuple(v_178) else caught-fail) in
        {518}let my_public_key_6: key = (if v_179 then 1-proj-2-tuple(v_178) else caught-fail) in
        {519}let input_key_material_7: key = (if v_177 then catch-fail((if v_179 then dhexp(my_private_key_6,rs_3) else fail-any)) else caught-fail) in
        {520}let v_180: bool = not-caught-fail(input_key_material_7) in
        {521}let v_181: bitstring = (if v_180 then catch-fail(symmetricstateunpack(ss_27)) else caught-fail) in
        {522}let v_182: bool = (not-caught-fail(v_181) && success?(1-proj-3-tuple(v_181))) in
        {523}let h_27: bitstring = (if v_182 then 3-proj-3-tuple(v_181) else caught-fail) in
        {524}let ck_33: key = (if v_182 then 2-proj-3-tuple(v_181) else caught-fail) in
        {525}let cs_27: cipherstate = (if v_182 then 1-proj-3-tuple(v_181) else caught-fail) in
        {526}let output1_7: key = (if v_182 then hmac_hash1(ck_33,input_key_material_7) else caught-fail) in
        {527}let output2_7: key = (if v_182 then hmac_hash2(ck_33,input_key_material_7) else caught-fail) in
        {528}let output3_7: key = (if v_182 then hmac_hash3(ck_33,input_key_material_7) else caught-fail) in
        {529}let v_183: bitstring = (if v_182 then catch-fail((output1_7,output2_7,output3_7)) else caught-fail) in
        {530}let v_184: bool = (not-caught-fail(v_183) && success?(1-proj-3-tuple(v_183))) in
        {531}let output_6: key = (if v_184 then 3-proj-3-tuple(v_183) else caught-fail) in
        {532}let temp_k_6: key = (if v_184 then 2-proj-3-tuple(v_183) else caught-fail) in
        {533}let ck_34: key = (if v_184 then 1-proj-3-tuple(v_183) else caught-fail) in
        {534}let ss_28: symmetricstate = (if v_177 then catch-fail((if v_180 then (if v_182 then (if v_184 then symmetricstatepack(cipherstatepack(temp_k_6,minnonce),ck_34,h_27) else fail-any) else fail-any) else fail-any)) else caught-fail) in
        {535}let v_185: bool = not-caught-fail(ss_28) in
        {536}let v_186: bitstring = (if v_185 then catch-fail(keypairunpack(s_5)) else caught-fail) in
        {537}let v_187: bool = (not-caught-fail(v_186) && success?(1-proj-2-tuple(v_186))) in
        {538}let my_private_key_7: key = (if v_187 then 2-proj-2-tuple(v_186) else caught-fail) in
        {539}let my_public_key_7: key = (if v_187 then 1-proj-2-tuple(v_186) else caught-fail) in
        {540}let input_key_material_8: key = (if v_185 then catch-fail((if v_187 then dhexp(my_private_key_7,rm_3) else fail-any)) else caught-fail) in
        {541}let v_188: bool = not-caught-fail(input_key_material_8) in
        {542}let v_189: bitstring = (if v_188 then catch-fail(symmetricstateunpack(ss_28)) else caught-fail) in
        {543}let v_190: bool = (not-caught-fail(v_189) && success?(1-proj-3-tuple(v_189))) in
        {544}let h_28: bitstring = (if v_190 then 3-proj-3-tuple(v_189) else caught-fail) in
        {545}let ck_35: key = (if v_190 then 2-proj-3-tuple(v_189) else caught-fail) in
        {546}let cs_28: cipherstate = (if v_190 then 1-proj-3-tuple(v_189) else caught-fail) in
        {547}let output1_8: key = (if v_190 then hmac_hash1(ck_35,input_key_material_8) else caught-fail) in
        {548}let output2_8: key = (if v_190 then hmac_hash2(ck_35,input_key_material_8) else caught-fail) in
        {549}let output3_8: key = (if v_190 then hmac_hash3(ck_35,input_key_material_8) else caught-fail) in
        {550}let v_191: bitstring = (if v_190 then catch-fail((output1_8,output2_8,output3_8)) else caught-fail) in
        {551}let v_192: bool = (not-caught-fail(v_191) && success?(1-proj-3-tuple(v_191))) in
        {552}let output_7: key = (if v_192 then 3-proj-3-tuple(v_191) else caught-fail) in
        {553}let temp_k_7: key = (if v_192 then 2-proj-3-tuple(v_191) else caught-fail) in
        {554}let ck_36: key = (if v_192 then 1-proj-3-tuple(v_191) else caught-fail) in
        {555}let ss_29: symmetricstate = (if v_185 then catch-fail((if v_188 then (if v_190 then (if v_192 then symmetricstatepack(cipherstatepack(temp_k_7,minnonce),ck_36,h_28) else fail-any) else fail-any) else fail-any)) else caught-fail) in
        {556}let v_193: bool = not-caught-fail(ss_29) in
        {557}let v_194: bitstring = (if v_193 then catch-fail(symmetricstateunpack(ss_29)) else caught-fail) in
        {558}let v_195: bool = (not-caught-fail(v_194) && success?(1-proj-3-tuple(v_194))) in
        {559}let h_29: bitstring = (if v_195 then 3-proj-3-tuple(v_194) else caught-fail) in
        {560}let ck_37: key = (if v_195 then 2-proj-3-tuple(v_194) else caught-fail) in
        {561}let cs_29: cipherstate = (if v_195 then 1-proj-3-tuple(v_194) else caught-fail) in
        {562}let v_196: bitstring = (if v_195 then catch-fail(cipherstateunpack(cs_29)) else caught-fail) in
        {563}let v_197: bool = (not-caught-fail(v_196) && success?(1-proj-2-tuple(v_196))) in
        {564}let n_10: nonce = (if v_197 then 2-proj-2-tuple(v_196) else caught-fail) in
        {565}let k_12: key = (if v_197 then 1-proj-2-tuple(v_196) else caught-fail) in
        {566}let e_11: bitstring = (if v_197 then encrypt(k_12,n_10,h_29,payload_1) else caught-fail) in
        {567}let n_11: nonce = (if v_197 then increment_nonce(n_10) else caught-fail) in
        {568}let v_198: bitstring = (if v_197 then catch-fail(cipherstateunpack(cs_29)) else caught-fail) in
        {569}let v_199: bool = (not-caught-fail(v_198) && success?(1-proj-2-tuple(v_198))) in
        {570}let o_5: nonce = (if v_199 then 2-proj-2-tuple(v_198) else caught-fail) in
        {571}let k_13: key = (if v_199 then 1-proj-2-tuple(v_198) else caught-fail) in
        {572}let csi_10: cipherstate = (if v_197 then catch-fail((if v_199 then cipherstatepack(k_13,n_11) else fail-any)) else caught-fail) in
        {573}let v_200: bool = not-caught-fail(csi_10) in
        {574}let v_201: bitstring = (if v_195 then catch-fail((if v_197 then (if v_200 then (csi_10,e_11) else fail-any) else fail-any)) else caught-fail) in
        {575}let v_202: bool = (not-caught-fail(v_201) && success?(1-proj-2-tuple(v_201))) in
        {576}let ciphertext_8: bitstring = (if v_202 then 2-proj-2-tuple(v_201) else caught-fail) in
        {577}let csi_11: cipherstate = (if v_202 then 1-proj-2-tuple(v_201) else caught-fail) in
        {578}let ss_30: symmetricstate = (if v_202 then symmetricstatepack(csi_11,ck_37,h_29) else caught-fail) in
        {579}let v_203: bitstring = (if v_202 then catch-fail(symmetricstateunpack(ss_30)) else caught-fail) in
        {580}let v_204: bool = (not-caught-fail(v_203) && success?(1-proj-3-tuple(v_203))) in
        {581}let h_30: bitstring = (if v_204 then 3-proj-3-tuple(v_203) else caught-fail) in
        {582}let ck_38: key = (if v_204 then 2-proj-3-tuple(v_203) else caught-fail) in
        {583}let cs_30: cipherstate = (if v_204 then 1-proj-3-tuple(v_203) else caught-fail) in
        {584}let ssi_6: symmetricstate = (if v_202 then catch-fail((if v_204 then symmetricstatepack(cs_30,ck_38,hash(h_30,ciphertext_8)) else fail-any)) else caught-fail) in
        {585}let v_205: bool = not-caught-fail(ssi_6) in
        {586}let v_206: bitstring = (if v_193 then catch-fail((if v_195 then (if v_202 then (if v_205 then (ssi_6,ciphertext_8) else fail-any) else fail-any) else fail-any)) else caught-fail) in
        {587}let v_207: bool = (not-caught-fail(v_206) && success?(1-proj-2-tuple(v_206))) in
        {588}let ciphertext_9: bitstring = (if v_207 then 2-proj-2-tuple(v_206) else caught-fail) in
        {589}let ss_31: symmetricstate = (if v_207 then 1-proj-2-tuple(v_206) else caught-fail) in
        {590}let hs_6: handshakestate = (if v_207 then handshakestatepack(ss_31,s_5,m_5,e_8,rs_3,rm_3,re_3,psk_3,initiator_2) else caught-fail) in
        {591}let message_buffer_1: bitstring = (if v_207 then concat4(ne_3,ns_3,nm_3,ciphertext_9) else caught-fail) in
        {592}let v_208: bitstring = (if v_207 then catch-fail(symmetricstateunpack(ss_31)) else caught-fail) in
        {593}let v_209: bool = (not-caught-fail(v_208) && success?(1-proj-3-tuple(v_208))) in
        {594}let h_31: bitstring = (if v_209 then 3-proj-3-tuple(v_208) else caught-fail) in
        {595}let ck_39: key = (if v_209 then 2-proj-3-tuple(v_208) else caught-fail) in
        {596}let cs_31: cipherstate = (if v_209 then 1-proj-3-tuple(v_208) else caught-fail) in
        {597}let input_key_material_9: key = (if v_209 then zero else caught-fail) in
        {598}let output1_9: key = (if v_209 then hmac_hash1(ck_39,input_key_material_9) else caught-fail) in
        {599}let output2_9: key = (if v_209 then hmac_hash2(ck_39,input_key_material_9) else caught-fail) in
        {600}let output3_9: key = (if v_209 then hmac_hash3(ck_39,input_key_material_9) else caught-fail) in
        {601}let v_210: bitstring = (if v_209 then catch-fail((output1_9,output2_9,output3_9)) else caught-fail) in
        {602}let v_211: bool = (not-caught-fail(v_210) && success?(1-proj-3-tuple(v_210))) in
        {603}let temp_k3_1: key = (if v_211 then 3-proj-3-tuple(v_210) else caught-fail) in
        {604}let temp_k2_1: key = (if v_211 then 2-proj-3-tuple(v_210) else caught-fail) in
        {605}let temp_k1_1: key = (if v_211 then 1-proj-3-tuple(v_210) else caught-fail) in
        {606}let cs1_3: cipherstate = (if v_211 then cipherstatepack(temp_k1_1,minnonce) else caught-fail) in
        {607}let cs2_3: cipherstate = (if v_211 then cipherstatepack(temp_k2_1,minnonce) else caught-fail) in
        {608}let v_212: bitstring = (if v_207 then catch-fail((if v_209 then (if v_211 then (ss_31,cs1_3,cs2_3) else fail-any) else fail-any)) else caught-fail) in
        {609}let v_213: bool = (not-caught-fail(v_212) && success?(1-proj-3-tuple(v_212))) in
        {610}let cs2_4: cipherstate = (if v_213 then 3-proj-3-tuple(v_212) else caught-fail) in
        {611}let cs1_4: cipherstate = (if v_213 then 2-proj-3-tuple(v_212) else caught-fail) in
        {612}let ssi_7: symmetricstate = (if v_213 then 1-proj-3-tuple(v_212) else caught-fail) in
        {613}let (hs_7: handshakestate,message_a_1: bitstring,cs1_5: cipherstate,cs2_5: cipherstate) = (if v_119 then (if v_121 then (if v_123 then (if v_124 then (if v_127 then (if v_135 then (if v_143 then (if v_145 then (if v_160 then (if v_162 then (if v_177 then (if v_185 then (if v_193 then (if v_207 then (if v_213 then (hs_6,message_buffer_1,cs1_4,cs2_4) else fail-any) else fail-any) else fail-any) else fail-any) else fail-any) else fail-any) else fail-any) else fail-any) else fail-any) else fail-any) else fail-any) else fail-any) else fail-any) else fail-any) else fail-any) in
        {614}event SendMsg(me_1,them_1,stagepack_a(sid_2),msg_a(me_1,them_1,sid_2));
        {615}out(pub, message_a_1)
    ) | (
        {617}event LeakS(phase0,me_1);
        {618}event LeakM(phase0,me_1);
        {619}out(pub, (key_s(me_1),key_m(me_1)))
    ) | (
        {620}phase 1;
        {621}event LeakS(phase1,me_1);
        {622}event LeakM(phase1,me_1);
        {623}out(pub, (key_s(me_1),key_m(me_1)))
    )
) | (
    {624}let me_2: principal = bob in
    {625}let them_2: principal = alice in
    {626}let sid_3: sessionid = sid in
    {627}let basis_10: key = key_s(me_2) in
    {628}let public_key_10: key = catch-fail(dhexp(basis_10,validkey(g))) in
    {629}let v_214: bool = not-caught-fail(public_key_10) in
    {630}let s_6: keypair = (if v_214 then keypairpack(validkey(public_key_10),basis_10) else fail-any) in
    {631}let basis_11: key = key_m(me_2) in
    {632}let public_key_11: key = catch-fail(dhexp(basis_11,validkey(g))) in
    {633}let v_215: bool = not-caught-fail(public_key_11) in
    {634}let m_6: keypair = (if v_215 then keypairpack(validkey(public_key_11),basis_11) else fail-any) in
    {635}out(pub, (getpublickey(s_6),getpublickey(m_6)));
    (
        {636}let e_12: keypair = keypairpack(empty,empty) in
        {637}let rs_4: key = empty in
        {638}let rm_4: key = empty in
        {639}let re_4: key = empty in
        {640}let prologue_2: bitstring = empty in
        {641}let psk_4: key = empty in
        {642}let protocol_name_2: bitstring = somename in
        {643}let h_32: bitstring = hash(protocol_name_2,empty) in
        {644}let ck_40: key = h_32 in
        {645}let k_14: key = empty in
        {646}let cs_32: cipherstate = cipherstatepack(k_14,minnonce) in
        {647}let ss_32: symmetricstate = symmetricstatepack(cs_32,ck_40,h_32) in
        {648}let v_216: bitstring = catch-fail(symmetricstateunpack(ss_32)) in
        {649}let v_217: bool = (not-caught-fail(v_216) && success?(1-proj-3-tuple(v_216))) in
        {650}let h_33: bitstring = (if v_217 then 3-proj-3-tuple(v_216) else caught-fail) in
        {651}let ck_41: key = (if v_217 then 2-proj-3-tuple(v_216) else caught-fail) in
        {652}let cs_33: cipherstate = (if v_217 then 1-proj-3-tuple(v_216) else caught-fail) in
        {653}let ss_33: symmetricstate = catch-fail((if v_217 then symmetricstatepack(cs_33,ck_41,hash(h_33,prologue_2)) else fail-any)) in
        {654}let v_218: bool = not-caught-fail(ss_33) in
        {655}let data: bitstring = (if v_218 then catch-fail(getpublickey(s_6)) else caught-fail) in
        {656}let v_219: bool = not-caught-fail(data) in
        {657}let v_220: bitstring = (if v_219 then catch-fail(symmetricstateunpack(ss_33)) else caught-fail) in
        {658}let v_221: bool = (not-caught-fail(v_220) && success?(1-proj-3-tuple(v_220))) in
        {659}let h_34: bitstring = (if v_221 then 3-proj-3-tuple(v_220) else caught-fail) in
        {660}let ck_42: key = (if v_221 then 2-proj-3-tuple(v_220) else caught-fail) in
        {661}let cs_34: cipherstate = (if v_221 then 1-proj-3-tuple(v_220) else caught-fail) in
        {662}let ss_34: symmetricstate = (if v_218 then catch-fail((if v_219 then (if v_221 then symmetricstatepack(cs_34,ck_42,hash(h_34,data)) else fail-any) else fail-any)) else caught-fail) in
        {663}let v_222: bool = not-caught-fail(ss_34) in
        {664}let data_1: bitstring = (if v_222 then catch-fail(getpublickey(m_6)) else caught-fail) in
        {665}let v_223: bool = not-caught-fail(data_1) in
        {666}let v_224: bitstring = (if v_223 then catch-fail(symmetricstateunpack(ss_34)) else caught-fail) in
        {667}let v_225: bool = (not-caught-fail(v_224) && success?(1-proj-3-tuple(v_224))) in
        {668}let h_35: bitstring = (if v_225 then 3-proj-3-tuple(v_224) else caught-fail) in
        {669}let ck_43: key = (if v_225 then 2-proj-3-tuple(v_224) else caught-fail) in
        {670}let cs_35: cipherstate = (if v_225 then 1-proj-3-tuple(v_224) else caught-fail) in
        {671}let ss_35: symmetricstate = (if v_222 then catch-fail((if v_223 then (if v_225 then symmetricstatepack(cs_35,ck_43,hash(h_35,data_1)) else fail-any) else fail-any)) else caught-fail) in
        {672}let v_226: bool = not-caught-fail(ss_35) in
        {673}let hs_8: handshakestate = (if v_218 then (if v_222 then (if v_226 then handshakestatepack(ss_35,s_6,m_6,e_12,rs_4,rm_4,re_4,psk_4,false) else fail-any) else fail-any) else fail-any) in
        {674}insert statestore(me_2,them_2,sid_3,statepack_a(hs_8))
    ) | (
        {944}get statestore(=me_2,=them_2,=sid_3,statepack_a(hs_9: handshakestate)) in
        {675}in(pub, message_a_2: bitstring);
        {676}let v_227: bitstring = catch-fail(handshakestateunpack(hs_9)) in
        {677}let v_228: bool = (not-caught-fail(v_227) && success?(1-proj-9-tuple(v_227))) in
        {678}let initiator_3: bool = (if v_228 then 9-proj-9-tuple(v_227) else caught-fail) in
        {679}let psk_5: key = (if v_228 then 8-proj-9-tuple(v_227) else caught-fail) in
        {680}let re_5: key = (if v_228 then 7-proj-9-tuple(v_227) else caught-fail) in
        {681}let rm_5: key = (if v_228 then 6-proj-9-tuple(v_227) else caught-fail) in
        {682}let rs_5: key = (if v_228 then 5-proj-9-tuple(v_227) else caught-fail) in
        {683}let e_13: keypair = (if v_228 then 4-proj-9-tuple(v_227) else caught-fail) in
        {684}let m_7: keypair = (if v_228 then 3-proj-9-tuple(v_227) else caught-fail) in
        {685}let s_7: keypair = (if v_228 then 2-proj-9-tuple(v_227) else caught-fail) in
        {686}let ss_36: symmetricstate = (if v_228 then 1-proj-9-tuple(v_227) else caught-fail) in
        {687}let v_229: bitstring = (if v_228 then catch-fail(deconcat4(message_a_2)) else caught-fail) in
        {688}let v_230: bool = (not-caught-fail(v_229) && success?(1-proj-4-tuple(v_229))) in
        {689}let ciphertext_10: bitstring = (if v_230 then 4-proj-4-tuple(v_229) else caught-fail) in
        {690}let nm_4: bitstring = (if v_230 then 3-proj-4-tuple(v_229) else caught-fail) in
        {691}let ns_4: bitstring = (if v_230 then 2-proj-4-tuple(v_229) else caught-fail) in
        {692}let ne_4: bitstring = (if v_230 then 1-proj-4-tuple(v_229) else caught-fail) in
        {693}let valid1: bool = (if v_230 then true else caught-fail) in
        {694}let valid2: bool = (if v_230 then true else caught-fail) in
        {695}let re_6: key = (if v_230 then ne_4 else caught-fail) in
        {696}let v_231: bitstring = (if v_230 then catch-fail(symmetricstateunpack(ss_36)) else caught-fail) in
        {697}let v_232: bool = (not-caught-fail(v_231) && success?(1-proj-3-tuple(v_231))) in
        {698}let h_36: bitstring = (if v_232 then 3-proj-3-tuple(v_231) else caught-fail) in
        {699}let ck_44: key = (if v_232 then 2-proj-3-tuple(v_231) else caught-fail) in
        {700}let cs_36: cipherstate = (if v_232 then 1-proj-3-tuple(v_231) else caught-fail) in
        {701}let ss_37: symmetricstate = (if v_230 then catch-fail((if v_232 then symmetricstatepack(cs_36,ck_44,hash(h_36,re_6)) else fail-any)) else caught-fail) in
        {702}let v_233: bool = not-caught-fail(ss_37) in
        {703}let v_234: bitstring = (if v_233 then catch-fail(keypairunpack(s_7)) else caught-fail) in
        {704}let v_235: bool = (not-caught-fail(v_234) && success?(1-proj-2-tuple(v_234))) in
        {705}let my_private_key_8: key = (if v_235 then 2-proj-2-tuple(v_234) else caught-fail) in
        {706}let my_public_key_8: key = (if v_235 then 1-proj-2-tuple(v_234) else caught-fail) in
        {707}let input_key_material_10: key = (if v_233 then catch-fail((if v_235 then dhexp(my_private_key_8,re_6) else fail-any)) else caught-fail) in
        {708}let v_236: bool = not-caught-fail(input_key_material_10) in
        {709}let v_237: bitstring = (if v_236 then catch-fail(symmetricstateunpack(ss_37)) else caught-fail) in
        {710}let v_238: bool = (not-caught-fail(v_237) && success?(1-proj-3-tuple(v_237))) in
        {711}let h_37: bitstring = (if v_238 then 3-proj-3-tuple(v_237) else caught-fail) in
        {712}let ck_45: key = (if v_238 then 2-proj-3-tuple(v_237) else caught-fail) in
        {713}let cs_37: cipherstate = (if v_238 then 1-proj-3-tuple(v_237) else caught-fail) in
        {714}let output1_10: key = (if v_238 then hmac_hash1(ck_45,input_key_material_10) else caught-fail) in
        {715}let output2_10: key = (if v_238 then hmac_hash2(ck_45,input_key_material_10) else caught-fail) in
        {716}let output3_10: key = (if v_238 then hmac_hash3(ck_45,input_key_material_10) else caught-fail) in
        {717}let v_239: bitstring = (if v_238 then catch-fail((output1_10,output2_10,output3_10)) else caught-fail) in
        {718}let v_240: bool = (not-caught-fail(v_239) && success?(1-proj-3-tuple(v_239))) in
        {719}let output_8: key = (if v_240 then 3-proj-3-tuple(v_239) else caught-fail) in
        {720}let temp_k_8: key = (if v_240 then 2-proj-3-tuple(v_239) else caught-fail) in
        {721}let ck_46: key = (if v_240 then 1-proj-3-tuple(v_239) else caught-fail) in
        {722}let ss_38: symmetricstate = (if v_233 then catch-fail((if v_236 then (if v_238 then (if v_240 then symmetricstatepack(cipherstatepack(temp_k_8,minnonce),ck_46,h_37) else fail-any) else fail-any) else fail-any)) else caught-fail) in
        {723}let v_241: bool = not-caught-fail(ss_38) in
        {724}let v_242: bitstring = (if v_241 then catch-fail(keypairunpack(m_7)) else caught-fail) in
        {725}let v_243: bool = (not-caught-fail(v_242) && success?(1-proj-2-tuple(v_242))) in
        {726}let my_private_key_9: key = (if v_243 then 2-proj-2-tuple(v_242) else caught-fail) in
        {727}let my_public_key_9: key = (if v_243 then 1-proj-2-tuple(v_242) else caught-fail) in
        {728}let input_key_material_11: key = (if v_241 then catch-fail((if v_243 then dhexp(my_private_key_9,re_6) else fail-any)) else caught-fail) in
        {729}let v_244: bool = not-caught-fail(input_key_material_11) in
        {730}let v_245: bitstring = (if v_244 then catch-fail(symmetricstateunpack(ss_38)) else caught-fail) in
        {731}let v_246: bool = (not-caught-fail(v_245) && success?(1-proj-3-tuple(v_245))) in
        {732}let h_38: bitstring = (if v_246 then 3-proj-3-tuple(v_245) else caught-fail) in
        {733}let ck_47: key = (if v_246 then 2-proj-3-tuple(v_245) else caught-fail) in
        {734}let cs_38: cipherstate = (if v_246 then 1-proj-3-tuple(v_245) else caught-fail) in
        {735}let output1_11: key = (if v_246 then hmac_hash1(ck_47,input_key_material_11) else caught-fail) in
        {736}let output2_11: key = (if v_246 then hmac_hash2(ck_47,input_key_material_11) else caught-fail) in
        {737}let output3_11: key = (if v_246 then hmac_hash3(ck_47,input_key_material_11) else caught-fail) in
        {738}let v_247: bitstring = (if v_246 then catch-fail((output1_11,output2_11,output3_11)) else caught-fail) in
        {739}let v_248: bool = (not-caught-fail(v_247) && success?(1-proj-3-tuple(v_247))) in
        {740}let output_9: key = (if v_248 then 3-proj-3-tuple(v_247) else caught-fail) in
        {741}let temp_k_9: key = (if v_248 then 2-proj-3-tuple(v_247) else caught-fail) in
        {742}let ck_48: key = (if v_248 then 1-proj-3-tuple(v_247) else caught-fail) in
        {743}let ss_39: symmetricstate = (if v_241 then catch-fail((if v_244 then (if v_246 then (if v_248 then symmetricstatepack(cipherstatepack(temp_k_9,minnonce),ck_48,h_38) else fail-any) else fail-any) else fail-any)) else caught-fail) in
        {744}let v_249: bool = not-caught-fail(ss_39) in
        {745}let v_250: bitstring = (if v_249 then catch-fail(symmetricstateunpack(ss_39)) else caught-fail) in
        {746}let v_251: bool = (not-caught-fail(v_250) && success?(1-proj-3-tuple(v_250))) in
        {747}let h_39: bitstring = (if v_251 then 3-proj-3-tuple(v_250) else caught-fail) in
        {748}let ck_49: key = (if v_251 then 2-proj-3-tuple(v_250) else caught-fail) in
        {749}let cs_39: cipherstate = (if v_251 then 1-proj-3-tuple(v_250) else caught-fail) in
        {750}let v_252: bitstring = (if v_251 then catch-fail(cipherstateunpack(cs_39)) else caught-fail) in
        {751}let v_253: bool = (not-caught-fail(v_252) && success?(1-proj-2-tuple(v_252))) in
        {752}let n_12: nonce = (if v_253 then 2-proj-2-tuple(v_252) else caught-fail) in
        {753}let k_15: key = (if v_253 then 1-proj-2-tuple(v_252) else caught-fail) in
        {754}let d: aead = (if v_253 then catch-fail(decrypt(k_15,n_12,h_39,ns_4)) else caught-fail) in
        {755}let v_254: bool = not-caught-fail(d) in
        {756}let v_255: bitstring = (if v_254 then catch-fail(aeadunpack(d)) else caught-fail) in
        {757}let v_256: bool = (not-caught-fail(v_255) && success?(1-proj-3-tuple(v_255))) in
        {758}let plaintext_4: bitstring = (if v_256 then 3-proj-3-tuple(v_255) else caught-fail) in
        {759}let adi: bitstring = (if v_256 then 2-proj-3-tuple(v_255) else caught-fail) in
        {760}let valid: bool = (if v_256 then 1-proj-3-tuple(v_255) else caught-fail) in
        {761}let n_13: nonce = (if v_256 then increment_nonce(n_12) else caught-fail) in
        {762}let v_257: bitstring = (if v_256 then catch-fail(cipherstateunpack(cs_39)) else caught-fail) in
        {763}let v_258: bool = (not-caught-fail(v_257) && success?(1-proj-2-tuple(v_257))) in
        {764}let o_6: nonce = (if v_258 then 2-proj-2-tuple(v_257) else caught-fail) in
        {765}let k_16: key = (if v_258 then 1-proj-2-tuple(v_257) else caught-fail) in
        {766}let csi_12: cipherstate = (if v_256 then catch-fail((if v_258 then cipherstatepack(k_16,n_13) else fail-any)) else caught-fail) in
        {767}let v_259: bool = not-caught-fail(csi_12) in
        {768}let v_260: bitstring = (if v_251 then catch-fail((if v_253 then (if v_254 then (if v_256 then (if v_259 then (csi_12,plaintext_4,valid) else fail-any) else fail-any) else fail-any) else fail-any)) else caught-fail) in
        {769}let v_261: bool = (not-caught-fail(v_260) && success?(1-proj-3-tuple(v_260))) in
        {770}let valid_1: bool = (if v_261 then 3-proj-3-tuple(v_260) else caught-fail) in
        {771}let plaintext_5: bitstring = (if v_261 then 2-proj-3-tuple(v_260) else caught-fail) in
        {772}let csi_13: cipherstate = (if v_261 then 1-proj-3-tuple(v_260) else caught-fail) in
        {773}let ss_40: symmetricstate = (if v_261 then symmetricstatepack(csi_13,ck_49,h_39) else caught-fail) in
        {774}let v_262: bitstring = (if v_261 then catch-fail(symmetricstateunpack(ss_40)) else caught-fail) in
        {775}let v_263: bool = (not-caught-fail(v_262) && success?(1-proj-3-tuple(v_262))) in
        {776}let h_40: bitstring = (if v_263 then 3-proj-3-tuple(v_262) else caught-fail) in
        {777}let ck_50: key = (if v_263 then 2-proj-3-tuple(v_262) else caught-fail) in
        {778}let cs_40: cipherstate = (if v_263 then 1-proj-3-tuple(v_262) else caught-fail) in
        {779}let ssi_8: symmetricstate = (if v_261 then catch-fail((if v_263 then symmetricstatepack(cs_40,ck_50,hash(h_40,ns_4)) else fail-any)) else caught-fail) in
        {780}let v_264: bool = not-caught-fail(ssi_8) in
        {781}let v_265: bitstring = (if v_249 then catch-fail((if v_251 then (if v_261 then (if v_264 then (ssi_8,plaintext_5,valid_1) else fail-any) else fail-any) else fail-any)) else caught-fail) in
        {782}let v_266: bool = (not-caught-fail(v_265) && success?(1-proj-3-tuple(v_265))) in
        {783}let valid1_1: bool = (if v_266 then 3-proj-3-tuple(v_265) else caught-fail) in
        {784}let se: bitstring = (if v_266 then 2-proj-3-tuple(v_265) else caught-fail) in
        {785}let ss_41: symmetricstate = (if v_266 then 1-proj-3-tuple(v_265) else caught-fail) in
        {786}let rs_6: key = (if v_266 then se else caught-fail) in
        {787}let v_267: bitstring = (if v_266 then catch-fail(symmetricstateunpack(ss_41)) else caught-fail) in
        {788}let v_268: bool = (not-caught-fail(v_267) && success?(1-proj-3-tuple(v_267))) in
        {789}let h_41: bitstring = (if v_268 then 3-proj-3-tuple(v_267) else caught-fail) in
        {790}let ck_51: key = (if v_268 then 2-proj-3-tuple(v_267) else caught-fail) in
        {791}let cs_41: cipherstate = (if v_268 then 1-proj-3-tuple(v_267) else caught-fail) in
        {792}let v_269: bitstring = (if v_268 then catch-fail(cipherstateunpack(cs_41)) else caught-fail) in
        {793}let v_270: bool = (not-caught-fail(v_269) && success?(1-proj-2-tuple(v_269))) in
        {794}let n_14: nonce = (if v_270 then 2-proj-2-tuple(v_269) else caught-fail) in
        {795}let k_17: key = (if v_270 then 1-proj-2-tuple(v_269) else caught-fail) in
        {796}let d_1: aead = (if v_270 then catch-fail(decrypt(k_17,n_14,h_41,nm_4)) else caught-fail) in
        {797}let v_271: bool = not-caught-fail(d_1) in
        {798}let v_272: bitstring = (if v_271 then catch-fail(aeadunpack(d_1)) else caught-fail) in
        {799}let v_273: bool = (not-caught-fail(v_272) && success?(1-proj-3-tuple(v_272))) in
        {800}let plaintext_6: bitstring = (if v_273 then 3-proj-3-tuple(v_272) else caught-fail) in
        {801}let adi_1: bitstring = (if v_273 then 2-proj-3-tuple(v_272) else caught-fail) in
        {802}let valid_2: bool = (if v_273 then 1-proj-3-tuple(v_272) else caught-fail) in
        {803}let n_15: nonce = (if v_273 then increment_nonce(n_14) else caught-fail) in
        {804}let v_274: bitstring = (if v_273 then catch-fail(cipherstateunpack(cs_41)) else caught-fail) in
        {805}let v_275: bool = (not-caught-fail(v_274) && success?(1-proj-2-tuple(v_274))) in
        {806}let o_7: nonce = (if v_275 then 2-proj-2-tuple(v_274) else caught-fail) in
        {807}let k_18: key = (if v_275 then 1-proj-2-tuple(v_274) else caught-fail) in
        {808}let csi_14: cipherstate = (if v_273 then catch-fail((if v_275 then cipherstatepack(k_18,n_15) else fail-any)) else caught-fail) in
        {809}let v_276: bool = not-caught-fail(csi_14) in
        {810}let v_277: bitstring = (if v_268 then catch-fail((if v_270 then (if v_271 then (if v_273 then (if v_276 then (csi_14,plaintext_6,valid_2) else fail-any) else fail-any) else fail-any) else fail-any)) else caught-fail) in
        {811}let v_278: bool = (not-caught-fail(v_277) && success?(1-proj-3-tuple(v_277))) in
        {812}let valid_3: bool = (if v_278 then 3-proj-3-tuple(v_277) else caught-fail) in
        {813}let plaintext_7: bitstring = (if v_278 then 2-proj-3-tuple(v_277) else caught-fail) in
        {814}let csi_15: cipherstate = (if v_278 then 1-proj-3-tuple(v_277) else caught-fail) in
        {815}let ss_42: symmetricstate = (if v_278 then symmetricstatepack(csi_15,ck_51,h_41) else caught-fail) in
        {816}let v_279: bitstring = (if v_278 then catch-fail(symmetricstateunpack(ss_42)) else caught-fail) in
        {817}let v_280: bool = (not-caught-fail(v_279) && success?(1-proj-3-tuple(v_279))) in
        {818}let h_42: bitstring = (if v_280 then 3-proj-3-tuple(v_279) else caught-fail) in
        {819}let ck_52: key = (if v_280 then 2-proj-3-tuple(v_279) else caught-fail) in
        {820}let cs_42: cipherstate = (if v_280 then 1-proj-3-tuple(v_279) else caught-fail) in
        {821}let ssi_9: symmetricstate = (if v_278 then catch-fail((if v_280 then symmetricstatepack(cs_42,ck_52,hash(h_42,nm_4)) else fail-any)) else caught-fail) in
        {822}let v_281: bool = not-caught-fail(ssi_9) in
        {823}let v_282: bitstring = (if v_266 then catch-fail((if v_268 then (if v_278 then (if v_281 then (ssi_9,plaintext_7,valid_3) else fail-any) else fail-any) else fail-any)) else caught-fail) in
        {824}let v_283: bool = (not-caught-fail(v_282) && success?(1-proj-3-tuple(v_282))) in
        {825}let valid2_1: bool = (if v_283 then 3-proj-3-tuple(v_282) else caught-fail) in
        {826}let me_3: bitstring = (if v_283 then 2-proj-3-tuple(v_282) else caught-fail) in
        {827}let ss_43: symmetricstate = (if v_283 then 1-proj-3-tuple(v_282) else caught-fail) in
        {828}let rm_6: key = (if v_283 then me_3 else caught-fail) in
        {829}let v_284: bitstring = (if v_283 then catch-fail(keypairunpack(s_7)) else caught-fail) in
        {830}let v_285: bool = (not-caught-fail(v_284) && success?(1-proj-2-tuple(v_284))) in
        {831}let my_private_key_10: key = (if v_285 then 2-proj-2-tuple(v_284) else caught-fail) in
        {832}let my_public_key_10: key = (if v_285 then 1-proj-2-tuple(v_284) else caught-fail) in
        {833}let input_key_material_12: key = (if v_283 then catch-fail((if v_285 then dhexp(my_private_key_10,rm_6) else fail-any)) else caught-fail) in
        {834}let v_286: bool = not-caught-fail(input_key_material_12) in
        {835}let v_287: bitstring = (if v_286 then catch-fail(symmetricstateunpack(ss_43)) else caught-fail) in
        {836}let v_288: bool = (not-caught-fail(v_287) && success?(1-proj-3-tuple(v_287))) in
        {837}let h_43: bitstring = (if v_288 then 3-proj-3-tuple(v_287) else caught-fail) in
        {838}let ck_53: key = (if v_288 then 2-proj-3-tuple(v_287) else caught-fail) in
        {839}let cs_43: cipherstate = (if v_288 then 1-proj-3-tuple(v_287) else caught-fail) in
        {840}let output1_12: key = (if v_288 then hmac_hash1(ck_53,input_key_material_12) else caught-fail) in
        {841}let output2_12: key = (if v_288 then hmac_hash2(ck_53,input_key_material_12) else caught-fail) in
        {842}let output3_12: key = (if v_288 then hmac_hash3(ck_53,input_key_material_12) else caught-fail) in
        {843}let v_289: bitstring = (if v_288 then catch-fail((output1_12,output2_12,output3_12)) else caught-fail) in
        {844}let v_290: bool = (not-caught-fail(v_289) && success?(1-proj-3-tuple(v_289))) in
        {845}let output_10: key = (if v_290 then 3-proj-3-tuple(v_289) else caught-fail) in
        {846}let temp_k_10: key = (if v_290 then 2-proj-3-tuple(v_289) else caught-fail) in
        {847}let ck_54: key = (if v_290 then 1-proj-3-tuple(v_289) else caught-fail) in
        {848}let ss_44: symmetricstate = (if v_283 then catch-fail((if v_286 then (if v_288 then (if v_290 then symmetricstatepack(cipherstatepack(temp_k_10,minnonce),ck_54,h_43) else fail-any) else fail-any) else fail-any)) else caught-fail) in
        {849}let v_291: bool = not-caught-fail(ss_44) in
        {850}let v_292: bitstring = (if v_291 then catch-fail(keypairunpack(m_7)) else caught-fail) in
        {851}let v_293: bool = (not-caught-fail(v_292) && success?(1-proj-2-tuple(v_292))) in
        {852}let my_private_key_11: key = (if v_293 then 2-proj-2-tuple(v_292) else caught-fail) in
        {853}let my_public_key_11: key = (if v_293 then 1-proj-2-tuple(v_292) else caught-fail) in
        {854}let input_key_material_13: key = (if v_291 then catch-fail((if v_293 then dhexp(my_private_key_11,rs_6) else fail-any)) else caught-fail) in
        {855}let v_294: bool = not-caught-fail(input_key_material_13) in
        {856}let v_295: bitstring = (if v_294 then catch-fail(symmetricstateunpack(ss_44)) else caught-fail) in
        {857}let v_296: bool = (not-caught-fail(v_295) && success?(1-proj-3-tuple(v_295))) in
        {858}let h_44: bitstring = (if v_296 then 3-proj-3-tuple(v_295) else caught-fail) in
        {859}let ck_55: key = (if v_296 then 2-proj-3-tuple(v_295) else caught-fail) in
        {860}let cs_44: cipherstate = (if v_296 then 1-proj-3-tuple(v_295) else caught-fail) in
        {861}let output1_13: key = (if v_296 then hmac_hash1(ck_55,input_key_material_13) else caught-fail) in
        {862}let output2_13: key = (if v_296 then hmac_hash2(ck_55,input_key_material_13) else caught-fail) in
        {863}let output3_13: key = (if v_296 then hmac_hash3(ck_55,input_key_material_13) else caught-fail) in
        {864}let v_297: bitstring = (if v_296 then catch-fail((output1_13,output2_13,output3_13)) else caught-fail) in
        {865}let v_298: bool = (not-caught-fail(v_297) && success?(1-proj-3-tuple(v_297))) in
        {866}let output_11: key = (if v_298 then 3-proj-3-tuple(v_297) else caught-fail) in
        {867}let temp_k_11: key = (if v_298 then 2-proj-3-tuple(v_297) else caught-fail) in
        {868}let ck_56: key = (if v_298 then 1-proj-3-tuple(v_297) else caught-fail) in
        {869}let ss_45: symmetricstate = (if v_291 then catch-fail((if v_294 then (if v_296 then (if v_298 then symmetricstatepack(cipherstatepack(temp_k_11,minnonce),ck_56,h_44) else fail-any) else fail-any) else fail-any)) else caught-fail) in
        {870}let v_299: bool = not-caught-fail(ss_45) in
        {871}let v_300: bitstring = (if v_299 then catch-fail(symmetricstateunpack(ss_45)) else caught-fail) in
        {872}let v_301: bool = (not-caught-fail(v_300) && success?(1-proj-3-tuple(v_300))) in
        {873}let h_45: bitstring = (if v_301 then 3-proj-3-tuple(v_300) else caught-fail) in
        {874}let ck_57: key = (if v_301 then 2-proj-3-tuple(v_300) else caught-fail) in
        {875}let cs_45: cipherstate = (if v_301 then 1-proj-3-tuple(v_300) else caught-fail) in
        {876}let v_302: bitstring = (if v_301 then catch-fail(cipherstateunpack(cs_45)) else caught-fail) in
        {877}let v_303: bool = (not-caught-fail(v_302) && success?(1-proj-2-tuple(v_302))) in
        {878}let n_16: nonce = (if v_303 then 2-proj-2-tuple(v_302) else caught-fail) in
        {879}let k_19: key = (if v_303 then 1-proj-2-tuple(v_302) else caught-fail) in
        {880}let d_2: aead = (if v_303 then catch-fail(decrypt(k_19,n_16,h_45,ciphertext_10)) else caught-fail) in
        {881}let v_304: bool = not-caught-fail(d_2) in
        {882}let v_305: bitstring = (if v_304 then catch-fail(aeadunpack(d_2)) else caught-fail) in
        {883}let v_306: bool = (not-caught-fail(v_305) && success?(1-proj-3-tuple(v_305))) in
        {884}let plaintext_8: bitstring = (if v_306 then 3-proj-3-tuple(v_305) else caught-fail) in
        {885}let adi_2: bitstring = (if v_306 then 2-proj-3-tuple(v_305) else caught-fail) in
        {886}let valid_4: bool = (if v_306 then 1-proj-3-tuple(v_305) else caught-fail) in
        {887}let n_17: nonce = (if v_306 then increment_nonce(n_16) else caught-fail) in
        {888}let v_307: bitstring = (if v_306 then catch-fail(cipherstateunpack(cs_45)) else caught-fail) in
        {889}let v_308: bool = (not-caught-fail(v_307) && success?(1-proj-2-tuple(v_307))) in
        {890}let o_8: nonce = (if v_308 then 2-proj-2-tuple(v_307) else caught-fail) in
        {891}let k_20: key = (if v_308 then 1-proj-2-tuple(v_307) else caught-fail) in
        {892}let csi_16: cipherstate = (if v_306 then catch-fail((if v_308 then cipherstatepack(k_20,n_17) else fail-any)) else caught-fail) in
        {893}let v_309: bool = not-caught-fail(csi_16) in
        {894}let v_310: bitstring = (if v_301 then catch-fail((if v_303 then (if v_304 then (if v_306 then (if v_309 then (csi_16,plaintext_8,valid_4) else fail-any) else fail-any) else fail-any) else fail-any)) else caught-fail) in
        {895}let v_311: bool = (not-caught-fail(v_310) && success?(1-proj-3-tuple(v_310))) in
        {896}let valid_5: bool = (if v_311 then 3-proj-3-tuple(v_310) else caught-fail) in
        {897}let plaintext_9: bitstring = (if v_311 then 2-proj-3-tuple(v_310) else caught-fail) in
        {898}let csi_17: cipherstate = (if v_311 then 1-proj-3-tuple(v_310) else caught-fail) in
        {899}let ss_46: symmetricstate = (if v_311 then symmetricstatepack(csi_17,ck_57,h_45) else caught-fail) in
        {900}let v_312: bitstring = (if v_311 then catch-fail(symmetricstateunpack(ss_46)) else caught-fail) in
        {901}let v_313: bool = (not-caught-fail(v_312) && success?(1-proj-3-tuple(v_312))) in
        {902}let h_46: bitstring = (if v_313 then 3-proj-3-tuple(v_312) else caught-fail) in
        {903}let ck_58: key = (if v_313 then 2-proj-3-tuple(v_312) else caught-fail) in
        {904}let cs_46: cipherstate = (if v_313 then 1-proj-3-tuple(v_312) else caught-fail) in
        {905}let ssi_10: symmetricstate = (if v_311 then catch-fail((if v_313 then symmetricstatepack(cs_46,ck_58,hash(h_46,ciphertext_10)) else fail-any)) else caught-fail) in
        {906}let v_314: bool = not-caught-fail(ssi_10) in
        {907}let v_315: bitstring = (if v_299 then catch-fail((if v_301 then (if v_311 then (if v_314 then (ssi_10,plaintext_9,valid_5) else fail-any) else fail-any) else fail-any)) else caught-fail) in
        {908}let v_316: bool = (not-caught-fail(v_315) && success?(1-proj-3-tuple(v_315))) in
        {909}let valid3: bool = (if v_316 then 3-proj-3-tuple(v_315) else caught-fail) in
        {910}let plaintext_10: bitstring = (if v_316 then 2-proj-3-tuple(v_315) else caught-fail) in
        {911}let ss_47: symmetricstate = (if v_316 then 1-proj-3-tuple(v_315) else caught-fail) in
        {912}let basis_12: key = (if v_316 then key_s(them_2) else caught-fail) in
        {913}let public_key_12: key = (if v_316 then catch-fail(dhexp(basis_12,validkey(g))) else caught-fail) in
        {914}let v_317: bool = not-caught-fail(public_key_12) in
        {915}let basis_13: key = (if v_316 then key_m(them_2) else caught-fail) in
        {916}let public_key_13: key = (if v_316 then catch-fail(dhexp(basis_13,validkey(g))) else caught-fail) in
        {917}let v_318: bool = not-caught-fail(public_key_13) in
        {918}let v_319: bool = (if v_316 then catch-fail(((valid1_1 && (valid2_1 && valid3)) && ((rs_6 = getpublickey((if v_317 then keypairpack(validkey(public_key_12),basis_12) else fail-any))) && (rm_6 = getpublickey((if v_318 then keypairpack(validkey(public_key_13),basis_13) else fail-any)))))) else caught-fail) in
        {919}let hs_10: handshakestate = (if v_319 then handshakestatepack(ss_47,s_7,m_7,e_13,rs_6,rm_6,re_6,psk_5,initiator_3) else caught-fail) in
        {920}let v_320: bitstring = (if v_319 then catch-fail(symmetricstateunpack(ss_47)) else caught-fail) in
        {921}let v_321: bool = (not-caught-fail(v_320) && success?(1-proj-3-tuple(v_320))) in
        {922}let h_47: bitstring = (if v_321 then 3-proj-3-tuple(v_320) else caught-fail) in
        {923}let ck_59: key = (if v_321 then 2-proj-3-tuple(v_320) else caught-fail) in
        {924}let cs_47: cipherstate = (if v_321 then 1-proj-3-tuple(v_320) else caught-fail) in
        {925}let input_key_material_14: key = (if v_321 then zero else caught-fail) in
        {926}let output1_14: key = (if v_321 then hmac_hash1(ck_59,input_key_material_14) else caught-fail) in
        {927}let output2_14: key = (if v_321 then hmac_hash2(ck_59,input_key_material_14) else caught-fail) in
        {928}let output3_14: key = (if v_321 then hmac_hash3(ck_59,input_key_material_14) else caught-fail) in
        {929}let v_322: bitstring = (if v_321 then catch-fail((output1_14,output2_14,output3_14)) else caught-fail) in
        {930}let v_323: bool = (not-caught-fail(v_322) && success?(1-proj-3-tuple(v_322))) in
        {931}let temp_k3_2: key = (if v_323 then 3-proj-3-tuple(v_322) else caught-fail) in
        {932}let temp_k2_2: key = (if v_323 then 2-proj-3-tuple(v_322) else caught-fail) in
        {933}let temp_k1_2: key = (if v_323 then 1-proj-3-tuple(v_322) else caught-fail) in
        {934}let cs1_6: cipherstate = (if v_323 then cipherstatepack(temp_k1_2,minnonce) else caught-fail) in
        {935}let cs2_6: cipherstate = (if v_323 then cipherstatepack(temp_k2_2,minnonce) else caught-fail) in
        {936}let v_324: bitstring = (if v_319 then catch-fail((if v_321 then (if v_323 then (ss_47,cs1_6,cs2_6) else fail-any) else fail-any)) else caught-fail) in
        {937}let v_325: bool = (not-caught-fail(v_324) && success?(1-proj-3-tuple(v_324))) in
        {938}let cs2_7: cipherstate = (if v_325 then 3-proj-3-tuple(v_324) else caught-fail) in
        {939}let cs1_7: cipherstate = (if v_325 then 2-proj-3-tuple(v_324) else caught-fail) in
        {940}let ssi_11: symmetricstate = (if v_325 then 1-proj-3-tuple(v_324) else caught-fail) in
        {941}let (hs_11: handshakestate,plaintext_a: bitstring,valid_6: bool,cs1_8: cipherstate,cs2_8: cipherstate) = (if v_228 then (if v_230 then (if v_233 then (if v_241 then (if v_249 then (if v_266 then (if v_283 then (if v_291 then (if v_299 then (if v_316 then (if undo-catch-fail(v_319) then (if v_325 then (hs_10,plaintext_10,true,cs1_7,cs2_7) else fail-any) else fail-any) else fail-any) else fail-any) else fail-any) else fail-any) else fail-any) else fail-any) else fail-any) else fail-any) else fail-any) else fail-any) in
        {942}event RecvMsg(me_2,them_2,stagepack_a(sid_3),plaintext_a);
        {943}event RecvEnd(valid_6)
    ) | (
        {945}event LeakS(phase0,me_2);
        {946}event LeakM(phase0,me_2);
        {947}out(pub, (key_s(me_2),key_m(me_2)))
    ) | (
        {948}phase 1;
        {949}event LeakS(phase1,me_2);
        {950}event LeakM(phase1,me_2);
        {951}out(pub, (key_s(me_2),key_m(me_2)))
    )
) | (
    {952}let me_4: principal = bob in
    {953}let them_3: principal = charlie in
    {954}let sid_4: sessionid = sid in
    {955}let basis_14: key = key_s(me_4) in
    {956}let public_key_14: key = catch-fail(dhexp(basis_14,validkey(g))) in
    {957}let v_326: bool = not-caught-fail(public_key_14) in
    {958}let s_8: keypair = (if v_326 then keypairpack(validkey(public_key_14),basis_14) else fail-any) in
    {959}let basis_15: key = key_m(me_4) in
    {960}let public_key_15: key = catch-fail(dhexp(basis_15,validkey(g))) in
    {961}let v_327: bool = not-caught-fail(public_key_15) in
    {962}let m_8: keypair = (if v_327 then keypairpack(validkey(public_key_15),basis_15) else fail-any) in
    {963}out(pub, (getpublickey(s_8),getpublickey(m_8)));
    (
        {964}let e_14: keypair = keypairpack(empty,empty) in
        {965}let rs_7: key = empty in
        {966}let rm_7: key = empty in
        {967}let re_7: key = empty in
        {968}let prologue_3: bitstring = empty in
        {969}let psk_6: key = empty in
        {970}let protocol_name_3: bitstring = somename in
        {971}let h_48: bitstring = hash(protocol_name_3,empty) in
        {972}let ck_60: key = h_48 in
        {973}let k_21: key = empty in
        {974}let cs_48: cipherstate = cipherstatepack(k_21,minnonce) in
        {975}let ss_48: symmetricstate = symmetricstatepack(cs_48,ck_60,h_48) in
        {976}let v_328: bitstring = catch-fail(symmetricstateunpack(ss_48)) in
        {977}let v_329: bool = (not-caught-fail(v_328) && success?(1-proj-3-tuple(v_328))) in
        {978}let h_49: bitstring = (if v_329 then 3-proj-3-tuple(v_328) else caught-fail) in
        {979}let ck_61: key = (if v_329 then 2-proj-3-tuple(v_328) else caught-fail) in
        {980}let cs_49: cipherstate = (if v_329 then 1-proj-3-tuple(v_328) else caught-fail) in
        {981}let ss_49: symmetricstate = catch-fail((if v_329 then symmetricstatepack(cs_49,ck_61,hash(h_49,prologue_3)) else fail-any)) in
        {982}let v_330: bool = not-caught-fail(ss_49) in
        {983}let data_2: bitstring = (if v_330 then catch-fail(getpublickey(s_8)) else caught-fail) in
        {984}let v_331: bool = not-caught-fail(data_2) in
        {985}let v_332: bitstring = (if v_331 then catch-fail(symmetricstateunpack(ss_49)) else caught-fail) in
        {986}let v_333: bool = (not-caught-fail(v_332) && success?(1-proj-3-tuple(v_332))) in
        {987}let h_50: bitstring = (if v_333 then 3-proj-3-tuple(v_332) else caught-fail) in
        {988}let ck_62: key = (if v_333 then 2-proj-3-tuple(v_332) else caught-fail) in
        {989}let cs_50: cipherstate = (if v_333 then 1-proj-3-tuple(v_332) else caught-fail) in
        {990}let ss_50: symmetricstate = (if v_330 then catch-fail((if v_331 then (if v_333 then symmetricstatepack(cs_50,ck_62,hash(h_50,data_2)) else fail-any) else fail-any)) else caught-fail) in
        {991}let v_334: bool = not-caught-fail(ss_50) in
        {992}let data_3: bitstring = (if v_334 then catch-fail(getpublickey(m_8)) else caught-fail) in
        {993}let v_335: bool = not-caught-fail(data_3) in
        {994}let v_336: bitstring = (if v_335 then catch-fail(symmetricstateunpack(ss_50)) else caught-fail) in
        {995}let v_337: bool = (not-caught-fail(v_336) && success?(1-proj-3-tuple(v_336))) in
        {996}let h_51: bitstring = (if v_337 then 3-proj-3-tuple(v_336) else caught-fail) in
        {997}let ck_63: key = (if v_337 then 2-proj-3-tuple(v_336) else caught-fail) in
        {998}let cs_51: cipherstate = (if v_337 then 1-proj-3-tuple(v_336) else caught-fail) in
        {999}let ss_51: symmetricstate = (if v_334 then catch-fail((if v_335 then (if v_337 then symmetricstatepack(cs_51,ck_63,hash(h_51,data_3)) else fail-any) else fail-any)) else caught-fail) in
        {1000}let v_338: bool = not-caught-fail(ss_51) in
        {1001}let hs_12: handshakestate = (if v_330 then (if v_334 then (if v_338 then handshakestatepack(ss_51,s_8,m_8,e_14,rs_7,rm_7,re_7,psk_6,false) else fail-any) else fail-any) else fail-any) in
        {1002}insert statestore(me_4,them_3,sid_4,statepack_a(hs_12))
    ) | (
        {1272}get statestore(=me_4,=them_3,=sid_4,statepack_a(hs_13: handshakestate)) in
        {1003}in(pub, message_a_3: bitstring);
        {1004}let v_339: bitstring = catch-fail(handshakestateunpack(hs_13)) in
        {1005}let v_340: bool = (not-caught-fail(v_339) && success?(1-proj-9-tuple(v_339))) in
        {1006}let initiator_4: bool = (if v_340 then 9-proj-9-tuple(v_339) else caught-fail) in
        {1007}let psk_7: key = (if v_340 then 8-proj-9-tuple(v_339) else caught-fail) in
        {1008}let re_8: key = (if v_340 then 7-proj-9-tuple(v_339) else caught-fail) in
        {1009}let rm_8: key = (if v_340 then 6-proj-9-tuple(v_339) else caught-fail) in
        {1010}let rs_8: key = (if v_340 then 5-proj-9-tuple(v_339) else caught-fail) in
        {1011}let e_15: keypair = (if v_340 then 4-proj-9-tuple(v_339) else caught-fail) in
        {1012}let m_9: keypair = (if v_340 then 3-proj-9-tuple(v_339) else caught-fail) in
        {1013}let s_9: keypair = (if v_340 then 2-proj-9-tuple(v_339) else caught-fail) in
        {1014}let ss_52: symmetricstate = (if v_340 then 1-proj-9-tuple(v_339) else caught-fail) in
        {1015}let v_341: bitstring = (if v_340 then catch-fail(deconcat4(message_a_3)) else caught-fail) in
        {1016}let v_342: bool = (not-caught-fail(v_341) && success?(1-proj-4-tuple(v_341))) in
        {1017}let ciphertext_11: bitstring = (if v_342 then 4-proj-4-tuple(v_341) else caught-fail) in
        {1018}let nm_5: bitstring = (if v_342 then 3-proj-4-tuple(v_341) else caught-fail) in
        {1019}let ns_5: bitstring = (if v_342 then 2-proj-4-tuple(v_341) else caught-fail) in
        {1020}let ne_5: bitstring = (if v_342 then 1-proj-4-tuple(v_341) else caught-fail) in
        {1021}let valid1_2: bool = (if v_342 then true else caught-fail) in
        {1022}let valid2_2: bool = (if v_342 then true else caught-fail) in
        {1023}let re_9: key = (if v_342 then ne_5 else caught-fail) in
        {1024}let v_343: bitstring = (if v_342 then catch-fail(symmetricstateunpack(ss_52)) else caught-fail) in
        {1025}let v_344: bool = (not-caught-fail(v_343) && success?(1-proj-3-tuple(v_343))) in
        {1026}let h_52: bitstring = (if v_344 then 3-proj-3-tuple(v_343) else caught-fail) in
        {1027}let ck_64: key = (if v_344 then 2-proj-3-tuple(v_343) else caught-fail) in
        {1028}let cs_52: cipherstate = (if v_344 then 1-proj-3-tuple(v_343) else caught-fail) in
        {1029}let ss_53: symmetricstate = (if v_342 then catch-fail((if v_344 then symmetricstatepack(cs_52,ck_64,hash(h_52,re_9)) else fail-any)) else caught-fail) in
        {1030}let v_345: bool = not-caught-fail(ss_53) in
        {1031}let v_346: bitstring = (if v_345 then catch-fail(keypairunpack(s_9)) else caught-fail) in
        {1032}let v_347: bool = (not-caught-fail(v_346) && success?(1-proj-2-tuple(v_346))) in
        {1033}let my_private_key_12: key = (if v_347 then 2-proj-2-tuple(v_346) else caught-fail) in
        {1034}let my_public_key_12: key = (if v_347 then 1-proj-2-tuple(v_346) else caught-fail) in
        {1035}let input_key_material_15: key = (if v_345 then catch-fail((if v_347 then dhexp(my_private_key_12,re_9) else fail-any)) else caught-fail) in
        {1036}let v_348: bool = not-caught-fail(input_key_material_15) in
        {1037}let v_349: bitstring = (if v_348 then catch-fail(symmetricstateunpack(ss_53)) else caught-fail) in
        {1038}let v_350: bool = (not-caught-fail(v_349) && success?(1-proj-3-tuple(v_349))) in
        {1039}let h_53: bitstring = (if v_350 then 3-proj-3-tuple(v_349) else caught-fail) in
        {1040}let ck_65: key = (if v_350 then 2-proj-3-tuple(v_349) else caught-fail) in
        {1041}let cs_53: cipherstate = (if v_350 then 1-proj-3-tuple(v_349) else caught-fail) in
        {1042}let output1_15: key = (if v_350 then hmac_hash1(ck_65,input_key_material_15) else caught-fail) in
        {1043}let output2_15: key = (if v_350 then hmac_hash2(ck_65,input_key_material_15) else caught-fail) in
        {1044}let output3_15: key = (if v_350 then hmac_hash3(ck_65,input_key_material_15) else caught-fail) in
        {1045}let v_351: bitstring = (if v_350 then catch-fail((output1_15,output2_15,output3_15)) else caught-fail) in
        {1046}let v_352: bool = (not-caught-fail(v_351) && success?(1-proj-3-tuple(v_351))) in
        {1047}let output_12: key = (if v_352 then 3-proj-3-tuple(v_351) else caught-fail) in
        {1048}let temp_k_12: key = (if v_352 then 2-proj-3-tuple(v_351) else caught-fail) in
        {1049}let ck_66: key = (if v_352 then 1-proj-3-tuple(v_351) else caught-fail) in
        {1050}let ss_54: symmetricstate = (if v_345 then catch-fail((if v_348 then (if v_350 then (if v_352 then symmetricstatepack(cipherstatepack(temp_k_12,minnonce),ck_66,h_53) else fail-any) else fail-any) else fail-any)) else caught-fail) in
        {1051}let v_353: bool = not-caught-fail(ss_54) in
        {1052}let v_354: bitstring = (if v_353 then catch-fail(keypairunpack(m_9)) else caught-fail) in
        {1053}let v_355: bool = (not-caught-fail(v_354) && success?(1-proj-2-tuple(v_354))) in
        {1054}let my_private_key_13: key = (if v_355 then 2-proj-2-tuple(v_354) else caught-fail) in
        {1055}let my_public_key_13: key = (if v_355 then 1-proj-2-tuple(v_354) else caught-fail) in
        {1056}let input_key_material_16: key = (if v_353 then catch-fail((if v_355 then dhexp(my_private_key_13,re_9) else fail-any)) else caught-fail) in
        {1057}let v_356: bool = not-caught-fail(input_key_material_16) in
        {1058}let v_357: bitstring = (if v_356 then catch-fail(symmetricstateunpack(ss_54)) else caught-fail) in
        {1059}let v_358: bool = (not-caught-fail(v_357) && success?(1-proj-3-tuple(v_357))) in
        {1060}let h_54: bitstring = (if v_358 then 3-proj-3-tuple(v_357) else caught-fail) in
        {1061}let ck_67: key = (if v_358 then 2-proj-3-tuple(v_357) else caught-fail) in
        {1062}let cs_54: cipherstate = (if v_358 then 1-proj-3-tuple(v_357) else caught-fail) in
        {1063}let output1_16: key = (if v_358 then hmac_hash1(ck_67,input_key_material_16) else caught-fail) in
        {1064}let output2_16: key = (if v_358 then hmac_hash2(ck_67,input_key_material_16) else caught-fail) in
        {1065}let output3_16: key = (if v_358 then hmac_hash3(ck_67,input_key_material_16) else caught-fail) in
        {1066}let v_359: bitstring = (if v_358 then catch-fail((output1_16,output2_16,output3_16)) else caught-fail) in
        {1067}let v_360: bool = (not-caught-fail(v_359) && success?(1-proj-3-tuple(v_359))) in
        {1068}let output_13: key = (if v_360 then 3-proj-3-tuple(v_359) else caught-fail) in
        {1069}let temp_k_13: key = (if v_360 then 2-proj-3-tuple(v_359) else caught-fail) in
        {1070}let ck_68: key = (if v_360 then 1-proj-3-tuple(v_359) else caught-fail) in
        {1071}let ss_55: symmetricstate = (if v_353 then catch-fail((if v_356 then (if v_358 then (if v_360 then symmetricstatepack(cipherstatepack(temp_k_13,minnonce),ck_68,h_54) else fail-any) else fail-any) else fail-any)) else caught-fail) in
        {1072}let v_361: bool = not-caught-fail(ss_55) in
        {1073}let v_362: bitstring = (if v_361 then catch-fail(symmetricstateunpack(ss_55)) else caught-fail) in
        {1074}let v_363: bool = (not-caught-fail(v_362) && success?(1-proj-3-tuple(v_362))) in
        {1075}let h_55: bitstring = (if v_363 then 3-proj-3-tuple(v_362) else caught-fail) in
        {1076}let ck_69: key = (if v_363 then 2-proj-3-tuple(v_362) else caught-fail) in
        {1077}let cs_55: cipherstate = (if v_363 then 1-proj-3-tuple(v_362) else caught-fail) in
        {1078}let v_364: bitstring = (if v_363 then catch-fail(cipherstateunpack(cs_55)) else caught-fail) in
        {1079}let v_365: bool = (not-caught-fail(v_364) && success?(1-proj-2-tuple(v_364))) in
        {1080}let n_18: nonce = (if v_365 then 2-proj-2-tuple(v_364) else caught-fail) in
        {1081}let k_22: key = (if v_365 then 1-proj-2-tuple(v_364) else caught-fail) in
        {1082}let d_3: aead = (if v_365 then catch-fail(decrypt(k_22,n_18,h_55,ns_5)) else caught-fail) in
        {1083}let v_366: bool = not-caught-fail(d_3) in
        {1084}let v_367: bitstring = (if v_366 then catch-fail(aeadunpack(d_3)) else caught-fail) in
        {1085}let v_368: bool = (not-caught-fail(v_367) && success?(1-proj-3-tuple(v_367))) in
        {1086}let plaintext_11: bitstring = (if v_368 then 3-proj-3-tuple(v_367) else caught-fail) in
        {1087}let adi_3: bitstring = (if v_368 then 2-proj-3-tuple(v_367) else caught-fail) in
        {1088}let valid_7: bool = (if v_368 then 1-proj-3-tuple(v_367) else caught-fail) in
        {1089}let n_19: nonce = (if v_368 then increment_nonce(n_18) else caught-fail) in
        {1090}let v_369: bitstring = (if v_368 then catch-fail(cipherstateunpack(cs_55)) else caught-fail) in
        {1091}let v_370: bool = (not-caught-fail(v_369) && success?(1-proj-2-tuple(v_369))) in
        {1092}let o_9: nonce = (if v_370 then 2-proj-2-tuple(v_369) else caught-fail) in
        {1093}let k_23: key = (if v_370 then 1-proj-2-tuple(v_369) else caught-fail) in
        {1094}let csi_18: cipherstate = (if v_368 then catch-fail((if v_370 then cipherstatepack(k_23,n_19) else fail-any)) else caught-fail) in
        {1095}let v_371: bool = not-caught-fail(csi_18) in
        {1096}let v_372: bitstring = (if v_363 then catch-fail((if v_365 then (if v_366 then (if v_368 then (if v_371 then (csi_18,plaintext_11,valid_7) else fail-any) else fail-any) else fail-any) else fail-any)) else caught-fail) in
        {1097}let v_373: bool = (not-caught-fail(v_372) && success?(1-proj-3-tuple(v_372))) in
        {1098}let valid_8: bool = (if v_373 then 3-proj-3-tuple(v_372) else caught-fail) in
        {1099}let plaintext_12: bitstring = (if v_373 then 2-proj-3-tuple(v_372) else caught-fail) in
        {1100}let csi_19: cipherstate = (if v_373 then 1-proj-3-tuple(v_372) else caught-fail) in
        {1101}let ss_56: symmetricstate = (if v_373 then symmetricstatepack(csi_19,ck_69,h_55) else caught-fail) in
        {1102}let v_374: bitstring = (if v_373 then catch-fail(symmetricstateunpack(ss_56)) else caught-fail) in
        {1103}let v_375: bool = (not-caught-fail(v_374) && success?(1-proj-3-tuple(v_374))) in
        {1104}let h_56: bitstring = (if v_375 then 3-proj-3-tuple(v_374) else caught-fail) in
        {1105}let ck_70: key = (if v_375 then 2-proj-3-tuple(v_374) else caught-fail) in
        {1106}let cs_56: cipherstate = (if v_375 then 1-proj-3-tuple(v_374) else caught-fail) in
        {1107}let ssi_12: symmetricstate = (if v_373 then catch-fail((if v_375 then symmetricstatepack(cs_56,ck_70,hash(h_56,ns_5)) else fail-any)) else caught-fail) in
        {1108}let v_376: bool = not-caught-fail(ssi_12) in
        {1109}let v_377: bitstring = (if v_361 then catch-fail((if v_363 then (if v_373 then (if v_376 then (ssi_12,plaintext_12,valid_8) else fail-any) else fail-any) else fail-any)) else caught-fail) in
        {1110}let v_378: bool = (not-caught-fail(v_377) && success?(1-proj-3-tuple(v_377))) in
        {1111}let valid1_3: bool = (if v_378 then 3-proj-3-tuple(v_377) else caught-fail) in
        {1112}let se_1: bitstring = (if v_378 then 2-proj-3-tuple(v_377) else caught-fail) in
        {1113}let ss_57: symmetricstate = (if v_378 then 1-proj-3-tuple(v_377) else caught-fail) in
        {1114}let rs_9: key = (if v_378 then se_1 else caught-fail) in
        {1115}let v_379: bitstring = (if v_378 then catch-fail(symmetricstateunpack(ss_57)) else caught-fail) in
        {1116}let v_380: bool = (not-caught-fail(v_379) && success?(1-proj-3-tuple(v_379))) in
        {1117}let h_57: bitstring = (if v_380 then 3-proj-3-tuple(v_379) else caught-fail) in
        {1118}let ck_71: key = (if v_380 then 2-proj-3-tuple(v_379) else caught-fail) in
        {1119}let cs_57: cipherstate = (if v_380 then 1-proj-3-tuple(v_379) else caught-fail) in
        {1120}let v_381: bitstring = (if v_380 then catch-fail(cipherstateunpack(cs_57)) else caught-fail) in
        {1121}let v_382: bool = (not-caught-fail(v_381) && success?(1-proj-2-tuple(v_381))) in
        {1122}let n_20: nonce = (if v_382 then 2-proj-2-tuple(v_381) else caught-fail) in
        {1123}let k_24: key = (if v_382 then 1-proj-2-tuple(v_381) else caught-fail) in
        {1124}let d_4: aead = (if v_382 then catch-fail(decrypt(k_24,n_20,h_57,nm_5)) else caught-fail) in
        {1125}let v_383: bool = not-caught-fail(d_4) in
        {1126}let v_384: bitstring = (if v_383 then catch-fail(aeadunpack(d_4)) else caught-fail) in
        {1127}let v_385: bool = (not-caught-fail(v_384) && success?(1-proj-3-tuple(v_384))) in
        {1128}let plaintext_13: bitstring = (if v_385 then 3-proj-3-tuple(v_384) else caught-fail) in
        {1129}let adi_4: bitstring = (if v_385 then 2-proj-3-tuple(v_384) else caught-fail) in
        {1130}let valid_9: bool = (if v_385 then 1-proj-3-tuple(v_384) else caught-fail) in
        {1131}let n_21: nonce = (if v_385 then increment_nonce(n_20) else caught-fail) in
        {1132}let v_386: bitstring = (if v_385 then catch-fail(cipherstateunpack(cs_57)) else caught-fail) in
        {1133}let v_387: bool = (not-caught-fail(v_386) && success?(1-proj-2-tuple(v_386))) in
        {1134}let o_10: nonce = (if v_387 then 2-proj-2-tuple(v_386) else caught-fail) in
        {1135}let k_25: key = (if v_387 then 1-proj-2-tuple(v_386) else caught-fail) in
        {1136}let csi_20: cipherstate = (if v_385 then catch-fail((if v_387 then cipherstatepack(k_25,n_21) else fail-any)) else caught-fail) in
        {1137}let v_388: bool = not-caught-fail(csi_20) in
        {1138}let v_389: bitstring = (if v_380 then catch-fail((if v_382 then (if v_383 then (if v_385 then (if v_388 then (csi_20,plaintext_13,valid_9) else fail-any) else fail-any) else fail-any) else fail-any)) else caught-fail) in
        {1139}let v_390: bool = (not-caught-fail(v_389) && success?(1-proj-3-tuple(v_389))) in
        {1140}let valid_10: bool = (if v_390 then 3-proj-3-tuple(v_389) else caught-fail) in
        {1141}let plaintext_14: bitstring = (if v_390 then 2-proj-3-tuple(v_389) else caught-fail) in
        {1142}let csi_21: cipherstate = (if v_390 then 1-proj-3-tuple(v_389) else caught-fail) in
        {1143}let ss_58: symmetricstate = (if v_390 then symmetricstatepack(csi_21,ck_71,h_57) else caught-fail) in
        {1144}let v_391: bitstring = (if v_390 then catch-fail(symmetricstateunpack(ss_58)) else caught-fail) in
        {1145}let v_392: bool = (not-caught-fail(v_391) && success?(1-proj-3-tuple(v_391))) in
        {1146}let h_58: bitstring = (if v_392 then 3-proj-3-tuple(v_391) else caught-fail) in
        {1147}let ck_72: key = (if v_392 then 2-proj-3-tuple(v_391) else caught-fail) in
        {1148}let cs_58: cipherstate = (if v_392 then 1-proj-3-tuple(v_391) else caught-fail) in
        {1149}let ssi_13: symmetricstate = (if v_390 then catch-fail((if v_392 then symmetricstatepack(cs_58,ck_72,hash(h_58,nm_5)) else fail-any)) else caught-fail) in
        {1150}let v_393: bool = not-caught-fail(ssi_13) in
        {1151}let v_394: bitstring = (if v_378 then catch-fail((if v_380 then (if v_390 then (if v_393 then (ssi_13,plaintext_14,valid_10) else fail-any) else fail-any) else fail-any)) else caught-fail) in
        {1152}let v_395: bool = (not-caught-fail(v_394) && success?(1-proj-3-tuple(v_394))) in
        {1153}let valid2_3: bool = (if v_395 then 3-proj-3-tuple(v_394) else caught-fail) in
        {1154}let me_5: bitstring = (if v_395 then 2-proj-3-tuple(v_394) else caught-fail) in
        {1155}let ss_59: symmetricstate = (if v_395 then 1-proj-3-tuple(v_394) else caught-fail) in
        {1156}let rm_9: key = (if v_395 then me_5 else caught-fail) in
        {1157}let v_396: bitstring = (if v_395 then catch-fail(keypairunpack(s_9)) else caught-fail) in
        {1158}let v_397: bool = (not-caught-fail(v_396) && success?(1-proj-2-tuple(v_396))) in
        {1159}let my_private_key_14: key = (if v_397 then 2-proj-2-tuple(v_396) else caught-fail) in
        {1160}let my_public_key_14: key = (if v_397 then 1-proj-2-tuple(v_396) else caught-fail) in
        {1161}let input_key_material_17: key = (if v_395 then catch-fail((if v_397 then dhexp(my_private_key_14,rm_9) else fail-any)) else caught-fail) in
        {1162}let v_398: bool = not-caught-fail(input_key_material_17) in
        {1163}let v_399: bitstring = (if v_398 then catch-fail(symmetricstateunpack(ss_59)) else caught-fail) in
        {1164}let v_400: bool = (not-caught-fail(v_399) && success?(1-proj-3-tuple(v_399))) in
        {1165}let h_59: bitstring = (if v_400 then 3-proj-3-tuple(v_399) else caught-fail) in
        {1166}let ck_73: key = (if v_400 then 2-proj-3-tuple(v_399) else caught-fail) in
        {1167}let cs_59: cipherstate = (if v_400 then 1-proj-3-tuple(v_399) else caught-fail) in
        {1168}let output1_17: key = (if v_400 then hmac_hash1(ck_73,input_key_material_17) else caught-fail) in
        {1169}let output2_17: key = (if v_400 then hmac_hash2(ck_73,input_key_material_17) else caught-fail) in
        {1170}let output3_17: key = (if v_400 then hmac_hash3(ck_73,input_key_material_17) else caught-fail) in
        {1171}let v_401: bitstring = (if v_400 then catch-fail((output1_17,output2_17,output3_17)) else caught-fail) in
        {1172}let v_402: bool = (not-caught-fail(v_401) && success?(1-proj-3-tuple(v_401))) in
        {1173}let output_14: key = (if v_402 then 3-proj-3-tuple(v_401) else caught-fail) in
        {1174}let temp_k_14: key = (if v_402 then 2-proj-3-tuple(v_401) else caught-fail) in
        {1175}let ck_74: key = (if v_402 then 1-proj-3-tuple(v_401) else caught-fail) in
        {1176}let ss_60: symmetricstate = (if v_395 then catch-fail((if v_398 then (if v_400 then (if v_402 then symmetricstatepack(cipherstatepack(temp_k_14,minnonce),ck_74,h_59) else fail-any) else fail-any) else fail-any)) else caught-fail) in
        {1177}let v_403: bool = not-caught-fail(ss_60) in
        {1178}let v_404: bitstring = (if v_403 then catch-fail(keypairunpack(m_9)) else caught-fail) in
        {1179}let v_405: bool = (not-caught-fail(v_404) && success?(1-proj-2-tuple(v_404))) in
        {1180}let my_private_key_15: key = (if v_405 then 2-proj-2-tuple(v_404) else caught-fail) in
        {1181}let my_public_key_15: key = (if v_405 then 1-proj-2-tuple(v_404) else caught-fail) in
        {1182}let input_key_material_18: key = (if v_403 then catch-fail((if v_405 then dhexp(my_private_key_15,rs_9) else fail-any)) else caught-fail) in
        {1183}let v_406: bool = not-caught-fail(input_key_material_18) in
        {1184}let v_407: bitstring = (if v_406 then catch-fail(symmetricstateunpack(ss_60)) else caught-fail) in
        {1185}let v_408: bool = (not-caught-fail(v_407) && success?(1-proj-3-tuple(v_407))) in
        {1186}let h_60: bitstring = (if v_408 then 3-proj-3-tuple(v_407) else caught-fail) in
        {1187}let ck_75: key = (if v_408 then 2-proj-3-tuple(v_407) else caught-fail) in
        {1188}let cs_60: cipherstate = (if v_408 then 1-proj-3-tuple(v_407) else caught-fail) in
        {1189}let output1_18: key = (if v_408 then hmac_hash1(ck_75,input_key_material_18) else caught-fail) in
        {1190}let output2_18: key = (if v_408 then hmac_hash2(ck_75,input_key_material_18) else caught-fail) in
        {1191}let output3_18: key = (if v_408 then hmac_hash3(ck_75,input_key_material_18) else caught-fail) in
        {1192}let v_409: bitstring = (if v_408 then catch-fail((output1_18,output2_18,output3_18)) else caught-fail) in
        {1193}let v_410: bool = (not-caught-fail(v_409) && success?(1-proj-3-tuple(v_409))) in
        {1194}let output_15: key = (if v_410 then 3-proj-3-tuple(v_409) else caught-fail) in
        {1195}let temp_k_15: key = (if v_410 then 2-proj-3-tuple(v_409) else caught-fail) in
        {1196}let ck_76: key = (if v_410 then 1-proj-3-tuple(v_409) else caught-fail) in
        {1197}let ss_61: symmetricstate = (if v_403 then catch-fail((if v_406 then (if v_408 then (if v_410 then symmetricstatepack(cipherstatepack(temp_k_15,minnonce),ck_76,h_60) else fail-any) else fail-any) else fail-any)) else caught-fail) in
        {1198}let v_411: bool = not-caught-fail(ss_61) in
        {1199}let v_412: bitstring = (if v_411 then catch-fail(symmetricstateunpack(ss_61)) else caught-fail) in
        {1200}let v_413: bool = (not-caught-fail(v_412) && success?(1-proj-3-tuple(v_412))) in
        {1201}let h_61: bitstring = (if v_413 then 3-proj-3-tuple(v_412) else caught-fail) in
        {1202}let ck_77: key = (if v_413 then 2-proj-3-tuple(v_412) else caught-fail) in
        {1203}let cs_61: cipherstate = (if v_413 then 1-proj-3-tuple(v_412) else caught-fail) in
        {1204}let v_414: bitstring = (if v_413 then catch-fail(cipherstateunpack(cs_61)) else caught-fail) in
        {1205}let v_415: bool = (not-caught-fail(v_414) && success?(1-proj-2-tuple(v_414))) in
        {1206}let n_22: nonce = (if v_415 then 2-proj-2-tuple(v_414) else caught-fail) in
        {1207}let k_26: key = (if v_415 then 1-proj-2-tuple(v_414) else caught-fail) in
        {1208}let d_5: aead = (if v_415 then catch-fail(decrypt(k_26,n_22,h_61,ciphertext_11)) else caught-fail) in
        {1209}let v_416: bool = not-caught-fail(d_5) in
        {1210}let v_417: bitstring = (if v_416 then catch-fail(aeadunpack(d_5)) else caught-fail) in
        {1211}let v_418: bool = (not-caught-fail(v_417) && success?(1-proj-3-tuple(v_417))) in
        {1212}let plaintext_15: bitstring = (if v_418 then 3-proj-3-tuple(v_417) else caught-fail) in
        {1213}let adi_5: bitstring = (if v_418 then 2-proj-3-tuple(v_417) else caught-fail) in
        {1214}let valid_11: bool = (if v_418 then 1-proj-3-tuple(v_417) else caught-fail) in
        {1215}let n_23: nonce = (if v_418 then increment_nonce(n_22) else caught-fail) in
        {1216}let v_419: bitstring = (if v_418 then catch-fail(cipherstateunpack(cs_61)) else caught-fail) in
        {1217}let v_420: bool = (not-caught-fail(v_419) && success?(1-proj-2-tuple(v_419))) in
        {1218}let o_11: nonce = (if v_420 then 2-proj-2-tuple(v_419) else caught-fail) in
        {1219}let k_27: key = (if v_420 then 1-proj-2-tuple(v_419) else caught-fail) in
        {1220}let csi_22: cipherstate = (if v_418 then catch-fail((if v_420 then cipherstatepack(k_27,n_23) else fail-any)) else caught-fail) in
        {1221}let v_421: bool = not-caught-fail(csi_22) in
        {1222}let v_422: bitstring = (if v_413 then catch-fail((if v_415 then (if v_416 then (if v_418 then (if v_421 then (csi_22,plaintext_15,valid_11) else fail-any) else fail-any) else fail-any) else fail-any)) else caught-fail) in
        {1223}let v_423: bool = (not-caught-fail(v_422) && success?(1-proj-3-tuple(v_422))) in
        {1224}let valid_12: bool = (if v_423 then 3-proj-3-tuple(v_422) else caught-fail) in
        {1225}let plaintext_16: bitstring = (if v_423 then 2-proj-3-tuple(v_422) else caught-fail) in
        {1226}let csi_23: cipherstate = (if v_423 then 1-proj-3-tuple(v_422) else caught-fail) in
        {1227}let ss_62: symmetricstate = (if v_423 then symmetricstatepack(csi_23,ck_77,h_61) else caught-fail) in
        {1228}let v_424: bitstring = (if v_423 then catch-fail(symmetricstateunpack(ss_62)) else caught-fail) in
        {1229}let v_425: bool = (not-caught-fail(v_424) && success?(1-proj-3-tuple(v_424))) in
        {1230}let h_62: bitstring = (if v_425 then 3-proj-3-tuple(v_424) else caught-fail) in
        {1231}let ck_78: key = (if v_425 then 2-proj-3-tuple(v_424) else caught-fail) in
        {1232}let cs_62: cipherstate = (if v_425 then 1-proj-3-tuple(v_424) else caught-fail) in
        {1233}let ssi_14: symmetricstate = (if v_423 then catch-fail((if v_425 then symmetricstatepack(cs_62,ck_78,hash(h_62,ciphertext_11)) else fail-any)) else caught-fail) in
        {1234}let v_426: bool = not-caught-fail(ssi_14) in
        {1235}let v_427: bitstring = (if v_411 then catch-fail((if v_413 then (if v_423 then (if v_426 then (ssi_14,plaintext_16,valid_12) else fail-any) else fail-any) else fail-any)) else caught-fail) in
        {1236}let v_428: bool = (not-caught-fail(v_427) && success?(1-proj-3-tuple(v_427))) in
        {1237}let valid3_1: bool = (if v_428 then 3-proj-3-tuple(v_427) else caught-fail) in
        {1238}let plaintext_17: bitstring = (if v_428 then 2-proj-3-tuple(v_427) else caught-fail) in
        {1239}let ss_63: symmetricstate = (if v_428 then 1-proj-3-tuple(v_427) else caught-fail) in
        {1240}let basis_16: key = (if v_428 then key_s(them_3) else caught-fail) in
        {1241}let public_key_16: key = (if v_428 then catch-fail(dhexp(basis_16,validkey(g))) else caught-fail) in
        {1242}let v_429: bool = not-caught-fail(public_key_16) in
        {1243}let basis_17: key = (if v_428 then key_m(them_3) else caught-fail) in
        {1244}let public_key_17: key = (if v_428 then catch-fail(dhexp(basis_17,validkey(g))) else caught-fail) in
        {1245}let v_430: bool = not-caught-fail(public_key_17) in
        {1246}let v_431: bool = (if v_428 then catch-fail(((valid1_3 && (valid2_3 && valid3_1)) && ((rs_9 = getpublickey((if v_429 then keypairpack(validkey(public_key_16),basis_16) else fail-any))) && (rm_9 = getpublickey((if v_430 then keypairpack(validkey(public_key_17),basis_17) else fail-any)))))) else caught-fail) in
        {1247}let hs_14: handshakestate = (if v_431 then handshakestatepack(ss_63,s_9,m_9,e_15,rs_9,rm_9,re_9,psk_7,initiator_4) else caught-fail) in
        {1248}let v_432: bitstring = (if v_431 then catch-fail(symmetricstateunpack(ss_63)) else caught-fail) in
        {1249}let v_433: bool = (not-caught-fail(v_432) && success?(1-proj-3-tuple(v_432))) in
        {1250}let h_63: bitstring = (if v_433 then 3-proj-3-tuple(v_432) else caught-fail) in
        {1251}let ck_79: key = (if v_433 then 2-proj-3-tuple(v_432) else caught-fail) in
        {1252}let cs_63: cipherstate = (if v_433 then 1-proj-3-tuple(v_432) else caught-fail) in
        {1253}let input_key_material_19: key = (if v_433 then zero else caught-fail) in
        {1254}let output1_19: key = (if v_433 then hmac_hash1(ck_79,input_key_material_19) else caught-fail) in
        {1255}let output2_19: key = (if v_433 then hmac_hash2(ck_79,input_key_material_19) else caught-fail) in
        {1256}let output3_19: key = (if v_433 then hmac_hash3(ck_79,input_key_material_19) else caught-fail) in
        {1257}let v_434: bitstring = (if v_433 then catch-fail((output1_19,output2_19,output3_19)) else caught-fail) in
        {1258}let v_435: bool = (not-caught-fail(v_434) && success?(1-proj-3-tuple(v_434))) in
        {1259}let temp_k3_3: key = (if v_435 then 3-proj-3-tuple(v_434) else caught-fail) in
        {1260}let temp_k2_3: key = (if v_435 then 2-proj-3-tuple(v_434) else caught-fail) in
        {1261}let temp_k1_3: key = (if v_435 then 1-proj-3-tuple(v_434) else caught-fail) in
        {1262}let cs1_9: cipherstate = (if v_435 then cipherstatepack(temp_k1_3,minnonce) else caught-fail) in
        {1263}let cs2_9: cipherstate = (if v_435 then cipherstatepack(temp_k2_3,minnonce) else caught-fail) in
        {1264}let v_436: bitstring = (if v_431 then catch-fail((if v_433 then (if v_435 then (ss_63,cs1_9,cs2_9) else fail-any) else fail-any)) else caught-fail) in
        {1265}let v_437: bool = (not-caught-fail(v_436) && success?(1-proj-3-tuple(v_436))) in
        {1266}let cs2_10: cipherstate = (if v_437 then 3-proj-3-tuple(v_436) else caught-fail) in
        {1267}let cs1_10: cipherstate = (if v_437 then 2-proj-3-tuple(v_436) else caught-fail) in
        {1268}let ssi_15: symmetricstate = (if v_437 then 1-proj-3-tuple(v_436) else caught-fail) in
        {1269}let (hs_15: handshakestate,plaintext_a_1: bitstring,valid_13: bool,cs1_11: cipherstate,cs2_11: cipherstate) = (if v_340 then (if v_342 then (if v_345 then (if v_353 then (if v_361 then (if v_378 then (if v_395 then (if v_403 then (if v_411 then (if v_428 then (if undo-catch-fail(v_431) then (if v_437 then (hs_14,plaintext_17,true,cs1_10,cs2_10) else fail-any) else fail-any) else fail-any) else fail-any) else fail-any) else fail-any) else fail-any) else fail-any) else fail-any) else fail-any) else fail-any) else fail-any) in
        {1270}event RecvMsg(me_4,them_3,stagepack_a(sid_4),plaintext_a_1);
        {1271}event RecvEnd(valid_13)
    ) | (
        {1273}event LeakS(phase0,me_4);
        {1274}event LeakM(phase0,me_4);
        {1275}out(pub, (key_s(me_4),key_m(me_4)))
    ) | (
        {1276}phase 1;
        {1277}event LeakS(phase1,me_4);
        {1278}event LeakM(phase1,me_4);
        {1279}out(pub, (key_s(me_4),key_m(me_4)))
    )
)

--  Process 1 (that is, process 0, with let moved downwards):
{1}out(pub, (key_s(charlie),key_m(charlie)));
{2}!
{3}new sid: sessionid;
(
    {8}let m: keypair = keypairpack(empty,empty) in
    {7}let s: keypair = keypairpack(empty,empty) in
    {9}out(pub, (getpublickey(s),getpublickey(m)));
    {6}let sid_1: sessionid = sid in
    {5}let them: principal = bob in
    {4}let me: principal = alice in
    (
        {11}let basis: key = key_s(them) in
        {12}let public_key: key = catch-fail(dhexp(basis,validkey(g))) in
        {13}let v: bool = not-caught-fail(public_key) in
        {14}let rs: key = getpublickey((if v then keypairpack(validkey(public_key),basis) else fail-any)) in
        {15}let basis_1: key = key_m(them) in
        {16}let public_key_1: key = catch-fail(dhexp(basis_1,validkey(g))) in
        {17}let v_1: bool = not-caught-fail(public_key_1) in
        {18}let rm: key = getpublickey((if v_1 then keypairpack(validkey(public_key_1),basis_1) else fail-any)) in
        {25}let k: key = empty in
        {26}let cs: cipherstate = cipherstatepack(k,minnonce) in
        {22}let protocol_name: bitstring = somename in
        {23}let h: bitstring = hash(protocol_name,empty) in
        {24}let ck: key = h in
        {27}let ss: symmetricstate = symmetricstatepack(cs,ck,h) in
        {28}let v_2: bitstring = catch-fail(symmetricstateunpack(ss)) in
        {29}let v_3: bool = (not-caught-fail(v_2) && success?(1-proj-3-tuple(v_2))) in
        {30}let h_1: bitstring = (if v_3 then 3-proj-3-tuple(v_2) else caught-fail) in
        {31}let ck_1: key = (if v_3 then 2-proj-3-tuple(v_2) else caught-fail) in
        {32}let cs_1: cipherstate = (if v_3 then 1-proj-3-tuple(v_2) else caught-fail) in
        {20}let prologue: bitstring = empty in
        {33}let ss_1: symmetricstate = catch-fail((if v_3 then symmetricstatepack(cs_1,ck_1,hash(h_1,prologue)) else fail-any)) in
        {34}let v_4: bool = not-caught-fail(ss_1) in
        {35}let v_5: bitstring = (if v_4 then catch-fail(symmetricstateunpack(ss_1)) else caught-fail) in
        {36}let v_6: bool = (not-caught-fail(v_5) && success?(1-proj-3-tuple(v_5))) in
        {37}let h_2: bitstring = (if v_6 then 3-proj-3-tuple(v_5) else caught-fail) in
        {38}let ck_2: key = (if v_6 then 2-proj-3-tuple(v_5) else caught-fail) in
        {39}let cs_2: cipherstate = (if v_6 then 1-proj-3-tuple(v_5) else caught-fail) in
        {40}let ss_2: symmetricstate = (if v_4 then catch-fail((if v_6 then symmetricstatepack(cs_2,ck_2,hash(h_2,rs)) else fail-any)) else caught-fail) in
        {41}let v_7: bool = not-caught-fail(ss_2) in
        {42}let v_8: bitstring = (if v_7 then catch-fail(symmetricstateunpack(ss_2)) else caught-fail) in
        {43}let v_9: bool = (not-caught-fail(v_8) && success?(1-proj-3-tuple(v_8))) in
        {44}let h_3: bitstring = (if v_9 then 3-proj-3-tuple(v_8) else caught-fail) in
        {45}let ck_3: key = (if v_9 then 2-proj-3-tuple(v_8) else caught-fail) in
        {46}let cs_3: cipherstate = (if v_9 then 1-proj-3-tuple(v_8) else caught-fail) in
        {47}let ss_3: symmetricstate = (if v_7 then catch-fail((if v_9 then symmetricstatepack(cs_3,ck_3,hash(h_3,rm)) else fail-any)) else caught-fail) in
        {48}let v_10: bool = not-caught-fail(ss_3) in
        {21}let psk: key = empty in
        {19}let re: key = empty in
        {10}let e: keypair = keypairpack(empty,empty) in
        {49}let hs: handshakestate = (if v_4 then (if v_7 then (if v_10 then handshakestatepack(ss_3,s,m,e,rs,rm,re,psk,true) else fail-any) else fail-any) else fail-any) in
        {50}insert statestore(me,them,sid_1,statepack_a(hs))
    ) | (
        {306}get statestore(=me,=them,=sid_1,statepack_a(hs_1: handshakestate)) in
        {52}let v_11: bitstring = catch-fail(handshakestateunpack(hs_1)) in
        {53}let v_12: bool = (not-caught-fail(v_11) && success?(1-proj-9-tuple(v_11))) in
        {54}let initiator_1: bool = (if v_12 then 9-proj-9-tuple(v_11) else caught-fail) in
        {55}let psk_1: key = (if v_12 then 8-proj-9-tuple(v_11) else caught-fail) in
        {56}let re_1: key = (if v_12 then 7-proj-9-tuple(v_11) else caught-fail) in
        {57}let rm_1: key = (if v_12 then 6-proj-9-tuple(v_11) else caught-fail) in
        {58}let rs_1: key = (if v_12 then 5-proj-9-tuple(v_11) else caught-fail) in
        {59}let e_1: keypair = (if v_12 then 4-proj-9-tuple(v_11) else caught-fail) in
        {60}let m_1: keypair = (if v_12 then 3-proj-9-tuple(v_11) else caught-fail) in
        {61}let s_1: keypair = (if v_12 then 2-proj-9-tuple(v_11) else caught-fail) in
        {62}let ss_4: symmetricstate = (if v_12 then 1-proj-9-tuple(v_11) else caught-fail) in
        {63}let v_13: bitstring = (if v_12 then catch-fail((empty,empty,empty,empty)) else caught-fail) in
        {64}let v_14: bool = (not-caught-fail(v_13) && success?(1-proj-4-tuple(v_13))) in
        {65}let ciphertext: bitstring = (if v_14 then 4-proj-4-tuple(v_13) else caught-fail) in
        {66}let nm: bitstring = (if v_14 then 3-proj-4-tuple(v_13) else caught-fail) in
        {67}let ns: bitstring = (if v_14 then 2-proj-4-tuple(v_13) else caught-fail) in
        {68}let ne: bitstring = (if v_14 then 1-proj-4-tuple(v_13) else caught-fail) in
        {69}let basis_2: key = (if v_14 then key_e(me,them,sid_1) else caught-fail) in
        {70}let public_key_2: key = (if v_14 then catch-fail(dhexp(basis_2,validkey(g))) else caught-fail) in
        {71}let v_15: bool = not-caught-fail(public_key_2) in
        {72}let e_2: keypair = (if v_14 then catch-fail((if v_15 then keypairpack(validkey(public_key_2),basis_2) else fail-any)) else caught-fail) in
        {73}let v_16: bool = not-caught-fail(e_2) in
        {74}let ne_1: bitstring = (if v_16 then catch-fail(getpublickey(e_2)) else caught-fail) in
        {75}let v_17: bool = not-caught-fail(ne_1) in
        {76}let v_18: bitstring = (if v_17 then catch-fail(symmetricstateunpack(ss_4)) else caught-fail) in
        {77}let v_19: bool = (not-caught-fail(v_18) && success?(1-proj-3-tuple(v_18))) in
        {78}let h_4: bitstring = (if v_19 then 3-proj-3-tuple(v_18) else caught-fail) in
        {79}let ck_4: key = (if v_19 then 2-proj-3-tuple(v_18) else caught-fail) in
        {80}let cs_4: cipherstate = (if v_19 then 1-proj-3-tuple(v_18) else caught-fail) in
        {81}let ss_5: symmetricstate = (if v_17 then catch-fail((if v_19 then symmetricstatepack(cs_4,ck_4,hash(h_4,ne_1)) else fail-any)) else caught-fail) in
        {82}let v_20: bool = not-caught-fail(ss_5) in
        {83}let v_21: bitstring = (if v_20 then catch-fail(keypairunpack(e_2)) else caught-fail) in
        {84}let v_22: bool = (not-caught-fail(v_21) && success?(1-proj-2-tuple(v_21))) in
        {85}let my_private_key: key = (if v_22 then 2-proj-2-tuple(v_21) else caught-fail) in
        {86}let my_public_key: key = (if v_22 then 1-proj-2-tuple(v_21) else caught-fail) in
        {87}let input_key_material: key = (if v_20 then catch-fail((if v_22 then dhexp(my_private_key,rs_1) else fail-any)) else caught-fail) in
        {88}let v_23: bool = not-caught-fail(input_key_material) in
        {89}let v_24: bitstring = (if v_23 then catch-fail(symmetricstateunpack(ss_5)) else caught-fail) in
        {90}let v_25: bool = (not-caught-fail(v_24) && success?(1-proj-3-tuple(v_24))) in
        {91}let h_5: bitstring = (if v_25 then 3-proj-3-tuple(v_24) else caught-fail) in
        {92}let ck_5: key = (if v_25 then 2-proj-3-tuple(v_24) else caught-fail) in
        {93}let cs_5: cipherstate = (if v_25 then 1-proj-3-tuple(v_24) else caught-fail) in
        {96}let output3: key = (if v_25 then hmac_hash3(ck_5,input_key_material) else caught-fail) in
        {95}let output2: key = (if v_25 then hmac_hash2(ck_5,input_key_material) else caught-fail) in
        {94}let output1: key = (if v_25 then hmac_hash1(ck_5,input_key_material) else caught-fail) in
        {97}let v_26: bitstring = (if v_25 then catch-fail((output1,output2,output3)) else caught-fail) in
        {98}let v_27: bool = (not-caught-fail(v_26) && success?(1-proj-3-tuple(v_26))) in
        {99}let output_3: key = (if v_27 then 3-proj-3-tuple(v_26) else caught-fail) in
        {100}let temp_k: key = (if v_27 then 2-proj-3-tuple(v_26) else caught-fail) in
        {101}let ck_6: key = (if v_27 then 1-proj-3-tuple(v_26) else caught-fail) in
        {102}let ss_6: symmetricstate = (if v_20 then catch-fail((if v_23 then (if v_25 then (if v_27 then symmetricstatepack(cipherstatepack(temp_k,minnonce),ck_6,h_5) else fail-any) else fail-any) else fail-any)) else caught-fail) in
        {103}let v_28: bool = not-caught-fail(ss_6) in
        {104}let v_29: bitstring = (if v_28 then catch-fail(keypairunpack(e_2)) else caught-fail) in
        {105}let v_30: bool = (not-caught-fail(v_29) && success?(1-proj-2-tuple(v_29))) in
        {106}let my_private_key_1: key = (if v_30 then 2-proj-2-tuple(v_29) else caught-fail) in
        {107}let my_public_key_1: key = (if v_30 then 1-proj-2-tuple(v_29) else caught-fail) in
        {108}let input_key_material_1: key = (if v_28 then catch-fail((if v_30 then dhexp(my_private_key_1,rm_1) else fail-any)) else caught-fail) in
        {109}let v_31: bool = not-caught-fail(input_key_material_1) in
        {110}let v_32: bitstring = (if v_31 then catch-fail(symmetricstateunpack(ss_6)) else caught-fail) in
        {111}let v_33: bool = (not-caught-fail(v_32) && success?(1-proj-3-tuple(v_32))) in
        {112}let h_6: bitstring = (if v_33 then 3-proj-3-tuple(v_32) else caught-fail) in
        {113}let ck_7: key = (if v_33 then 2-proj-3-tuple(v_32) else caught-fail) in
        {114}let cs_6: cipherstate = (if v_33 then 1-proj-3-tuple(v_32) else caught-fail) in
        {117}let output3_1: key = (if v_33 then hmac_hash3(ck_7,input_key_material_1) else caught-fail) in
        {116}let output2_1: key = (if v_33 then hmac_hash2(ck_7,input_key_material_1) else caught-fail) in
        {115}let output1_1: key = (if v_33 then hmac_hash1(ck_7,input_key_material_1) else caught-fail) in
        {118}let v_34: bitstring = (if v_33 then catch-fail((output1_1,output2_1,output3_1)) else caught-fail) in
        {119}let v_35: bool = (not-caught-fail(v_34) && success?(1-proj-3-tuple(v_34))) in
        {120}let output: key = (if v_35 then 3-proj-3-tuple(v_34) else caught-fail) in
        {121}let temp_k_1: key = (if v_35 then 2-proj-3-tuple(v_34) else caught-fail) in
        {122}let ck_8: key = (if v_35 then 1-proj-3-tuple(v_34) else caught-fail) in
        {123}let ss_7: symmetricstate = (if v_28 then catch-fail((if v_31 then (if v_33 then (if v_35 then symmetricstatepack(cipherstatepack(temp_k_1,minnonce),ck_8,h_6) else fail-any) else fail-any) else fail-any)) else caught-fail) in
        {124}let v_36: bool = not-caught-fail(ss_7) in
        {125}let basis_3: key = (if v_36 then key_s(me) else caught-fail) in
        {126}let public_key_3: key = (if v_36 then catch-fail(dhexp(basis_3,validkey(g))) else caught-fail) in
        {127}let v_37: bool = not-caught-fail(public_key_3) in
        {128}let s_2: keypair = (if v_36 then catch-fail((if v_37 then keypairpack(validkey(public_key_3),basis_3) else fail-any)) else caught-fail) in
        {129}let v_38: bool = not-caught-fail(s_2) in
        {130}let plaintext: bitstring = (if v_38 then catch-fail(getpublickey(s_2)) else caught-fail) in
        {131}let v_39: bool = not-caught-fail(plaintext) in
        {132}let v_40: bitstring = (if v_39 then catch-fail(symmetricstateunpack(ss_7)) else caught-fail) in
        {133}let v_41: bool = (not-caught-fail(v_40) && success?(1-proj-3-tuple(v_40))) in
        {134}let h_7: bitstring = (if v_41 then 3-proj-3-tuple(v_40) else caught-fail) in
        {135}let ck_9: key = (if v_41 then 2-proj-3-tuple(v_40) else caught-fail) in
        {136}let cs_7: cipherstate = (if v_41 then 1-proj-3-tuple(v_40) else caught-fail) in
        {137}let v_42: bitstring = (if v_41 then catch-fail(cipherstateunpack(cs_7)) else caught-fail) in
        {138}let v_43: bool = (not-caught-fail(v_42) && success?(1-proj-2-tuple(v_42))) in
        {139}let n: nonce = (if v_43 then 2-proj-2-tuple(v_42) else caught-fail) in
        {140}let k_1: key = (if v_43 then 1-proj-2-tuple(v_42) else caught-fail) in
        {143}let v_44: bitstring = (if v_43 then catch-fail(cipherstateunpack(cs_7)) else caught-fail) in
        {144}let v_45: bool = (not-caught-fail(v_44) && success?(1-proj-2-tuple(v_44))) in
        {145}let o: nonce = (if v_45 then 2-proj-2-tuple(v_44) else caught-fail) in
        {146}let k_2: key = (if v_45 then 1-proj-2-tuple(v_44) else caught-fail) in
        {142}let n_1: nonce = (if v_43 then increment_nonce(n) else caught-fail) in
        {147}let csi: cipherstate = (if v_43 then catch-fail((if v_45 then cipherstatepack(k_2,n_1) else fail-any)) else caught-fail) in
        {148}let v_46: bool = not-caught-fail(csi) in
        {141}let e_3: bitstring = (if v_43 then encrypt(k_1,n,h_7,plaintext) else caught-fail) in
        {149}let v_47: bitstring = (if v_41 then catch-fail((if v_43 then (if v_46 then (csi,e_3) else fail-any) else fail-any)) else caught-fail) in
        {150}let v_48: bool = (not-caught-fail(v_47) && success?(1-proj-2-tuple(v_47))) in
        {151}let ciphertext_1: bitstring = (if v_48 then 2-proj-2-tuple(v_47) else caught-fail) in
        {152}let csi_1: cipherstate = (if v_48 then 1-proj-2-tuple(v_47) else caught-fail) in
        {153}let ss_8: symmetricstate = (if v_48 then symmetricstatepack(csi_1,ck_9,h_7) else caught-fail) in
        {154}let v_49: bitstring = (if v_48 then catch-fail(symmetricstateunpack(ss_8)) else caught-fail) in
        {155}let v_50: bool = (not-caught-fail(v_49) && success?(1-proj-3-tuple(v_49))) in
        {156}let h_8: bitstring = (if v_50 then 3-proj-3-tuple(v_49) else caught-fail) in
        {157}let ck_10: key = (if v_50 then 2-proj-3-tuple(v_49) else caught-fail) in
        {158}let cs_8: cipherstate = (if v_50 then 1-proj-3-tuple(v_49) else caught-fail) in
        {159}let ssi: symmetricstate = (if v_48 then catch-fail((if v_50 then symmetricstatepack(cs_8,ck_10,hash(h_8,ciphertext_1)) else fail-any)) else caught-fail) in
        {160}let v_51: bool = not-caught-fail(ssi) in
        {161}let v_52: bitstring = (if v_38 then catch-fail((if v_39 then (if v_41 then (if v_48 then (if v_51 then (ssi,ciphertext_1) else fail-any) else fail-any) else fail-any) else fail-any)) else caught-fail) in
        {162}let v_53: bool = (not-caught-fail(v_52) && success?(1-proj-2-tuple(v_52))) in
        {163}let ns_1: bitstring = (if v_53 then 2-proj-2-tuple(v_52) else caught-fail) in
        {164}let ss_9: symmetricstate = (if v_53 then 1-proj-2-tuple(v_52) else caught-fail) in
        {165}let basis_4: key = (if v_53 then key_m(me) else caught-fail) in
        {166}let public_key_4: key = (if v_53 then catch-fail(dhexp(basis_4,validkey(g))) else caught-fail) in
        {167}let v_54: bool = not-caught-fail(public_key_4) in
        {168}let m_2: keypair = (if v_53 then catch-fail((if v_54 then keypairpack(validkey(public_key_4),basis_4) else fail-any)) else caught-fail) in
        {169}let v_55: bool = not-caught-fail(m_2) in
        {170}let plaintext_1: bitstring = (if v_55 then catch-fail(getpublickey(m_2)) else caught-fail) in
        {171}let v_56: bool = not-caught-fail(plaintext_1) in
        {172}let v_57: bitstring = (if v_56 then catch-fail(symmetricstateunpack(ss_9)) else caught-fail) in
        {173}let v_58: bool = (not-caught-fail(v_57) && success?(1-proj-3-tuple(v_57))) in
        {174}let h_9: bitstring = (if v_58 then 3-proj-3-tuple(v_57) else caught-fail) in
        {175}let ck_11: key = (if v_58 then 2-proj-3-tuple(v_57) else caught-fail) in
        {176}let cs_9: cipherstate = (if v_58 then 1-proj-3-tuple(v_57) else caught-fail) in
        {177}let v_59: bitstring = (if v_58 then catch-fail(cipherstateunpack(cs_9)) else caught-fail) in
        {178}let v_60: bool = (not-caught-fail(v_59) && success?(1-proj-2-tuple(v_59))) in
        {179}let n_2: nonce = (if v_60 then 2-proj-2-tuple(v_59) else caught-fail) in
        {180}let k_3: key = (if v_60 then 1-proj-2-tuple(v_59) else caught-fail) in
        {183}let v_61: bitstring = (if v_60 then catch-fail(cipherstateunpack(cs_9)) else caught-fail) in
        {184}let v_62: bool = (not-caught-fail(v_61) && success?(1-proj-2-tuple(v_61))) in
        {185}let o_1: nonce = (if v_62 then 2-proj-2-tuple(v_61) else caught-fail) in
        {186}let k_4: key = (if v_62 then 1-proj-2-tuple(v_61) else caught-fail) in
        {182}let n_3: nonce = (if v_60 then increment_nonce(n_2) else caught-fail) in
        {187}let csi_2: cipherstate = (if v_60 then catch-fail((if v_62 then cipherstatepack(k_4,n_3) else fail-any)) else caught-fail) in
        {188}let v_63: bool = not-caught-fail(csi_2) in
        {181}let e_4: bitstring = (if v_60 then encrypt(k_3,n_2,h_9,plaintext_1) else caught-fail) in
        {189}let v_64: bitstring = (if v_58 then catch-fail((if v_60 then (if v_63 then (csi_2,e_4) else fail-any) else fail-any)) else caught-fail) in
        {190}let v_65: bool = (not-caught-fail(v_64) && success?(1-proj-2-tuple(v_64))) in
        {191}let ciphertext_2: bitstring = (if v_65 then 2-proj-2-tuple(v_64) else caught-fail) in
        {192}let csi_3: cipherstate = (if v_65 then 1-proj-2-tuple(v_64) else caught-fail) in
        {193}let ss_10: symmetricstate = (if v_65 then symmetricstatepack(csi_3,ck_11,h_9) else caught-fail) in
        {194}let v_66: bitstring = (if v_65 then catch-fail(symmetricstateunpack(ss_10)) else caught-fail) in
        {195}let v_67: bool = (not-caught-fail(v_66) && success?(1-proj-3-tuple(v_66))) in
        {196}let h_10: bitstring = (if v_67 then 3-proj-3-tuple(v_66) else caught-fail) in
        {197}let ck_12: key = (if v_67 then 2-proj-3-tuple(v_66) else caught-fail) in
        {198}let cs_10: cipherstate = (if v_67 then 1-proj-3-tuple(v_66) else caught-fail) in
        {199}let ssi_1: symmetricstate = (if v_65 then catch-fail((if v_67 then symmetricstatepack(cs_10,ck_12,hash(h_10,ciphertext_2)) else fail-any)) else caught-fail) in
        {200}let v_68: bool = not-caught-fail(ssi_1) in
        {201}let v_69: bitstring = (if v_55 then catch-fail((if v_56 then (if v_58 then (if v_65 then (if v_68 then (ssi_1,ciphertext_2) else fail-any) else fail-any) else fail-any) else fail-any)) else caught-fail) in
        {202}let v_70: bool = (not-caught-fail(v_69) && success?(1-proj-2-tuple(v_69))) in
        {203}let nm_1: bitstring = (if v_70 then 2-proj-2-tuple(v_69) else caught-fail) in
        {204}let ss_11: symmetricstate = (if v_70 then 1-proj-2-tuple(v_69) else caught-fail) in
        {205}let v_71: bitstring = (if v_70 then catch-fail(keypairunpack(m_2)) else caught-fail) in
        {206}let v_72: bool = (not-caught-fail(v_71) && success?(1-proj-2-tuple(v_71))) in
        {207}let my_private_key_2: key = (if v_72 then 2-proj-2-tuple(v_71) else caught-fail) in
        {208}let my_public_key_2: key = (if v_72 then 1-proj-2-tuple(v_71) else caught-fail) in
        {209}let input_key_material_2: key = (if v_70 then catch-fail((if v_72 then dhexp(my_private_key_2,rs_1) else fail-any)) else caught-fail) in
        {210}let v_73: bool = not-caught-fail(input_key_material_2) in
        {211}let v_74: bitstring = (if v_73 then catch-fail(symmetricstateunpack(ss_11)) else caught-fail) in
        {212}let v_75: bool = (not-caught-fail(v_74) && success?(1-proj-3-tuple(v_74))) in
        {213}let h_11: bitstring = (if v_75 then 3-proj-3-tuple(v_74) else caught-fail) in
        {214}let ck_13: key = (if v_75 then 2-proj-3-tuple(v_74) else caught-fail) in
        {215}let cs_11: cipherstate = (if v_75 then 1-proj-3-tuple(v_74) else caught-fail) in
        {218}let output3_2: key = (if v_75 then hmac_hash3(ck_13,input_key_material_2) else caught-fail) in
        {217}let output2_2: key = (if v_75 then hmac_hash2(ck_13,input_key_material_2) else caught-fail) in
        {216}let output1_2: key = (if v_75 then hmac_hash1(ck_13,input_key_material_2) else caught-fail) in
        {219}let v_76: bitstring = (if v_75 then catch-fail((output1_2,output2_2,output3_2)) else caught-fail) in
        {220}let v_77: bool = (not-caught-fail(v_76) && success?(1-proj-3-tuple(v_76))) in
        {221}let output_1: key = (if v_77 then 3-proj-3-tuple(v_76) else caught-fail) in
        {222}let temp_k_2: key = (if v_77 then 2-proj-3-tuple(v_76) else caught-fail) in
        {223}let ck_14: key = (if v_77 then 1-proj-3-tuple(v_76) else caught-fail) in
        {224}let ss_12: symmetricstate = (if v_70 then catch-fail((if v_73 then (if v_75 then (if v_77 then symmetricstatepack(cipherstatepack(temp_k_2,minnonce),ck_14,h_11) else fail-any) else fail-any) else fail-any)) else caught-fail) in
        {225}let v_78: bool = not-caught-fail(ss_12) in
        {226}let v_79: bitstring = (if v_78 then catch-fail(keypairunpack(s_2)) else caught-fail) in
        {227}let v_80: bool = (not-caught-fail(v_79) && success?(1-proj-2-tuple(v_79))) in
        {228}let my_private_key_3: key = (if v_80 then 2-proj-2-tuple(v_79) else caught-fail) in
        {229}let my_public_key_3: key = (if v_80 then 1-proj-2-tuple(v_79) else caught-fail) in
        {230}let input_key_material_3: key = (if v_78 then catch-fail((if v_80 then dhexp(my_private_key_3,rm_1) else fail-any)) else caught-fail) in
        {231}let v_81: bool = not-caught-fail(input_key_material_3) in
        {232}let v_82: bitstring = (if v_81 then catch-fail(symmetricstateunpack(ss_12)) else caught-fail) in
        {233}let v_83: bool = (not-caught-fail(v_82) && success?(1-proj-3-tuple(v_82))) in
        {234}let h_12: bitstring = (if v_83 then 3-proj-3-tuple(v_82) else caught-fail) in
        {235}let ck_15: key = (if v_83 then 2-proj-3-tuple(v_82) else caught-fail) in
        {236}let cs_12: cipherstate = (if v_83 then 1-proj-3-tuple(v_82) else caught-fail) in
        {239}let output3_3: key = (if v_83 then hmac_hash3(ck_15,input_key_material_3) else caught-fail) in
        {238}let output2_3: key = (if v_83 then hmac_hash2(ck_15,input_key_material_3) else caught-fail) in
        {237}let output1_3: key = (if v_83 then hmac_hash1(ck_15,input_key_material_3) else caught-fail) in
        {240}let v_84: bitstring = (if v_83 then catch-fail((output1_3,output2_3,output3_3)) else caught-fail) in
        {241}let v_85: bool = (not-caught-fail(v_84) && success?(1-proj-3-tuple(v_84))) in
        {242}let output_2: key = (if v_85 then 3-proj-3-tuple(v_84) else caught-fail) in
        {243}let temp_k_3: key = (if v_85 then 2-proj-3-tuple(v_84) else caught-fail) in
        {244}let ck_16: key = (if v_85 then 1-proj-3-tuple(v_84) else caught-fail) in
        {245}let ss_13: symmetricstate = (if v_78 then catch-fail((if v_81 then (if v_83 then (if v_85 then symmetricstatepack(cipherstatepack(temp_k_3,minnonce),ck_16,h_12) else fail-any) else fail-any) else fail-any)) else caught-fail) in
        {246}let v_86: bool = not-caught-fail(ss_13) in
        {247}let v_87: bitstring = (if v_86 then catch-fail(symmetricstateunpack(ss_13)) else caught-fail) in
        {248}let v_88: bool = (not-caught-fail(v_87) && success?(1-proj-3-tuple(v_87))) in
        {249}let h_13: bitstring = (if v_88 then 3-proj-3-tuple(v_87) else caught-fail) in
        {250}let ck_17: key = (if v_88 then 2-proj-3-tuple(v_87) else caught-fail) in
        {251}let cs_13: cipherstate = (if v_88 then 1-proj-3-tuple(v_87) else caught-fail) in
        {252}let v_89: bitstring = (if v_88 then catch-fail(cipherstateunpack(cs_13)) else caught-fail) in
        {253}let v_90: bool = (not-caught-fail(v_89) && success?(1-proj-2-tuple(v_89))) in
        {254}let n_4: nonce = (if v_90 then 2-proj-2-tuple(v_89) else caught-fail) in
        {255}let k_5: key = (if v_90 then 1-proj-2-tuple(v_89) else caught-fail) in
        {258}let v_91: bitstring = (if v_90 then catch-fail(cipherstateunpack(cs_13)) else caught-fail) in
        {259}let v_92: bool = (not-caught-fail(v_91) && success?(1-proj-2-tuple(v_91))) in
        {260}let o_2: nonce = (if v_92 then 2-proj-2-tuple(v_91) else caught-fail) in
        {261}let k_6: key = (if v_92 then 1-proj-2-tuple(v_91) else caught-fail) in
        {257}let n_5: nonce = (if v_90 then increment_nonce(n_4) else caught-fail) in
        {262}let csi_4: cipherstate = (if v_90 then catch-fail((if v_92 then cipherstatepack(k_6,n_5) else fail-any)) else caught-fail) in
        {263}let v_93: bool = not-caught-fail(csi_4) in
        {51}let payload: bitstring = msg_a(me,them,sid_1) in
        {256}let e_5: bitstring = (if v_90 then encrypt(k_5,n_4,h_13,payload) else caught-fail) in
        {264}let v_94: bitstring = (if v_88 then catch-fail((if v_90 then (if v_93 then (csi_4,e_5) else fail-any) else fail-any)) else caught-fail) in
        {265}let v_95: bool = (not-caught-fail(v_94) && success?(1-proj-2-tuple(v_94))) in
        {266}let ciphertext_3: bitstring = (if v_95 then 2-proj-2-tuple(v_94) else caught-fail) in
        {267}let csi_5: cipherstate = (if v_95 then 1-proj-2-tuple(v_94) else caught-fail) in
        {268}let ss_14: symmetricstate = (if v_95 then symmetricstatepack(csi_5,ck_17,h_13) else caught-fail) in
        {269}let v_96: bitstring = (if v_95 then catch-fail(symmetricstateunpack(ss_14)) else caught-fail) in
        {270}let v_97: bool = (not-caught-fail(v_96) && success?(1-proj-3-tuple(v_96))) in
        {271}let h_14: bitstring = (if v_97 then 3-proj-3-tuple(v_96) else caught-fail) in
        {272}let ck_18: key = (if v_97 then 2-proj-3-tuple(v_96) else caught-fail) in
        {273}let cs_14: cipherstate = (if v_97 then 1-proj-3-tuple(v_96) else caught-fail) in
        {274}let ssi_2: symmetricstate = (if v_95 then catch-fail((if v_97 then symmetricstatepack(cs_14,ck_18,hash(h_14,ciphertext_3)) else fail-any)) else caught-fail) in
        {275}let v_98: bool = not-caught-fail(ssi_2) in
        {276}let v_99: bitstring = (if v_86 then catch-fail((if v_88 then (if v_95 then (if v_98 then (ssi_2,ciphertext_3) else fail-any) else fail-any) else fail-any)) else caught-fail) in
        {277}let v_100: bool = (not-caught-fail(v_99) && success?(1-proj-2-tuple(v_99))) in
        {278}let ciphertext_4: bitstring = (if v_100 then 2-proj-2-tuple(v_99) else caught-fail) in
        {279}let ss_15: symmetricstate = (if v_100 then 1-proj-2-tuple(v_99) else caught-fail) in
        {282}let v_101: bitstring = (if v_100 then catch-fail(symmetricstateunpack(ss_15)) else caught-fail) in
        {283}let v_102: bool = (not-caught-fail(v_101) && success?(1-proj-3-tuple(v_101))) in
        {284}let h_15: bitstring = (if v_102 then 3-proj-3-tuple(v_101) else caught-fail) in
        {285}let ck_19: key = (if v_102 then 2-proj-3-tuple(v_101) else caught-fail) in
        {286}let cs_15: cipherstate = (if v_102 then 1-proj-3-tuple(v_101) else caught-fail) in
        {287}let input_key_material_4: key = (if v_102 then zero else caught-fail) in
        {290}let output3_4: key = (if v_102 then hmac_hash3(ck_19,input_key_material_4) else caught-fail) in
        {289}let output2_4: key = (if v_102 then hmac_hash2(ck_19,input_key_material_4) else caught-fail) in
        {288}let output1_4: key = (if v_102 then hmac_hash1(ck_19,input_key_material_4) else caught-fail) in
        {291}let v_103: bitstring = (if v_102 then catch-fail((output1_4,output2_4,output3_4)) else caught-fail) in
        {292}let v_104: bool = (not-caught-fail(v_103) && success?(1-proj-3-tuple(v_103))) in
        {293}let temp_k3: key = (if v_104 then 3-proj-3-tuple(v_103) else caught-fail) in
        {294}let temp_k2: key = (if v_104 then 2-proj-3-tuple(v_103) else caught-fail) in
        {295}let temp_k1: key = (if v_104 then 1-proj-3-tuple(v_103) else caught-fail) in
        {297}let cs2: cipherstate = (if v_104 then cipherstatepack(temp_k2,minnonce) else caught-fail) in
        {296}let cs1: cipherstate = (if v_104 then cipherstatepack(temp_k1,minnonce) else caught-fail) in
        {298}let v_105: bitstring = (if v_100 then catch-fail((if v_102 then (if v_104 then (ss_15,cs1,cs2) else fail-any) else fail-any)) else caught-fail) in
        {299}let v_106: bool = (not-caught-fail(v_105) && success?(1-proj-3-tuple(v_105))) in
        {300}let cs2_1: cipherstate = (if v_106 then 3-proj-3-tuple(v_105) else caught-fail) in
        {301}let cs1_1: cipherstate = (if v_106 then 2-proj-3-tuple(v_105) else caught-fail) in
        {302}let ssi_3: symmetricstate = (if v_106 then 1-proj-3-tuple(v_105) else caught-fail) in
        {281}let message_buffer: bitstring = (if v_100 then concat4(ne_1,ns_1,nm_1,ciphertext_4) else caught-fail) in
        {280}let hs_2: handshakestate = (if v_100 then handshakestatepack(ss_15,s_2,m_2,e_2,rs_1,rm_1,re_1,psk_1,initiator_1) else caught-fail) in
        {303}let (hs_3: handshakestate,message_a: bitstring,cs1_2: cipherstate,cs2_2: cipherstate) = (if v_12 then (if v_14 then (if v_16 then (if v_17 then (if v_20 then (if v_28 then (if v_36 then (if v_38 then (if v_53 then (if v_55 then (if v_70 then (if v_78 then (if v_86 then (if v_100 then (if v_106 then (hs_2,message_buffer,cs1_1,cs2_1) else fail-any) else fail-any) else fail-any) else fail-any) else fail-any) else fail-any) else fail-any) else fail-any) else fail-any) else fail-any) else fail-any) else fail-any) else fail-any) else fail-any) else fail-any) in
        {304}event SendMsg(me,them,stagepack_a(sid_1),msg_a(me,them,sid_1));
        {305}out(pub, message_a)
    ) | (
        {307}event LeakS(phase0,me);
        {308}event LeakM(phase0,me);
        {309}out(pub, (key_s(me),key_m(me)))
    ) | (
        {310}phase 1;
        {311}event LeakS(phase1,me);
        {312}event LeakM(phase1,me);
        {313}out(pub, (key_s(me),key_m(me)))
    )
) | (
    {318}let m_3: keypair = keypairpack(empty,empty) in
    {317}let s_3: keypair = keypairpack(empty,empty) in
    {319}out(pub, (getpublickey(s_3),getpublickey(m_3)));
    {316}let sid_2: sessionid = sid in
    {315}let them_1: principal = charlie in
    {314}let me_1: principal = alice in
    (
        {321}let basis_5: key = key_s(them_1) in
        {322}let public_key_5: key = catch-fail(dhexp(basis_5,validkey(g))) in
        {323}let v_107: bool = not-caught-fail(public_key_5) in
        {324}let rs_2: key = getpublickey((if v_107 then keypairpack(validkey(public_key_5),basis_5) else fail-any)) in
        {325}let basis_6: key = key_m(them_1) in
        {326}let public_key_6: key = catch-fail(dhexp(basis_6,validkey(g))) in
        {327}let v_108: bool = not-caught-fail(public_key_6) in
        {328}let rm_2: key = getpublickey((if v_108 then keypairpack(validkey(public_key_6),basis_6) else fail-any)) in
        {335}let k_7: key = empty in
        {336}let cs_16: cipherstate = cipherstatepack(k_7,minnonce) in
        {332}let protocol_name_1: bitstring = somename in
        {333}let h_16: bitstring = hash(protocol_name_1,empty) in
        {334}let ck_20: key = h_16 in
        {337}let ss_16: symmetricstate = symmetricstatepack(cs_16,ck_20,h_16) in
        {338}let v_109: bitstring = catch-fail(symmetricstateunpack(ss_16)) in
        {339}let v_110: bool = (not-caught-fail(v_109) && success?(1-proj-3-tuple(v_109))) in
        {340}let h_17: bitstring = (if v_110 then 3-proj-3-tuple(v_109) else caught-fail) in
        {341}let ck_21: key = (if v_110 then 2-proj-3-tuple(v_109) else caught-fail) in
        {342}let cs_17: cipherstate = (if v_110 then 1-proj-3-tuple(v_109) else caught-fail) in
        {330}let prologue_1: bitstring = empty in
        {343}let ss_17: symmetricstate = catch-fail((if v_110 then symmetricstatepack(cs_17,ck_21,hash(h_17,prologue_1)) else fail-any)) in
        {344}let v_111: bool = not-caught-fail(ss_17) in
        {345}let v_112: bitstring = (if v_111 then catch-fail(symmetricstateunpack(ss_17)) else caught-fail) in
        {346}let v_113: bool = (not-caught-fail(v_112) && success?(1-proj-3-tuple(v_112))) in
        {347}let h_18: bitstring = (if v_113 then 3-proj-3-tuple(v_112) else caught-fail) in
        {348}let ck_22: key = (if v_113 then 2-proj-3-tuple(v_112) else caught-fail) in
        {349}let cs_18: cipherstate = (if v_113 then 1-proj-3-tuple(v_112) else caught-fail) in
        {350}let ss_18: symmetricstate = (if v_111 then catch-fail((if v_113 then symmetricstatepack(cs_18,ck_22,hash(h_18,rs_2)) else fail-any)) else caught-fail) in
        {351}let v_114: bool = not-caught-fail(ss_18) in
        {352}let v_115: bitstring = (if v_114 then catch-fail(symmetricstateunpack(ss_18)) else caught-fail) in
        {353}let v_116: bool = (not-caught-fail(v_115) && success?(1-proj-3-tuple(v_115))) in
        {354}let h_19: bitstring = (if v_116 then 3-proj-3-tuple(v_115) else caught-fail) in
        {355}let ck_23: key = (if v_116 then 2-proj-3-tuple(v_115) else caught-fail) in
        {356}let cs_19: cipherstate = (if v_116 then 1-proj-3-tuple(v_115) else caught-fail) in
        {357}let ss_19: symmetricstate = (if v_114 then catch-fail((if v_116 then symmetricstatepack(cs_19,ck_23,hash(h_19,rm_2)) else fail-any)) else caught-fail) in
        {358}let v_117: bool = not-caught-fail(ss_19) in
        {331}let psk_2: key = empty in
        {329}let re_2: key = empty in
        {320}let e_6: keypair = keypairpack(empty,empty) in
        {359}let hs_4: handshakestate = (if v_111 then (if v_114 then (if v_117 then handshakestatepack(ss_19,s_3,m_3,e_6,rs_2,rm_2,re_2,psk_2,true) else fail-any) else fail-any) else fail-any) in
        {360}insert statestore(me_1,them_1,sid_2,statepack_a(hs_4))
    ) | (
        {616}get statestore(=me_1,=them_1,=sid_2,statepack_a(hs_5: handshakestate)) in
        {362}let v_118: bitstring = catch-fail(handshakestateunpack(hs_5)) in
        {363}let v_119: bool = (not-caught-fail(v_118) && success?(1-proj-9-tuple(v_118))) in
        {364}let initiator_2: bool = (if v_119 then 9-proj-9-tuple(v_118) else caught-fail) in
        {365}let psk_3: key = (if v_119 then 8-proj-9-tuple(v_118) else caught-fail) in
        {366}let re_3: key = (if v_119 then 7-proj-9-tuple(v_118) else caught-fail) in
        {367}let rm_3: key = (if v_119 then 6-proj-9-tuple(v_118) else caught-fail) in
        {368}let rs_3: key = (if v_119 then 5-proj-9-tuple(v_118) else caught-fail) in
        {369}let e_7: keypair = (if v_119 then 4-proj-9-tuple(v_118) else caught-fail) in
        {370}let m_4: keypair = (if v_119 then 3-proj-9-tuple(v_118) else caught-fail) in
        {371}let s_4: keypair = (if v_119 then 2-proj-9-tuple(v_118) else caught-fail) in
        {372}let ss_20: symmetricstate = (if v_119 then 1-proj-9-tuple(v_118) else caught-fail) in
        {373}let v_120: bitstring = (if v_119 then catch-fail((empty,empty,empty,empty)) else caught-fail) in
        {374}let v_121: bool = (not-caught-fail(v_120) && success?(1-proj-4-tuple(v_120))) in
        {375}let ciphertext_5: bitstring = (if v_121 then 4-proj-4-tuple(v_120) else caught-fail) in
        {376}let nm_2: bitstring = (if v_121 then 3-proj-4-tuple(v_120) else caught-fail) in
        {377}let ns_2: bitstring = (if v_121 then 2-proj-4-tuple(v_120) else caught-fail) in
        {378}let ne_2: bitstring = (if v_121 then 1-proj-4-tuple(v_120) else caught-fail) in
        {379}let basis_7: key = (if v_121 then key_e(me_1,them_1,sid_2) else caught-fail) in
        {380}let public_key_7: key = (if v_121 then catch-fail(dhexp(basis_7,validkey(g))) else caught-fail) in
        {381}let v_122: bool = not-caught-fail(public_key_7) in
        {382}let e_8: keypair = (if v_121 then catch-fail((if v_122 then keypairpack(validkey(public_key_7),basis_7) else fail-any)) else caught-fail) in
        {383}let v_123: bool = not-caught-fail(e_8) in
        {384}let ne_3: bitstring = (if v_123 then catch-fail(getpublickey(e_8)) else caught-fail) in
        {385}let v_124: bool = not-caught-fail(ne_3) in
        {386}let v_125: bitstring = (if v_124 then catch-fail(symmetricstateunpack(ss_20)) else caught-fail) in
        {387}let v_126: bool = (not-caught-fail(v_125) && success?(1-proj-3-tuple(v_125))) in
        {388}let h_20: bitstring = (if v_126 then 3-proj-3-tuple(v_125) else caught-fail) in
        {389}let ck_24: key = (if v_126 then 2-proj-3-tuple(v_125) else caught-fail) in
        {390}let cs_20: cipherstate = (if v_126 then 1-proj-3-tuple(v_125) else caught-fail) in
        {391}let ss_21: symmetricstate = (if v_124 then catch-fail((if v_126 then symmetricstatepack(cs_20,ck_24,hash(h_20,ne_3)) else fail-any)) else caught-fail) in
        {392}let v_127: bool = not-caught-fail(ss_21) in
        {393}let v_128: bitstring = (if v_127 then catch-fail(keypairunpack(e_8)) else caught-fail) in
        {394}let v_129: bool = (not-caught-fail(v_128) && success?(1-proj-2-tuple(v_128))) in
        {395}let my_private_key_4: key = (if v_129 then 2-proj-2-tuple(v_128) else caught-fail) in
        {396}let my_public_key_4: key = (if v_129 then 1-proj-2-tuple(v_128) else caught-fail) in
        {397}let input_key_material_5: key = (if v_127 then catch-fail((if v_129 then dhexp(my_private_key_4,rs_3) else fail-any)) else caught-fail) in
        {398}let v_130: bool = not-caught-fail(input_key_material_5) in
        {399}let v_131: bitstring = (if v_130 then catch-fail(symmetricstateunpack(ss_21)) else caught-fail) in
        {400}let v_132: bool = (not-caught-fail(v_131) && success?(1-proj-3-tuple(v_131))) in
        {401}let h_21: bitstring = (if v_132 then 3-proj-3-tuple(v_131) else caught-fail) in
        {402}let ck_25: key = (if v_132 then 2-proj-3-tuple(v_131) else caught-fail) in
        {403}let cs_21: cipherstate = (if v_132 then 1-proj-3-tuple(v_131) else caught-fail) in
        {406}let output3_5: key = (if v_132 then hmac_hash3(ck_25,input_key_material_5) else caught-fail) in
        {405}let output2_5: key = (if v_132 then hmac_hash2(ck_25,input_key_material_5) else caught-fail) in
        {404}let output1_5: key = (if v_132 then hmac_hash1(ck_25,input_key_material_5) else caught-fail) in
        {407}let v_133: bitstring = (if v_132 then catch-fail((output1_5,output2_5,output3_5)) else caught-fail) in
        {408}let v_134: bool = (not-caught-fail(v_133) && success?(1-proj-3-tuple(v_133))) in
        {409}let output_4: key = (if v_134 then 3-proj-3-tuple(v_133) else caught-fail) in
        {410}let temp_k_4: key = (if v_134 then 2-proj-3-tuple(v_133) else caught-fail) in
        {411}let ck_26: key = (if v_134 then 1-proj-3-tuple(v_133) else caught-fail) in
        {412}let ss_22: symmetricstate = (if v_127 then catch-fail((if v_130 then (if v_132 then (if v_134 then symmetricstatepack(cipherstatepack(temp_k_4,minnonce),ck_26,h_21) else fail-any) else fail-any) else fail-any)) else caught-fail) in
        {413}let v_135: bool = not-caught-fail(ss_22) in
        {414}let v_136: bitstring = (if v_135 then catch-fail(keypairunpack(e_8)) else caught-fail) in
        {415}let v_137: bool = (not-caught-fail(v_136) && success?(1-proj-2-tuple(v_136))) in
        {416}let my_private_key_5: key = (if v_137 then 2-proj-2-tuple(v_136) else caught-fail) in
        {417}let my_public_key_5: key = (if v_137 then 1-proj-2-tuple(v_136) else caught-fail) in
        {418}let input_key_material_6: key = (if v_135 then catch-fail((if v_137 then dhexp(my_private_key_5,rm_3) else fail-any)) else caught-fail) in
        {419}let v_138: bool = not-caught-fail(input_key_material_6) in
        {420}let v_139: bitstring = (if v_138 then catch-fail(symmetricstateunpack(ss_22)) else caught-fail) in
        {421}let v_140: bool = (not-caught-fail(v_139) && success?(1-proj-3-tuple(v_139))) in
        {422}let h_22: bitstring = (if v_140 then 3-proj-3-tuple(v_139) else caught-fail) in
        {423}let ck_27: key = (if v_140 then 2-proj-3-tuple(v_139) else caught-fail) in
        {424}let cs_22: cipherstate = (if v_140 then 1-proj-3-tuple(v_139) else caught-fail) in
        {427}let output3_6: key = (if v_140 then hmac_hash3(ck_27,input_key_material_6) else caught-fail) in
        {426}let output2_6: key = (if v_140 then hmac_hash2(ck_27,input_key_material_6) else caught-fail) in
        {425}let output1_6: key = (if v_140 then hmac_hash1(ck_27,input_key_material_6) else caught-fail) in
        {428}let v_141: bitstring = (if v_140 then catch-fail((output1_6,output2_6,output3_6)) else caught-fail) in
        {429}let v_142: bool = (not-caught-fail(v_141) && success?(1-proj-3-tuple(v_141))) in
        {430}let output_5: key = (if v_142 then 3-proj-3-tuple(v_141) else caught-fail) in
        {431}let temp_k_5: key = (if v_142 then 2-proj-3-tuple(v_141) else caught-fail) in
        {432}let ck_28: key = (if v_142 then 1-proj-3-tuple(v_141) else caught-fail) in
        {433}let ss_23: symmetricstate = (if v_135 then catch-fail((if v_138 then (if v_140 then (if v_142 then symmetricstatepack(cipherstatepack(temp_k_5,minnonce),ck_28,h_22) else fail-any) else fail-any) else fail-any)) else caught-fail) in
        {434}let v_143: bool = not-caught-fail(ss_23) in
        {435}let basis_8: key = (if v_143 then key_s(me_1) else caught-fail) in
        {436}let public_key_8: key = (if v_143 then catch-fail(dhexp(basis_8,validkey(g))) else caught-fail) in
        {437}let v_144: bool = not-caught-fail(public_key_8) in
        {438}let s_5: keypair = (if v_143 then catch-fail((if v_144 then keypairpack(validkey(public_key_8),basis_8) else fail-any)) else caught-fail) in
        {439}let v_145: bool = not-caught-fail(s_5) in
        {440}let plaintext_2: bitstring = (if v_145 then catch-fail(getpublickey(s_5)) else caught-fail) in
        {441}let v_146: bool = not-caught-fail(plaintext_2) in
        {442}let v_147: bitstring = (if v_146 then catch-fail(symmetricstateunpack(ss_23)) else caught-fail) in
        {443}let v_148: bool = (not-caught-fail(v_147) && success?(1-proj-3-tuple(v_147))) in
        {444}let h_23: bitstring = (if v_148 then 3-proj-3-tuple(v_147) else caught-fail) in
        {445}let ck_29: key = (if v_148 then 2-proj-3-tuple(v_147) else caught-fail) in
        {446}let cs_23: cipherstate = (if v_148 then 1-proj-3-tuple(v_147) else caught-fail) in
        {447}let v_149: bitstring = (if v_148 then catch-fail(cipherstateunpack(cs_23)) else caught-fail) in
        {448}let v_150: bool = (not-caught-fail(v_149) && success?(1-proj-2-tuple(v_149))) in
        {449}let n_6: nonce = (if v_150 then 2-proj-2-tuple(v_149) else caught-fail) in
        {450}let k_8: key = (if v_150 then 1-proj-2-tuple(v_149) else caught-fail) in
        {453}let v_151: bitstring = (if v_150 then catch-fail(cipherstateunpack(cs_23)) else caught-fail) in
        {454}let v_152: bool = (not-caught-fail(v_151) && success?(1-proj-2-tuple(v_151))) in
        {455}let o_3: nonce = (if v_152 then 2-proj-2-tuple(v_151) else caught-fail) in
        {456}let k_9: key = (if v_152 then 1-proj-2-tuple(v_151) else caught-fail) in
        {452}let n_7: nonce = (if v_150 then increment_nonce(n_6) else caught-fail) in
        {457}let csi_6: cipherstate = (if v_150 then catch-fail((if v_152 then cipherstatepack(k_9,n_7) else fail-any)) else caught-fail) in
        {458}let v_153: bool = not-caught-fail(csi_6) in
        {451}let e_9: bitstring = (if v_150 then encrypt(k_8,n_6,h_23,plaintext_2) else caught-fail) in
        {459}let v_154: bitstring = (if v_148 then catch-fail((if v_150 then (if v_153 then (csi_6,e_9) else fail-any) else fail-any)) else caught-fail) in
        {460}let v_155: bool = (not-caught-fail(v_154) && success?(1-proj-2-tuple(v_154))) in
        {461}let ciphertext_6: bitstring = (if v_155 then 2-proj-2-tuple(v_154) else caught-fail) in
        {462}let csi_7: cipherstate = (if v_155 then 1-proj-2-tuple(v_154) else caught-fail) in
        {463}let ss_24: symmetricstate = (if v_155 then symmetricstatepack(csi_7,ck_29,h_23) else caught-fail) in
        {464}let v_156: bitstring = (if v_155 then catch-fail(symmetricstateunpack(ss_24)) else caught-fail) in
        {465}let v_157: bool = (not-caught-fail(v_156) && success?(1-proj-3-tuple(v_156))) in
        {466}let h_24: bitstring = (if v_157 then 3-proj-3-tuple(v_156) else caught-fail) in
        {467}let ck_30: key = (if v_157 then 2-proj-3-tuple(v_156) else caught-fail) in
        {468}let cs_24: cipherstate = (if v_157 then 1-proj-3-tuple(v_156) else caught-fail) in
        {469}let ssi_4: symmetricstate = (if v_155 then catch-fail((if v_157 then symmetricstatepack(cs_24,ck_30,hash(h_24,ciphertext_6)) else fail-any)) else caught-fail) in
        {470}let v_158: bool = not-caught-fail(ssi_4) in
        {471}let v_159: bitstring = (if v_145 then catch-fail((if v_146 then (if v_148 then (if v_155 then (if v_158 then (ssi_4,ciphertext_6) else fail-any) else fail-any) else fail-any) else fail-any)) else caught-fail) in
        {472}let v_160: bool = (not-caught-fail(v_159) && success?(1-proj-2-tuple(v_159))) in
        {473}let ns_3: bitstring = (if v_160 then 2-proj-2-tuple(v_159) else caught-fail) in
        {474}let ss_25: symmetricstate = (if v_160 then 1-proj-2-tuple(v_159) else caught-fail) in
        {475}let basis_9: key = (if v_160 then key_m(me_1) else caught-fail) in
        {476}let public_key_9: key = (if v_160 then catch-fail(dhexp(basis_9,validkey(g))) else caught-fail) in
        {477}let v_161: bool = not-caught-fail(public_key_9) in
        {478}let m_5: keypair = (if v_160 then catch-fail((if v_161 then keypairpack(validkey(public_key_9),basis_9) else fail-any)) else caught-fail) in
        {479}let v_162: bool = not-caught-fail(m_5) in
        {480}let plaintext_3: bitstring = (if v_162 then catch-fail(getpublickey(m_5)) else caught-fail) in
        {481}let v_163: bool = not-caught-fail(plaintext_3) in
        {482}let v_164: bitstring = (if v_163 then catch-fail(symmetricstateunpack(ss_25)) else caught-fail) in
        {483}let v_165: bool = (not-caught-fail(v_164) && success?(1-proj-3-tuple(v_164))) in
        {484}let h_25: bitstring = (if v_165 then 3-proj-3-tuple(v_164) else caught-fail) in
        {485}let ck_31: key = (if v_165 then 2-proj-3-tuple(v_164) else caught-fail) in
        {486}let cs_25: cipherstate = (if v_165 then 1-proj-3-tuple(v_164) else caught-fail) in
        {487}let v_166: bitstring = (if v_165 then catch-fail(cipherstateunpack(cs_25)) else caught-fail) in
        {488}let v_167: bool = (not-caught-fail(v_166) && success?(1-proj-2-tuple(v_166))) in
        {489}let n_8: nonce = (if v_167 then 2-proj-2-tuple(v_166) else caught-fail) in
        {490}let k_10: key = (if v_167 then 1-proj-2-tuple(v_166) else caught-fail) in
        {493}let v_168: bitstring = (if v_167 then catch-fail(cipherstateunpack(cs_25)) else caught-fail) in
        {494}let v_169: bool = (not-caught-fail(v_168) && success?(1-proj-2-tuple(v_168))) in
        {495}let o_4: nonce = (if v_169 then 2-proj-2-tuple(v_168) else caught-fail) in
        {496}let k_11: key = (if v_169 then 1-proj-2-tuple(v_168) else caught-fail) in
        {492}let n_9: nonce = (if v_167 then increment_nonce(n_8) else caught-fail) in
        {497}let csi_8: cipherstate = (if v_167 then catch-fail((if v_169 then cipherstatepack(k_11,n_9) else fail-any)) else caught-fail) in
        {498}let v_170: bool = not-caught-fail(csi_8) in
        {491}let e_10: bitstring = (if v_167 then encrypt(k_10,n_8,h_25,plaintext_3) else caught-fail) in
        {499}let v_171: bitstring = (if v_165 then catch-fail((if v_167 then (if v_170 then (csi_8,e_10) else fail-any) else fail-any)) else caught-fail) in
        {500}let v_172: bool = (not-caught-fail(v_171) && success?(1-proj-2-tuple(v_171))) in
        {501}let ciphertext_7: bitstring = (if v_172 then 2-proj-2-tuple(v_171) else caught-fail) in
        {502}let csi_9: cipherstate = (if v_172 then 1-proj-2-tuple(v_171) else caught-fail) in
        {503}let ss_26: symmetricstate = (if v_172 then symmetricstatepack(csi_9,ck_31,h_25) else caught-fail) in
        {504}let v_173: bitstring = (if v_172 then catch-fail(symmetricstateunpack(ss_26)) else caught-fail) in
        {505}let v_174: bool = (not-caught-fail(v_173) && success?(1-proj-3-tuple(v_173))) in
        {506}let h_26: bitstring = (if v_174 then 3-proj-3-tuple(v_173) else caught-fail) in
        {507}let ck_32: key = (if v_174 then 2-proj-3-tuple(v_173) else caught-fail) in
        {508}let cs_26: cipherstate = (if v_174 then 1-proj-3-tuple(v_173) else caught-fail) in
        {509}let ssi_5: symmetricstate = (if v_172 then catch-fail((if v_174 then symmetricstatepack(cs_26,ck_32,hash(h_26,ciphertext_7)) else fail-any)) else caught-fail) in
        {510}let v_175: bool = not-caught-fail(ssi_5) in
        {511}let v_176: bitstring = (if v_162 then catch-fail((if v_163 then (if v_165 then (if v_172 then (if v_175 then (ssi_5,ciphertext_7) else fail-any) else fail-any) else fail-any) else fail-any)) else caught-fail) in
        {512}let v_177: bool = (not-caught-fail(v_176) && success?(1-proj-2-tuple(v_176))) in
        {513}let nm_3: bitstring = (if v_177 then 2-proj-2-tuple(v_176) else caught-fail) in
        {514}let ss_27: symmetricstate = (if v_177 then 1-proj-2-tuple(v_176) else caught-fail) in
        {515}let v_178: bitstring = (if v_177 then catch-fail(keypairunpack(m_5)) else caught-fail) in
        {516}let v_179: bool = (not-caught-fail(v_178) && success?(1-proj-2-tuple(v_178))) in
        {517}let my_private_key_6: key = (if v_179 then 2-proj-2-tuple(v_178) else caught-fail) in
        {518}let my_public_key_6: key = (if v_179 then 1-proj-2-tuple(v_178) else caught-fail) in
        {519}let input_key_material_7: key = (if v_177 then catch-fail((if v_179 then dhexp(my_private_key_6,rs_3) else fail-any)) else caught-fail) in
        {520}let v_180: bool = not-caught-fail(input_key_material_7) in
        {521}let v_181: bitstring = (if v_180 then catch-fail(symmetricstateunpack(ss_27)) else caught-fail) in
        {522}let v_182: bool = (not-caught-fail(v_181) && success?(1-proj-3-tuple(v_181))) in
        {523}let h_27: bitstring = (if v_182 then 3-proj-3-tuple(v_181) else caught-fail) in
        {524}let ck_33: key = (if v_182 then 2-proj-3-tuple(v_181) else caught-fail) in
        {525}let cs_27: cipherstate = (if v_182 then 1-proj-3-tuple(v_181) else caught-fail) in
        {528}let output3_7: key = (if v_182 then hmac_hash3(ck_33,input_key_material_7) else caught-fail) in
        {527}let output2_7: key = (if v_182 then hmac_hash2(ck_33,input_key_material_7) else caught-fail) in
        {526}let output1_7: key = (if v_182 then hmac_hash1(ck_33,input_key_material_7) else caught-fail) in
        {529}let v_183: bitstring = (if v_182 then catch-fail((output1_7,output2_7,output3_7)) else caught-fail) in
        {530}let v_184: bool = (not-caught-fail(v_183) && success?(1-proj-3-tuple(v_183))) in
        {531}let output_6: key = (if v_184 then 3-proj-3-tuple(v_183) else caught-fail) in
        {532}let temp_k_6: key = (if v_184 then 2-proj-3-tuple(v_183) else caught-fail) in
        {533}let ck_34: key = (if v_184 then 1-proj-3-tuple(v_183) else caught-fail) in
        {534}let ss_28: symmetricstate = (if v_177 then catch-fail((if v_180 then (if v_182 then (if v_184 then symmetricstatepack(cipherstatepack(temp_k_6,minnonce),ck_34,h_27) else fail-any) else fail-any) else fail-any)) else caught-fail) in
        {535}let v_185: bool = not-caught-fail(ss_28) in
        {536}let v_186: bitstring = (if v_185 then catch-fail(keypairunpack(s_5)) else caught-fail) in
        {537}let v_187: bool = (not-caught-fail(v_186) && success?(1-proj-2-tuple(v_186))) in
        {538}let my_private_key_7: key = (if v_187 then 2-proj-2-tuple(v_186) else caught-fail) in
        {539}let my_public_key_7: key = (if v_187 then 1-proj-2-tuple(v_186) else caught-fail) in
        {540}let input_key_material_8: key = (if v_185 then catch-fail((if v_187 then dhexp(my_private_key_7,rm_3) else fail-any)) else caught-fail) in
        {541}let v_188: bool = not-caught-fail(input_key_material_8) in
        {542}let v_189: bitstring = (if v_188 then catch-fail(symmetricstateunpack(ss_28)) else caught-fail) in
        {543}let v_190: bool = (not-caught-fail(v_189) && success?(1-proj-3-tuple(v_189))) in
        {544}let h_28: bitstring = (if v_190 then 3-proj-3-tuple(v_189) else caught-fail) in
        {545}let ck_35: key = (if v_190 then 2-proj-3-tuple(v_189) else caught-fail) in
        {546}let cs_28: cipherstate = (if v_190 then 1-proj-3-tuple(v_189) else caught-fail) in
        {549}let output3_8: key = (if v_190 then hmac_hash3(ck_35,input_key_material_8) else caught-fail) in
        {548}let output2_8: key = (if v_190 then hmac_hash2(ck_35,input_key_material_8) else caught-fail) in
        {547}let output1_8: key = (if v_190 then hmac_hash1(ck_35,input_key_material_8) else caught-fail) in
        {550}let v_191: bitstring = (if v_190 then catch-fail((output1_8,output2_8,output3_8)) else caught-fail) in
        {551}let v_192: bool = (not-caught-fail(v_191) && success?(1-proj-3-tuple(v_191))) in
        {552}let output_7: key = (if v_192 then 3-proj-3-tuple(v_191) else caught-fail) in
        {553}let temp_k_7: key = (if v_192 then 2-proj-3-tuple(v_191) else caught-fail) in
        {554}let ck_36: key = (if v_192 then 1-proj-3-tuple(v_191) else caught-fail) in
        {555}let ss_29: symmetricstate = (if v_185 then catch-fail((if v_188 then (if v_190 then (if v_192 then symmetricstatepack(cipherstatepack(temp_k_7,minnonce),ck_36,h_28) else fail-any) else fail-any) else fail-any)) else caught-fail) in
        {556}let v_193: bool = not-caught-fail(ss_29) in
        {557}let v_194: bitstring = (if v_193 then catch-fail(symmetricstateunpack(ss_29)) else caught-fail) in
        {558}let v_195: bool = (not-caught-fail(v_194) && success?(1-proj-3-tuple(v_194))) in
        {559}let h_29: bitstring = (if v_195 then 3-proj-3-tuple(v_194) else caught-fail) in
        {560}let ck_37: key = (if v_195 then 2-proj-3-tuple(v_194) else caught-fail) in
        {561}let cs_29: cipherstate = (if v_195 then 1-proj-3-tuple(v_194) else caught-fail) in
        {562}let v_196: bitstring = (if v_195 then catch-fail(cipherstateunpack(cs_29)) else caught-fail) in
        {563}let v_197: bool = (not-caught-fail(v_196) && success?(1-proj-2-tuple(v_196))) in
        {564}let n_10: nonce = (if v_197 then 2-proj-2-tuple(v_196) else caught-fail) in
        {565}let k_12: key = (if v_197 then 1-proj-2-tuple(v_196) else caught-fail) in
        {568}let v_198: bitstring = (if v_197 then catch-fail(cipherstateunpack(cs_29)) else caught-fail) in
        {569}let v_199: bool = (not-caught-fail(v_198) && success?(1-proj-2-tuple(v_198))) in
        {570}let o_5: nonce = (if v_199 then 2-proj-2-tuple(v_198) else caught-fail) in
        {571}let k_13: key = (if v_199 then 1-proj-2-tuple(v_198) else caught-fail) in
        {567}let n_11: nonce = (if v_197 then increment_nonce(n_10) else caught-fail) in
        {572}let csi_10: cipherstate = (if v_197 then catch-fail((if v_199 then cipherstatepack(k_13,n_11) else fail-any)) else caught-fail) in
        {573}let v_200: bool = not-caught-fail(csi_10) in
        {361}let payload_1: bitstring = msg_a(me_1,them_1,sid_2) in
        {566}let e_11: bitstring = (if v_197 then encrypt(k_12,n_10,h_29,payload_1) else caught-fail) in
        {574}let v_201: bitstring = (if v_195 then catch-fail((if v_197 then (if v_200 then (csi_10,e_11) else fail-any) else fail-any)) else caught-fail) in
        {575}let v_202: bool = (not-caught-fail(v_201) && success?(1-proj-2-tuple(v_201))) in
        {576}let ciphertext_8: bitstring = (if v_202 then 2-proj-2-tuple(v_201) else caught-fail) in
        {577}let csi_11: cipherstate = (if v_202 then 1-proj-2-tuple(v_201) else caught-fail) in
        {578}let ss_30: symmetricstate = (if v_202 then symmetricstatepack(csi_11,ck_37,h_29) else caught-fail) in
        {579}let v_203: bitstring = (if v_202 then catch-fail(symmetricstateunpack(ss_30)) else caught-fail) in
        {580}let v_204: bool = (not-caught-fail(v_203) && success?(1-proj-3-tuple(v_203))) in
        {581}let h_30: bitstring = (if v_204 then 3-proj-3-tuple(v_203) else caught-fail) in
        {582}let ck_38: key = (if v_204 then 2-proj-3-tuple(v_203) else caught-fail) in
        {583}let cs_30: cipherstate = (if v_204 then 1-proj-3-tuple(v_203) else caught-fail) in
        {584}let ssi_6: symmetricstate = (if v_202 then catch-fail((if v_204 then symmetricstatepack(cs_30,ck_38,hash(h_30,ciphertext_8)) else fail-any)) else caught-fail) in
        {585}let v_205: bool = not-caught-fail(ssi_6) in
        {586}let v_206: bitstring = (if v_193 then catch-fail((if v_195 then (if v_202 then (if v_205 then (ssi_6,ciphertext_8) else fail-any) else fail-any) else fail-any)) else caught-fail) in
        {587}let v_207: bool = (not-caught-fail(v_206) && success?(1-proj-2-tuple(v_206))) in
        {588}let ciphertext_9: bitstring = (if v_207 then 2-proj-2-tuple(v_206) else caught-fail) in
        {589}let ss_31: symmetricstate = (if v_207 then 1-proj-2-tuple(v_206) else caught-fail) in
        {592}let v_208: bitstring = (if v_207 then catch-fail(symmetricstateunpack(ss_31)) else caught-fail) in
        {593}let v_209: bool = (not-caught-fail(v_208) && success?(1-proj-3-tuple(v_208))) in
        {594}let h_31: bitstring = (if v_209 then 3-proj-3-tuple(v_208) else caught-fail) in
        {595}let ck_39: key = (if v_209 then 2-proj-3-tuple(v_208) else caught-fail) in
        {596}let cs_31: cipherstate = (if v_209 then 1-proj-3-tuple(v_208) else caught-fail) in
        {597}let input_key_material_9: key = (if v_209 then zero else caught-fail) in
        {600}let output3_9: key = (if v_209 then hmac_hash3(ck_39,input_key_material_9) else caught-fail) in
        {599}let output2_9: key = (if v_209 then hmac_hash2(ck_39,input_key_material_9) else caught-fail) in
        {598}let output1_9: key = (if v_209 then hmac_hash1(ck_39,input_key_material_9) else caught-fail) in
        {601}let v_210: bitstring = (if v_209 then catch-fail((output1_9,output2_9,output3_9)) else caught-fail) in
        {602}let v_211: bool = (not-caught-fail(v_210) && success?(1-proj-3-tuple(v_210))) in
        {603}let temp_k3_1: key = (if v_211 then 3-proj-3-tuple(v_210) else caught-fail) in
        {604}let temp_k2_1: key = (if v_211 then 2-proj-3-tuple(v_210) else caught-fail) in
        {605}let temp_k1_1: key = (if v_211 then 1-proj-3-tuple(v_210) else caught-fail) in
        {607}let cs2_3: cipherstate = (if v_211 then cipherstatepack(temp_k2_1,minnonce) else caught-fail) in
        {606}let cs1_3: cipherstate = (if v_211 then cipherstatepack(temp_k1_1,minnonce) else caught-fail) in
        {608}let v_212: bitstring = (if v_207 then catch-fail((if v_209 then (if v_211 then (ss_31,cs1_3,cs2_3) else fail-any) else fail-any)) else caught-fail) in
        {609}let v_213: bool = (not-caught-fail(v_212) && success?(1-proj-3-tuple(v_212))) in
        {610}let cs2_4: cipherstate = (if v_213 then 3-proj-3-tuple(v_212) else caught-fail) in
        {611}let cs1_4: cipherstate = (if v_213 then 2-proj-3-tuple(v_212) else caught-fail) in
        {612}let ssi_7: symmetricstate = (if v_213 then 1-proj-3-tuple(v_212) else caught-fail) in
        {591}let message_buffer_1: bitstring = (if v_207 then concat4(ne_3,ns_3,nm_3,ciphertext_9) else caught-fail) in
        {590}let hs_6: handshakestate = (if v_207 then handshakestatepack(ss_31,s_5,m_5,e_8,rs_3,rm_3,re_3,psk_3,initiator_2) else caught-fail) in
        {613}let (hs_7: handshakestate,message_a_1: bitstring,cs1_5: cipherstate,cs2_5: cipherstate) = (if v_119 then (if v_121 then (if v_123 then (if v_124 then (if v_127 then (if v_135 then (if v_143 then (if v_145 then (if v_160 then (if v_162 then (if v_177 then (if v_185 then (if v_193 then (if v_207 then (if v_213 then (hs_6,message_buffer_1,cs1_4,cs2_4) else fail-any) else fail-any) else fail-any) else fail-any) else fail-any) else fail-any) else fail-any) else fail-any) else fail-any) else fail-any) else fail-any) else fail-any) else fail-any) else fail-any) else fail-any) in
        {614}event SendMsg(me_1,them_1,stagepack_a(sid_2),msg_a(me_1,them_1,sid_2));
        {615}out(pub, message_a_1)
    ) | (
        {617}event LeakS(phase0,me_1);
        {618}event LeakM(phase0,me_1);
        {619}out(pub, (key_s(me_1),key_m(me_1)))
    ) | (
        {620}phase 1;
        {621}event LeakS(phase1,me_1);
        {622}event LeakM(phase1,me_1);
        {623}out(pub, (key_s(me_1),key_m(me_1)))
    )
) | (
    {624}let me_2: principal = bob in
    {627}let basis_10: key = key_s(me_2) in
    {628}let public_key_10: key = catch-fail(dhexp(basis_10,validkey(g))) in
    {629}let v_214: bool = not-caught-fail(public_key_10) in
    {630}let s_6: keypair = (if v_214 then keypairpack(validkey(public_key_10),basis_10) else fail-any) in
    {631}let basis_11: key = key_m(me_2) in
    {632}let public_key_11: key = catch-fail(dhexp(basis_11,validkey(g))) in
    {633}let v_215: bool = not-caught-fail(public_key_11) in
    {634}let m_6: keypair = (if v_215 then keypairpack(validkey(public_key_11),basis_11) else fail-any) in
    {635}out(pub, (getpublickey(s_6),getpublickey(m_6)));
    {626}let sid_3: sessionid = sid in
    {625}let them_2: principal = alice in
    (
        {645}let k_14: key = empty in
        {646}let cs_32: cipherstate = cipherstatepack(k_14,minnonce) in
        {642}let protocol_name_2: bitstring = somename in
        {643}let h_32: bitstring = hash(protocol_name_2,empty) in
        {644}let ck_40: key = h_32 in
        {647}let ss_32: symmetricstate = symmetricstatepack(cs_32,ck_40,h_32) in
        {648}let v_216: bitstring = catch-fail(symmetricstateunpack(ss_32)) in
        {649}let v_217: bool = (not-caught-fail(v_216) && success?(1-proj-3-tuple(v_216))) in
        {650}let h_33: bitstring = (if v_217 then 3-proj-3-tuple(v_216) else caught-fail) in
        {651}let ck_41: key = (if v_217 then 2-proj-3-tuple(v_216) else caught-fail) in
        {652}let cs_33: cipherstate = (if v_217 then 1-proj-3-tuple(v_216) else caught-fail) in
        {640}let prologue_2: bitstring = empty in
        {653}let ss_33: symmetricstate = catch-fail((if v_217 then symmetricstatepack(cs_33,ck_41,hash(h_33,prologue_2)) else fail-any)) in
        {654}let v_218: bool = not-caught-fail(ss_33) in
        {655}let data: bitstring = (if v_218 then catch-fail(getpublickey(s_6)) else caught-fail) in
        {656}let v_219: bool = not-caught-fail(data) in
        {657}let v_220: bitstring = (if v_219 then catch-fail(symmetricstateunpack(ss_33)) else caught-fail) in
        {658}let v_221: bool = (not-caught-fail(v_220) && success?(1-proj-3-tuple(v_220))) in
        {659}let h_34: bitstring = (if v_221 then 3-proj-3-tuple(v_220) else caught-fail) in
        {660}let ck_42: key = (if v_221 then 2-proj-3-tuple(v_220) else caught-fail) in
        {661}let cs_34: cipherstate = (if v_221 then 1-proj-3-tuple(v_220) else caught-fail) in
        {662}let ss_34: symmetricstate = (if v_218 then catch-fail((if v_219 then (if v_221 then symmetricstatepack(cs_34,ck_42,hash(h_34,data)) else fail-any) else fail-any)) else caught-fail) in
        {663}let v_222: bool = not-caught-fail(ss_34) in
        {664}let data_1: bitstring = (if v_222 then catch-fail(getpublickey(m_6)) else caught-fail) in
        {665}let v_223: bool = not-caught-fail(data_1) in
        {666}let v_224: bitstring = (if v_223 then catch-fail(symmetricstateunpack(ss_34)) else caught-fail) in
        {667}let v_225: bool = (not-caught-fail(v_224) && success?(1-proj-3-tuple(v_224))) in
        {668}let h_35: bitstring = (if v_225 then 3-proj-3-tuple(v_224) else caught-fail) in
        {669}let ck_43: key = (if v_225 then 2-proj-3-tuple(v_224) else caught-fail) in
        {670}let cs_35: cipherstate = (if v_225 then 1-proj-3-tuple(v_224) else caught-fail) in
        {671}let ss_35: symmetricstate = (if v_222 then catch-fail((if v_223 then (if v_225 then symmetricstatepack(cs_35,ck_43,hash(h_35,data_1)) else fail-any) else fail-any)) else caught-fail) in
        {672}let v_226: bool = not-caught-fail(ss_35) in
        {641}let psk_4: key = empty in
        {639}let re_4: key = empty in
        {638}let rm_4: key = empty in
        {637}let rs_4: key = empty in
        {636}let e_12: keypair = keypairpack(empty,empty) in
        {673}let hs_8: handshakestate = (if v_218 then (if v_222 then (if v_226 then handshakestatepack(ss_35,s_6,m_6,e_12,rs_4,rm_4,re_4,psk_4,false) else fail-any) else fail-any) else fail-any) in
        {674}insert statestore(me_2,them_2,sid_3,statepack_a(hs_8))
    ) | (
        {944}get statestore(=me_2,=them_2,=sid_3,statepack_a(hs_9: handshakestate)) in
        {675}in(pub, message_a_2: bitstring);
        {676}let v_227: bitstring = catch-fail(handshakestateunpack(hs_9)) in
        {677}let v_228: bool = (not-caught-fail(v_227) && success?(1-proj-9-tuple(v_227))) in
        {678}let initiator_3: bool = (if v_228 then 9-proj-9-tuple(v_227) else caught-fail) in
        {679}let psk_5: key = (if v_228 then 8-proj-9-tuple(v_227) else caught-fail) in
        {680}let re_5: key = (if v_228 then 7-proj-9-tuple(v_227) else caught-fail) in
        {681}let rm_5: key = (if v_228 then 6-proj-9-tuple(v_227) else caught-fail) in
        {682}let rs_5: key = (if v_228 then 5-proj-9-tuple(v_227) else caught-fail) in
        {683}let e_13: keypair = (if v_228 then 4-proj-9-tuple(v_227) else caught-fail) in
        {684}let m_7: keypair = (if v_228 then 3-proj-9-tuple(v_227) else caught-fail) in
        {685}let s_7: keypair = (if v_228 then 2-proj-9-tuple(v_227) else caught-fail) in
        {686}let ss_36: symmetricstate = (if v_228 then 1-proj-9-tuple(v_227) else caught-fail) in
        {687}let v_229: bitstring = (if v_228 then catch-fail(deconcat4(message_a_2)) else caught-fail) in
        {688}let v_230: bool = (not-caught-fail(v_229) && success?(1-proj-4-tuple(v_229))) in
        {689}let ciphertext_10: bitstring = (if v_230 then 4-proj-4-tuple(v_229) else caught-fail) in
        {690}let nm_4: bitstring = (if v_230 then 3-proj-4-tuple(v_229) else caught-fail) in
        {691}let ns_4: bitstring = (if v_230 then 2-proj-4-tuple(v_229) else caught-fail) in
        {692}let ne_4: bitstring = (if v_230 then 1-proj-4-tuple(v_229) else caught-fail) in
        {696}let v_231: bitstring = (if v_230 then catch-fail(symmetricstateunpack(ss_36)) else caught-fail) in
        {697}let v_232: bool = (not-caught-fail(v_231) && success?(1-proj-3-tuple(v_231))) in
        {698}let h_36: bitstring = (if v_232 then 3-proj-3-tuple(v_231) else caught-fail) in
        {699}let ck_44: key = (if v_232 then 2-proj-3-tuple(v_231) else caught-fail) in
        {700}let cs_36: cipherstate = (if v_232 then 1-proj-3-tuple(v_231) else caught-fail) in
        {695}let re_6: key = (if v_230 then ne_4 else caught-fail) in
        {701}let ss_37: symmetricstate = (if v_230 then catch-fail((if v_232 then symmetricstatepack(cs_36,ck_44,hash(h_36,re_6)) else fail-any)) else caught-fail) in
        {702}let v_233: bool = not-caught-fail(ss_37) in
        {703}let v_234: bitstring = (if v_233 then catch-fail(keypairunpack(s_7)) else caught-fail) in
        {704}let v_235: bool = (not-caught-fail(v_234) && success?(1-proj-2-tuple(v_234))) in
        {705}let my_private_key_8: key = (if v_235 then 2-proj-2-tuple(v_234) else caught-fail) in
        {706}let my_public_key_8: key = (if v_235 then 1-proj-2-tuple(v_234) else caught-fail) in
        {707}let input_key_material_10: key = (if v_233 then catch-fail((if v_235 then dhexp(my_private_key_8,re_6) else fail-any)) else caught-fail) in
        {708}let v_236: bool = not-caught-fail(input_key_material_10) in
        {709}let v_237: bitstring = (if v_236 then catch-fail(symmetricstateunpack(ss_37)) else caught-fail) in
        {710}let v_238: bool = (not-caught-fail(v_237) && success?(1-proj-3-tuple(v_237))) in
        {711}let h_37: bitstring = (if v_238 then 3-proj-3-tuple(v_237) else caught-fail) in
        {712}let ck_45: key = (if v_238 then 2-proj-3-tuple(v_237) else caught-fail) in
        {713}let cs_37: cipherstate = (if v_238 then 1-proj-3-tuple(v_237) else caught-fail) in
        {716}let output3_10: key = (if v_238 then hmac_hash3(ck_45,input_key_material_10) else caught-fail) in
        {715}let output2_10: key = (if v_238 then hmac_hash2(ck_45,input_key_material_10) else caught-fail) in
        {714}let output1_10: key = (if v_238 then hmac_hash1(ck_45,input_key_material_10) else caught-fail) in
        {717}let v_239: bitstring = (if v_238 then catch-fail((output1_10,output2_10,output3_10)) else caught-fail) in
        {718}let v_240: bool = (not-caught-fail(v_239) && success?(1-proj-3-tuple(v_239))) in
        {719}let output_8: key = (if v_240 then 3-proj-3-tuple(v_239) else caught-fail) in
        {720}let temp_k_8: key = (if v_240 then 2-proj-3-tuple(v_239) else caught-fail) in
        {721}let ck_46: key = (if v_240 then 1-proj-3-tuple(v_239) else caught-fail) in
        {722}let ss_38: symmetricstate = (if v_233 then catch-fail((if v_236 then (if v_238 then (if v_240 then symmetricstatepack(cipherstatepack(temp_k_8,minnonce),ck_46,h_37) else fail-any) else fail-any) else fail-any)) else caught-fail) in
        {723}let v_241: bool = not-caught-fail(ss_38) in
        {724}let v_242: bitstring = (if v_241 then catch-fail(keypairunpack(m_7)) else caught-fail) in
        {725}let v_243: bool = (not-caught-fail(v_242) && success?(1-proj-2-tuple(v_242))) in
        {726}let my_private_key_9: key = (if v_243 then 2-proj-2-tuple(v_242) else caught-fail) in
        {727}let my_public_key_9: key = (if v_243 then 1-proj-2-tuple(v_242) else caught-fail) in
        {728}let input_key_material_11: key = (if v_241 then catch-fail((if v_243 then dhexp(my_private_key_9,re_6) else fail-any)) else caught-fail) in
        {729}let v_244: bool = not-caught-fail(input_key_material_11) in
        {730}let v_245: bitstring = (if v_244 then catch-fail(symmetricstateunpack(ss_38)) else caught-fail) in
        {731}let v_246: bool = (not-caught-fail(v_245) && success?(1-proj-3-tuple(v_245))) in
        {732}let h_38: bitstring = (if v_246 then 3-proj-3-tuple(v_245) else caught-fail) in
        {733}let ck_47: key = (if v_246 then 2-proj-3-tuple(v_245) else caught-fail) in
        {734}let cs_38: cipherstate = (if v_246 then 1-proj-3-tuple(v_245) else caught-fail) in
        {737}let output3_11: key = (if v_246 then hmac_hash3(ck_47,input_key_material_11) else caught-fail) in
        {736}let output2_11: key = (if v_246 then hmac_hash2(ck_47,input_key_material_11) else caught-fail) in
        {735}let output1_11: key = (if v_246 then hmac_hash1(ck_47,input_key_material_11) else caught-fail) in
        {738}let v_247: bitstring = (if v_246 then catch-fail((output1_11,output2_11,output3_11)) else caught-fail) in
        {739}let v_248: bool = (not-caught-fail(v_247) && success?(1-proj-3-tuple(v_247))) in
        {740}let output_9: key = (if v_248 then 3-proj-3-tuple(v_247) else caught-fail) in
        {741}let temp_k_9: key = (if v_248 then 2-proj-3-tuple(v_247) else caught-fail) in
        {742}let ck_48: key = (if v_248 then 1-proj-3-tuple(v_247) else caught-fail) in
        {743}let ss_39: symmetricstate = (if v_241 then catch-fail((if v_244 then (if v_246 then (if v_248 then symmetricstatepack(cipherstatepack(temp_k_9,minnonce),ck_48,h_38) else fail-any) else fail-any) else fail-any)) else caught-fail) in
        {744}let v_249: bool = not-caught-fail(ss_39) in
        {745}let v_250: bitstring = (if v_249 then catch-fail(symmetricstateunpack(ss_39)) else caught-fail) in
        {746}let v_251: bool = (not-caught-fail(v_250) && success?(1-proj-3-tuple(v_250))) in
        {747}let h_39: bitstring = (if v_251 then 3-proj-3-tuple(v_250) else caught-fail) in
        {748}let ck_49: key = (if v_251 then 2-proj-3-tuple(v_250) else caught-fail) in
        {749}let cs_39: cipherstate = (if v_251 then 1-proj-3-tuple(v_250) else caught-fail) in
        {750}let v_252: bitstring = (if v_251 then catch-fail(cipherstateunpack(cs_39)) else caught-fail) in
        {751}let v_253: bool = (not-caught-fail(v_252) && success?(1-proj-2-tuple(v_252))) in
        {752}let n_12: nonce = (if v_253 then 2-proj-2-tuple(v_252) else caught-fail) in
        {753}let k_15: key = (if v_253 then 1-proj-2-tuple(v_252) else caught-fail) in
        {754}let d: aead = (if v_253 then catch-fail(decrypt(k_15,n_12,h_39,ns_4)) else caught-fail) in
        {755}let v_254: bool = not-caught-fail(d) in
        {756}let v_255: bitstring = (if v_254 then catch-fail(aeadunpack(d)) else caught-fail) in
        {757}let v_256: bool = (not-caught-fail(v_255) && success?(1-proj-3-tuple(v_255))) in
        {758}let plaintext_4: bitstring = (if v_256 then 3-proj-3-tuple(v_255) else caught-fail) in
        {759}let adi: bitstring = (if v_256 then 2-proj-3-tuple(v_255) else caught-fail) in
        {760}let valid: bool = (if v_256 then 1-proj-3-tuple(v_255) else caught-fail) in
        {762}let v_257: bitstring = (if v_256 then catch-fail(cipherstateunpack(cs_39)) else caught-fail) in
        {763}let v_258: bool = (not-caught-fail(v_257) && success?(1-proj-2-tuple(v_257))) in
        {764}let o_6: nonce = (if v_258 then 2-proj-2-tuple(v_257) else caught-fail) in
        {765}let k_16: key = (if v_258 then 1-proj-2-tuple(v_257) else caught-fail) in
        {761}let n_13: nonce = (if v_256 then increment_nonce(n_12) else caught-fail) in
        {766}let csi_12: cipherstate = (if v_256 then catch-fail((if v_258 then cipherstatepack(k_16,n_13) else fail-any)) else caught-fail) in
        {767}let v_259: bool = not-caught-fail(csi_12) in
        {768}let v_260: bitstring = (if v_251 then catch-fail((if v_253 then (if v_254 then (if v_256 then (if v_259 then (csi_12,plaintext_4,valid) else fail-any) else fail-any) else fail-any) else fail-any)) else caught-fail) in
        {769}let v_261: bool = (not-caught-fail(v_260) && success?(1-proj-3-tuple(v_260))) in
        {770}let valid_1: bool = (if v_261 then 3-proj-3-tuple(v_260) else caught-fail) in
        {771}let plaintext_5: bitstring = (if v_261 then 2-proj-3-tuple(v_260) else caught-fail) in
        {772}let csi_13: cipherstate = (if v_261 then 1-proj-3-tuple(v_260) else caught-fail) in
        {773}let ss_40: symmetricstate = (if v_261 then symmetricstatepack(csi_13,ck_49,h_39) else caught-fail) in
        {774}let v_262: bitstring = (if v_261 then catch-fail(symmetricstateunpack(ss_40)) else caught-fail) in
        {775}let v_263: bool = (not-caught-fail(v_262) && success?(1-proj-3-tuple(v_262))) in
        {776}let h_40: bitstring = (if v_263 then 3-proj-3-tuple(v_262) else caught-fail) in
        {777}let ck_50: key = (if v_263 then 2-proj-3-tuple(v_262) else caught-fail) in
        {778}let cs_40: cipherstate = (if v_263 then 1-proj-3-tuple(v_262) else caught-fail) in
        {779}let ssi_8: symmetricstate = (if v_261 then catch-fail((if v_263 then symmetricstatepack(cs_40,ck_50,hash(h_40,ns_4)) else fail-any)) else caught-fail) in
        {780}let v_264: bool = not-caught-fail(ssi_8) in
        {781}let v_265: bitstring = (if v_249 then catch-fail((if v_251 then (if v_261 then (if v_264 then (ssi_8,plaintext_5,valid_1) else fail-any) else fail-any) else fail-any)) else caught-fail) in
        {782}let v_266: bool = (not-caught-fail(v_265) && success?(1-proj-3-tuple(v_265))) in
        {783}let valid1_1: bool = (if v_266 then 3-proj-3-tuple(v_265) else caught-fail) in
        {784}let se: bitstring = (if v_266 then 2-proj-3-tuple(v_265) else caught-fail) in
        {785}let ss_41: symmetricstate = (if v_266 then 1-proj-3-tuple(v_265) else caught-fail) in
        {787}let v_267: bitstring = (if v_266 then catch-fail(symmetricstateunpack(ss_41)) else caught-fail) in
        {788}let v_268: bool = (not-caught-fail(v_267) && success?(1-proj-3-tuple(v_267))) in
        {789}let h_41: bitstring = (if v_268 then 3-proj-3-tuple(v_267) else caught-fail) in
        {790}let ck_51: key = (if v_268 then 2-proj-3-tuple(v_267) else caught-fail) in
        {791}let cs_41: cipherstate = (if v_268 then 1-proj-3-tuple(v_267) else caught-fail) in
        {792}let v_269: bitstring = (if v_268 then catch-fail(cipherstateunpack(cs_41)) else caught-fail) in
        {793}let v_270: bool = (not-caught-fail(v_269) && success?(1-proj-2-tuple(v_269))) in
        {794}let n_14: nonce = (if v_270 then 2-proj-2-tuple(v_269) else caught-fail) in
        {795}let k_17: key = (if v_270 then 1-proj-2-tuple(v_269) else caught-fail) in
        {796}let d_1: aead = (if v_270 then catch-fail(decrypt(k_17,n_14,h_41,nm_4)) else caught-fail) in
        {797}let v_271: bool = not-caught-fail(d_1) in
        {798}let v_272: bitstring = (if v_271 then catch-fail(aeadunpack(d_1)) else caught-fail) in
        {799}let v_273: bool = (not-caught-fail(v_272) && success?(1-proj-3-tuple(v_272))) in
        {800}let plaintext_6: bitstring = (if v_273 then 3-proj-3-tuple(v_272) else caught-fail) in
        {801}let adi_1: bitstring = (if v_273 then 2-proj-3-tuple(v_272) else caught-fail) in
        {802}let valid_2: bool = (if v_273 then 1-proj-3-tuple(v_272) else caught-fail) in
        {804}let v_274: bitstring = (if v_273 then catch-fail(cipherstateunpack(cs_41)) else caught-fail) in
        {805}let v_275: bool = (not-caught-fail(v_274) && success?(1-proj-2-tuple(v_274))) in
        {806}let o_7: nonce = (if v_275 then 2-proj-2-tuple(v_274) else caught-fail) in
        {807}let k_18: key = (if v_275 then 1-proj-2-tuple(v_274) else caught-fail) in
        {803}let n_15: nonce = (if v_273 then increment_nonce(n_14) else caught-fail) in
        {808}let csi_14: cipherstate = (if v_273 then catch-fail((if v_275 then cipherstatepack(k_18,n_15) else fail-any)) else caught-fail) in
        {809}let v_276: bool = not-caught-fail(csi_14) in
        {810}let v_277: bitstring = (if v_268 then catch-fail((if v_270 then (if v_271 then (if v_273 then (if v_276 then (csi_14,plaintext_6,valid_2) else fail-any) else fail-any) else fail-any) else fail-any)) else caught-fail) in
        {811}let v_278: bool = (not-caught-fail(v_277) && success?(1-proj-3-tuple(v_277))) in
        {812}let valid_3: bool = (if v_278 then 3-proj-3-tuple(v_277) else caught-fail) in
        {813}let plaintext_7: bitstring = (if v_278 then 2-proj-3-tuple(v_277) else caught-fail) in
        {814}let csi_15: cipherstate = (if v_278 then 1-proj-3-tuple(v_277) else caught-fail) in
        {815}let ss_42: symmetricstate = (if v_278 then symmetricstatepack(csi_15,ck_51,h_41) else caught-fail) in
        {816}let v_279: bitstring = (if v_278 then catch-fail(symmetricstateunpack(ss_42)) else caught-fail) in
        {817}let v_280: bool = (not-caught-fail(v_279) && success?(1-proj-3-tuple(v_279))) in
        {818}let h_42: bitstring = (if v_280 then 3-proj-3-tuple(v_279) else caught-fail) in
        {819}let ck_52: key = (if v_280 then 2-proj-3-tuple(v_279) else caught-fail) in
        {820}let cs_42: cipherstate = (if v_280 then 1-proj-3-tuple(v_279) else caught-fail) in
        {821}let ssi_9: symmetricstate = (if v_278 then catch-fail((if v_280 then symmetricstatepack(cs_42,ck_52,hash(h_42,nm_4)) else fail-any)) else caught-fail) in
        {822}let v_281: bool = not-caught-fail(ssi_9) in
        {823}let v_282: bitstring = (if v_266 then catch-fail((if v_268 then (if v_278 then (if v_281 then (ssi_9,plaintext_7,valid_3) else fail-any) else fail-any) else fail-any)) else caught-fail) in
        {824}let v_283: bool = (not-caught-fail(v_282) && success?(1-proj-3-tuple(v_282))) in
        {825}let valid2_1: bool = (if v_283 then 3-proj-3-tuple(v_282) else caught-fail) in
        {826}let me_3: bitstring = (if v_283 then 2-proj-3-tuple(v_282) else caught-fail) in
        {827}let ss_43: symmetricstate = (if v_283 then 1-proj-3-tuple(v_282) else caught-fail) in
        {829}let v_284: bitstring = (if v_283 then catch-fail(keypairunpack(s_7)) else caught-fail) in
        {830}let v_285: bool = (not-caught-fail(v_284) && success?(1-proj-2-tuple(v_284))) in
        {831}let my_private_key_10: key = (if v_285 then 2-proj-2-tuple(v_284) else caught-fail) in
        {832}let my_public_key_10: key = (if v_285 then 1-proj-2-tuple(v_284) else caught-fail) in
        {828}let rm_6: key = (if v_283 then me_3 else caught-fail) in
        {833}let input_key_material_12: key = (if v_283 then catch-fail((if v_285 then dhexp(my_private_key_10,rm_6) else fail-any)) else caught-fail) in
        {834}let v_286: bool = not-caught-fail(input_key_material_12) in
        {835}let v_287: bitstring = (if v_286 then catch-fail(symmetricstateunpack(ss_43)) else caught-fail) in
        {836}let v_288: bool = (not-caught-fail(v_287) && success?(1-proj-3-tuple(v_287))) in
        {837}let h_43: bitstring = (if v_288 then 3-proj-3-tuple(v_287) else caught-fail) in
        {838}let ck_53: key = (if v_288 then 2-proj-3-tuple(v_287) else caught-fail) in
        {839}let cs_43: cipherstate = (if v_288 then 1-proj-3-tuple(v_287) else caught-fail) in
        {842}let output3_12: key = (if v_288 then hmac_hash3(ck_53,input_key_material_12) else caught-fail) in
        {841}let output2_12: key = (if v_288 then hmac_hash2(ck_53,input_key_material_12) else caught-fail) in
        {840}let output1_12: key = (if v_288 then hmac_hash1(ck_53,input_key_material_12) else caught-fail) in
        {843}let v_289: bitstring = (if v_288 then catch-fail((output1_12,output2_12,output3_12)) else caught-fail) in
        {844}let v_290: bool = (not-caught-fail(v_289) && success?(1-proj-3-tuple(v_289))) in
        {845}let output_10: key = (if v_290 then 3-proj-3-tuple(v_289) else caught-fail) in
        {846}let temp_k_10: key = (if v_290 then 2-proj-3-tuple(v_289) else caught-fail) in
        {847}let ck_54: key = (if v_290 then 1-proj-3-tuple(v_289) else caught-fail) in
        {848}let ss_44: symmetricstate = (if v_283 then catch-fail((if v_286 then (if v_288 then (if v_290 then symmetricstatepack(cipherstatepack(temp_k_10,minnonce),ck_54,h_43) else fail-any) else fail-any) else fail-any)) else caught-fail) in
        {849}let v_291: bool = not-caught-fail(ss_44) in
        {850}let v_292: bitstring = (if v_291 then catch-fail(keypairunpack(m_7)) else caught-fail) in
        {851}let v_293: bool = (not-caught-fail(v_292) && success?(1-proj-2-tuple(v_292))) in
        {852}let my_private_key_11: key = (if v_293 then 2-proj-2-tuple(v_292) else caught-fail) in
        {853}let my_public_key_11: key = (if v_293 then 1-proj-2-tuple(v_292) else caught-fail) in
        {786}let rs_6: key = (if v_266 then se else caught-fail) in
        {854}let input_key_material_13: key = (if v_291 then catch-fail((if v_293 then dhexp(my_private_key_11,rs_6) else fail-any)) else caught-fail) in
        {855}let v_294: bool = not-caught-fail(input_key_material_13) in
        {856}let v_295: bitstring = (if v_294 then catch-fail(symmetricstateunpack(ss_44)) else caught-fail) in
        {857}let v_296: bool = (not-caught-fail(v_295) && success?(1-proj-3-tuple(v_295))) in
        {858}let h_44: bitstring = (if v_296 then 3-proj-3-tuple(v_295) else caught-fail) in
        {859}let ck_55: key = (if v_296 then 2-proj-3-tuple(v_295) else caught-fail) in
        {860}let cs_44: cipherstate = (if v_296 then 1-proj-3-tuple(v_295) else caught-fail) in
        {863}let output3_13: key = (if v_296 then hmac_hash3(ck_55,input_key_material_13) else caught-fail) in
        {862}let output2_13: key = (if v_296 then hmac_hash2(ck_55,input_key_material_13) else caught-fail) in
        {861}let output1_13: key = (if v_296 then hmac_hash1(ck_55,input_key_material_13) else caught-fail) in
        {864}let v_297: bitstring = (if v_296 then catch-fail((output1_13,output2_13,output3_13)) else caught-fail) in
        {865}let v_298: bool = (not-caught-fail(v_297) && success?(1-proj-3-tuple(v_297))) in
        {866}let output_11: key = (if v_298 then 3-proj-3-tuple(v_297) else caught-fail) in
        {867}let temp_k_11: key = (if v_298 then 2-proj-3-tuple(v_297) else caught-fail) in
        {868}let ck_56: key = (if v_298 then 1-proj-3-tuple(v_297) else caught-fail) in
        {869}let ss_45: symmetricstate = (if v_291 then catch-fail((if v_294 then (if v_296 then (if v_298 then symmetricstatepack(cipherstatepack(temp_k_11,minnonce),ck_56,h_44) else fail-any) else fail-any) else fail-any)) else caught-fail) in
        {870}let v_299: bool = not-caught-fail(ss_45) in
        {871}let v_300: bitstring = (if v_299 then catch-fail(symmetricstateunpack(ss_45)) else caught-fail) in
        {872}let v_301: bool = (not-caught-fail(v_300) && success?(1-proj-3-tuple(v_300))) in
        {873}let h_45: bitstring = (if v_301 then 3-proj-3-tuple(v_300) else caught-fail) in
        {874}let ck_57: key = (if v_301 then 2-proj-3-tuple(v_300) else caught-fail) in
        {875}let cs_45: cipherstate = (if v_301 then 1-proj-3-tuple(v_300) else caught-fail) in
        {876}let v_302: bitstring = (if v_301 then catch-fail(cipherstateunpack(cs_45)) else caught-fail) in
        {877}let v_303: bool = (not-caught-fail(v_302) && success?(1-proj-2-tuple(v_302))) in
        {878}let n_16: nonce = (if v_303 then 2-proj-2-tuple(v_302) else caught-fail) in
        {879}let k_19: key = (if v_303 then 1-proj-2-tuple(v_302) else caught-fail) in
        {880}let d_2: aead = (if v_303 then catch-fail(decrypt(k_19,n_16,h_45,ciphertext_10)) else caught-fail) in
        {881}let v_304: bool = not-caught-fail(d_2) in
        {882}let v_305: bitstring = (if v_304 then catch-fail(aeadunpack(d_2)) else caught-fail) in
        {883}let v_306: bool = (not-caught-fail(v_305) && success?(1-proj-3-tuple(v_305))) in
        {884}let plaintext_8: bitstring = (if v_306 then 3-proj-3-tuple(v_305) else caught-fail) in
        {885}let adi_2: bitstring = (if v_306 then 2-proj-3-tuple(v_305) else caught-fail) in
        {886}let valid_4: bool = (if v_306 then 1-proj-3-tuple(v_305) else caught-fail) in
        {888}let v_307: bitstring = (if v_306 then catch-fail(cipherstateunpack(cs_45)) else caught-fail) in
        {889}let v_308: bool = (not-caught-fail(v_307) && success?(1-proj-2-tuple(v_307))) in
        {890}let o_8: nonce = (if v_308 then 2-proj-2-tuple(v_307) else caught-fail) in
        {891}let k_20: key = (if v_308 then 1-proj-2-tuple(v_307) else caught-fail) in
        {887}let n_17: nonce = (if v_306 then increment_nonce(n_16) else caught-fail) in
        {892}let csi_16: cipherstate = (if v_306 then catch-fail((if v_308 then cipherstatepack(k_20,n_17) else fail-any)) else caught-fail) in
        {893}let v_309: bool = not-caught-fail(csi_16) in
        {894}let v_310: bitstring = (if v_301 then catch-fail((if v_303 then (if v_304 then (if v_306 then (if v_309 then (csi_16,plaintext_8,valid_4) else fail-any) else fail-any) else fail-any) else fail-any)) else caught-fail) in
        {895}let v_311: bool = (not-caught-fail(v_310) && success?(1-proj-3-tuple(v_310))) in
        {896}let valid_5: bool = (if v_311 then 3-proj-3-tuple(v_310) else caught-fail) in
        {897}let plaintext_9: bitstring = (if v_311 then 2-proj-3-tuple(v_310) else caught-fail) in
        {898}let csi_17: cipherstate = (if v_311 then 1-proj-3-tuple(v_310) else caught-fail) in
        {899}let ss_46: symmetricstate = (if v_311 then symmetricstatepack(csi_17,ck_57,h_45) else caught-fail) in
        {900}let v_312: bitstring = (if v_311 then catch-fail(symmetricstateunpack(ss_46)) else caught-fail) in
        {901}let v_313: bool = (not-caught-fail(v_312) && success?(1-proj-3-tuple(v_312))) in
        {902}let h_46: bitstring = (if v_313 then 3-proj-3-tuple(v_312) else caught-fail) in
        {903}let ck_58: key = (if v_313 then 2-proj-3-tuple(v_312) else caught-fail) in
        {904}let cs_46: cipherstate = (if v_313 then 1-proj-3-tuple(v_312) else caught-fail) in
        {905}let ssi_10: symmetricstate = (if v_311 then catch-fail((if v_313 then symmetricstatepack(cs_46,ck_58,hash(h_46,ciphertext_10)) else fail-any)) else caught-fail) in
        {906}let v_314: bool = not-caught-fail(ssi_10) in
        {907}let v_315: bitstring = (if v_299 then catch-fail((if v_301 then (if v_311 then (if v_314 then (ssi_10,plaintext_9,valid_5) else fail-any) else fail-any) else fail-any)) else caught-fail) in
        {908}let v_316: bool = (not-caught-fail(v_315) && success?(1-proj-3-tuple(v_315))) in
        {909}let valid3: bool = (if v_316 then 3-proj-3-tuple(v_315) else caught-fail) in
        {910}let plaintext_10: bitstring = (if v_316 then 2-proj-3-tuple(v_315) else caught-fail) in
        {911}let ss_47: symmetricstate = (if v_316 then 1-proj-3-tuple(v_315) else caught-fail) in
        {915}let basis_13: key = (if v_316 then key_m(them_2) else caught-fail) in
        {916}let public_key_13: key = (if v_316 then catch-fail(dhexp(basis_13,validkey(g))) else caught-fail) in
        {917}let v_318: bool = not-caught-fail(public_key_13) in
        {912}let basis_12: key = (if v_316 then key_s(them_2) else caught-fail) in
        {913}let public_key_12: key = (if v_316 then catch-fail(dhexp(basis_12,validkey(g))) else caught-fail) in
        {914}let v_317: bool = not-caught-fail(public_key_12) in
        {918}let v_319: bool = (if v_316 then catch-fail(((valid1_1 && (valid2_1 && valid3)) && ((rs_6 = getpublickey((if v_317 then keypairpack(validkey(public_key_12),basis_12) else fail-any))) && (rm_6 = getpublickey((if v_318 then keypairpack(validkey(public_key_13),basis_13) else fail-any)))))) else caught-fail) in
        {920}let v_320: bitstring = (if v_319 then catch-fail(symmetricstateunpack(ss_47)) else caught-fail) in
        {921}let v_321: bool = (not-caught-fail(v_320) && success?(1-proj-3-tuple(v_320))) in
        {922}let h_47: bitstring = (if v_321 then 3-proj-3-tuple(v_320) else caught-fail) in
        {923}let ck_59: key = (if v_321 then 2-proj-3-tuple(v_320) else caught-fail) in
        {924}let cs_47: cipherstate = (if v_321 then 1-proj-3-tuple(v_320) else caught-fail) in
        {925}let input_key_material_14: key = (if v_321 then zero else caught-fail) in
        {928}let output3_14: key = (if v_321 then hmac_hash3(ck_59,input_key_material_14) else caught-fail) in
        {927}let output2_14: key = (if v_321 then hmac_hash2(ck_59,input_key_material_14) else caught-fail) in
        {926}let output1_14: key = (if v_321 then hmac_hash1(ck_59,input_key_material_14) else caught-fail) in
        {929}let v_322: bitstring = (if v_321 then catch-fail((output1_14,output2_14,output3_14)) else caught-fail) in
        {930}let v_323: bool = (not-caught-fail(v_322) && success?(1-proj-3-tuple(v_322))) in
        {931}let temp_k3_2: key = (if v_323 then 3-proj-3-tuple(v_322) else caught-fail) in
        {932}let temp_k2_2: key = (if v_323 then 2-proj-3-tuple(v_322) else caught-fail) in
        {933}let temp_k1_2: key = (if v_323 then 1-proj-3-tuple(v_322) else caught-fail) in
        {935}let cs2_6: cipherstate = (if v_323 then cipherstatepack(temp_k2_2,minnonce) else caught-fail) in
        {934}let cs1_6: cipherstate = (if v_323 then cipherstatepack(temp_k1_2,minnonce) else caught-fail) in
        {936}let v_324: bitstring = (if v_319 then catch-fail((if v_321 then (if v_323 then (ss_47,cs1_6,cs2_6) else fail-any) else fail-any)) else caught-fail) in
        {937}let v_325: bool = (not-caught-fail(v_324) && success?(1-proj-3-tuple(v_324))) in
        {938}let cs2_7: cipherstate = (if v_325 then 3-proj-3-tuple(v_324) else caught-fail) in
        {939}let cs1_7: cipherstate = (if v_325 then 2-proj-3-tuple(v_324) else caught-fail) in
        {940}let ssi_11: symmetricstate = (if v_325 then 1-proj-3-tuple(v_324) else caught-fail) in
        {919}let hs_10: handshakestate = (if v_319 then handshakestatepack(ss_47,s_7,m_7,e_13,rs_6,rm_6,re_6,psk_5,initiator_3) else caught-fail) in
        {941}let (hs_11: handshakestate,plaintext_a: bitstring,valid_6: bool,cs1_8: cipherstate,cs2_8: cipherstate) = (if v_228 then (if v_230 then (if v_233 then (if v_241 then (if v_249 then (if v_266 then (if v_283 then (if v_291 then (if v_299 then (if v_316 then (if undo-catch-fail(v_319) then (if v_325 then (hs_10,plaintext_10,true,cs1_7,cs2_7) else fail-any) else fail-any) else fail-any) else fail-any) else fail-any) else fail-any) else fail-any) else fail-any) else fail-any) else fail-any) else fail-any) else fail-any) in
        {942}event RecvMsg(me_2,them_2,stagepack_a(sid_3),plaintext_a);
        {943}event RecvEnd(valid_6)
    ) | (
        {945}event LeakS(phase0,me_2);
        {946}event LeakM(phase0,me_2);
        {947}out(pub, (key_s(me_2),key_m(me_2)))
    ) | (
        {948}phase 1;
        {949}event LeakS(phase1,me_2);
        {950}event LeakM(phase1,me_2);
        {951}out(pub, (key_s(me_2),key_m(me_2)))
    )
) | (
    {952}let me_4: principal = bob in
    {955}let basis_14: key = key_s(me_4) in
    {956}let public_key_14: key = catch-fail(dhexp(basis_14,validkey(g))) in
    {957}let v_326: bool = not-caught-fail(public_key_14) in
    {958}let s_8: keypair = (if v_326 then keypairpack(validkey(public_key_14),basis_14) else fail-any) in
    {959}let basis_15: key = key_m(me_4) in
    {960}let public_key_15: key = catch-fail(dhexp(basis_15,validkey(g))) in
    {961}let v_327: bool = not-caught-fail(public_key_15) in
    {962}let m_8: keypair = (if v_327 then keypairpack(validkey(public_key_15),basis_15) else fail-any) in
    {963}out(pub, (getpublickey(s_8),getpublickey(m_8)));
    {954}let sid_4: sessionid = sid in
    {953}let them_3: principal = charlie in
    (
        {973}let k_21: key = empty in
        {974}let cs_48: cipherstate = cipherstatepack(k_21,minnonce) in
        {970}let protocol_name_3: bitstring = somename in
        {971}let h_48: bitstring = hash(protocol_name_3,empty) in
        {972}let ck_60: key = h_48 in
        {975}let ss_48: symmetricstate = symmetricstatepack(cs_48,ck_60,h_48) in
        {976}let v_328: bitstring = catch-fail(symmetricstateunpack(ss_48)) in
        {977}let v_329: bool = (not-caught-fail(v_328) && success?(1-proj-3-tuple(v_328))) in
        {978}let h_49: bitstring = (if v_329 then 3-proj-3-tuple(v_328) else caught-fail) in
        {979}let ck_61: key = (if v_329 then 2-proj-3-tuple(v_328) else caught-fail) in
        {980}let cs_49: cipherstate = (if v_329 then 1-proj-3-tuple(v_328) else caught-fail) in
        {968}let prologue_3: bitstring = empty in
        {981}let ss_49: symmetricstate = catch-fail((if v_329 then symmetricstatepack(cs_49,ck_61,hash(h_49,prologue_3)) else fail-any)) in
        {982}let v_330: bool = not-caught-fail(ss_49) in
        {983}let data_2: bitstring = (if v_330 then catch-fail(getpublickey(s_8)) else caught-fail) in
        {984}let v_331: bool = not-caught-fail(data_2) in
        {985}let v_332: bitstring = (if v_331 then catch-fail(symmetricstateunpack(ss_49)) else caught-fail) in
        {986}let v_333: bool = (not-caught-fail(v_332) && success?(1-proj-3-tuple(v_332))) in
        {987}let h_50: bitstring = (if v_333 then 3-proj-3-tuple(v_332) else caught-fail) in
        {988}let ck_62: key = (if v_333 then 2-proj-3-tuple(v_332) else caught-fail) in
        {989}let cs_50: cipherstate = (if v_333 then 1-proj-3-tuple(v_332) else caught-fail) in
        {990}let ss_50: symmetricstate = (if v_330 then catch-fail((if v_331 then (if v_333 then symmetricstatepack(cs_50,ck_62,hash(h_50,data_2)) else fail-any) else fail-any)) else caught-fail) in
        {991}let v_334: bool = not-caught-fail(ss_50) in
        {992}let data_3: bitstring = (if v_334 then catch-fail(getpublickey(m_8)) else caught-fail) in
        {993}let v_335: bool = not-caught-fail(data_3) in
        {994}let v_336: bitstring = (if v_335 then catch-fail(symmetricstateunpack(ss_50)) else caught-fail) in
        {995}let v_337: bool = (not-caught-fail(v_336) && success?(1-proj-3-tuple(v_336))) in
        {996}let h_51: bitstring = (if v_337 then 3-proj-3-tuple(v_336) else caught-fail) in
        {997}let ck_63: key = (if v_337 then 2-proj-3-tuple(v_336) else caught-fail) in
        {998}let cs_51: cipherstate = (if v_337 then 1-proj-3-tuple(v_336) else caught-fail) in
        {999}let ss_51: symmetricstate = (if v_334 then catch-fail((if v_335 then (if v_337 then symmetricstatepack(cs_51,ck_63,hash(h_51,data_3)) else fail-any) else fail-any)) else caught-fail) in
        {1000}let v_338: bool = not-caught-fail(ss_51) in
        {969}let psk_6: key = empty in
        {967}let re_7: key = empty in
        {966}let rm_7: key = empty in
        {965}let rs_7: key = empty in
        {964}let e_14: keypair = keypairpack(empty,empty) in
        {1001}let hs_12: handshakestate = (if v_330 then (if v_334 then (if v_338 then handshakestatepack(ss_51,s_8,m_8,e_14,rs_7,rm_7,re_7,psk_6,false) else fail-any) else fail-any) else fail-any) in
        {1002}insert statestore(me_4,them_3,sid_4,statepack_a(hs_12))
    ) | (
        {1272}get statestore(=me_4,=them_3,=sid_4,statepack_a(hs_13: handshakestate)) in
        {1003}in(pub, message_a_3: bitstring);
        {1004}let v_339: bitstring = catch-fail(handshakestateunpack(hs_13)) in
        {1005}let v_340: bool = (not-caught-fail(v_339) && success?(1-proj-9-tuple(v_339))) in
        {1006}let initiator_4: bool = (if v_340 then 9-proj-9-tuple(v_339) else caught-fail) in
        {1007}let psk_7: key = (if v_340 then 8-proj-9-tuple(v_339) else caught-fail) in
        {1008}let re_8: key = (if v_340 then 7-proj-9-tuple(v_339) else caught-fail) in
        {1009}let rm_8: key = (if v_340 then 6-proj-9-tuple(v_339) else caught-fail) in
        {1010}let rs_8: key = (if v_340 then 5-proj-9-tuple(v_339) else caught-fail) in
        {1011}let e_15: keypair = (if v_340 then 4-proj-9-tuple(v_339) else caught-fail) in
        {1012}let m_9: keypair = (if v_340 then 3-proj-9-tuple(v_339) else caught-fail) in
        {1013}let s_9: keypair = (if v_340 then 2-proj-9-tuple(v_339) else caught-fail) in
        {1014}let ss_52: symmetricstate = (if v_340 then 1-proj-9-tuple(v_339) else caught-fail) in
        {1015}let v_341: bitstring = (if v_340 then catch-fail(deconcat4(message_a_3)) else caught-fail) in
        {1016}let v_342: bool = (not-caught-fail(v_341) && success?(1-proj-4-tuple(v_341))) in
        {1017}let ciphertext_11: bitstring = (if v_342 then 4-proj-4-tuple(v_341) else caught-fail) in
        {1018}let nm_5: bitstring = (if v_342 then 3-proj-4-tuple(v_341) else caught-fail) in
        {1019}let ns_5: bitstring = (if v_342 then 2-proj-4-tuple(v_341) else caught-fail) in
        {1020}let ne_5: bitstring = (if v_342 then 1-proj-4-tuple(v_341) else caught-fail) in
        {1024}let v_343: bitstring = (if v_342 then catch-fail(symmetricstateunpack(ss_52)) else caught-fail) in
        {1025}let v_344: bool = (not-caught-fail(v_343) && success?(1-proj-3-tuple(v_343))) in
        {1026}let h_52: bitstring = (if v_344 then 3-proj-3-tuple(v_343) else caught-fail) in
        {1027}let ck_64: key = (if v_344 then 2-proj-3-tuple(v_343) else caught-fail) in
        {1028}let cs_52: cipherstate = (if v_344 then 1-proj-3-tuple(v_343) else caught-fail) in
        {1023}let re_9: key = (if v_342 then ne_5 else caught-fail) in
        {1029}let ss_53: symmetricstate = (if v_342 then catch-fail((if v_344 then symmetricstatepack(cs_52,ck_64,hash(h_52,re_9)) else fail-any)) else caught-fail) in
        {1030}let v_345: bool = not-caught-fail(ss_53) in
        {1031}let v_346: bitstring = (if v_345 then catch-fail(keypairunpack(s_9)) else caught-fail) in
        {1032}let v_347: bool = (not-caught-fail(v_346) && success?(1-proj-2-tuple(v_346))) in
        {1033}let my_private_key_12: key = (if v_347 then 2-proj-2-tuple(v_346) else caught-fail) in
        {1034}let my_public_key_12: key = (if v_347 then 1-proj-2-tuple(v_346) else caught-fail) in
        {1035}let input_key_material_15: key = (if v_345 then catch-fail((if v_347 then dhexp(my_private_key_12,re_9) else fail-any)) else caught-fail) in
        {1036}let v_348: bool = not-caught-fail(input_key_material_15) in
        {1037}let v_349: bitstring = (if v_348 then catch-fail(symmetricstateunpack(ss_53)) else caught-fail) in
        {1038}let v_350: bool = (not-caught-fail(v_349) && success?(1-proj-3-tuple(v_349))) in
        {1039}let h_53: bitstring = (if v_350 then 3-proj-3-tuple(v_349) else caught-fail) in
        {1040}let ck_65: key = (if v_350 then 2-proj-3-tuple(v_349) else caught-fail) in
        {1041}let cs_53: cipherstate = (if v_350 then 1-proj-3-tuple(v_349) else caught-fail) in
        {1044}let output3_15: key = (if v_350 then hmac_hash3(ck_65,input_key_material_15) else caught-fail) in
        {1043}let output2_15: key = (if v_350 then hmac_hash2(ck_65,input_key_material_15) else caught-fail) in
        {1042}let output1_15: key = (if v_350 then hmac_hash1(ck_65,input_key_material_15) else caught-fail) in
        {1045}let v_351: bitstring = (if v_350 then catch-fail((output1_15,output2_15,output3_15)) else caught-fail) in
        {1046}let v_352: bool = (not-caught-fail(v_351) && success?(1-proj-3-tuple(v_351))) in
        {1047}let output_12: key = (if v_352 then 3-proj-3-tuple(v_351) else caught-fail) in
        {1048}let temp_k_12: key = (if v_352 then 2-proj-3-tuple(v_351) else caught-fail) in
        {1049}let ck_66: key = (if v_352 then 1-proj-3-tuple(v_351) else caught-fail) in
        {1050}let ss_54: symmetricstate = (if v_345 then catch-fail((if v_348 then (if v_350 then (if v_352 then symmetricstatepack(cipherstatepack(temp_k_12,minnonce),ck_66,h_53) else fail-any) else fail-any) else fail-any)) else caught-fail) in
        {1051}let v_353: bool = not-caught-fail(ss_54) in
        {1052}let v_354: bitstring = (if v_353 then catch-fail(keypairunpack(m_9)) else caught-fail) in
        {1053}let v_355: bool = (not-caught-fail(v_354) && success?(1-proj-2-tuple(v_354))) in
        {1054}let my_private_key_13: key = (if v_355 then 2-proj-2-tuple(v_354) else caught-fail) in
        {1055}let my_public_key_13: key = (if v_355 then 1-proj-2-tuple(v_354) else caught-fail) in
        {1056}let input_key_material_16: key = (if v_353 then catch-fail((if v_355 then dhexp(my_private_key_13,re_9) else fail-any)) else caught-fail) in
        {1057}let v_356: bool = not-caught-fail(input_key_material_16) in
        {1058}let v_357: bitstring = (if v_356 then catch-fail(symmetricstateunpack(ss_54)) else caught-fail) in
        {1059}let v_358: bool = (not-caught-fail(v_357) && success?(1-proj-3-tuple(v_357))) in
        {1060}let h_54: bitstring = (if v_358 then 3-proj-3-tuple(v_357) else caught-fail) in
        {1061}let ck_67: key = (if v_358 then 2-proj-3-tuple(v_357) else caught-fail) in
        {1062}let cs_54: cipherstate = (if v_358 then 1-proj-3-tuple(v_357) else caught-fail) in
        {1065}let output3_16: key = (if v_358 then hmac_hash3(ck_67,input_key_material_16) else caught-fail) in
        {1064}let output2_16: key = (if v_358 then hmac_hash2(ck_67,input_key_material_16) else caught-fail) in
        {1063}let output1_16: key = (if v_358 then hmac_hash1(ck_67,input_key_material_16) else caught-fail) in
        {1066}let v_359: bitstring = (if v_358 then catch-fail((output1_16,output2_16,output3_16)) else caught-fail) in
        {1067}let v_360: bool = (not-caught-fail(v_359) && success?(1-proj-3-tuple(v_359))) in
        {1068}let output_13: key = (if v_360 then 3-proj-3-tuple(v_359) else caught-fail) in
        {1069}let temp_k_13: key = (if v_360 then 2-proj-3-tuple(v_359) else caught-fail) in
        {1070}let ck_68: key = (if v_360 then 1-proj-3-tuple(v_359) else caught-fail) in
        {1071}let ss_55: symmetricstate = (if v_353 then catch-fail((if v_356 then (if v_358 then (if v_360 then symmetricstatepack(cipherstatepack(temp_k_13,minnonce),ck_68,h_54) else fail-any) else fail-any) else fail-any)) else caught-fail) in
        {1072}let v_361: bool = not-caught-fail(ss_55) in
        {1073}let v_362: bitstring = (if v_361 then catch-fail(symmetricstateunpack(ss_55)) else caught-fail) in
        {1074}let v_363: bool = (not-caught-fail(v_362) && success?(1-proj-3-tuple(v_362))) in
        {1075}let h_55: bitstring = (if v_363 then 3-proj-3-tuple(v_362) else caught-fail) in
        {1076}let ck_69: key = (if v_363 then 2-proj-3-tuple(v_362) else caught-fail) in
        {1077}let cs_55: cipherstate = (if v_363 then 1-proj-3-tuple(v_362) else caught-fail) in
        {1078}let v_364: bitstring = (if v_363 then catch-fail(cipherstateunpack(cs_55)) else caught-fail) in
        {1079}let v_365: bool = (not-caught-fail(v_364) && success?(1-proj-2-tuple(v_364))) in
        {1080}let n_18: nonce = (if v_365 then 2-proj-2-tuple(v_364) else caught-fail) in
        {1081}let k_22: key = (if v_365 then 1-proj-2-tuple(v_364) else caught-fail) in
        {1082}let d_3: aead = (if v_365 then catch-fail(decrypt(k_22,n_18,h_55,ns_5)) else caught-fail) in
        {1083}let v_366: bool = not-caught-fail(d_3) in
        {1084}let v_367: bitstring = (if v_366 then catch-fail(aeadunpack(d_3)) else caught-fail) in
        {1085}let v_368: bool = (not-caught-fail(v_367) && success?(1-proj-3-tuple(v_367))) in
        {1086}let plaintext_11: bitstring = (if v_368 then 3-proj-3-tuple(v_367) else caught-fail) in
        {1087}let adi_3: bitstring = (if v_368 then 2-proj-3-tuple(v_367) else caught-fail) in
        {1088}let valid_7: bool = (if v_368 then 1-proj-3-tuple(v_367) else caught-fail) in
        {1090}let v_369: bitstring = (if v_368 then catch-fail(cipherstateunpack(cs_55)) else caught-fail) in
        {1091}let v_370: bool = (not-caught-fail(v_369) && success?(1-proj-2-tuple(v_369))) in
        {1092}let o_9: nonce = (if v_370 then 2-proj-2-tuple(v_369) else caught-fail) in
        {1093}let k_23: key = (if v_370 then 1-proj-2-tuple(v_369) else caught-fail) in
        {1089}let n_19: nonce = (if v_368 then increment_nonce(n_18) else caught-fail) in
        {1094}let csi_18: cipherstate = (if v_368 then catch-fail((if v_370 then cipherstatepack(k_23,n_19) else fail-any)) else caught-fail) in
        {1095}let v_371: bool = not-caught-fail(csi_18) in
        {1096}let v_372: bitstring = (if v_363 then catch-fail((if v_365 then (if v_366 then (if v_368 then (if v_371 then (csi_18,plaintext_11,valid_7) else fail-any) else fail-any) else fail-any) else fail-any)) else caught-fail) in
        {1097}let v_373: bool = (not-caught-fail(v_372) && success?(1-proj-3-tuple(v_372))) in
        {1098}let valid_8: bool = (if v_373 then 3-proj-3-tuple(v_372) else caught-fail) in
        {1099}let plaintext_12: bitstring = (if v_373 then 2-proj-3-tuple(v_372) else caught-fail) in
        {1100}let csi_19: cipherstate = (if v_373 then 1-proj-3-tuple(v_372) else caught-fail) in
        {1101}let ss_56: symmetricstate = (if v_373 then symmetricstatepack(csi_19,ck_69,h_55) else caught-fail) in
        {1102}let v_374: bitstring = (if v_373 then catch-fail(symmetricstateunpack(ss_56)) else caught-fail) in
        {1103}let v_375: bool = (not-caught-fail(v_374) && success?(1-proj-3-tuple(v_374))) in
        {1104}let h_56: bitstring = (if v_375 then 3-proj-3-tuple(v_374) else caught-fail) in
        {1105}let ck_70: key = (if v_375 then 2-proj-3-tuple(v_374) else caught-fail) in
        {1106}let cs_56: cipherstate = (if v_375 then 1-proj-3-tuple(v_374) else caught-fail) in
        {1107}let ssi_12: symmetricstate = (if v_373 then catch-fail((if v_375 then symmetricstatepack(cs_56,ck_70,hash(h_56,ns_5)) else fail-any)) else caught-fail) in
        {1108}let v_376: bool = not-caught-fail(ssi_12) in
        {1109}let v_377: bitstring = (if v_361 then catch-fail((if v_363 then (if v_373 then (if v_376 then (ssi_12,plaintext_12,valid_8) else fail-any) else fail-any) else fail-any)) else caught-fail) in
        {1110}let v_378: bool = (not-caught-fail(v_377) && success?(1-proj-3-tuple(v_377))) in
        {1111}let valid1_3: bool = (if v_378 then 3-proj-3-tuple(v_377) else caught-fail) in
        {1112}let se_1: bitstring = (if v_378 then 2-proj-3-tuple(v_377) else caught-fail) in
        {1113}let ss_57: symmetricstate = (if v_378 then 1-proj-3-tuple(v_377) else caught-fail) in
        {1115}let v_379: bitstring = (if v_378 then catch-fail(symmetricstateunpack(ss_57)) else caught-fail) in
        {1116}let v_380: bool = (not-caught-fail(v_379) && success?(1-proj-3-tuple(v_379))) in
        {1117}let h_57: bitstring = (if v_380 then 3-proj-3-tuple(v_379) else caught-fail) in
        {1118}let ck_71: key = (if v_380 then 2-proj-3-tuple(v_379) else caught-fail) in
        {1119}let cs_57: cipherstate = (if v_380 then 1-proj-3-tuple(v_379) else caught-fail) in
        {1120}let v_381: bitstring = (if v_380 then catch-fail(cipherstateunpack(cs_57)) else caught-fail) in
        {1121}let v_382: bool = (not-caught-fail(v_381) && success?(1-proj-2-tuple(v_381))) in
        {1122}let n_20: nonce = (if v_382 then 2-proj-2-tuple(v_381) else caught-fail) in
        {1123}let k_24: key = (if v_382 then 1-proj-2-tuple(v_381) else caught-fail) in
        {1124}let d_4: aead = (if v_382 then catch-fail(decrypt(k_24,n_20,h_57,nm_5)) else caught-fail) in
        {1125}let v_383: bool = not-caught-fail(d_4) in
        {1126}let v_384: bitstring = (if v_383 then catch-fail(aeadunpack(d_4)) else caught-fail) in
        {1127}let v_385: bool = (not-caught-fail(v_384) && success?(1-proj-3-tuple(v_384))) in
        {1128}let plaintext_13: bitstring = (if v_385 then 3-proj-3-tuple(v_384) else caught-fail) in
        {1129}let adi_4: bitstring = (if v_385 then 2-proj-3-tuple(v_384) else caught-fail) in
        {1130}let valid_9: bool = (if v_385 then 1-proj-3-tuple(v_384) else caught-fail) in
        {1132}let v_386: bitstring = (if v_385 then catch-fail(cipherstateunpack(cs_57)) else caught-fail) in
        {1133}let v_387: bool = (not-caught-fail(v_386) && success?(1-proj-2-tuple(v_386))) in
        {1134}let o_10: nonce = (if v_387 then 2-proj-2-tuple(v_386) else caught-fail) in
        {1135}let k_25: key = (if v_387 then 1-proj-2-tuple(v_386) else caught-fail) in
        {1131}let n_21: nonce = (if v_385 then increment_nonce(n_20) else caught-fail) in
        {1136}let csi_20: cipherstate = (if v_385 then catch-fail((if v_387 then cipherstatepack(k_25,n_21) else fail-any)) else caught-fail) in
        {1137}let v_388: bool = not-caught-fail(csi_20) in
        {1138}let v_389: bitstring = (if v_380 then catch-fail((if v_382 then (if v_383 then (if v_385 then (if v_388 then (csi_20,plaintext_13,valid_9) else fail-any) else fail-any) else fail-any) else fail-any)) else caught-fail) in
        {1139}let v_390: bool = (not-caught-fail(v_389) && success?(1-proj-3-tuple(v_389))) in
        {1140}let valid_10: bool = (if v_390 then 3-proj-3-tuple(v_389) else caught-fail) in
        {1141}let plaintext_14: bitstring = (if v_390 then 2-proj-3-tuple(v_389) else caught-fail) in
        {1142}let csi_21: cipherstate = (if v_390 then 1-proj-3-tuple(v_389) else caught-fail) in
        {1143}let ss_58: symmetricstate = (if v_390 then symmetricstatepack(csi_21,ck_71,h_57) else caught-fail) in
        {1144}let v_391: bitstring = (if v_390 then catch-fail(symmetricstateunpack(ss_58)) else caught-fail) in
        {1145}let v_392: bool = (not-caught-fail(v_391) && success?(1-proj-3-tuple(v_391))) in
        {1146}let h_58: bitstring = (if v_392 then 3-proj-3-tuple(v_391) else caught-fail) in
        {1147}let ck_72: key = (if v_392 then 2-proj-3-tuple(v_391) else caught-fail) in
        {1148}let cs_58: cipherstate = (if v_392 then 1-proj-3-tuple(v_391) else caught-fail) in
        {1149}let ssi_13: symmetricstate = (if v_390 then catch-fail((if v_392 then symmetricstatepack(cs_58,ck_72,hash(h_58,nm_5)) else fail-any)) else caught-fail) in
        {1150}let v_393: bool = not-caught-fail(ssi_13) in
        {1151}let v_394: bitstring = (if v_378 then catch-fail((if v_380 then (if v_390 then (if v_393 then (ssi_13,plaintext_14,valid_10) else fail-any) else fail-any) else fail-any)) else caught-fail) in
        {1152}let v_395: bool = (not-caught-fail(v_394) && success?(1-proj-3-tuple(v_394))) in
        {1153}let valid2_3: bool = (if v_395 then 3-proj-3-tuple(v_394) else caught-fail) in
        {1154}let me_5: bitstring = (if v_395 then 2-proj-3-tuple(v_394) else caught-fail) in
        {1155}let ss_59: symmetricstate = (if v_395 then 1-proj-3-tuple(v_394) else caught-fail) in
        {1157}let v_396: bitstring = (if v_395 then catch-fail(keypairunpack(s_9)) else caught-fail) in
        {1158}let v_397: bool = (not-caught-fail(v_396) && success?(1-proj-2-tuple(v_396))) in
        {1159}let my_private_key_14: key = (if v_397 then 2-proj-2-tuple(v_396) else caught-fail) in
        {1160}let my_public_key_14: key = (if v_397 then 1-proj-2-tuple(v_396) else caught-fail) in
        {1156}let rm_9: key = (if v_395 then me_5 else caught-fail) in
        {1161}let input_key_material_17: key = (if v_395 then catch-fail((if v_397 then dhexp(my_private_key_14,rm_9) else fail-any)) else caught-fail) in
        {1162}let v_398: bool = not-caught-fail(input_key_material_17) in
        {1163}let v_399: bitstring = (if v_398 then catch-fail(symmetricstateunpack(ss_59)) else caught-fail) in
        {1164}let v_400: bool = (not-caught-fail(v_399) && success?(1-proj-3-tuple(v_399))) in
        {1165}let h_59: bitstring = (if v_400 then 3-proj-3-tuple(v_399) else caught-fail) in
        {1166}let ck_73: key = (if v_400 then 2-proj-3-tuple(v_399) else caught-fail) in
        {1167}let cs_59: cipherstate = (if v_400 then 1-proj-3-tuple(v_399) else caught-fail) in
        {1170}let output3_17: key = (if v_400 then hmac_hash3(ck_73,input_key_material_17) else caught-fail) in
        {1169}let output2_17: key = (if v_400 then hmac_hash2(ck_73,input_key_material_17) else caught-fail) in
        {1168}let output1_17: key = (if v_400 then hmac_hash1(ck_73,input_key_material_17) else caught-fail) in
        {1171}let v_401: bitstring = (if v_400 then catch-fail((output1_17,output2_17,output3_17)) else caught-fail) in
        {1172}let v_402: bool = (not-caught-fail(v_401) && success?(1-proj-3-tuple(v_401))) in
        {1173}let output_14: key = (if v_402 then 3-proj-3-tuple(v_401) else caught-fail) in
        {1174}let temp_k_14: key = (if v_402 then 2-proj-3-tuple(v_401) else caught-fail) in
        {1175}let ck_74: key = (if v_402 then 1-proj-3-tuple(v_401) else caught-fail) in
        {1176}let ss_60: symmetricstate = (if v_395 then catch-fail((if v_398 then (if v_400 then (if v_402 then symmetricstatepack(cipherstatepack(temp_k_14,minnonce),ck_74,h_59) else fail-any) else fail-any) else fail-any)) else caught-fail) in
        {1177}let v_403: bool = not-caught-fail(ss_60) in
        {1178}let v_404: bitstring = (if v_403 then catch-fail(keypairunpack(m_9)) else caught-fail) in
        {1179}let v_405: bool = (not-caught-fail(v_404) && success?(1-proj-2-tuple(v_404))) in
        {1180}let my_private_key_15: key = (if v_405 then 2-proj-2-tuple(v_404) else caught-fail) in
        {1181}let my_public_key_15: key = (if v_405 then 1-proj-2-tuple(v_404) else caught-fail) in
        {1114}let rs_9: key = (if v_378 then se_1 else caught-fail) in
        {1182}let input_key_material_18: key = (if v_403 then catch-fail((if v_405 then dhexp(my_private_key_15,rs_9) else fail-any)) else caught-fail) in
        {1183}let v_406: bool = not-caught-fail(input_key_material_18) in
        {1184}let v_407: bitstring = (if v_406 then catch-fail(symmetricstateunpack(ss_60)) else caught-fail) in
        {1185}let v_408: bool = (not-caught-fail(v_407) && success?(1-proj-3-tuple(v_407))) in
        {1186}let h_60: bitstring = (if v_408 then 3-proj-3-tuple(v_407) else caught-fail) in
        {1187}let ck_75: key = (if v_408 then 2-proj-3-tuple(v_407) else caught-fail) in
        {1188}let cs_60: cipherstate = (if v_408 then 1-proj-3-tuple(v_407) else caught-fail) in
        {1191}let output3_18: key = (if v_408 then hmac_hash3(ck_75,input_key_material_18) else caught-fail) in
        {1190}let output2_18: key = (if v_408 then hmac_hash2(ck_75,input_key_material_18) else caught-fail) in
        {1189}let output1_18: key = (if v_408 then hmac_hash1(ck_75,input_key_material_18) else caught-fail) in
        {1192}let v_409: bitstring = (if v_408 then catch-fail((output1_18,output2_18,output3_18)) else caught-fail) in
        {1193}let v_410: bool = (not-caught-fail(v_409) && success?(1-proj-3-tuple(v_409))) in
        {1194}let output_15: key = (if v_410 then 3-proj-3-tuple(v_409) else caught-fail) in
        {1195}let temp_k_15: key = (if v_410 then 2-proj-3-tuple(v_409) else caught-fail) in
        {1196}let ck_76: key = (if v_410 then 1-proj-3-tuple(v_409) else caught-fail) in
        {1197}let ss_61: symmetricstate = (if v_403 then catch-fail((if v_406 then (if v_408 then (if v_410 then symmetricstatepack(cipherstatepack(temp_k_15,minnonce),ck_76,h_60) else fail-any) else fail-any) else fail-any)) else caught-fail) in
        {1198}let v_411: bool = not-caught-fail(ss_61) in
        {1199}let v_412: bitstring = (if v_411 then catch-fail(symmetricstateunpack(ss_61)) else caught-fail) in
        {1200}let v_413: bool = (not-caught-fail(v_412) && success?(1-proj-3-tuple(v_412))) in
        {1201}let h_61: bitstring = (if v_413 then 3-proj-3-tuple(v_412) else caught-fail) in
        {1202}let ck_77: key = (if v_413 then 2-proj-3-tuple(v_412) else caught-fail) in
        {1203}let cs_61: cipherstate = (if v_413 then 1-proj-3-tuple(v_412) else caught-fail) in
        {1204}let v_414: bitstring = (if v_413 then catch-fail(cipherstateunpack(cs_61)) else caught-fail) in
        {1205}let v_415: bool = (not-caught-fail(v_414) && success?(1-proj-2-tuple(v_414))) in
        {1206}let n_22: nonce = (if v_415 then 2-proj-2-tuple(v_414) else caught-fail) in
        {1207}let k_26: key = (if v_415 then 1-proj-2-tuple(v_414) else caught-fail) in
        {1208}let d_5: aead = (if v_415 then catch-fail(decrypt(k_26,n_22,h_61,ciphertext_11)) else caught-fail) in
        {1209}let v_416: bool = not-caught-fail(d_5) in
        {1210}let v_417: bitstring = (if v_416 then catch-fail(aeadunpack(d_5)) else caught-fail) in
        {1211}let v_418: bool = (not-caught-fail(v_417) && success?(1-proj-3-tuple(v_417))) in
        {1212}let plaintext_15: bitstring = (if v_418 then 3-proj-3-tuple(v_417) else caught-fail) in
        {1213}let adi_5: bitstring = (if v_418 then 2-proj-3-tuple(v_417) else caught-fail) in
        {1214}let valid_11: bool = (if v_418 then 1-proj-3-tuple(v_417) else caught-fail) in
        {1216}let v_419: bitstring = (if v_418 then catch-fail(cipherstateunpack(cs_61)) else caught-fail) in
        {1217}let v_420: bool = (not-caught-fail(v_419) && success?(1-proj-2-tuple(v_419))) in
        {1218}let o_11: nonce = (if v_420 then 2-proj-2-tuple(v_419) else caught-fail) in
        {1219}let k_27: key = (if v_420 then 1-proj-2-tuple(v_419) else caught-fail) in
        {1215}let n_23: nonce = (if v_418 then increment_nonce(n_22) else caught-fail) in
        {1220}let csi_22: cipherstate = (if v_418 then catch-fail((if v_420 then cipherstatepack(k_27,n_23) else fail-any)) else caught-fail) in
        {1221}let v_421: bool = not-caught-fail(csi_22) in
        {1222}let v_422: bitstring = (if v_413 then catch-fail((if v_415 then (if v_416 then (if v_418 then (if v_421 then (csi_22,plaintext_15,valid_11) else fail-any) else fail-any) else fail-any) else fail-any)) else caught-fail) in
        {1223}let v_423: bool = (not-caught-fail(v_422) && success?(1-proj-3-tuple(v_422))) in
        {1224}let valid_12: bool = (if v_423 then 3-proj-3-tuple(v_422) else caught-fail) in
        {1225}let plaintext_16: bitstring = (if v_423 then 2-proj-3-tuple(v_422) else caught-fail) in
        {1226}let csi_23: cipherstate = (if v_423 then 1-proj-3-tuple(v_422) else caught-fail) in
        {1227}let ss_62: symmetricstate = (if v_423 then symmetricstatepack(csi_23,ck_77,h_61) else caught-fail) in
        {1228}let v_424: bitstring = (if v_423 then catch-fail(symmetricstateunpack(ss_62)) else caught-fail) in
        {1229}let v_425: bool = (not-caught-fail(v_424) && success?(1-proj-3-tuple(v_424))) in
        {1230}let h_62: bitstring = (if v_425 then 3-proj-3-tuple(v_424) else caught-fail) in
        {1231}let ck_78: key = (if v_425 then 2-proj-3-tuple(v_424) else caught-fail) in
        {1232}let cs_62: cipherstate = (if v_425 then 1-proj-3-tuple(v_424) else caught-fail) in
        {1233}let ssi_14: symmetricstate = (if v_423 then catch-fail((if v_425 then symmetricstatepack(cs_62,ck_78,hash(h_62,ciphertext_11)) else fail-any)) else caught-fail) in
        {1234}let v_426: bool = not-caught-fail(ssi_14) in
        {1235}let v_427: bitstring = (if v_411 then catch-fail((if v_413 then (if v_423 then (if v_426 then (ssi_14,plaintext_16,valid_12) else fail-any) else fail-any) else fail-any)) else caught-fail) in
        {1236}let v_428: bool = (not-caught-fail(v_427) && success?(1-proj-3-tuple(v_427))) in
        {1237}let valid3_1: bool = (if v_428 then 3-proj-3-tuple(v_427) else caught-fail) in
        {1238}let plaintext_17: bitstring = (if v_428 then 2-proj-3-tuple(v_427) else caught-fail) in
        {1239}let ss_63: symmetricstate = (if v_428 then 1-proj-3-tuple(v_427) else caught-fail) in
        {1243}let basis_17: key = (if v_428 then key_m(them_3) else caught-fail) in
        {1244}let public_key_17: key = (if v_428 then catch-fail(dhexp(basis_17,validkey(g))) else caught-fail) in
        {1245}let v_430: bool = not-caught-fail(public_key_17) in
        {1240}let basis_16: key = (if v_428 then key_s(them_3) else caught-fail) in
        {1241}let public_key_16: key = (if v_428 then catch-fail(dhexp(basis_16,validkey(g))) else caught-fail) in
        {1242}let v_429: bool = not-caught-fail(public_key_16) in
        {1246}let v_431: bool = (if v_428 then catch-fail(((valid1_3 && (valid2_3 && valid3_1)) && ((rs_9 = getpublickey((if v_429 then keypairpack(validkey(public_key_16),basis_16) else fail-any))) && (rm_9 = getpublickey((if v_430 then keypairpack(validkey(public_key_17),basis_17) else fail-any)))))) else caught-fail) in
        {1248}let v_432: bitstring = (if v_431 then catch-fail(symmetricstateunpack(ss_63)) else caught-fail) in
        {1249}let v_433: bool = (not-caught-fail(v_432) && success?(1-proj-3-tuple(v_432))) in
        {1250}let h_63: bitstring = (if v_433 then 3-proj-3-tuple(v_432) else caught-fail) in
        {1251}let ck_79: key = (if v_433 then 2-proj-3-tuple(v_432) else caught-fail) in
        {1252}let cs_63: cipherstate = (if v_433 then 1-proj-3-tuple(v_432) else caught-fail) in
        {1253}let input_key_material_19: key = (if v_433 then zero else caught-fail) in
        {1256}let output3_19: key = (if v_433 then hmac_hash3(ck_79,input_key_material_19) else caught-fail) in
        {1255}let output2_19: key = (if v_433 then hmac_hash2(ck_79,input_key_material_19) else caught-fail) in
        {1254}let output1_19: key = (if v_433 then hmac_hash1(ck_79,input_key_material_19) else caught-fail) in
        {1257}let v_434: bitstring = (if v_433 then catch-fail((output1_19,output2_19,output3_19)) else caught-fail) in
        {1258}let v_435: bool = (not-caught-fail(v_434) && success?(1-proj-3-tuple(v_434))) in
        {1259}let temp_k3_3: key = (if v_435 then 3-proj-3-tuple(v_434) else caught-fail) in
        {1260}let temp_k2_3: key = (if v_435 then 2-proj-3-tuple(v_434) else caught-fail) in
        {1261}let temp_k1_3: key = (if v_435 then 1-proj-3-tuple(v_434) else caught-fail) in
        {1263}let cs2_9: cipherstate = (if v_435 then cipherstatepack(temp_k2_3,minnonce) else caught-fail) in
        {1262}let cs1_9: cipherstate = (if v_435 then cipherstatepack(temp_k1_3,minnonce) else caught-fail) in
        {1264}let v_436: bitstring = (if v_431 then catch-fail((if v_433 then (if v_435 then (ss_63,cs1_9,cs2_9) else fail-any) else fail-any)) else caught-fail) in
        {1265}let v_437: bool = (not-caught-fail(v_436) && success?(1-proj-3-tuple(v_436))) in
        {1266}let cs2_10: cipherstate = (if v_437 then 3-proj-3-tuple(v_436) else caught-fail) in
        {1267}let cs1_10: cipherstate = (if v_437 then 2-proj-3-tuple(v_436) else caught-fail) in
        {1268}let ssi_15: symmetricstate = (if v_437 then 1-proj-3-tuple(v_436) else caught-fail) in
        {1247}let hs_14: handshakestate = (if v_431 then handshakestatepack(ss_63,s_9,m_9,e_15,rs_9,rm_9,re_9,psk_7,initiator_4) else caught-fail) in
        {1269}let (hs_15: handshakestate,plaintext_a_1: bitstring,valid_13: bool,cs1_11: cipherstate,cs2_11: cipherstate) = (if v_340 then (if v_342 then (if v_345 then (if v_353 then (if v_361 then (if v_378 then (if v_395 then (if v_403 then (if v_411 then (if v_428 then (if undo-catch-fail(v_431) then (if v_437 then (hs_14,plaintext_17,true,cs1_10,cs2_10) else fail-any) else fail-any) else fail-any) else fail-any) else fail-any) else fail-any) else fail-any) else fail-any) else fail-any) else fail-any) else fail-any) else fail-any) in
        {1270}event RecvMsg(me_4,them_3,stagepack_a(sid_4),plaintext_a_1);
        {1271}event RecvEnd(valid_13)
    ) | (
        {1273}event LeakS(phase0,me_4);
        {1274}event LeakM(phase0,me_4);
        {1275}out(pub, (key_s(me_4),key_m(me_4)))
    ) | (
        {1276}phase 1;
        {1277}event LeakS(phase1,me_4);
        {1278}event LeakM(phase1,me_4);
        {1279}out(pub, (key_s(me_4),key_m(me_4)))
    )
)

-- Query event(RecvMsg(bob,alice,stagepack_a(sid_b),m_10)) ==> event(SendMsg(alice,bob,stagepack_a(sid_a),m_10)); event(RecvMsg(bob,alice,stagepack_a(sid_b),m_10)) ==> event(SendMsg(alice,c,stagepack_a(sid_a),m_10)) || (event(LeakS(phase0,alice)) && event(LeakM(phase0,alice))) || (event(LeakS(phase0,bob)) && event(LeakM(phase0,bob))); event(RecvMsg(bob,alice,stagepack_a(sid_b),m_10)) ==> event(SendMsg(alice,c,stagepack_a(sid_a),m_10)) || (event(LeakS(phase0,alice)) && event(LeakM(phase0,alice))); event(RecvMsg(bob,alice,stagepack_a(sid_b),m_10)) ==> event(SendMsg(alice,bob,stagepack_a(sid_a),m_10)) || (event(LeakS(phase0,alice)) && event(LeakM(phase0,alice))) || (event(LeakS(phase0,bob)) && event(LeakM(phase0,bob))); event(RecvMsg(bob,alice,stagepack_a(sid_b),m_10)) ==> event(SendMsg(alice,bob,stagepack_a(sid_a),m_10)) || (event(LeakS(phase0,alice)) && event(LeakM(phase0,alice))); not attacker_p1(msg_a(alice,bob,sid_a)); attacker_p1(msg_a(alice,bob,sid_a)) ==> event(LeakS(px,bob)) && event(LeakM(px,bob)); attacker_p1(msg_a(alice,bob,sid_a)) ==> (event(LeakS(phase0,bob)) && event(LeakM(phase0,bob))) || (event(LeakS(px,bob)) && event(LeakM(px,bob)) && event(LeakS(pz,alice)) && event(LeakM(pz,alice))); attacker_p1(msg_a(alice,bob,sid_a)) ==> event(LeakS(phase0,bob)) && event(LeakM(phase0,bob)); not event(RecvEnd(true)) in process 1.
Translating the process into Horn clauses...
Completing...
200 rules inserted. Base: 200 rules (82 with conclusion selected). Queue: 147 rules.
400 rules inserted. Base: 398 rules (144 with conclusion selected). Queue: 64 rules.
600 rules inserted. Base: 588 rules (214 with conclusion selected). Queue: 154 rules.
800 rules inserted. Base: 687 rules (214 with conclusion selected). Queue: 201 rules.
1000 rules inserted. Base: 765 rules (214 with conclusion selected). Queue: 234 rules.
1200 rules inserted. Base: 890 rules (214 with conclusion selected). Queue: 301 rules.
1400 rules inserted. Base: 1008 rules (214 with conclusion selected). Queue: 384 rules.
1600 rules inserted. Base: 1088 rules (214 with conclusion selected). Queue: 476 rules.
1800 rules inserted. Base: 1174 rules (214 with conclusion selected). Queue: 565 rules.
2000 rules inserted. Base: 1275 rules (214 with conclusion selected). Queue: 622 rules.
2200 rules inserted. Base: 1383 rules (214 with conclusion selected). Queue: 705 rules.
2400 rules inserted. Base: 1479 rules (214 with conclusion selected). Queue: 754 rules.
2600 rules inserted. Base: 1577 rules (214 with conclusion selected). Queue: 776 rules.
2800 rules inserted. Base: 1696 rules (214 with conclusion selected). Queue: 851 rules.
3000 rules inserted. Base: 1789 rules (214 with conclusion selected). Queue: 867 rules.
3200 rules inserted. Base: 1881 rules (214 with conclusion selected). Queue: 883 rules.
3400 rules inserted. Base: 1969 rules (214 with conclusion selected). Queue: 904 rules.
3600 rules inserted. Base: 2063 rules (214 with conclusion selected). Queue: 927 rules.
3800 rules inserted. Base: 2155 rules (214 with conclusion selected). Queue: 959 rules.
4000 rules inserted. Base: 2223 rules (214 with conclusion selected). Queue: 982 rules.
4200 rules inserted. Base: 2314 rules (214 with conclusion selected). Queue: 994 rules.
4400 rules inserted. Base: 2372 rules (214 with conclusion selected). Queue: 1008 rules.
4600 rules inserted. Base: 2453 rules (214 with conclusion selected). Queue: 1041 rules.
4800 rules inserted. Base: 2538 rules (214 with conclusion selected). Queue: 1040 rules.
5000 rules inserted. Base: 2616 rules (214 with conclusion selected). Queue: 998 rules.
5200 rules inserted. Base: 2705 rules (214 with conclusion selected). Queue: 959 rules.
5400 rules inserted. Base: 2778 rules (214 with conclusion selected). Queue: 954 rules.
5600 rules inserted. Base: 2867 rules (214 with conclusion selected). Queue: 895 rules.
5800 rules inserted. Base: 2944 rules (214 with conclusion selected). Queue: 847 rules.
6000 rules inserted. Base: 3050 rules (214 with conclusion selected). Queue: 893 rules.
6200 rules inserted. Base: 3164 rules (214 with conclusion selected). Queue: 901 rules.
6400 rules inserted. Base: 3256 rules (214 with conclusion selected). Queue: 908 rules.
6600 rules inserted. Base: 3377 rules (215 with conclusion selected). Queue: 966 rules.
6800 rules inserted. Base: 3484 rules (215 with conclusion selected). Queue: 968 rules.
7000 rules inserted. Base: 3603 rules (215 with conclusion selected). Queue: 961 rules.
7200 rules inserted. Base: 3673 rules (215 with conclusion selected). Queue: 933 rules.
7400 rules inserted. Base: 3796 rules (215 with conclusion selected). Queue: 946 rules.
7600 rules inserted. Base: 3909 rules (220 with conclusion selected). Queue: 955 rules.
7800 rules inserted. Base: 4044 rules (220 with conclusion selected). Queue: 984 rules.
8000 rules inserted. Base: 4100 rules (220 with conclusion selected). Queue: 963 rules.
8200 rules inserted. Base: 4226 rules (220 with conclusion selected). Queue: 1096 rules.
8400 rules inserted. Base: 4367 rules (223 with conclusion selected). Queue: 1085 rules.
8600 rules inserted. Base: 4489 rules (223 with conclusion selected). Queue: 1130 rules.
8800 rules inserted. Base: 4633 rules (224 with conclusion selected). Queue: 1065 rules.
9000 rules inserted. Base: 4727 rules (224 with conclusion selected). Queue: 1211 rules.
9200 rules inserted. Base: 4874 rules (224 with conclusion selected). Queue: 1310 rules.
9400 rules inserted. Base: 5029 rules (224 with conclusion selected). Queue: 1271 rules.
9600 rules inserted. Base: 5138 rules (229 with conclusion selected). Queue: 1451 rules.
9800 rules inserted. Base: 5002 rules (232 with conclusion selected). Queue: 1392 rules.
10000 rules inserted. Base: 5066 rules (233 with conclusion selected). Queue: 1502 rules.
10200 rules inserted. Base: 5159 rules (233 with conclusion selected). Queue: 1599 rules.
10400 rules inserted. Base: 5272 rules (233 with conclusion selected). Queue: 1671 rules.
10600 rules inserted. Base: 5435 rules (235 with conclusion selected). Queue: 1650 rules.
10800 rules inserted. Base: 5497 rules (235 with conclusion selected). Queue: 1817 rules.
11000 rules inserted. Base: 5587 rules (235 with conclusion selected). Queue: 1884 rules.
11200 rules inserted. Base: 5690 rules (236 with conclusion selected). Queue: 1896 rules.
11400 rules inserted. Base: 5792 rules (236 with conclusion selected). Queue: 1948 rules.
11600 rules inserted. Base: 5878 rules (236 with conclusion selected). Queue: 2006 rules.
11800 rules inserted. Base: 5966 rules (236 with conclusion selected). Queue: 2012 rules.
12000 rules inserted. Base: 6121 rules (236 with conclusion selected). Queue: 1948 rules.
12200 rules inserted. Base: 6215 rules (236 with conclusion selected). Queue: 2070 rules.
12400 rules inserted. Base: 6275 rules (236 with conclusion selected). Queue: 2099 rules.
12600 rules inserted. Base: 6347 rules (236 with conclusion selected). Queue: 2148 rules.
12800 rules inserted. Base: 5897 rules (240 with conclusion selected). Queue: 2093 rules.
13000 rules inserted. Base: 5950 rules (240 with conclusion selected). Queue: 2023 rules.
13200 rules inserted. Base: 6042 rules (240 with conclusion selected). Queue: 1897 rules.
13400 rules inserted. Base: 6191 rules (240 with conclusion selected). Queue: 1796 rules.
13600 rules inserted. Base: 6303 rules (240 with conclusion selected). Queue: 1774 rules.
13800 rules inserted. Base: 6323 rules (240 with conclusion selected). Queue: 1781 rules.
14000 rules inserted. Base: 6397 rules (240 with conclusion selected). Queue: 1721 rules.
14200 rules inserted. Base: 6452 rules (240 with conclusion selected). Queue: 1695 rules.
14400 rules inserted. Base: 6399 rules (240 with conclusion selected). Queue: 1594 rules.
14600 rules inserted. Base: 6418 rules (240 with conclusion selected). Queue: 1577 rules.
14800 rules inserted. Base: 6478 rules (240 with conclusion selected). Queue: 1464 rules.
15000 rules inserted. Base: 6530 rules (240 with conclusion selected). Queue: 1372 rules.
15200 rules inserted. Base: 6517 rules (240 with conclusion selected). Queue: 1186 rules.
15400 rules inserted. Base: 6566 rules (240 with conclusion selected). Queue: 1111 rules.
15600 rules inserted. Base: 6583 rules (240 with conclusion selected). Queue: 977 rules.
15800 rules inserted. Base: 6592 rules (240 with conclusion selected). Queue: 918 rules.
16000 rules inserted. Base: 6661 rules (240 with conclusion selected). Queue: 799 rules.
16200 rules inserted. Base: 6680 rules (240 with conclusion selected). Queue: 625 rules.
16400 rules inserted. Base: 6644 rules (240 with conclusion selected). Queue: 482 rules.
16600 rules inserted. Base: 6687 rules (240 with conclusion selected). Queue: 379 rules.
16800 rules inserted. Base: 6605 rules (240 with conclusion selected). Queue: 333 rules.
17000 rules inserted. Base: 6557 rules (241 with conclusion selected). Queue: 208 rules.
17200 rules inserted. Base: 6572 rules (242 with conclusion selected). Queue: 123 rules.
Starting query event(RecvMsg(bob,alice,stagepack_a(sid_b),m_10)) ==> event(SendMsg(alice,bob,stagepack_a(sid_a),m_10))
goal reachable: begin(SendMsg(alice,bob,stagepack_a(sid_5),msg_a(alice,bob,sid_5))) -> end(RecvMsg(bob,alice,stagepack_a(sid_6),msg_a(alice,bob,sid_5)))
Abbreviations:
sid_6 = sid[!1 = @sid]
sid_5 = sid[!1 = @sid_1]
RESULT event(RecvMsg(bob,alice,stagepack_a(sid_b),m_10)) ==> event(SendMsg(alice,bob,stagepack_a(sid_a),m_10)) is true.
Starting query event(RecvMsg(bob,alice,stagepack_a(sid_b),m_10)) ==> event(SendMsg(alice,c,stagepack_a(sid_a),m_10)) || (event(LeakS(phase0,alice)) && event(LeakM(phase0,alice))) || (event(LeakS(phase0,bob)) && event(LeakM(phase0,bob)))
goal reachable: begin(SendMsg(alice,bob,stagepack_a(sid_5),msg_a(alice,bob,sid_5))) -> end(RecvMsg(bob,alice,stagepack_a(sid_6),msg_a(alice,bob,sid_5)))
Abbreviations:
sid_6 = sid[!1 = @sid]
sid_5 = sid[!1 = @sid_1]
RESULT event(RecvMsg(bob,alice,stagepack_a(sid_b),m_10)) ==> event(SendMsg(alice,c,stagepack_a(sid_a),m_10)) || (event(LeakS(phase0,alice)) && event(LeakM(phase0,alice))) || (event(LeakS(phase0,bob)) && event(LeakM(phase0,bob))) is true.
Starting query event(RecvMsg(bob,alice,stagepack_a(sid_b),m_10)) ==> event(SendMsg(alice,c,stagepack_a(sid_a),m_10)) || (event(LeakS(phase0,alice)) && event(LeakM(phase0,alice)))
goal reachable: begin(SendMsg(alice,bob,stagepack_a(sid_5),msg_a(alice,bob,sid_5))) -> end(RecvMsg(bob,alice,stagepack_a(sid_6),msg_a(alice,bob,sid_5)))
Abbreviations:
sid_6 = sid[!1 = @sid]
sid_5 = sid[!1 = @sid_1]
RESULT event(RecvMsg(bob,alice,stagepack_a(sid_b),m_10)) ==> event(SendMsg(alice,c,stagepack_a(sid_a),m_10)) || (event(LeakS(phase0,alice)) && event(LeakM(phase0,alice))) is true.
Starting query event(RecvMsg(bob,alice,stagepack_a(sid_b),m_10)) ==> event(SendMsg(alice,bob,stagepack_a(sid_a),m_10)) || (event(LeakS(phase0,alice)) && event(LeakM(phase0,alice))) || (event(LeakS(phase0,bob)) && event(LeakM(phase0,bob)))
goal reachable: begin(SendMsg(alice,bob,stagepack_a(sid_5),msg_a(alice,bob,sid_5))) -> end(RecvMsg(bob,alice,stagepack_a(sid_6),msg_a(alice,bob,sid_5)))
Abbreviations:
sid_6 = sid[!1 = @sid]
sid_5 = sid[!1 = @sid_1]
RESULT event(RecvMsg(bob,alice,stagepack_a(sid_b),m_10)) ==> event(SendMsg(alice,bob,stagepack_a(sid_a),m_10)) || (event(LeakS(phase0,alice)) && event(LeakM(phase0,alice))) || (event(LeakS(phase0,bob)) && event(LeakM(phase0,bob))) is true.
Starting query event(RecvMsg(bob,alice,stagepack_a(sid_b),m_10)) ==> event(SendMsg(alice,bob,stagepack_a(sid_a),m_10)) || (event(LeakS(phase0,alice)) && event(LeakM(phase0,alice)))
goal reachable: begin(SendMsg(alice,bob,stagepack_a(sid_5),msg_a(alice,bob,sid_5))) -> end(RecvMsg(bob,alice,stagepack_a(sid_6),msg_a(alice,bob,sid_5)))
Abbreviations:
sid_6 = sid[!1 = @sid]
sid_5 = sid[!1 = @sid_1]
RESULT event(RecvMsg(bob,alice,stagepack_a(sid_b),m_10)) ==> event(SendMsg(alice,bob,stagepack_a(sid_a),m_10)) || (event(LeakS(phase0,alice)) && event(LeakM(phase0,alice))) is true.
Starting query not attacker_p1(msg_a(alice,bob,sid_a))
goal reachable: begin(LeakM(phase1,bob)) && begin(LeakS(phase1,bob)) && begin(SendMsg(alice,bob,stagepack_a(sid_5),msg_a(alice,bob,sid_5))) -> attacker_p1(msg_a(alice,bob,sid_5))
Abbreviations:
sid_5 = sid[!1 = @sid]

Derivation:
Abbreviations:
sid_5 = sid[!1 = @sid]

1. Using the function pub the attacker may obtain pub.
attacker(pub).

2. The entry statestore(alice,bob,sid_5,statepack_a(handshakestatepack(symmetricstatepack(cipherstatepack(empty,minnonce),hash(somename,empty),hash(hash(hash(hash(somename,empty),empty),validkey(dhexp_real(key_s(bob),g))),validkey(dhexp_real(key_m(bob),g)))),keypairpack(empty,empty),keypairpack(empty,empty),keypairpack(empty,empty),validkey(dhexp_real(key_s(bob),g)),validkey(dhexp_real(key_m(bob),g)),empty,empty,true))) may be inserted in a table at insert {50}.
table(statestore(alice,bob,sid_5,statepack_a(handshakestatepack(symmetricstatepack(cipherstatepack(empty,minnonce),hash(somename,empty),hash(hash(hash(hash(somename,empty),empty),validkey(dhexp_real(key_s(bob),g))),validkey(dhexp_real(key_m(bob),g)))),keypairpack(empty,empty),keypairpack(empty,empty),keypairpack(empty,empty),validkey(dhexp_real(key_s(bob),g)),validkey(dhexp_real(key_m(bob),g)),empty,empty,true)))).

3. The entry statestore(alice,bob,sid_5,statepack_a(handshakestatepack(symmetricstatepack(cipherstatepack(empty,minnonce),hash(somename,empty),hash(hash(hash(hash(somename,empty),empty),validkey(dhexp_real(key_s(bob),g))),validkey(dhexp_real(key_m(bob),g)))),keypairpack(empty,empty),keypairpack(empty,empty),keypairpack(empty,empty),validkey(dhexp_real(key_s(bob),g)),validkey(dhexp_real(key_m(bob),g)),empty,empty,true))) that may be in a table by 2 may be read at get {306}.
The event SendMsg(alice,bob,stagepack_a(sid_5),msg_a(alice,bob,sid_5)) may be executed at {304}.
So the message concat4(validkey(dhexp_real(key_e(alice,bob,sid_5),g)),encrypt(hmac_hash2(hmac_hash1(hash(somename,empty),dhexp_real(key_e(alice,bob,sid_5),dhexp_real(key_s(bob),g))),dhexp_real(key_e(alice,bob,sid_5),dhexp_real(key_m(bob),g))),minnonce,hash(hash(hash(hash(hash(somename,empty),empty),validkey(dhexp_real(key_s(bob),g))),validkey(dhexp_real(key_m(bob),g))),validkey(dhexp_real(key_e(alice,bob,sid_5),g))),validkey(dhexp_real(key_s(alice),g))),encrypt(hmac_hash2(hmac_hash1(hash(somename,empty),dhexp_real(key_e(alice,bob,sid_5),dhexp_real(key_s(bob),g))),dhexp_real(key_e(alice,bob,sid_5),dhexp_real(key_m(bob),g))),increment_nonce(minnonce),hash(hash(hash(hash(hash(hash(somename,empty),empty),validkey(dhexp_real(key_s(bob),g))),validkey(dhexp_real(key_m(bob),g))),validkey(dhexp_real(key_e(alice,bob,sid_5),g))),encrypt(hmac_hash2(hmac_hash1(hash(somename,empty),dhexp_real(key_e(alice,bob,sid_5),dhexp_real(key_s(bob),g))),dhexp_real(key_e(alice,bob,sid_5),dhexp_real(key_m(bob),g))),minnonce,hash(hash(hash(hash(hash(somename,empty),empty),validkey(dhexp_real(key_s(bob),g))),validkey(dhexp_real(key_m(bob),g))),validkey(dhexp_real(key_e(alice,bob,sid_5),g))),validkey(dhexp_real(key_s(alice),g)))),validkey(dhexp_real(key_m(alice),g))),encrypt(hmac_hash2(hmac_hash1(hmac_hash1(hmac_hash1(hash(somename,empty),dhexp_real(key_e(alice,bob,sid_5),dhexp_real(key_s(bob),g))),dhexp_real(key_e(alice,bob,sid_5),dhexp_real(key_m(bob),g))),dhexp_real(key_m(alice),dhexp_real(key_s(bob),g))),dhexp_real(key_m(bob),dhexp_real(key_s(alice),g))),minnonce,hash(hash(hash(hash(hash(hash(hash(somename,empty),empty),validkey(dhexp_real(key_s(bob),g))),validkey(dhexp_real(key_m(bob),g))),validkey(dhexp_real(key_e(alice,bob,sid_5),g))),encrypt(hmac_hash2(hmac_hash1(hash(somename,empty),dhexp_real(key_e(alice,bob,sid_5),dhexp_real(key_s(bob),g))),dhexp_real(key_e(alice,bob,sid_5),dhexp_real(key_m(bob),g))),minnonce,hash(hash(hash(hash(hash(somename,empty),empty),validkey(dhexp_real(key_s(bob),g))),validkey(dhexp_real(key_m(bob),g))),validkey(dhexp_real(key_e(alice,bob,sid_5),g))),validkey(dhexp_real(key_s(alice),g)))),encrypt(hmac_hash2(hmac_hash1(hash(somename,empty),dhexp_real(key_e(alice,bob,sid_5),dhexp_real(key_s(bob),g))),dhexp_real(key_e(alice,bob,sid_5),dhexp_real(key_m(bob),g))),increment_nonce(minnonce),hash(hash(hash(hash(hash(hash(somename,empty),empty),validkey(dhexp_real(key_s(bob),g))),validkey(dhexp_real(key_m(bob),g))),validkey(dhexp_real(key_e(alice,bob,sid_5),g))),encrypt(hmac_hash2(hmac_hash1(hash(somename,empty),dhexp_real(key_e(alice,bob,sid_5),dhexp_real(key_s(bob),g))),dhexp_real(key_e(alice,bob,sid_5),dhexp_real(key_m(bob),g))),minnonce,hash(hash(hash(hash(hash(somename,empty),empty),validkey(dhexp_real(key_s(bob),g))),validkey(dhexp_real(key_m(bob),g))),validkey(dhexp_real(key_e(alice,bob,sid_5),g))),validkey(dhexp_real(key_s(alice),g)))),validkey(dhexp_real(key_m(alice),g)))),msg_a(alice,bob,sid_5))) may be sent on channel pub at output {305}.
mess(pub,concat4(validkey(dhexp_real(key_e(alice,bob,sid_5),g)),encrypt(hmac_hash2(hmac_hash1(hash(somename,empty),dhexp_real(key_e(alice,bob,sid_5),dhexp_real(key_s(bob),g))),dhexp_real(key_e(alice,bob,sid_5),dhexp_real(key_m(bob),g))),minnonce,hash(hash(hash(hash(hash(somename,empty),empty),validkey(dhexp_real(key_s(bob),g))),validkey(dhexp_real(key_m(bob),g))),validkey(dhexp_real(key_e(alice,bob,sid_5),g))),validkey(dhexp_real(key_s(alice),g))),encrypt(hmac_hash2(hmac_hash1(hash(somename,empty),dhexp_real(key_e(alice,bob,sid_5),dhexp_real(key_s(bob),g))),dhexp_real(key_e(alice,bob,sid_5),dhexp_real(key_m(bob),g))),increment_nonce(minnonce),hash(hash(hash(hash(hash(hash(somename,empty),empty),validkey(dhexp_real(key_s(bob),g))),validkey(dhexp_real(key_m(bob),g))),validkey(dhexp_real(key_e(alice,bob,sid_5),g))),encrypt(hmac_hash2(hmac_hash1(hash(somename,empty),dhexp_real(key_e(alice,bob,sid_5),dhexp_real(key_s(bob),g))),dhexp_real(key_e(alice,bob,sid_5),dhexp_real(key_m(bob),g))),minnonce,hash(hash(hash(hash(hash(somename,empty),empty),validkey(dhexp_real(key_s(bob),g))),validkey(dhexp_real(key_m(bob),g))),validkey(dhexp_real(key_e(alice,bob,sid_5),g))),validkey(dhexp_real(key_s(alice),g)))),validkey(dhexp_real(key_m(alice),g))),encrypt(hmac_hash2(hmac_hash1(hmac_hash1(hmac_hash1(hash(somename,empty),dhexp_real(key_e(alice,bob,sid_5),dhexp_real(key_s(bob),g))),dhexp_real(key_e(alice,bob,sid_5),dhexp_real(key_m(bob),g))),dhexp_real(key_m(alice),dhexp_real(key_s(bob),g))),dhexp_real(key_m(bob),dhexp_real(key_s(alice),g))),minnonce,hash(hash(hash(hash(hash(hash(hash(somename,empty),empty),validkey(dhexp_real(key_s(bob),g))),validkey(dhexp_real(key_m(bob),g))),validkey(dhexp_real(key_e(alice,bob,sid_5),g))),encrypt(hmac_hash2(hmac_hash1(hash(somename,empty),dhexp_real(key_e(alice,bob,sid_5),dhexp_real(key_s(bob),g))),dhexp_real(key_e(alice,bob,sid_5),dhexp_real(key_m(bob),g))),minnonce,hash(hash(hash(hash(hash(somename,empty),empty),validkey(dhexp_real(key_s(bob),g))),validkey(dhexp_real(key_m(bob),g))),validkey(dhexp_real(key_e(alice,bob,sid_5),g))),validkey(dhexp_real(key_s(alice),g)))),encrypt(hmac_hash2(hmac_hash1(hash(somename,empty),dhexp_real(key_e(alice,bob,sid_5),dhexp_real(key_s(bob),g))),dhexp_real(key_e(alice,bob,sid_5),dhexp_real(key_m(bob),g))),increment_nonce(minnonce),hash(hash(hash(hash(hash(hash(somename,empty),empty),validkey(dhexp_real(key_s(bob),g))),validkey(dhexp_real(key_m(bob),g))),validkey(dhexp_real(key_e(alice,bob,sid_5),g))),encrypt(hmac_hash2(hmac_hash1(hash(somename,empty),dhexp_real(key_e(alice,bob,sid_5),dhexp_real(key_s(bob),g))),dhexp_real(key_e(alice,bob,sid_5),dhexp_real(key_m(bob),g))),minnonce,hash(hash(hash(hash(hash(somename,empty),empty),validkey(dhexp_real(key_s(bob),g))),validkey(dhexp_real(key_m(bob),g))),validkey(dhexp_real(key_e(alice,bob,sid_5),g))),validkey(dhexp_real(key_s(alice),g)))),validkey(dhexp_real(key_m(alice),g)))),msg_a(alice,bob,sid_5)))).

4. By 1, the attacker may have the channel pub.
By 3, the message concat4(validkey(dhexp_real(key_e(alice,bob,sid_5),g)),encrypt(hmac_hash2(hmac_hash1(hash(somename,empty),dhexp_real(key_e(alice,bob,sid_5),dhexp_real(key_s(bob),g))),dhexp_real(key_e(alice,bob,sid_5),dhexp_real(key_m(bob),g))),minnonce,hash(hash(hash(hash(hash(somename,empty),empty),validkey(dhexp_real(key_s(bob),g))),validkey(dhexp_real(key_m(bob),g))),validkey(dhexp_real(key_e(alice,bob,sid_5),g))),validkey(dhexp_real(key_s(alice),g))),encrypt(hmac_hash2(hmac_hash1(hash(somename,empty),dhexp_real(key_e(alice,bob,sid_5),dhexp_real(key_s(bob),g))),dhexp_real(key_e(alice,bob,sid_5),dhexp_real(key_m(bob),g))),increment_nonce(minnonce),hash(hash(hash(hash(hash(hash(somename,empty),empty),validkey(dhexp_real(key_s(bob),g))),validkey(dhexp_real(key_m(bob),g))),validkey(dhexp_real(key_e(alice,bob,sid_5),g))),encrypt(hmac_hash2(hmac_hash1(hash(somename,empty),dhexp_real(key_e(alice,bob,sid_5),dhexp_real(key_s(bob),g))),dhexp_real(key_e(alice,bob,sid_5),dhexp_real(key_m(bob),g))),minnonce,hash(hash(hash(hash(hash(somename,empty),empty),validkey(dhexp_real(key_s(bob),g))),validkey(dhexp_real(key_m(bob),g))),validkey(dhexp_real(key_e(alice,bob,sid_5),g))),validkey(dhexp_real(key_s(alice),g)))),validkey(dhexp_real(key_m(alice),g))),encrypt(hmac_hash2(hmac_hash1(hmac_hash1(hmac_hash1(hash(somename,empty),dhexp_real(key_e(alice,bob,sid_5),dhexp_real(key_s(bob),g))),dhexp_real(key_e(alice,bob,sid_5),dhexp_real(key_m(bob),g))),dhexp_real(key_m(alice),dhexp_real(key_s(bob),g))),dhexp_real(key_m(bob),dhexp_real(key_s(alice),g))),minnonce,hash(hash(hash(hash(hash(hash(hash(somename,empty),empty),validkey(dhexp_real(key_s(bob),g))),validkey(dhexp_real(key_m(bob),g))),validkey(dhexp_real(key_e(alice,bob,sid_5),g))),encrypt(hmac_hash2(hmac_hash1(hash(somename,empty),dhexp_real(key_e(alice,bob,sid_5),dhexp_real(key_s(bob),g))),dhexp_real(key_e(alice,bob,sid_5),dhexp_real(key_m(bob),g))),minnonce,hash(hash(hash(hash(hash(somename,empty),empty),validkey(dhexp_real(key_s(bob),g))),validkey(dhexp_real(key_m(bob),g))),validkey(dhexp_real(key_e(alice,bob,sid_5),g))),validkey(dhexp_real(key_s(alice),g)))),encrypt(hmac_hash2(hmac_hash1(hash(somename,empty),dhexp_real(key_e(alice,bob,sid_5),dhexp_real(key_s(bob),g))),dhexp_real(key_e(alice,bob,sid_5),dhexp_real(key_m(bob),g))),increment_nonce(minnonce),hash(hash(hash(hash(hash(hash(somename,empty),empty),validkey(dhexp_real(key_s(bob),g))),validkey(dhexp_real(key_m(bob),g))),validkey(dhexp_real(key_e(alice,bob,sid_5),g))),encrypt(hmac_hash2(hmac_hash1(hash(somename,empty),dhexp_real(key_e(alice,bob,sid_5),dhexp_real(key_s(bob),g))),dhexp_real(key_e(alice,bob,sid_5),dhexp_real(key_m(bob),g))),minnonce,hash(hash(hash(hash(hash(somename,empty),empty),validkey(dhexp_real(key_s(bob),g))),validkey(dhexp_real(key_m(bob),g))),validkey(dhexp_real(key_e(alice,bob,sid_5),g))),validkey(dhexp_real(key_s(alice),g)))),validkey(dhexp_real(key_m(alice),g)))),msg_a(alice,bob,sid_5))) may be sent on this channel.
So the attacker may obtain the message concat4(validkey(dhexp_real(key_e(alice,bob,sid_5),g)),encrypt(hmac_hash2(hmac_hash1(hash(somename,empty),dhexp_real(key_e(alice,bob,sid_5),dhexp_real(key_s(bob),g))),dhexp_real(key_e(alice,bob,sid_5),dhexp_real(key_m(bob),g))),minnonce,hash(hash(hash(hash(hash(somename,empty),empty),validkey(dhexp_real(key_s(bob),g))),validkey(dhexp_real(key_m(bob),g))),validkey(dhexp_real(key_e(alice,bob,sid_5),g))),validkey(dhexp_real(key_s(alice),g))),encrypt(hmac_hash2(hmac_hash1(hash(somename,empty),dhexp_real(key_e(alice,bob,sid_5),dhexp_real(key_s(bob),g))),dhexp_real(key_e(alice,bob,sid_5),dhexp_real(key_m(bob),g))),increment_nonce(minnonce),hash(hash(hash(hash(hash(hash(somename,empty),empty),validkey(dhexp_real(key_s(bob),g))),validkey(dhexp_real(key_m(bob),g))),validkey(dhexp_real(key_e(alice,bob,sid_5),g))),encrypt(hmac_hash2(hmac_hash1(hash(somename,empty),dhexp_real(key_e(alice,bob,sid_5),dhexp_real(key_s(bob),g))),dhexp_real(key_e(alice,bob,sid_5),dhexp_real(key_m(bob),g))),minnonce,hash(hash(hash(hash(hash(somename,empty),empty),validkey(dhexp_real(key_s(bob),g))),validkey(dhexp_real(key_m(bob),g))),validkey(dhexp_real(key_e(alice,bob,sid_5),g))),validkey(dhexp_real(key_s(alice),g)))),validkey(dhexp_real(key_m(alice),g))),encrypt(hmac_hash2(hmac_hash1(hmac_hash1(hmac_hash1(hash(somename,empty),dhexp_real(key_e(alice,bob,sid_5),dhexp_real(key_s(bob),g))),dhexp_real(key_e(alice,bob,sid_5),dhexp_real(key_m(bob),g))),dhexp_real(key_m(alice),dhexp_real(key_s(bob),g))),dhexp_real(key_m(bob),dhexp_real(key_s(alice),g))),minnonce,hash(hash(hash(hash(hash(hash(hash(somename,empty),empty),validkey(dhexp_real(key_s(bob),g))),validkey(dhexp_real(key_m(bob),g))),validkey(dhexp_real(key_e(alice,bob,sid_5),g))),encrypt(hmac_hash2(hmac_hash1(hash(somename,empty),dhexp_real(key_e(alice,bob,sid_5),dhexp_real(key_s(bob),g))),dhexp_real(key_e(alice,bob,sid_5),dhexp_real(key_m(bob),g))),minnonce,hash(hash(hash(hash(hash(somename,empty),empty),validkey(dhexp_real(key_s(bob),g))),validkey(dhexp_real(key_m(bob),g))),validkey(dhexp_real(key_e(alice,bob,sid_5),g))),validkey(dhexp_real(key_s(alice),g)))),encrypt(hmac_hash2(hmac_hash1(hash(somename,empty),dhexp_real(key_e(alice,bob,sid_5),dhexp_real(key_s(bob),g))),dhexp_real(key_e(alice,bob,sid_5),dhexp_real(key_m(bob),g))),increment_nonce(minnonce),hash(hash(hash(hash(hash(hash(somename,empty),empty),validkey(dhexp_real(key_s(bob),g))),validkey(dhexp_real(key_m(bob),g))),validkey(dhexp_real(key_e(alice,bob,sid_5),g))),encrypt(hmac_hash2(hmac_hash1(hash(somename,empty),dhexp_real(key_e(alice,bob,sid_5),dhexp_real(key_s(bob),g))),dhexp_real(key_e(alice,bob,sid_5),dhexp_real(key_m(bob),g))),minnonce,hash(hash(hash(hash(hash(somename,empty),empty),validkey(dhexp_real(key_s(bob),g))),validkey(dhexp_real(key_m(bob),g))),validkey(dhexp_real(key_e(alice,bob,sid_5),g))),validkey(dhexp_real(key_s(alice),g)))),validkey(dhexp_real(key_m(alice),g)))),msg_a(alice,bob,sid_5))) by listening on this channel.
attacker(concat4(validkey(dhexp_real(key_e(alice,bob,sid_5),g)),encrypt(hmac_hash2(hmac_hash1(hash(somename,empty),dhexp_real(key_e(alice,bob,sid_5),dhexp_real(key_s(bob),g))),dhexp_real(key_e(alice,bob,sid_5),dhexp_real(key_m(bob),g))),minnonce,hash(hash(hash(hash(hash(somename,empty),empty),validkey(dhexp_real(key_s(bob),g))),validkey(dhexp_real(key_m(bob),g))),validkey(dhexp_real(key_e(alice,bob,sid_5),g))),validkey(dhexp_real(key_s(alice),g))),encrypt(hmac_hash2(hmac_hash1(hash(somename,empty),dhexp_real(key_e(alice,bob,sid_5),dhexp_real(key_s(bob),g))),dhexp_real(key_e(alice,bob,sid_5),dhexp_real(key_m(bob),g))),increment_nonce(minnonce),hash(hash(hash(hash(hash(hash(somename,empty),empty),validkey(dhexp_real(key_s(bob),g))),validkey(dhexp_real(key_m(bob),g))),validkey(dhexp_real(key_e(alice,bob,sid_5),g))),encrypt(hmac_hash2(hmac_hash1(hash(somename,empty),dhexp_real(key_e(alice,bob,sid_5),dhexp_real(key_s(bob),g))),dhexp_real(key_e(alice,bob,sid_5),dhexp_real(key_m(bob),g))),minnonce,hash(hash(hash(hash(hash(somename,empty),empty),validkey(dhexp_real(key_s(bob),g))),validkey(dhexp_real(key_m(bob),g))),validkey(dhexp_real(key_e(alice,bob,sid_5),g))),validkey(dhexp_real(key_s(alice),g)))),validkey(dhexp_real(key_m(alice),g))),encrypt(hmac_hash2(hmac_hash1(hmac_hash1(hmac_hash1(hash(somename,empty),dhexp_real(key_e(alice,bob,sid_5),dhexp_real(key_s(bob),g))),dhexp_real(key_e(alice,bob,sid_5),dhexp_real(key_m(bob),g))),dhexp_real(key_m(alice),dhexp_real(key_s(bob),g))),dhexp_real(key_m(bob),dhexp_real(key_s(alice),g))),minnonce,hash(hash(hash(hash(hash(hash(hash(somename,empty),empty),validkey(dhexp_real(key_s(bob),g))),validkey(dhexp_real(key_m(bob),g))),validkey(dhexp_real(key_e(alice,bob,sid_5),g))),encrypt(hmac_hash2(hmac_hash1(hash(somename,empty),dhexp_real(key_e(alice,bob,sid_5),dhexp_real(key_s(bob),g))),dhexp_real(key_e(alice,bob,sid_5),dhexp_real(key_m(bob),g))),minnonce,hash(hash(hash(hash(hash(somename,empty),empty),validkey(dhexp_real(key_s(bob),g))),validkey(dhexp_real(key_m(bob),g))),validkey(dhexp_real(key_e(alice,bob,sid_5),g))),validkey(dhexp_real(key_s(alice),g)))),encrypt(hmac_hash2(hmac_hash1(hash(somename,empty),dhexp_real(key_e(alice,bob,sid_5),dhexp_real(key_s(bob),g))),dhexp_real(key_e(alice,bob,sid_5),dhexp_real(key_m(bob),g))),increment_nonce(minnonce),hash(hash(hash(hash(hash(hash(somename,empty),empty),validkey(dhexp_real(key_s(bob),g))),validkey(dhexp_real(key_m(bob),g))),validkey(dhexp_real(key_e(alice,bob,sid_5),g))),encrypt(hmac_hash2(hmac_hash1(hash(somename,empty),dhexp_real(key_e(alice,bob,sid_5),dhexp_real(key_s(bob),g))),dhexp_real(key_e(alice,bob,sid_5),dhexp_real(key_m(bob),g))),minnonce,hash(hash(hash(hash(hash(somename,empty),empty),validkey(dhexp_real(key_s(bob),g))),validkey(dhexp_real(key_m(bob),g))),validkey(dhexp_real(key_e(alice,bob,sid_5),g))),validkey(dhexp_real(key_s(alice),g)))),validkey(dhexp_real(key_m(alice),g)))),msg_a(alice,bob,sid_5)))).

5. By 4, the attacker may know concat4(validkey(dhexp_real(key_e(alice,bob,sid_5),g)),encrypt(hmac_hash2(hmac_hash1(hash(somename,empty),dhexp_real(key_e(alice,bob,sid_5),dhexp_real(key_s(bob),g))),dhexp_real(key_e(alice,bob,sid_5),dhexp_real(key_m(bob),g))),minnonce,hash(hash(hash(hash(hash(somename,empty),empty),validkey(dhexp_real(key_s(bob),g))),validkey(dhexp_real(key_m(bob),g))),validkey(dhexp_real(key_e(alice,bob,sid_5),g))),validkey(dhexp_real(key_s(alice),g))),encrypt(hmac_hash2(hmac_hash1(hash(somename,empty),dhexp_real(key_e(alice,bob,sid_5),dhexp_real(key_s(bob),g))),dhexp_real(key_e(alice,bob,sid_5),dhexp_real(key_m(bob),g))),increment_nonce(minnonce),hash(hash(hash(hash(hash(hash(somename,empty),empty),validkey(dhexp_real(key_s(bob),g))),validkey(dhexp_real(key_m(bob),g))),validkey(dhexp_real(key_e(alice,bob,sid_5),g))),encrypt(hmac_hash2(hmac_hash1(hash(somename,empty),dhexp_real(key_e(alice,bob,sid_5),dhexp_real(key_s(bob),g))),dhexp_real(key_e(alice,bob,sid_5),dhexp_real(key_m(bob),g))),minnonce,hash(hash(hash(hash(hash(somename,empty),empty),validkey(dhexp_real(key_s(bob),g))),validkey(dhexp_real(key_m(bob),g))),validkey(dhexp_real(key_e(alice,bob,sid_5),g))),validkey(dhexp_real(key_s(alice),g)))),validkey(dhexp_real(key_m(alice),g))),encrypt(hmac_hash2(hmac_hash1(hmac_hash1(hmac_hash1(hash(somename,empty),dhexp_real(key_e(alice,bob,sid_5),dhexp_real(key_s(bob),g))),dhexp_real(key_e(alice,bob,sid_5),dhexp_real(key_m(bob),g))),dhexp_real(key_m(alice),dhexp_real(key_s(bob),g))),dhexp_real(key_m(bob),dhexp_real(key_s(alice),g))),minnonce,hash(hash(hash(hash(hash(hash(hash(somename,empty),empty),validkey(dhexp_real(key_s(bob),g))),validkey(dhexp_real(key_m(bob),g))),validkey(dhexp_real(key_e(alice,bob,sid_5),g))),encrypt(hmac_hash2(hmac_hash1(hash(somename,empty),dhexp_real(key_e(alice,bob,sid_5),dhexp_real(key_s(bob),g))),dhexp_real(key_e(alice,bob,sid_5),dhexp_real(key_m(bob),g))),minnonce,hash(hash(hash(hash(hash(somename,empty),empty),validkey(dhexp_real(key_s(bob),g))),validkey(dhexp_real(key_m(bob),g))),validkey(dhexp_real(key_e(alice,bob,sid_5),g))),validkey(dhexp_real(key_s(alice),g)))),encrypt(hmac_hash2(hmac_hash1(hash(somename,empty),dhexp_real(key_e(alice,bob,sid_5),dhexp_real(key_s(bob),g))),dhexp_real(key_e(alice,bob,sid_5),dhexp_real(key_m(bob),g))),increment_nonce(minnonce),hash(hash(hash(hash(hash(hash(somename,empty),empty),validkey(dhexp_real(key_s(bob),g))),validkey(dhexp_real(key_m(bob),g))),validkey(dhexp_real(key_e(alice,bob,sid_5),g))),encrypt(hmac_hash2(hmac_hash1(hash(somename,empty),dhexp_real(key_e(alice,bob,sid_5),dhexp_real(key_s(bob),g))),dhexp_real(key_e(alice,bob,sid_5),dhexp_real(key_m(bob),g))),minnonce,hash(hash(hash(hash(hash(somename,empty),empty),validkey(dhexp_real(key_s(bob),g))),validkey(dhexp_real(key_m(bob),g))),validkey(dhexp_real(key_e(alice,bob,sid_5),g))),validkey(dhexp_real(key_s(alice),g)))),validkey(dhexp_real(key_m(alice),g)))),msg_a(alice,bob,sid_5))).
Using the function 4-proj-concat4 the attacker may obtain encrypt(hmac_hash2(hmac_hash1(hmac_hash1(hmac_hash1(hash(somename,empty),dhexp_real(key_e(alice,bob,sid_5),dhexp_real(key_s(bob),g))),dhexp_real(key_e(alice,bob,sid_5),dhexp_real(key_m(bob),g))),dhexp_real(key_m(alice),dhexp_real(key_s(bob),g))),dhexp_real(key_m(bob),dhexp_real(key_s(alice),g))),minnonce,hash(hash(hash(hash(hash(hash(hash(somename,empty),empty),validkey(dhexp_real(key_s(bob),g))),validkey(dhexp_real(key_m(bob),g))),validkey(dhexp_real(key_e(alice,bob,sid_5),g))),encrypt(hmac_hash2(hmac_hash1(hash(somename,empty),dhexp_real(key_e(alice,bob,sid_5),dhexp_real(key_s(bob),g))),dhexp_real(key_e(alice,bob,sid_5),dhexp_real(key_m(bob),g))),minnonce,hash(hash(hash(hash(hash(somename,empty),empty),validkey(dhexp_real(key_s(bob),g))),validkey(dhexp_real(key_m(bob),g))),validkey(dhexp_real(key_e(alice,bob,sid_5),g))),validkey(dhexp_real(key_s(alice),g)))),encrypt(hmac_hash2(hmac_hash1(hash(somename,empty),dhexp_real(key_e(alice,bob,sid_5),dhexp_real(key_s(bob),g))),dhexp_real(key_e(alice,bob,sid_5),dhexp_real(key_m(bob),g))),increment_nonce(minnonce),hash(hash(hash(hash(hash(hash(somename,empty),empty),validkey(dhexp_real(key_s(bob),g))),validkey(dhexp_real(key_m(bob),g))),validkey(dhexp_real(key_e(alice,bob,sid_5),g))),encrypt(hmac_hash2(hmac_hash1(hash(somename,empty),dhexp_real(key_e(alice,bob,sid_5),dhexp_real(key_s(bob),g))),dhexp_real(key_e(alice,bob,sid_5),dhexp_real(key_m(bob),g))),minnonce,hash(hash(hash(hash(hash(somename,empty),empty),validkey(dhexp_real(key_s(bob),g))),validkey(dhexp_real(key_m(bob),g))),validkey(dhexp_real(key_e(alice,bob,sid_5),g))),validkey(dhexp_real(key_s(alice),g)))),validkey(dhexp_real(key_m(alice),g)))),msg_a(alice,bob,sid_5)).
attacker(encrypt(hmac_hash2(hmac_hash1(hmac_hash1(hmac_hash1(hash(somename,empty),dhexp_real(key_e(alice,bob,sid_5),dhexp_real(key_s(bob),g))),dhexp_real(key_e(alice,bob,sid_5),dhexp_real(key_m(bob),g))),dhexp_real(key_m(alice),dhexp_real(key_s(bob),g))),dhexp_real(key_m(bob),dhexp_real(key_s(alice),g))),minnonce,hash(hash(hash(hash(hash(hash(hash(somename,empty),empty),validkey(dhexp_real(key_s(bob),g))),validkey(dhexp_real(key_m(bob),g))),validkey(dhexp_real(key_e(alice,bob,sid_5),g))),encrypt(hmac_hash2(hmac_hash1(hash(somename,empty),dhexp_real(key_e(alice,bob,sid_5),dhexp_real(key_s(bob),g))),dhexp_real(key_e(alice,bob,sid_5),dhexp_real(key_m(bob),g))),minnonce,hash(hash(hash(hash(hash(somename,empty),empty),validkey(dhexp_real(key_s(bob),g))),validkey(dhexp_real(key_m(bob),g))),validkey(dhexp_real(key_e(alice,bob,sid_5),g))),validkey(dhexp_real(key_s(alice),g)))),encrypt(hmac_hash2(hmac_hash1(hash(somename,empty),dhexp_real(key_e(alice,bob,sid_5),dhexp_real(key_s(bob),g))),dhexp_real(key_e(alice,bob,sid_5),dhexp_real(key_m(bob),g))),increment_nonce(minnonce),hash(hash(hash(hash(hash(hash(somename,empty),empty),validkey(dhexp_real(key_s(bob),g))),validkey(dhexp_real(key_m(bob),g))),validkey(dhexp_real(key_e(alice,bob,sid_5),g))),encrypt(hmac_hash2(hmac_hash1(hash(somename,empty),dhexp_real(key_e(alice,bob,sid_5),dhexp_real(key_s(bob),g))),dhexp_real(key_e(alice,bob,sid_5),dhexp_real(key_m(bob),g))),minnonce,hash(hash(hash(hash(hash(somename,empty),empty),validkey(dhexp_real(key_s(bob),g))),validkey(dhexp_real(key_m(bob),g))),validkey(dhexp_real(key_e(alice,bob,sid_5),g))),validkey(dhexp_real(key_s(alice),g)))),validkey(dhexp_real(key_m(alice),g)))),msg_a(alice,bob,sid_5))).

6. By 5, the attacker may know encrypt(hmac_hash2(hmac_hash1(hmac_hash1(hmac_hash1(hash(somename,empty),dhexp_real(key_e(alice,bob,sid_5),dhexp_real(key_s(bob),g))),dhexp_real(key_e(alice,bob,sid_5),dhexp_real(key_m(bob),g))),dhexp_real(key_m(alice),dhexp_real(key_s(bob),g))),dhexp_real(key_m(bob),dhexp_real(key_s(alice),g))),minnonce,hash(hash(hash(hash(hash(hash(hash(somename,empty),empty),validkey(dhexp_real(key_s(bob),g))),validkey(dhexp_real(key_m(bob),g))),validkey(dhexp_real(key_e(alice,bob,sid_5),g))),encrypt(hmac_hash2(hmac_hash1(hash(somename,empty),dhexp_real(key_e(alice,bob,sid_5),dhexp_real(key_s(bob),g))),dhexp_real(key_e(alice,bob,sid_5),dhexp_real(key_m(bob),g))),minnonce,hash(hash(hash(hash(hash(somename,empty),empty),validkey(dhexp_real(key_s(bob),g))),validkey(dhexp_real(key_m(bob),g))),validkey(dhexp_real(key_e(alice,bob,sid_5),g))),validkey(dhexp_real(key_s(alice),g)))),encrypt(hmac_hash2(hmac_hash1(hash(somename,empty),dhexp_real(key_e(alice,bob,sid_5),dhexp_real(key_s(bob),g))),dhexp_real(key_e(alice,bob,sid_5),dhexp_real(key_m(bob),g))),increment_nonce(minnonce),hash(hash(hash(hash(hash(hash(somename,empty),empty),validkey(dhexp_real(key_s(bob),g))),validkey(dhexp_real(key_m(bob),g))),validkey(dhexp_real(key_e(alice,bob,sid_5),g))),encrypt(hmac_hash2(hmac_hash1(hash(somename,empty),dhexp_real(key_e(alice,bob,sid_5),dhexp_real(key_s(bob),g))),dhexp_real(key_e(alice,bob,sid_5),dhexp_real(key_m(bob),g))),minnonce,hash(hash(hash(hash(hash(somename,empty),empty),validkey(dhexp_real(key_s(bob),g))),validkey(dhexp_real(key_m(bob),g))),validkey(dhexp_real(key_e(alice,bob,sid_5),g))),validkey(dhexp_real(key_s(alice),g)))),validkey(dhexp_real(key_m(alice),g)))),msg_a(alice,bob,sid_5)).
So the attacker may know encrypt(hmac_hash2(hmac_hash1(hmac_hash1(hmac_hash1(hash(somename,empty),dhexp_real(key_e(alice,bob,sid_5),dhexp_real(key_s(bob),g))),dhexp_real(key_e(alice,bob,sid_5),dhexp_real(key_m(bob),g))),dhexp_real(key_m(alice),dhexp_real(key_s(bob),g))),dhexp_real(key_m(bob),dhexp_real(key_s(alice),g))),minnonce,hash(hash(hash(hash(hash(hash(hash(somename,empty),empty),validkey(dhexp_real(key_s(bob),g))),validkey(dhexp_real(key_m(bob),g))),validkey(dhexp_real(key_e(alice,bob,sid_5),g))),encrypt(hmac_hash2(hmac_hash1(hash(somename,empty),dhexp_real(key_e(alice,bob,sid_5),dhexp_real(key_s(bob),g))),dhexp_real(key_e(alice,bob,sid_5),dhexp_real(key_m(bob),g))),minnonce,hash(hash(hash(hash(hash(somename,empty),empty),validkey(dhexp_real(key_s(bob),g))),validkey(dhexp_real(key_m(bob),g))),validkey(dhexp_real(key_e(alice,bob,sid_5),g))),validkey(dhexp_real(key_s(alice),g)))),encrypt(hmac_hash2(hmac_hash1(hash(somename,empty),dhexp_real(key_e(alice,bob,sid_5),dhexp_real(key_s(bob),g))),dhexp_real(key_e(alice,bob,sid_5),dhexp_real(key_m(bob),g))),increment_nonce(minnonce),hash(hash(hash(hash(hash(hash(somename,empty),empty),validkey(dhexp_real(key_s(bob),g))),validkey(dhexp_real(key_m(bob),g))),validkey(dhexp_real(key_e(alice,bob,sid_5),g))),encrypt(hmac_hash2(hmac_hash1(hash(somename,empty),dhexp_real(key_e(alice,bob,sid_5),dhexp_real(key_s(bob),g))),dhexp_real(key_e(alice,bob,sid_5),dhexp_real(key_m(bob),g))),minnonce,hash(hash(hash(hash(hash(somename,empty),empty),validkey(dhexp_real(key_s(bob),g))),validkey(dhexp_real(key_m(bob),g))),validkey(dhexp_real(key_e(alice,bob,sid_5),g))),validkey(dhexp_real(key_s(alice),g)))),validkey(dhexp_real(key_m(alice),g)))),msg_a(alice,bob,sid_5)) in phase 1.
attacker_p1(encrypt(hmac_hash2(hmac_hash1(hmac_hash1(hmac_hash1(hash(somename,empty),dhexp_real(key_e(alice,bob,sid_5),dhexp_real(key_s(bob),g))),dhexp_real(key_e(alice,bob,sid_5),dhexp_real(key_m(bob),g))),dhexp_real(key_m(alice),dhexp_real(key_s(bob),g))),dhexp_real(key_m(bob),dhexp_real(key_s(alice),g))),minnonce,hash(hash(hash(hash(hash(hash(hash(somename,empty),empty),validkey(dhexp_real(key_s(bob),g))),validkey(dhexp_real(key_m(bob),g))),validkey(dhexp_real(key_e(alice,bob,sid_5),g))),encrypt(hmac_hash2(hmac_hash1(hash(somename,empty),dhexp_real(key_e(alice,bob,sid_5),dhexp_real(key_s(bob),g))),dhexp_real(key_e(alice,bob,sid_5),dhexp_real(key_m(bob),g))),minnonce,hash(hash(hash(hash(hash(somename,empty),empty),validkey(dhexp_real(key_s(bob),g))),validkey(dhexp_real(key_m(bob),g))),validkey(dhexp_real(key_e(alice,bob,sid_5),g))),validkey(dhexp_real(key_s(alice),g)))),encrypt(hmac_hash2(hmac_hash1(hash(somename,empty),dhexp_real(key_e(alice,bob,sid_5),dhexp_real(key_s(bob),g))),dhexp_real(key_e(alice,bob,sid_5),dhexp_real(key_m(bob),g))),increment_nonce(minnonce),hash(hash(hash(hash(hash(hash(somename,empty),empty),validkey(dhexp_real(key_s(bob),g))),validkey(dhexp_real(key_m(bob),g))),validkey(dhexp_real(key_e(alice,bob,sid_5),g))),encrypt(hmac_hash2(hmac_hash1(hash(somename,empty),dhexp_real(key_e(alice,bob,sid_5),dhexp_real(key_s(bob),g))),dhexp_real(key_e(alice,bob,sid_5),dhexp_real(key_m(bob),g))),minnonce,hash(hash(hash(hash(hash(somename,empty),empty),validkey(dhexp_real(key_s(bob),g))),validkey(dhexp_real(key_m(bob),g))),validkey(dhexp_real(key_e(alice,bob,sid_5),g))),validkey(dhexp_real(key_s(alice),g)))),validkey(dhexp_real(key_m(alice),g)))),msg_a(alice,bob,sid_5))).

7. The entry statestore(alice,bob,sid_5,statepack_a(handshakestatepack(symmetricstatepack(cipherstatepack(empty,minnonce),hash(somename,empty),hash(hash(hash(hash(somename,empty),empty),validkey(dhexp_real(key_s(bob),g))),validkey(dhexp_real(key_m(bob),g)))),keypairpack(empty,empty),keypairpack(empty,empty),keypairpack(empty,empty),validkey(dhexp_real(key_s(bob),g)),validkey(dhexp_real(key_m(bob),g)),empty,empty,true))) that may be in a table by 2 may be read at get {306}.
The event SendMsg(alice,bob,stagepack_a(sid_5),msg_a(alice,bob,sid_5)) may be executed at {304}.
So the message concat4(validkey(dhexp_real(key_e(alice,bob,sid_5),g)),encrypt(hmac_hash2(hmac_hash1(hash(somename,empty),dhexp_real(key_e(alice,bob,sid_5),dhexp_real(key_s(bob),g))),dhexp_real(key_e(alice,bob,sid_5),dhexp_real(key_m(bob),g))),minnonce,hash(hash(hash(hash(hash(somename,empty),empty),validkey(dhexp_real(key_s(bob),g))),validkey(dhexp_real(key_m(bob),g))),validkey(dhexp_real(key_e(alice,bob,sid_5),g))),validkey(dhexp_real(key_s(alice),g))),encrypt(hmac_hash2(hmac_hash1(hash(somename,empty),dhexp_real(key_e(alice,bob,sid_5),dhexp_real(key_s(bob),g))),dhexp_real(key_e(alice,bob,sid_5),dhexp_real(key_m(bob),g))),increment_nonce(minnonce),hash(hash(hash(hash(hash(hash(somename,empty),empty),validkey(dhexp_real(key_s(bob),g))),validkey(dhexp_real(key_m(bob),g))),validkey(dhexp_real(key_e(alice,bob,sid_5),g))),encrypt(hmac_hash2(hmac_hash1(hash(somename,empty),dhexp_real(key_e(alice,bob,sid_5),dhexp_real(key_s(bob),g))),dhexp_real(key_e(alice,bob,sid_5),dhexp_real(key_m(bob),g))),minnonce,hash(hash(hash(hash(hash(somename,empty),empty),validkey(dhexp_real(key_s(bob),g))),validkey(dhexp_real(key_m(bob),g))),validkey(dhexp_real(key_e(alice,bob,sid_5),g))),validkey(dhexp_real(key_s(alice),g)))),validkey(dhexp_real(key_m(alice),g))),encrypt(hmac_hash2(hmac_hash1(hmac_hash1(hmac_hash1(hash(somename,empty),dhexp_real(key_e(alice,bob,sid_5),dhexp_real(key_s(bob),g))),dhexp_real(key_e(alice,bob,sid_5),dhexp_real(key_m(bob),g))),dhexp_real(key_m(alice),dhexp_real(key_s(bob),g))),dhexp_real(key_s(alice),dhexp_real(key_m(bob),g))),minnonce,hash(hash(hash(hash(hash(hash(hash(somename,empty),empty),validkey(dhexp_real(key_s(bob),g))),validkey(dhexp_real(key_m(bob),g))),validkey(dhexp_real(key_e(alice,bob,sid_5),g))),encrypt(hmac_hash2(hmac_hash1(hash(somename,empty),dhexp_real(key_e(alice,bob,sid_5),dhexp_real(key_s(bob),g))),dhexp_real(key_e(alice,bob,sid_5),dhexp_real(key_m(bob),g))),minnonce,hash(hash(hash(hash(hash(somename,empty),empty),validkey(dhexp_real(key_s(bob),g))),validkey(dhexp_real(key_m(bob),g))),validkey(dhexp_real(key_e(alice,bob,sid_5),g))),validkey(dhexp_real(key_s(alice),g)))),encrypt(hmac_hash2(hmac_hash1(hash(somename,empty),dhexp_real(key_e(alice,bob,sid_5),dhexp_real(key_s(bob),g))),dhexp_real(key_e(alice,bob,sid_5),dhexp_real(key_m(bob),g))),increment_nonce(minnonce),hash(hash(hash(hash(hash(hash(somename,empty),empty),validkey(dhexp_real(key_s(bob),g))),validkey(dhexp_real(key_m(bob),g))),validkey(dhexp_real(key_e(alice,bob,sid_5),g))),encrypt(hmac_hash2(hmac_hash1(hash(somename,empty),dhexp_real(key_e(alice,bob,sid_5),dhexp_real(key_s(bob),g))),dhexp_real(key_e(alice,bob,sid_5),dhexp_real(key_m(bob),g))),minnonce,hash(hash(hash(hash(hash(somename,empty),empty),validkey(dhexp_real(key_s(bob),g))),validkey(dhexp_real(key_m(bob),g))),validkey(dhexp_real(key_e(alice,bob,sid_5),g))),validkey(dhexp_real(key_s(alice),g)))),validkey(dhexp_real(key_m(alice),g)))),msg_a(alice,bob,sid_5))) may be sent on channel pub at output {305}.
mess(pub,concat4(validkey(dhexp_real(key_e(alice,bob,sid_5),g)),encrypt(hmac_hash2(hmac_hash1(hash(somename,empty),dhexp_real(key_e(alice,bob,sid_5),dhexp_real(key_s(bob),g))),dhexp_real(key_e(alice,bob,sid_5),dhexp_real(key_m(bob),g))),minnonce,hash(hash(hash(hash(hash(somename,empty),empty),validkey(dhexp_real(key_s(bob),g))),validkey(dhexp_real(key_m(bob),g))),validkey(dhexp_real(key_e(alice,bob,sid_5),g))),validkey(dhexp_real(key_s(alice),g))),encrypt(hmac_hash2(hmac_hash1(hash(somename,empty),dhexp_real(key_e(alice,bob,sid_5),dhexp_real(key_s(bob),g))),dhexp_real(key_e(alice,bob,sid_5),dhexp_real(key_m(bob),g))),increment_nonce(minnonce),hash(hash(hash(hash(hash(hash(somename,empty),empty),validkey(dhexp_real(key_s(bob),g))),validkey(dhexp_real(key_m(bob),g))),validkey(dhexp_real(key_e(alice,bob,sid_5),g))),encrypt(hmac_hash2(hmac_hash1(hash(somename,empty),dhexp_real(key_e(alice,bob,sid_5),dhexp_real(key_s(bob),g))),dhexp_real(key_e(alice,bob,sid_5),dhexp_real(key_m(bob),g))),minnonce,hash(hash(hash(hash(hash(somename,empty),empty),validkey(dhexp_real(key_s(bob),g))),validkey(dhexp_real(key_m(bob),g))),validkey(dhexp_real(key_e(alice,bob,sid_5),g))),validkey(dhexp_real(key_s(alice),g)))),validkey(dhexp_real(key_m(alice),g))),encrypt(hmac_hash2(hmac_hash1(hmac_hash1(hmac_hash1(hash(somename,empty),dhexp_real(key_e(alice,bob,sid_5),dhexp_real(key_s(bob),g))),dhexp_real(key_e(alice,bob,sid_5),dhexp_real(key_m(bob),g))),dhexp_real(key_m(alice),dhexp_real(key_s(bob),g))),dhexp_real(key_s(alice),dhexp_real(key_m(bob),g))),minnonce,hash(hash(hash(hash(hash(hash(hash(somename,empty),empty),validkey(dhexp_real(key_s(bob),g))),validkey(dhexp_real(key_m(bob),g))),validkey(dhexp_real(key_e(alice,bob,sid_5),g))),encrypt(hmac_hash2(hmac_hash1(hash(somename,empty),dhexp_real(key_e(alice,bob,sid_5),dhexp_real(key_s(bob),g))),dhexp_real(key_e(alice,bob,sid_5),dhexp_real(key_m(bob),g))),minnonce,hash(hash(hash(hash(hash(somename,empty),empty),validkey(dhexp_real(key_s(bob),g))),validkey(dhexp_real(key_m(bob),g))),validkey(dhexp_real(key_e(alice,bob,sid_5),g))),validkey(dhexp_real(key_s(alice),g)))),encrypt(hmac_hash2(hmac_hash1(hash(somename,empty),dhexp_real(key_e(alice,bob,sid_5),dhexp_real(key_s(bob),g))),dhexp_real(key_e(alice,bob,sid_5),dhexp_real(key_m(bob),g))),increment_nonce(minnonce),hash(hash(hash(hash(hash(hash(somename,empty),empty),validkey(dhexp_real(key_s(bob),g))),validkey(dhexp_real(key_m(bob),g))),validkey(dhexp_real(key_e(alice,bob,sid_5),g))),encrypt(hmac_hash2(hmac_hash1(hash(somename,empty),dhexp_real(key_e(alice,bob,sid_5),dhexp_real(key_s(bob),g))),dhexp_real(key_e(alice,bob,sid_5),dhexp_real(key_m(bob),g))),minnonce,hash(hash(hash(hash(hash(somename,empty),empty),validkey(dhexp_real(key_s(bob),g))),validkey(dhexp_real(key_m(bob),g))),validkey(dhexp_real(key_e(alice,bob,sid_5),g))),validkey(dhexp_real(key_s(alice),g)))),validkey(dhexp_real(key_m(alice),g)))),msg_a(alice,bob,sid_5)))).

8. By 1, the attacker may have the channel pub.
By 7, the message concat4(validkey(dhexp_real(key_e(alice,bob,sid_5),g)),encrypt(hmac_hash2(hmac_hash1(hash(somename,empty),dhexp_real(key_e(alice,bob,sid_5),dhexp_real(key_s(bob),g))),dhexp_real(key_e(alice,bob,sid_5),dhexp_real(key_m(bob),g))),minnonce,hash(hash(hash(hash(hash(somename,empty),empty),validkey(dhexp_real(key_s(bob),g))),validkey(dhexp_real(key_m(bob),g))),validkey(dhexp_real(key_e(alice,bob,sid_5),g))),validkey(dhexp_real(key_s(alice),g))),encrypt(hmac_hash2(hmac_hash1(hash(somename,empty),dhexp_real(key_e(alice,bob,sid_5),dhexp_real(key_s(bob),g))),dhexp_real(key_e(alice,bob,sid_5),dhexp_real(key_m(bob),g))),increment_nonce(minnonce),hash(hash(hash(hash(hash(hash(somename,empty),empty),validkey(dhexp_real(key_s(bob),g))),validkey(dhexp_real(key_m(bob),g))),validkey(dhexp_real(key_e(alice,bob,sid_5),g))),encrypt(hmac_hash2(hmac_hash1(hash(somename,empty),dhexp_real(key_e(alice,bob,sid_5),dhexp_real(key_s(bob),g))),dhexp_real(key_e(alice,bob,sid_5),dhexp_real(key_m(bob),g))),minnonce,hash(hash(hash(hash(hash(somename,empty),empty),validkey(dhexp_real(key_s(bob),g))),validkey(dhexp_real(key_m(bob),g))),validkey(dhexp_real(key_e(alice,bob,sid_5),g))),validkey(dhexp_real(key_s(alice),g)))),validkey(dhexp_real(key_m(alice),g))),encrypt(hmac_hash2(hmac_hash1(hmac_hash1(hmac_hash1(hash(somename,empty),dhexp_real(key_e(alice,bob,sid_5),dhexp_real(key_s(bob),g))),dhexp_real(key_e(alice,bob,sid_5),dhexp_real(key_m(bob),g))),dhexp_real(key_m(alice),dhexp_real(key_s(bob),g))),dhexp_real(key_s(alice),dhexp_real(key_m(bob),g))),minnonce,hash(hash(hash(hash(hash(hash(hash(somename,empty),empty),validkey(dhexp_real(key_s(bob),g))),validkey(dhexp_real(key_m(bob),g))),validkey(dhexp_real(key_e(alice,bob,sid_5),g))),encrypt(hmac_hash2(hmac_hash1(hash(somename,empty),dhexp_real(key_e(alice,bob,sid_5),dhexp_real(key_s(bob),g))),dhexp_real(key_e(alice,bob,sid_5),dhexp_real(key_m(bob),g))),minnonce,hash(hash(hash(hash(hash(somename,empty),empty),validkey(dhexp_real(key_s(bob),g))),validkey(dhexp_real(key_m(bob),g))),validkey(dhexp_real(key_e(alice,bob,sid_5),g))),validkey(dhexp_real(key_s(alice),g)))),encrypt(hmac_hash2(hmac_hash1(hash(somename,empty),dhexp_real(key_e(alice,bob,sid_5),dhexp_real(key_s(bob),g))),dhexp_real(key_e(alice,bob,sid_5),dhexp_real(key_m(bob),g))),increment_nonce(minnonce),hash(hash(hash(hash(hash(hash(somename,empty),empty),validkey(dhexp_real(key_s(bob),g))),validkey(dhexp_real(key_m(bob),g))),validkey(dhexp_real(key_e(alice,bob,sid_5),g))),encrypt(hmac_hash2(hmac_hash1(hash(somename,empty),dhexp_real(key_e(alice,bob,sid_5),dhexp_real(key_s(bob),g))),dhexp_real(key_e(alice,bob,sid_5),dhexp_real(key_m(bob),g))),minnonce,hash(hash(hash(hash(hash(somename,empty),empty),validkey(dhexp_real(key_s(bob),g))),validkey(dhexp_real(key_m(bob),g))),validkey(dhexp_real(key_e(alice,bob,sid_5),g))),validkey(dhexp_real(key_s(alice),g)))),validkey(dhexp_real(key_m(alice),g)))),msg_a(alice,bob,sid_5))) may be sent on this channel.
So the attacker may obtain the message concat4(validkey(dhexp_real(key_e(alice,bob,sid_5),g)),encrypt(hmac_hash2(hmac_hash1(hash(somename,empty),dhexp_real(key_e(alice,bob,sid_5),dhexp_real(key_s(bob),g))),dhexp_real(key_e(alice,bob,sid_5),dhexp_real(key_m(bob),g))),minnonce,hash(hash(hash(hash(hash(somename,empty),empty),validkey(dhexp_real(key_s(bob),g))),validkey(dhexp_real(key_m(bob),g))),validkey(dhexp_real(key_e(alice,bob,sid_5),g))),validkey(dhexp_real(key_s(alice),g))),encrypt(hmac_hash2(hmac_hash1(hash(somename,empty),dhexp_real(key_e(alice,bob,sid_5),dhexp_real(key_s(bob),g))),dhexp_real(key_e(alice,bob,sid_5),dhexp_real(key_m(bob),g))),increment_nonce(minnonce),hash(hash(hash(hash(hash(hash(somename,empty),empty),validkey(dhexp_real(key_s(bob),g))),validkey(dhexp_real(key_m(bob),g))),validkey(dhexp_real(key_e(alice,bob,sid_5),g))),encrypt(hmac_hash2(hmac_hash1(hash(somename,empty),dhexp_real(key_e(alice,bob,sid_5),dhexp_real(key_s(bob),g))),dhexp_real(key_e(alice,bob,sid_5),dhexp_real(key_m(bob),g))),minnonce,hash(hash(hash(hash(hash(somename,empty),empty),validkey(dhexp_real(key_s(bob),g))),validkey(dhexp_real(key_m(bob),g))),validkey(dhexp_real(key_e(alice,bob,sid_5),g))),validkey(dhexp_real(key_s(alice),g)))),validkey(dhexp_real(key_m(alice),g))),encrypt(hmac_hash2(hmac_hash1(hmac_hash1(hmac_hash1(hash(somename,empty),dhexp_real(key_e(alice,bob,sid_5),dhexp_real(key_s(bob),g))),dhexp_real(key_e(alice,bob,sid_5),dhexp_real(key_m(bob),g))),dhexp_real(key_m(alice),dhexp_real(key_s(bob),g))),dhexp_real(key_s(alice),dhexp_real(key_m(bob),g))),minnonce,hash(hash(hash(hash(hash(hash(hash(somename,empty),empty),validkey(dhexp_real(key_s(bob),g))),validkey(dhexp_real(key_m(bob),g))),validkey(dhexp_real(key_e(alice,bob,sid_5),g))),encrypt(hmac_hash2(hmac_hash1(hash(somename,empty),dhexp_real(key_e(alice,bob,sid_5),dhexp_real(key_s(bob),g))),dhexp_real(key_e(alice,bob,sid_5),dhexp_real(key_m(bob),g))),minnonce,hash(hash(hash(hash(hash(somename,empty),empty),validkey(dhexp_real(key_s(bob),g))),validkey(dhexp_real(key_m(bob),g))),validkey(dhexp_real(key_e(alice,bob,sid_5),g))),validkey(dhexp_real(key_s(alice),g)))),encrypt(hmac_hash2(hmac_hash1(hash(somename,empty),dhexp_real(key_e(alice,bob,sid_5),dhexp_real(key_s(bob),g))),dhexp_real(key_e(alice,bob,sid_5),dhexp_real(key_m(bob),g))),increment_nonce(minnonce),hash(hash(hash(hash(hash(hash(somename,empty),empty),validkey(dhexp_real(key_s(bob),g))),validkey(dhexp_real(key_m(bob),g))),validkey(dhexp_real(key_e(alice,bob,sid_5),g))),encrypt(hmac_hash2(hmac_hash1(hash(somename,empty),dhexp_real(key_e(alice,bob,sid_5),dhexp_real(key_s(bob),g))),dhexp_real(key_e(alice,bob,sid_5),dhexp_real(key_m(bob),g))),minnonce,hash(hash(hash(hash(hash(somename,empty),empty),validkey(dhexp_real(key_s(bob),g))),validkey(dhexp_real(key_m(bob),g))),validkey(dhexp_real(key_e(alice,bob,sid_5),g))),validkey(dhexp_real(key_s(alice),g)))),validkey(dhexp_real(key_m(alice),g)))),msg_a(alice,bob,sid_5))) by listening on this channel.
attacker(concat4(validkey(dhexp_real(key_e(alice,bob,sid_5),g)),encrypt(hmac_hash2(hmac_hash1(hash(somename,empty),dhexp_real(key_e(alice,bob,sid_5),dhexp_real(key_s(bob),g))),dhexp_real(key_e(alice,bob,sid_5),dhexp_real(key_m(bob),g))),minnonce,hash(hash(hash(hash(hash(somename,empty),empty),validkey(dhexp_real(key_s(bob),g))),validkey(dhexp_real(key_m(bob),g))),validkey(dhexp_real(key_e(alice,bob,sid_5),g))),validkey(dhexp_real(key_s(alice),g))),encrypt(hmac_hash2(hmac_hash1(hash(somename,empty),dhexp_real(key_e(alice,bob,sid_5),dhexp_real(key_s(bob),g))),dhexp_real(key_e(alice,bob,sid_5),dhexp_real(key_m(bob),g))),increment_nonce(minnonce),hash(hash(hash(hash(hash(hash(somename,empty),empty),validkey(dhexp_real(key_s(bob),g))),validkey(dhexp_real(key_m(bob),g))),validkey(dhexp_real(key_e(alice,bob,sid_5),g))),encrypt(hmac_hash2(hmac_hash1(hash(somename,empty),dhexp_real(key_e(alice,bob,sid_5),dhexp_real(key_s(bob),g))),dhexp_real(key_e(alice,bob,sid_5),dhexp_real(key_m(bob),g))),minnonce,hash(hash(hash(hash(hash(somename,empty),empty),validkey(dhexp_real(key_s(bob),g))),validkey(dhexp_real(key_m(bob),g))),validkey(dhexp_real(key_e(alice,bob,sid_5),g))),validkey(dhexp_real(key_s(alice),g)))),validkey(dhexp_real(key_m(alice),g))),encrypt(hmac_hash2(hmac_hash1(hmac_hash1(hmac_hash1(hash(somename,empty),dhexp_real(key_e(alice,bob,sid_5),dhexp_real(key_s(bob),g))),dhexp_real(key_e(alice,bob,sid_5),dhexp_real(key_m(bob),g))),dhexp_real(key_m(alice),dhexp_real(key_s(bob),g))),dhexp_real(key_s(alice),dhexp_real(key_m(bob),g))),minnonce,hash(hash(hash(hash(hash(hash(hash(somename,empty),empty),validkey(dhexp_real(key_s(bob),g))),validkey(dhexp_real(key_m(bob),g))),validkey(dhexp_real(key_e(alice,bob,sid_5),g))),encrypt(hmac_hash2(hmac_hash1(hash(somename,empty),dhexp_real(key_e(alice,bob,sid_5),dhexp_real(key_s(bob),g))),dhexp_real(key_e(alice,bob,sid_5),dhexp_real(key_m(bob),g))),minnonce,hash(hash(hash(hash(hash(somename,empty),empty),validkey(dhexp_real(key_s(bob),g))),validkey(dhexp_real(key_m(bob),g))),validkey(dhexp_real(key_e(alice,bob,sid_5),g))),validkey(dhexp_real(key_s(alice),g)))),encrypt(hmac_hash2(hmac_hash1(hash(somename,empty),dhexp_real(key_e(alice,bob,sid_5),dhexp_real(key_s(bob),g))),dhexp_real(key_e(alice,bob,sid_5),dhexp_real(key_m(bob),g))),increment_nonce(minnonce),hash(hash(hash(hash(hash(hash(somename,empty),empty),validkey(dhexp_real(key_s(bob),g))),validkey(dhexp_real(key_m(bob),g))),validkey(dhexp_real(key_e(alice,bob,sid_5),g))),encrypt(hmac_hash2(hmac_hash1(hash(somename,empty),dhexp_real(key_e(alice,bob,sid_5),dhexp_real(key_s(bob),g))),dhexp_real(key_e(alice,bob,sid_5),dhexp_real(key_m(bob),g))),minnonce,hash(hash(hash(hash(hash(somename,empty),empty),validkey(dhexp_real(key_s(bob),g))),validkey(dhexp_real(key_m(bob),g))),validkey(dhexp_real(key_e(alice,bob,sid_5),g))),validkey(dhexp_real(key_s(alice),g)))),validkey(dhexp_real(key_m(alice),g)))),msg_a(alice,bob,sid_5)))).

9. By 8, the attacker may know concat4(validkey(dhexp_real(key_e(alice,bob,sid_5),g)),encrypt(hmac_hash2(hmac_hash1(hash(somename,empty),dhexp_real(key_e(alice,bob,sid_5),dhexp_real(key_s(bob),g))),dhexp_real(key_e(alice,bob,sid_5),dhexp_real(key_m(bob),g))),minnonce,hash(hash(hash(hash(hash(somename,empty),empty),validkey(dhexp_real(key_s(bob),g))),validkey(dhexp_real(key_m(bob),g))),validkey(dhexp_real(key_e(alice,bob,sid_5),g))),validkey(dhexp_real(key_s(alice),g))),encrypt(hmac_hash2(hmac_hash1(hash(somename,empty),dhexp_real(key_e(alice,bob,sid_5),dhexp_real(key_s(bob),g))),dhexp_real(key_e(alice,bob,sid_5),dhexp_real(key_m(bob),g))),increment_nonce(minnonce),hash(hash(hash(hash(hash(hash(somename,empty),empty),validkey(dhexp_real(key_s(bob),g))),validkey(dhexp_real(key_m(bob),g))),validkey(dhexp_real(key_e(alice,bob,sid_5),g))),encrypt(hmac_hash2(hmac_hash1(hash(somename,empty),dhexp_real(key_e(alice,bob,sid_5),dhexp_real(key_s(bob),g))),dhexp_real(key_e(alice,bob,sid_5),dhexp_real(key_m(bob),g))),minnonce,hash(hash(hash(hash(hash(somename,empty),empty),validkey(dhexp_real(key_s(bob),g))),validkey(dhexp_real(key_m(bob),g))),validkey(dhexp_real(key_e(alice,bob,sid_5),g))),validkey(dhexp_real(key_s(alice),g)))),validkey(dhexp_real(key_m(alice),g))),encrypt(hmac_hash2(hmac_hash1(hmac_hash1(hmac_hash1(hash(somename,empty),dhexp_real(key_e(alice,bob,sid_5),dhexp_real(key_s(bob),g))),dhexp_real(key_e(alice,bob,sid_5),dhexp_real(key_m(bob),g))),dhexp_real(key_m(alice),dhexp_real(key_s(bob),g))),dhexp_real(key_s(alice),dhexp_real(key_m(bob),g))),minnonce,hash(hash(hash(hash(hash(hash(hash(somename,empty),empty),validkey(dhexp_real(key_s(bob),g))),validkey(dhexp_real(key_m(bob),g))),validkey(dhexp_real(key_e(alice,bob,sid_5),g))),encrypt(hmac_hash2(hmac_hash1(hash(somename,empty),dhexp_real(key_e(alice,bob,sid_5),dhexp_real(key_s(bob),g))),dhexp_real(key_e(alice,bob,sid_5),dhexp_real(key_m(bob),g))),minnonce,hash(hash(hash(hash(hash(somename,empty),empty),validkey(dhexp_real(key_s(bob),g))),validkey(dhexp_real(key_m(bob),g))),validkey(dhexp_real(key_e(alice,bob,sid_5),g))),validkey(dhexp_real(key_s(alice),g)))),encrypt(hmac_hash2(hmac_hash1(hash(somename,empty),dhexp_real(key_e(alice,bob,sid_5),dhexp_real(key_s(bob),g))),dhexp_real(key_e(alice,bob,sid_5),dhexp_real(key_m(bob),g))),increment_nonce(minnonce),hash(hash(hash(hash(hash(hash(somename,empty),empty),validkey(dhexp_real(key_s(bob),g))),validkey(dhexp_real(key_m(bob),g))),validkey(dhexp_real(key_e(alice,bob,sid_5),g))),encrypt(hmac_hash2(hmac_hash1(hash(somename,empty),dhexp_real(key_e(alice,bob,sid_5),dhexp_real(key_s(bob),g))),dhexp_real(key_e(alice,bob,sid_5),dhexp_real(key_m(bob),g))),minnonce,hash(hash(hash(hash(hash(somename,empty),empty),validkey(dhexp_real(key_s(bob),g))),validkey(dhexp_real(key_m(bob),g))),validkey(dhexp_real(key_e(alice,bob,sid_5),g))),validkey(dhexp_real(key_s(alice),g)))),validkey(dhexp_real(key_m(alice),g)))),msg_a(alice,bob,sid_5))).
Using the function 3-proj-concat4 the attacker may obtain encrypt(hmac_hash2(hmac_hash1(hash(somename,empty),dhexp_real(key_e(alice,bob,sid_5),dhexp_real(key_s(bob),g))),dhexp_real(key_e(alice,bob,sid_5),dhexp_real(key_m(bob),g))),increment_nonce(minnonce),hash(hash(hash(hash(hash(hash(somename,empty),empty),validkey(dhexp_real(key_s(bob),g))),validkey(dhexp_real(key_m(bob),g))),validkey(dhexp_real(key_e(alice,bob,sid_5),g))),encrypt(hmac_hash2(hmac_hash1(hash(somename,empty),dhexp_real(key_e(alice,bob,sid_5),dhexp_real(key_s(bob),g))),dhexp_real(key_e(alice,bob,sid_5),dhexp_real(key_m(bob),g))),minnonce,hash(hash(hash(hash(hash(somename,empty),empty),validkey(dhexp_real(key_s(bob),g))),validkey(dhexp_real(key_m(bob),g))),validkey(dhexp_real(key_e(alice,bob,sid_5),g))),validkey(dhexp_real(key_s(alice),g)))),validkey(dhexp_real(key_m(alice),g))).
attacker(encrypt(hmac_hash2(hmac_hash1(hash(somename,empty),dhexp_real(key_e(alice,bob,sid_5),dhexp_real(key_s(bob),g))),dhexp_real(key_e(alice,bob,sid_5),dhexp_real(key_m(bob),g))),increment_nonce(minnonce),hash(hash(hash(hash(hash(hash(somename,empty),empty),validkey(dhexp_real(key_s(bob),g))),validkey(dhexp_real(key_m(bob),g))),validkey(dhexp_real(key_e(alice,bob,sid_5),g))),encrypt(hmac_hash2(hmac_hash1(hash(somename,empty),dhexp_real(key_e(alice,bob,sid_5),dhexp_real(key_s(bob),g))),dhexp_real(key_e(alice,bob,sid_5),dhexp_real(key_m(bob),g))),minnonce,hash(hash(hash(hash(hash(somename,empty),empty),validkey(dhexp_real(key_s(bob),g))),validkey(dhexp_real(key_m(bob),g))),validkey(dhexp_real(key_e(alice,bob,sid_5),g))),validkey(dhexp_real(key_s(alice),g)))),validkey(dhexp_real(key_m(alice),g)))).

10. By 8, the attacker may know concat4(validkey(dhexp_real(key_e(alice,bob,sid_5),g)),encrypt(hmac_hash2(hmac_hash1(hash(somename,empty),dhexp_real(key_e(alice,bob,sid_5),dhexp_real(key_s(bob),g))),dhexp_real(key_e(alice,bob,sid_5),dhexp_real(key_m(bob),g))),minnonce,hash(hash(hash(hash(hash(somename,empty),empty),validkey(dhexp_real(key_s(bob),g))),validkey(dhexp_real(key_m(bob),g))),validkey(dhexp_real(key_e(alice,bob,sid_5),g))),validkey(dhexp_real(key_s(alice),g))),encrypt(hmac_hash2(hmac_hash1(hash(somename,empty),dhexp_real(key_e(alice,bob,sid_5),dhexp_real(key_s(bob),g))),dhexp_real(key_e(alice,bob,sid_5),dhexp_real(key_m(bob),g))),increment_nonce(minnonce),hash(hash(hash(hash(hash(hash(somename,empty),empty),validkey(dhexp_real(key_s(bob),g))),validkey(dhexp_real(key_m(bob),g))),validkey(dhexp_real(key_e(alice,bob,sid_5),g))),encrypt(hmac_hash2(hmac_hash1(hash(somename,empty),dhexp_real(key_e(alice,bob,sid_5),dhexp_real(key_s(bob),g))),dhexp_real(key_e(alice,bob,sid_5),dhexp_real(key_m(bob),g))),minnonce,hash(hash(hash(hash(hash(somename,empty),empty),validkey(dhexp_real(key_s(bob),g))),validkey(dhexp_real(key_m(bob),g))),validkey(dhexp_real(key_e(alice,bob,sid_5),g))),validkey(dhexp_real(key_s(alice),g)))),validkey(dhexp_real(key_m(alice),g))),encrypt(hmac_hash2(hmac_hash1(hmac_hash1(hmac_hash1(hash(somename,empty),dhexp_real(key_e(alice,bob,sid_5),dhexp_real(key_s(bob),g))),dhexp_real(key_e(alice,bob,sid_5),dhexp_real(key_m(bob),g))),dhexp_real(key_m(alice),dhexp_real(key_s(bob),g))),dhexp_real(key_s(alice),dhexp_real(key_m(bob),g))),minnonce,hash(hash(hash(hash(hash(hash(hash(somename,empty),empty),validkey(dhexp_real(key_s(bob),g))),validkey(dhexp_real(key_m(bob),g))),validkey(dhexp_real(key_e(alice,bob,sid_5),g))),encrypt(hmac_hash2(hmac_hash1(hash(somename,empty),dhexp_real(key_e(alice,bob,sid_5),dhexp_real(key_s(bob),g))),dhexp_real(key_e(alice,bob,sid_5),dhexp_real(key_m(bob),g))),minnonce,hash(hash(hash(hash(hash(somename,empty),empty),validkey(dhexp_real(key_s(bob),g))),validkey(dhexp_real(key_m(bob),g))),validkey(dhexp_real(key_e(alice,bob,sid_5),g))),validkey(dhexp_real(key_s(alice),g)))),encrypt(hmac_hash2(hmac_hash1(hash(somename,empty),dhexp_real(key_e(alice,bob,sid_5),dhexp_real(key_s(bob),g))),dhexp_real(key_e(alice,bob,sid_5),dhexp_real(key_m(bob),g))),increment_nonce(minnonce),hash(hash(hash(hash(hash(hash(somename,empty),empty),validkey(dhexp_real(key_s(bob),g))),validkey(dhexp_real(key_m(bob),g))),validkey(dhexp_real(key_e(alice,bob,sid_5),g))),encrypt(hmac_hash2(hmac_hash1(hash(somename,empty),dhexp_real(key_e(alice,bob,sid_5),dhexp_real(key_s(bob),g))),dhexp_real(key_e(alice,bob,sid_5),dhexp_real(key_m(bob),g))),minnonce,hash(hash(hash(hash(hash(somename,empty),empty),validkey(dhexp_real(key_s(bob),g))),validkey(dhexp_real(key_m(bob),g))),validkey(dhexp_real(key_e(alice,bob,sid_5),g))),validkey(dhexp_real(key_s(alice),g)))),validkey(dhexp_real(key_m(alice),g)))),msg_a(alice,bob,sid_5))).
Using the function 2-proj-concat4 the attacker may obtain encrypt(hmac_hash2(hmac_hash1(hash(somename,empty),dhexp_real(key_e(alice,bob,sid_5),dhexp_real(key_s(bob),g))),dhexp_real(key_e(alice,bob,sid_5),dhexp_real(key_m(bob),g))),minnonce,hash(hash(hash(hash(hash(somename,empty),empty),validkey(dhexp_real(key_s(bob),g))),validkey(dhexp_real(key_m(bob),g))),validkey(dhexp_real(key_e(alice,bob,sid_5),g))),validkey(dhexp_real(key_s(alice),g))).
attacker(encrypt(hmac_hash2(hmac_hash1(hash(somename,empty),dhexp_real(key_e(alice,bob,sid_5),dhexp_real(key_s(bob),g))),dhexp_real(key_e(alice,bob,sid_5),dhexp_real(key_m(bob),g))),minnonce,hash(hash(hash(hash(hash(somename,empty),empty),validkey(dhexp_real(key_s(bob),g))),validkey(dhexp_real(key_m(bob),g))),validkey(dhexp_real(key_e(alice,bob,sid_5),g))),validkey(dhexp_real(key_s(alice),g)))).

11. By 8, the attacker may know concat4(validkey(dhexp_real(key_e(alice,bob,sid_5),g)),encrypt(hmac_hash2(hmac_hash1(hash(somename,empty),dhexp_real(key_e(alice,bob,sid_5),dhexp_real(key_s(bob),g))),dhexp_real(key_e(alice,bob,sid_5),dhexp_real(key_m(bob),g))),minnonce,hash(hash(hash(hash(hash(somename,empty),empty),validkey(dhexp_real(key_s(bob),g))),validkey(dhexp_real(key_m(bob),g))),validkey(dhexp_real(key_e(alice,bob,sid_5),g))),validkey(dhexp_real(key_s(alice),g))),encrypt(hmac_hash2(hmac_hash1(hash(somename,empty),dhexp_real(key_e(alice,bob,sid_5),dhexp_real(key_s(bob),g))),dhexp_real(key_e(alice,bob,sid_5),dhexp_real(key_m(bob),g))),increment_nonce(minnonce),hash(hash(hash(hash(hash(hash(somename,empty),empty),validkey(dhexp_real(key_s(bob),g))),validkey(dhexp_real(key_m(bob),g))),validkey(dhexp_real(key_e(alice,bob,sid_5),g))),encrypt(hmac_hash2(hmac_hash1(hash(somename,empty),dhexp_real(key_e(alice,bob,sid_5),dhexp_real(key_s(bob),g))),dhexp_real(key_e(alice,bob,sid_5),dhexp_real(key_m(bob),g))),minnonce,hash(hash(hash(hash(hash(somename,empty),empty),validkey(dhexp_real(key_s(bob),g))),validkey(dhexp_real(key_m(bob),g))),validkey(dhexp_real(key_e(alice,bob,sid_5),g))),validkey(dhexp_real(key_s(alice),g)))),validkey(dhexp_real(key_m(alice),g))),encrypt(hmac_hash2(hmac_hash1(hmac_hash1(hmac_hash1(hash(somename,empty),dhexp_real(key_e(alice,bob,sid_5),dhexp_real(key_s(bob),g))),dhexp_real(key_e(alice,bob,sid_5),dhexp_real(key_m(bob),g))),dhexp_real(key_m(alice),dhexp_real(key_s(bob),g))),dhexp_real(key_s(alice),dhexp_real(key_m(bob),g))),minnonce,hash(hash(hash(hash(hash(hash(hash(somename,empty),empty),validkey(dhexp_real(key_s(bob),g))),validkey(dhexp_real(key_m(bob),g))),validkey(dhexp_real(key_e(alice,bob,sid_5),g))),encrypt(hmac_hash2(hmac_hash1(hash(somename,empty),dhexp_real(key_e(alice,bob,sid_5),dhexp_real(key_s(bob),g))),dhexp_real(key_e(alice,bob,sid_5),dhexp_real(key_m(bob),g))),minnonce,hash(hash(hash(hash(hash(somename,empty),empty),validkey(dhexp_real(key_s(bob),g))),validkey(dhexp_real(key_m(bob),g))),validkey(dhexp_real(key_e(alice,bob,sid_5),g))),validkey(dhexp_real(key_s(alice),g)))),encrypt(hmac_hash2(hmac_hash1(hash(somename,empty),dhexp_real(key_e(alice,bob,sid_5),dhexp_real(key_s(bob),g))),dhexp_real(key_e(alice,bob,sid_5),dhexp_real(key_m(bob),g))),increment_nonce(minnonce),hash(hash(hash(hash(hash(hash(somename,empty),empty),validkey(dhexp_real(key_s(bob),g))),validkey(dhexp_real(key_m(bob),g))),validkey(dhexp_real(key_e(alice,bob,sid_5),g))),encrypt(hmac_hash2(hmac_hash1(hash(somename,empty),dhexp_real(key_e(alice,bob,sid_5),dhexp_real(key_s(bob),g))),dhexp_real(key_e(alice,bob,sid_5),dhexp_real(key_m(bob),g))),minnonce,hash(hash(hash(hash(hash(somename,empty),empty),validkey(dhexp_real(key_s(bob),g))),validkey(dhexp_real(key_m(bob),g))),validkey(dhexp_real(key_e(alice,bob,sid_5),g))),validkey(dhexp_real(key_s(alice),g)))),validkey(dhexp_real(key_m(alice),g)))),msg_a(alice,bob,sid_5))).
Using the function 1-proj-concat4 the attacker may obtain validkey(dhexp_real(key_e(alice,bob,sid_5),g)).
attacker(validkey(dhexp_real(key_e(alice,bob,sid_5),g))).

12. The message (validkey(dhexp_real(key_s(bob),g)),validkey(dhexp_real(key_m(bob),g))) may be sent on channel pub at output {635}.
mess(pub,(validkey(dhexp_real(key_s(bob),g)),validkey(dhexp_real(key_m(bob),g)))).

13. By 1, the attacker may have the channel pub.
By 12, the message (validkey(dhexp_real(key_s(bob),g)),validkey(dhexp_real(key_m(bob),g))) may be sent on this channel.
So the attacker may obtain the message (validkey(dhexp_real(key_s(bob),g)),validkey(dhexp_real(key_m(bob),g))) by listening on this channel.
attacker((validkey(dhexp_real(key_s(bob),g)),validkey(dhexp_real(key_m(bob),g)))).

14. By 13, the attacker may know (validkey(dhexp_real(key_s(bob),g)),validkey(dhexp_real(key_m(bob),g))).
Using the function 2-proj-2-tuple the attacker may obtain validkey(dhexp_real(key_m(bob),g)).
attacker(validkey(dhexp_real(key_m(bob),g))).

15. By 13, the attacker may know (validkey(dhexp_real(key_s(bob),g)),validkey(dhexp_real(key_m(bob),g))).
Using the function 1-proj-2-tuple the attacker may obtain validkey(dhexp_real(key_s(bob),g)).
attacker(validkey(dhexp_real(key_s(bob),g))).

16. Using the function empty the attacker may obtain empty.
attacker(empty).

17. Using the function somename the attacker may obtain somename.
attacker(somename).

18. By 17, the attacker may know somename.
By 16, the attacker may know empty.
Using the function hash the attacker may obtain hash(somename,empty).
attacker(hash(somename,empty)).

19. By 18, the attacker may know hash(somename,empty).
By 16, the attacker may know empty.
Using the function hash the attacker may obtain hash(hash(somename,empty),empty).
attacker(hash(hash(somename,empty),empty)).

20. By 19, the attacker may know hash(hash(somename,empty),empty).
By 15, the attacker may know validkey(dhexp_real(key_s(bob),g)).
Using the function hash the attacker may obtain hash(hash(hash(somename,empty),empty),validkey(dhexp_real(key_s(bob),g))).
attacker(hash(hash(hash(somename,empty),empty),validkey(dhexp_real(key_s(bob),g)))).

21. By 20, the attacker may know hash(hash(hash(somename,empty),empty),validkey(dhexp_real(key_s(bob),g))).
By 14, the attacker may know validkey(dhexp_real(key_m(bob),g)).
Using the function hash the attacker may obtain hash(hash(hash(hash(somename,empty),empty),validkey(dhexp_real(key_s(bob),g))),validkey(dhexp_real(key_m(bob),g))).
attacker(hash(hash(hash(hash(somename,empty),empty),validkey(dhexp_real(key_s(bob),g))),validkey(dhexp_real(key_m(bob),g)))).

22. By 21, the attacker may know hash(hash(hash(hash(somename,empty),empty),validkey(dhexp_real(key_s(bob),g))),validkey(dhexp_real(key_m(bob),g))).
By 11, the attacker may know validkey(dhexp_real(key_e(alice,bob,sid_5),g)).
Using the function hash the attacker may obtain hash(hash(hash(hash(hash(somename,empty),empty),validkey(dhexp_real(key_s(bob),g))),validkey(dhexp_real(key_m(bob),g))),validkey(dhexp_real(key_e(alice,bob,sid_5),g))).
attacker(hash(hash(hash(hash(hash(somename,empty),empty),validkey(dhexp_real(key_s(bob),g))),validkey(dhexp_real(key_m(bob),g))),validkey(dhexp_real(key_e(alice,bob,sid_5),g)))).

23. By 22, the attacker may know hash(hash(hash(hash(hash(somename,empty),empty),validkey(dhexp_real(key_s(bob),g))),validkey(dhexp_real(key_m(bob),g))),validkey(dhexp_real(key_e(alice,bob,sid_5),g))).
By 10, the attacker may know encrypt(hmac_hash2(hmac_hash1(hash(somename,empty),dhexp_real(key_e(alice,bob,sid_5),dhexp_real(key_s(bob),g))),dhexp_real(key_e(alice,bob,sid_5),dhexp_real(key_m(bob),g))),minnonce,hash(hash(hash(hash(hash(somename,empty),empty),validkey(dhexp_real(key_s(bob),g))),validkey(dhexp_real(key_m(bob),g))),validkey(dhexp_real(key_e(alice,bob,sid_5),g))),validkey(dhexp_real(key_s(alice),g))).
Using the function hash the attacker may obtain hash(hash(hash(hash(hash(hash(somename,empty),empty),validkey(dhexp_real(key_s(bob),g))),validkey(dhexp_real(key_m(bob),g))),validkey(dhexp_real(key_e(alice,bob,sid_5),g))),encrypt(hmac_hash2(hmac_hash1(hash(somename,empty),dhexp_real(key_e(alice,bob,sid_5),dhexp_real(key_s(bob),g))),dhexp_real(key_e(alice,bob,sid_5),dhexp_real(key_m(bob),g))),minnonce,hash(hash(hash(hash(hash(somename,empty),empty),validkey(dhexp_real(key_s(bob),g))),validkey(dhexp_real(key_m(bob),g))),validkey(dhexp_real(key_e(alice,bob,sid_5),g))),validkey(dhexp_real(key_s(alice),g)))).
attacker(hash(hash(hash(hash(hash(hash(somename,empty),empty),validkey(dhexp_real(key_s(bob),g))),validkey(dhexp_real(key_m(bob),g))),validkey(dhexp_real(key_e(alice,bob,sid_5),g))),encrypt(hmac_hash2(hmac_hash1(hash(somename,empty),dhexp_real(key_e(alice,bob,sid_5),dhexp_real(key_s(bob),g))),dhexp_real(key_e(alice,bob,sid_5),dhexp_real(key_m(bob),g))),minnonce,hash(hash(hash(hash(hash(somename,empty),empty),validkey(dhexp_real(key_s(bob),g))),validkey(dhexp_real(key_m(bob),g))),validkey(dhexp_real(key_e(alice,bob,sid_5),g))),validkey(dhexp_real(key_s(alice),g))))).

24. By 23, the attacker may know hash(hash(hash(hash(hash(hash(somename,empty),empty),validkey(dhexp_real(key_s(bob),g))),validkey(dhexp_real(key_m(bob),g))),validkey(dhexp_real(key_e(alice,bob,sid_5),g))),encrypt(hmac_hash2(hmac_hash1(hash(somename,empty),dhexp_real(key_e(alice,bob,sid_5),dhexp_real(key_s(bob),g))),dhexp_real(key_e(alice,bob,sid_5),dhexp_real(key_m(bob),g))),minnonce,hash(hash(hash(hash(hash(somename,empty),empty),validkey(dhexp_real(key_s(bob),g))),validkey(dhexp_real(key_m(bob),g))),validkey(dhexp_real(key_e(alice,bob,sid_5),g))),validkey(dhexp_real(key_s(alice),g)))).
By 9, the attacker may know encrypt(hmac_hash2(hmac_hash1(hash(somename,empty),dhexp_real(key_e(alice,bob,sid_5),dhexp_real(key_s(bob),g))),dhexp_real(key_e(alice,bob,sid_5),dhexp_real(key_m(bob),g))),increment_nonce(minnonce),hash(hash(hash(hash(hash(hash(somename,empty),empty),validkey(dhexp_real(key_s(bob),g))),validkey(dhexp_real(key_m(bob),g))),validkey(dhexp_real(key_e(alice,bob,sid_5),g))),encrypt(hmac_hash2(hmac_hash1(hash(somename,empty),dhexp_real(key_e(alice,bob,sid_5),dhexp_real(key_s(bob),g))),dhexp_real(key_e(alice,bob,sid_5),dhexp_real(key_m(bob),g))),minnonce,hash(hash(hash(hash(hash(somename,empty),empty),validkey(dhexp_real(key_s(bob),g))),validkey(dhexp_real(key_m(bob),g))),validkey(dhexp_real(key_e(alice,bob,sid_5),g))),validkey(dhexp_real(key_s(alice),g)))),validkey(dhexp_real(key_m(alice),g))).
Using the function hash the attacker may obtain hash(hash(hash(hash(hash(hash(hash(somename,empty),empty),validkey(dhexp_real(key_s(bob),g))),validkey(dhexp_real(key_m(bob),g))),validkey(dhexp_real(key_e(alice,bob,sid_5),g))),encrypt(hmac_hash2(hmac_hash1(hash(somename,empty),dhexp_real(key_e(alice,bob,sid_5),dhexp_real(key_s(bob),g))),dhexp_real(key_e(alice,bob,sid_5),dhexp_real(key_m(bob),g))),minnonce,hash(hash(hash(hash(hash(somename,empty),empty),validkey(dhexp_real(key_s(bob),g))),validkey(dhexp_real(key_m(bob),g))),validkey(dhexp_real(key_e(alice,bob,sid_5),g))),validkey(dhexp_real(key_s(alice),g)))),encrypt(hmac_hash2(hmac_hash1(hash(somename,empty),dhexp_real(key_e(alice,bob,sid_5),dhexp_real(key_s(bob),g))),dhexp_real(key_e(alice,bob,sid_5),dhexp_real(key_m(bob),g))),increment_nonce(minnonce),hash(hash(hash(hash(hash(hash(somename,empty),empty),validkey(dhexp_real(key_s(bob),g))),validkey(dhexp_real(key_m(bob),g))),validkey(dhexp_real(key_e(alice,bob,sid_5),g))),encrypt(hmac_hash2(hmac_hash1(hash(somename,empty),dhexp_real(key_e(alice,bob,sid_5),dhexp_real(key_s(bob),g))),dhexp_real(key_e(alice,bob,sid_5),dhexp_real(key_m(bob),g))),minnonce,hash(hash(hash(hash(hash(somename,empty),empty),validkey(dhexp_real(key_s(bob),g))),validkey(dhexp_real(key_m(bob),g))),validkey(dhexp_real(key_e(alice,bob,sid_5),g))),validkey(dhexp_real(key_s(alice),g)))),validkey(dhexp_real(key_m(alice),g)))).
attacker(hash(hash(hash(hash(hash(hash(hash(somename,empty),empty),validkey(dhexp_real(key_s(bob),g))),validkey(dhexp_real(key_m(bob),g))),validkey(dhexp_real(key_e(alice,bob,sid_5),g))),encrypt(hmac_hash2(hmac_hash1(hash(somename,empty),dhexp_real(key_e(alice,bob,sid_5),dhexp_real(key_s(bob),g))),dhexp_real(key_e(alice,bob,sid_5),dhexp_real(key_m(bob),g))),minnonce,hash(hash(hash(hash(hash(somename,empty),empty),validkey(dhexp_real(key_s(bob),g))),validkey(dhexp_real(key_m(bob),g))),validkey(dhexp_real(key_e(alice,bob,sid_5),g))),validkey(dhexp_real(key_s(alice),g)))),encrypt(hmac_hash2(hmac_hash1(hash(somename,empty),dhexp_real(key_e(alice,bob,sid_5),dhexp_real(key_s(bob),g))),dhexp_real(key_e(alice,bob,sid_5),dhexp_real(key_m(bob),g))),increment_nonce(minnonce),hash(hash(hash(hash(hash(hash(somename,empty),empty),validkey(dhexp_real(key_s(bob),g))),validkey(dhexp_real(key_m(bob),g))),validkey(dhexp_real(key_e(alice,bob,sid_5),g))),encrypt(hmac_hash2(hmac_hash1(hash(somename,empty),dhexp_real(key_e(alice,bob,sid_5),dhexp_real(key_s(bob),g))),dhexp_real(key_e(alice,bob,sid_5),dhexp_real(key_m(bob),g))),minnonce,hash(hash(hash(hash(hash(somename,empty),empty),validkey(dhexp_real(key_s(bob),g))),validkey(dhexp_real(key_m(bob),g))),validkey(dhexp_real(key_e(alice,bob,sid_5),g))),validkey(dhexp_real(key_s(alice),g)))),validkey(dhexp_real(key_m(alice),g))))).

25. By 24, the attacker may know hash(hash(hash(hash(hash(hash(hash(somename,empty),empty),validkey(dhexp_real(key_s(bob),g))),validkey(dhexp_real(key_m(bob),g))),validkey(dhexp_real(key_e(alice,bob,sid_5),g))),encrypt(hmac_hash2(hmac_hash1(hash(somename,empty),dhexp_real(key_e(alice,bob,sid_5),dhexp_real(key_s(bob),g))),dhexp_real(key_e(alice,bob,sid_5),dhexp_real(key_m(bob),g))),minnonce,hash(hash(hash(hash(hash(somename,empty),empty),validkey(dhexp_real(key_s(bob),g))),validkey(dhexp_real(key_m(bob),g))),validkey(dhexp_real(key_e(alice,bob,sid_5),g))),validkey(dhexp_real(key_s(alice),g)))),encrypt(hmac_hash2(hmac_hash1(hash(somename,empty),dhexp_real(key_e(alice,bob,sid_5),dhexp_real(key_s(bob),g))),dhexp_real(key_e(alice,bob,sid_5),dhexp_real(key_m(bob),g))),increment_nonce(minnonce),hash(hash(hash(hash(hash(hash(somename,empty),empty),validkey(dhexp_real(key_s(bob),g))),validkey(dhexp_real(key_m(bob),g))),validkey(dhexp_real(key_e(alice,bob,sid_5),g))),encrypt(hmac_hash2(hmac_hash1(hash(somename,empty),dhexp_real(key_e(alice,bob,sid_5),dhexp_real(key_s(bob),g))),dhexp_real(key_e(alice,bob,sid_5),dhexp_real(key_m(bob),g))),minnonce,hash(hash(hash(hash(hash(somename,empty),empty),validkey(dhexp_real(key_s(bob),g))),validkey(dhexp_real(key_m(bob),g))),validkey(dhexp_real(key_e(alice,bob,sid_5),g))),validkey(dhexp_real(key_s(alice),g)))),validkey(dhexp_real(key_m(alice),g)))).
So the attacker may know hash(hash(hash(hash(hash(hash(hash(somename,empty),empty),validkey(dhexp_real(key_s(bob),g))),validkey(dhexp_real(key_m(bob),g))),validkey(dhexp_real(key_e(alice,bob,sid_5),g))),encrypt(hmac_hash2(hmac_hash1(hash(somename,empty),dhexp_real(key_e(alice,bob,sid_5),dhexp_real(key_s(bob),g))),dhexp_real(key_e(alice,bob,sid_5),dhexp_real(key_m(bob),g))),minnonce,hash(hash(hash(hash(hash(somename,empty),empty),validkey(dhexp_real(key_s(bob),g))),validkey(dhexp_real(key_m(bob),g))),validkey(dhexp_real(key_e(alice,bob,sid_5),g))),validkey(dhexp_real(key_s(alice),g)))),encrypt(hmac_hash2(hmac_hash1(hash(somename,empty),dhexp_real(key_e(alice,bob,sid_5),dhexp_real(key_s(bob),g))),dhexp_real(key_e(alice,bob,sid_5),dhexp_real(key_m(bob),g))),increment_nonce(minnonce),hash(hash(hash(hash(hash(hash(somename,empty),empty),validkey(dhexp_real(key_s(bob),g))),validkey(dhexp_real(key_m(bob),g))),validkey(dhexp_real(key_e(alice,bob,sid_5),g))),encrypt(hmac_hash2(hmac_hash1(hash(somename,empty),dhexp_real(key_e(alice,bob,sid_5),dhexp_real(key_s(bob),g))),dhexp_real(key_e(alice,bob,sid_5),dhexp_real(key_m(bob),g))),minnonce,hash(hash(hash(hash(hash(somename,empty),empty),validkey(dhexp_real(key_s(bob),g))),validkey(dhexp_real(key_m(bob),g))),validkey(dhexp_real(key_e(alice,bob,sid_5),g))),validkey(dhexp_real(key_s(alice),g)))),validkey(dhexp_real(key_m(alice),g)))) in phase 1.
attacker_p1(hash(hash(hash(hash(hash(hash(hash(somename,empty),empty),validkey(dhexp_real(key_s(bob),g))),validkey(dhexp_real(key_m(bob),g))),validkey(dhexp_real(key_e(alice,bob,sid_5),g))),encrypt(hmac_hash2(hmac_hash1(hash(somename,empty),dhexp_real(key_e(alice,bob,sid_5),dhexp_real(key_s(bob),g))),dhexp_real(key_e(alice,bob,sid_5),dhexp_real(key_m(bob),g))),minnonce,hash(hash(hash(hash(hash(somename,empty),empty),validkey(dhexp_real(key_s(bob),g))),validkey(dhexp_real(key_m(bob),g))),validkey(dhexp_real(key_e(alice,bob,sid_5),g))),validkey(dhexp_real(key_s(alice),g)))),encrypt(hmac_hash2(hmac_hash1(hash(somename,empty),dhexp_real(key_e(alice,bob,sid_5),dhexp_real(key_s(bob),g))),dhexp_real(key_e(alice,bob,sid_5),dhexp_real(key_m(bob),g))),increment_nonce(minnonce),hash(hash(hash(hash(hash(hash(somename,empty),empty),validkey(dhexp_real(key_s(bob),g))),validkey(dhexp_real(key_m(bob),g))),validkey(dhexp_real(key_e(alice,bob,sid_5),g))),encrypt(hmac_hash2(hmac_hash1(hash(somename,empty),dhexp_real(key_e(alice,bob,sid_5),dhexp_real(key_s(bob),g))),dhexp_real(key_e(alice,bob,sid_5),dhexp_real(key_m(bob),g))),minnonce,hash(hash(hash(hash(hash(somename,empty),empty),validkey(dhexp_real(key_s(bob),g))),validkey(dhexp_real(key_m(bob),g))),validkey(dhexp_real(key_e(alice,bob,sid_5),g))),validkey(dhexp_real(key_s(alice),g)))),validkey(dhexp_real(key_m(alice),g))))).

26. Using the function minnonce the attacker may obtain minnonce in phase 1.
attacker_p1(minnonce).

27. By 10, the attacker may know encrypt(hmac_hash2(hmac_hash1(hash(somename,empty),dhexp_real(key_e(alice,bob,sid_5),dhexp_real(key_s(bob),g))),dhexp_real(key_e(alice,bob,sid_5),dhexp_real(key_m(bob),g))),minnonce,hash(hash(hash(hash(hash(somename,empty),empty),validkey(dhexp_real(key_s(bob),g))),validkey(dhexp_real(key_m(bob),g))),validkey(dhexp_real(key_e(alice,bob,sid_5),g))),validkey(dhexp_real(key_s(alice),g))).
So the attacker may know encrypt(hmac_hash2(hmac_hash1(hash(somename,empty),dhexp_real(key_e(alice,bob,sid_5),dhexp_real(key_s(bob),g))),dhexp_real(key_e(alice,bob,sid_5),dhexp_real(key_m(bob),g))),minnonce,hash(hash(hash(hash(hash(somename,empty),empty),validkey(dhexp_real(key_s(bob),g))),validkey(dhexp_real(key_m(bob),g))),validkey(dhexp_real(key_e(alice,bob,sid_5),g))),validkey(dhexp_real(key_s(alice),g))) in phase 1.
attacker_p1(encrypt(hmac_hash2(hmac_hash1(hash(somename,empty),dhexp_real(key_e(alice,bob,sid_5),dhexp_real(key_s(bob),g))),dhexp_real(key_e(alice,bob,sid_5),dhexp_real(key_m(bob),g))),minnonce,hash(hash(hash(hash(hash(somename,empty),empty),validkey(dhexp_real(key_s(bob),g))),validkey(dhexp_real(key_m(bob),g))),validkey(dhexp_real(key_e(alice,bob,sid_5),g))),validkey(dhexp_real(key_s(alice),g)))).

28. By 22, the attacker may know hash(hash(hash(hash(hash(somename,empty),empty),validkey(dhexp_real(key_s(bob),g))),validkey(dhexp_real(key_m(bob),g))),validkey(dhexp_real(key_e(alice,bob,sid_5),g))).
So the attacker may know hash(hash(hash(hash(hash(somename,empty),empty),validkey(dhexp_real(key_s(bob),g))),validkey(dhexp_real(key_m(bob),g))),validkey(dhexp_real(key_e(alice,bob,sid_5),g))) in phase 1.
attacker_p1(hash(hash(hash(hash(hash(somename,empty),empty),validkey(dhexp_real(key_s(bob),g))),validkey(dhexp_real(key_m(bob),g))),validkey(dhexp_real(key_e(alice,bob,sid_5),g)))).

29. By 11, the attacker may know validkey(dhexp_real(key_e(alice,bob,sid_5),g)).
So the attacker may know validkey(dhexp_real(key_e(alice,bob,sid_5),g)) in phase 1.
attacker_p1(validkey(dhexp_real(key_e(alice,bob,sid_5),g))).

30. Using the function pub the attacker may obtain pub in phase 1.
attacker_p1(pub).

31. The event LeakS(phase1,bob) may be executed at {949}.
The event LeakM(phase1,bob) may be executed at {950}.
So the message (key_s(bob),key_m(bob)) may be sent on channel pub in phase 1 at output {951}.
mess_p1(pub,(key_s(bob),key_m(bob))).

32. By 30, the attacker may have the channel pub in phase 1.
By 31, the message (key_s(bob),key_m(bob)) in phase 1 may be sent on this channel.
So the attacker may obtain the message (key_s(bob),key_m(bob)) in phase 1 by listening on this channel.
attacker_p1((key_s(bob),key_m(bob))).

33. By 32, the attacker may know (key_s(bob),key_m(bob)) in phase 1.
Using the function 2-proj-2-tuple the attacker may obtain key_m(bob) in phase 1.
attacker_p1(key_m(bob)).

34. By 33, the attacker may know key_m(bob) in phase 1.
By 29, the attacker may know validkey(dhexp_real(key_e(alice,bob,sid_5),g)) in phase 1.
Using the function dhexp the attacker may obtain dhexp_real(key_e(alice,bob,sid_5),dhexp_real(key_m(bob),g)) in phase 1.
attacker_p1(dhexp_real(key_e(alice,bob,sid_5),dhexp_real(key_m(bob),g))).

35. By 32, the attacker may know (key_s(bob),key_m(bob)) in phase 1.
Using the function 1-proj-2-tuple the attacker may obtain key_s(bob) in phase 1.
attacker_p1(key_s(bob)).

36. By 35, the attacker may know key_s(bob) in phase 1.
By 29, the attacker may know validkey(dhexp_real(key_e(alice,bob,sid_5),g)) in phase 1.
Using the function dhexp the attacker may obtain dhexp_real(key_e(alice,bob,sid_5),dhexp_real(key_s(bob),g)) in phase 1.
attacker_p1(dhexp_real(key_e(alice,bob,sid_5),dhexp_real(key_s(bob),g))).

37. Using the function empty the attacker may obtain empty in phase 1.
attacker_p1(empty).

38. Using the function somename the attacker may obtain somename in phase 1.
attacker_p1(somename).

39. By 38, the attacker may know somename in phase 1.
By 37, the attacker may know empty in phase 1.
Using the function hash the attacker may obtain hash(somename,empty) in phase 1.
attacker_p1(hash(somename,empty)).

40. By 39, the attacker may know hash(somename,empty) in phase 1.
By 36, the attacker may know dhexp_real(key_e(alice,bob,sid_5),dhexp_real(key_s(bob),g)) in phase 1.
Using the function hmac_hash1 the attacker may obtain hmac_hash1(hash(somename,empty),dhexp_real(key_e(alice,bob,sid_5),dhexp_real(key_s(bob),g))) in phase 1.
attacker_p1(hmac_hash1(hash(somename,empty),dhexp_real(key_e(alice,bob,sid_5),dhexp_real(key_s(bob),g)))).

41. By 40, the attacker may know hmac_hash1(hash(somename,empty),dhexp_real(key_e(alice,bob,sid_5),dhexp_real(key_s(bob),g))) in phase 1.
By 34, the attacker may know dhexp_real(key_e(alice,bob,sid_5),dhexp_real(key_m(bob),g)) in phase 1.
Using the function hmac_hash2 the attacker may obtain hmac_hash2(hmac_hash1(hash(somename,empty),dhexp_real(key_e(alice,bob,sid_5),dhexp_real(key_s(bob),g))),dhexp_real(key_e(alice,bob,sid_5),dhexp_real(key_m(bob),g))) in phase 1.
attacker_p1(hmac_hash2(hmac_hash1(hash(somename,empty),dhexp_real(key_e(alice,bob,sid_5),dhexp_real(key_s(bob),g))),dhexp_real(key_e(alice,bob,sid_5),dhexp_real(key_m(bob),g)))).

42. By 41, the attacker may know hmac_hash2(hmac_hash1(hash(somename,empty),dhexp_real(key_e(alice,bob,sid_5),dhexp_real(key_s(bob),g))),dhexp_real(key_e(alice,bob,sid_5),dhexp_real(key_m(bob),g))) in phase 1.
By 26, the attacker may know minnonce in phase 1.
By 28, the attacker may know hash(hash(hash(hash(hash(somename,empty),empty),validkey(dhexp_real(key_s(bob),g))),validkey(dhexp_real(key_m(bob),g))),validkey(dhexp_real(key_e(alice,bob,sid_5),g))) in phase 1.
By 27, the attacker may know encrypt(hmac_hash2(hmac_hash1(hash(somename,empty),dhexp_real(key_e(alice,bob,sid_5),dhexp_real(key_s(bob),g))),dhexp_real(key_e(alice,bob,sid_5),dhexp_real(key_m(bob),g))),minnonce,hash(hash(hash(hash(hash(somename,empty),empty),validkey(dhexp_real(key_s(bob),g))),validkey(dhexp_real(key_m(bob),g))),validkey(dhexp_real(key_e(alice,bob,sid_5),g))),validkey(dhexp_real(key_s(alice),g))) in phase 1.
Using the function decrypt the attacker may obtain aeadpack(true,hash(hash(hash(hash(hash(somename,empty),empty),validkey(dhexp_real(key_s(bob),g))),validkey(dhexp_real(key_m(bob),g))),validkey(dhexp_real(key_e(alice,bob,sid_5),g))),validkey(dhexp_real(key_s(alice),g))) in phase 1.
attacker_p1(aeadpack(true,hash(hash(hash(hash(hash(somename,empty),empty),validkey(dhexp_real(key_s(bob),g))),validkey(dhexp_real(key_m(bob),g))),validkey(dhexp_real(key_e(alice,bob,sid_5),g))),validkey(dhexp_real(key_s(alice),g)))).

43. By 42, the attacker may know aeadpack(true,hash(hash(hash(hash(hash(somename,empty),empty),validkey(dhexp_real(key_s(bob),g))),validkey(dhexp_real(key_m(bob),g))),validkey(dhexp_real(key_e(alice,bob,sid_5),g))),validkey(dhexp_real(key_s(alice),g))) in phase 1.
Using the function 3-proj-aeadpack the attacker may obtain validkey(dhexp_real(key_s(alice),g)) in phase 1.
attacker_p1(validkey(dhexp_real(key_s(alice),g))).

44. By 33, the attacker may know key_m(bob) in phase 1.
By 43, the attacker may know validkey(dhexp_real(key_s(alice),g)) in phase 1.
Using the function dhexp the attacker may obtain dhexp_real(key_m(bob),dhexp_real(key_s(alice),g)) in phase 1.
attacker_p1(dhexp_real(key_m(bob),dhexp_real(key_s(alice),g))).

45. By 9, the attacker may know encrypt(hmac_hash2(hmac_hash1(hash(somename,empty),dhexp_real(key_e(alice,bob,sid_5),dhexp_real(key_s(bob),g))),dhexp_real(key_e(alice,bob,sid_5),dhexp_real(key_m(bob),g))),increment_nonce(minnonce),hash(hash(hash(hash(hash(hash(somename,empty),empty),validkey(dhexp_real(key_s(bob),g))),validkey(dhexp_real(key_m(bob),g))),validkey(dhexp_real(key_e(alice,bob,sid_5),g))),encrypt(hmac_hash2(hmac_hash1(hash(somename,empty),dhexp_real(key_e(alice,bob,sid_5),dhexp_real(key_s(bob),g))),dhexp_real(key_e(alice,bob,sid_5),dhexp_real(key_m(bob),g))),minnonce,hash(hash(hash(hash(hash(somename,empty),empty),validkey(dhexp_real(key_s(bob),g))),validkey(dhexp_real(key_m(bob),g))),validkey(dhexp_real(key_e(alice,bob,sid_5),g))),validkey(dhexp_real(key_s(alice),g)))),validkey(dhexp_real(key_m(alice),g))).
So the attacker may know encrypt(hmac_hash2(hmac_hash1(hash(somename,empty),dhexp_real(key_e(alice,bob,sid_5),dhexp_real(key_s(bob),g))),dhexp_real(key_e(alice,bob,sid_5),dhexp_real(key_m(bob),g))),increment_nonce(minnonce),hash(hash(hash(hash(hash(hash(somename,empty),empty),validkey(dhexp_real(key_s(bob),g))),validkey(dhexp_real(key_m(bob),g))),validkey(dhexp_real(key_e(alice,bob,sid_5),g))),encrypt(hmac_hash2(hmac_hash1(hash(somename,empty),dhexp_real(key_e(alice,bob,sid_5),dhexp_real(key_s(bob),g))),dhexp_real(key_e(alice,bob,sid_5),dhexp_real(key_m(bob),g))),minnonce,hash(hash(hash(hash(hash(somename,empty),empty),validkey(dhexp_real(key_s(bob),g))),validkey(dhexp_real(key_m(bob),g))),validkey(dhexp_real(key_e(alice,bob,sid_5),g))),validkey(dhexp_real(key_s(alice),g)))),validkey(dhexp_real(key_m(alice),g))) in phase 1.
attacker_p1(encrypt(hmac_hash2(hmac_hash1(hash(somename,empty),dhexp_real(key_e(alice,bob,sid_5),dhexp_real(key_s(bob),g))),dhexp_real(key_e(alice,bob,sid_5),dhexp_real(key_m(bob),g))),increment_nonce(minnonce),hash(hash(hash(hash(hash(hash(somename,empty),empty),validkey(dhexp_real(key_s(bob),g))),validkey(dhexp_real(key_m(bob),g))),validkey(dhexp_real(key_e(alice,bob,sid_5),g))),encrypt(hmac_hash2(hmac_hash1(hash(somename,empty),dhexp_real(key_e(alice,bob,sid_5),dhexp_real(key_s(bob),g))),dhexp_real(key_e(alice,bob,sid_5),dhexp_real(key_m(bob),g))),minnonce,hash(hash(hash(hash(hash(somename,empty),empty),validkey(dhexp_real(key_s(bob),g))),validkey(dhexp_real(key_m(bob),g))),validkey(dhexp_real(key_e(alice,bob,sid_5),g))),validkey(dhexp_real(key_s(alice),g)))),validkey(dhexp_real(key_m(alice),g)))).

46. By 23, the attacker may know hash(hash(hash(hash(hash(hash(somename,empty),empty),validkey(dhexp_real(key_s(bob),g))),validkey(dhexp_real(key_m(bob),g))),validkey(dhexp_real(key_e(alice,bob,sid_5),g))),encrypt(hmac_hash2(hmac_hash1(hash(somename,empty),dhexp_real(key_e(alice,bob,sid_5),dhexp_real(key_s(bob),g))),dhexp_real(key_e(alice,bob,sid_5),dhexp_real(key_m(bob),g))),minnonce,hash(hash(hash(hash(hash(somename,empty),empty),validkey(dhexp_real(key_s(bob),g))),validkey(dhexp_real(key_m(bob),g))),validkey(dhexp_real(key_e(alice,bob,sid_5),g))),validkey(dhexp_real(key_s(alice),g)))).
So the attacker may know hash(hash(hash(hash(hash(hash(somename,empty),empty),validkey(dhexp_real(key_s(bob),g))),validkey(dhexp_real(key_m(bob),g))),validkey(dhexp_real(key_e(alice,bob,sid_5),g))),encrypt(hmac_hash2(hmac_hash1(hash(somename,empty),dhexp_real(key_e(alice,bob,sid_5),dhexp_real(key_s(bob),g))),dhexp_real(key_e(alice,bob,sid_5),dhexp_real(key_m(bob),g))),minnonce,hash(hash(hash(hash(hash(somename,empty),empty),validkey(dhexp_real(key_s(bob),g))),validkey(dhexp_real(key_m(bob),g))),validkey(dhexp_real(key_e(alice,bob,sid_5),g))),validkey(dhexp_real(key_s(alice),g)))) in phase 1.
attacker_p1(hash(hash(hash(hash(hash(hash(somename,empty),empty),validkey(dhexp_real(key_s(bob),g))),validkey(dhexp_real(key_m(bob),g))),validkey(dhexp_real(key_e(alice,bob,sid_5),g))),encrypt(hmac_hash2(hmac_hash1(hash(somename,empty),dhexp_real(key_e(alice,bob,sid_5),dhexp_real(key_s(bob),g))),dhexp_real(key_e(alice,bob,sid_5),dhexp_real(key_m(bob),g))),minnonce,hash(hash(hash(hash(hash(somename,empty),empty),validkey(dhexp_real(key_s(bob),g))),validkey(dhexp_real(key_m(bob),g))),validkey(dhexp_real(key_e(alice,bob,sid_5),g))),validkey(dhexp_real(key_s(alice),g))))).

47. By 26, the attacker may know minnonce in phase 1.
Using the function increment_nonce the attacker may obtain increment_nonce(minnonce) in phase 1.
attacker_p1(increment_nonce(minnonce)).

48. By 41, the attacker may know hmac_hash2(hmac_hash1(hash(somename,empty),dhexp_real(key_e(alice,bob,sid_5),dhexp_real(key_s(bob),g))),dhexp_real(key_e(alice,bob,sid_5),dhexp_real(key_m(bob),g))) in phase 1.
By 47, the attacker may know increment_nonce(minnonce) in phase 1.
By 46, the attacker may know hash(hash(hash(hash(hash(hash(somename,empty),empty),validkey(dhexp_real(key_s(bob),g))),validkey(dhexp_real(key_m(bob),g))),validkey(dhexp_real(key_e(alice,bob,sid_5),g))),encrypt(hmac_hash2(hmac_hash1(hash(somename,empty),dhexp_real(key_e(alice,bob,sid_5),dhexp_real(key_s(bob),g))),dhexp_real(key_e(alice,bob,sid_5),dhexp_real(key_m(bob),g))),minnonce,hash(hash(hash(hash(hash(somename,empty),empty),validkey(dhexp_real(key_s(bob),g))),validkey(dhexp_real(key_m(bob),g))),validkey(dhexp_real(key_e(alice,bob,sid_5),g))),validkey(dhexp_real(key_s(alice),g)))) in phase 1.
By 45, the attacker may know encrypt(hmac_hash2(hmac_hash1(hash(somename,empty),dhexp_real(key_e(alice,bob,sid_5),dhexp_real(key_s(bob),g))),dhexp_real(key_e(alice,bob,sid_5),dhexp_real(key_m(bob),g))),increment_nonce(minnonce),hash(hash(hash(hash(hash(hash(somename,empty),empty),validkey(dhexp_real(key_s(bob),g))),validkey(dhexp_real(key_m(bob),g))),validkey(dhexp_real(key_e(alice,bob,sid_5),g))),encrypt(hmac_hash2(hmac_hash1(hash(somename,empty),dhexp_real(key_e(alice,bob,sid_5),dhexp_real(key_s(bob),g))),dhexp_real(key_e(alice,bob,sid_5),dhexp_real(key_m(bob),g))),minnonce,hash(hash(hash(hash(hash(somename,empty),empty),validkey(dhexp_real(key_s(bob),g))),validkey(dhexp_real(key_m(bob),g))),validkey(dhexp_real(key_e(alice,bob,sid_5),g))),validkey(dhexp_real(key_s(alice),g)))),validkey(dhexp_real(key_m(alice),g))) in phase 1.
Using the function decrypt the attacker may obtain aeadpack(true,hash(hash(hash(hash(hash(hash(somename,empty),empty),validkey(dhexp_real(key_s(bob),g))),validkey(dhexp_real(key_m(bob),g))),validkey(dhexp_real(key_e(alice,bob,sid_5),g))),encrypt(hmac_hash2(hmac_hash1(hash(somename,empty),dhexp_real(key_e(alice,bob,sid_5),dhexp_real(key_s(bob),g))),dhexp_real(key_e(alice,bob,sid_5),dhexp_real(key_m(bob),g))),minnonce,hash(hash(hash(hash(hash(somename,empty),empty),validkey(dhexp_real(key_s(bob),g))),validkey(dhexp_real(key_m(bob),g))),validkey(dhexp_real(key_e(alice,bob,sid_5),g))),validkey(dhexp_real(key_s(alice),g)))),validkey(dhexp_real(key_m(alice),g))) in phase 1.
attacker_p1(aeadpack(true,hash(hash(hash(hash(hash(hash(somename,empty),empty),validkey(dhexp_real(key_s(bob),g))),validkey(dhexp_real(key_m(bob),g))),validkey(dhexp_real(key_e(alice,bob,sid_5),g))),encrypt(hmac_hash2(hmac_hash1(hash(somename,empty),dhexp_real(key_e(alice,bob,sid_5),dhexp_real(key_s(bob),g))),dhexp_real(key_e(alice,bob,sid_5),dhexp_real(key_m(bob),g))),minnonce,hash(hash(hash(hash(hash(somename,empty),empty),validkey(dhexp_real(key_s(bob),g))),validkey(dhexp_real(key_m(bob),g))),validkey(dhexp_real(key_e(alice,bob,sid_5),g))),validkey(dhexp_real(key_s(alice),g)))),validkey(dhexp_real(key_m(alice),g)))).

49. By 48, the attacker may know aeadpack(true,hash(hash(hash(hash(hash(hash(somename,empty),empty),validkey(dhexp_real(key_s(bob),g))),validkey(dhexp_real(key_m(bob),g))),validkey(dhexp_real(key_e(alice,bob,sid_5),g))),encrypt(hmac_hash2(hmac_hash1(hash(somename,empty),dhexp_real(key_e(alice,bob,sid_5),dhexp_real(key_s(bob),g))),dhexp_real(key_e(alice,bob,sid_5),dhexp_real(key_m(bob),g))),minnonce,hash(hash(hash(hash(hash(somename,empty),empty),validkey(dhexp_real(key_s(bob),g))),validkey(dhexp_real(key_m(bob),g))),validkey(dhexp_real(key_e(alice,bob,sid_5),g))),validkey(dhexp_real(key_s(alice),g)))),validkey(dhexp_real(key_m(alice),g))) in phase 1.
Using the function 3-proj-aeadpack the attacker may obtain validkey(dhexp_real(key_m(alice),g)) in phase 1.
attacker_p1(validkey(dhexp_real(key_m(alice),g))).

50. By 35, the attacker may know key_s(bob) in phase 1.
By 49, the attacker may know validkey(dhexp_real(key_m(alice),g)) in phase 1.
Using the function dhexp the attacker may obtain dhexp_real(key_m(alice),dhexp_real(key_s(bob),g)) in phase 1.
attacker_p1(dhexp_real(key_m(alice),dhexp_real(key_s(bob),g))).

51. By 40, the attacker may know hmac_hash1(hash(somename,empty),dhexp_real(key_e(alice,bob,sid_5),dhexp_real(key_s(bob),g))) in phase 1.
By 34, the attacker may know dhexp_real(key_e(alice,bob,sid_5),dhexp_real(key_m(bob),g)) in phase 1.
Using the function hmac_hash1 the attacker may obtain hmac_hash1(hmac_hash1(hash(somename,empty),dhexp_real(key_e(alice,bob,sid_5),dhexp_real(key_s(bob),g))),dhexp_real(key_e(alice,bob,sid_5),dhexp_real(key_m(bob),g))) in phase 1.
attacker_p1(hmac_hash1(hmac_hash1(hash(somename,empty),dhexp_real(key_e(alice,bob,sid_5),dhexp_real(key_s(bob),g))),dhexp_real(key_e(alice,bob,sid_5),dhexp_real(key_m(bob),g)))).

52. By 51, the attacker may know hmac_hash1(hmac_hash1(hash(somename,empty),dhexp_real(key_e(alice,bob,sid_5),dhexp_real(key_s(bob),g))),dhexp_real(key_e(alice,bob,sid_5),dhexp_real(key_m(bob),g))) in phase 1.
By 50, the attacker may know dhexp_real(key_m(alice),dhexp_real(key_s(bob),g)) in phase 1.
Using the function hmac_hash1 the attacker may obtain hmac_hash1(hmac_hash1(hmac_hash1(hash(somename,empty),dhexp_real(key_e(alice,bob,sid_5),dhexp_real(key_s(bob),g))),dhexp_real(key_e(alice,bob,sid_5),dhexp_real(key_m(bob),g))),dhexp_real(key_m(alice),dhexp_real(key_s(bob),g))) in phase 1.
attacker_p1(hmac_hash1(hmac_hash1(hmac_hash1(hash(somename,empty),dhexp_real(key_e(alice,bob,sid_5),dhexp_real(key_s(bob),g))),dhexp_real(key_e(alice,bob,sid_5),dhexp_real(key_m(bob),g))),dhexp_real(key_m(alice),dhexp_real(key_s(bob),g)))).

53. By 52, the attacker may know hmac_hash1(hmac_hash1(hmac_hash1(hash(somename,empty),dhexp_real(key_e(alice,bob,sid_5),dhexp_real(key_s(bob),g))),dhexp_real(key_e(alice,bob,sid_5),dhexp_real(key_m(bob),g))),dhexp_real(key_m(alice),dhexp_real(key_s(bob),g))) in phase 1.
By 44, the attacker may know dhexp_real(key_m(bob),dhexp_real(key_s(alice),g)) in phase 1.
Using the function hmac_hash2 the attacker may obtain hmac_hash2(hmac_hash1(hmac_hash1(hmac_hash1(hash(somename,empty),dhexp_real(key_e(alice,bob,sid_5),dhexp_real(key_s(bob),g))),dhexp_real(key_e(alice,bob,sid_5),dhexp_real(key_m(bob),g))),dhexp_real(key_m(alice),dhexp_real(key_s(bob),g))),dhexp_real(key_m(bob),dhexp_real(key_s(alice),g))) in phase 1.
attacker_p1(hmac_hash2(hmac_hash1(hmac_hash1(hmac_hash1(hash(somename,empty),dhexp_real(key_e(alice,bob,sid_5),dhexp_real(key_s(bob),g))),dhexp_real(key_e(alice,bob,sid_5),dhexp_real(key_m(bob),g))),dhexp_real(key_m(alice),dhexp_real(key_s(bob),g))),dhexp_real(key_m(bob),dhexp_real(key_s(alice),g)))).

54. By 53, the attacker may know hmac_hash2(hmac_hash1(hmac_hash1(hmac_hash1(hash(somename,empty),dhexp_real(key_e(alice,bob,sid_5),dhexp_real(key_s(bob),g))),dhexp_real(key_e(alice,bob,sid_5),dhexp_real(key_m(bob),g))),dhexp_real(key_m(alice),dhexp_real(key_s(bob),g))),dhexp_real(key_m(bob),dhexp_real(key_s(alice),g))) in phase 1.
By 26, the attacker may know minnonce in phase 1.
By 25, the attacker may know hash(hash(hash(hash(hash(hash(hash(somename,empty),empty),validkey(dhexp_real(key_s(bob),g))),validkey(dhexp_real(key_m(bob),g))),validkey(dhexp_real(key_e(alice,bob,sid_5),g))),encrypt(hmac_hash2(hmac_hash1(hash(somename,empty),dhexp_real(key_e(alice,bob,sid_5),dhexp_real(key_s(bob),g))),dhexp_real(key_e(alice,bob,sid_5),dhexp_real(key_m(bob),g))),minnonce,hash(hash(hash(hash(hash(somename,empty),empty),validkey(dhexp_real(key_s(bob),g))),validkey(dhexp_real(key_m(bob),g))),validkey(dhexp_real(key_e(alice,bob,sid_5),g))),validkey(dhexp_real(key_s(alice),g)))),encrypt(hmac_hash2(hmac_hash1(hash(somename,empty),dhexp_real(key_e(alice,bob,sid_5),dhexp_real(key_s(bob),g))),dhexp_real(key_e(alice,bob,sid_5),dhexp_real(key_m(bob),g))),increment_nonce(minnonce),hash(hash(hash(hash(hash(hash(somename,empty),empty),validkey(dhexp_real(key_s(bob),g))),validkey(dhexp_real(key_m(bob),g))),validkey(dhexp_real(key_e(alice,bob,sid_5),g))),encrypt(hmac_hash2(hmac_hash1(hash(somename,empty),dhexp_real(key_e(alice,bob,sid_5),dhexp_real(key_s(bob),g))),dhexp_real(key_e(alice,bob,sid_5),dhexp_real(key_m(bob),g))),minnonce,hash(hash(hash(hash(hash(somename,empty),empty),validkey(dhexp_real(key_s(bob),g))),validkey(dhexp_real(key_m(bob),g))),validkey(dhexp_real(key_e(alice,bob,sid_5),g))),validkey(dhexp_real(key_s(alice),g)))),validkey(dhexp_real(key_m(alice),g)))) in phase 1.
By 6, the attacker may know encrypt(hmac_hash2(hmac_hash1(hmac_hash1(hmac_hash1(hash(somename,empty),dhexp_real(key_e(alice,bob,sid_5),dhexp_real(key_s(bob),g))),dhexp_real(key_e(alice,bob,sid_5),dhexp_real(key_m(bob),g))),dhexp_real(key_m(alice),dhexp_real(key_s(bob),g))),dhexp_real(key_m(bob),dhexp_real(key_s(alice),g))),minnonce,hash(hash(hash(hash(hash(hash(hash(somename,empty),empty),validkey(dhexp_real(key_s(bob),g))),validkey(dhexp_real(key_m(bob),g))),validkey(dhexp_real(key_e(alice,bob,sid_5),g))),encrypt(hmac_hash2(hmac_hash1(hash(somename,empty),dhexp_real(key_e(alice,bob,sid_5),dhexp_real(key_s(bob),g))),dhexp_real(key_e(alice,bob,sid_5),dhexp_real(key_m(bob),g))),minnonce,hash(hash(hash(hash(hash(somename,empty),empty),validkey(dhexp_real(key_s(bob),g))),validkey(dhexp_real(key_m(bob),g))),validkey(dhexp_real(key_e(alice,bob,sid_5),g))),validkey(dhexp_real(key_s(alice),g)))),encrypt(hmac_hash2(hmac_hash1(hash(somename,empty),dhexp_real(key_e(alice,bob,sid_5),dhexp_real(key_s(bob),g))),dhexp_real(key_e(alice,bob,sid_5),dhexp_real(key_m(bob),g))),increment_nonce(minnonce),hash(hash(hash(hash(hash(hash(somename,empty),empty),validkey(dhexp_real(key_s(bob),g))),validkey(dhexp_real(key_m(bob),g))),validkey(dhexp_real(key_e(alice,bob,sid_5),g))),encrypt(hmac_hash2(hmac_hash1(hash(somename,empty),dhexp_real(key_e(alice,bob,sid_5),dhexp_real(key_s(bob),g))),dhexp_real(key_e(alice,bob,sid_5),dhexp_real(key_m(bob),g))),minnonce,hash(hash(hash(hash(hash(somename,empty),empty),validkey(dhexp_real(key_s(bob),g))),validkey(dhexp_real(key_m(bob),g))),validkey(dhexp_real(key_e(alice,bob,sid_5),g))),validkey(dhexp_real(key_s(alice),g)))),validkey(dhexp_real(key_m(alice),g)))),msg_a(alice,bob,sid_5)) in phase 1.
Using the function decrypt the attacker may obtain aeadpack(true,hash(hash(hash(hash(hash(hash(hash(somename,empty),empty),validkey(dhexp_real(key_s(bob),g))),validkey(dhexp_real(key_m(bob),g))),validkey(dhexp_real(key_e(alice,bob,sid_5),g))),encrypt(hmac_hash2(hmac_hash1(hash(somename,empty),dhexp_real(key_e(alice,bob,sid_5),dhexp_real(key_s(bob),g))),dhexp_real(key_e(alice,bob,sid_5),dhexp_real(key_m(bob),g))),minnonce,hash(hash(hash(hash(hash(somename,empty),empty),validkey(dhexp_real(key_s(bob),g))),validkey(dhexp_real(key_m(bob),g))),validkey(dhexp_real(key_e(alice,bob,sid_5),g))),validkey(dhexp_real(key_s(alice),g)))),encrypt(hmac_hash2(hmac_hash1(hash(somename,empty),dhexp_real(key_e(alice,bob,sid_5),dhexp_real(key_s(bob),g))),dhexp_real(key_e(alice,bob,sid_5),dhexp_real(key_m(bob),g))),increment_nonce(minnonce),hash(hash(hash(hash(hash(hash(somename,empty),empty),validkey(dhexp_real(key_s(bob),g))),validkey(dhexp_real(key_m(bob),g))),validkey(dhexp_real(key_e(alice,bob,sid_5),g))),encrypt(hmac_hash2(hmac_hash1(hash(somename,empty),dhexp_real(key_e(alice,bob,sid_5),dhexp_real(key_s(bob),g))),dhexp_real(key_e(alice,bob,sid_5),dhexp_real(key_m(bob),g))),minnonce,hash(hash(hash(hash(hash(somename,empty),empty),validkey(dhexp_real(key_s(bob),g))),validkey(dhexp_real(key_m(bob),g))),validkey(dhexp_real(key_e(alice,bob,sid_5),g))),validkey(dhexp_real(key_s(alice),g)))),validkey(dhexp_real(key_m(alice),g)))),msg_a(alice,bob,sid_5)) in phase 1.
attacker_p1(aeadpack(true,hash(hash(hash(hash(hash(hash(hash(somename,empty),empty),validkey(dhexp_real(key_s(bob),g))),validkey(dhexp_real(key_m(bob),g))),validkey(dhexp_real(key_e(alice,bob,sid_5),g))),encrypt(hmac_hash2(hmac_hash1(hash(somename,empty),dhexp_real(key_e(alice,bob,sid_5),dhexp_real(key_s(bob),g))),dhexp_real(key_e(alice,bob,sid_5),dhexp_real(key_m(bob),g))),minnonce,hash(hash(hash(hash(hash(somename,empty),empty),validkey(dhexp_real(key_s(bob),g))),validkey(dhexp_real(key_m(bob),g))),validkey(dhexp_real(key_e(alice,bob,sid_5),g))),validkey(dhexp_real(key_s(alice),g)))),encrypt(hmac_hash2(hmac_hash1(hash(somename,empty),dhexp_real(key_e(alice,bob,sid_5),dhexp_real(key_s(bob),g))),dhexp_real(key_e(alice,bob,sid_5),dhexp_real(key_m(bob),g))),increment_nonce(minnonce),hash(hash(hash(hash(hash(hash(somename,empty),empty),validkey(dhexp_real(key_s(bob),g))),validkey(dhexp_real(key_m(bob),g))),validkey(dhexp_real(key_e(alice,bob,sid_5),g))),encrypt(hmac_hash2(hmac_hash1(hash(somename,empty),dhexp_real(key_e(alice,bob,sid_5),dhexp_real(key_s(bob),g))),dhexp_real(key_e(alice,bob,sid_5),dhexp_real(key_m(bob),g))),minnonce,hash(hash(hash(hash(hash(somename,empty),empty),validkey(dhexp_real(key_s(bob),g))),validkey(dhexp_real(key_m(bob),g))),validkey(dhexp_real(key_e(alice,bob,sid_5),g))),validkey(dhexp_real(key_s(alice),g)))),validkey(dhexp_real(key_m(alice),g)))),msg_a(alice,bob,sid_5))).

55. By 54, the attacker may know aeadpack(true,hash(hash(hash(hash(hash(hash(hash(somename,empty),empty),validkey(dhexp_real(key_s(bob),g))),validkey(dhexp_real(key_m(bob),g))),validkey(dhexp_real(key_e(alice,bob,sid_5),g))),encrypt(hmac_hash2(hmac_hash1(hash(somename,empty),dhexp_real(key_e(alice,bob,sid_5),dhexp_real(key_s(bob),g))),dhexp_real(key_e(alice,bob,sid_5),dhexp_real(key_m(bob),g))),minnonce,hash(hash(hash(hash(hash(somename,empty),empty),validkey(dhexp_real(key_s(bob),g))),validkey(dhexp_real(key_m(bob),g))),validkey(dhexp_real(key_e(alice,bob,sid_5),g))),validkey(dhexp_real(key_s(alice),g)))),encrypt(hmac_hash2(hmac_hash1(hash(somename,empty),dhexp_real(key_e(alice,bob,sid_5),dhexp_real(key_s(bob),g))),dhexp_real(key_e(alice,bob,sid_5),dhexp_real(key_m(bob),g))),increment_nonce(minnonce),hash(hash(hash(hash(hash(hash(somename,empty),empty),validkey(dhexp_real(key_s(bob),g))),validkey(dhexp_real(key_m(bob),g))),validkey(dhexp_real(key_e(alice,bob,sid_5),g))),encrypt(hmac_hash2(hmac_hash1(hash(somename,empty),dhexp_real(key_e(alice,bob,sid_5),dhexp_real(key_s(bob),g))),dhexp_real(key_e(alice,bob,sid_5),dhexp_real(key_m(bob),g))),minnonce,hash(hash(hash(hash(hash(somename,empty),empty),validkey(dhexp_real(key_s(bob),g))),validkey(dhexp_real(key_m(bob),g))),validkey(dhexp_real(key_e(alice,bob,sid_5),g))),validkey(dhexp_real(key_s(alice),g)))),validkey(dhexp_real(key_m(alice),g)))),msg_a(alice,bob,sid_5)) in phase 1.
Using the function 3-proj-aeadpack the attacker may obtain msg_a(alice,bob,sid_5) in phase 1.
attacker_p1(msg_a(alice,bob,sid_5)).

56. By 55, attacker_p1(msg_a(alice,bob,sid_5)).
The goal is reached, represented in the following fact:
attacker_p1(msg_a(alice,bob,sid_5)).


RESULT not attacker_p1(msg_a(alice,bob,sid_a)) cannot be proved.
Starting query attacker_p1(msg_a(alice,bob,sid_a)) ==> event(LeakS(px,bob)) && event(LeakM(px,bob))
goal reachable: begin(LeakM(phase1,bob)) && begin(LeakS(phase1,bob)) && begin(SendMsg(alice,bob,stagepack_a(sid_5),msg_a(alice,bob,sid_5))) -> attacker_p1(msg_a(alice,bob,sid_5))
Abbreviations:
sid_5 = sid[!1 = @sid]
goal reachable: begin(LeakM(phase0,bob)) && begin(LeakS(phase0,bob)) && begin(SendMsg(alice,bob,stagepack_a(sid_5),msg_a(alice,bob,sid_5))) -> attacker_p1(msg_a(alice,bob,sid_5))
Abbreviations:
sid_5 = sid[!1 = @sid]
RESULT attacker_p1(msg_a(alice,bob,sid_a)) ==> event(LeakS(px,bob)) && event(LeakM(px,bob)) is true.
Starting query attacker_p1(msg_a(alice,bob,sid_a)) ==> (event(LeakS(phase0,bob)) && event(LeakM(phase0,bob))) || (event(LeakS(px,bob)) && event(LeakM(px,bob)) && event(LeakS(pz,alice)) && event(LeakM(pz,alice)))
goal reachable: begin(LeakM(phase1,bob)) && begin(LeakS(phase1,bob)) && begin(SendMsg(alice,bob,stagepack_a(sid_5),msg_a(alice,bob,sid_5))) -> attacker_p1(msg_a(alice,bob,sid_5))
Abbreviations:
sid_5 = sid[!1 = @sid]

Derivation:
Abbreviations:
sid_5 = sid[!1 = @sid]

1. Using the function pub the attacker may obtain pub.
attacker(pub).

2. The entry statestore(alice,bob,sid_5,statepack_a(handshakestatepack(symmetricstatepack(cipherstatepack(empty,minnonce),hash(somename,empty),hash(hash(hash(hash(somename,empty),empty),validkey(dhexp_real(key_s(bob),g))),validkey(dhexp_real(key_m(bob),g)))),keypairpack(empty,empty),keypairpack(empty,empty),keypairpack(empty,empty),validkey(dhexp_real(key_s(bob),g)),validkey(dhexp_real(key_m(bob),g)),empty,empty,true))) may be inserted in a table at insert {50}.
table(statestore(alice,bob,sid_5,statepack_a(handshakestatepack(symmetricstatepack(cipherstatepack(empty,minnonce),hash(somename,empty),hash(hash(hash(hash(somename,empty),empty),validkey(dhexp_real(key_s(bob),g))),validkey(dhexp_real(key_m(bob),g)))),keypairpack(empty,empty),keypairpack(empty,empty),keypairpack(empty,empty),validkey(dhexp_real(key_s(bob),g)),validkey(dhexp_real(key_m(bob),g)),empty,empty,true)))).

3. The entry statestore(alice,bob,sid_5,statepack_a(handshakestatepack(symmetricstatepack(cipherstatepack(empty,minnonce),hash(somename,empty),hash(hash(hash(hash(somename,empty),empty),validkey(dhexp_real(key_s(bob),g))),validkey(dhexp_real(key_m(bob),g)))),keypairpack(empty,empty),keypairpack(empty,empty),keypairpack(empty,empty),validkey(dhexp_real(key_s(bob),g)),validkey(dhexp_real(key_m(bob),g)),empty,empty,true))) that may be in a table by 2 may be read at get {306}.
The event SendMsg(alice,bob,stagepack_a(sid_5),msg_a(alice,bob,sid_5)) may be executed at {304}.
So the message concat4(validkey(dhexp_real(key_e(alice,bob,sid_5),g)),encrypt(hmac_hash2(hmac_hash1(hash(somename,empty),dhexp_real(key_e(alice,bob,sid_5),dhexp_real(key_s(bob),g))),dhexp_real(key_e(alice,bob,sid_5),dhexp_real(key_m(bob),g))),minnonce,hash(hash(hash(hash(hash(somename,empty),empty),validkey(dhexp_real(key_s(bob),g))),validkey(dhexp_real(key_m(bob),g))),validkey(dhexp_real(key_e(alice,bob,sid_5),g))),validkey(dhexp_real(key_s(alice),g))),encrypt(hmac_hash2(hmac_hash1(hash(somename,empty),dhexp_real(key_e(alice,bob,sid_5),dhexp_real(key_s(bob),g))),dhexp_real(key_e(alice,bob,sid_5),dhexp_real(key_m(bob),g))),increment_nonce(minnonce),hash(hash(hash(hash(hash(hash(somename,empty),empty),validkey(dhexp_real(key_s(bob),g))),validkey(dhexp_real(key_m(bob),g))),validkey(dhexp_real(key_e(alice,bob,sid_5),g))),encrypt(hmac_hash2(hmac_hash1(hash(somename,empty),dhexp_real(key_e(alice,bob,sid_5),dhexp_real(key_s(bob),g))),dhexp_real(key_e(alice,bob,sid_5),dhexp_real(key_m(bob),g))),minnonce,hash(hash(hash(hash(hash(somename,empty),empty),validkey(dhexp_real(key_s(bob),g))),validkey(dhexp_real(key_m(bob),g))),validkey(dhexp_real(key_e(alice,bob,sid_5),g))),validkey(dhexp_real(key_s(alice),g)))),validkey(dhexp_real(key_m(alice),g))),encrypt(hmac_hash2(hmac_hash1(hmac_hash1(hmac_hash1(hash(somename,empty),dhexp_real(key_e(alice,bob,sid_5),dhexp_real(key_s(bob),g))),dhexp_real(key_e(alice,bob,sid_5),dhexp_real(key_m(bob),g))),dhexp_real(key_m(alice),dhexp_real(key_s(bob),g))),dhexp_real(key_m(bob),dhexp_real(key_s(alice),g))),minnonce,hash(hash(hash(hash(hash(hash(hash(somename,empty),empty),validkey(dhexp_real(key_s(bob),g))),validkey(dhexp_real(key_m(bob),g))),validkey(dhexp_real(key_e(alice,bob,sid_5),g))),encrypt(hmac_hash2(hmac_hash1(hash(somename,empty),dhexp_real(key_e(alice,bob,sid_5),dhexp_real(key_s(bob),g))),dhexp_real(key_e(alice,bob,sid_5),dhexp_real(key_m(bob),g))),minnonce,hash(hash(hash(hash(hash(somename,empty),empty),validkey(dhexp_real(key_s(bob),g))),validkey(dhexp_real(key_m(bob),g))),validkey(dhexp_real(key_e(alice,bob,sid_5),g))),validkey(dhexp_real(key_s(alice),g)))),encrypt(hmac_hash2(hmac_hash1(hash(somename,empty),dhexp_real(key_e(alice,bob,sid_5),dhexp_real(key_s(bob),g))),dhexp_real(key_e(alice,bob,sid_5),dhexp_real(key_m(bob),g))),increment_nonce(minnonce),hash(hash(hash(hash(hash(hash(somename,empty),empty),validkey(dhexp_real(key_s(bob),g))),validkey(dhexp_real(key_m(bob),g))),validkey(dhexp_real(key_e(alice,bob,sid_5),g))),encrypt(hmac_hash2(hmac_hash1(hash(somename,empty),dhexp_real(key_e(alice,bob,sid_5),dhexp_real(key_s(bob),g))),dhexp_real(key_e(alice,bob,sid_5),dhexp_real(key_m(bob),g))),minnonce,hash(hash(hash(hash(hash(somename,empty),empty),validkey(dhexp_real(key_s(bob),g))),validkey(dhexp_real(key_m(bob),g))),validkey(dhexp_real(key_e(alice,bob,sid_5),g))),validkey(dhexp_real(key_s(alice),g)))),validkey(dhexp_real(key_m(alice),g)))),msg_a(alice,bob,sid_5))) may be sent on channel pub at output {305}.
mess(pub,concat4(validkey(dhexp_real(key_e(alice,bob,sid_5),g)),encrypt(hmac_hash2(hmac_hash1(hash(somename,empty),dhexp_real(key_e(alice,bob,sid_5),dhexp_real(key_s(bob),g))),dhexp_real(key_e(alice,bob,sid_5),dhexp_real(key_m(bob),g))),minnonce,hash(hash(hash(hash(hash(somename,empty),empty),validkey(dhexp_real(key_s(bob),g))),validkey(dhexp_real(key_m(bob),g))),validkey(dhexp_real(key_e(alice,bob,sid_5),g))),validkey(dhexp_real(key_s(alice),g))),encrypt(hmac_hash2(hmac_hash1(hash(somename,empty),dhexp_real(key_e(alice,bob,sid_5),dhexp_real(key_s(bob),g))),dhexp_real(key_e(alice,bob,sid_5),dhexp_real(key_m(bob),g))),increment_nonce(minnonce),hash(hash(hash(hash(hash(hash(somename,empty),empty),validkey(dhexp_real(key_s(bob),g))),validkey(dhexp_real(key_m(bob),g))),validkey(dhexp_real(key_e(alice,bob,sid_5),g))),encrypt(hmac_hash2(hmac_hash1(hash(somename,empty),dhexp_real(key_e(alice,bob,sid_5),dhexp_real(key_s(bob),g))),dhexp_real(key_e(alice,bob,sid_5),dhexp_real(key_m(bob),g))),minnonce,hash(hash(hash(hash(hash(somename,empty),empty),validkey(dhexp_real(key_s(bob),g))),validkey(dhexp_real(key_m(bob),g))),validkey(dhexp_real(key_e(alice,bob,sid_5),g))),validkey(dhexp_real(key_s(alice),g)))),validkey(dhexp_real(key_m(alice),g))),encrypt(hmac_hash2(hmac_hash1(hmac_hash1(hmac_hash1(hash(somename,empty),dhexp_real(key_e(alice,bob,sid_5),dhexp_real(key_s(bob),g))),dhexp_real(key_e(alice,bob,sid_5),dhexp_real(key_m(bob),g))),dhexp_real(key_m(alice),dhexp_real(key_s(bob),g))),dhexp_real(key_m(bob),dhexp_real(key_s(alice),g))),minnonce,hash(hash(hash(hash(hash(hash(hash(somename,empty),empty),validkey(dhexp_real(key_s(bob),g))),validkey(dhexp_real(key_m(bob),g))),validkey(dhexp_real(key_e(alice,bob,sid_5),g))),encrypt(hmac_hash2(hmac_hash1(hash(somename,empty),dhexp_real(key_e(alice,bob,sid_5),dhexp_real(key_s(bob),g))),dhexp_real(key_e(alice,bob,sid_5),dhexp_real(key_m(bob),g))),minnonce,hash(hash(hash(hash(hash(somename,empty),empty),validkey(dhexp_real(key_s(bob),g))),validkey(dhexp_real(key_m(bob),g))),validkey(dhexp_real(key_e(alice,bob,sid_5),g))),validkey(dhexp_real(key_s(alice),g)))),encrypt(hmac_hash2(hmac_hash1(hash(somename,empty),dhexp_real(key_e(alice,bob,sid_5),dhexp_real(key_s(bob),g))),dhexp_real(key_e(alice,bob,sid_5),dhexp_real(key_m(bob),g))),increment_nonce(minnonce),hash(hash(hash(hash(hash(hash(somename,empty),empty),validkey(dhexp_real(key_s(bob),g))),validkey(dhexp_real(key_m(bob),g))),validkey(dhexp_real(key_e(alice,bob,sid_5),g))),encrypt(hmac_hash2(hmac_hash1(hash(somename,empty),dhexp_real(key_e(alice,bob,sid_5),dhexp_real(key_s(bob),g))),dhexp_real(key_e(alice,bob,sid_5),dhexp_real(key_m(bob),g))),minnonce,hash(hash(hash(hash(hash(somename,empty),empty),validkey(dhexp_real(key_s(bob),g))),validkey(dhexp_real(key_m(bob),g))),validkey(dhexp_real(key_e(alice,bob,sid_5),g))),validkey(dhexp_real(key_s(alice),g)))),validkey(dhexp_real(key_m(alice),g)))),msg_a(alice,bob,sid_5)))).

4. By 1, the attacker may have the channel pub.
By 3, the message concat4(validkey(dhexp_real(key_e(alice,bob,sid_5),g)),encrypt(hmac_hash2(hmac_hash1(hash(somename,empty),dhexp_real(key_e(alice,bob,sid_5),dhexp_real(key_s(bob),g))),dhexp_real(key_e(alice,bob,sid_5),dhexp_real(key_m(bob),g))),minnonce,hash(hash(hash(hash(hash(somename,empty),empty),validkey(dhexp_real(key_s(bob),g))),validkey(dhexp_real(key_m(bob),g))),validkey(dhexp_real(key_e(alice,bob,sid_5),g))),validkey(dhexp_real(key_s(alice),g))),encrypt(hmac_hash2(hmac_hash1(hash(somename,empty),dhexp_real(key_e(alice,bob,sid_5),dhexp_real(key_s(bob),g))),dhexp_real(key_e(alice,bob,sid_5),dhexp_real(key_m(bob),g))),increment_nonce(minnonce),hash(hash(hash(hash(hash(hash(somename,empty),empty),validkey(dhexp_real(key_s(bob),g))),validkey(dhexp_real(key_m(bob),g))),validkey(dhexp_real(key_e(alice,bob,sid_5),g))),encrypt(hmac_hash2(hmac_hash1(hash(somename,empty),dhexp_real(key_e(alice,bob,sid_5),dhexp_real(key_s(bob),g))),dhexp_real(key_e(alice,bob,sid_5),dhexp_real(key_m(bob),g))),minnonce,hash(hash(hash(hash(hash(somename,empty),empty),validkey(dhexp_real(key_s(bob),g))),validkey(dhexp_real(key_m(bob),g))),validkey(dhexp_real(key_e(alice,bob,sid_5),g))),validkey(dhexp_real(key_s(alice),g)))),validkey(dhexp_real(key_m(alice),g))),encrypt(hmac_hash2(hmac_hash1(hmac_hash1(hmac_hash1(hash(somename,empty),dhexp_real(key_e(alice,bob,sid_5),dhexp_real(key_s(bob),g))),dhexp_real(key_e(alice,bob,sid_5),dhexp_real(key_m(bob),g))),dhexp_real(key_m(alice),dhexp_real(key_s(bob),g))),dhexp_real(key_m(bob),dhexp_real(key_s(alice),g))),minnonce,hash(hash(hash(hash(hash(hash(hash(somename,empty),empty),validkey(dhexp_real(key_s(bob),g))),validkey(dhexp_real(key_m(bob),g))),validkey(dhexp_real(key_e(alice,bob,sid_5),g))),encrypt(hmac_hash2(hmac_hash1(hash(somename,empty),dhexp_real(key_e(alice,bob,sid_5),dhexp_real(key_s(bob),g))),dhexp_real(key_e(alice,bob,sid_5),dhexp_real(key_m(bob),g))),minnonce,hash(hash(hash(hash(hash(somename,empty),empty),validkey(dhexp_real(key_s(bob),g))),validkey(dhexp_real(key_m(bob),g))),validkey(dhexp_real(key_e(alice,bob,sid_5),g))),validkey(dhexp_real(key_s(alice),g)))),encrypt(hmac_hash2(hmac_hash1(hash(somename,empty),dhexp_real(key_e(alice,bob,sid_5),dhexp_real(key_s(bob),g))),dhexp_real(key_e(alice,bob,sid_5),dhexp_real(key_m(bob),g))),increment_nonce(minnonce),hash(hash(hash(hash(hash(hash(somename,empty),empty),validkey(dhexp_real(key_s(bob),g))),validkey(dhexp_real(key_m(bob),g))),validkey(dhexp_real(key_e(alice,bob,sid_5),g))),encrypt(hmac_hash2(hmac_hash1(hash(somename,empty),dhexp_real(key_e(alice,bob,sid_5),dhexp_real(key_s(bob),g))),dhexp_real(key_e(alice,bob,sid_5),dhexp_real(key_m(bob),g))),minnonce,hash(hash(hash(hash(hash(somename,empty),empty),validkey(dhexp_real(key_s(bob),g))),validkey(dhexp_real(key_m(bob),g))),validkey(dhexp_real(key_e(alice,bob,sid_5),g))),validkey(dhexp_real(key_s(alice),g)))),validkey(dhexp_real(key_m(alice),g)))),msg_a(alice,bob,sid_5))) may be sent on this channel.
So the attacker may obtain the message concat4(validkey(dhexp_real(key_e(alice,bob,sid_5),g)),encrypt(hmac_hash2(hmac_hash1(hash(somename,empty),dhexp_real(key_e(alice,bob,sid_5),dhexp_real(key_s(bob),g))),dhexp_real(key_e(alice,bob,sid_5),dhexp_real(key_m(bob),g))),minnonce,hash(hash(hash(hash(hash(somename,empty),empty),validkey(dhexp_real(key_s(bob),g))),validkey(dhexp_real(key_m(bob),g))),validkey(dhexp_real(key_e(alice,bob,sid_5),g))),validkey(dhexp_real(key_s(alice),g))),encrypt(hmac_hash2(hmac_hash1(hash(somename,empty),dhexp_real(key_e(alice,bob,sid_5),dhexp_real(key_s(bob),g))),dhexp_real(key_e(alice,bob,sid_5),dhexp_real(key_m(bob),g))),increment_nonce(minnonce),hash(hash(hash(hash(hash(hash(somename,empty),empty),validkey(dhexp_real(key_s(bob),g))),validkey(dhexp_real(key_m(bob),g))),validkey(dhexp_real(key_e(alice,bob,sid_5),g))),encrypt(hmac_hash2(hmac_hash1(hash(somename,empty),dhexp_real(key_e(alice,bob,sid_5),dhexp_real(key_s(bob),g))),dhexp_real(key_e(alice,bob,sid_5),dhexp_real(key_m(bob),g))),minnonce,hash(hash(hash(hash(hash(somename,empty),empty),validkey(dhexp_real(key_s(bob),g))),validkey(dhexp_real(key_m(bob),g))),validkey(dhexp_real(key_e(alice,bob,sid_5),g))),validkey(dhexp_real(key_s(alice),g)))),validkey(dhexp_real(key_m(alice),g))),encrypt(hmac_hash2(hmac_hash1(hmac_hash1(hmac_hash1(hash(somename,empty),dhexp_real(key_e(alice,bob,sid_5),dhexp_real(key_s(bob),g))),dhexp_real(key_e(alice,bob,sid_5),dhexp_real(key_m(bob),g))),dhexp_real(key_m(alice),dhexp_real(key_s(bob),g))),dhexp_real(key_m(bob),dhexp_real(key_s(alice),g))),minnonce,hash(hash(hash(hash(hash(hash(hash(somename,empty),empty),validkey(dhexp_real(key_s(bob),g))),validkey(dhexp_real(key_m(bob),g))),validkey(dhexp_real(key_e(alice,bob,sid_5),g))),encrypt(hmac_hash2(hmac_hash1(hash(somename,empty),dhexp_real(key_e(alice,bob,sid_5),dhexp_real(key_s(bob),g))),dhexp_real(key_e(alice,bob,sid_5),dhexp_real(key_m(bob),g))),minnonce,hash(hash(hash(hash(hash(somename,empty),empty),validkey(dhexp_real(key_s(bob),g))),validkey(dhexp_real(key_m(bob),g))),validkey(dhexp_real(key_e(alice,bob,sid_5),g))),validkey(dhexp_real(key_s(alice),g)))),encrypt(hmac_hash2(hmac_hash1(hash(somename,empty),dhexp_real(key_e(alice,bob,sid_5),dhexp_real(key_s(bob),g))),dhexp_real(key_e(alice,bob,sid_5),dhexp_real(key_m(bob),g))),increment_nonce(minnonce),hash(hash(hash(hash(hash(hash(somename,empty),empty),validkey(dhexp_real(key_s(bob),g))),validkey(dhexp_real(key_m(bob),g))),validkey(dhexp_real(key_e(alice,bob,sid_5),g))),encrypt(hmac_hash2(hmac_hash1(hash(somename,empty),dhexp_real(key_e(alice,bob,sid_5),dhexp_real(key_s(bob),g))),dhexp_real(key_e(alice,bob,sid_5),dhexp_real(key_m(bob),g))),minnonce,hash(hash(hash(hash(hash(somename,empty),empty),validkey(dhexp_real(key_s(bob),g))),validkey(dhexp_real(key_m(bob),g))),validkey(dhexp_real(key_e(alice,bob,sid_5),g))),validkey(dhexp_real(key_s(alice),g)))),validkey(dhexp_real(key_m(alice),g)))),msg_a(alice,bob,sid_5))) by listening on this channel.
attacker(concat4(validkey(dhexp_real(key_e(alice,bob,sid_5),g)),encrypt(hmac_hash2(hmac_hash1(hash(somename,empty),dhexp_real(key_e(alice,bob,sid_5),dhexp_real(key_s(bob),g))),dhexp_real(key_e(alice,bob,sid_5),dhexp_real(key_m(bob),g))),minnonce,hash(hash(hash(hash(hash(somename,empty),empty),validkey(dhexp_real(key_s(bob),g))),validkey(dhexp_real(key_m(bob),g))),validkey(dhexp_real(key_e(alice,bob,sid_5),g))),validkey(dhexp_real(key_s(alice),g))),encrypt(hmac_hash2(hmac_hash1(hash(somename,empty),dhexp_real(key_e(alice,bob,sid_5),dhexp_real(key_s(bob),g))),dhexp_real(key_e(alice,bob,sid_5),dhexp_real(key_m(bob),g))),increment_nonce(minnonce),hash(hash(hash(hash(hash(hash(somename,empty),empty),validkey(dhexp_real(key_s(bob),g))),validkey(dhexp_real(key_m(bob),g))),validkey(dhexp_real(key_e(alice,bob,sid_5),g))),encrypt(hmac_hash2(hmac_hash1(hash(somename,empty),dhexp_real(key_e(alice,bob,sid_5),dhexp_real(key_s(bob),g))),dhexp_real(key_e(alice,bob,sid_5),dhexp_real(key_m(bob),g))),minnonce,hash(hash(hash(hash(hash(somename,empty),empty),validkey(dhexp_real(key_s(bob),g))),validkey(dhexp_real(key_m(bob),g))),validkey(dhexp_real(key_e(alice,bob,sid_5),g))),validkey(dhexp_real(key_s(alice),g)))),validkey(dhexp_real(key_m(alice),g))),encrypt(hmac_hash2(hmac_hash1(hmac_hash1(hmac_hash1(hash(somename,empty),dhexp_real(key_e(alice,bob,sid_5),dhexp_real(key_s(bob),g))),dhexp_real(key_e(alice,bob,sid_5),dhexp_real(key_m(bob),g))),dhexp_real(key_m(alice),dhexp_real(key_s(bob),g))),dhexp_real(key_m(bob),dhexp_real(key_s(alice),g))),minnonce,hash(hash(hash(hash(hash(hash(hash(somename,empty),empty),validkey(dhexp_real(key_s(bob),g))),validkey(dhexp_real(key_m(bob),g))),validkey(dhexp_real(key_e(alice,bob,sid_5),g))),encrypt(hmac_hash2(hmac_hash1(hash(somename,empty),dhexp_real(key_e(alice,bob,sid_5),dhexp_real(key_s(bob),g))),dhexp_real(key_e(alice,bob,sid_5),dhexp_real(key_m(bob),g))),minnonce,hash(hash(hash(hash(hash(somename,empty),empty),validkey(dhexp_real(key_s(bob),g))),validkey(dhexp_real(key_m(bob),g))),validkey(dhexp_real(key_e(alice,bob,sid_5),g))),validkey(dhexp_real(key_s(alice),g)))),encrypt(hmac_hash2(hmac_hash1(hash(somename,empty),dhexp_real(key_e(alice,bob,sid_5),dhexp_real(key_s(bob),g))),dhexp_real(key_e(alice,bob,sid_5),dhexp_real(key_m(bob),g))),increment_nonce(minnonce),hash(hash(hash(hash(hash(hash(somename,empty),empty),validkey(dhexp_real(key_s(bob),g))),validkey(dhexp_real(key_m(bob),g))),validkey(dhexp_real(key_e(alice,bob,sid_5),g))),encrypt(hmac_hash2(hmac_hash1(hash(somename,empty),dhexp_real(key_e(alice,bob,sid_5),dhexp_real(key_s(bob),g))),dhexp_real(key_e(alice,bob,sid_5),dhexp_real(key_m(bob),g))),minnonce,hash(hash(hash(hash(hash(somename,empty),empty),validkey(dhexp_real(key_s(bob),g))),validkey(dhexp_real(key_m(bob),g))),validkey(dhexp_real(key_e(alice,bob,sid_5),g))),validkey(dhexp_real(key_s(alice),g)))),validkey(dhexp_real(key_m(alice),g)))),msg_a(alice,bob,sid_5)))).

5. By 4, the attacker may know concat4(validkey(dhexp_real(key_e(alice,bob,sid_5),g)),encrypt(hmac_hash2(hmac_hash1(hash(somename,empty),dhexp_real(key_e(alice,bob,sid_5),dhexp_real(key_s(bob),g))),dhexp_real(key_e(alice,bob,sid_5),dhexp_real(key_m(bob),g))),minnonce,hash(hash(hash(hash(hash(somename,empty),empty),validkey(dhexp_real(key_s(bob),g))),validkey(dhexp_real(key_m(bob),g))),validkey(dhexp_real(key_e(alice,bob,sid_5),g))),validkey(dhexp_real(key_s(alice),g))),encrypt(hmac_hash2(hmac_hash1(hash(somename,empty),dhexp_real(key_e(alice,bob,sid_5),dhexp_real(key_s(bob),g))),dhexp_real(key_e(alice,bob,sid_5),dhexp_real(key_m(bob),g))),increment_nonce(minnonce),hash(hash(hash(hash(hash(hash(somename,empty),empty),validkey(dhexp_real(key_s(bob),g))),validkey(dhexp_real(key_m(bob),g))),validkey(dhexp_real(key_e(alice,bob,sid_5),g))),encrypt(hmac_hash2(hmac_hash1(hash(somename,empty),dhexp_real(key_e(alice,bob,sid_5),dhexp_real(key_s(bob),g))),dhexp_real(key_e(alice,bob,sid_5),dhexp_real(key_m(bob),g))),minnonce,hash(hash(hash(hash(hash(somename,empty),empty),validkey(dhexp_real(key_s(bob),g))),validkey(dhexp_real(key_m(bob),g))),validkey(dhexp_real(key_e(alice,bob,sid_5),g))),validkey(dhexp_real(key_s(alice),g)))),validkey(dhexp_real(key_m(alice),g))),encrypt(hmac_hash2(hmac_hash1(hmac_hash1(hmac_hash1(hash(somename,empty),dhexp_real(key_e(alice,bob,sid_5),dhexp_real(key_s(bob),g))),dhexp_real(key_e(alice,bob,sid_5),dhexp_real(key_m(bob),g))),dhexp_real(key_m(alice),dhexp_real(key_s(bob),g))),dhexp_real(key_m(bob),dhexp_real(key_s(alice),g))),minnonce,hash(hash(hash(hash(hash(hash(hash(somename,empty),empty),validkey(dhexp_real(key_s(bob),g))),validkey(dhexp_real(key_m(bob),g))),validkey(dhexp_real(key_e(alice,bob,sid_5),g))),encrypt(hmac_hash2(hmac_hash1(hash(somename,empty),dhexp_real(key_e(alice,bob,sid_5),dhexp_real(key_s(bob),g))),dhexp_real(key_e(alice,bob,sid_5),dhexp_real(key_m(bob),g))),minnonce,hash(hash(hash(hash(hash(somename,empty),empty),validkey(dhexp_real(key_s(bob),g))),validkey(dhexp_real(key_m(bob),g))),validkey(dhexp_real(key_e(alice,bob,sid_5),g))),validkey(dhexp_real(key_s(alice),g)))),encrypt(hmac_hash2(hmac_hash1(hash(somename,empty),dhexp_real(key_e(alice,bob,sid_5),dhexp_real(key_s(bob),g))),dhexp_real(key_e(alice,bob,sid_5),dhexp_real(key_m(bob),g))),increment_nonce(minnonce),hash(hash(hash(hash(hash(hash(somename,empty),empty),validkey(dhexp_real(key_s(bob),g))),validkey(dhexp_real(key_m(bob),g))),validkey(dhexp_real(key_e(alice,bob,sid_5),g))),encrypt(hmac_hash2(hmac_hash1(hash(somename,empty),dhexp_real(key_e(alice,bob,sid_5),dhexp_real(key_s(bob),g))),dhexp_real(key_e(alice,bob,sid_5),dhexp_real(key_m(bob),g))),minnonce,hash(hash(hash(hash(hash(somename,empty),empty),validkey(dhexp_real(key_s(bob),g))),validkey(dhexp_real(key_m(bob),g))),validkey(dhexp_real(key_e(alice,bob,sid_5),g))),validkey(dhexp_real(key_s(alice),g)))),validkey(dhexp_real(key_m(alice),g)))),msg_a(alice,bob,sid_5))).
Using the function 4-proj-concat4 the attacker may obtain encrypt(hmac_hash2(hmac_hash1(hmac_hash1(hmac_hash1(hash(somename,empty),dhexp_real(key_e(alice,bob,sid_5),dhexp_real(key_s(bob),g))),dhexp_real(key_e(alice,bob,sid_5),dhexp_real(key_m(bob),g))),dhexp_real(key_m(alice),dhexp_real(key_s(bob),g))),dhexp_real(key_m(bob),dhexp_real(key_s(alice),g))),minnonce,hash(hash(hash(hash(hash(hash(hash(somename,empty),empty),validkey(dhexp_real(key_s(bob),g))),validkey(dhexp_real(key_m(bob),g))),validkey(dhexp_real(key_e(alice,bob,sid_5),g))),encrypt(hmac_hash2(hmac_hash1(hash(somename,empty),dhexp_real(key_e(alice,bob,sid_5),dhexp_real(key_s(bob),g))),dhexp_real(key_e(alice,bob,sid_5),dhexp_real(key_m(bob),g))),minnonce,hash(hash(hash(hash(hash(somename,empty),empty),validkey(dhexp_real(key_s(bob),g))),validkey(dhexp_real(key_m(bob),g))),validkey(dhexp_real(key_e(alice,bob,sid_5),g))),validkey(dhexp_real(key_s(alice),g)))),encrypt(hmac_hash2(hmac_hash1(hash(somename,empty),dhexp_real(key_e(alice,bob,sid_5),dhexp_real(key_s(bob),g))),dhexp_real(key_e(alice,bob,sid_5),dhexp_real(key_m(bob),g))),increment_nonce(minnonce),hash(hash(hash(hash(hash(hash(somename,empty),empty),validkey(dhexp_real(key_s(bob),g))),validkey(dhexp_real(key_m(bob),g))),validkey(dhexp_real(key_e(alice,bob,sid_5),g))),encrypt(hmac_hash2(hmac_hash1(hash(somename,empty),dhexp_real(key_e(alice,bob,sid_5),dhexp_real(key_s(bob),g))),dhexp_real(key_e(alice,bob,sid_5),dhexp_real(key_m(bob),g))),minnonce,hash(hash(hash(hash(hash(somename,empty),empty),validkey(dhexp_real(key_s(bob),g))),validkey(dhexp_real(key_m(bob),g))),validkey(dhexp_real(key_e(alice,bob,sid_5),g))),validkey(dhexp_real(key_s(alice),g)))),validkey(dhexp_real(key_m(alice),g)))),msg_a(alice,bob,sid_5)).
attacker(encrypt(hmac_hash2(hmac_hash1(hmac_hash1(hmac_hash1(hash(somename,empty),dhexp_real(key_e(alice,bob,sid_5),dhexp_real(key_s(bob),g))),dhexp_real(key_e(alice,bob,sid_5),dhexp_real(key_m(bob),g))),dhexp_real(key_m(alice),dhexp_real(key_s(bob),g))),dhexp_real(key_m(bob),dhexp_real(key_s(alice),g))),minnonce,hash(hash(hash(hash(hash(hash(hash(somename,empty),empty),validkey(dhexp_real(key_s(bob),g))),validkey(dhexp_real(key_m(bob),g))),validkey(dhexp_real(key_e(alice,bob,sid_5),g))),encrypt(hmac_hash2(hmac_hash1(hash(somename,empty),dhexp_real(key_e(alice,bob,sid_5),dhexp_real(key_s(bob),g))),dhexp_real(key_e(alice,bob,sid_5),dhexp_real(key_m(bob),g))),minnonce,hash(hash(hash(hash(hash(somename,empty),empty),validkey(dhexp_real(key_s(bob),g))),validkey(dhexp_real(key_m(bob),g))),validkey(dhexp_real(key_e(alice,bob,sid_5),g))),validkey(dhexp_real(key_s(alice),g)))),encrypt(hmac_hash2(hmac_hash1(hash(somename,empty),dhexp_real(key_e(alice,bob,sid_5),dhexp_real(key_s(bob),g))),dhexp_real(key_e(alice,bob,sid_5),dhexp_real(key_m(bob),g))),increment_nonce(minnonce),hash(hash(hash(hash(hash(hash(somename,empty),empty),validkey(dhexp_real(key_s(bob),g))),validkey(dhexp_real(key_m(bob),g))),validkey(dhexp_real(key_e(alice,bob,sid_5),g))),encrypt(hmac_hash2(hmac_hash1(hash(somename,empty),dhexp_real(key_e(alice,bob,sid_5),dhexp_real(key_s(bob),g))),dhexp_real(key_e(alice,bob,sid_5),dhexp_real(key_m(bob),g))),minnonce,hash(hash(hash(hash(hash(somename,empty),empty),validkey(dhexp_real(key_s(bob),g))),validkey(dhexp_real(key_m(bob),g))),validkey(dhexp_real(key_e(alice,bob,sid_5),g))),validkey(dhexp_real(key_s(alice),g)))),validkey(dhexp_real(key_m(alice),g)))),msg_a(alice,bob,sid_5))).

6. By 5, the attacker may know encrypt(hmac_hash2(hmac_hash1(hmac_hash1(hmac_hash1(hash(somename,empty),dhexp_real(key_e(alice,bob,sid_5),dhexp_real(key_s(bob),g))),dhexp_real(key_e(alice,bob,sid_5),dhexp_real(key_m(bob),g))),dhexp_real(key_m(alice),dhexp_real(key_s(bob),g))),dhexp_real(key_m(bob),dhexp_real(key_s(alice),g))),minnonce,hash(hash(hash(hash(hash(hash(hash(somename,empty),empty),validkey(dhexp_real(key_s(bob),g))),validkey(dhexp_real(key_m(bob),g))),validkey(dhexp_real(key_e(alice,bob,sid_5),g))),encrypt(hmac_hash2(hmac_hash1(hash(somename,empty),dhexp_real(key_e(alice,bob,sid_5),dhexp_real(key_s(bob),g))),dhexp_real(key_e(alice,bob,sid_5),dhexp_real(key_m(bob),g))),minnonce,hash(hash(hash(hash(hash(somename,empty),empty),validkey(dhexp_real(key_s(bob),g))),validkey(dhexp_real(key_m(bob),g))),validkey(dhexp_real(key_e(alice,bob,sid_5),g))),validkey(dhexp_real(key_s(alice),g)))),encrypt(hmac_hash2(hmac_hash1(hash(somename,empty),dhexp_real(key_e(alice,bob,sid_5),dhexp_real(key_s(bob),g))),dhexp_real(key_e(alice,bob,sid_5),dhexp_real(key_m(bob),g))),increment_nonce(minnonce),hash(hash(hash(hash(hash(hash(somename,empty),empty),validkey(dhexp_real(key_s(bob),g))),validkey(dhexp_real(key_m(bob),g))),validkey(dhexp_real(key_e(alice,bob,sid_5),g))),encrypt(hmac_hash2(hmac_hash1(hash(somename,empty),dhexp_real(key_e(alice,bob,sid_5),dhexp_real(key_s(bob),g))),dhexp_real(key_e(alice,bob,sid_5),dhexp_real(key_m(bob),g))),minnonce,hash(hash(hash(hash(hash(somename,empty),empty),validkey(dhexp_real(key_s(bob),g))),validkey(dhexp_real(key_m(bob),g))),validkey(dhexp_real(key_e(alice,bob,sid_5),g))),validkey(dhexp_real(key_s(alice),g)))),validkey(dhexp_real(key_m(alice),g)))),msg_a(alice,bob,sid_5)).
So the attacker may know encrypt(hmac_hash2(hmac_hash1(hmac_hash1(hmac_hash1(hash(somename,empty),dhexp_real(key_e(alice,bob,sid_5),dhexp_real(key_s(bob),g))),dhexp_real(key_e(alice,bob,sid_5),dhexp_real(key_m(bob),g))),dhexp_real(key_m(alice),dhexp_real(key_s(bob),g))),dhexp_real(key_m(bob),dhexp_real(key_s(alice),g))),minnonce,hash(hash(hash(hash(hash(hash(hash(somename,empty),empty),validkey(dhexp_real(key_s(bob),g))),validkey(dhexp_real(key_m(bob),g))),validkey(dhexp_real(key_e(alice,bob,sid_5),g))),encrypt(hmac_hash2(hmac_hash1(hash(somename,empty),dhexp_real(key_e(alice,bob,sid_5),dhexp_real(key_s(bob),g))),dhexp_real(key_e(alice,bob,sid_5),dhexp_real(key_m(bob),g))),minnonce,hash(hash(hash(hash(hash(somename,empty),empty),validkey(dhexp_real(key_s(bob),g))),validkey(dhexp_real(key_m(bob),g))),validkey(dhexp_real(key_e(alice,bob,sid_5),g))),validkey(dhexp_real(key_s(alice),g)))),encrypt(hmac_hash2(hmac_hash1(hash(somename,empty),dhexp_real(key_e(alice,bob,sid_5),dhexp_real(key_s(bob),g))),dhexp_real(key_e(alice,bob,sid_5),dhexp_real(key_m(bob),g))),increment_nonce(minnonce),hash(hash(hash(hash(hash(hash(somename,empty),empty),validkey(dhexp_real(key_s(bob),g))),validkey(dhexp_real(key_m(bob),g))),validkey(dhexp_real(key_e(alice,bob,sid_5),g))),encrypt(hmac_hash2(hmac_hash1(hash(somename,empty),dhexp_real(key_e(alice,bob,sid_5),dhexp_real(key_s(bob),g))),dhexp_real(key_e(alice,bob,sid_5),dhexp_real(key_m(bob),g))),minnonce,hash(hash(hash(hash(hash(somename,empty),empty),validkey(dhexp_real(key_s(bob),g))),validkey(dhexp_real(key_m(bob),g))),validkey(dhexp_real(key_e(alice,bob,sid_5),g))),validkey(dhexp_real(key_s(alice),g)))),validkey(dhexp_real(key_m(alice),g)))),msg_a(alice,bob,sid_5)) in phase 1.
attacker_p1(encrypt(hmac_hash2(hmac_hash1(hmac_hash1(hmac_hash1(hash(somename,empty),dhexp_real(key_e(alice,bob,sid_5),dhexp_real(key_s(bob),g))),dhexp_real(key_e(alice,bob,sid_5),dhexp_real(key_m(bob),g))),dhexp_real(key_m(alice),dhexp_real(key_s(bob),g))),dhexp_real(key_m(bob),dhexp_real(key_s(alice),g))),minnonce,hash(hash(hash(hash(hash(hash(hash(somename,empty),empty),validkey(dhexp_real(key_s(bob),g))),validkey(dhexp_real(key_m(bob),g))),validkey(dhexp_real(key_e(alice,bob,sid_5),g))),encrypt(hmac_hash2(hmac_hash1(hash(somename,empty),dhexp_real(key_e(alice,bob,sid_5),dhexp_real(key_s(bob),g))),dhexp_real(key_e(alice,bob,sid_5),dhexp_real(key_m(bob),g))),minnonce,hash(hash(hash(hash(hash(somename,empty),empty),validkey(dhexp_real(key_s(bob),g))),validkey(dhexp_real(key_m(bob),g))),validkey(dhexp_real(key_e(alice,bob,sid_5),g))),validkey(dhexp_real(key_s(alice),g)))),encrypt(hmac_hash2(hmac_hash1(hash(somename,empty),dhexp_real(key_e(alice,bob,sid_5),dhexp_real(key_s(bob),g))),dhexp_real(key_e(alice,bob,sid_5),dhexp_real(key_m(bob),g))),increment_nonce(minnonce),hash(hash(hash(hash(hash(hash(somename,empty),empty),validkey(dhexp_real(key_s(bob),g))),validkey(dhexp_real(key_m(bob),g))),validkey(dhexp_real(key_e(alice,bob,sid_5),g))),encrypt(hmac_hash2(hmac_hash1(hash(somename,empty),dhexp_real(key_e(alice,bob,sid_5),dhexp_real(key_s(bob),g))),dhexp_real(key_e(alice,bob,sid_5),dhexp_real(key_m(bob),g))),minnonce,hash(hash(hash(hash(hash(somename,empty),empty),validkey(dhexp_real(key_s(bob),g))),validkey(dhexp_real(key_m(bob),g))),validkey(dhexp_real(key_e(alice,bob,sid_5),g))),validkey(dhexp_real(key_s(alice),g)))),validkey(dhexp_real(key_m(alice),g)))),msg_a(alice,bob,sid_5))).

7. The entry statestore(alice,bob,sid_5,statepack_a(handshakestatepack(symmetricstatepack(cipherstatepack(empty,minnonce),hash(somename,empty),hash(hash(hash(hash(somename,empty),empty),validkey(dhexp_real(key_s(bob),g))),validkey(dhexp_real(key_m(bob),g)))),keypairpack(empty,empty),keypairpack(empty,empty),keypairpack(empty,empty),validkey(dhexp_real(key_s(bob),g)),validkey(dhexp_real(key_m(bob),g)),empty,empty,true))) that may be in a table by 2 may be read at get {306}.
The event SendMsg(alice,bob,stagepack_a(sid_5),msg_a(alice,bob,sid_5)) may be executed at {304}.
So the message concat4(validkey(dhexp_real(key_e(alice,bob,sid_5),g)),encrypt(hmac_hash2(hmac_hash1(hash(somename,empty),dhexp_real(key_e(alice,bob,sid_5),dhexp_real(key_s(bob),g))),dhexp_real(key_e(alice,bob,sid_5),dhexp_real(key_m(bob),g))),minnonce,hash(hash(hash(hash(hash(somename,empty),empty),validkey(dhexp_real(key_s(bob),g))),validkey(dhexp_real(key_m(bob),g))),validkey(dhexp_real(key_e(alice,bob,sid_5),g))),validkey(dhexp_real(key_s(alice),g))),encrypt(hmac_hash2(hmac_hash1(hash(somename,empty),dhexp_real(key_e(alice,bob,sid_5),dhexp_real(key_s(bob),g))),dhexp_real(key_e(alice,bob,sid_5),dhexp_real(key_m(bob),g))),increment_nonce(minnonce),hash(hash(hash(hash(hash(hash(somename,empty),empty),validkey(dhexp_real(key_s(bob),g))),validkey(dhexp_real(key_m(bob),g))),validkey(dhexp_real(key_e(alice,bob,sid_5),g))),encrypt(hmac_hash2(hmac_hash1(hash(somename,empty),dhexp_real(key_e(alice,bob,sid_5),dhexp_real(key_s(bob),g))),dhexp_real(key_e(alice,bob,sid_5),dhexp_real(key_m(bob),g))),minnonce,hash(hash(hash(hash(hash(somename,empty),empty),validkey(dhexp_real(key_s(bob),g))),validkey(dhexp_real(key_m(bob),g))),validkey(dhexp_real(key_e(alice,bob,sid_5),g))),validkey(dhexp_real(key_s(alice),g)))),validkey(dhexp_real(key_m(alice),g))),encrypt(hmac_hash2(hmac_hash1(hmac_hash1(hmac_hash1(hash(somename,empty),dhexp_real(key_e(alice,bob,sid_5),dhexp_real(key_s(bob),g))),dhexp_real(key_e(alice,bob,sid_5),dhexp_real(key_m(bob),g))),dhexp_real(key_m(alice),dhexp_real(key_s(bob),g))),dhexp_real(key_s(alice),dhexp_real(key_m(bob),g))),minnonce,hash(hash(hash(hash(hash(hash(hash(somename,empty),empty),validkey(dhexp_real(key_s(bob),g))),validkey(dhexp_real(key_m(bob),g))),validkey(dhexp_real(key_e(alice,bob,sid_5),g))),encrypt(hmac_hash2(hmac_hash1(hash(somename,empty),dhexp_real(key_e(alice,bob,sid_5),dhexp_real(key_s(bob),g))),dhexp_real(key_e(alice,bob,sid_5),dhexp_real(key_m(bob),g))),minnonce,hash(hash(hash(hash(hash(somename,empty),empty),validkey(dhexp_real(key_s(bob),g))),validkey(dhexp_real(key_m(bob),g))),validkey(dhexp_real(key_e(alice,bob,sid_5),g))),validkey(dhexp_real(key_s(alice),g)))),encrypt(hmac_hash2(hmac_hash1(hash(somename,empty),dhexp_real(key_e(alice,bob,sid_5),dhexp_real(key_s(bob),g))),dhexp_real(key_e(alice,bob,sid_5),dhexp_real(key_m(bob),g))),increment_nonce(minnonce),hash(hash(hash(hash(hash(hash(somename,empty),empty),validkey(dhexp_real(key_s(bob),g))),validkey(dhexp_real(key_m(bob),g))),validkey(dhexp_real(key_e(alice,bob,sid_5),g))),encrypt(hmac_hash2(hmac_hash1(hash(somename,empty),dhexp_real(key_e(alice,bob,sid_5),dhexp_real(key_s(bob),g))),dhexp_real(key_e(alice,bob,sid_5),dhexp_real(key_m(bob),g))),minnonce,hash(hash(hash(hash(hash(somename,empty),empty),validkey(dhexp_real(key_s(bob),g))),validkey(dhexp_real(key_m(bob),g))),validkey(dhexp_real(key_e(alice,bob,sid_5),g))),validkey(dhexp_real(key_s(alice),g)))),validkey(dhexp_real(key_m(alice),g)))),msg_a(alice,bob,sid_5))) may be sent on channel pub at output {305}.
mess(pub,concat4(validkey(dhexp_real(key_e(alice,bob,sid_5),g)),encrypt(hmac_hash2(hmac_hash1(hash(somename,empty),dhexp_real(key_e(alice,bob,sid_5),dhexp_real(key_s(bob),g))),dhexp_real(key_e(alice,bob,sid_5),dhexp_real(key_m(bob),g))),minnonce,hash(hash(hash(hash(hash(somename,empty),empty),validkey(dhexp_real(key_s(bob),g))),validkey(dhexp_real(key_m(bob),g))),validkey(dhexp_real(key_e(alice,bob,sid_5),g))),validkey(dhexp_real(key_s(alice),g))),encrypt(hmac_hash2(hmac_hash1(hash(somename,empty),dhexp_real(key_e(alice,bob,sid_5),dhexp_real(key_s(bob),g))),dhexp_real(key_e(alice,bob,sid_5),dhexp_real(key_m(bob),g))),increment_nonce(minnonce),hash(hash(hash(hash(hash(hash(somename,empty),empty),validkey(dhexp_real(key_s(bob),g))),validkey(dhexp_real(key_m(bob),g))),validkey(dhexp_real(key_e(alice,bob,sid_5),g))),encrypt(hmac_hash2(hmac_hash1(hash(somename,empty),dhexp_real(key_e(alice,bob,sid_5),dhexp_real(key_s(bob),g))),dhexp_real(key_e(alice,bob,sid_5),dhexp_real(key_m(bob),g))),minnonce,hash(hash(hash(hash(hash(somename,empty),empty),validkey(dhexp_real(key_s(bob),g))),validkey(dhexp_real(key_m(bob),g))),validkey(dhexp_real(key_e(alice,bob,sid_5),g))),validkey(dhexp_real(key_s(alice),g)))),validkey(dhexp_real(key_m(alice),g))),encrypt(hmac_hash2(hmac_hash1(hmac_hash1(hmac_hash1(hash(somename,empty),dhexp_real(key_e(alice,bob,sid_5),dhexp_real(key_s(bob),g))),dhexp_real(key_e(alice,bob,sid_5),dhexp_real(key_m(bob),g))),dhexp_real(key_m(alice),dhexp_real(key_s(bob),g))),dhexp_real(key_s(alice),dhexp_real(key_m(bob),g))),minnonce,hash(hash(hash(hash(hash(hash(hash(somename,empty),empty),validkey(dhexp_real(key_s(bob),g))),validkey(dhexp_real(key_m(bob),g))),validkey(dhexp_real(key_e(alice,bob,sid_5),g))),encrypt(hmac_hash2(hmac_hash1(hash(somename,empty),dhexp_real(key_e(alice,bob,sid_5),dhexp_real(key_s(bob),g))),dhexp_real(key_e(alice,bob,sid_5),dhexp_real(key_m(bob),g))),minnonce,hash(hash(hash(hash(hash(somename,empty),empty),validkey(dhexp_real(key_s(bob),g))),validkey(dhexp_real(key_m(bob),g))),validkey(dhexp_real(key_e(alice,bob,sid_5),g))),validkey(dhexp_real(key_s(alice),g)))),encrypt(hmac_hash2(hmac_hash1(hash(somename,empty),dhexp_real(key_e(alice,bob,sid_5),dhexp_real(key_s(bob),g))),dhexp_real(key_e(alice,bob,sid_5),dhexp_real(key_m(bob),g))),increment_nonce(minnonce),hash(hash(hash(hash(hash(hash(somename,empty),empty),validkey(dhexp_real(key_s(bob),g))),validkey(dhexp_real(key_m(bob),g))),validkey(dhexp_real(key_e(alice,bob,sid_5),g))),encrypt(hmac_hash2(hmac_hash1(hash(somename,empty),dhexp_real(key_e(alice,bob,sid_5),dhexp_real(key_s(bob),g))),dhexp_real(key_e(alice,bob,sid_5),dhexp_real(key_m(bob),g))),minnonce,hash(hash(hash(hash(hash(somename,empty),empty),validkey(dhexp_real(key_s(bob),g))),validkey(dhexp_real(key_m(bob),g))),validkey(dhexp_real(key_e(alice,bob,sid_5),g))),validkey(dhexp_real(key_s(alice),g)))),validkey(dhexp_real(key_m(alice),g)))),msg_a(alice,bob,sid_5)))).

8. By 1, the attacker may have the channel pub.
By 7, the message concat4(validkey(dhexp_real(key_e(alice,bob,sid_5),g)),encrypt(hmac_hash2(hmac_hash1(hash(somename,empty),dhexp_real(key_e(alice,bob,sid_5),dhexp_real(key_s(bob),g))),dhexp_real(key_e(alice,bob,sid_5),dhexp_real(key_m(bob),g))),minnonce,hash(hash(hash(hash(hash(somename,empty),empty),validkey(dhexp_real(key_s(bob),g))),validkey(dhexp_real(key_m(bob),g))),validkey(dhexp_real(key_e(alice,bob,sid_5),g))),validkey(dhexp_real(key_s(alice),g))),encrypt(hmac_hash2(hmac_hash1(hash(somename,empty),dhexp_real(key_e(alice,bob,sid_5),dhexp_real(key_s(bob),g))),dhexp_real(key_e(alice,bob,sid_5),dhexp_real(key_m(bob),g))),increment_nonce(minnonce),hash(hash(hash(hash(hash(hash(somename,empty),empty),validkey(dhexp_real(key_s(bob),g))),validkey(dhexp_real(key_m(bob),g))),validkey(dhexp_real(key_e(alice,bob,sid_5),g))),encrypt(hmac_hash2(hmac_hash1(hash(somename,empty),dhexp_real(key_e(alice,bob,sid_5),dhexp_real(key_s(bob),g))),dhexp_real(key_e(alice,bob,sid_5),dhexp_real(key_m(bob),g))),minnonce,hash(hash(hash(hash(hash(somename,empty),empty),validkey(dhexp_real(key_s(bob),g))),validkey(dhexp_real(key_m(bob),g))),validkey(dhexp_real(key_e(alice,bob,sid_5),g))),validkey(dhexp_real(key_s(alice),g)))),validkey(dhexp_real(key_m(alice),g))),encrypt(hmac_hash2(hmac_hash1(hmac_hash1(hmac_hash1(hash(somename,empty),dhexp_real(key_e(alice,bob,sid_5),dhexp_real(key_s(bob),g))),dhexp_real(key_e(alice,bob,sid_5),dhexp_real(key_m(bob),g))),dhexp_real(key_m(alice),dhexp_real(key_s(bob),g))),dhexp_real(key_s(alice),dhexp_real(key_m(bob),g))),minnonce,hash(hash(hash(hash(hash(hash(hash(somename,empty),empty),validkey(dhexp_real(key_s(bob),g))),validkey(dhexp_real(key_m(bob),g))),validkey(dhexp_real(key_e(alice,bob,sid_5),g))),encrypt(hmac_hash2(hmac_hash1(hash(somename,empty),dhexp_real(key_e(alice,bob,sid_5),dhexp_real(key_s(bob),g))),dhexp_real(key_e(alice,bob,sid_5),dhexp_real(key_m(bob),g))),minnonce,hash(hash(hash(hash(hash(somename,empty),empty),validkey(dhexp_real(key_s(bob),g))),validkey(dhexp_real(key_m(bob),g))),validkey(dhexp_real(key_e(alice,bob,sid_5),g))),validkey(dhexp_real(key_s(alice),g)))),encrypt(hmac_hash2(hmac_hash1(hash(somename,empty),dhexp_real(key_e(alice,bob,sid_5),dhexp_real(key_s(bob),g))),dhexp_real(key_e(alice,bob,sid_5),dhexp_real(key_m(bob),g))),increment_nonce(minnonce),hash(hash(hash(hash(hash(hash(somename,empty),empty),validkey(dhexp_real(key_s(bob),g))),validkey(dhexp_real(key_m(bob),g))),validkey(dhexp_real(key_e(alice,bob,sid_5),g))),encrypt(hmac_hash2(hmac_hash1(hash(somename,empty),dhexp_real(key_e(alice,bob,sid_5),dhexp_real(key_s(bob),g))),dhexp_real(key_e(alice,bob,sid_5),dhexp_real(key_m(bob),g))),minnonce,hash(hash(hash(hash(hash(somename,empty),empty),validkey(dhexp_real(key_s(bob),g))),validkey(dhexp_real(key_m(bob),g))),validkey(dhexp_real(key_e(alice,bob,sid_5),g))),validkey(dhexp_real(key_s(alice),g)))),validkey(dhexp_real(key_m(alice),g)))),msg_a(alice,bob,sid_5))) may be sent on this channel.
So the attacker may obtain the message concat4(validkey(dhexp_real(key_e(alice,bob,sid_5),g)),encrypt(hmac_hash2(hmac_hash1(hash(somename,empty),dhexp_real(key_e(alice,bob,sid_5),dhexp_real(key_s(bob),g))),dhexp_real(key_e(alice,bob,sid_5),dhexp_real(key_m(bob),g))),minnonce,hash(hash(hash(hash(hash(somename,empty),empty),validkey(dhexp_real(key_s(bob),g))),validkey(dhexp_real(key_m(bob),g))),validkey(dhexp_real(key_e(alice,bob,sid_5),g))),validkey(dhexp_real(key_s(alice),g))),encrypt(hmac_hash2(hmac_hash1(hash(somename,empty),dhexp_real(key_e(alice,bob,sid_5),dhexp_real(key_s(bob),g))),dhexp_real(key_e(alice,bob,sid_5),dhexp_real(key_m(bob),g))),increment_nonce(minnonce),hash(hash(hash(hash(hash(hash(somename,empty),empty),validkey(dhexp_real(key_s(bob),g))),validkey(dhexp_real(key_m(bob),g))),validkey(dhexp_real(key_e(alice,bob,sid_5),g))),encrypt(hmac_hash2(hmac_hash1(hash(somename,empty),dhexp_real(key_e(alice,bob,sid_5),dhexp_real(key_s(bob),g))),dhexp_real(key_e(alice,bob,sid_5),dhexp_real(key_m(bob),g))),minnonce,hash(hash(hash(hash(hash(somename,empty),empty),validkey(dhexp_real(key_s(bob),g))),validkey(dhexp_real(key_m(bob),g))),validkey(dhexp_real(key_e(alice,bob,sid_5),g))),validkey(dhexp_real(key_s(alice),g)))),validkey(dhexp_real(key_m(alice),g))),encrypt(hmac_hash2(hmac_hash1(hmac_hash1(hmac_hash1(hash(somename,empty),dhexp_real(key_e(alice,bob,sid_5),dhexp_real(key_s(bob),g))),dhexp_real(key_e(alice,bob,sid_5),dhexp_real(key_m(bob),g))),dhexp_real(key_m(alice),dhexp_real(key_s(bob),g))),dhexp_real(key_s(alice),dhexp_real(key_m(bob),g))),minnonce,hash(hash(hash(hash(hash(hash(hash(somename,empty),empty),validkey(dhexp_real(key_s(bob),g))),validkey(dhexp_real(key_m(bob),g))),validkey(dhexp_real(key_e(alice,bob,sid_5),g))),encrypt(hmac_hash2(hmac_hash1(hash(somename,empty),dhexp_real(key_e(alice,bob,sid_5),dhexp_real(key_s(bob),g))),dhexp_real(key_e(alice,bob,sid_5),dhexp_real(key_m(bob),g))),minnonce,hash(hash(hash(hash(hash(somename,empty),empty),validkey(dhexp_real(key_s(bob),g))),validkey(dhexp_real(key_m(bob),g))),validkey(dhexp_real(key_e(alice,bob,sid_5),g))),validkey(dhexp_real(key_s(alice),g)))),encrypt(hmac_hash2(hmac_hash1(hash(somename,empty),dhexp_real(key_e(alice,bob,sid_5),dhexp_real(key_s(bob),g))),dhexp_real(key_e(alice,bob,sid_5),dhexp_real(key_m(bob),g))),increment_nonce(minnonce),hash(hash(hash(hash(hash(hash(somename,empty),empty),validkey(dhexp_real(key_s(bob),g))),validkey(dhexp_real(key_m(bob),g))),validkey(dhexp_real(key_e(alice,bob,sid_5),g))),encrypt(hmac_hash2(hmac_hash1(hash(somename,empty),dhexp_real(key_e(alice,bob,sid_5),dhexp_real(key_s(bob),g))),dhexp_real(key_e(alice,bob,sid_5),dhexp_real(key_m(bob),g))),minnonce,hash(hash(hash(hash(hash(somename,empty),empty),validkey(dhexp_real(key_s(bob),g))),validkey(dhexp_real(key_m(bob),g))),validkey(dhexp_real(key_e(alice,bob,sid_5),g))),validkey(dhexp_real(key_s(alice),g)))),validkey(dhexp_real(key_m(alice),g)))),msg_a(alice,bob,sid_5))) by listening on this channel.
attacker(concat4(validkey(dhexp_real(key_e(alice,bob,sid_5),g)),encrypt(hmac_hash2(hmac_hash1(hash(somename,empty),dhexp_real(key_e(alice,bob,sid_5),dhexp_real(key_s(bob),g))),dhexp_real(key_e(alice,bob,sid_5),dhexp_real(key_m(bob),g))),minnonce,hash(hash(hash(hash(hash(somename,empty),empty),validkey(dhexp_real(key_s(bob),g))),validkey(dhexp_real(key_m(bob),g))),validkey(dhexp_real(key_e(alice,bob,sid_5),g))),validkey(dhexp_real(key_s(alice),g))),encrypt(hmac_hash2(hmac_hash1(hash(somename,empty),dhexp_real(key_e(alice,bob,sid_5),dhexp_real(key_s(bob),g))),dhexp_real(key_e(alice,bob,sid_5),dhexp_real(key_m(bob),g))),increment_nonce(minnonce),hash(hash(hash(hash(hash(hash(somename,empty),empty),validkey(dhexp_real(key_s(bob),g))),validkey(dhexp_real(key_m(bob),g))),validkey(dhexp_real(key_e(alice,bob,sid_5),g))),encrypt(hmac_hash2(hmac_hash1(hash(somename,empty),dhexp_real(key_e(alice,bob,sid_5),dhexp_real(key_s(bob),g))),dhexp_real(key_e(alice,bob,sid_5),dhexp_real(key_m(bob),g))),minnonce,hash(hash(hash(hash(hash(somename,empty),empty),validkey(dhexp_real(key_s(bob),g))),validkey(dhexp_real(key_m(bob),g))),validkey(dhexp_real(key_e(alice,bob,sid_5),g))),validkey(dhexp_real(key_s(alice),g)))),validkey(dhexp_real(key_m(alice),g))),encrypt(hmac_hash2(hmac_hash1(hmac_hash1(hmac_hash1(hash(somename,empty),dhexp_real(key_e(alice,bob,sid_5),dhexp_real(key_s(bob),g))),dhexp_real(key_e(alice,bob,sid_5),dhexp_real(key_m(bob),g))),dhexp_real(key_m(alice),dhexp_real(key_s(bob),g))),dhexp_real(key_s(alice),dhexp_real(key_m(bob),g))),minnonce,hash(hash(hash(hash(hash(hash(hash(somename,empty),empty),validkey(dhexp_real(key_s(bob),g))),validkey(dhexp_real(key_m(bob),g))),validkey(dhexp_real(key_e(alice,bob,sid_5),g))),encrypt(hmac_hash2(hmac_hash1(hash(somename,empty),dhexp_real(key_e(alice,bob,sid_5),dhexp_real(key_s(bob),g))),dhexp_real(key_e(alice,bob,sid_5),dhexp_real(key_m(bob),g))),minnonce,hash(hash(hash(hash(hash(somename,empty),empty),validkey(dhexp_real(key_s(bob),g))),validkey(dhexp_real(key_m(bob),g))),validkey(dhexp_real(key_e(alice,bob,sid_5),g))),validkey(dhexp_real(key_s(alice),g)))),encrypt(hmac_hash2(hmac_hash1(hash(somename,empty),dhexp_real(key_e(alice,bob,sid_5),dhexp_real(key_s(bob),g))),dhexp_real(key_e(alice,bob,sid_5),dhexp_real(key_m(bob),g))),increment_nonce(minnonce),hash(hash(hash(hash(hash(hash(somename,empty),empty),validkey(dhexp_real(key_s(bob),g))),validkey(dhexp_real(key_m(bob),g))),validkey(dhexp_real(key_e(alice,bob,sid_5),g))),encrypt(hmac_hash2(hmac_hash1(hash(somename,empty),dhexp_real(key_e(alice,bob,sid_5),dhexp_real(key_s(bob),g))),dhexp_real(key_e(alice,bob,sid_5),dhexp_real(key_m(bob),g))),minnonce,hash(hash(hash(hash(hash(somename,empty),empty),validkey(dhexp_real(key_s(bob),g))),validkey(dhexp_real(key_m(bob),g))),validkey(dhexp_real(key_e(alice,bob,sid_5),g))),validkey(dhexp_real(key_s(alice),g)))),validkey(dhexp_real(key_m(alice),g)))),msg_a(alice,bob,sid_5)))).

9. By 8, the attacker may know concat4(validkey(dhexp_real(key_e(alice,bob,sid_5),g)),encrypt(hmac_hash2(hmac_hash1(hash(somename,empty),dhexp_real(key_e(alice,bob,sid_5),dhexp_real(key_s(bob),g))),dhexp_real(key_e(alice,bob,sid_5),dhexp_real(key_m(bob),g))),minnonce,hash(hash(hash(hash(hash(somename,empty),empty),validkey(dhexp_real(key_s(bob),g))),validkey(dhexp_real(key_m(bob),g))),validkey(dhexp_real(key_e(alice,bob,sid_5),g))),validkey(dhexp_real(key_s(alice),g))),encrypt(hmac_hash2(hmac_hash1(hash(somename,empty),dhexp_real(key_e(alice,bob,sid_5),dhexp_real(key_s(bob),g))),dhexp_real(key_e(alice,bob,sid_5),dhexp_real(key_m(bob),g))),increment_nonce(minnonce),hash(hash(hash(hash(hash(hash(somename,empty),empty),validkey(dhexp_real(key_s(bob),g))),validkey(dhexp_real(key_m(bob),g))),validkey(dhexp_real(key_e(alice,bob,sid_5),g))),encrypt(hmac_hash2(hmac_hash1(hash(somename,empty),dhexp_real(key_e(alice,bob,sid_5),dhexp_real(key_s(bob),g))),dhexp_real(key_e(alice,bob,sid_5),dhexp_real(key_m(bob),g))),minnonce,hash(hash(hash(hash(hash(somename,empty),empty),validkey(dhexp_real(key_s(bob),g))),validkey(dhexp_real(key_m(bob),g))),validkey(dhexp_real(key_e(alice,bob,sid_5),g))),validkey(dhexp_real(key_s(alice),g)))),validkey(dhexp_real(key_m(alice),g))),encrypt(hmac_hash2(hmac_hash1(hmac_hash1(hmac_hash1(hash(somename,empty),dhexp_real(key_e(alice,bob,sid_5),dhexp_real(key_s(bob),g))),dhexp_real(key_e(alice,bob,sid_5),dhexp_real(key_m(bob),g))),dhexp_real(key_m(alice),dhexp_real(key_s(bob),g))),dhexp_real(key_s(alice),dhexp_real(key_m(bob),g))),minnonce,hash(hash(hash(hash(hash(hash(hash(somename,empty),empty),validkey(dhexp_real(key_s(bob),g))),validkey(dhexp_real(key_m(bob),g))),validkey(dhexp_real(key_e(alice,bob,sid_5),g))),encrypt(hmac_hash2(hmac_hash1(hash(somename,empty),dhexp_real(key_e(alice,bob,sid_5),dhexp_real(key_s(bob),g))),dhexp_real(key_e(alice,bob,sid_5),dhexp_real(key_m(bob),g))),minnonce,hash(hash(hash(hash(hash(somename,empty),empty),validkey(dhexp_real(key_s(bob),g))),validkey(dhexp_real(key_m(bob),g))),validkey(dhexp_real(key_e(alice,bob,sid_5),g))),validkey(dhexp_real(key_s(alice),g)))),encrypt(hmac_hash2(hmac_hash1(hash(somename,empty),dhexp_real(key_e(alice,bob,sid_5),dhexp_real(key_s(bob),g))),dhexp_real(key_e(alice,bob,sid_5),dhexp_real(key_m(bob),g))),increment_nonce(minnonce),hash(hash(hash(hash(hash(hash(somename,empty),empty),validkey(dhexp_real(key_s(bob),g))),validkey(dhexp_real(key_m(bob),g))),validkey(dhexp_real(key_e(alice,bob,sid_5),g))),encrypt(hmac_hash2(hmac_hash1(hash(somename,empty),dhexp_real(key_e(alice,bob,sid_5),dhexp_real(key_s(bob),g))),dhexp_real(key_e(alice,bob,sid_5),dhexp_real(key_m(bob),g))),minnonce,hash(hash(hash(hash(hash(somename,empty),empty),validkey(dhexp_real(key_s(bob),g))),validkey(dhexp_real(key_m(bob),g))),validkey(dhexp_real(key_e(alice,bob,sid_5),g))),validkey(dhexp_real(key_s(alice),g)))),validkey(dhexp_real(key_m(alice),g)))),msg_a(alice,bob,sid_5))).
Using the function 3-proj-concat4 the attacker may obtain encrypt(hmac_hash2(hmac_hash1(hash(somename,empty),dhexp_real(key_e(alice,bob,sid_5),dhexp_real(key_s(bob),g))),dhexp_real(key_e(alice,bob,sid_5),dhexp_real(key_m(bob),g))),increment_nonce(minnonce),hash(hash(hash(hash(hash(hash(somename,empty),empty),validkey(dhexp_real(key_s(bob),g))),validkey(dhexp_real(key_m(bob),g))),validkey(dhexp_real(key_e(alice,bob,sid_5),g))),encrypt(hmac_hash2(hmac_hash1(hash(somename,empty),dhexp_real(key_e(alice,bob,sid_5),dhexp_real(key_s(bob),g))),dhexp_real(key_e(alice,bob,sid_5),dhexp_real(key_m(bob),g))),minnonce,hash(hash(hash(hash(hash(somename,empty),empty),validkey(dhexp_real(key_s(bob),g))),validkey(dhexp_real(key_m(bob),g))),validkey(dhexp_real(key_e(alice,bob,sid_5),g))),validkey(dhexp_real(key_s(alice),g)))),validkey(dhexp_real(key_m(alice),g))).
attacker(encrypt(hmac_hash2(hmac_hash1(hash(somename,empty),dhexp_real(key_e(alice,bob,sid_5),dhexp_real(key_s(bob),g))),dhexp_real(key_e(alice,bob,sid_5),dhexp_real(key_m(bob),g))),increment_nonce(minnonce),hash(hash(hash(hash(hash(hash(somename,empty),empty),validkey(dhexp_real(key_s(bob),g))),validkey(dhexp_real(key_m(bob),g))),validkey(dhexp_real(key_e(alice,bob,sid_5),g))),encrypt(hmac_hash2(hmac_hash1(hash(somename,empty),dhexp_real(key_e(alice,bob,sid_5),dhexp_real(key_s(bob),g))),dhexp_real(key_e(alice,bob,sid_5),dhexp_real(key_m(bob),g))),minnonce,hash(hash(hash(hash(hash(somename,empty),empty),validkey(dhexp_real(key_s(bob),g))),validkey(dhexp_real(key_m(bob),g))),validkey(dhexp_real(key_e(alice,bob,sid_5),g))),validkey(dhexp_real(key_s(alice),g)))),validkey(dhexp_real(key_m(alice),g)))).

10. By 8, the attacker may know concat4(validkey(dhexp_real(key_e(alice,bob,sid_5),g)),encrypt(hmac_hash2(hmac_hash1(hash(somename,empty),dhexp_real(key_e(alice,bob,sid_5),dhexp_real(key_s(bob),g))),dhexp_real(key_e(alice,bob,sid_5),dhexp_real(key_m(bob),g))),minnonce,hash(hash(hash(hash(hash(somename,empty),empty),validkey(dhexp_real(key_s(bob),g))),validkey(dhexp_real(key_m(bob),g))),validkey(dhexp_real(key_e(alice,bob,sid_5),g))),validkey(dhexp_real(key_s(alice),g))),encrypt(hmac_hash2(hmac_hash1(hash(somename,empty),dhexp_real(key_e(alice,bob,sid_5),dhexp_real(key_s(bob),g))),dhexp_real(key_e(alice,bob,sid_5),dhexp_real(key_m(bob),g))),increment_nonce(minnonce),hash(hash(hash(hash(hash(hash(somename,empty),empty),validkey(dhexp_real(key_s(bob),g))),validkey(dhexp_real(key_m(bob),g))),validkey(dhexp_real(key_e(alice,bob,sid_5),g))),encrypt(hmac_hash2(hmac_hash1(hash(somename,empty),dhexp_real(key_e(alice,bob,sid_5),dhexp_real(key_s(bob),g))),dhexp_real(key_e(alice,bob,sid_5),dhexp_real(key_m(bob),g))),minnonce,hash(hash(hash(hash(hash(somename,empty),empty),validkey(dhexp_real(key_s(bob),g))),validkey(dhexp_real(key_m(bob),g))),validkey(dhexp_real(key_e(alice,bob,sid_5),g))),validkey(dhexp_real(key_s(alice),g)))),validkey(dhexp_real(key_m(alice),g))),encrypt(hmac_hash2(hmac_hash1(hmac_hash1(hmac_hash1(hash(somename,empty),dhexp_real(key_e(alice,bob,sid_5),dhexp_real(key_s(bob),g))),dhexp_real(key_e(alice,bob,sid_5),dhexp_real(key_m(bob),g))),dhexp_real(key_m(alice),dhexp_real(key_s(bob),g))),dhexp_real(key_s(alice),dhexp_real(key_m(bob),g))),minnonce,hash(hash(hash(hash(hash(hash(hash(somename,empty),empty),validkey(dhexp_real(key_s(bob),g))),validkey(dhexp_real(key_m(bob),g))),validkey(dhexp_real(key_e(alice,bob,sid_5),g))),encrypt(hmac_hash2(hmac_hash1(hash(somename,empty),dhexp_real(key_e(alice,bob,sid_5),dhexp_real(key_s(bob),g))),dhexp_real(key_e(alice,bob,sid_5),dhexp_real(key_m(bob),g))),minnonce,hash(hash(hash(hash(hash(somename,empty),empty),validkey(dhexp_real(key_s(bob),g))),validkey(dhexp_real(key_m(bob),g))),validkey(dhexp_real(key_e(alice,bob,sid_5),g))),validkey(dhexp_real(key_s(alice),g)))),encrypt(hmac_hash2(hmac_hash1(hash(somename,empty),dhexp_real(key_e(alice,bob,sid_5),dhexp_real(key_s(bob),g))),dhexp_real(key_e(alice,bob,sid_5),dhexp_real(key_m(bob),g))),increment_nonce(minnonce),hash(hash(hash(hash(hash(hash(somename,empty),empty),validkey(dhexp_real(key_s(bob),g))),validkey(dhexp_real(key_m(bob),g))),validkey(dhexp_real(key_e(alice,bob,sid_5),g))),encrypt(hmac_hash2(hmac_hash1(hash(somename,empty),dhexp_real(key_e(alice,bob,sid_5),dhexp_real(key_s(bob),g))),dhexp_real(key_e(alice,bob,sid_5),dhexp_real(key_m(bob),g))),minnonce,hash(hash(hash(hash(hash(somename,empty),empty),validkey(dhexp_real(key_s(bob),g))),validkey(dhexp_real(key_m(bob),g))),validkey(dhexp_real(key_e(alice,bob,sid_5),g))),validkey(dhexp_real(key_s(alice),g)))),validkey(dhexp_real(key_m(alice),g)))),msg_a(alice,bob,sid_5))).
Using the function 2-proj-concat4 the attacker may obtain encrypt(hmac_hash2(hmac_hash1(hash(somename,empty),dhexp_real(key_e(alice,bob,sid_5),dhexp_real(key_s(bob),g))),dhexp_real(key_e(alice,bob,sid_5),dhexp_real(key_m(bob),g))),minnonce,hash(hash(hash(hash(hash(somename,empty),empty),validkey(dhexp_real(key_s(bob),g))),validkey(dhexp_real(key_m(bob),g))),validkey(dhexp_real(key_e(alice,bob,sid_5),g))),validkey(dhexp_real(key_s(alice),g))).
attacker(encrypt(hmac_hash2(hmac_hash1(hash(somename,empty),dhexp_real(key_e(alice,bob,sid_5),dhexp_real(key_s(bob),g))),dhexp_real(key_e(alice,bob,sid_5),dhexp_real(key_m(bob),g))),minnonce,hash(hash(hash(hash(hash(somename,empty),empty),validkey(dhexp_real(key_s(bob),g))),validkey(dhexp_real(key_m(bob),g))),validkey(dhexp_real(key_e(alice,bob,sid_5),g))),validkey(dhexp_real(key_s(alice),g)))).

11. By 8, the attacker may know concat4(validkey(dhexp_real(key_e(alice,bob,sid_5),g)),encrypt(hmac_hash2(hmac_hash1(hash(somename,empty),dhexp_real(key_e(alice,bob,sid_5),dhexp_real(key_s(bob),g))),dhexp_real(key_e(alice,bob,sid_5),dhexp_real(key_m(bob),g))),minnonce,hash(hash(hash(hash(hash(somename,empty),empty),validkey(dhexp_real(key_s(bob),g))),validkey(dhexp_real(key_m(bob),g))),validkey(dhexp_real(key_e(alice,bob,sid_5),g))),validkey(dhexp_real(key_s(alice),g))),encrypt(hmac_hash2(hmac_hash1(hash(somename,empty),dhexp_real(key_e(alice,bob,sid_5),dhexp_real(key_s(bob),g))),dhexp_real(key_e(alice,bob,sid_5),dhexp_real(key_m(bob),g))),increment_nonce(minnonce),hash(hash(hash(hash(hash(hash(somename,empty),empty),validkey(dhexp_real(key_s(bob),g))),validkey(dhexp_real(key_m(bob),g))),validkey(dhexp_real(key_e(alice,bob,sid_5),g))),encrypt(hmac_hash2(hmac_hash1(hash(somename,empty),dhexp_real(key_e(alice,bob,sid_5),dhexp_real(key_s(bob),g))),dhexp_real(key_e(alice,bob,sid_5),dhexp_real(key_m(bob),g))),minnonce,hash(hash(hash(hash(hash(somename,empty),empty),validkey(dhexp_real(key_s(bob),g))),validkey(dhexp_real(key_m(bob),g))),validkey(dhexp_real(key_e(alice,bob,sid_5),g))),validkey(dhexp_real(key_s(alice),g)))),validkey(dhexp_real(key_m(alice),g))),encrypt(hmac_hash2(hmac_hash1(hmac_hash1(hmac_hash1(hash(somename,empty),dhexp_real(key_e(alice,bob,sid_5),dhexp_real(key_s(bob),g))),dhexp_real(key_e(alice,bob,sid_5),dhexp_real(key_m(bob),g))),dhexp_real(key_m(alice),dhexp_real(key_s(bob),g))),dhexp_real(key_s(alice),dhexp_real(key_m(bob),g))),minnonce,hash(hash(hash(hash(hash(hash(hash(somename,empty),empty),validkey(dhexp_real(key_s(bob),g))),validkey(dhexp_real(key_m(bob),g))),validkey(dhexp_real(key_e(alice,bob,sid_5),g))),encrypt(hmac_hash2(hmac_hash1(hash(somename,empty),dhexp_real(key_e(alice,bob,sid_5),dhexp_real(key_s(bob),g))),dhexp_real(key_e(alice,bob,sid_5),dhexp_real(key_m(bob),g))),minnonce,hash(hash(hash(hash(hash(somename,empty),empty),validkey(dhexp_real(key_s(bob),g))),validkey(dhexp_real(key_m(bob),g))),validkey(dhexp_real(key_e(alice,bob,sid_5),g))),validkey(dhexp_real(key_s(alice),g)))),encrypt(hmac_hash2(hmac_hash1(hash(somename,empty),dhexp_real(key_e(alice,bob,sid_5),dhexp_real(key_s(bob),g))),dhexp_real(key_e(alice,bob,sid_5),dhexp_real(key_m(bob),g))),increment_nonce(minnonce),hash(hash(hash(hash(hash(hash(somename,empty),empty),validkey(dhexp_real(key_s(bob),g))),validkey(dhexp_real(key_m(bob),g))),validkey(dhexp_real(key_e(alice,bob,sid_5),g))),encrypt(hmac_hash2(hmac_hash1(hash(somename,empty),dhexp_real(key_e(alice,bob,sid_5),dhexp_real(key_s(bob),g))),dhexp_real(key_e(alice,bob,sid_5),dhexp_real(key_m(bob),g))),minnonce,hash(hash(hash(hash(hash(somename,empty),empty),validkey(dhexp_real(key_s(bob),g))),validkey(dhexp_real(key_m(bob),g))),validkey(dhexp_real(key_e(alice,bob,sid_5),g))),validkey(dhexp_real(key_s(alice),g)))),validkey(dhexp_real(key_m(alice),g)))),msg_a(alice,bob,sid_5))).
Using the function 1-proj-concat4 the attacker may obtain validkey(dhexp_real(key_e(alice,bob,sid_5),g)).
attacker(validkey(dhexp_real(key_e(alice,bob,sid_5),g))).

12. The message (validkey(dhexp_real(key_s(bob),g)),validkey(dhexp_real(key_m(bob),g))) may be sent on channel pub at output {635}.
mess(pub,(validkey(dhexp_real(key_s(bob),g)),validkey(dhexp_real(key_m(bob),g)))).

13. By 1, the attacker may have the channel pub.
By 12, the message (validkey(dhexp_real(key_s(bob),g)),validkey(dhexp_real(key_m(bob),g))) may be sent on this channel.
So the attacker may obtain the message (validkey(dhexp_real(key_s(bob),g)),validkey(dhexp_real(key_m(bob),g))) by listening on this channel.
attacker((validkey(dhexp_real(key_s(bob),g)),validkey(dhexp_real(key_m(bob),g)))).

14. By 13, the attacker may know (validkey(dhexp_real(key_s(bob),g)),validkey(dhexp_real(key_m(bob),g))).
Using the function 2-proj-2-tuple the attacker may obtain validkey(dhexp_real(key_m(bob),g)).
attacker(validkey(dhexp_real(key_m(bob),g))).

15. By 13, the attacker may know (validkey(dhexp_real(key_s(bob),g)),validkey(dhexp_real(key_m(bob),g))).
Using the function 1-proj-2-tuple the attacker may obtain validkey(dhexp_real(key_s(bob),g)).
attacker(validkey(dhexp_real(key_s(bob),g))).

16. Using the function empty the attacker may obtain empty.
attacker(empty).

17. Using the function somename the attacker may obtain somename.
attacker(somename).

18. By 17, the attacker may know somename.
By 16, the attacker may know empty.
Using the function hash the attacker may obtain hash(somename,empty).
attacker(hash(somename,empty)).

19. By 18, the attacker may know hash(somename,empty).
By 16, the attacker may know empty.
Using the function hash the attacker may obtain hash(hash(somename,empty),empty).
attacker(hash(hash(somename,empty),empty)).

20. By 19, the attacker may know hash(hash(somename,empty),empty).
By 15, the attacker may know validkey(dhexp_real(key_s(bob),g)).
Using the function hash the attacker may obtain hash(hash(hash(somename,empty),empty),validkey(dhexp_real(key_s(bob),g))).
attacker(hash(hash(hash(somename,empty),empty),validkey(dhexp_real(key_s(bob),g)))).

21. By 20, the attacker may know hash(hash(hash(somename,empty),empty),validkey(dhexp_real(key_s(bob),g))).
By 14, the attacker may know validkey(dhexp_real(key_m(bob),g)).
Using the function hash the attacker may obtain hash(hash(hash(hash(somename,empty),empty),validkey(dhexp_real(key_s(bob),g))),validkey(dhexp_real(key_m(bob),g))).
attacker(hash(hash(hash(hash(somename,empty),empty),validkey(dhexp_real(key_s(bob),g))),validkey(dhexp_real(key_m(bob),g)))).

22. By 21, the attacker may know hash(hash(hash(hash(somename,empty),empty),validkey(dhexp_real(key_s(bob),g))),validkey(dhexp_real(key_m(bob),g))).
By 11, the attacker may know validkey(dhexp_real(key_e(alice,bob,sid_5),g)).
Using the function hash the attacker may obtain hash(hash(hash(hash(hash(somename,empty),empty),validkey(dhexp_real(key_s(bob),g))),validkey(dhexp_real(key_m(bob),g))),validkey(dhexp_real(key_e(alice,bob,sid_5),g))).
attacker(hash(hash(hash(hash(hash(somename,empty),empty),validkey(dhexp_real(key_s(bob),g))),validkey(dhexp_real(key_m(bob),g))),validkey(dhexp_real(key_e(alice,bob,sid_5),g)))).

23. By 22, the attacker may know hash(hash(hash(hash(hash(somename,empty),empty),validkey(dhexp_real(key_s(bob),g))),validkey(dhexp_real(key_m(bob),g))),validkey(dhexp_real(key_e(alice,bob,sid_5),g))).
By 10, the attacker may know encrypt(hmac_hash2(hmac_hash1(hash(somename,empty),dhexp_real(key_e(alice,bob,sid_5),dhexp_real(key_s(bob),g))),dhexp_real(key_e(alice,bob,sid_5),dhexp_real(key_m(bob),g))),minnonce,hash(hash(hash(hash(hash(somename,empty),empty),validkey(dhexp_real(key_s(bob),g))),validkey(dhexp_real(key_m(bob),g))),validkey(dhexp_real(key_e(alice,bob,sid_5),g))),validkey(dhexp_real(key_s(alice),g))).
Using the function hash the attacker may obtain hash(hash(hash(hash(hash(hash(somename,empty),empty),validkey(dhexp_real(key_s(bob),g))),validkey(dhexp_real(key_m(bob),g))),validkey(dhexp_real(key_e(alice,bob,sid_5),g))),encrypt(hmac_hash2(hmac_hash1(hash(somename,empty),dhexp_real(key_e(alice,bob,sid_5),dhexp_real(key_s(bob),g))),dhexp_real(key_e(alice,bob,sid_5),dhexp_real(key_m(bob),g))),minnonce,hash(hash(hash(hash(hash(somename,empty),empty),validkey(dhexp_real(key_s(bob),g))),validkey(dhexp_real(key_m(bob),g))),validkey(dhexp_real(key_e(alice,bob,sid_5),g))),validkey(dhexp_real(key_s(alice),g)))).
attacker(hash(hash(hash(hash(hash(hash(somename,empty),empty),validkey(dhexp_real(key_s(bob),g))),validkey(dhexp_real(key_m(bob),g))),validkey(dhexp_real(key_e(alice,bob,sid_5),g))),encrypt(hmac_hash2(hmac_hash1(hash(somename,empty),dhexp_real(key_e(alice,bob,sid_5),dhexp_real(key_s(bob),g))),dhexp_real(key_e(alice,bob,sid_5),dhexp_real(key_m(bob),g))),minnonce,hash(hash(hash(hash(hash(somename,empty),empty),validkey(dhexp_real(key_s(bob),g))),validkey(dhexp_real(key_m(bob),g))),validkey(dhexp_real(key_e(alice,bob,sid_5),g))),validkey(dhexp_real(key_s(alice),g))))).

24. By 23, the attacker may know hash(hash(hash(hash(hash(hash(somename,empty),empty),validkey(dhexp_real(key_s(bob),g))),validkey(dhexp_real(key_m(bob),g))),validkey(dhexp_real(key_e(alice,bob,sid_5),g))),encrypt(hmac_hash2(hmac_hash1(hash(somename,empty),dhexp_real(key_e(alice,bob,sid_5),dhexp_real(key_s(bob),g))),dhexp_real(key_e(alice,bob,sid_5),dhexp_real(key_m(bob),g))),minnonce,hash(hash(hash(hash(hash(somename,empty),empty),validkey(dhexp_real(key_s(bob),g))),validkey(dhexp_real(key_m(bob),g))),validkey(dhexp_real(key_e(alice,bob,sid_5),g))),validkey(dhexp_real(key_s(alice),g)))).
By 9, the attacker may know encrypt(hmac_hash2(hmac_hash1(hash(somename,empty),dhexp_real(key_e(alice,bob,sid_5),dhexp_real(key_s(bob),g))),dhexp_real(key_e(alice,bob,sid_5),dhexp_real(key_m(bob),g))),increment_nonce(minnonce),hash(hash(hash(hash(hash(hash(somename,empty),empty),validkey(dhexp_real(key_s(bob),g))),validkey(dhexp_real(key_m(bob),g))),validkey(dhexp_real(key_e(alice,bob,sid_5),g))),encrypt(hmac_hash2(hmac_hash1(hash(somename,empty),dhexp_real(key_e(alice,bob,sid_5),dhexp_real(key_s(bob),g))),dhexp_real(key_e(alice,bob,sid_5),dhexp_real(key_m(bob),g))),minnonce,hash(hash(hash(hash(hash(somename,empty),empty),validkey(dhexp_real(key_s(bob),g))),validkey(dhexp_real(key_m(bob),g))),validkey(dhexp_real(key_e(alice,bob,sid_5),g))),validkey(dhexp_real(key_s(alice),g)))),validkey(dhexp_real(key_m(alice),g))).
Using the function hash the attacker may obtain hash(hash(hash(hash(hash(hash(hash(somename,empty),empty),validkey(dhexp_real(key_s(bob),g))),validkey(dhexp_real(key_m(bob),g))),validkey(dhexp_real(key_e(alice,bob,sid_5),g))),encrypt(hmac_hash2(hmac_hash1(hash(somename,empty),dhexp_real(key_e(alice,bob,sid_5),dhexp_real(key_s(bob),g))),dhexp_real(key_e(alice,bob,sid_5),dhexp_real(key_m(bob),g))),minnonce,hash(hash(hash(hash(hash(somename,empty),empty),validkey(dhexp_real(key_s(bob),g))),validkey(dhexp_real(key_m(bob),g))),validkey(dhexp_real(key_e(alice,bob,sid_5),g))),validkey(dhexp_real(key_s(alice),g)))),encrypt(hmac_hash2(hmac_hash1(hash(somename,empty),dhexp_real(key_e(alice,bob,sid_5),dhexp_real(key_s(bob),g))),dhexp_real(key_e(alice,bob,sid_5),dhexp_real(key_m(bob),g))),increment_nonce(minnonce),hash(hash(hash(hash(hash(hash(somename,empty),empty),validkey(dhexp_real(key_s(bob),g))),validkey(dhexp_real(key_m(bob),g))),validkey(dhexp_real(key_e(alice,bob,sid_5),g))),encrypt(hmac_hash2(hmac_hash1(hash(somename,empty),dhexp_real(key_e(alice,bob,sid_5),dhexp_real(key_s(bob),g))),dhexp_real(key_e(alice,bob,sid_5),dhexp_real(key_m(bob),g))),minnonce,hash(hash(hash(hash(hash(somename,empty),empty),validkey(dhexp_real(key_s(bob),g))),validkey(dhexp_real(key_m(bob),g))),validkey(dhexp_real(key_e(alice,bob,sid_5),g))),validkey(dhexp_real(key_s(alice),g)))),validkey(dhexp_real(key_m(alice),g)))).
attacker(hash(hash(hash(hash(hash(hash(hash(somename,empty),empty),validkey(dhexp_real(key_s(bob),g))),validkey(dhexp_real(key_m(bob),g))),validkey(dhexp_real(key_e(alice,bob,sid_5),g))),encrypt(hmac_hash2(hmac_hash1(hash(somename,empty),dhexp_real(key_e(alice,bob,sid_5),dhexp_real(key_s(bob),g))),dhexp_real(key_e(alice,bob,sid_5),dhexp_real(key_m(bob),g))),minnonce,hash(hash(hash(hash(hash(somename,empty),empty),validkey(dhexp_real(key_s(bob),g))),validkey(dhexp_real(key_m(bob),g))),validkey(dhexp_real(key_e(alice,bob,sid_5),g))),validkey(dhexp_real(key_s(alice),g)))),encrypt(hmac_hash2(hmac_hash1(hash(somename,empty),dhexp_real(key_e(alice,bob,sid_5),dhexp_real(key_s(bob),g))),dhexp_real(key_e(alice,bob,sid_5),dhexp_real(key_m(bob),g))),increment_nonce(minnonce),hash(hash(hash(hash(hash(hash(somename,empty),empty),validkey(dhexp_real(key_s(bob),g))),validkey(dhexp_real(key_m(bob),g))),validkey(dhexp_real(key_e(alice,bob,sid_5),g))),encrypt(hmac_hash2(hmac_hash1(hash(somename,empty),dhexp_real(key_e(alice,bob,sid_5),dhexp_real(key_s(bob),g))),dhexp_real(key_e(alice,bob,sid_5),dhexp_real(key_m(bob),g))),minnonce,hash(hash(hash(hash(hash(somename,empty),empty),validkey(dhexp_real(key_s(bob),g))),validkey(dhexp_real(key_m(bob),g))),validkey(dhexp_real(key_e(alice,bob,sid_5),g))),validkey(dhexp_real(key_s(alice),g)))),validkey(dhexp_real(key_m(alice),g))))).

25. By 24, the attacker may know hash(hash(hash(hash(hash(hash(hash(somename,empty),empty),validkey(dhexp_real(key_s(bob),g))),validkey(dhexp_real(key_m(bob),g))),validkey(dhexp_real(key_e(alice,bob,sid_5),g))),encrypt(hmac_hash2(hmac_hash1(hash(somename,empty),dhexp_real(key_e(alice,bob,sid_5),dhexp_real(key_s(bob),g))),dhexp_real(key_e(alice,bob,sid_5),dhexp_real(key_m(bob),g))),minnonce,hash(hash(hash(hash(hash(somename,empty),empty),validkey(dhexp_real(key_s(bob),g))),validkey(dhexp_real(key_m(bob),g))),validkey(dhexp_real(key_e(alice,bob,sid_5),g))),validkey(dhexp_real(key_s(alice),g)))),encrypt(hmac_hash2(hmac_hash1(hash(somename,empty),dhexp_real(key_e(alice,bob,sid_5),dhexp_real(key_s(bob),g))),dhexp_real(key_e(alice,bob,sid_5),dhexp_real(key_m(bob),g))),increment_nonce(minnonce),hash(hash(hash(hash(hash(hash(somename,empty),empty),validkey(dhexp_real(key_s(bob),g))),validkey(dhexp_real(key_m(bob),g))),validkey(dhexp_real(key_e(alice,bob,sid_5),g))),encrypt(hmac_hash2(hmac_hash1(hash(somename,empty),dhexp_real(key_e(alice,bob,sid_5),dhexp_real(key_s(bob),g))),dhexp_real(key_e(alice,bob,sid_5),dhexp_real(key_m(bob),g))),minnonce,hash(hash(hash(hash(hash(somename,empty),empty),validkey(dhexp_real(key_s(bob),g))),validkey(dhexp_real(key_m(bob),g))),validkey(dhexp_real(key_e(alice,bob,sid_5),g))),validkey(dhexp_real(key_s(alice),g)))),validkey(dhexp_real(key_m(alice),g)))).
So the attacker may know hash(hash(hash(hash(hash(hash(hash(somename,empty),empty),validkey(dhexp_real(key_s(bob),g))),validkey(dhexp_real(key_m(bob),g))),validkey(dhexp_real(key_e(alice,bob,sid_5),g))),encrypt(hmac_hash2(hmac_hash1(hash(somename,empty),dhexp_real(key_e(alice,bob,sid_5),dhexp_real(key_s(bob),g))),dhexp_real(key_e(alice,bob,sid_5),dhexp_real(key_m(bob),g))),minnonce,hash(hash(hash(hash(hash(somename,empty),empty),validkey(dhexp_real(key_s(bob),g))),validkey(dhexp_real(key_m(bob),g))),validkey(dhexp_real(key_e(alice,bob,sid_5),g))),validkey(dhexp_real(key_s(alice),g)))),encrypt(hmac_hash2(hmac_hash1(hash(somename,empty),dhexp_real(key_e(alice,bob,sid_5),dhexp_real(key_s(bob),g))),dhexp_real(key_e(alice,bob,sid_5),dhexp_real(key_m(bob),g))),increment_nonce(minnonce),hash(hash(hash(hash(hash(hash(somename,empty),empty),validkey(dhexp_real(key_s(bob),g))),validkey(dhexp_real(key_m(bob),g))),validkey(dhexp_real(key_e(alice,bob,sid_5),g))),encrypt(hmac_hash2(hmac_hash1(hash(somename,empty),dhexp_real(key_e(alice,bob,sid_5),dhexp_real(key_s(bob),g))),dhexp_real(key_e(alice,bob,sid_5),dhexp_real(key_m(bob),g))),minnonce,hash(hash(hash(hash(hash(somename,empty),empty),validkey(dhexp_real(key_s(bob),g))),validkey(dhexp_real(key_m(bob),g))),validkey(dhexp_real(key_e(alice,bob,sid_5),g))),validkey(dhexp_real(key_s(alice),g)))),validkey(dhexp_real(key_m(alice),g)))) in phase 1.
attacker_p1(hash(hash(hash(hash(hash(hash(hash(somename,empty),empty),validkey(dhexp_real(key_s(bob),g))),validkey(dhexp_real(key_m(bob),g))),validkey(dhexp_real(key_e(alice,bob,sid_5),g))),encrypt(hmac_hash2(hmac_hash1(hash(somename,empty),dhexp_real(key_e(alice,bob,sid_5),dhexp_real(key_s(bob),g))),dhexp_real(key_e(alice,bob,sid_5),dhexp_real(key_m(bob),g))),minnonce,hash(hash(hash(hash(hash(somename,empty),empty),validkey(dhexp_real(key_s(bob),g))),validkey(dhexp_real(key_m(bob),g))),validkey(dhexp_real(key_e(alice,bob,sid_5),g))),validkey(dhexp_real(key_s(alice),g)))),encrypt(hmac_hash2(hmac_hash1(hash(somename,empty),dhexp_real(key_e(alice,bob,sid_5),dhexp_real(key_s(bob),g))),dhexp_real(key_e(alice,bob,sid_5),dhexp_real(key_m(bob),g))),increment_nonce(minnonce),hash(hash(hash(hash(hash(hash(somename,empty),empty),validkey(dhexp_real(key_s(bob),g))),validkey(dhexp_real(key_m(bob),g))),validkey(dhexp_real(key_e(alice,bob,sid_5),g))),encrypt(hmac_hash2(hmac_hash1(hash(somename,empty),dhexp_real(key_e(alice,bob,sid_5),dhexp_real(key_s(bob),g))),dhexp_real(key_e(alice,bob,sid_5),dhexp_real(key_m(bob),g))),minnonce,hash(hash(hash(hash(hash(somename,empty),empty),validkey(dhexp_real(key_s(bob),g))),validkey(dhexp_real(key_m(bob),g))),validkey(dhexp_real(key_e(alice,bob,sid_5),g))),validkey(dhexp_real(key_s(alice),g)))),validkey(dhexp_real(key_m(alice),g))))).

26. Using the function minnonce the attacker may obtain minnonce in phase 1.
attacker_p1(minnonce).

27. By 10, the attacker may know encrypt(hmac_hash2(hmac_hash1(hash(somename,empty),dhexp_real(key_e(alice,bob,sid_5),dhexp_real(key_s(bob),g))),dhexp_real(key_e(alice,bob,sid_5),dhexp_real(key_m(bob),g))),minnonce,hash(hash(hash(hash(hash(somename,empty),empty),validkey(dhexp_real(key_s(bob),g))),validkey(dhexp_real(key_m(bob),g))),validkey(dhexp_real(key_e(alice,bob,sid_5),g))),validkey(dhexp_real(key_s(alice),g))).
So the attacker may know encrypt(hmac_hash2(hmac_hash1(hash(somename,empty),dhexp_real(key_e(alice,bob,sid_5),dhexp_real(key_s(bob),g))),dhexp_real(key_e(alice,bob,sid_5),dhexp_real(key_m(bob),g))),minnonce,hash(hash(hash(hash(hash(somename,empty),empty),validkey(dhexp_real(key_s(bob),g))),validkey(dhexp_real(key_m(bob),g))),validkey(dhexp_real(key_e(alice,bob,sid_5),g))),validkey(dhexp_real(key_s(alice),g))) in phase 1.
attacker_p1(encrypt(hmac_hash2(hmac_hash1(hash(somename,empty),dhexp_real(key_e(alice,bob,sid_5),dhexp_real(key_s(bob),g))),dhexp_real(key_e(alice,bob,sid_5),dhexp_real(key_m(bob),g))),minnonce,hash(hash(hash(hash(hash(somename,empty),empty),validkey(dhexp_real(key_s(bob),g))),validkey(dhexp_real(key_m(bob),g))),validkey(dhexp_real(key_e(alice,bob,sid_5),g))),validkey(dhexp_real(key_s(alice),g)))).

28. By 22, the attacker may know hash(hash(hash(hash(hash(somename,empty),empty),validkey(dhexp_real(key_s(bob),g))),validkey(dhexp_real(key_m(bob),g))),validkey(dhexp_real(key_e(alice,bob,sid_5),g))).
So the attacker may know hash(hash(hash(hash(hash(somename,empty),empty),validkey(dhexp_real(key_s(bob),g))),validkey(dhexp_real(key_m(bob),g))),validkey(dhexp_real(key_e(alice,bob,sid_5),g))) in phase 1.
attacker_p1(hash(hash(hash(hash(hash(somename,empty),empty),validkey(dhexp_real(key_s(bob),g))),validkey(dhexp_real(key_m(bob),g))),validkey(dhexp_real(key_e(alice,bob,sid_5),g)))).

29. By 11, the attacker may know validkey(dhexp_real(key_e(alice,bob,sid_5),g)).
So the attacker may know validkey(dhexp_real(key_e(alice,bob,sid_5),g)) in phase 1.
attacker_p1(validkey(dhexp_real(key_e(alice,bob,sid_5),g))).

30. Using the function pub the attacker may obtain pub in phase 1.
attacker_p1(pub).

31. The event LeakS(phase1,bob) may be executed at {949}.
The event LeakM(phase1,bob) may be executed at {950}.
So the message (key_s(bob),key_m(bob)) may be sent on channel pub in phase 1 at output {951}.
mess_p1(pub,(key_s(bob),key_m(bob))).

32. By 30, the attacker may have the channel pub in phase 1.
By 31, the message (key_s(bob),key_m(bob)) in phase 1 may be sent on this channel.
So the attacker may obtain the message (key_s(bob),key_m(bob)) in phase 1 by listening on this channel.
attacker_p1((key_s(bob),key_m(bob))).

33. By 32, the attacker may know (key_s(bob),key_m(bob)) in phase 1.
Using the function 2-proj-2-tuple the attacker may obtain key_m(bob) in phase 1.
attacker_p1(key_m(bob)).

34. By 33, the attacker may know key_m(bob) in phase 1.
By 29, the attacker may know validkey(dhexp_real(key_e(alice,bob,sid_5),g)) in phase 1.
Using the function dhexp the attacker may obtain dhexp_real(key_e(alice,bob,sid_5),dhexp_real(key_m(bob),g)) in phase 1.
attacker_p1(dhexp_real(key_e(alice,bob,sid_5),dhexp_real(key_m(bob),g))).

35. By 32, the attacker may know (key_s(bob),key_m(bob)) in phase 1.
Using the function 1-proj-2-tuple the attacker may obtain key_s(bob) in phase 1.
attacker_p1(key_s(bob)).

36. By 35, the attacker may know key_s(bob) in phase 1.
By 29, the attacker may know validkey(dhexp_real(key_e(alice,bob,sid_5),g)) in phase 1.
Using the function dhexp the attacker may obtain dhexp_real(key_e(alice,bob,sid_5),dhexp_real(key_s(bob),g)) in phase 1.
attacker_p1(dhexp_real(key_e(alice,bob,sid_5),dhexp_real(key_s(bob),g))).

37. Using the function empty the attacker may obtain empty in phase 1.
attacker_p1(empty).

38. Using the function somename the attacker may obtain somename in phase 1.
attacker_p1(somename).

39. By 38, the attacker may know somename in phase 1.
By 37, the attacker may know empty in phase 1.
Using the function hash the attacker may obtain hash(somename,empty) in phase 1.
attacker_p1(hash(somename,empty)).

40. By 39, the attacker may know hash(somename,empty) in phase 1.
By 36, the attacker may know dhexp_real(key_e(alice,bob,sid_5),dhexp_real(key_s(bob),g)) in phase 1.
Using the function hmac_hash1 the attacker may obtain hmac_hash1(hash(somename,empty),dhexp_real(key_e(alice,bob,sid_5),dhexp_real(key_s(bob),g))) in phase 1.
attacker_p1(hmac_hash1(hash(somename,empty),dhexp_real(key_e(alice,bob,sid_5),dhexp_real(key_s(bob),g)))).

41. By 40, the attacker may know hmac_hash1(hash(somename,empty),dhexp_real(key_e(alice,bob,sid_5),dhexp_real(key_s(bob),g))) in phase 1.
By 34, the attacker may know dhexp_real(key_e(alice,bob,sid_5),dhexp_real(key_m(bob),g)) in phase 1.
Using the function hmac_hash2 the attacker may obtain hmac_hash2(hmac_hash1(hash(somename,empty),dhexp_real(key_e(alice,bob,sid_5),dhexp_real(key_s(bob),g))),dhexp_real(key_e(alice,bob,sid_5),dhexp_real(key_m(bob),g))) in phase 1.
attacker_p1(hmac_hash2(hmac_hash1(hash(somename,empty),dhexp_real(key_e(alice,bob,sid_5),dhexp_real(key_s(bob),g))),dhexp_real(key_e(alice,bob,sid_5),dhexp_real(key_m(bob),g)))).

42. By 41, the attacker may know hmac_hash2(hmac_hash1(hash(somename,empty),dhexp_real(key_e(alice,bob,sid_5),dhexp_real(key_s(bob),g))),dhexp_real(key_e(alice,bob,sid_5),dhexp_real(key_m(bob),g))) in phase 1.
By 26, the attacker may know minnonce in phase 1.
By 28, the attacker may know hash(hash(hash(hash(hash(somename,empty),empty),validkey(dhexp_real(key_s(bob),g))),validkey(dhexp_real(key_m(bob),g))),validkey(dhexp_real(key_e(alice,bob,sid_5),g))) in phase 1.
By 27, the attacker may know encrypt(hmac_hash2(hmac_hash1(hash(somename,empty),dhexp_real(key_e(alice,bob,sid_5),dhexp_real(key_s(bob),g))),dhexp_real(key_e(alice,bob,sid_5),dhexp_real(key_m(bob),g))),minnonce,hash(hash(hash(hash(hash(somename,empty),empty),validkey(dhexp_real(key_s(bob),g))),validkey(dhexp_real(key_m(bob),g))),validkey(dhexp_real(key_e(alice,bob,sid_5),g))),validkey(dhexp_real(key_s(alice),g))) in phase 1.
Using the function decrypt the attacker may obtain aeadpack(true,hash(hash(hash(hash(hash(somename,empty),empty),validkey(dhexp_real(key_s(bob),g))),validkey(dhexp_real(key_m(bob),g))),validkey(dhexp_real(key_e(alice,bob,sid_5),g))),validkey(dhexp_real(key_s(alice),g))) in phase 1.
attacker_p1(aeadpack(true,hash(hash(hash(hash(hash(somename,empty),empty),validkey(dhexp_real(key_s(bob),g))),validkey(dhexp_real(key_m(bob),g))),validkey(dhexp_real(key_e(alice,bob,sid_5),g))),validkey(dhexp_real(key_s(alice),g)))).

43. By 42, the attacker may know aeadpack(true,hash(hash(hash(hash(hash(somename,empty),empty),validkey(dhexp_real(key_s(bob),g))),validkey(dhexp_real(key_m(bob),g))),validkey(dhexp_real(key_e(alice,bob,sid_5),g))),validkey(dhexp_real(key_s(alice),g))) in phase 1.
Using the function 3-proj-aeadpack the attacker may obtain validkey(dhexp_real(key_s(alice),g)) in phase 1.
attacker_p1(validkey(dhexp_real(key_s(alice),g))).

44. By 33, the attacker may know key_m(bob) in phase 1.
By 43, the attacker may know validkey(dhexp_real(key_s(alice),g)) in phase 1.
Using the function dhexp the attacker may obtain dhexp_real(key_m(bob),dhexp_real(key_s(alice),g)) in phase 1.
attacker_p1(dhexp_real(key_m(bob),dhexp_real(key_s(alice),g))).

45. By 9, the attacker may know encrypt(hmac_hash2(hmac_hash1(hash(somename,empty),dhexp_real(key_e(alice,bob,sid_5),dhexp_real(key_s(bob),g))),dhexp_real(key_e(alice,bob,sid_5),dhexp_real(key_m(bob),g))),increment_nonce(minnonce),hash(hash(hash(hash(hash(hash(somename,empty),empty),validkey(dhexp_real(key_s(bob),g))),validkey(dhexp_real(key_m(bob),g))),validkey(dhexp_real(key_e(alice,bob,sid_5),g))),encrypt(hmac_hash2(hmac_hash1(hash(somename,empty),dhexp_real(key_e(alice,bob,sid_5),dhexp_real(key_s(bob),g))),dhexp_real(key_e(alice,bob,sid_5),dhexp_real(key_m(bob),g))),minnonce,hash(hash(hash(hash(hash(somename,empty),empty),validkey(dhexp_real(key_s(bob),g))),validkey(dhexp_real(key_m(bob),g))),validkey(dhexp_real(key_e(alice,bob,sid_5),g))),validkey(dhexp_real(key_s(alice),g)))),validkey(dhexp_real(key_m(alice),g))).
So the attacker may know encrypt(hmac_hash2(hmac_hash1(hash(somename,empty),dhexp_real(key_e(alice,bob,sid_5),dhexp_real(key_s(bob),g))),dhexp_real(key_e(alice,bob,sid_5),dhexp_real(key_m(bob),g))),increment_nonce(minnonce),hash(hash(hash(hash(hash(hash(somename,empty),empty),validkey(dhexp_real(key_s(bob),g))),validkey(dhexp_real(key_m(bob),g))),validkey(dhexp_real(key_e(alice,bob,sid_5),g))),encrypt(hmac_hash2(hmac_hash1(hash(somename,empty),dhexp_real(key_e(alice,bob,sid_5),dhexp_real(key_s(bob),g))),dhexp_real(key_e(alice,bob,sid_5),dhexp_real(key_m(bob),g))),minnonce,hash(hash(hash(hash(hash(somename,empty),empty),validkey(dhexp_real(key_s(bob),g))),validkey(dhexp_real(key_m(bob),g))),validkey(dhexp_real(key_e(alice,bob,sid_5),g))),validkey(dhexp_real(key_s(alice),g)))),validkey(dhexp_real(key_m(alice),g))) in phase 1.
attacker_p1(encrypt(hmac_hash2(hmac_hash1(hash(somename,empty),dhexp_real(key_e(alice,bob,sid_5),dhexp_real(key_s(bob),g))),dhexp_real(key_e(alice,bob,sid_5),dhexp_real(key_m(bob),g))),increment_nonce(minnonce),hash(hash(hash(hash(hash(hash(somename,empty),empty),validkey(dhexp_real(key_s(bob),g))),validkey(dhexp_real(key_m(bob),g))),validkey(dhexp_real(key_e(alice,bob,sid_5),g))),encrypt(hmac_hash2(hmac_hash1(hash(somename,empty),dhexp_real(key_e(alice,bob,sid_5),dhexp_real(key_s(bob),g))),dhexp_real(key_e(alice,bob,sid_5),dhexp_real(key_m(bob),g))),minnonce,hash(hash(hash(hash(hash(somename,empty),empty),validkey(dhexp_real(key_s(bob),g))),validkey(dhexp_real(key_m(bob),g))),validkey(dhexp_real(key_e(alice,bob,sid_5),g))),validkey(dhexp_real(key_s(alice),g)))),validkey(dhexp_real(key_m(alice),g)))).

46. By 23, the attacker may know hash(hash(hash(hash(hash(hash(somename,empty),empty),validkey(dhexp_real(key_s(bob),g))),validkey(dhexp_real(key_m(bob),g))),validkey(dhexp_real(key_e(alice,bob,sid_5),g))),encrypt(hmac_hash2(hmac_hash1(hash(somename,empty),dhexp_real(key_e(alice,bob,sid_5),dhexp_real(key_s(bob),g))),dhexp_real(key_e(alice,bob,sid_5),dhexp_real(key_m(bob),g))),minnonce,hash(hash(hash(hash(hash(somename,empty),empty),validkey(dhexp_real(key_s(bob),g))),validkey(dhexp_real(key_m(bob),g))),validkey(dhexp_real(key_e(alice,bob,sid_5),g))),validkey(dhexp_real(key_s(alice),g)))).
So the attacker may know hash(hash(hash(hash(hash(hash(somename,empty),empty),validkey(dhexp_real(key_s(bob),g))),validkey(dhexp_real(key_m(bob),g))),validkey(dhexp_real(key_e(alice,bob,sid_5),g))),encrypt(hmac_hash2(hmac_hash1(hash(somename,empty),dhexp_real(key_e(alice,bob,sid_5),dhexp_real(key_s(bob),g))),dhexp_real(key_e(alice,bob,sid_5),dhexp_real(key_m(bob),g))),minnonce,hash(hash(hash(hash(hash(somename,empty),empty),validkey(dhexp_real(key_s(bob),g))),validkey(dhexp_real(key_m(bob),g))),validkey(dhexp_real(key_e(alice,bob,sid_5),g))),validkey(dhexp_real(key_s(alice),g)))) in phase 1.
attacker_p1(hash(hash(hash(hash(hash(hash(somename,empty),empty),validkey(dhexp_real(key_s(bob),g))),validkey(dhexp_real(key_m(bob),g))),validkey(dhexp_real(key_e(alice,bob,sid_5),g))),encrypt(hmac_hash2(hmac_hash1(hash(somename,empty),dhexp_real(key_e(alice,bob,sid_5),dhexp_real(key_s(bob),g))),dhexp_real(key_e(alice,bob,sid_5),dhexp_real(key_m(bob),g))),minnonce,hash(hash(hash(hash(hash(somename,empty),empty),validkey(dhexp_real(key_s(bob),g))),validkey(dhexp_real(key_m(bob),g))),validkey(dhexp_real(key_e(alice,bob,sid_5),g))),validkey(dhexp_real(key_s(alice),g))))).

47. By 26, the attacker may know minnonce in phase 1.
Using the function increment_nonce the attacker may obtain increment_nonce(minnonce) in phase 1.
attacker_p1(increment_nonce(minnonce)).

48. By 41, the attacker may know hmac_hash2(hmac_hash1(hash(somename,empty),dhexp_real(key_e(alice,bob,sid_5),dhexp_real(key_s(bob),g))),dhexp_real(key_e(alice,bob,sid_5),dhexp_real(key_m(bob),g))) in phase 1.
By 47, the attacker may know increment_nonce(minnonce) in phase 1.
By 46, the attacker may know hash(hash(hash(hash(hash(hash(somename,empty),empty),validkey(dhexp_real(key_s(bob),g))),validkey(dhexp_real(key_m(bob),g))),validkey(dhexp_real(key_e(alice,bob,sid_5),g))),encrypt(hmac_hash2(hmac_hash1(hash(somename,empty),dhexp_real(key_e(alice,bob,sid_5),dhexp_real(key_s(bob),g))),dhexp_real(key_e(alice,bob,sid_5),dhexp_real(key_m(bob),g))),minnonce,hash(hash(hash(hash(hash(somename,empty),empty),validkey(dhexp_real(key_s(bob),g))),validkey(dhexp_real(key_m(bob),g))),validkey(dhexp_real(key_e(alice,bob,sid_5),g))),validkey(dhexp_real(key_s(alice),g)))) in phase 1.
By 45, the attacker may know encrypt(hmac_hash2(hmac_hash1(hash(somename,empty),dhexp_real(key_e(alice,bob,sid_5),dhexp_real(key_s(bob),g))),dhexp_real(key_e(alice,bob,sid_5),dhexp_real(key_m(bob),g))),increment_nonce(minnonce),hash(hash(hash(hash(hash(hash(somename,empty),empty),validkey(dhexp_real(key_s(bob),g))),validkey(dhexp_real(key_m(bob),g))),validkey(dhexp_real(key_e(alice,bob,sid_5),g))),encrypt(hmac_hash2(hmac_hash1(hash(somename,empty),dhexp_real(key_e(alice,bob,sid_5),dhexp_real(key_s(bob),g))),dhexp_real(key_e(alice,bob,sid_5),dhexp_real(key_m(bob),g))),minnonce,hash(hash(hash(hash(hash(somename,empty),empty),validkey(dhexp_real(key_s(bob),g))),validkey(dhexp_real(key_m(bob),g))),validkey(dhexp_real(key_e(alice,bob,sid_5),g))),validkey(dhexp_real(key_s(alice),g)))),validkey(dhexp_real(key_m(alice),g))) in phase 1.
Using the function decrypt the attacker may obtain aeadpack(true,hash(hash(hash(hash(hash(hash(somename,empty),empty),validkey(dhexp_real(key_s(bob),g))),validkey(dhexp_real(key_m(bob),g))),validkey(dhexp_real(key_e(alice,bob,sid_5),g))),encrypt(hmac_hash2(hmac_hash1(hash(somename,empty),dhexp_real(key_e(alice,bob,sid_5),dhexp_real(key_s(bob),g))),dhexp_real(key_e(alice,bob,sid_5),dhexp_real(key_m(bob),g))),minnonce,hash(hash(hash(hash(hash(somename,empty),empty),validkey(dhexp_real(key_s(bob),g))),validkey(dhexp_real(key_m(bob),g))),validkey(dhexp_real(key_e(alice,bob,sid_5),g))),validkey(dhexp_real(key_s(alice),g)))),validkey(dhexp_real(key_m(alice),g))) in phase 1.
attacker_p1(aeadpack(true,hash(hash(hash(hash(hash(hash(somename,empty),empty),validkey(dhexp_real(key_s(bob),g))),validkey(dhexp_real(key_m(bob),g))),validkey(dhexp_real(key_e(alice,bob,sid_5),g))),encrypt(hmac_hash2(hmac_hash1(hash(somename,empty),dhexp_real(key_e(alice,bob,sid_5),dhexp_real(key_s(bob),g))),dhexp_real(key_e(alice,bob,sid_5),dhexp_real(key_m(bob),g))),minnonce,hash(hash(hash(hash(hash(somename,empty),empty),validkey(dhexp_real(key_s(bob),g))),validkey(dhexp_real(key_m(bob),g))),validkey(dhexp_real(key_e(alice,bob,sid_5),g))),validkey(dhexp_real(key_s(alice),g)))),validkey(dhexp_real(key_m(alice),g)))).

49. By 48, the attacker may know aeadpack(true,hash(hash(hash(hash(hash(hash(somename,empty),empty),validkey(dhexp_real(key_s(bob),g))),validkey(dhexp_real(key_m(bob),g))),validkey(dhexp_real(key_e(alice,bob,sid_5),g))),encrypt(hmac_hash2(hmac_hash1(hash(somename,empty),dhexp_real(key_e(alice,bob,sid_5),dhexp_real(key_s(bob),g))),dhexp_real(key_e(alice,bob,sid_5),dhexp_real(key_m(bob),g))),minnonce,hash(hash(hash(hash(hash(somename,empty),empty),validkey(dhexp_real(key_s(bob),g))),validkey(dhexp_real(key_m(bob),g))),validkey(dhexp_real(key_e(alice,bob,sid_5),g))),validkey(dhexp_real(key_s(alice),g)))),validkey(dhexp_real(key_m(alice),g))) in phase 1.
Using the function 3-proj-aeadpack the attacker may obtain validkey(dhexp_real(key_m(alice),g)) in phase 1.
attacker_p1(validkey(dhexp_real(key_m(alice),g))).

50. By 35, the attacker may know key_s(bob) in phase 1.
By 49, the attacker may know validkey(dhexp_real(key_m(alice),g)) in phase 1.
Using the function dhexp the attacker may obtain dhexp_real(key_m(alice),dhexp_real(key_s(bob),g)) in phase 1.
attacker_p1(dhexp_real(key_m(alice),dhexp_real(key_s(bob),g))).

51. By 40, the attacker may know hmac_hash1(hash(somename,empty),dhexp_real(key_e(alice,bob,sid_5),dhexp_real(key_s(bob),g))) in phase 1.
By 34, the attacker may know dhexp_real(key_e(alice,bob,sid_5),dhexp_real(key_m(bob),g)) in phase 1.
Using the function hmac_hash1 the attacker may obtain hmac_hash1(hmac_hash1(hash(somename,empty),dhexp_real(key_e(alice,bob,sid_5),dhexp_real(key_s(bob),g))),dhexp_real(key_e(alice,bob,sid_5),dhexp_real(key_m(bob),g))) in phase 1.
attacker_p1(hmac_hash1(hmac_hash1(hash(somename,empty),dhexp_real(key_e(alice,bob,sid_5),dhexp_real(key_s(bob),g))),dhexp_real(key_e(alice,bob,sid_5),dhexp_real(key_m(bob),g)))).

52. By 51, the attacker may know hmac_hash1(hmac_hash1(hash(somename,empty),dhexp_real(key_e(alice,bob,sid_5),dhexp_real(key_s(bob),g))),dhexp_real(key_e(alice,bob,sid_5),dhexp_real(key_m(bob),g))) in phase 1.
By 50, the attacker may know dhexp_real(key_m(alice),dhexp_real(key_s(bob),g)) in phase 1.
Using the function hmac_hash1 the attacker may obtain hmac_hash1(hmac_hash1(hmac_hash1(hash(somename,empty),dhexp_real(key_e(alice,bob,sid_5),dhexp_real(key_s(bob),g))),dhexp_real(key_e(alice,bob,sid_5),dhexp_real(key_m(bob),g))),dhexp_real(key_m(alice),dhexp_real(key_s(bob),g))) in phase 1.
attacker_p1(hmac_hash1(hmac_hash1(hmac_hash1(hash(somename,empty),dhexp_real(key_e(alice,bob,sid_5),dhexp_real(key_s(bob),g))),dhexp_real(key_e(alice,bob,sid_5),dhexp_real(key_m(bob),g))),dhexp_real(key_m(alice),dhexp_real(key_s(bob),g)))).

53. By 52, the attacker may know hmac_hash1(hmac_hash1(hmac_hash1(hash(somename,empty),dhexp_real(key_e(alice,bob,sid_5),dhexp_real(key_s(bob),g))),dhexp_real(key_e(alice,bob,sid_5),dhexp_real(key_m(bob),g))),dhexp_real(key_m(alice),dhexp_real(key_s(bob),g))) in phase 1.
By 44, the attacker may know dhexp_real(key_m(bob),dhexp_real(key_s(alice),g)) in phase 1.
Using the function hmac_hash2 the attacker may obtain hmac_hash2(hmac_hash1(hmac_hash1(hmac_hash1(hash(somename,empty),dhexp_real(key_e(alice,bob,sid_5),dhexp_real(key_s(bob),g))),dhexp_real(key_e(alice,bob,sid_5),dhexp_real(key_m(bob),g))),dhexp_real(key_m(alice),dhexp_real(key_s(bob),g))),dhexp_real(key_m(bob),dhexp_real(key_s(alice),g))) in phase 1.
attacker_p1(hmac_hash2(hmac_hash1(hmac_hash1(hmac_hash1(hash(somename,empty),dhexp_real(key_e(alice,bob,sid_5),dhexp_real(key_s(bob),g))),dhexp_real(key_e(alice,bob,sid_5),dhexp_real(key_m(bob),g))),dhexp_real(key_m(alice),dhexp_real(key_s(bob),g))),dhexp_real(key_m(bob),dhexp_real(key_s(alice),g)))).

54. By 53, the attacker may know hmac_hash2(hmac_hash1(hmac_hash1(hmac_hash1(hash(somename,empty),dhexp_real(key_e(alice,bob,sid_5),dhexp_real(key_s(bob),g))),dhexp_real(key_e(alice,bob,sid_5),dhexp_real(key_m(bob),g))),dhexp_real(key_m(alice),dhexp_real(key_s(bob),g))),dhexp_real(key_m(bob),dhexp_real(key_s(alice),g))) in phase 1.
By 26, the attacker may know minnonce in phase 1.
By 25, the attacker may know hash(hash(hash(hash(hash(hash(hash(somename,empty),empty),validkey(dhexp_real(key_s(bob),g))),validkey(dhexp_real(key_m(bob),g))),validkey(dhexp_real(key_e(alice,bob,sid_5),g))),encrypt(hmac_hash2(hmac_hash1(hash(somename,empty),dhexp_real(key_e(alice,bob,sid_5),dhexp_real(key_s(bob),g))),dhexp_real(key_e(alice,bob,sid_5),dhexp_real(key_m(bob),g))),minnonce,hash(hash(hash(hash(hash(somename,empty),empty),validkey(dhexp_real(key_s(bob),g))),validkey(dhexp_real(key_m(bob),g))),validkey(dhexp_real(key_e(alice,bob,sid_5),g))),validkey(dhexp_real(key_s(alice),g)))),encrypt(hmac_hash2(hmac_hash1(hash(somename,empty),dhexp_real(key_e(alice,bob,sid_5),dhexp_real(key_s(bob),g))),dhexp_real(key_e(alice,bob,sid_5),dhexp_real(key_m(bob),g))),increment_nonce(minnonce),hash(hash(hash(hash(hash(hash(somename,empty),empty),validkey(dhexp_real(key_s(bob),g))),validkey(dhexp_real(key_m(bob),g))),validkey(dhexp_real(key_e(alice,bob,sid_5),g))),encrypt(hmac_hash2(hmac_hash1(hash(somename,empty),dhexp_real(key_e(alice,bob,sid_5),dhexp_real(key_s(bob),g))),dhexp_real(key_e(alice,bob,sid_5),dhexp_real(key_m(bob),g))),minnonce,hash(hash(hash(hash(hash(somename,empty),empty),validkey(dhexp_real(key_s(bob),g))),validkey(dhexp_real(key_m(bob),g))),validkey(dhexp_real(key_e(alice,bob,sid_5),g))),validkey(dhexp_real(key_s(alice),g)))),validkey(dhexp_real(key_m(alice),g)))) in phase 1.
By 6, the attacker may know encrypt(hmac_hash2(hmac_hash1(hmac_hash1(hmac_hash1(hash(somename,empty),dhexp_real(key_e(alice,bob,sid_5),dhexp_real(key_s(bob),g))),dhexp_real(key_e(alice,bob,sid_5),dhexp_real(key_m(bob),g))),dhexp_real(key_m(alice),dhexp_real(key_s(bob),g))),dhexp_real(key_m(bob),dhexp_real(key_s(alice),g))),minnonce,hash(hash(hash(hash(hash(hash(hash(somename,empty),empty),validkey(dhexp_real(key_s(bob),g))),validkey(dhexp_real(key_m(bob),g))),validkey(dhexp_real(key_e(alice,bob,sid_5),g))),encrypt(hmac_hash2(hmac_hash1(hash(somename,empty),dhexp_real(key_e(alice,bob,sid_5),dhexp_real(key_s(bob),g))),dhexp_real(key_e(alice,bob,sid_5),dhexp_real(key_m(bob),g))),minnonce,hash(hash(hash(hash(hash(somename,empty),empty),validkey(dhexp_real(key_s(bob),g))),validkey(dhexp_real(key_m(bob),g))),validkey(dhexp_real(key_e(alice,bob,sid_5),g))),validkey(dhexp_real(key_s(alice),g)))),encrypt(hmac_hash2(hmac_hash1(hash(somename,empty),dhexp_real(key_e(alice,bob,sid_5),dhexp_real(key_s(bob),g))),dhexp_real(key_e(alice,bob,sid_5),dhexp_real(key_m(bob),g))),increment_nonce(minnonce),hash(hash(hash(hash(hash(hash(somename,empty),empty),validkey(dhexp_real(key_s(bob),g))),validkey(dhexp_real(key_m(bob),g))),validkey(dhexp_real(key_e(alice,bob,sid_5),g))),encrypt(hmac_hash2(hmac_hash1(hash(somename,empty),dhexp_real(key_e(alice,bob,sid_5),dhexp_real(key_s(bob),g))),dhexp_real(key_e(alice,bob,sid_5),dhexp_real(key_m(bob),g))),minnonce,hash(hash(hash(hash(hash(somename,empty),empty),validkey(dhexp_real(key_s(bob),g))),validkey(dhexp_real(key_m(bob),g))),validkey(dhexp_real(key_e(alice,bob,sid_5),g))),validkey(dhexp_real(key_s(alice),g)))),validkey(dhexp_real(key_m(alice),g)))),msg_a(alice,bob,sid_5)) in phase 1.
Using the function decrypt the attacker may obtain aeadpack(true,hash(hash(hash(hash(hash(hash(hash(somename,empty),empty),validkey(dhexp_real(key_s(bob),g))),validkey(dhexp_real(key_m(bob),g))),validkey(dhexp_real(key_e(alice,bob,sid_5),g))),encrypt(hmac_hash2(hmac_hash1(hash(somename,empty),dhexp_real(key_e(alice,bob,sid_5),dhexp_real(key_s(bob),g))),dhexp_real(key_e(alice,bob,sid_5),dhexp_real(key_m(bob),g))),minnonce,hash(hash(hash(hash(hash(somename,empty),empty),validkey(dhexp_real(key_s(bob),g))),validkey(dhexp_real(key_m(bob),g))),validkey(dhexp_real(key_e(alice,bob,sid_5),g))),validkey(dhexp_real(key_s(alice),g)))),encrypt(hmac_hash2(hmac_hash1(hash(somename,empty),dhexp_real(key_e(alice,bob,sid_5),dhexp_real(key_s(bob),g))),dhexp_real(key_e(alice,bob,sid_5),dhexp_real(key_m(bob),g))),increment_nonce(minnonce),hash(hash(hash(hash(hash(hash(somename,empty),empty),validkey(dhexp_real(key_s(bob),g))),validkey(dhexp_real(key_m(bob),g))),validkey(dhexp_real(key_e(alice,bob,sid_5),g))),encrypt(hmac_hash2(hmac_hash1(hash(somename,empty),dhexp_real(key_e(alice,bob,sid_5),dhexp_real(key_s(bob),g))),dhexp_real(key_e(alice,bob,sid_5),dhexp_real(key_m(bob),g))),minnonce,hash(hash(hash(hash(hash(somename,empty),empty),validkey(dhexp_real(key_s(bob),g))),validkey(dhexp_real(key_m(bob),g))),validkey(dhexp_real(key_e(alice,bob,sid_5),g))),validkey(dhexp_real(key_s(alice),g)))),validkey(dhexp_real(key_m(alice),g)))),msg_a(alice,bob,sid_5)) in phase 1.
attacker_p1(aeadpack(true,hash(hash(hash(hash(hash(hash(hash(somename,empty),empty),validkey(dhexp_real(key_s(bob),g))),validkey(dhexp_real(key_m(bob),g))),validkey(dhexp_real(key_e(alice,bob,sid_5),g))),encrypt(hmac_hash2(hmac_hash1(hash(somename,empty),dhexp_real(key_e(alice,bob,sid_5),dhexp_real(key_s(bob),g))),dhexp_real(key_e(alice,bob,sid_5),dhexp_real(key_m(bob),g))),minnonce,hash(hash(hash(hash(hash(somename,empty),empty),validkey(dhexp_real(key_s(bob),g))),validkey(dhexp_real(key_m(bob),g))),validkey(dhexp_real(key_e(alice,bob,sid_5),g))),validkey(dhexp_real(key_s(alice),g)))),encrypt(hmac_hash2(hmac_hash1(hash(somename,empty),dhexp_real(key_e(alice,bob,sid_5),dhexp_real(key_s(bob),g))),dhexp_real(key_e(alice,bob,sid_5),dhexp_real(key_m(bob),g))),increment_nonce(minnonce),hash(hash(hash(hash(hash(hash(somename,empty),empty),validkey(dhexp_real(key_s(bob),g))),validkey(dhexp_real(key_m(bob),g))),validkey(dhexp_real(key_e(alice,bob,sid_5),g))),encrypt(hmac_hash2(hmac_hash1(hash(somename,empty),dhexp_real(key_e(alice,bob,sid_5),dhexp_real(key_s(bob),g))),dhexp_real(key_e(alice,bob,sid_5),dhexp_real(key_m(bob),g))),minnonce,hash(hash(hash(hash(hash(somename,empty),empty),validkey(dhexp_real(key_s(bob),g))),validkey(dhexp_real(key_m(bob),g))),validkey(dhexp_real(key_e(alice,bob,sid_5),g))),validkey(dhexp_real(key_s(alice),g)))),validkey(dhexp_real(key_m(alice),g)))),msg_a(alice,bob,sid_5))).

55. By 54, the attacker may know aeadpack(true,hash(hash(hash(hash(hash(hash(hash(somename,empty),empty),validkey(dhexp_real(key_s(bob),g))),validkey(dhexp_real(key_m(bob),g))),validkey(dhexp_real(key_e(alice,bob,sid_5),g))),encrypt(hmac_hash2(hmac_hash1(hash(somename,empty),dhexp_real(key_e(alice,bob,sid_5),dhexp_real(key_s(bob),g))),dhexp_real(key_e(alice,bob,sid_5),dhexp_real(key_m(bob),g))),minnonce,hash(hash(hash(hash(hash(somename,empty),empty),validkey(dhexp_real(key_s(bob),g))),validkey(dhexp_real(key_m(bob),g))),validkey(dhexp_real(key_e(alice,bob,sid_5),g))),validkey(dhexp_real(key_s(alice),g)))),encrypt(hmac_hash2(hmac_hash1(hash(somename,empty),dhexp_real(key_e(alice,bob,sid_5),dhexp_real(key_s(bob),g))),dhexp_real(key_e(alice,bob,sid_5),dhexp_real(key_m(bob),g))),increment_nonce(minnonce),hash(hash(hash(hash(hash(hash(somename,empty),empty),validkey(dhexp_real(key_s(bob),g))),validkey(dhexp_real(key_m(bob),g))),validkey(dhexp_real(key_e(alice,bob,sid_5),g))),encrypt(hmac_hash2(hmac_hash1(hash(somename,empty),dhexp_real(key_e(alice,bob,sid_5),dhexp_real(key_s(bob),g))),dhexp_real(key_e(alice,bob,sid_5),dhexp_real(key_m(bob),g))),minnonce,hash(hash(hash(hash(hash(somename,empty),empty),validkey(dhexp_real(key_s(bob),g))),validkey(dhexp_real(key_m(bob),g))),validkey(dhexp_real(key_e(alice,bob,sid_5),g))),validkey(dhexp_real(key_s(alice),g)))),validkey(dhexp_real(key_m(alice),g)))),msg_a(alice,bob,sid_5)) in phase 1.
Using the function 3-proj-aeadpack the attacker may obtain msg_a(alice,bob,sid_5) in phase 1.
attacker_p1(msg_a(alice,bob,sid_5)).

56. By 55, attacker_p1(msg_a(alice,bob,sid_5)).
The goal is reached, represented in the following fact:
attacker_p1(msg_a(alice,bob,sid_5)).


RESULT attacker_p1(msg_a(alice,bob,sid_a)) ==> (event(LeakS(phase0,bob)) && event(LeakM(phase0,bob))) || (event(LeakS(px,bob)) && event(LeakM(px,bob)) && event(LeakS(pz,alice)) && event(LeakM(pz,alice))) cannot be proved.
Starting query attacker_p1(msg_a(alice,bob,sid_a)) ==> event(LeakS(phase0,bob)) && event(LeakM(phase0,bob))
goal reachable: begin(LeakM(phase1,bob)) && begin(LeakS(phase1,bob)) && begin(SendMsg(alice,bob,stagepack_a(sid_5),msg_a(alice,bob,sid_5))) -> attacker_p1(msg_a(alice,bob,sid_5))
Abbreviations:
sid_5 = sid[!1 = @sid]

Derivation:
Abbreviations:
sid_5 = sid[!1 = @sid]

1. Using the function pub the attacker may obtain pub.
attacker(pub).

2. The entry statestore(alice,bob,sid_5,statepack_a(handshakestatepack(symmetricstatepack(cipherstatepack(empty,minnonce),hash(somename,empty),hash(hash(hash(hash(somename,empty),empty),validkey(dhexp_real(key_s(bob),g))),validkey(dhexp_real(key_m(bob),g)))),keypairpack(empty,empty),keypairpack(empty,empty),keypairpack(empty,empty),validkey(dhexp_real(key_s(bob),g)),validkey(dhexp_real(key_m(bob),g)),empty,empty,true))) may be inserted in a table at insert {50}.
table(statestore(alice,bob,sid_5,statepack_a(handshakestatepack(symmetricstatepack(cipherstatepack(empty,minnonce),hash(somename,empty),hash(hash(hash(hash(somename,empty),empty),validkey(dhexp_real(key_s(bob),g))),validkey(dhexp_real(key_m(bob),g)))),keypairpack(empty,empty),keypairpack(empty,empty),keypairpack(empty,empty),validkey(dhexp_real(key_s(bob),g)),validkey(dhexp_real(key_m(bob),g)),empty,empty,true)))).

3. The entry statestore(alice,bob,sid_5,statepack_a(handshakestatepack(symmetricstatepack(cipherstatepack(empty,minnonce),hash(somename,empty),hash(hash(hash(hash(somename,empty),empty),validkey(dhexp_real(key_s(bob),g))),validkey(dhexp_real(key_m(bob),g)))),keypairpack(empty,empty),keypairpack(empty,empty),keypairpack(empty,empty),validkey(dhexp_real(key_s(bob),g)),validkey(dhexp_real(key_m(bob),g)),empty,empty,true))) that may be in a table by 2 may be read at get {306}.
The event SendMsg(alice,bob,stagepack_a(sid_5),msg_a(alice,bob,sid_5)) may be executed at {304}.
So the message concat4(validkey(dhexp_real(key_e(alice,bob,sid_5),g)),encrypt(hmac_hash2(hmac_hash1(hash(somename,empty),dhexp_real(key_e(alice,bob,sid_5),dhexp_real(key_s(bob),g))),dhexp_real(key_e(alice,bob,sid_5),dhexp_real(key_m(bob),g))),minnonce,hash(hash(hash(hash(hash(somename,empty),empty),validkey(dhexp_real(key_s(bob),g))),validkey(dhexp_real(key_m(bob),g))),validkey(dhexp_real(key_e(alice,bob,sid_5),g))),validkey(dhexp_real(key_s(alice),g))),encrypt(hmac_hash2(hmac_hash1(hash(somename,empty),dhexp_real(key_e(alice,bob,sid_5),dhexp_real(key_s(bob),g))),dhexp_real(key_e(alice,bob,sid_5),dhexp_real(key_m(bob),g))),increment_nonce(minnonce),hash(hash(hash(hash(hash(hash(somename,empty),empty),validkey(dhexp_real(key_s(bob),g))),validkey(dhexp_real(key_m(bob),g))),validkey(dhexp_real(key_e(alice,bob,sid_5),g))),encrypt(hmac_hash2(hmac_hash1(hash(somename,empty),dhexp_real(key_e(alice,bob,sid_5),dhexp_real(key_s(bob),g))),dhexp_real(key_e(alice,bob,sid_5),dhexp_real(key_m(bob),g))),minnonce,hash(hash(hash(hash(hash(somename,empty),empty),validkey(dhexp_real(key_s(bob),g))),validkey(dhexp_real(key_m(bob),g))),validkey(dhexp_real(key_e(alice,bob,sid_5),g))),validkey(dhexp_real(key_s(alice),g)))),validkey(dhexp_real(key_m(alice),g))),encrypt(hmac_hash2(hmac_hash1(hmac_hash1(hmac_hash1(hash(somename,empty),dhexp_real(key_e(alice,bob,sid_5),dhexp_real(key_s(bob),g))),dhexp_real(key_e(alice,bob,sid_5),dhexp_real(key_m(bob),g))),dhexp_real(key_m(alice),dhexp_real(key_s(bob),g))),dhexp_real(key_m(bob),dhexp_real(key_s(alice),g))),minnonce,hash(hash(hash(hash(hash(hash(hash(somename,empty),empty),validkey(dhexp_real(key_s(bob),g))),validkey(dhexp_real(key_m(bob),g))),validkey(dhexp_real(key_e(alice,bob,sid_5),g))),encrypt(hmac_hash2(hmac_hash1(hash(somename,empty),dhexp_real(key_e(alice,bob,sid_5),dhexp_real(key_s(bob),g))),dhexp_real(key_e(alice,bob,sid_5),dhexp_real(key_m(bob),g))),minnonce,hash(hash(hash(hash(hash(somename,empty),empty),validkey(dhexp_real(key_s(bob),g))),validkey(dhexp_real(key_m(bob),g))),validkey(dhexp_real(key_e(alice,bob,sid_5),g))),validkey(dhexp_real(key_s(alice),g)))),encrypt(hmac_hash2(hmac_hash1(hash(somename,empty),dhexp_real(key_e(alice,bob,sid_5),dhexp_real(key_s(bob),g))),dhexp_real(key_e(alice,bob,sid_5),dhexp_real(key_m(bob),g))),increment_nonce(minnonce),hash(hash(hash(hash(hash(hash(somename,empty),empty),validkey(dhexp_real(key_s(bob),g))),validkey(dhexp_real(key_m(bob),g))),validkey(dhexp_real(key_e(alice,bob,sid_5),g))),encrypt(hmac_hash2(hmac_hash1(hash(somename,empty),dhexp_real(key_e(alice,bob,sid_5),dhexp_real(key_s(bob),g))),dhexp_real(key_e(alice,bob,sid_5),dhexp_real(key_m(bob),g))),minnonce,hash(hash(hash(hash(hash(somename,empty),empty),validkey(dhexp_real(key_s(bob),g))),validkey(dhexp_real(key_m(bob),g))),validkey(dhexp_real(key_e(alice,bob,sid_5),g))),validkey(dhexp_real(key_s(alice),g)))),validkey(dhexp_real(key_m(alice),g)))),msg_a(alice,bob,sid_5))) may be sent on channel pub at output {305}.
mess(pub,concat4(validkey(dhexp_real(key_e(alice,bob,sid_5),g)),encrypt(hmac_hash2(hmac_hash1(hash(somename,empty),dhexp_real(key_e(alice,bob,sid_5),dhexp_real(key_s(bob),g))),dhexp_real(key_e(alice,bob,sid_5),dhexp_real(key_m(bob),g))),minnonce,hash(hash(hash(hash(hash(somename,empty),empty),validkey(dhexp_real(key_s(bob),g))),validkey(dhexp_real(key_m(bob),g))),validkey(dhexp_real(key_e(alice,bob,sid_5),g))),validkey(dhexp_real(key_s(alice),g))),encrypt(hmac_hash2(hmac_hash1(hash(somename,empty),dhexp_real(key_e(alice,bob,sid_5),dhexp_real(key_s(bob),g))),dhexp_real(key_e(alice,bob,sid_5),dhexp_real(key_m(bob),g))),increment_nonce(minnonce),hash(hash(hash(hash(hash(hash(somename,empty),empty),validkey(dhexp_real(key_s(bob),g))),validkey(dhexp_real(key_m(bob),g))),validkey(dhexp_real(key_e(alice,bob,sid_5),g))),encrypt(hmac_hash2(hmac_hash1(hash(somename,empty),dhexp_real(key_e(alice,bob,sid_5),dhexp_real(key_s(bob),g))),dhexp_real(key_e(alice,bob,sid_5),dhexp_real(key_m(bob),g))),minnonce,hash(hash(hash(hash(hash(somename,empty),empty),validkey(dhexp_real(key_s(bob),g))),validkey(dhexp_real(key_m(bob),g))),validkey(dhexp_real(key_e(alice,bob,sid_5),g))),validkey(dhexp_real(key_s(alice),g)))),validkey(dhexp_real(key_m(alice),g))),encrypt(hmac_hash2(hmac_hash1(hmac_hash1(hmac_hash1(hash(somename,empty),dhexp_real(key_e(alice,bob,sid_5),dhexp_real(key_s(bob),g))),dhexp_real(key_e(alice,bob,sid_5),dhexp_real(key_m(bob),g))),dhexp_real(key_m(alice),dhexp_real(key_s(bob),g))),dhexp_real(key_m(bob),dhexp_real(key_s(alice),g))),minnonce,hash(hash(hash(hash(hash(hash(hash(somename,empty),empty),validkey(dhexp_real(key_s(bob),g))),validkey(dhexp_real(key_m(bob),g))),validkey(dhexp_real(key_e(alice,bob,sid_5),g))),encrypt(hmac_hash2(hmac_hash1(hash(somename,empty),dhexp_real(key_e(alice,bob,sid_5),dhexp_real(key_s(bob),g))),dhexp_real(key_e(alice,bob,sid_5),dhexp_real(key_m(bob),g))),minnonce,hash(hash(hash(hash(hash(somename,empty),empty),validkey(dhexp_real(key_s(bob),g))),validkey(dhexp_real(key_m(bob),g))),validkey(dhexp_real(key_e(alice,bob,sid_5),g))),validkey(dhexp_real(key_s(alice),g)))),encrypt(hmac_hash2(hmac_hash1(hash(somename,empty),dhexp_real(key_e(alice,bob,sid_5),dhexp_real(key_s(bob),g))),dhexp_real(key_e(alice,bob,sid_5),dhexp_real(key_m(bob),g))),increment_nonce(minnonce),hash(hash(hash(hash(hash(hash(somename,empty),empty),validkey(dhexp_real(key_s(bob),g))),validkey(dhexp_real(key_m(bob),g))),validkey(dhexp_real(key_e(alice,bob,sid_5),g))),encrypt(hmac_hash2(hmac_hash1(hash(somename,empty),dhexp_real(key_e(alice,bob,sid_5),dhexp_real(key_s(bob),g))),dhexp_real(key_e(alice,bob,sid_5),dhexp_real(key_m(bob),g))),minnonce,hash(hash(hash(hash(hash(somename,empty),empty),validkey(dhexp_real(key_s(bob),g))),validkey(dhexp_real(key_m(bob),g))),validkey(dhexp_real(key_e(alice,bob,sid_5),g))),validkey(dhexp_real(key_s(alice),g)))),validkey(dhexp_real(key_m(alice),g)))),msg_a(alice,bob,sid_5)))).

4. By 1, the attacker may have the channel pub.
By 3, the message concat4(validkey(dhexp_real(key_e(alice,bob,sid_5),g)),encrypt(hmac_hash2(hmac_hash1(hash(somename,empty),dhexp_real(key_e(alice,bob,sid_5),dhexp_real(key_s(bob),g))),dhexp_real(key_e(alice,bob,sid_5),dhexp_real(key_m(bob),g))),minnonce,hash(hash(hash(hash(hash(somename,empty),empty),validkey(dhexp_real(key_s(bob),g))),validkey(dhexp_real(key_m(bob),g))),validkey(dhexp_real(key_e(alice,bob,sid_5),g))),validkey(dhexp_real(key_s(alice),g))),encrypt(hmac_hash2(hmac_hash1(hash(somename,empty),dhexp_real(key_e(alice,bob,sid_5),dhexp_real(key_s(bob),g))),dhexp_real(key_e(alice,bob,sid_5),dhexp_real(key_m(bob),g))),increment_nonce(minnonce),hash(hash(hash(hash(hash(hash(somename,empty),empty),validkey(dhexp_real(key_s(bob),g))),validkey(dhexp_real(key_m(bob),g))),validkey(dhexp_real(key_e(alice,bob,sid_5),g))),encrypt(hmac_hash2(hmac_hash1(hash(somename,empty),dhexp_real(key_e(alice,bob,sid_5),dhexp_real(key_s(bob),g))),dhexp_real(key_e(alice,bob,sid_5),dhexp_real(key_m(bob),g))),minnonce,hash(hash(hash(hash(hash(somename,empty),empty),validkey(dhexp_real(key_s(bob),g))),validkey(dhexp_real(key_m(bob),g))),validkey(dhexp_real(key_e(alice,bob,sid_5),g))),validkey(dhexp_real(key_s(alice),g)))),validkey(dhexp_real(key_m(alice),g))),encrypt(hmac_hash2(hmac_hash1(hmac_hash1(hmac_hash1(hash(somename,empty),dhexp_real(key_e(alice,bob,sid_5),dhexp_real(key_s(bob),g))),dhexp_real(key_e(alice,bob,sid_5),dhexp_real(key_m(bob),g))),dhexp_real(key_m(alice),dhexp_real(key_s(bob),g))),dhexp_real(key_m(bob),dhexp_real(key_s(alice),g))),minnonce,hash(hash(hash(hash(hash(hash(hash(somename,empty),empty),validkey(dhexp_real(key_s(bob),g))),validkey(dhexp_real(key_m(bob),g))),validkey(dhexp_real(key_e(alice,bob,sid_5),g))),encrypt(hmac_hash2(hmac_hash1(hash(somename,empty),dhexp_real(key_e(alice,bob,sid_5),dhexp_real(key_s(bob),g))),dhexp_real(key_e(alice,bob,sid_5),dhexp_real(key_m(bob),g))),minnonce,hash(hash(hash(hash(hash(somename,empty),empty),validkey(dhexp_real(key_s(bob),g))),validkey(dhexp_real(key_m(bob),g))),validkey(dhexp_real(key_e(alice,bob,sid_5),g))),validkey(dhexp_real(key_s(alice),g)))),encrypt(hmac_hash2(hmac_hash1(hash(somename,empty),dhexp_real(key_e(alice,bob,sid_5),dhexp_real(key_s(bob),g))),dhexp_real(key_e(alice,bob,sid_5),dhexp_real(key_m(bob),g))),increment_nonce(minnonce),hash(hash(hash(hash(hash(hash(somename,empty),empty),validkey(dhexp_real(key_s(bob),g))),validkey(dhexp_real(key_m(bob),g))),validkey(dhexp_real(key_e(alice,bob,sid_5),g))),encrypt(hmac_hash2(hmac_hash1(hash(somename,empty),dhexp_real(key_e(alice,bob,sid_5),dhexp_real(key_s(bob),g))),dhexp_real(key_e(alice,bob,sid_5),dhexp_real(key_m(bob),g))),minnonce,hash(hash(hash(hash(hash(somename,empty),empty),validkey(dhexp_real(key_s(bob),g))),validkey(dhexp_real(key_m(bob),g))),validkey(dhexp_real(key_e(alice,bob,sid_5),g))),validkey(dhexp_real(key_s(alice),g)))),validkey(dhexp_real(key_m(alice),g)))),msg_a(alice,bob,sid_5))) may be sent on this channel.
So the attacker may obtain the message concat4(validkey(dhexp_real(key_e(alice,bob,sid_5),g)),encrypt(hmac_hash2(hmac_hash1(hash(somename,empty),dhexp_real(key_e(alice,bob,sid_5),dhexp_real(key_s(bob),g))),dhexp_real(key_e(alice,bob,sid_5),dhexp_real(key_m(bob),g))),minnonce,hash(hash(hash(hash(hash(somename,empty),empty),validkey(dhexp_real(key_s(bob),g))),validkey(dhexp_real(key_m(bob),g))),validkey(dhexp_real(key_e(alice,bob,sid_5),g))),validkey(dhexp_real(key_s(alice),g))),encrypt(hmac_hash2(hmac_hash1(hash(somename,empty),dhexp_real(key_e(alice,bob,sid_5),dhexp_real(key_s(bob),g))),dhexp_real(key_e(alice,bob,sid_5),dhexp_real(key_m(bob),g))),increment_nonce(minnonce),hash(hash(hash(hash(hash(hash(somename,empty),empty),validkey(dhexp_real(key_s(bob),g))),validkey(dhexp_real(key_m(bob),g))),validkey(dhexp_real(key_e(alice,bob,sid_5),g))),encrypt(hmac_hash2(hmac_hash1(hash(somename,empty),dhexp_real(key_e(alice,bob,sid_5),dhexp_real(key_s(bob),g))),dhexp_real(key_e(alice,bob,sid_5),dhexp_real(key_m(bob),g))),minnonce,hash(hash(hash(hash(hash(somename,empty),empty),validkey(dhexp_real(key_s(bob),g))),validkey(dhexp_real(key_m(bob),g))),validkey(dhexp_real(key_e(alice,bob,sid_5),g))),validkey(dhexp_real(key_s(alice),g)))),validkey(dhexp_real(key_m(alice),g))),encrypt(hmac_hash2(hmac_hash1(hmac_hash1(hmac_hash1(hash(somename,empty),dhexp_real(key_e(alice,bob,sid_5),dhexp_real(key_s(bob),g))),dhexp_real(key_e(alice,bob,sid_5),dhexp_real(key_m(bob),g))),dhexp_real(key_m(alice),dhexp_real(key_s(bob),g))),dhexp_real(key_m(bob),dhexp_real(key_s(alice),g))),minnonce,hash(hash(hash(hash(hash(hash(hash(somename,empty),empty),validkey(dhexp_real(key_s(bob),g))),validkey(dhexp_real(key_m(bob),g))),validkey(dhexp_real(key_e(alice,bob,sid_5),g))),encrypt(hmac_hash2(hmac_hash1(hash(somename,empty),dhexp_real(key_e(alice,bob,sid_5),dhexp_real(key_s(bob),g))),dhexp_real(key_e(alice,bob,sid_5),dhexp_real(key_m(bob),g))),minnonce,hash(hash(hash(hash(hash(somename,empty),empty),validkey(dhexp_real(key_s(bob),g))),validkey(dhexp_real(key_m(bob),g))),validkey(dhexp_real(key_e(alice,bob,sid_5),g))),validkey(dhexp_real(key_s(alice),g)))),encrypt(hmac_hash2(hmac_hash1(hash(somename,empty),dhexp_real(key_e(alice,bob,sid_5),dhexp_real(key_s(bob),g))),dhexp_real(key_e(alice,bob,sid_5),dhexp_real(key_m(bob),g))),increment_nonce(minnonce),hash(hash(hash(hash(hash(hash(somename,empty),empty),validkey(dhexp_real(key_s(bob),g))),validkey(dhexp_real(key_m(bob),g))),validkey(dhexp_real(key_e(alice,bob,sid_5),g))),encrypt(hmac_hash2(hmac_hash1(hash(somename,empty),dhexp_real(key_e(alice,bob,sid_5),dhexp_real(key_s(bob),g))),dhexp_real(key_e(alice,bob,sid_5),dhexp_real(key_m(bob),g))),minnonce,hash(hash(hash(hash(hash(somename,empty),empty),validkey(dhexp_real(key_s(bob),g))),validkey(dhexp_real(key_m(bob),g))),validkey(dhexp_real(key_e(alice,bob,sid_5),g))),validkey(dhexp_real(key_s(alice),g)))),validkey(dhexp_real(key_m(alice),g)))),msg_a(alice,bob,sid_5))) by listening on this channel.
attacker(concat4(validkey(dhexp_real(key_e(alice,bob,sid_5),g)),encrypt(hmac_hash2(hmac_hash1(hash(somename,empty),dhexp_real(key_e(alice,bob,sid_5),dhexp_real(key_s(bob),g))),dhexp_real(key_e(alice,bob,sid_5),dhexp_real(key_m(bob),g))),minnonce,hash(hash(hash(hash(hash(somename,empty),empty),validkey(dhexp_real(key_s(bob),g))),validkey(dhexp_real(key_m(bob),g))),validkey(dhexp_real(key_e(alice,bob,sid_5),g))),validkey(dhexp_real(key_s(alice),g))),encrypt(hmac_hash2(hmac_hash1(hash(somename,empty),dhexp_real(key_e(alice,bob,sid_5),dhexp_real(key_s(bob),g))),dhexp_real(key_e(alice,bob,sid_5),dhexp_real(key_m(bob),g))),increment_nonce(minnonce),hash(hash(hash(hash(hash(hash(somename,empty),empty),validkey(dhexp_real(key_s(bob),g))),validkey(dhexp_real(key_m(bob),g))),validkey(dhexp_real(key_e(alice,bob,sid_5),g))),encrypt(hmac_hash2(hmac_hash1(hash(somename,empty),dhexp_real(key_e(alice,bob,sid_5),dhexp_real(key_s(bob),g))),dhexp_real(key_e(alice,bob,sid_5),dhexp_real(key_m(bob),g))),minnonce,hash(hash(hash(hash(hash(somename,empty),empty),validkey(dhexp_real(key_s(bob),g))),validkey(dhexp_real(key_m(bob),g))),validkey(dhexp_real(key_e(alice,bob,sid_5),g))),validkey(dhexp_real(key_s(alice),g)))),validkey(dhexp_real(key_m(alice),g))),encrypt(hmac_hash2(hmac_hash1(hmac_hash1(hmac_hash1(hash(somename,empty),dhexp_real(key_e(alice,bob,sid_5),dhexp_real(key_s(bob),g))),dhexp_real(key_e(alice,bob,sid_5),dhexp_real(key_m(bob),g))),dhexp_real(key_m(alice),dhexp_real(key_s(bob),g))),dhexp_real(key_m(bob),dhexp_real(key_s(alice),g))),minnonce,hash(hash(hash(hash(hash(hash(hash(somename,empty),empty),validkey(dhexp_real(key_s(bob),g))),validkey(dhexp_real(key_m(bob),g))),validkey(dhexp_real(key_e(alice,bob,sid_5),g))),encrypt(hmac_hash2(hmac_hash1(hash(somename,empty),dhexp_real(key_e(alice,bob,sid_5),dhexp_real(key_s(bob),g))),dhexp_real(key_e(alice,bob,sid_5),dhexp_real(key_m(bob),g))),minnonce,hash(hash(hash(hash(hash(somename,empty),empty),validkey(dhexp_real(key_s(bob),g))),validkey(dhexp_real(key_m(bob),g))),validkey(dhexp_real(key_e(alice,bob,sid_5),g))),validkey(dhexp_real(key_s(alice),g)))),encrypt(hmac_hash2(hmac_hash1(hash(somename,empty),dhexp_real(key_e(alice,bob,sid_5),dhexp_real(key_s(bob),g))),dhexp_real(key_e(alice,bob,sid_5),dhexp_real(key_m(bob),g))),increment_nonce(minnonce),hash(hash(hash(hash(hash(hash(somename,empty),empty),validkey(dhexp_real(key_s(bob),g))),validkey(dhexp_real(key_m(bob),g))),validkey(dhexp_real(key_e(alice,bob,sid_5),g))),encrypt(hmac_hash2(hmac_hash1(hash(somename,empty),dhexp_real(key_e(alice,bob,sid_5),dhexp_real(key_s(bob),g))),dhexp_real(key_e(alice,bob,sid_5),dhexp_real(key_m(bob),g))),minnonce,hash(hash(hash(hash(hash(somename,empty),empty),validkey(dhexp_real(key_s(bob),g))),validkey(dhexp_real(key_m(bob),g))),validkey(dhexp_real(key_e(alice,bob,sid_5),g))),validkey(dhexp_real(key_s(alice),g)))),validkey(dhexp_real(key_m(alice),g)))),msg_a(alice,bob,sid_5)))).

5. By 4, the attacker may know concat4(validkey(dhexp_real(key_e(alice,bob,sid_5),g)),encrypt(hmac_hash2(hmac_hash1(hash(somename,empty),dhexp_real(key_e(alice,bob,sid_5),dhexp_real(key_s(bob),g))),dhexp_real(key_e(alice,bob,sid_5),dhexp_real(key_m(bob),g))),minnonce,hash(hash(hash(hash(hash(somename,empty),empty),validkey(dhexp_real(key_s(bob),g))),validkey(dhexp_real(key_m(bob),g))),validkey(dhexp_real(key_e(alice,bob,sid_5),g))),validkey(dhexp_real(key_s(alice),g))),encrypt(hmac_hash2(hmac_hash1(hash(somename,empty),dhexp_real(key_e(alice,bob,sid_5),dhexp_real(key_s(bob),g))),dhexp_real(key_e(alice,bob,sid_5),dhexp_real(key_m(bob),g))),increment_nonce(minnonce),hash(hash(hash(hash(hash(hash(somename,empty),empty),validkey(dhexp_real(key_s(bob),g))),validkey(dhexp_real(key_m(bob),g))),validkey(dhexp_real(key_e(alice,bob,sid_5),g))),encrypt(hmac_hash2(hmac_hash1(hash(somename,empty),dhexp_real(key_e(alice,bob,sid_5),dhexp_real(key_s(bob),g))),dhexp_real(key_e(alice,bob,sid_5),dhexp_real(key_m(bob),g))),minnonce,hash(hash(hash(hash(hash(somename,empty),empty),validkey(dhexp_real(key_s(bob),g))),validkey(dhexp_real(key_m(bob),g))),validkey(dhexp_real(key_e(alice,bob,sid_5),g))),validkey(dhexp_real(key_s(alice),g)))),validkey(dhexp_real(key_m(alice),g))),encrypt(hmac_hash2(hmac_hash1(hmac_hash1(hmac_hash1(hash(somename,empty),dhexp_real(key_e(alice,bob,sid_5),dhexp_real(key_s(bob),g))),dhexp_real(key_e(alice,bob,sid_5),dhexp_real(key_m(bob),g))),dhexp_real(key_m(alice),dhexp_real(key_s(bob),g))),dhexp_real(key_m(bob),dhexp_real(key_s(alice),g))),minnonce,hash(hash(hash(hash(hash(hash(hash(somename,empty),empty),validkey(dhexp_real(key_s(bob),g))),validkey(dhexp_real(key_m(bob),g))),validkey(dhexp_real(key_e(alice,bob,sid_5),g))),encrypt(hmac_hash2(hmac_hash1(hash(somename,empty),dhexp_real(key_e(alice,bob,sid_5),dhexp_real(key_s(bob),g))),dhexp_real(key_e(alice,bob,sid_5),dhexp_real(key_m(bob),g))),minnonce,hash(hash(hash(hash(hash(somename,empty),empty),validkey(dhexp_real(key_s(bob),g))),validkey(dhexp_real(key_m(bob),g))),validkey(dhexp_real(key_e(alice,bob,sid_5),g))),validkey(dhexp_real(key_s(alice),g)))),encrypt(hmac_hash2(hmac_hash1(hash(somename,empty),dhexp_real(key_e(alice,bob,sid_5),dhexp_real(key_s(bob),g))),dhexp_real(key_e(alice,bob,sid_5),dhexp_real(key_m(bob),g))),increment_nonce(minnonce),hash(hash(hash(hash(hash(hash(somename,empty),empty),validkey(dhexp_real(key_s(bob),g))),validkey(dhexp_real(key_m(bob),g))),validkey(dhexp_real(key_e(alice,bob,sid_5),g))),encrypt(hmac_hash2(hmac_hash1(hash(somename,empty),dhexp_real(key_e(alice,bob,sid_5),dhexp_real(key_s(bob),g))),dhexp_real(key_e(alice,bob,sid_5),dhexp_real(key_m(bob),g))),minnonce,hash(hash(hash(hash(hash(somename,empty),empty),validkey(dhexp_real(key_s(bob),g))),validkey(dhexp_real(key_m(bob),g))),validkey(dhexp_real(key_e(alice,bob,sid_5),g))),validkey(dhexp_real(key_s(alice),g)))),validkey(dhexp_real(key_m(alice),g)))),msg_a(alice,bob,sid_5))).
Using the function 4-proj-concat4 the attacker may obtain encrypt(hmac_hash2(hmac_hash1(hmac_hash1(hmac_hash1(hash(somename,empty),dhexp_real(key_e(alice,bob,sid_5),dhexp_real(key_s(bob),g))),dhexp_real(key_e(alice,bob,sid_5),dhexp_real(key_m(bob),g))),dhexp_real(key_m(alice),dhexp_real(key_s(bob),g))),dhexp_real(key_m(bob),dhexp_real(key_s(alice),g))),minnonce,hash(hash(hash(hash(hash(hash(hash(somename,empty),empty),validkey(dhexp_real(key_s(bob),g))),validkey(dhexp_real(key_m(bob),g))),validkey(dhexp_real(key_e(alice,bob,sid_5),g))),encrypt(hmac_hash2(hmac_hash1(hash(somename,empty),dhexp_real(key_e(alice,bob,sid_5),dhexp_real(key_s(bob),g))),dhexp_real(key_e(alice,bob,sid_5),dhexp_real(key_m(bob),g))),minnonce,hash(hash(hash(hash(hash(somename,empty),empty),validkey(dhexp_real(key_s(bob),g))),validkey(dhexp_real(key_m(bob),g))),validkey(dhexp_real(key_e(alice,bob,sid_5),g))),validkey(dhexp_real(key_s(alice),g)))),encrypt(hmac_hash2(hmac_hash1(hash(somename,empty),dhexp_real(key_e(alice,bob,sid_5),dhexp_real(key_s(bob),g))),dhexp_real(key_e(alice,bob,sid_5),dhexp_real(key_m(bob),g))),increment_nonce(minnonce),hash(hash(hash(hash(hash(hash(somename,empty),empty),validkey(dhexp_real(key_s(bob),g))),validkey(dhexp_real(key_m(bob),g))),validkey(dhexp_real(key_e(alice,bob,sid_5),g))),encrypt(hmac_hash2(hmac_hash1(hash(somename,empty),dhexp_real(key_e(alice,bob,sid_5),dhexp_real(key_s(bob),g))),dhexp_real(key_e(alice,bob,sid_5),dhexp_real(key_m(bob),g))),minnonce,hash(hash(hash(hash(hash(somename,empty),empty),validkey(dhexp_real(key_s(bob),g))),validkey(dhexp_real(key_m(bob),g))),validkey(dhexp_real(key_e(alice,bob,sid_5),g))),validkey(dhexp_real(key_s(alice),g)))),validkey(dhexp_real(key_m(alice),g)))),msg_a(alice,bob,sid_5)).
attacker(encrypt(hmac_hash2(hmac_hash1(hmac_hash1(hmac_hash1(hash(somename,empty),dhexp_real(key_e(alice,bob,sid_5),dhexp_real(key_s(bob),g))),dhexp_real(key_e(alice,bob,sid_5),dhexp_real(key_m(bob),g))),dhexp_real(key_m(alice),dhexp_real(key_s(bob),g))),dhexp_real(key_m(bob),dhexp_real(key_s(alice),g))),minnonce,hash(hash(hash(hash(hash(hash(hash(somename,empty),empty),validkey(dhexp_real(key_s(bob),g))),validkey(dhexp_real(key_m(bob),g))),validkey(dhexp_real(key_e(alice,bob,sid_5),g))),encrypt(hmac_hash2(hmac_hash1(hash(somename,empty),dhexp_real(key_e(alice,bob,sid_5),dhexp_real(key_s(bob),g))),dhexp_real(key_e(alice,bob,sid_5),dhexp_real(key_m(bob),g))),minnonce,hash(hash(hash(hash(hash(somename,empty),empty),validkey(dhexp_real(key_s(bob),g))),validkey(dhexp_real(key_m(bob),g))),validkey(dhexp_real(key_e(alice,bob,sid_5),g))),validkey(dhexp_real(key_s(alice),g)))),encrypt(hmac_hash2(hmac_hash1(hash(somename,empty),dhexp_real(key_e(alice,bob,sid_5),dhexp_real(key_s(bob),g))),dhexp_real(key_e(alice,bob,sid_5),dhexp_real(key_m(bob),g))),increment_nonce(minnonce),hash(hash(hash(hash(hash(hash(somename,empty),empty),validkey(dhexp_real(key_s(bob),g))),validkey(dhexp_real(key_m(bob),g))),validkey(dhexp_real(key_e(alice,bob,sid_5),g))),encrypt(hmac_hash2(hmac_hash1(hash(somename,empty),dhexp_real(key_e(alice,bob,sid_5),dhexp_real(key_s(bob),g))),dhexp_real(key_e(alice,bob,sid_5),dhexp_real(key_m(bob),g))),minnonce,hash(hash(hash(hash(hash(somename,empty),empty),validkey(dhexp_real(key_s(bob),g))),validkey(dhexp_real(key_m(bob),g))),validkey(dhexp_real(key_e(alice,bob,sid_5),g))),validkey(dhexp_real(key_s(alice),g)))),validkey(dhexp_real(key_m(alice),g)))),msg_a(alice,bob,sid_5))).

6. By 5, the attacker may know encrypt(hmac_hash2(hmac_hash1(hmac_hash1(hmac_hash1(hash(somename,empty),dhexp_real(key_e(alice,bob,sid_5),dhexp_real(key_s(bob),g))),dhexp_real(key_e(alice,bob,sid_5),dhexp_real(key_m(bob),g))),dhexp_real(key_m(alice),dhexp_real(key_s(bob),g))),dhexp_real(key_m(bob),dhexp_real(key_s(alice),g))),minnonce,hash(hash(hash(hash(hash(hash(hash(somename,empty),empty),validkey(dhexp_real(key_s(bob),g))),validkey(dhexp_real(key_m(bob),g))),validkey(dhexp_real(key_e(alice,bob,sid_5),g))),encrypt(hmac_hash2(hmac_hash1(hash(somename,empty),dhexp_real(key_e(alice,bob,sid_5),dhexp_real(key_s(bob),g))),dhexp_real(key_e(alice,bob,sid_5),dhexp_real(key_m(bob),g))),minnonce,hash(hash(hash(hash(hash(somename,empty),empty),validkey(dhexp_real(key_s(bob),g))),validkey(dhexp_real(key_m(bob),g))),validkey(dhexp_real(key_e(alice,bob,sid_5),g))),validkey(dhexp_real(key_s(alice),g)))),encrypt(hmac_hash2(hmac_hash1(hash(somename,empty),dhexp_real(key_e(alice,bob,sid_5),dhexp_real(key_s(bob),g))),dhexp_real(key_e(alice,bob,sid_5),dhexp_real(key_m(bob),g))),increment_nonce(minnonce),hash(hash(hash(hash(hash(hash(somename,empty),empty),validkey(dhexp_real(key_s(bob),g))),validkey(dhexp_real(key_m(bob),g))),validkey(dhexp_real(key_e(alice,bob,sid_5),g))),encrypt(hmac_hash2(hmac_hash1(hash(somename,empty),dhexp_real(key_e(alice,bob,sid_5),dhexp_real(key_s(bob),g))),dhexp_real(key_e(alice,bob,sid_5),dhexp_real(key_m(bob),g))),minnonce,hash(hash(hash(hash(hash(somename,empty),empty),validkey(dhexp_real(key_s(bob),g))),validkey(dhexp_real(key_m(bob),g))),validkey(dhexp_real(key_e(alice,bob,sid_5),g))),validkey(dhexp_real(key_s(alice),g)))),validkey(dhexp_real(key_m(alice),g)))),msg_a(alice,bob,sid_5)).
So the attacker may know encrypt(hmac_hash2(hmac_hash1(hmac_hash1(hmac_hash1(hash(somename,empty),dhexp_real(key_e(alice,bob,sid_5),dhexp_real(key_s(bob),g))),dhexp_real(key_e(alice,bob,sid_5),dhexp_real(key_m(bob),g))),dhexp_real(key_m(alice),dhexp_real(key_s(bob),g))),dhexp_real(key_m(bob),dhexp_real(key_s(alice),g))),minnonce,hash(hash(hash(hash(hash(hash(hash(somename,empty),empty),validkey(dhexp_real(key_s(bob),g))),validkey(dhexp_real(key_m(bob),g))),validkey(dhexp_real(key_e(alice,bob,sid_5),g))),encrypt(hmac_hash2(hmac_hash1(hash(somename,empty),dhexp_real(key_e(alice,bob,sid_5),dhexp_real(key_s(bob),g))),dhexp_real(key_e(alice,bob,sid_5),dhexp_real(key_m(bob),g))),minnonce,hash(hash(hash(hash(hash(somename,empty),empty),validkey(dhexp_real(key_s(bob),g))),validkey(dhexp_real(key_m(bob),g))),validkey(dhexp_real(key_e(alice,bob,sid_5),g))),validkey(dhexp_real(key_s(alice),g)))),encrypt(hmac_hash2(hmac_hash1(hash(somename,empty),dhexp_real(key_e(alice,bob,sid_5),dhexp_real(key_s(bob),g))),dhexp_real(key_e(alice,bob,sid_5),dhexp_real(key_m(bob),g))),increment_nonce(minnonce),hash(hash(hash(hash(hash(hash(somename,empty),empty),validkey(dhexp_real(key_s(bob),g))),validkey(dhexp_real(key_m(bob),g))),validkey(dhexp_real(key_e(alice,bob,sid_5),g))),encrypt(hmac_hash2(hmac_hash1(hash(somename,empty),dhexp_real(key_e(alice,bob,sid_5),dhexp_real(key_s(bob),g))),dhexp_real(key_e(alice,bob,sid_5),dhexp_real(key_m(bob),g))),minnonce,hash(hash(hash(hash(hash(somename,empty),empty),validkey(dhexp_real(key_s(bob),g))),validkey(dhexp_real(key_m(bob),g))),validkey(dhexp_real(key_e(alice,bob,sid_5),g))),validkey(dhexp_real(key_s(alice),g)))),validkey(dhexp_real(key_m(alice),g)))),msg_a(alice,bob,sid_5)) in phase 1.
attacker_p1(encrypt(hmac_hash2(hmac_hash1(hmac_hash1(hmac_hash1(hash(somename,empty),dhexp_real(key_e(alice,bob,sid_5),dhexp_real(key_s(bob),g))),dhexp_real(key_e(alice,bob,sid_5),dhexp_real(key_m(bob),g))),dhexp_real(key_m(alice),dhexp_real(key_s(bob),g))),dhexp_real(key_m(bob),dhexp_real(key_s(alice),g))),minnonce,hash(hash(hash(hash(hash(hash(hash(somename,empty),empty),validkey(dhexp_real(key_s(bob),g))),validkey(dhexp_real(key_m(bob),g))),validkey(dhexp_real(key_e(alice,bob,sid_5),g))),encrypt(hmac_hash2(hmac_hash1(hash(somename,empty),dhexp_real(key_e(alice,bob,sid_5),dhexp_real(key_s(bob),g))),dhexp_real(key_e(alice,bob,sid_5),dhexp_real(key_m(bob),g))),minnonce,hash(hash(hash(hash(hash(somename,empty),empty),validkey(dhexp_real(key_s(bob),g))),validkey(dhexp_real(key_m(bob),g))),validkey(dhexp_real(key_e(alice,bob,sid_5),g))),validkey(dhexp_real(key_s(alice),g)))),encrypt(hmac_hash2(hmac_hash1(hash(somename,empty),dhexp_real(key_e(alice,bob,sid_5),dhexp_real(key_s(bob),g))),dhexp_real(key_e(alice,bob,sid_5),dhexp_real(key_m(bob),g))),increment_nonce(minnonce),hash(hash(hash(hash(hash(hash(somename,empty),empty),validkey(dhexp_real(key_s(bob),g))),validkey(dhexp_real(key_m(bob),g))),validkey(dhexp_real(key_e(alice,bob,sid_5),g))),encrypt(hmac_hash2(hmac_hash1(hash(somename,empty),dhexp_real(key_e(alice,bob,sid_5),dhexp_real(key_s(bob),g))),dhexp_real(key_e(alice,bob,sid_5),dhexp_real(key_m(bob),g))),minnonce,hash(hash(hash(hash(hash(somename,empty),empty),validkey(dhexp_real(key_s(bob),g))),validkey(dhexp_real(key_m(bob),g))),validkey(dhexp_real(key_e(alice,bob,sid_5),g))),validkey(dhexp_real(key_s(alice),g)))),validkey(dhexp_real(key_m(alice),g)))),msg_a(alice,bob,sid_5))).

7. The entry statestore(alice,bob,sid_5,statepack_a(handshakestatepack(symmetricstatepack(cipherstatepack(empty,minnonce),hash(somename,empty),hash(hash(hash(hash(somename,empty),empty),validkey(dhexp_real(key_s(bob),g))),validkey(dhexp_real(key_m(bob),g)))),keypairpack(empty,empty),keypairpack(empty,empty),keypairpack(empty,empty),validkey(dhexp_real(key_s(bob),g)),validkey(dhexp_real(key_m(bob),g)),empty,empty,true))) that may be in a table by 2 may be read at get {306}.
The event SendMsg(alice,bob,stagepack_a(sid_5),msg_a(alice,bob,sid_5)) may be executed at {304}.
So the message concat4(validkey(dhexp_real(key_e(alice,bob,sid_5),g)),encrypt(hmac_hash2(hmac_hash1(hash(somename,empty),dhexp_real(key_e(alice,bob,sid_5),dhexp_real(key_s(bob),g))),dhexp_real(key_e(alice,bob,sid_5),dhexp_real(key_m(bob),g))),minnonce,hash(hash(hash(hash(hash(somename,empty),empty),validkey(dhexp_real(key_s(bob),g))),validkey(dhexp_real(key_m(bob),g))),validkey(dhexp_real(key_e(alice,bob,sid_5),g))),validkey(dhexp_real(key_s(alice),g))),encrypt(hmac_hash2(hmac_hash1(hash(somename,empty),dhexp_real(key_e(alice,bob,sid_5),dhexp_real(key_s(bob),g))),dhexp_real(key_e(alice,bob,sid_5),dhexp_real(key_m(bob),g))),increment_nonce(minnonce),hash(hash(hash(hash(hash(hash(somename,empty),empty),validkey(dhexp_real(key_s(bob),g))),validkey(dhexp_real(key_m(bob),g))),validkey(dhexp_real(key_e(alice,bob,sid_5),g))),encrypt(hmac_hash2(hmac_hash1(hash(somename,empty),dhexp_real(key_e(alice,bob,sid_5),dhexp_real(key_s(bob),g))),dhexp_real(key_e(alice,bob,sid_5),dhexp_real(key_m(bob),g))),minnonce,hash(hash(hash(hash(hash(somename,empty),empty),validkey(dhexp_real(key_s(bob),g))),validkey(dhexp_real(key_m(bob),g))),validkey(dhexp_real(key_e(alice,bob,sid_5),g))),validkey(dhexp_real(key_s(alice),g)))),validkey(dhexp_real(key_m(alice),g))),encrypt(hmac_hash2(hmac_hash1(hmac_hash1(hmac_hash1(hash(somename,empty),dhexp_real(key_e(alice,bob,sid_5),dhexp_real(key_s(bob),g))),dhexp_real(key_e(alice,bob,sid_5),dhexp_real(key_m(bob),g))),dhexp_real(key_m(alice),dhexp_real(key_s(bob),g))),dhexp_real(key_s(alice),dhexp_real(key_m(bob),g))),minnonce,hash(hash(hash(hash(hash(hash(hash(somename,empty),empty),validkey(dhexp_real(key_s(bob),g))),validkey(dhexp_real(key_m(bob),g))),validkey(dhexp_real(key_e(alice,bob,sid_5),g))),encrypt(hmac_hash2(hmac_hash1(hash(somename,empty),dhexp_real(key_e(alice,bob,sid_5),dhexp_real(key_s(bob),g))),dhexp_real(key_e(alice,bob,sid_5),dhexp_real(key_m(bob),g))),minnonce,hash(hash(hash(hash(hash(somename,empty),empty),validkey(dhexp_real(key_s(bob),g))),validkey(dhexp_real(key_m(bob),g))),validkey(dhexp_real(key_e(alice,bob,sid_5),g))),validkey(dhexp_real(key_s(alice),g)))),encrypt(hmac_hash2(hmac_hash1(hash(somename,empty),dhexp_real(key_e(alice,bob,sid_5),dhexp_real(key_s(bob),g))),dhexp_real(key_e(alice,bob,sid_5),dhexp_real(key_m(bob),g))),increment_nonce(minnonce),hash(hash(hash(hash(hash(hash(somename,empty),empty),validkey(dhexp_real(key_s(bob),g))),validkey(dhexp_real(key_m(bob),g))),validkey(dhexp_real(key_e(alice,bob,sid_5),g))),encrypt(hmac_hash2(hmac_hash1(hash(somename,empty),dhexp_real(key_e(alice,bob,sid_5),dhexp_real(key_s(bob),g))),dhexp_real(key_e(alice,bob,sid_5),dhexp_real(key_m(bob),g))),minnonce,hash(hash(hash(hash(hash(somename,empty),empty),validkey(dhexp_real(key_s(bob),g))),validkey(dhexp_real(key_m(bob),g))),validkey(dhexp_real(key_e(alice,bob,sid_5),g))),validkey(dhexp_real(key_s(alice),g)))),validkey(dhexp_real(key_m(alice),g)))),msg_a(alice,bob,sid_5))) may be sent on channel pub at output {305}.
mess(pub,concat4(validkey(dhexp_real(key_e(alice,bob,sid_5),g)),encrypt(hmac_hash2(hmac_hash1(hash(somename,empty),dhexp_real(key_e(alice,bob,sid_5),dhexp_real(key_s(bob),g))),dhexp_real(key_e(alice,bob,sid_5),dhexp_real(key_m(bob),g))),minnonce,hash(hash(hash(hash(hash(somename,empty),empty),validkey(dhexp_real(key_s(bob),g))),validkey(dhexp_real(key_m(bob),g))),validkey(dhexp_real(key_e(alice,bob,sid_5),g))),validkey(dhexp_real(key_s(alice),g))),encrypt(hmac_hash2(hmac_hash1(hash(somename,empty),dhexp_real(key_e(alice,bob,sid_5),dhexp_real(key_s(bob),g))),dhexp_real(key_e(alice,bob,sid_5),dhexp_real(key_m(bob),g))),increment_nonce(minnonce),hash(hash(hash(hash(hash(hash(somename,empty),empty),validkey(dhexp_real(key_s(bob),g))),validkey(dhexp_real(key_m(bob),g))),validkey(dhexp_real(key_e(alice,bob,sid_5),g))),encrypt(hmac_hash2(hmac_hash1(hash(somename,empty),dhexp_real(key_e(alice,bob,sid_5),dhexp_real(key_s(bob),g))),dhexp_real(key_e(alice,bob,sid_5),dhexp_real(key_m(bob),g))),minnonce,hash(hash(hash(hash(hash(somename,empty),empty),validkey(dhexp_real(key_s(bob),g))),validkey(dhexp_real(key_m(bob),g))),validkey(dhexp_real(key_e(alice,bob,sid_5),g))),validkey(dhexp_real(key_s(alice),g)))),validkey(dhexp_real(key_m(alice),g))),encrypt(hmac_hash2(hmac_hash1(hmac_hash1(hmac_hash1(hash(somename,empty),dhexp_real(key_e(alice,bob,sid_5),dhexp_real(key_s(bob),g))),dhexp_real(key_e(alice,bob,sid_5),dhexp_real(key_m(bob),g))),dhexp_real(key_m(alice),dhexp_real(key_s(bob),g))),dhexp_real(key_s(alice),dhexp_real(key_m(bob),g))),minnonce,hash(hash(hash(hash(hash(hash(hash(somename,empty),empty),validkey(dhexp_real(key_s(bob),g))),validkey(dhexp_real(key_m(bob),g))),validkey(dhexp_real(key_e(alice,bob,sid_5),g))),encrypt(hmac_hash2(hmac_hash1(hash(somename,empty),dhexp_real(key_e(alice,bob,sid_5),dhexp_real(key_s(bob),g))),dhexp_real(key_e(alice,bob,sid_5),dhexp_real(key_m(bob),g))),minnonce,hash(hash(hash(hash(hash(somename,empty),empty),validkey(dhexp_real(key_s(bob),g))),validkey(dhexp_real(key_m(bob),g))),validkey(dhexp_real(key_e(alice,bob,sid_5),g))),validkey(dhexp_real(key_s(alice),g)))),encrypt(hmac_hash2(hmac_hash1(hash(somename,empty),dhexp_real(key_e(alice,bob,sid_5),dhexp_real(key_s(bob),g))),dhexp_real(key_e(alice,bob,sid_5),dhexp_real(key_m(bob),g))),increment_nonce(minnonce),hash(hash(hash(hash(hash(hash(somename,empty),empty),validkey(dhexp_real(key_s(bob),g))),validkey(dhexp_real(key_m(bob),g))),validkey(dhexp_real(key_e(alice,bob,sid_5),g))),encrypt(hmac_hash2(hmac_hash1(hash(somename,empty),dhexp_real(key_e(alice,bob,sid_5),dhexp_real(key_s(bob),g))),dhexp_real(key_e(alice,bob,sid_5),dhexp_real(key_m(bob),g))),minnonce,hash(hash(hash(hash(hash(somename,empty),empty),validkey(dhexp_real(key_s(bob),g))),validkey(dhexp_real(key_m(bob),g))),validkey(dhexp_real(key_e(alice,bob,sid_5),g))),validkey(dhexp_real(key_s(alice),g)))),validkey(dhexp_real(key_m(alice),g)))),msg_a(alice,bob,sid_5)))).

8. By 1, the attacker may have the channel pub.
By 7, the message concat4(validkey(dhexp_real(key_e(alice,bob,sid_5),g)),encrypt(hmac_hash2(hmac_hash1(hash(somename,empty),dhexp_real(key_e(alice,bob,sid_5),dhexp_real(key_s(bob),g))),dhexp_real(key_e(alice,bob,sid_5),dhexp_real(key_m(bob),g))),minnonce,hash(hash(hash(hash(hash(somename,empty),empty),validkey(dhexp_real(key_s(bob),g))),validkey(dhexp_real(key_m(bob),g))),validkey(dhexp_real(key_e(alice,bob,sid_5),g))),validkey(dhexp_real(key_s(alice),g))),encrypt(hmac_hash2(hmac_hash1(hash(somename,empty),dhexp_real(key_e(alice,bob,sid_5),dhexp_real(key_s(bob),g))),dhexp_real(key_e(alice,bob,sid_5),dhexp_real(key_m(bob),g))),increment_nonce(minnonce),hash(hash(hash(hash(hash(hash(somename,empty),empty),validkey(dhexp_real(key_s(bob),g))),validkey(dhexp_real(key_m(bob),g))),validkey(dhexp_real(key_e(alice,bob,sid_5),g))),encrypt(hmac_hash2(hmac_hash1(hash(somename,empty),dhexp_real(key_e(alice,bob,sid_5),dhexp_real(key_s(bob),g))),dhexp_real(key_e(alice,bob,sid_5),dhexp_real(key_m(bob),g))),minnonce,hash(hash(hash(hash(hash(somename,empty),empty),validkey(dhexp_real(key_s(bob),g))),validkey(dhexp_real(key_m(bob),g))),validkey(dhexp_real(key_e(alice,bob,sid_5),g))),validkey(dhexp_real(key_s(alice),g)))),validkey(dhexp_real(key_m(alice),g))),encrypt(hmac_hash2(hmac_hash1(hmac_hash1(hmac_hash1(hash(somename,empty),dhexp_real(key_e(alice,bob,sid_5),dhexp_real(key_s(bob),g))),dhexp_real(key_e(alice,bob,sid_5),dhexp_real(key_m(bob),g))),dhexp_real(key_m(alice),dhexp_real(key_s(bob),g))),dhexp_real(key_s(alice),dhexp_real(key_m(bob),g))),minnonce,hash(hash(hash(hash(hash(hash(hash(somename,empty),empty),validkey(dhexp_real(key_s(bob),g))),validkey(dhexp_real(key_m(bob),g))),validkey(dhexp_real(key_e(alice,bob,sid_5),g))),encrypt(hmac_hash2(hmac_hash1(hash(somename,empty),dhexp_real(key_e(alice,bob,sid_5),dhexp_real(key_s(bob),g))),dhexp_real(key_e(alice,bob,sid_5),dhexp_real(key_m(bob),g))),minnonce,hash(hash(hash(hash(hash(somename,empty),empty),validkey(dhexp_real(key_s(bob),g))),validkey(dhexp_real(key_m(bob),g))),validkey(dhexp_real(key_e(alice,bob,sid_5),g))),validkey(dhexp_real(key_s(alice),g)))),encrypt(hmac_hash2(hmac_hash1(hash(somename,empty),dhexp_real(key_e(alice,bob,sid_5),dhexp_real(key_s(bob),g))),dhexp_real(key_e(alice,bob,sid_5),dhexp_real(key_m(bob),g))),increment_nonce(minnonce),hash(hash(hash(hash(hash(hash(somename,empty),empty),validkey(dhexp_real(key_s(bob),g))),validkey(dhexp_real(key_m(bob),g))),validkey(dhexp_real(key_e(alice,bob,sid_5),g))),encrypt(hmac_hash2(hmac_hash1(hash(somename,empty),dhexp_real(key_e(alice,bob,sid_5),dhexp_real(key_s(bob),g))),dhexp_real(key_e(alice,bob,sid_5),dhexp_real(key_m(bob),g))),minnonce,hash(hash(hash(hash(hash(somename,empty),empty),validkey(dhexp_real(key_s(bob),g))),validkey(dhexp_real(key_m(bob),g))),validkey(dhexp_real(key_e(alice,bob,sid_5),g))),validkey(dhexp_real(key_s(alice),g)))),validkey(dhexp_real(key_m(alice),g)))),msg_a(alice,bob,sid_5))) may be sent on this channel.
So the attacker may obtain the message concat4(validkey(dhexp_real(key_e(alice,bob,sid_5),g)),encrypt(hmac_hash2(hmac_hash1(hash(somename,empty),dhexp_real(key_e(alice,bob,sid_5),dhexp_real(key_s(bob),g))),dhexp_real(key_e(alice,bob,sid_5),dhexp_real(key_m(bob),g))),minnonce,hash(hash(hash(hash(hash(somename,empty),empty),validkey(dhexp_real(key_s(bob),g))),validkey(dhexp_real(key_m(bob),g))),validkey(dhexp_real(key_e(alice,bob,sid_5),g))),validkey(dhexp_real(key_s(alice),g))),encrypt(hmac_hash2(hmac_hash1(hash(somename,empty),dhexp_real(key_e(alice,bob,sid_5),dhexp_real(key_s(bob),g))),dhexp_real(key_e(alice,bob,sid_5),dhexp_real(key_m(bob),g))),increment_nonce(minnonce),hash(hash(hash(hash(hash(hash(somename,empty),empty),validkey(dhexp_real(key_s(bob),g))),validkey(dhexp_real(key_m(bob),g))),validkey(dhexp_real(key_e(alice,bob,sid_5),g))),encrypt(hmac_hash2(hmac_hash1(hash(somename,empty),dhexp_real(key_e(alice,bob,sid_5),dhexp_real(key_s(bob),g))),dhexp_real(key_e(alice,bob,sid_5),dhexp_real(key_m(bob),g))),minnonce,hash(hash(hash(hash(hash(somename,empty),empty),validkey(dhexp_real(key_s(bob),g))),validkey(dhexp_real(key_m(bob),g))),validkey(dhexp_real(key_e(alice,bob,sid_5),g))),validkey(dhexp_real(key_s(alice),g)))),validkey(dhexp_real(key_m(alice),g))),encrypt(hmac_hash2(hmac_hash1(hmac_hash1(hmac_hash1(hash(somename,empty),dhexp_real(key_e(alice,bob,sid_5),dhexp_real(key_s(bob),g))),dhexp_real(key_e(alice,bob,sid_5),dhexp_real(key_m(bob),g))),dhexp_real(key_m(alice),dhexp_real(key_s(bob),g))),dhexp_real(key_s(alice),dhexp_real(key_m(bob),g))),minnonce,hash(hash(hash(hash(hash(hash(hash(somename,empty),empty),validkey(dhexp_real(key_s(bob),g))),validkey(dhexp_real(key_m(bob),g))),validkey(dhexp_real(key_e(alice,bob,sid_5),g))),encrypt(hmac_hash2(hmac_hash1(hash(somename,empty),dhexp_real(key_e(alice,bob,sid_5),dhexp_real(key_s(bob),g))),dhexp_real(key_e(alice,bob,sid_5),dhexp_real(key_m(bob),g))),minnonce,hash(hash(hash(hash(hash(somename,empty),empty),validkey(dhexp_real(key_s(bob),g))),validkey(dhexp_real(key_m(bob),g))),validkey(dhexp_real(key_e(alice,bob,sid_5),g))),validkey(dhexp_real(key_s(alice),g)))),encrypt(hmac_hash2(hmac_hash1(hash(somename,empty),dhexp_real(key_e(alice,bob,sid_5),dhexp_real(key_s(bob),g))),dhexp_real(key_e(alice,bob,sid_5),dhexp_real(key_m(bob),g))),increment_nonce(minnonce),hash(hash(hash(hash(hash(hash(somename,empty),empty),validkey(dhexp_real(key_s(bob),g))),validkey(dhexp_real(key_m(bob),g))),validkey(dhexp_real(key_e(alice,bob,sid_5),g))),encrypt(hmac_hash2(hmac_hash1(hash(somename,empty),dhexp_real(key_e(alice,bob,sid_5),dhexp_real(key_s(bob),g))),dhexp_real(key_e(alice,bob,sid_5),dhexp_real(key_m(bob),g))),minnonce,hash(hash(hash(hash(hash(somename,empty),empty),validkey(dhexp_real(key_s(bob),g))),validkey(dhexp_real(key_m(bob),g))),validkey(dhexp_real(key_e(alice,bob,sid_5),g))),validkey(dhexp_real(key_s(alice),g)))),validkey(dhexp_real(key_m(alice),g)))),msg_a(alice,bob,sid_5))) by listening on this channel.
attacker(concat4(validkey(dhexp_real(key_e(alice,bob,sid_5),g)),encrypt(hmac_hash2(hmac_hash1(hash(somename,empty),dhexp_real(key_e(alice,bob,sid_5),dhexp_real(key_s(bob),g))),dhexp_real(key_e(alice,bob,sid_5),dhexp_real(key_m(bob),g))),minnonce,hash(hash(hash(hash(hash(somename,empty),empty),validkey(dhexp_real(key_s(bob),g))),validkey(dhexp_real(key_m(bob),g))),validkey(dhexp_real(key_e(alice,bob,sid_5),g))),validkey(dhexp_real(key_s(alice),g))),encrypt(hmac_hash2(hmac_hash1(hash(somename,empty),dhexp_real(key_e(alice,bob,sid_5),dhexp_real(key_s(bob),g))),dhexp_real(key_e(alice,bob,sid_5),dhexp_real(key_m(bob),g))),increment_nonce(minnonce),hash(hash(hash(hash(hash(hash(somename,empty),empty),validkey(dhexp_real(key_s(bob),g))),validkey(dhexp_real(key_m(bob),g))),validkey(dhexp_real(key_e(alice,bob,sid_5),g))),encrypt(hmac_hash2(hmac_hash1(hash(somename,empty),dhexp_real(key_e(alice,bob,sid_5),dhexp_real(key_s(bob),g))),dhexp_real(key_e(alice,bob,sid_5),dhexp_real(key_m(bob),g))),minnonce,hash(hash(hash(hash(hash(somename,empty),empty),validkey(dhexp_real(key_s(bob),g))),validkey(dhexp_real(key_m(bob),g))),validkey(dhexp_real(key_e(alice,bob,sid_5),g))),validkey(dhexp_real(key_s(alice),g)))),validkey(dhexp_real(key_m(alice),g))),encrypt(hmac_hash2(hmac_hash1(hmac_hash1(hmac_hash1(hash(somename,empty),dhexp_real(key_e(alice,bob,sid_5),dhexp_real(key_s(bob),g))),dhexp_real(key_e(alice,bob,sid_5),dhexp_real(key_m(bob),g))),dhexp_real(key_m(alice),dhexp_real(key_s(bob),g))),dhexp_real(key_s(alice),dhexp_real(key_m(bob),g))),minnonce,hash(hash(hash(hash(hash(hash(hash(somename,empty),empty),validkey(dhexp_real(key_s(bob),g))),validkey(dhexp_real(key_m(bob),g))),validkey(dhexp_real(key_e(alice,bob,sid_5),g))),encrypt(hmac_hash2(hmac_hash1(hash(somename,empty),dhexp_real(key_e(alice,bob,sid_5),dhexp_real(key_s(bob),g))),dhexp_real(key_e(alice,bob,sid_5),dhexp_real(key_m(bob),g))),minnonce,hash(hash(hash(hash(hash(somename,empty),empty),validkey(dhexp_real(key_s(bob),g))),validkey(dhexp_real(key_m(bob),g))),validkey(dhexp_real(key_e(alice,bob,sid_5),g))),validkey(dhexp_real(key_s(alice),g)))),encrypt(hmac_hash2(hmac_hash1(hash(somename,empty),dhexp_real(key_e(alice,bob,sid_5),dhexp_real(key_s(bob),g))),dhexp_real(key_e(alice,bob,sid_5),dhexp_real(key_m(bob),g))),increment_nonce(minnonce),hash(hash(hash(hash(hash(hash(somename,empty),empty),validkey(dhexp_real(key_s(bob),g))),validkey(dhexp_real(key_m(bob),g))),validkey(dhexp_real(key_e(alice,bob,sid_5),g))),encrypt(hmac_hash2(hmac_hash1(hash(somename,empty),dhexp_real(key_e(alice,bob,sid_5),dhexp_real(key_s(bob),g))),dhexp_real(key_e(alice,bob,sid_5),dhexp_real(key_m(bob),g))),minnonce,hash(hash(hash(hash(hash(somename,empty),empty),validkey(dhexp_real(key_s(bob),g))),validkey(dhexp_real(key_m(bob),g))),validkey(dhexp_real(key_e(alice,bob,sid_5),g))),validkey(dhexp_real(key_s(alice),g)))),validkey(dhexp_real(key_m(alice),g)))),msg_a(alice,bob,sid_5)))).

9. By 8, the attacker may know concat4(validkey(dhexp_real(key_e(alice,bob,sid_5),g)),encrypt(hmac_hash2(hmac_hash1(hash(somename,empty),dhexp_real(key_e(alice,bob,sid_5),dhexp_real(key_s(bob),g))),dhexp_real(key_e(alice,bob,sid_5),dhexp_real(key_m(bob),g))),minnonce,hash(hash(hash(hash(hash(somename,empty),empty),validkey(dhexp_real(key_s(bob),g))),validkey(dhexp_real(key_m(bob),g))),validkey(dhexp_real(key_e(alice,bob,sid_5),g))),validkey(dhexp_real(key_s(alice),g))),encrypt(hmac_hash2(hmac_hash1(hash(somename,empty),dhexp_real(key_e(alice,bob,sid_5),dhexp_real(key_s(bob),g))),dhexp_real(key_e(alice,bob,sid_5),dhexp_real(key_m(bob),g))),increment_nonce(minnonce),hash(hash(hash(hash(hash(hash(somename,empty),empty),validkey(dhexp_real(key_s(bob),g))),validkey(dhexp_real(key_m(bob),g))),validkey(dhexp_real(key_e(alice,bob,sid_5),g))),encrypt(hmac_hash2(hmac_hash1(hash(somename,empty),dhexp_real(key_e(alice,bob,sid_5),dhexp_real(key_s(bob),g))),dhexp_real(key_e(alice,bob,sid_5),dhexp_real(key_m(bob),g))),minnonce,hash(hash(hash(hash(hash(somename,empty),empty),validkey(dhexp_real(key_s(bob),g))),validkey(dhexp_real(key_m(bob),g))),validkey(dhexp_real(key_e(alice,bob,sid_5),g))),validkey(dhexp_real(key_s(alice),g)))),validkey(dhexp_real(key_m(alice),g))),encrypt(hmac_hash2(hmac_hash1(hmac_hash1(hmac_hash1(hash(somename,empty),dhexp_real(key_e(alice,bob,sid_5),dhexp_real(key_s(bob),g))),dhexp_real(key_e(alice,bob,sid_5),dhexp_real(key_m(bob),g))),dhexp_real(key_m(alice),dhexp_real(key_s(bob),g))),dhexp_real(key_s(alice),dhexp_real(key_m(bob),g))),minnonce,hash(hash(hash(hash(hash(hash(hash(somename,empty),empty),validkey(dhexp_real(key_s(bob),g))),validkey(dhexp_real(key_m(bob),g))),validkey(dhexp_real(key_e(alice,bob,sid_5),g))),encrypt(hmac_hash2(hmac_hash1(hash(somename,empty),dhexp_real(key_e(alice,bob,sid_5),dhexp_real(key_s(bob),g))),dhexp_real(key_e(alice,bob,sid_5),dhexp_real(key_m(bob),g))),minnonce,hash(hash(hash(hash(hash(somename,empty),empty),validkey(dhexp_real(key_s(bob),g))),validkey(dhexp_real(key_m(bob),g))),validkey(dhexp_real(key_e(alice,bob,sid_5),g))),validkey(dhexp_real(key_s(alice),g)))),encrypt(hmac_hash2(hmac_hash1(hash(somename,empty),dhexp_real(key_e(alice,bob,sid_5),dhexp_real(key_s(bob),g))),dhexp_real(key_e(alice,bob,sid_5),dhexp_real(key_m(bob),g))),increment_nonce(minnonce),hash(hash(hash(hash(hash(hash(somename,empty),empty),validkey(dhexp_real(key_s(bob),g))),validkey(dhexp_real(key_m(bob),g))),validkey(dhexp_real(key_e(alice,bob,sid_5),g))),encrypt(hmac_hash2(hmac_hash1(hash(somename,empty),dhexp_real(key_e(alice,bob,sid_5),dhexp_real(key_s(bob),g))),dhexp_real(key_e(alice,bob,sid_5),dhexp_real(key_m(bob),g))),minnonce,hash(hash(hash(hash(hash(somename,empty),empty),validkey(dhexp_real(key_s(bob),g))),validkey(dhexp_real(key_m(bob),g))),validkey(dhexp_real(key_e(alice,bob,sid_5),g))),validkey(dhexp_real(key_s(alice),g)))),validkey(dhexp_real(key_m(alice),g)))),msg_a(alice,bob,sid_5))).
Using the function 3-proj-concat4 the attacker may obtain encrypt(hmac_hash2(hmac_hash1(hash(somename,empty),dhexp_real(key_e(alice,bob,sid_5),dhexp_real(key_s(bob),g))),dhexp_real(key_e(alice,bob,sid_5),dhexp_real(key_m(bob),g))),increment_nonce(minnonce),hash(hash(hash(hash(hash(hash(somename,empty),empty),validkey(dhexp_real(key_s(bob),g))),validkey(dhexp_real(key_m(bob),g))),validkey(dhexp_real(key_e(alice,bob,sid_5),g))),encrypt(hmac_hash2(hmac_hash1(hash(somename,empty),dhexp_real(key_e(alice,bob,sid_5),dhexp_real(key_s(bob),g))),dhexp_real(key_e(alice,bob,sid_5),dhexp_real(key_m(bob),g))),minnonce,hash(hash(hash(hash(hash(somename,empty),empty),validkey(dhexp_real(key_s(bob),g))),validkey(dhexp_real(key_m(bob),g))),validkey(dhexp_real(key_e(alice,bob,sid_5),g))),validkey(dhexp_real(key_s(alice),g)))),validkey(dhexp_real(key_m(alice),g))).
attacker(encrypt(hmac_hash2(hmac_hash1(hash(somename,empty),dhexp_real(key_e(alice,bob,sid_5),dhexp_real(key_s(bob),g))),dhexp_real(key_e(alice,bob,sid_5),dhexp_real(key_m(bob),g))),increment_nonce(minnonce),hash(hash(hash(hash(hash(hash(somename,empty),empty),validkey(dhexp_real(key_s(bob),g))),validkey(dhexp_real(key_m(bob),g))),validkey(dhexp_real(key_e(alice,bob,sid_5),g))),encrypt(hmac_hash2(hmac_hash1(hash(somename,empty),dhexp_real(key_e(alice,bob,sid_5),dhexp_real(key_s(bob),g))),dhexp_real(key_e(alice,bob,sid_5),dhexp_real(key_m(bob),g))),minnonce,hash(hash(hash(hash(hash(somename,empty),empty),validkey(dhexp_real(key_s(bob),g))),validkey(dhexp_real(key_m(bob),g))),validkey(dhexp_real(key_e(alice,bob,sid_5),g))),validkey(dhexp_real(key_s(alice),g)))),validkey(dhexp_real(key_m(alice),g)))).

10. By 8, the attacker may know concat4(validkey(dhexp_real(key_e(alice,bob,sid_5),g)),encrypt(hmac_hash2(hmac_hash1(hash(somename,empty),dhexp_real(key_e(alice,bob,sid_5),dhexp_real(key_s(bob),g))),dhexp_real(key_e(alice,bob,sid_5),dhexp_real(key_m(bob),g))),minnonce,hash(hash(hash(hash(hash(somename,empty),empty),validkey(dhexp_real(key_s(bob),g))),validkey(dhexp_real(key_m(bob),g))),validkey(dhexp_real(key_e(alice,bob,sid_5),g))),validkey(dhexp_real(key_s(alice),g))),encrypt(hmac_hash2(hmac_hash1(hash(somename,empty),dhexp_real(key_e(alice,bob,sid_5),dhexp_real(key_s(bob),g))),dhexp_real(key_e(alice,bob,sid_5),dhexp_real(key_m(bob),g))),increment_nonce(minnonce),hash(hash(hash(hash(hash(hash(somename,empty),empty),validkey(dhexp_real(key_s(bob),g))),validkey(dhexp_real(key_m(bob),g))),validkey(dhexp_real(key_e(alice,bob,sid_5),g))),encrypt(hmac_hash2(hmac_hash1(hash(somename,empty),dhexp_real(key_e(alice,bob,sid_5),dhexp_real(key_s(bob),g))),dhexp_real(key_e(alice,bob,sid_5),dhexp_real(key_m(bob),g))),minnonce,hash(hash(hash(hash(hash(somename,empty),empty),validkey(dhexp_real(key_s(bob),g))),validkey(dhexp_real(key_m(bob),g))),validkey(dhexp_real(key_e(alice,bob,sid_5),g))),validkey(dhexp_real(key_s(alice),g)))),validkey(dhexp_real(key_m(alice),g))),encrypt(hmac_hash2(hmac_hash1(hmac_hash1(hmac_hash1(hash(somename,empty),dhexp_real(key_e(alice,bob,sid_5),dhexp_real(key_s(bob),g))),dhexp_real(key_e(alice,bob,sid_5),dhexp_real(key_m(bob),g))),dhexp_real(key_m(alice),dhexp_real(key_s(bob),g))),dhexp_real(key_s(alice),dhexp_real(key_m(bob),g))),minnonce,hash(hash(hash(hash(hash(hash(hash(somename,empty),empty),validkey(dhexp_real(key_s(bob),g))),validkey(dhexp_real(key_m(bob),g))),validkey(dhexp_real(key_e(alice,bob,sid_5),g))),encrypt(hmac_hash2(hmac_hash1(hash(somename,empty),dhexp_real(key_e(alice,bob,sid_5),dhexp_real(key_s(bob),g))),dhexp_real(key_e(alice,bob,sid_5),dhexp_real(key_m(bob),g))),minnonce,hash(hash(hash(hash(hash(somename,empty),empty),validkey(dhexp_real(key_s(bob),g))),validkey(dhexp_real(key_m(bob),g))),validkey(dhexp_real(key_e(alice,bob,sid_5),g))),validkey(dhexp_real(key_s(alice),g)))),encrypt(hmac_hash2(hmac_hash1(hash(somename,empty),dhexp_real(key_e(alice,bob,sid_5),dhexp_real(key_s(bob),g))),dhexp_real(key_e(alice,bob,sid_5),dhexp_real(key_m(bob),g))),increment_nonce(minnonce),hash(hash(hash(hash(hash(hash(somename,empty),empty),validkey(dhexp_real(key_s(bob),g))),validkey(dhexp_real(key_m(bob),g))),validkey(dhexp_real(key_e(alice,bob,sid_5),g))),encrypt(hmac_hash2(hmac_hash1(hash(somename,empty),dhexp_real(key_e(alice,bob,sid_5),dhexp_real(key_s(bob),g))),dhexp_real(key_e(alice,bob,sid_5),dhexp_real(key_m(bob),g))),minnonce,hash(hash(hash(hash(hash(somename,empty),empty),validkey(dhexp_real(key_s(bob),g))),validkey(dhexp_real(key_m(bob),g))),validkey(dhexp_real(key_e(alice,bob,sid_5),g))),validkey(dhexp_real(key_s(alice),g)))),validkey(dhexp_real(key_m(alice),g)))),msg_a(alice,bob,sid_5))).
Using the function 2-proj-concat4 the attacker may obtain encrypt(hmac_hash2(hmac_hash1(hash(somename,empty),dhexp_real(key_e(alice,bob,sid_5),dhexp_real(key_s(bob),g))),dhexp_real(key_e(alice,bob,sid_5),dhexp_real(key_m(bob),g))),minnonce,hash(hash(hash(hash(hash(somename,empty),empty),validkey(dhexp_real(key_s(bob),g))),validkey(dhexp_real(key_m(bob),g))),validkey(dhexp_real(key_e(alice,bob,sid_5),g))),validkey(dhexp_real(key_s(alice),g))).
attacker(encrypt(hmac_hash2(hmac_hash1(hash(somename,empty),dhexp_real(key_e(alice,bob,sid_5),dhexp_real(key_s(bob),g))),dhexp_real(key_e(alice,bob,sid_5),dhexp_real(key_m(bob),g))),minnonce,hash(hash(hash(hash(hash(somename,empty),empty),validkey(dhexp_real(key_s(bob),g))),validkey(dhexp_real(key_m(bob),g))),validkey(dhexp_real(key_e(alice,bob,sid_5),g))),validkey(dhexp_real(key_s(alice),g)))).

11. By 8, the attacker may know concat4(validkey(dhexp_real(key_e(alice,bob,sid_5),g)),encrypt(hmac_hash2(hmac_hash1(hash(somename,empty),dhexp_real(key_e(alice,bob,sid_5),dhexp_real(key_s(bob),g))),dhexp_real(key_e(alice,bob,sid_5),dhexp_real(key_m(bob),g))),minnonce,hash(hash(hash(hash(hash(somename,empty),empty),validkey(dhexp_real(key_s(bob),g))),validkey(dhexp_real(key_m(bob),g))),validkey(dhexp_real(key_e(alice,bob,sid_5),g))),validkey(dhexp_real(key_s(alice),g))),encrypt(hmac_hash2(hmac_hash1(hash(somename,empty),dhexp_real(key_e(alice,bob,sid_5),dhexp_real(key_s(bob),g))),dhexp_real(key_e(alice,bob,sid_5),dhexp_real(key_m(bob),g))),increment_nonce(minnonce),hash(hash(hash(hash(hash(hash(somename,empty),empty),validkey(dhexp_real(key_s(bob),g))),validkey(dhexp_real(key_m(bob),g))),validkey(dhexp_real(key_e(alice,bob,sid_5),g))),encrypt(hmac_hash2(hmac_hash1(hash(somename,empty),dhexp_real(key_e(alice,bob,sid_5),dhexp_real(key_s(bob),g))),dhexp_real(key_e(alice,bob,sid_5),dhexp_real(key_m(bob),g))),minnonce,hash(hash(hash(hash(hash(somename,empty),empty),validkey(dhexp_real(key_s(bob),g))),validkey(dhexp_real(key_m(bob),g))),validkey(dhexp_real(key_e(alice,bob,sid_5),g))),validkey(dhexp_real(key_s(alice),g)))),validkey(dhexp_real(key_m(alice),g))),encrypt(hmac_hash2(hmac_hash1(hmac_hash1(hmac_hash1(hash(somename,empty),dhexp_real(key_e(alice,bob,sid_5),dhexp_real(key_s(bob),g))),dhexp_real(key_e(alice,bob,sid_5),dhexp_real(key_m(bob),g))),dhexp_real(key_m(alice),dhexp_real(key_s(bob),g))),dhexp_real(key_s(alice),dhexp_real(key_m(bob),g))),minnonce,hash(hash(hash(hash(hash(hash(hash(somename,empty),empty),validkey(dhexp_real(key_s(bob),g))),validkey(dhexp_real(key_m(bob),g))),validkey(dhexp_real(key_e(alice,bob,sid_5),g))),encrypt(hmac_hash2(hmac_hash1(hash(somename,empty),dhexp_real(key_e(alice,bob,sid_5),dhexp_real(key_s(bob),g))),dhexp_real(key_e(alice,bob,sid_5),dhexp_real(key_m(bob),g))),minnonce,hash(hash(hash(hash(hash(somename,empty),empty),validkey(dhexp_real(key_s(bob),g))),validkey(dhexp_real(key_m(bob),g))),validkey(dhexp_real(key_e(alice,bob,sid_5),g))),validkey(dhexp_real(key_s(alice),g)))),encrypt(hmac_hash2(hmac_hash1(hash(somename,empty),dhexp_real(key_e(alice,bob,sid_5),dhexp_real(key_s(bob),g))),dhexp_real(key_e(alice,bob,sid_5),dhexp_real(key_m(bob),g))),increment_nonce(minnonce),hash(hash(hash(hash(hash(hash(somename,empty),empty),validkey(dhexp_real(key_s(bob),g))),validkey(dhexp_real(key_m(bob),g))),validkey(dhexp_real(key_e(alice,bob,sid_5),g))),encrypt(hmac_hash2(hmac_hash1(hash(somename,empty),dhexp_real(key_e(alice,bob,sid_5),dhexp_real(key_s(bob),g))),dhexp_real(key_e(alice,bob,sid_5),dhexp_real(key_m(bob),g))),minnonce,hash(hash(hash(hash(hash(somename,empty),empty),validkey(dhexp_real(key_s(bob),g))),validkey(dhexp_real(key_m(bob),g))),validkey(dhexp_real(key_e(alice,bob,sid_5),g))),validkey(dhexp_real(key_s(alice),g)))),validkey(dhexp_real(key_m(alice),g)))),msg_a(alice,bob,sid_5))).
Using the function 1-proj-concat4 the attacker may obtain validkey(dhexp_real(key_e(alice,bob,sid_5),g)).
attacker(validkey(dhexp_real(key_e(alice,bob,sid_5),g))).

12. The message (validkey(dhexp_real(key_s(bob),g)),validkey(dhexp_real(key_m(bob),g))) may be sent on channel pub at output {635}.
mess(pub,(validkey(dhexp_real(key_s(bob),g)),validkey(dhexp_real(key_m(bob),g)))).

13. By 1, the attacker may have the channel pub.
By 12, the message (validkey(dhexp_real(key_s(bob),g)),validkey(dhexp_real(key_m(bob),g))) may be sent on this channel.
So the attacker may obtain the message (validkey(dhexp_real(key_s(bob),g)),validkey(dhexp_real(key_m(bob),g))) by listening on this channel.
attacker((validkey(dhexp_real(key_s(bob),g)),validkey(dhexp_real(key_m(bob),g)))).

14. By 13, the attacker may know (validkey(dhexp_real(key_s(bob),g)),validkey(dhexp_real(key_m(bob),g))).
Using the function 2-proj-2-tuple the attacker may obtain validkey(dhexp_real(key_m(bob),g)).
attacker(validkey(dhexp_real(key_m(bob),g))).

15. By 13, the attacker may know (validkey(dhexp_real(key_s(bob),g)),validkey(dhexp_real(key_m(bob),g))).
Using the function 1-proj-2-tuple the attacker may obtain validkey(dhexp_real(key_s(bob),g)).
attacker(validkey(dhexp_real(key_s(bob),g))).

16. Using the function empty the attacker may obtain empty.
attacker(empty).

17. Using the function somename the attacker may obtain somename.
attacker(somename).

18. By 17, the attacker may know somename.
By 16, the attacker may know empty.
Using the function hash the attacker may obtain hash(somename,empty).
attacker(hash(somename,empty)).

19. By 18, the attacker may know hash(somename,empty).
By 16, the attacker may know empty.
Using the function hash the attacker may obtain hash(hash(somename,empty),empty).
attacker(hash(hash(somename,empty),empty)).

20. By 19, the attacker may know hash(hash(somename,empty),empty).
By 15, the attacker may know validkey(dhexp_real(key_s(bob),g)).
Using the function hash the attacker may obtain hash(hash(hash(somename,empty),empty),validkey(dhexp_real(key_s(bob),g))).
attacker(hash(hash(hash(somename,empty),empty),validkey(dhexp_real(key_s(bob),g)))).

21. By 20, the attacker may know hash(hash(hash(somename,empty),empty),validkey(dhexp_real(key_s(bob),g))).
By 14, the attacker may know validkey(dhexp_real(key_m(bob),g)).
Using the function hash the attacker may obtain hash(hash(hash(hash(somename,empty),empty),validkey(dhexp_real(key_s(bob),g))),validkey(dhexp_real(key_m(bob),g))).
attacker(hash(hash(hash(hash(somename,empty),empty),validkey(dhexp_real(key_s(bob),g))),validkey(dhexp_real(key_m(bob),g)))).

22. By 21, the attacker may know hash(hash(hash(hash(somename,empty),empty),validkey(dhexp_real(key_s(bob),g))),validkey(dhexp_real(key_m(bob),g))).
By 11, the attacker may know validkey(dhexp_real(key_e(alice,bob,sid_5),g)).
Using the function hash the attacker may obtain hash(hash(hash(hash(hash(somename,empty),empty),validkey(dhexp_real(key_s(bob),g))),validkey(dhexp_real(key_m(bob),g))),validkey(dhexp_real(key_e(alice,bob,sid_5),g))).
attacker(hash(hash(hash(hash(hash(somename,empty),empty),validkey(dhexp_real(key_s(bob),g))),validkey(dhexp_real(key_m(bob),g))),validkey(dhexp_real(key_e(alice,bob,sid_5),g)))).

23. By 22, the attacker may know hash(hash(hash(hash(hash(somename,empty),empty),validkey(dhexp_real(key_s(bob),g))),validkey(dhexp_real(key_m(bob),g))),validkey(dhexp_real(key_e(alice,bob,sid_5),g))).
By 10, the attacker may know encrypt(hmac_hash2(hmac_hash1(hash(somename,empty),dhexp_real(key_e(alice,bob,sid_5),dhexp_real(key_s(bob),g))),dhexp_real(key_e(alice,bob,sid_5),dhexp_real(key_m(bob),g))),minnonce,hash(hash(hash(hash(hash(somename,empty),empty),validkey(dhexp_real(key_s(bob),g))),validkey(dhexp_real(key_m(bob),g))),validkey(dhexp_real(key_e(alice,bob,sid_5),g))),validkey(dhexp_real(key_s(alice),g))).
Using the function hash the attacker may obtain hash(hash(hash(hash(hash(hash(somename,empty),empty),validkey(dhexp_real(key_s(bob),g))),validkey(dhexp_real(key_m(bob),g))),validkey(dhexp_real(key_e(alice,bob,sid_5),g))),encrypt(hmac_hash2(hmac_hash1(hash(somename,empty),dhexp_real(key_e(alice,bob,sid_5),dhexp_real(key_s(bob),g))),dhexp_real(key_e(alice,bob,sid_5),dhexp_real(key_m(bob),g))),minnonce,hash(hash(hash(hash(hash(somename,empty),empty),validkey(dhexp_real(key_s(bob),g))),validkey(dhexp_real(key_m(bob),g))),validkey(dhexp_real(key_e(alice,bob,sid_5),g))),validkey(dhexp_real(key_s(alice),g)))).
attacker(hash(hash(hash(hash(hash(hash(somename,empty),empty),validkey(dhexp_real(key_s(bob),g))),validkey(dhexp_real(key_m(bob),g))),validkey(dhexp_real(key_e(alice,bob,sid_5),g))),encrypt(hmac_hash2(hmac_hash1(hash(somename,empty),dhexp_real(key_e(alice,bob,sid_5),dhexp_real(key_s(bob),g))),dhexp_real(key_e(alice,bob,sid_5),dhexp_real(key_m(bob),g))),minnonce,hash(hash(hash(hash(hash(somename,empty),empty),validkey(dhexp_real(key_s(bob),g))),validkey(dhexp_real(key_m(bob),g))),validkey(dhexp_real(key_e(alice,bob,sid_5),g))),validkey(dhexp_real(key_s(alice),g))))).

24. By 23, the attacker may know hash(hash(hash(hash(hash(hash(somename,empty),empty),validkey(dhexp_real(key_s(bob),g))),validkey(dhexp_real(key_m(bob),g))),validkey(dhexp_real(key_e(alice,bob,sid_5),g))),encrypt(hmac_hash2(hmac_hash1(hash(somename,empty),dhexp_real(key_e(alice,bob,sid_5),dhexp_real(key_s(bob),g))),dhexp_real(key_e(alice,bob,sid_5),dhexp_real(key_m(bob),g))),minnonce,hash(hash(hash(hash(hash(somename,empty),empty),validkey(dhexp_real(key_s(bob),g))),validkey(dhexp_real(key_m(bob),g))),validkey(dhexp_real(key_e(alice,bob,sid_5),g))),validkey(dhexp_real(key_s(alice),g)))).
By 9, the attacker may know encrypt(hmac_hash2(hmac_hash1(hash(somename,empty),dhexp_real(key_e(alice,bob,sid_5),dhexp_real(key_s(bob),g))),dhexp_real(key_e(alice,bob,sid_5),dhexp_real(key_m(bob),g))),increment_nonce(minnonce),hash(hash(hash(hash(hash(hash(somename,empty),empty),validkey(dhexp_real(key_s(bob),g))),validkey(dhexp_real(key_m(bob),g))),validkey(dhexp_real(key_e(alice,bob,sid_5),g))),encrypt(hmac_hash2(hmac_hash1(hash(somename,empty),dhexp_real(key_e(alice,bob,sid_5),dhexp_real(key_s(bob),g))),dhexp_real(key_e(alice,bob,sid_5),dhexp_real(key_m(bob),g))),minnonce,hash(hash(hash(hash(hash(somename,empty),empty),validkey(dhexp_real(key_s(bob),g))),validkey(dhexp_real(key_m(bob),g))),validkey(dhexp_real(key_e(alice,bob,sid_5),g))),validkey(dhexp_real(key_s(alice),g)))),validkey(dhexp_real(key_m(alice),g))).
Using the function hash the attacker may obtain hash(hash(hash(hash(hash(hash(hash(somename,empty),empty),validkey(dhexp_real(key_s(bob),g))),validkey(dhexp_real(key_m(bob),g))),validkey(dhexp_real(key_e(alice,bob,sid_5),g))),encrypt(hmac_hash2(hmac_hash1(hash(somename,empty),dhexp_real(key_e(alice,bob,sid_5),dhexp_real(key_s(bob),g))),dhexp_real(key_e(alice,bob,sid_5),dhexp_real(key_m(bob),g))),minnonce,hash(hash(hash(hash(hash(somename,empty),empty),validkey(dhexp_real(key_s(bob),g))),validkey(dhexp_real(key_m(bob),g))),validkey(dhexp_real(key_e(alice,bob,sid_5),g))),validkey(dhexp_real(key_s(alice),g)))),encrypt(hmac_hash2(hmac_hash1(hash(somename,empty),dhexp_real(key_e(alice,bob,sid_5),dhexp_real(key_s(bob),g))),dhexp_real(key_e(alice,bob,sid_5),dhexp_real(key_m(bob),g))),increment_nonce(minnonce),hash(hash(hash(hash(hash(hash(somename,empty),empty),validkey(dhexp_real(key_s(bob),g))),validkey(dhexp_real(key_m(bob),g))),validkey(dhexp_real(key_e(alice,bob,sid_5),g))),encrypt(hmac_hash2(hmac_hash1(hash(somename,empty),dhexp_real(key_e(alice,bob,sid_5),dhexp_real(key_s(bob),g))),dhexp_real(key_e(alice,bob,sid_5),dhexp_real(key_m(bob),g))),minnonce,hash(hash(hash(hash(hash(somename,empty),empty),validkey(dhexp_real(key_s(bob),g))),validkey(dhexp_real(key_m(bob),g))),validkey(dhexp_real(key_e(alice,bob,sid_5),g))),validkey(dhexp_real(key_s(alice),g)))),validkey(dhexp_real(key_m(alice),g)))).
attacker(hash(hash(hash(hash(hash(hash(hash(somename,empty),empty),validkey(dhexp_real(key_s(bob),g))),validkey(dhexp_real(key_m(bob),g))),validkey(dhexp_real(key_e(alice,bob,sid_5),g))),encrypt(hmac_hash2(hmac_hash1(hash(somename,empty),dhexp_real(key_e(alice,bob,sid_5),dhexp_real(key_s(bob),g))),dhexp_real(key_e(alice,bob,sid_5),dhexp_real(key_m(bob),g))),minnonce,hash(hash(hash(hash(hash(somename,empty),empty),validkey(dhexp_real(key_s(bob),g))),validkey(dhexp_real(key_m(bob),g))),validkey(dhexp_real(key_e(alice,bob,sid_5),g))),validkey(dhexp_real(key_s(alice),g)))),encrypt(hmac_hash2(hmac_hash1(hash(somename,empty),dhexp_real(key_e(alice,bob,sid_5),dhexp_real(key_s(bob),g))),dhexp_real(key_e(alice,bob,sid_5),dhexp_real(key_m(bob),g))),increment_nonce(minnonce),hash(hash(hash(hash(hash(hash(somename,empty),empty),validkey(dhexp_real(key_s(bob),g))),validkey(dhexp_real(key_m(bob),g))),validkey(dhexp_real(key_e(alice,bob,sid_5),g))),encrypt(hmac_hash2(hmac_hash1(hash(somename,empty),dhexp_real(key_e(alice,bob,sid_5),dhexp_real(key_s(bob),g))),dhexp_real(key_e(alice,bob,sid_5),dhexp_real(key_m(bob),g))),minnonce,hash(hash(hash(hash(hash(somename,empty),empty),validkey(dhexp_real(key_s(bob),g))),validkey(dhexp_real(key_m(bob),g))),validkey(dhexp_real(key_e(alice,bob,sid_5),g))),validkey(dhexp_real(key_s(alice),g)))),validkey(dhexp_real(key_m(alice),g))))).

25. By 24, the attacker may know hash(hash(hash(hash(hash(hash(hash(somename,empty),empty),validkey(dhexp_real(key_s(bob),g))),validkey(dhexp_real(key_m(bob),g))),validkey(dhexp_real(key_e(alice,bob,sid_5),g))),encrypt(hmac_hash2(hmac_hash1(hash(somename,empty),dhexp_real(key_e(alice,bob,sid_5),dhexp_real(key_s(bob),g))),dhexp_real(key_e(alice,bob,sid_5),dhexp_real(key_m(bob),g))),minnonce,hash(hash(hash(hash(hash(somename,empty),empty),validkey(dhexp_real(key_s(bob),g))),validkey(dhexp_real(key_m(bob),g))),validkey(dhexp_real(key_e(alice,bob,sid_5),g))),validkey(dhexp_real(key_s(alice),g)))),encrypt(hmac_hash2(hmac_hash1(hash(somename,empty),dhexp_real(key_e(alice,bob,sid_5),dhexp_real(key_s(bob),g))),dhexp_real(key_e(alice,bob,sid_5),dhexp_real(key_m(bob),g))),increment_nonce(minnonce),hash(hash(hash(hash(hash(hash(somename,empty),empty),validkey(dhexp_real(key_s(bob),g))),validkey(dhexp_real(key_m(bob),g))),validkey(dhexp_real(key_e(alice,bob,sid_5),g))),encrypt(hmac_hash2(hmac_hash1(hash(somename,empty),dhexp_real(key_e(alice,bob,sid_5),dhexp_real(key_s(bob),g))),dhexp_real(key_e(alice,bob,sid_5),dhexp_real(key_m(bob),g))),minnonce,hash(hash(hash(hash(hash(somename,empty),empty),validkey(dhexp_real(key_s(bob),g))),validkey(dhexp_real(key_m(bob),g))),validkey(dhexp_real(key_e(alice,bob,sid_5),g))),validkey(dhexp_real(key_s(alice),g)))),validkey(dhexp_real(key_m(alice),g)))).
So the attacker may know hash(hash(hash(hash(hash(hash(hash(somename,empty),empty),validkey(dhexp_real(key_s(bob),g))),validkey(dhexp_real(key_m(bob),g))),validkey(dhexp_real(key_e(alice,bob,sid_5),g))),encrypt(hmac_hash2(hmac_hash1(hash(somename,empty),dhexp_real(key_e(alice,bob,sid_5),dhexp_real(key_s(bob),g))),dhexp_real(key_e(alice,bob,sid_5),dhexp_real(key_m(bob),g))),minnonce,hash(hash(hash(hash(hash(somename,empty),empty),validkey(dhexp_real(key_s(bob),g))),validkey(dhexp_real(key_m(bob),g))),validkey(dhexp_real(key_e(alice,bob,sid_5),g))),validkey(dhexp_real(key_s(alice),g)))),encrypt(hmac_hash2(hmac_hash1(hash(somename,empty),dhexp_real(key_e(alice,bob,sid_5),dhexp_real(key_s(bob),g))),dhexp_real(key_e(alice,bob,sid_5),dhexp_real(key_m(bob),g))),increment_nonce(minnonce),hash(hash(hash(hash(hash(hash(somename,empty),empty),validkey(dhexp_real(key_s(bob),g))),validkey(dhexp_real(key_m(bob),g))),validkey(dhexp_real(key_e(alice,bob,sid_5),g))),encrypt(hmac_hash2(hmac_hash1(hash(somename,empty),dhexp_real(key_e(alice,bob,sid_5),dhexp_real(key_s(bob),g))),dhexp_real(key_e(alice,bob,sid_5),dhexp_real(key_m(bob),g))),minnonce,hash(hash(hash(hash(hash(somename,empty),empty),validkey(dhexp_real(key_s(bob),g))),validkey(dhexp_real(key_m(bob),g))),validkey(dhexp_real(key_e(alice,bob,sid_5),g))),validkey(dhexp_real(key_s(alice),g)))),validkey(dhexp_real(key_m(alice),g)))) in phase 1.
attacker_p1(hash(hash(hash(hash(hash(hash(hash(somename,empty),empty),validkey(dhexp_real(key_s(bob),g))),validkey(dhexp_real(key_m(bob),g))),validkey(dhexp_real(key_e(alice,bob,sid_5),g))),encrypt(hmac_hash2(hmac_hash1(hash(somename,empty),dhexp_real(key_e(alice,bob,sid_5),dhexp_real(key_s(bob),g))),dhexp_real(key_e(alice,bob,sid_5),dhexp_real(key_m(bob),g))),minnonce,hash(hash(hash(hash(hash(somename,empty),empty),validkey(dhexp_real(key_s(bob),g))),validkey(dhexp_real(key_m(bob),g))),validkey(dhexp_real(key_e(alice,bob,sid_5),g))),validkey(dhexp_real(key_s(alice),g)))),encrypt(hmac_hash2(hmac_hash1(hash(somename,empty),dhexp_real(key_e(alice,bob,sid_5),dhexp_real(key_s(bob),g))),dhexp_real(key_e(alice,bob,sid_5),dhexp_real(key_m(bob),g))),increment_nonce(minnonce),hash(hash(hash(hash(hash(hash(somename,empty),empty),validkey(dhexp_real(key_s(bob),g))),validkey(dhexp_real(key_m(bob),g))),validkey(dhexp_real(key_e(alice,bob,sid_5),g))),encrypt(hmac_hash2(hmac_hash1(hash(somename,empty),dhexp_real(key_e(alice,bob,sid_5),dhexp_real(key_s(bob),g))),dhexp_real(key_e(alice,bob,sid_5),dhexp_real(key_m(bob),g))),minnonce,hash(hash(hash(hash(hash(somename,empty),empty),validkey(dhexp_real(key_s(bob),g))),validkey(dhexp_real(key_m(bob),g))),validkey(dhexp_real(key_e(alice,bob,sid_5),g))),validkey(dhexp_real(key_s(alice),g)))),validkey(dhexp_real(key_m(alice),g))))).

26. Using the function minnonce the attacker may obtain minnonce in phase 1.
attacker_p1(minnonce).

27. By 10, the attacker may know encrypt(hmac_hash2(hmac_hash1(hash(somename,empty),dhexp_real(key_e(alice,bob,sid_5),dhexp_real(key_s(bob),g))),dhexp_real(key_e(alice,bob,sid_5),dhexp_real(key_m(bob),g))),minnonce,hash(hash(hash(hash(hash(somename,empty),empty),validkey(dhexp_real(key_s(bob),g))),validkey(dhexp_real(key_m(bob),g))),validkey(dhexp_real(key_e(alice,bob,sid_5),g))),validkey(dhexp_real(key_s(alice),g))).
So the attacker may know encrypt(hmac_hash2(hmac_hash1(hash(somename,empty),dhexp_real(key_e(alice,bob,sid_5),dhexp_real(key_s(bob),g))),dhexp_real(key_e(alice,bob,sid_5),dhexp_real(key_m(bob),g))),minnonce,hash(hash(hash(hash(hash(somename,empty),empty),validkey(dhexp_real(key_s(bob),g))),validkey(dhexp_real(key_m(bob),g))),validkey(dhexp_real(key_e(alice,bob,sid_5),g))),validkey(dhexp_real(key_s(alice),g))) in phase 1.
attacker_p1(encrypt(hmac_hash2(hmac_hash1(hash(somename,empty),dhexp_real(key_e(alice,bob,sid_5),dhexp_real(key_s(bob),g))),dhexp_real(key_e(alice,bob,sid_5),dhexp_real(key_m(bob),g))),minnonce,hash(hash(hash(hash(hash(somename,empty),empty),validkey(dhexp_real(key_s(bob),g))),validkey(dhexp_real(key_m(bob),g))),validkey(dhexp_real(key_e(alice,bob,sid_5),g))),validkey(dhexp_real(key_s(alice),g)))).

28. By 22, the attacker may know hash(hash(hash(hash(hash(somename,empty),empty),validkey(dhexp_real(key_s(bob),g))),validkey(dhexp_real(key_m(bob),g))),validkey(dhexp_real(key_e(alice,bob,sid_5),g))).
So the attacker may know hash(hash(hash(hash(hash(somename,empty),empty),validkey(dhexp_real(key_s(bob),g))),validkey(dhexp_real(key_m(bob),g))),validkey(dhexp_real(key_e(alice,bob,sid_5),g))) in phase 1.
attacker_p1(hash(hash(hash(hash(hash(somename,empty),empty),validkey(dhexp_real(key_s(bob),g))),validkey(dhexp_real(key_m(bob),g))),validkey(dhexp_real(key_e(alice,bob,sid_5),g)))).

29. By 11, the attacker may know validkey(dhexp_real(key_e(alice,bob,sid_5),g)).
So the attacker may know validkey(dhexp_real(key_e(alice,bob,sid_5),g)) in phase 1.
attacker_p1(validkey(dhexp_real(key_e(alice,bob,sid_5),g))).

30. Using the function pub the attacker may obtain pub in phase 1.
attacker_p1(pub).

31. The event LeakS(phase1,bob) may be executed at {949}.
The event LeakM(phase1,bob) may be executed at {950}.
So the message (key_s(bob),key_m(bob)) may be sent on channel pub in phase 1 at output {951}.
mess_p1(pub,(key_s(bob),key_m(bob))).

32. By 30, the attacker may have the channel pub in phase 1.
By 31, the message (key_s(bob),key_m(bob)) in phase 1 may be sent on this channel.
So the attacker may obtain the message (key_s(bob),key_m(bob)) in phase 1 by listening on this channel.
attacker_p1((key_s(bob),key_m(bob))).

33. By 32, the attacker may know (key_s(bob),key_m(bob)) in phase 1.
Using the function 2-proj-2-tuple the attacker may obtain key_m(bob) in phase 1.
attacker_p1(key_m(bob)).

34. By 33, the attacker may know key_m(bob) in phase 1.
By 29, the attacker may know validkey(dhexp_real(key_e(alice,bob,sid_5),g)) in phase 1.
Using the function dhexp the attacker may obtain dhexp_real(key_e(alice,bob,sid_5),dhexp_real(key_m(bob),g)) in phase 1.
attacker_p1(dhexp_real(key_e(alice,bob,sid_5),dhexp_real(key_m(bob),g))).

35. By 32, the attacker may know (key_s(bob),key_m(bob)) in phase 1.
Using the function 1-proj-2-tuple the attacker may obtain key_s(bob) in phase 1.
attacker_p1(key_s(bob)).

36. By 35, the attacker may know key_s(bob) in phase 1.
By 29, the attacker may know validkey(dhexp_real(key_e(alice,bob,sid_5),g)) in phase 1.
Using the function dhexp the attacker may obtain dhexp_real(key_e(alice,bob,sid_5),dhexp_real(key_s(bob),g)) in phase 1.
attacker_p1(dhexp_real(key_e(alice,bob,sid_5),dhexp_real(key_s(bob),g))).

37. Using the function empty the attacker may obtain empty in phase 1.
attacker_p1(empty).

38. Using the function somename the attacker may obtain somename in phase 1.
attacker_p1(somename).

39. By 38, the attacker may know somename in phase 1.
By 37, the attacker may know empty in phase 1.
Using the function hash the attacker may obtain hash(somename,empty) in phase 1.
attacker_p1(hash(somename,empty)).

40. By 39, the attacker may know hash(somename,empty) in phase 1.
By 36, the attacker may know dhexp_real(key_e(alice,bob,sid_5),dhexp_real(key_s(bob),g)) in phase 1.
Using the function hmac_hash1 the attacker may obtain hmac_hash1(hash(somename,empty),dhexp_real(key_e(alice,bob,sid_5),dhexp_real(key_s(bob),g))) in phase 1.
attacker_p1(hmac_hash1(hash(somename,empty),dhexp_real(key_e(alice,bob,sid_5),dhexp_real(key_s(bob),g)))).

41. By 40, the attacker may know hmac_hash1(hash(somename,empty),dhexp_real(key_e(alice,bob,sid_5),dhexp_real(key_s(bob),g))) in phase 1.
By 34, the attacker may know dhexp_real(key_e(alice,bob,sid_5),dhexp_real(key_m(bob),g)) in phase 1.
Using the function hmac_hash2 the attacker may obtain hmac_hash2(hmac_hash1(hash(somename,empty),dhexp_real(key_e(alice,bob,sid_5),dhexp_real(key_s(bob),g))),dhexp_real(key_e(alice,bob,sid_5),dhexp_real(key_m(bob),g))) in phase 1.
attacker_p1(hmac_hash2(hmac_hash1(hash(somename,empty),dhexp_real(key_e(alice,bob,sid_5),dhexp_real(key_s(bob),g))),dhexp_real(key_e(alice,bob,sid_5),dhexp_real(key_m(bob),g)))).

42. By 41, the attacker may know hmac_hash2(hmac_hash1(hash(somename,empty),dhexp_real(key_e(alice,bob,sid_5),dhexp_real(key_s(bob),g))),dhexp_real(key_e(alice,bob,sid_5),dhexp_real(key_m(bob),g))) in phase 1.
By 26, the attacker may know minnonce in phase 1.
By 28, the attacker may know hash(hash(hash(hash(hash(somename,empty),empty),validkey(dhexp_real(key_s(bob),g))),validkey(dhexp_real(key_m(bob),g))),validkey(dhexp_real(key_e(alice,bob,sid_5),g))) in phase 1.
By 27, the attacker may know encrypt(hmac_hash2(hmac_hash1(hash(somename,empty),dhexp_real(key_e(alice,bob,sid_5),dhexp_real(key_s(bob),g))),dhexp_real(key_e(alice,bob,sid_5),dhexp_real(key_m(bob),g))),minnonce,hash(hash(hash(hash(hash(somename,empty),empty),validkey(dhexp_real(key_s(bob),g))),validkey(dhexp_real(key_m(bob),g))),validkey(dhexp_real(key_e(alice,bob,sid_5),g))),validkey(dhexp_real(key_s(alice),g))) in phase 1.
Using the function decrypt the attacker may obtain aeadpack(true,hash(hash(hash(hash(hash(somename,empty),empty),validkey(dhexp_real(key_s(bob),g))),validkey(dhexp_real(key_m(bob),g))),validkey(dhexp_real(key_e(alice,bob,sid_5),g))),validkey(dhexp_real(key_s(alice),g))) in phase 1.
attacker_p1(aeadpack(true,hash(hash(hash(hash(hash(somename,empty),empty),validkey(dhexp_real(key_s(bob),g))),validkey(dhexp_real(key_m(bob),g))),validkey(dhexp_real(key_e(alice,bob,sid_5),g))),validkey(dhexp_real(key_s(alice),g)))).

43. By 42, the attacker may know aeadpack(true,hash(hash(hash(hash(hash(somename,empty),empty),validkey(dhexp_real(key_s(bob),g))),validkey(dhexp_real(key_m(bob),g))),validkey(dhexp_real(key_e(alice,bob,sid_5),g))),validkey(dhexp_real(key_s(alice),g))) in phase 1.
Using the function 3-proj-aeadpack the attacker may obtain validkey(dhexp_real(key_s(alice),g)) in phase 1.
attacker_p1(validkey(dhexp_real(key_s(alice),g))).

44. By 33, the attacker may know key_m(bob) in phase 1.
By 43, the attacker may know validkey(dhexp_real(key_s(alice),g)) in phase 1.
Using the function dhexp the attacker may obtain dhexp_real(key_m(bob),dhexp_real(key_s(alice),g)) in phase 1.
attacker_p1(dhexp_real(key_m(bob),dhexp_real(key_s(alice),g))).

45. By 9, the attacker may know encrypt(hmac_hash2(hmac_hash1(hash(somename,empty),dhexp_real(key_e(alice,bob,sid_5),dhexp_real(key_s(bob),g))),dhexp_real(key_e(alice,bob,sid_5),dhexp_real(key_m(bob),g))),increment_nonce(minnonce),hash(hash(hash(hash(hash(hash(somename,empty),empty),validkey(dhexp_real(key_s(bob),g))),validkey(dhexp_real(key_m(bob),g))),validkey(dhexp_real(key_e(alice,bob,sid_5),g))),encrypt(hmac_hash2(hmac_hash1(hash(somename,empty),dhexp_real(key_e(alice,bob,sid_5),dhexp_real(key_s(bob),g))),dhexp_real(key_e(alice,bob,sid_5),dhexp_real(key_m(bob),g))),minnonce,hash(hash(hash(hash(hash(somename,empty),empty),validkey(dhexp_real(key_s(bob),g))),validkey(dhexp_real(key_m(bob),g))),validkey(dhexp_real(key_e(alice,bob,sid_5),g))),validkey(dhexp_real(key_s(alice),g)))),validkey(dhexp_real(key_m(alice),g))).
So the attacker may know encrypt(hmac_hash2(hmac_hash1(hash(somename,empty),dhexp_real(key_e(alice,bob,sid_5),dhexp_real(key_s(bob),g))),dhexp_real(key_e(alice,bob,sid_5),dhexp_real(key_m(bob),g))),increment_nonce(minnonce),hash(hash(hash(hash(hash(hash(somename,empty),empty),validkey(dhexp_real(key_s(bob),g))),validkey(dhexp_real(key_m(bob),g))),validkey(dhexp_real(key_e(alice,bob,sid_5),g))),encrypt(hmac_hash2(hmac_hash1(hash(somename,empty),dhexp_real(key_e(alice,bob,sid_5),dhexp_real(key_s(bob),g))),dhexp_real(key_e(alice,bob,sid_5),dhexp_real(key_m(bob),g))),minnonce,hash(hash(hash(hash(hash(somename,empty),empty),validkey(dhexp_real(key_s(bob),g))),validkey(dhexp_real(key_m(bob),g))),validkey(dhexp_real(key_e(alice,bob,sid_5),g))),validkey(dhexp_real(key_s(alice),g)))),validkey(dhexp_real(key_m(alice),g))) in phase 1.
attacker_p1(encrypt(hmac_hash2(hmac_hash1(hash(somename,empty),dhexp_real(key_e(alice,bob,sid_5),dhexp_real(key_s(bob),g))),dhexp_real(key_e(alice,bob,sid_5),dhexp_real(key_m(bob),g))),increment_nonce(minnonce),hash(hash(hash(hash(hash(hash(somename,empty),empty),validkey(dhexp_real(key_s(bob),g))),validkey(dhexp_real(key_m(bob),g))),validkey(dhexp_real(key_e(alice,bob,sid_5),g))),encrypt(hmac_hash2(hmac_hash1(hash(somename,empty),dhexp_real(key_e(alice,bob,sid_5),dhexp_real(key_s(bob),g))),dhexp_real(key_e(alice,bob,sid_5),dhexp_real(key_m(bob),g))),minnonce,hash(hash(hash(hash(hash(somename,empty),empty),validkey(dhexp_real(key_s(bob),g))),validkey(dhexp_real(key_m(bob),g))),validkey(dhexp_real(key_e(alice,bob,sid_5),g))),validkey(dhexp_real(key_s(alice),g)))),validkey(dhexp_real(key_m(alice),g)))).

46. By 23, the attacker may know hash(hash(hash(hash(hash(hash(somename,empty),empty),validkey(dhexp_real(key_s(bob),g))),validkey(dhexp_real(key_m(bob),g))),validkey(dhexp_real(key_e(alice,bob,sid_5),g))),encrypt(hmac_hash2(hmac_hash1(hash(somename,empty),dhexp_real(key_e(alice,bob,sid_5),dhexp_real(key_s(bob),g))),dhexp_real(key_e(alice,bob,sid_5),dhexp_real(key_m(bob),g))),minnonce,hash(hash(hash(hash(hash(somename,empty),empty),validkey(dhexp_real(key_s(bob),g))),validkey(dhexp_real(key_m(bob),g))),validkey(dhexp_real(key_e(alice,bob,sid_5),g))),validkey(dhexp_real(key_s(alice),g)))).
So the attacker may know hash(hash(hash(hash(hash(hash(somename,empty),empty),validkey(dhexp_real(key_s(bob),g))),validkey(dhexp_real(key_m(bob),g))),validkey(dhexp_real(key_e(alice,bob,sid_5),g))),encrypt(hmac_hash2(hmac_hash1(hash(somename,empty),dhexp_real(key_e(alice,bob,sid_5),dhexp_real(key_s(bob),g))),dhexp_real(key_e(alice,bob,sid_5),dhexp_real(key_m(bob),g))),minnonce,hash(hash(hash(hash(hash(somename,empty),empty),validkey(dhexp_real(key_s(bob),g))),validkey(dhexp_real(key_m(bob),g))),validkey(dhexp_real(key_e(alice,bob,sid_5),g))),validkey(dhexp_real(key_s(alice),g)))) in phase 1.
attacker_p1(hash(hash(hash(hash(hash(hash(somename,empty),empty),validkey(dhexp_real(key_s(bob),g))),validkey(dhexp_real(key_m(bob),g))),validkey(dhexp_real(key_e(alice,bob,sid_5),g))),encrypt(hmac_hash2(hmac_hash1(hash(somename,empty),dhexp_real(key_e(alice,bob,sid_5),dhexp_real(key_s(bob),g))),dhexp_real(key_e(alice,bob,sid_5),dhexp_real(key_m(bob),g))),minnonce,hash(hash(hash(hash(hash(somename,empty),empty),validkey(dhexp_real(key_s(bob),g))),validkey(dhexp_real(key_m(bob),g))),validkey(dhexp_real(key_e(alice,bob,sid_5),g))),validkey(dhexp_real(key_s(alice),g))))).

47. By 26, the attacker may know minnonce in phase 1.
Using the function increment_nonce the attacker may obtain increment_nonce(minnonce) in phase 1.
attacker_p1(increment_nonce(minnonce)).

48. By 41, the attacker may know hmac_hash2(hmac_hash1(hash(somename,empty),dhexp_real(key_e(alice,bob,sid_5),dhexp_real(key_s(bob),g))),dhexp_real(key_e(alice,bob,sid_5),dhexp_real(key_m(bob),g))) in phase 1.
By 47, the attacker may know increment_nonce(minnonce) in phase 1.
By 46, the attacker may know hash(hash(hash(hash(hash(hash(somename,empty),empty),validkey(dhexp_real(key_s(bob),g))),validkey(dhexp_real(key_m(bob),g))),validkey(dhexp_real(key_e(alice,bob,sid_5),g))),encrypt(hmac_hash2(hmac_hash1(hash(somename,empty),dhexp_real(key_e(alice,bob,sid_5),dhexp_real(key_s(bob),g))),dhexp_real(key_e(alice,bob,sid_5),dhexp_real(key_m(bob),g))),minnonce,hash(hash(hash(hash(hash(somename,empty),empty),validkey(dhexp_real(key_s(bob),g))),validkey(dhexp_real(key_m(bob),g))),validkey(dhexp_real(key_e(alice,bob,sid_5),g))),validkey(dhexp_real(key_s(alice),g)))) in phase 1.
By 45, the attacker may know encrypt(hmac_hash2(hmac_hash1(hash(somename,empty),dhexp_real(key_e(alice,bob,sid_5),dhexp_real(key_s(bob),g))),dhexp_real(key_e(alice,bob,sid_5),dhexp_real(key_m(bob),g))),increment_nonce(minnonce),hash(hash(hash(hash(hash(hash(somename,empty),empty),validkey(dhexp_real(key_s(bob),g))),validkey(dhexp_real(key_m(bob),g))),validkey(dhexp_real(key_e(alice,bob,sid_5),g))),encrypt(hmac_hash2(hmac_hash1(hash(somename,empty),dhexp_real(key_e(alice,bob,sid_5),dhexp_real(key_s(bob),g))),dhexp_real(key_e(alice,bob,sid_5),dhexp_real(key_m(bob),g))),minnonce,hash(hash(hash(hash(hash(somename,empty),empty),validkey(dhexp_real(key_s(bob),g))),validkey(dhexp_real(key_m(bob),g))),validkey(dhexp_real(key_e(alice,bob,sid_5),g))),validkey(dhexp_real(key_s(alice),g)))),validkey(dhexp_real(key_m(alice),g))) in phase 1.
Using the function decrypt the attacker may obtain aeadpack(true,hash(hash(hash(hash(hash(hash(somename,empty),empty),validkey(dhexp_real(key_s(bob),g))),validkey(dhexp_real(key_m(bob),g))),validkey(dhexp_real(key_e(alice,bob,sid_5),g))),encrypt(hmac_hash2(hmac_hash1(hash(somename,empty),dhexp_real(key_e(alice,bob,sid_5),dhexp_real(key_s(bob),g))),dhexp_real(key_e(alice,bob,sid_5),dhexp_real(key_m(bob),g))),minnonce,hash(hash(hash(hash(hash(somename,empty),empty),validkey(dhexp_real(key_s(bob),g))),validkey(dhexp_real(key_m(bob),g))),validkey(dhexp_real(key_e(alice,bob,sid_5),g))),validkey(dhexp_real(key_s(alice),g)))),validkey(dhexp_real(key_m(alice),g))) in phase 1.
attacker_p1(aeadpack(true,hash(hash(hash(hash(hash(hash(somename,empty),empty),validkey(dhexp_real(key_s(bob),g))),validkey(dhexp_real(key_m(bob),g))),validkey(dhexp_real(key_e(alice,bob,sid_5),g))),encrypt(hmac_hash2(hmac_hash1(hash(somename,empty),dhexp_real(key_e(alice,bob,sid_5),dhexp_real(key_s(bob),g))),dhexp_real(key_e(alice,bob,sid_5),dhexp_real(key_m(bob),g))),minnonce,hash(hash(hash(hash(hash(somename,empty),empty),validkey(dhexp_real(key_s(bob),g))),validkey(dhexp_real(key_m(bob),g))),validkey(dhexp_real(key_e(alice,bob,sid_5),g))),validkey(dhexp_real(key_s(alice),g)))),validkey(dhexp_real(key_m(alice),g)))).

49. By 48, the attacker may know aeadpack(true,hash(hash(hash(hash(hash(hash(somename,empty),empty),validkey(dhexp_real(key_s(bob),g))),validkey(dhexp_real(key_m(bob),g))),validkey(dhexp_real(key_e(alice,bob,sid_5),g))),encrypt(hmac_hash2(hmac_hash1(hash(somename,empty),dhexp_real(key_e(alice,bob,sid_5),dhexp_real(key_s(bob),g))),dhexp_real(key_e(alice,bob,sid_5),dhexp_real(key_m(bob),g))),minnonce,hash(hash(hash(hash(hash(somename,empty),empty),validkey(dhexp_real(key_s(bob),g))),validkey(dhexp_real(key_m(bob),g))),validkey(dhexp_real(key_e(alice,bob,sid_5),g))),validkey(dhexp_real(key_s(alice),g)))),validkey(dhexp_real(key_m(alice),g))) in phase 1.
Using the function 3-proj-aeadpack the attacker may obtain validkey(dhexp_real(key_m(alice),g)) in phase 1.
attacker_p1(validkey(dhexp_real(key_m(alice),g))).

50. By 35, the attacker may know key_s(bob) in phase 1.
By 49, the attacker may know validkey(dhexp_real(key_m(alice),g)) in phase 1.
Using the function dhexp the attacker may obtain dhexp_real(key_m(alice),dhexp_real(key_s(bob),g)) in phase 1.
attacker_p1(dhexp_real(key_m(alice),dhexp_real(key_s(bob),g))).

51. By 40, the attacker may know hmac_hash1(hash(somename,empty),dhexp_real(key_e(alice,bob,sid_5),dhexp_real(key_s(bob),g))) in phase 1.
By 34, the attacker may know dhexp_real(key_e(alice,bob,sid_5),dhexp_real(key_m(bob),g)) in phase 1.
Using the function hmac_hash1 the attacker may obtain hmac_hash1(hmac_hash1(hash(somename,empty),dhexp_real(key_e(alice,bob,sid_5),dhexp_real(key_s(bob),g))),dhexp_real(key_e(alice,bob,sid_5),dhexp_real(key_m(bob),g))) in phase 1.
attacker_p1(hmac_hash1(hmac_hash1(hash(somename,empty),dhexp_real(key_e(alice,bob,sid_5),dhexp_real(key_s(bob),g))),dhexp_real(key_e(alice,bob,sid_5),dhexp_real(key_m(bob),g)))).

52. By 51, the attacker may know hmac_hash1(hmac_hash1(hash(somename,empty),dhexp_real(key_e(alice,bob,sid_5),dhexp_real(key_s(bob),g))),dhexp_real(key_e(alice,bob,sid_5),dhexp_real(key_m(bob),g))) in phase 1.
By 50, the attacker may know dhexp_real(key_m(alice),dhexp_real(key_s(bob),g)) in phase 1.
Using the function hmac_hash1 the attacker may obtain hmac_hash1(hmac_hash1(hmac_hash1(hash(somename,empty),dhexp_real(key_e(alice,bob,sid_5),dhexp_real(key_s(bob),g))),dhexp_real(key_e(alice,bob,sid_5),dhexp_real(key_m(bob),g))),dhexp_real(key_m(alice),dhexp_real(key_s(bob),g))) in phase 1.
attacker_p1(hmac_hash1(hmac_hash1(hmac_hash1(hash(somename,empty),dhexp_real(key_e(alice,bob,sid_5),dhexp_real(key_s(bob),g))),dhexp_real(key_e(alice,bob,sid_5),dhexp_real(key_m(bob),g))),dhexp_real(key_m(alice),dhexp_real(key_s(bob),g)))).

53. By 52, the attacker may know hmac_hash1(hmac_hash1(hmac_hash1(hash(somename,empty),dhexp_real(key_e(alice,bob,sid_5),dhexp_real(key_s(bob),g))),dhexp_real(key_e(alice,bob,sid_5),dhexp_real(key_m(bob),g))),dhexp_real(key_m(alice),dhexp_real(key_s(bob),g))) in phase 1.
By 44, the attacker may know dhexp_real(key_m(bob),dhexp_real(key_s(alice),g)) in phase 1.
Using the function hmac_hash2 the attacker may obtain hmac_hash2(hmac_hash1(hmac_hash1(hmac_hash1(hash(somename,empty),dhexp_real(key_e(alice,bob,sid_5),dhexp_real(key_s(bob),g))),dhexp_real(key_e(alice,bob,sid_5),dhexp_real(key_m(bob),g))),dhexp_real(key_m(alice),dhexp_real(key_s(bob),g))),dhexp_real(key_m(bob),dhexp_real(key_s(alice),g))) in phase 1.
attacker_p1(hmac_hash2(hmac_hash1(hmac_hash1(hmac_hash1(hash(somename,empty),dhexp_real(key_e(alice,bob,sid_5),dhexp_real(key_s(bob),g))),dhexp_real(key_e(alice,bob,sid_5),dhexp_real(key_m(bob),g))),dhexp_real(key_m(alice),dhexp_real(key_s(bob),g))),dhexp_real(key_m(bob),dhexp_real(key_s(alice),g)))).

54. By 53, the attacker may know hmac_hash2(hmac_hash1(hmac_hash1(hmac_hash1(hash(somename,empty),dhexp_real(key_e(alice,bob,sid_5),dhexp_real(key_s(bob),g))),dhexp_real(key_e(alice,bob,sid_5),dhexp_real(key_m(bob),g))),dhexp_real(key_m(alice),dhexp_real(key_s(bob),g))),dhexp_real(key_m(bob),dhexp_real(key_s(alice),g))) in phase 1.
By 26, the attacker may know minnonce in phase 1.
By 25, the attacker may know hash(hash(hash(hash(hash(hash(hash(somename,empty),empty),validkey(dhexp_real(key_s(bob),g))),validkey(dhexp_real(key_m(bob),g))),validkey(dhexp_real(key_e(alice,bob,sid_5),g))),encrypt(hmac_hash2(hmac_hash1(hash(somename,empty),dhexp_real(key_e(alice,bob,sid_5),dhexp_real(key_s(bob),g))),dhexp_real(key_e(alice,bob,sid_5),dhexp_real(key_m(bob),g))),minnonce,hash(hash(hash(hash(hash(somename,empty),empty),validkey(dhexp_real(key_s(bob),g))),validkey(dhexp_real(key_m(bob),g))),validkey(dhexp_real(key_e(alice,bob,sid_5),g))),validkey(dhexp_real(key_s(alice),g)))),encrypt(hmac_hash2(hmac_hash1(hash(somename,empty),dhexp_real(key_e(alice,bob,sid_5),dhexp_real(key_s(bob),g))),dhexp_real(key_e(alice,bob,sid_5),dhexp_real(key_m(bob),g))),increment_nonce(minnonce),hash(hash(hash(hash(hash(hash(somename,empty),empty),validkey(dhexp_real(key_s(bob),g))),validkey(dhexp_real(key_m(bob),g))),validkey(dhexp_real(key_e(alice,bob,sid_5),g))),encrypt(hmac_hash2(hmac_hash1(hash(somename,empty),dhexp_real(key_e(alice,bob,sid_5),dhexp_real(key_s(bob),g))),dhexp_real(key_e(alice,bob,sid_5),dhexp_real(key_m(bob),g))),minnonce,hash(hash(hash(hash(hash(somename,empty),empty),validkey(dhexp_real(key_s(bob),g))),validkey(dhexp_real(key_m(bob),g))),validkey(dhexp_real(key_e(alice,bob,sid_5),g))),validkey(dhexp_real(key_s(alice),g)))),validkey(dhexp_real(key_m(alice),g)))) in phase 1.
By 6, the attacker may know encrypt(hmac_hash2(hmac_hash1(hmac_hash1(hmac_hash1(hash(somename,empty),dhexp_real(key_e(alice,bob,sid_5),dhexp_real(key_s(bob),g))),dhexp_real(key_e(alice,bob,sid_5),dhexp_real(key_m(bob),g))),dhexp_real(key_m(alice),dhexp_real(key_s(bob),g))),dhexp_real(key_m(bob),dhexp_real(key_s(alice),g))),minnonce,hash(hash(hash(hash(hash(hash(hash(somename,empty),empty),validkey(dhexp_real(key_s(bob),g))),validkey(dhexp_real(key_m(bob),g))),validkey(dhexp_real(key_e(alice,bob,sid_5),g))),encrypt(hmac_hash2(hmac_hash1(hash(somename,empty),dhexp_real(key_e(alice,bob,sid_5),dhexp_real(key_s(bob),g))),dhexp_real(key_e(alice,bob,sid_5),dhexp_real(key_m(bob),g))),minnonce,hash(hash(hash(hash(hash(somename,empty),empty),validkey(dhexp_real(key_s(bob),g))),validkey(dhexp_real(key_m(bob),g))),validkey(dhexp_real(key_e(alice,bob,sid_5),g))),validkey(dhexp_real(key_s(alice),g)))),encrypt(hmac_hash2(hmac_hash1(hash(somename,empty),dhexp_real(key_e(alice,bob,sid_5),dhexp_real(key_s(bob),g))),dhexp_real(key_e(alice,bob,sid_5),dhexp_real(key_m(bob),g))),increment_nonce(minnonce),hash(hash(hash(hash(hash(hash(somename,empty),empty),validkey(dhexp_real(key_s(bob),g))),validkey(dhexp_real(key_m(bob),g))),validkey(dhexp_real(key_e(alice,bob,sid_5),g))),encrypt(hmac_hash2(hmac_hash1(hash(somename,empty),dhexp_real(key_e(alice,bob,sid_5),dhexp_real(key_s(bob),g))),dhexp_real(key_e(alice,bob,sid_5),dhexp_real(key_m(bob),g))),minnonce,hash(hash(hash(hash(hash(somename,empty),empty),validkey(dhexp_real(key_s(bob),g))),validkey(dhexp_real(key_m(bob),g))),validkey(dhexp_real(key_e(alice,bob,sid_5),g))),validkey(dhexp_real(key_s(alice),g)))),validkey(dhexp_real(key_m(alice),g)))),msg_a(alice,bob,sid_5)) in phase 1.
Using the function decrypt the attacker may obtain aeadpack(true,hash(hash(hash(hash(hash(hash(hash(somename,empty),empty),validkey(dhexp_real(key_s(bob),g))),validkey(dhexp_real(key_m(bob),g))),validkey(dhexp_real(key_e(alice,bob,sid_5),g))),encrypt(hmac_hash2(hmac_hash1(hash(somename,empty),dhexp_real(key_e(alice,bob,sid_5),dhexp_real(key_s(bob),g))),dhexp_real(key_e(alice,bob,sid_5),dhexp_real(key_m(bob),g))),minnonce,hash(hash(hash(hash(hash(somename,empty),empty),validkey(dhexp_real(key_s(bob),g))),validkey(dhexp_real(key_m(bob),g))),validkey(dhexp_real(key_e(alice,bob,sid_5),g))),validkey(dhexp_real(key_s(alice),g)))),encrypt(hmac_hash2(hmac_hash1(hash(somename,empty),dhexp_real(key_e(alice,bob,sid_5),dhexp_real(key_s(bob),g))),dhexp_real(key_e(alice,bob,sid_5),dhexp_real(key_m(bob),g))),increment_nonce(minnonce),hash(hash(hash(hash(hash(hash(somename,empty),empty),validkey(dhexp_real(key_s(bob),g))),validkey(dhexp_real(key_m(bob),g))),validkey(dhexp_real(key_e(alice,bob,sid_5),g))),encrypt(hmac_hash2(hmac_hash1(hash(somename,empty),dhexp_real(key_e(alice,bob,sid_5),dhexp_real(key_s(bob),g))),dhexp_real(key_e(alice,bob,sid_5),dhexp_real(key_m(bob),g))),minnonce,hash(hash(hash(hash(hash(somename,empty),empty),validkey(dhexp_real(key_s(bob),g))),validkey(dhexp_real(key_m(bob),g))),validkey(dhexp_real(key_e(alice,bob,sid_5),g))),validkey(dhexp_real(key_s(alice),g)))),validkey(dhexp_real(key_m(alice),g)))),msg_a(alice,bob,sid_5)) in phase 1.
attacker_p1(aeadpack(true,hash(hash(hash(hash(hash(hash(hash(somename,empty),empty),validkey(dhexp_real(key_s(bob),g))),validkey(dhexp_real(key_m(bob),g))),validkey(dhexp_real(key_e(alice,bob,sid_5),g))),encrypt(hmac_hash2(hmac_hash1(hash(somename,empty),dhexp_real(key_e(alice,bob,sid_5),dhexp_real(key_s(bob),g))),dhexp_real(key_e(alice,bob,sid_5),dhexp_real(key_m(bob),g))),minnonce,hash(hash(hash(hash(hash(somename,empty),empty),validkey(dhexp_real(key_s(bob),g))),validkey(dhexp_real(key_m(bob),g))),validkey(dhexp_real(key_e(alice,bob,sid_5),g))),validkey(dhexp_real(key_s(alice),g)))),encrypt(hmac_hash2(hmac_hash1(hash(somename,empty),dhexp_real(key_e(alice,bob,sid_5),dhexp_real(key_s(bob),g))),dhexp_real(key_e(alice,bob,sid_5),dhexp_real(key_m(bob),g))),increment_nonce(minnonce),hash(hash(hash(hash(hash(hash(somename,empty),empty),validkey(dhexp_real(key_s(bob),g))),validkey(dhexp_real(key_m(bob),g))),validkey(dhexp_real(key_e(alice,bob,sid_5),g))),encrypt(hmac_hash2(hmac_hash1(hash(somename,empty),dhexp_real(key_e(alice,bob,sid_5),dhexp_real(key_s(bob),g))),dhexp_real(key_e(alice,bob,sid_5),dhexp_real(key_m(bob),g))),minnonce,hash(hash(hash(hash(hash(somename,empty),empty),validkey(dhexp_real(key_s(bob),g))),validkey(dhexp_real(key_m(bob),g))),validkey(dhexp_real(key_e(alice,bob,sid_5),g))),validkey(dhexp_real(key_s(alice),g)))),validkey(dhexp_real(key_m(alice),g)))),msg_a(alice,bob,sid_5))).

55. By 54, the attacker may know aeadpack(true,hash(hash(hash(hash(hash(hash(hash(somename,empty),empty),validkey(dhexp_real(key_s(bob),g))),validkey(dhexp_real(key_m(bob),g))),validkey(dhexp_real(key_e(alice,bob,sid_5),g))),encrypt(hmac_hash2(hmac_hash1(hash(somename,empty),dhexp_real(key_e(alice,bob,sid_5),dhexp_real(key_s(bob),g))),dhexp_real(key_e(alice,bob,sid_5),dhexp_real(key_m(bob),g))),minnonce,hash(hash(hash(hash(hash(somename,empty),empty),validkey(dhexp_real(key_s(bob),g))),validkey(dhexp_real(key_m(bob),g))),validkey(dhexp_real(key_e(alice,bob,sid_5),g))),validkey(dhexp_real(key_s(alice),g)))),encrypt(hmac_hash2(hmac_hash1(hash(somename,empty),dhexp_real(key_e(alice,bob,sid_5),dhexp_real(key_s(bob),g))),dhexp_real(key_e(alice,bob,sid_5),dhexp_real(key_m(bob),g))),increment_nonce(minnonce),hash(hash(hash(hash(hash(hash(somename,empty),empty),validkey(dhexp_real(key_s(bob),g))),validkey(dhexp_real(key_m(bob),g))),validkey(dhexp_real(key_e(alice,bob,sid_5),g))),encrypt(hmac_hash2(hmac_hash1(hash(somename,empty),dhexp_real(key_e(alice,bob,sid_5),dhexp_real(key_s(bob),g))),dhexp_real(key_e(alice,bob,sid_5),dhexp_real(key_m(bob),g))),minnonce,hash(hash(hash(hash(hash(somename,empty),empty),validkey(dhexp_real(key_s(bob),g))),validkey(dhexp_real(key_m(bob),g))),validkey(dhexp_real(key_e(alice,bob,sid_5),g))),validkey(dhexp_real(key_s(alice),g)))),validkey(dhexp_real(key_m(alice),g)))),msg_a(alice,bob,sid_5)) in phase 1.
Using the function 3-proj-aeadpack the attacker may obtain msg_a(alice,bob,sid_5) in phase 1.
attacker_p1(msg_a(alice,bob,sid_5)).

56. By 55, attacker_p1(msg_a(alice,bob,sid_5)).
The goal is reached, represented in the following fact:
attacker_p1(msg_a(alice,bob,sid_5)).


RESULT attacker_p1(msg_a(alice,bob,sid_a)) ==> event(LeakS(phase0,bob)) && event(LeakM(phase0,bob)) cannot be proved.
Starting query not event(RecvEnd(true))
goal reachable: begin(SendMsg(alice,bob,stagepack_a(sid_5),msg_a(alice,bob,sid_5))) -> end(RecvEnd(true))
Abbreviations:
sid_5 = sid[!1 = @sid]

Derivation:
Abbreviations:
sid_5 = sid[!1 = @sid]
sid_6 = sid[!1 = @sid_1]

1. The entry statestore(bob,alice,sid_6,statepack_a(handshakestatepack(symmetricstatepack(cipherstatepack(empty,minnonce),hash(somename,empty),hash(hash(hash(hash(somename,empty),empty),validkey(dhexp_real(key_s(bob),g))),validkey(dhexp_real(key_m(bob),g)))),keypairpack(validkey(dhexp_real(key_s(bob),g)),key_s(bob)),keypairpack(validkey(dhexp_real(key_m(bob),g)),key_m(bob)),keypairpack(empty,empty),empty,empty,empty,empty,false))) may be inserted in a table at insert {674}.
table(statestore(bob,alice,sid_6,statepack_a(handshakestatepack(symmetricstatepack(cipherstatepack(empty,minnonce),hash(somename,empty),hash(hash(hash(hash(somename,empty),empty),validkey(dhexp_real(key_s(bob),g))),validkey(dhexp_real(key_m(bob),g)))),keypairpack(validkey(dhexp_real(key_s(bob),g)),key_s(bob)),keypairpack(validkey(dhexp_real(key_m(bob),g)),key_m(bob)),keypairpack(empty,empty),empty,empty,empty,empty,false)))).

2. The entry statestore(alice,bob,sid_5,statepack_a(handshakestatepack(symmetricstatepack(cipherstatepack(empty,minnonce),hash(somename,empty),hash(hash(hash(hash(somename,empty),empty),validkey(dhexp_real(key_s(bob),g))),validkey(dhexp_real(key_m(bob),g)))),keypairpack(empty,empty),keypairpack(empty,empty),keypairpack(empty,empty),validkey(dhexp_real(key_s(bob),g)),validkey(dhexp_real(key_m(bob),g)),empty,empty,true))) may be inserted in a table at insert {50}.
table(statestore(alice,bob,sid_5,statepack_a(handshakestatepack(symmetricstatepack(cipherstatepack(empty,minnonce),hash(somename,empty),hash(hash(hash(hash(somename,empty),empty),validkey(dhexp_real(key_s(bob),g))),validkey(dhexp_real(key_m(bob),g)))),keypairpack(empty,empty),keypairpack(empty,empty),keypairpack(empty,empty),validkey(dhexp_real(key_s(bob),g)),validkey(dhexp_real(key_m(bob),g)),empty,empty,true)))).

3. The entry statestore(alice,bob,sid_5,statepack_a(handshakestatepack(symmetricstatepack(cipherstatepack(empty,minnonce),hash(somename,empty),hash(hash(hash(hash(somename,empty),empty),validkey(dhexp_real(key_s(bob),g))),validkey(dhexp_real(key_m(bob),g)))),keypairpack(empty,empty),keypairpack(empty,empty),keypairpack(empty,empty),validkey(dhexp_real(key_s(bob),g)),validkey(dhexp_real(key_m(bob),g)),empty,empty,true))) that may be in a table by 2 may be read at get {306}.
The event SendMsg(alice,bob,stagepack_a(sid_5),msg_a(alice,bob,sid_5)) may be executed at {304}.
So the message concat4(validkey(dhexp_real(key_e(alice,bob,sid_5),g)),encrypt(hmac_hash2(hmac_hash1(hash(somename,empty),dhexp_real(key_e(alice,bob,sid_5),dhexp_real(key_s(bob),g))),dhexp_real(key_e(alice,bob,sid_5),dhexp_real(key_m(bob),g))),minnonce,hash(hash(hash(hash(hash(somename,empty),empty),validkey(dhexp_real(key_s(bob),g))),validkey(dhexp_real(key_m(bob),g))),validkey(dhexp_real(key_e(alice,bob,sid_5),g))),validkey(dhexp_real(key_s(alice),g))),encrypt(hmac_hash2(hmac_hash1(hash(somename,empty),dhexp_real(key_e(alice,bob,sid_5),dhexp_real(key_s(bob),g))),dhexp_real(key_e(alice,bob,sid_5),dhexp_real(key_m(bob),g))),increment_nonce(minnonce),hash(hash(hash(hash(hash(hash(somename,empty),empty),validkey(dhexp_real(key_s(bob),g))),validkey(dhexp_real(key_m(bob),g))),validkey(dhexp_real(key_e(alice,bob,sid_5),g))),encrypt(hmac_hash2(hmac_hash1(hash(somename,empty),dhexp_real(key_e(alice,bob,sid_5),dhexp_real(key_s(bob),g))),dhexp_real(key_e(alice,bob,sid_5),dhexp_real(key_m(bob),g))),minnonce,hash(hash(hash(hash(hash(somename,empty),empty),validkey(dhexp_real(key_s(bob),g))),validkey(dhexp_real(key_m(bob),g))),validkey(dhexp_real(key_e(alice,bob,sid_5),g))),validkey(dhexp_real(key_s(alice),g)))),validkey(dhexp_real(key_m(alice),g))),encrypt(hmac_hash2(hmac_hash1(hmac_hash1(hmac_hash1(hash(somename,empty),dhexp_real(key_e(alice,bob,sid_5),dhexp_real(key_s(bob),g))),dhexp_real(key_e(alice,bob,sid_5),dhexp_real(key_m(bob),g))),dhexp_real(key_m(alice),dhexp_real(key_s(bob),g))),dhexp_real(key_s(alice),dhexp_real(key_m(bob),g))),minnonce,hash(hash(hash(hash(hash(hash(hash(somename,empty),empty),validkey(dhexp_real(key_s(bob),g))),validkey(dhexp_real(key_m(bob),g))),validkey(dhexp_real(key_e(alice,bob,sid_5),g))),encrypt(hmac_hash2(hmac_hash1(hash(somename,empty),dhexp_real(key_e(alice,bob,sid_5),dhexp_real(key_s(bob),g))),dhexp_real(key_e(alice,bob,sid_5),dhexp_real(key_m(bob),g))),minnonce,hash(hash(hash(hash(hash(somename,empty),empty),validkey(dhexp_real(key_s(bob),g))),validkey(dhexp_real(key_m(bob),g))),validkey(dhexp_real(key_e(alice,bob,sid_5),g))),validkey(dhexp_real(key_s(alice),g)))),encrypt(hmac_hash2(hmac_hash1(hash(somename,empty),dhexp_real(key_e(alice,bob,sid_5),dhexp_real(key_s(bob),g))),dhexp_real(key_e(alice,bob,sid_5),dhexp_real(key_m(bob),g))),increment_nonce(minnonce),hash(hash(hash(hash(hash(hash(somename,empty),empty),validkey(dhexp_real(key_s(bob),g))),validkey(dhexp_real(key_m(bob),g))),validkey(dhexp_real(key_e(alice,bob,sid_5),g))),encrypt(hmac_hash2(hmac_hash1(hash(somename,empty),dhexp_real(key_e(alice,bob,sid_5),dhexp_real(key_s(bob),g))),dhexp_real(key_e(alice,bob,sid_5),dhexp_real(key_m(bob),g))),minnonce,hash(hash(hash(hash(hash(somename,empty),empty),validkey(dhexp_real(key_s(bob),g))),validkey(dhexp_real(key_m(bob),g))),validkey(dhexp_real(key_e(alice,bob,sid_5),g))),validkey(dhexp_real(key_s(alice),g)))),validkey(dhexp_real(key_m(alice),g)))),msg_a(alice,bob,sid_5))) may be sent on channel pub at output {305}.
mess(pub,concat4(validkey(dhexp_real(key_e(alice,bob,sid_5),g)),encrypt(hmac_hash2(hmac_hash1(hash(somename,empty),dhexp_real(key_e(alice,bob,sid_5),dhexp_real(key_s(bob),g))),dhexp_real(key_e(alice,bob,sid_5),dhexp_real(key_m(bob),g))),minnonce,hash(hash(hash(hash(hash(somename,empty),empty),validkey(dhexp_real(key_s(bob),g))),validkey(dhexp_real(key_m(bob),g))),validkey(dhexp_real(key_e(alice,bob,sid_5),g))),validkey(dhexp_real(key_s(alice),g))),encrypt(hmac_hash2(hmac_hash1(hash(somename,empty),dhexp_real(key_e(alice,bob,sid_5),dhexp_real(key_s(bob),g))),dhexp_real(key_e(alice,bob,sid_5),dhexp_real(key_m(bob),g))),increment_nonce(minnonce),hash(hash(hash(hash(hash(hash(somename,empty),empty),validkey(dhexp_real(key_s(bob),g))),validkey(dhexp_real(key_m(bob),g))),validkey(dhexp_real(key_e(alice,bob,sid_5),g))),encrypt(hmac_hash2(hmac_hash1(hash(somename,empty),dhexp_real(key_e(alice,bob,sid_5),dhexp_real(key_s(bob),g))),dhexp_real(key_e(alice,bob,sid_5),dhexp_real(key_m(bob),g))),minnonce,hash(hash(hash(hash(hash(somename,empty),empty),validkey(dhexp_real(key_s(bob),g))),validkey(dhexp_real(key_m(bob),g))),validkey(dhexp_real(key_e(alice,bob,sid_5),g))),validkey(dhexp_real(key_s(alice),g)))),validkey(dhexp_real(key_m(alice),g))),encrypt(hmac_hash2(hmac_hash1(hmac_hash1(hmac_hash1(hash(somename,empty),dhexp_real(key_e(alice,bob,sid_5),dhexp_real(key_s(bob),g))),dhexp_real(key_e(alice,bob,sid_5),dhexp_real(key_m(bob),g))),dhexp_real(key_m(alice),dhexp_real(key_s(bob),g))),dhexp_real(key_s(alice),dhexp_real(key_m(bob),g))),minnonce,hash(hash(hash(hash(hash(hash(hash(somename,empty),empty),validkey(dhexp_real(key_s(bob),g))),validkey(dhexp_real(key_m(bob),g))),validkey(dhexp_real(key_e(alice,bob,sid_5),g))),encrypt(hmac_hash2(hmac_hash1(hash(somename,empty),dhexp_real(key_e(alice,bob,sid_5),dhexp_real(key_s(bob),g))),dhexp_real(key_e(alice,bob,sid_5),dhexp_real(key_m(bob),g))),minnonce,hash(hash(hash(hash(hash(somename,empty),empty),validkey(dhexp_real(key_s(bob),g))),validkey(dhexp_real(key_m(bob),g))),validkey(dhexp_real(key_e(alice,bob,sid_5),g))),validkey(dhexp_real(key_s(alice),g)))),encrypt(hmac_hash2(hmac_hash1(hash(somename,empty),dhexp_real(key_e(alice,bob,sid_5),dhexp_real(key_s(bob),g))),dhexp_real(key_e(alice,bob,sid_5),dhexp_real(key_m(bob),g))),increment_nonce(minnonce),hash(hash(hash(hash(hash(hash(somename,empty),empty),validkey(dhexp_real(key_s(bob),g))),validkey(dhexp_real(key_m(bob),g))),validkey(dhexp_real(key_e(alice,bob,sid_5),g))),encrypt(hmac_hash2(hmac_hash1(hash(somename,empty),dhexp_real(key_e(alice,bob,sid_5),dhexp_real(key_s(bob),g))),dhexp_real(key_e(alice,bob,sid_5),dhexp_real(key_m(bob),g))),minnonce,hash(hash(hash(hash(hash(somename,empty),empty),validkey(dhexp_real(key_s(bob),g))),validkey(dhexp_real(key_m(bob),g))),validkey(dhexp_real(key_e(alice,bob,sid_5),g))),validkey(dhexp_real(key_s(alice),g)))),validkey(dhexp_real(key_m(alice),g)))),msg_a(alice,bob,sid_5)))).

4. The entry statestore(bob,alice,sid_6,statepack_a(handshakestatepack(symmetricstatepack(cipherstatepack(empty,minnonce),hash(somename,empty),hash(hash(hash(hash(somename,empty),empty),validkey(dhexp_real(key_s(bob),g))),validkey(dhexp_real(key_m(bob),g)))),keypairpack(validkey(dhexp_real(key_s(bob),g)),key_s(bob)),keypairpack(validkey(dhexp_real(key_m(bob),g)),key_m(bob)),keypairpack(empty,empty),empty,empty,empty,empty,false))) that may be in a table by 1 may be read at get {944}.
The message concat4(validkey(dhexp_real(key_e(alice,bob,sid_5),g)),encrypt(hmac_hash2(hmac_hash1(hash(somename,empty),dhexp_real(key_e(alice,bob,sid_5),dhexp_real(key_s(bob),g))),dhexp_real(key_e(alice,bob,sid_5),dhexp_real(key_m(bob),g))),minnonce,hash(hash(hash(hash(hash(somename,empty),empty),validkey(dhexp_real(key_s(bob),g))),validkey(dhexp_real(key_m(bob),g))),validkey(dhexp_real(key_e(alice,bob,sid_5),g))),validkey(dhexp_real(key_s(alice),g))),encrypt(hmac_hash2(hmac_hash1(hash(somename,empty),dhexp_real(key_e(alice,bob,sid_5),dhexp_real(key_s(bob),g))),dhexp_real(key_e(alice,bob,sid_5),dhexp_real(key_m(bob),g))),increment_nonce(minnonce),hash(hash(hash(hash(hash(hash(somename,empty),empty),validkey(dhexp_real(key_s(bob),g))),validkey(dhexp_real(key_m(bob),g))),validkey(dhexp_real(key_e(alice,bob,sid_5),g))),encrypt(hmac_hash2(hmac_hash1(hash(somename,empty),dhexp_real(key_e(alice,bob,sid_5),dhexp_real(key_s(bob),g))),dhexp_real(key_e(alice,bob,sid_5),dhexp_real(key_m(bob),g))),minnonce,hash(hash(hash(hash(hash(somename,empty),empty),validkey(dhexp_real(key_s(bob),g))),validkey(dhexp_real(key_m(bob),g))),validkey(dhexp_real(key_e(alice,bob,sid_5),g))),validkey(dhexp_real(key_s(alice),g)))),validkey(dhexp_real(key_m(alice),g))),encrypt(hmac_hash2(hmac_hash1(hmac_hash1(hmac_hash1(hash(somename,empty),dhexp_real(key_e(alice,bob,sid_5),dhexp_real(key_s(bob),g))),dhexp_real(key_e(alice,bob,sid_5),dhexp_real(key_m(bob),g))),dhexp_real(key_m(alice),dhexp_real(key_s(bob),g))),dhexp_real(key_s(alice),dhexp_real(key_m(bob),g))),minnonce,hash(hash(hash(hash(hash(hash(hash(somename,empty),empty),validkey(dhexp_real(key_s(bob),g))),validkey(dhexp_real(key_m(bob),g))),validkey(dhexp_real(key_e(alice,bob,sid_5),g))),encrypt(hmac_hash2(hmac_hash1(hash(somename,empty),dhexp_real(key_e(alice,bob,sid_5),dhexp_real(key_s(bob),g))),dhexp_real(key_e(alice,bob,sid_5),dhexp_real(key_m(bob),g))),minnonce,hash(hash(hash(hash(hash(somename,empty),empty),validkey(dhexp_real(key_s(bob),g))),validkey(dhexp_real(key_m(bob),g))),validkey(dhexp_real(key_e(alice,bob,sid_5),g))),validkey(dhexp_real(key_s(alice),g)))),encrypt(hmac_hash2(hmac_hash1(hash(somename,empty),dhexp_real(key_e(alice,bob,sid_5),dhexp_real(key_s(bob),g))),dhexp_real(key_e(alice,bob,sid_5),dhexp_real(key_m(bob),g))),increment_nonce(minnonce),hash(hash(hash(hash(hash(hash(somename,empty),empty),validkey(dhexp_real(key_s(bob),g))),validkey(dhexp_real(key_m(bob),g))),validkey(dhexp_real(key_e(alice,bob,sid_5),g))),encrypt(hmac_hash2(hmac_hash1(hash(somename,empty),dhexp_real(key_e(alice,bob,sid_5),dhexp_real(key_s(bob),g))),dhexp_real(key_e(alice,bob,sid_5),dhexp_real(key_m(bob),g))),minnonce,hash(hash(hash(hash(hash(somename,empty),empty),validkey(dhexp_real(key_s(bob),g))),validkey(dhexp_real(key_m(bob),g))),validkey(dhexp_real(key_e(alice,bob,sid_5),g))),validkey(dhexp_real(key_s(alice),g)))),validkey(dhexp_real(key_m(alice),g)))),msg_a(alice,bob,sid_5))) that may be sent on channel pub by 3 may be received at input {675}.
So event RecvEnd(true) may be executed at {943}.
end(RecvEnd(true)).

5. By 4, end(RecvEnd(true)).
The goal is reached, represented in the following fact:
end(RecvEnd(true)).


RESULT not event(RecvEnd(true)) cannot be proved.

--------------------------------------------------------------
Verification summary:

Query event(RecvMsg(bob,alice,stagepack_a(sid_b),m_10)) ==> event(SendMsg(alice,bob,stagepack_a(sid_a),m_10)) is true.

Query event(RecvMsg(bob,alice,stagepack_a(sid_b),m_10)) ==> event(SendMsg(alice,c,stagepack_a(sid_a),m_10)) || (event(LeakS(phase0,alice)) && event(LeakM(phase0,alice))) || (event(LeakS(phase0,bob)) && event(LeakM(phase0,bob))) is true.

Query event(RecvMsg(bob,alice,stagepack_a(sid_b),m_10)) ==> event(SendMsg(alice,c,stagepack_a(sid_a),m_10)) || (event(LeakS(phase0,alice)) && event(LeakM(phase0,alice))) is true.

Query event(RecvMsg(bob,alice,stagepack_a(sid_b),m_10)) ==> event(SendMsg(alice,bob,stagepack_a(sid_a),m_10)) || (event(LeakS(phase0,alice)) && event(LeakM(phase0,alice))) || (event(LeakS(phase0,bob)) && event(LeakM(phase0,bob))) is true.

Query event(RecvMsg(bob,alice,stagepack_a(sid_b),m_10)) ==> event(SendMsg(alice,bob,stagepack_a(sid_a),m_10)) || (event(LeakS(phase0,alice)) && event(LeakM(phase0,alice))) is true.

Query not attacker_p1(msg_a(alice,bob,sid_a)) cannot be proved.

Query attacker_p1(msg_a(alice,bob,sid_a)) ==> event(LeakS(px,bob)) && event(LeakM(px,bob)) is true.

Query attacker_p1(msg_a(alice,bob,sid_a)) ==> (event(LeakS(phase0,bob)) && event(LeakM(phase0,bob))) || (event(LeakS(px,bob)) && event(LeakM(px,bob)) && event(LeakS(pz,alice)) && event(LeakM(pz,alice))) cannot be proved.

Query attacker_p1(msg_a(alice,bob,sid_a)) ==> event(LeakS(phase0,bob)) && event(LeakM(phase0,bob)) cannot be proved.

Query not event(RecvEnd(true)) cannot be proved.

--------------------------------------------------------------


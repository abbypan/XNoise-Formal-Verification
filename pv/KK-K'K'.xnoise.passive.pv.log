File "pv/KK-K'K'.xnoise.passive.pv", line 219, characters 7-8:
Warning: identifier ck rebound.
File "pv/KK-K'K'.xnoise.passive.pv", line 228, characters 7-8:
Warning: identifier ck rebound.
File "pv/KK-K'K'.xnoise.passive.pv", line 229, characters 7-8:
Warning: identifier cs rebound.
File "pv/KK-K'K'.xnoise.passive.pv", line 229, character 36:
Warning: identifier h rebound.
File "pv/KK-K'K'.xnoise.passive.pv", line 259, characters 6-7:
Warning: identifier ss rebound.
File "pv/KK-K'K'.xnoise.passive.pv", line 260, characters 6-7:
Warning: identifier ss rebound.
File "pv/KK-K'K'.xnoise.passive.pv", line 261, characters 6-7:
Warning: identifier ss rebound.
File "pv/KK-K'K'.xnoise.passive.pv", line 262, characters 6-7:
Warning: identifier ss rebound.
File "pv/KK-K'K'.xnoise.passive.pv", line 267, characters 6-7:
Warning: identifier ss rebound.
File "pv/KK-K'K'.xnoise.passive.pv", line 268, characters 6-7:
Warning: identifier ss rebound.
File "pv/KK-K'K'.xnoise.passive.pv", line 269, characters 6-7:
Warning: identifier ss rebound.
File "pv/KK-K'K'.xnoise.passive.pv", line 270, characters 6-7:
Warning: identifier ss rebound.
File "pv/KK-K'K'.xnoise.passive.pv", line 276, character 6:
Warning: identifier e rebound.
File "pv/KK-K'K'.xnoise.passive.pv", line 277, characters 6-7:
Warning: identifier ne rebound.
File "pv/KK-K'K'.xnoise.passive.pv", line 278, characters 6-7:
Warning: identifier ss rebound.
File "pv/KK-K'K'.xnoise.passive.pv", line 280, characters 6-7:
Warning: identifier ss rebound.
File "pv/KK-K'K'.xnoise.passive.pv", line 281, characters 6-7:
Warning: identifier ss rebound.
File "pv/KK-K'K'.xnoise.passive.pv", line 282, characters 7-8:
Warning: identifier ss rebound.
File "pv/KK-K'K'.xnoise.passive.pv", line 282, characters 26-35:
Warning: identifier ciphertext rebound.
File "pv/KK-K'K'.xnoise.passive.pv", line 283, characters 6-7:
Warning: identifier hs rebound.
File "pv/KK-K'K'.xnoise.passive.pv", line 290, character 6:
Warning: identifier e rebound.
File "pv/KK-K'K'.xnoise.passive.pv", line 291, characters 6-7:
Warning: identifier ne rebound.
File "pv/KK-K'K'.xnoise.passive.pv", line 292, characters 6-7:
Warning: identifier ss rebound.
File "pv/KK-K'K'.xnoise.passive.pv", line 294, characters 6-7:
Warning: identifier ss rebound.
File "pv/KK-K'K'.xnoise.passive.pv", line 295, characters 6-7:
Warning: identifier ss rebound.
File "pv/KK-K'K'.xnoise.passive.pv", line 296, characters 6-7:
Warning: identifier ss rebound.
File "pv/KK-K'K'.xnoise.passive.pv", line 297, characters 7-8:
Warning: identifier ss rebound.
File "pv/KK-K'K'.xnoise.passive.pv", line 297, characters 26-35:
Warning: identifier ciphertext rebound.
File "pv/KK-K'K'.xnoise.passive.pv", line 298, characters 6-7:
Warning: identifier hs rebound.
File "pv/KK-K'K'.xnoise.passive.pv", line 306, characters 7-8:
Warning: identifier ss rebound.
File "pv/KK-K'K'.xnoise.passive.pv", line 306, characters 26-35:
Warning: identifier ciphertext rebound.
File "pv/KK-K'K'.xnoise.passive.pv", line 307, characters 6-7:
Warning: identifier hs rebound.
File "pv/KK-K'K'.xnoise.passive.pv", line 314, characters 7-8:
Warning: identifier ss rebound.
File "pv/KK-K'K'.xnoise.passive.pv", line 314, characters 26-35:
Warning: identifier ciphertext rebound.
File "pv/KK-K'K'.xnoise.passive.pv", line 315, characters 6-7:
Warning: identifier hs rebound.
File "pv/KK-K'K'.xnoise.passive.pv", line 323, characters 6-7:
Warning: identifier re rebound.
File "pv/KK-K'K'.xnoise.passive.pv", line 324, characters 6-7:
Warning: identifier ss rebound.
File "pv/KK-K'K'.xnoise.passive.pv", line 326, characters 6-7:
Warning: identifier ss rebound.
File "pv/KK-K'K'.xnoise.passive.pv", line 327, characters 6-7:
Warning: identifier ss rebound.
File "pv/KK-K'K'.xnoise.passive.pv", line 328, characters 7-8:
Warning: identifier ss rebound.
File "pv/KK-K'K'.xnoise.passive.pv", line 330, characters 7-8:
Warning: identifier hs rebound.
File "pv/KK-K'K'.xnoise.passive.pv", line 338, characters 6-7:
Warning: identifier re rebound.
File "pv/KK-K'K'.xnoise.passive.pv", line 339, characters 6-7:
Warning: identifier ss rebound.
File "pv/KK-K'K'.xnoise.passive.pv", line 341, characters 6-7:
Warning: identifier ss rebound.
File "pv/KK-K'K'.xnoise.passive.pv", line 342, characters 6-7:
Warning: identifier ss rebound.
File "pv/KK-K'K'.xnoise.passive.pv", line 343, characters 6-7:
Warning: identifier ss rebound.
File "pv/KK-K'K'.xnoise.passive.pv", line 344, characters 7-8:
Warning: identifier ss rebound.
File "pv/KK-K'K'.xnoise.passive.pv", line 346, characters 7-8:
Warning: identifier hs rebound.
File "pv/KK-K'K'.xnoise.passive.pv", line 355, characters 7-8:
Warning: identifier ss rebound.
File "pv/KK-K'K'.xnoise.passive.pv", line 357, characters 7-8:
Warning: identifier hs rebound.
File "pv/KK-K'K'.xnoise.passive.pv", line 365, characters 7-8:
Warning: identifier ss rebound.
File "pv/KK-K'K'.xnoise.passive.pv", line 367, characters 7-8:
Warning: identifier hs rebound.
File "pv/KK-K'K'.xnoise.passive.pv", line 526, characters 7-8:
Warning: identifier hs rebound.
File "pv/KK-K'K'.xnoise.passive.pv", line 528, characters 8-9:
Warning: identifier hs rebound.
File "pv/KK-K'K'.xnoise.passive.pv", line 519, characters 7-8:
Warning: identifier hs rebound.
File "pv/KK-K'K'.xnoise.passive.pv", line 520, characters 8-9:
Warning: identifier hs rebound.
File "pv/KK-K'K'.xnoise.passive.pv", line 513, characters 8-9:
Warning: identifier hs rebound.
File "pv/KK-K'K'.xnoise.passive.pv", line 506, characters 8-9:
Warning: identifier hs rebound.
File "pv/KK-K'K'.xnoise.passive.pv", line 577, characters 7-8:
Warning: identifier hs rebound.
File "pv/KK-K'K'.xnoise.passive.pv", line 578, characters 8-9:
Warning: identifier hs rebound.
File "pv/KK-K'K'.xnoise.passive.pv", line 569, characters 7-8:
Warning: identifier hs rebound.
File "pv/KK-K'K'.xnoise.passive.pv", line 571, characters 8-9:
Warning: identifier hs rebound.
File "pv/KK-K'K'.xnoise.passive.pv", line 563, characters 8-9:
Warning: identifier hs rebound.
File "pv/KK-K'K'.xnoise.passive.pv", line 557, characters 8-9:
Warning: identifier hs rebound.
Linear part:
dhexp_real(b,dhexp_real(a,g)) = dhexp_real(a,dhexp_real(b,g))
Completing equations...
Completed equations:
dhexp_real(b,dhexp_real(a,g)) = dhexp_real(a,dhexp_real(b,g))
Convergent part: No equation.
Process 0 (that is, the initial process):
{1}out(pub, (key_s(charlie),key_m(charlie)));
{2}!
{3}new sid: sessionid;
(
    {4}let me: principal = alice in
    {5}let them: principal = bob in
    {6}let sid_1: sessionid = sid in
    {7}let basis: key = key_s(me) in
    {8}let public_key: key = catch-fail(dhexp(basis,validkey(g))) in
    {9}let v: bool = not-caught-fail(public_key) in
    {10}let s: keypair = (if v then keypairpack(validkey(public_key),basis) else fail-any) in
    {11}let basis_1: key = key_m(me) in
    {12}let public_key_1: key = catch-fail(dhexp(basis_1,validkey(g))) in
    {13}let v_1: bool = not-caught-fail(public_key_1) in
    {14}let m: keypair = (if v_1 then keypairpack(validkey(public_key_1),basis_1) else fail-any) in
    {15}out(pub, (getpublickey(s),getpublickey(m)));
    (
        {16}let e: keypair = keypairpack(empty,empty) in
        {17}let basis_2: key = key_s(them) in
        {18}let public_key_2: key = catch-fail(dhexp(basis_2,validkey(g))) in
        {19}let v_2: bool = not-caught-fail(public_key_2) in
        {20}let rs: key = getpublickey((if v_2 then keypairpack(validkey(public_key_2),basis_2) else fail-any)) in
        {21}let basis_3: key = key_s(them) in
        {22}let public_key_3: key = catch-fail(dhexp(basis_3,validkey(g))) in
        {23}let v_3: bool = not-caught-fail(public_key_3) in
        {24}let rm: key = getpublickey((if v_3 then keypairpack(validkey(public_key_3),basis_3) else fail-any)) in
        {25}let re: key = empty in
        {26}let prologue: bitstring = empty in
        {27}let psk: key = empty in
        {28}let protocol_name: bitstring = somename in
        {29}let h: bitstring = hash(protocol_name,empty) in
        {30}let ck: key = h in
        {31}let k: key = empty in
        {32}let cs: cipherstate = cipherstatepack(k,minnonce) in
        {33}let ss: symmetricstate = symmetricstatepack(cs,ck,h) in
        {34}let v_4: bitstring = catch-fail(symmetricstateunpack(ss)) in
        {35}let v_5: bool = (not-caught-fail(v_4) && success?(1-proj-3-tuple(v_4))) in
        {36}let h_1: bitstring = (if v_5 then 3-proj-3-tuple(v_4) else caught-fail) in
        {37}let ck_1: key = (if v_5 then 2-proj-3-tuple(v_4) else caught-fail) in
        {38}let cs_1: cipherstate = (if v_5 then 1-proj-3-tuple(v_4) else caught-fail) in
        {39}let ss_1: symmetricstate = catch-fail((if v_5 then symmetricstatepack(cs_1,ck_1,hash(h_1,prologue)) else fail-any)) in
        {40}let v_6: bool = not-caught-fail(ss_1) in
        {41}let data: bitstring = (if v_6 then catch-fail(getpublickey(s)) else caught-fail) in
        {42}let v_7: bool = not-caught-fail(data) in
        {43}let v_8: bitstring = (if v_7 then catch-fail(symmetricstateunpack(ss_1)) else caught-fail) in
        {44}let v_9: bool = (not-caught-fail(v_8) && success?(1-proj-3-tuple(v_8))) in
        {45}let h_2: bitstring = (if v_9 then 3-proj-3-tuple(v_8) else caught-fail) in
        {46}let ck_2: key = (if v_9 then 2-proj-3-tuple(v_8) else caught-fail) in
        {47}let cs_2: cipherstate = (if v_9 then 1-proj-3-tuple(v_8) else caught-fail) in
        {48}let ss_2: symmetricstate = (if v_6 then catch-fail((if v_7 then (if v_9 then symmetricstatepack(cs_2,ck_2,hash(h_2,data)) else fail-any) else fail-any)) else caught-fail) in
        {49}let v_10: bool = not-caught-fail(ss_2) in
        {50}let data_1: bitstring = (if v_10 then catch-fail(getpublickey(m)) else caught-fail) in
        {51}let v_11: bool = not-caught-fail(data_1) in
        {52}let v_12: bitstring = (if v_11 then catch-fail(symmetricstateunpack(ss_2)) else caught-fail) in
        {53}let v_13: bool = (not-caught-fail(v_12) && success?(1-proj-3-tuple(v_12))) in
        {54}let h_3: bitstring = (if v_13 then 3-proj-3-tuple(v_12) else caught-fail) in
        {55}let ck_3: key = (if v_13 then 2-proj-3-tuple(v_12) else caught-fail) in
        {56}let cs_3: cipherstate = (if v_13 then 1-proj-3-tuple(v_12) else caught-fail) in
        {57}let ss_3: symmetricstate = (if v_10 then catch-fail((if v_11 then (if v_13 then symmetricstatepack(cs_3,ck_3,hash(h_3,data_1)) else fail-any) else fail-any)) else caught-fail) in
        {58}let v_14: bool = not-caught-fail(ss_3) in
        {59}let v_15: bitstring = (if v_14 then catch-fail(symmetricstateunpack(ss_3)) else caught-fail) in
        {60}let v_16: bool = (not-caught-fail(v_15) && success?(1-proj-3-tuple(v_15))) in
        {61}let h_4: bitstring = (if v_16 then 3-proj-3-tuple(v_15) else caught-fail) in
        {62}let ck_4: key = (if v_16 then 2-proj-3-tuple(v_15) else caught-fail) in
        {63}let cs_4: cipherstate = (if v_16 then 1-proj-3-tuple(v_15) else caught-fail) in
        {64}let ss_4: symmetricstate = (if v_14 then catch-fail((if v_16 then symmetricstatepack(cs_4,ck_4,hash(h_4,rs)) else fail-any)) else caught-fail) in
        {65}let v_17: bool = not-caught-fail(ss_4) in
        {66}let v_18: bitstring = (if v_17 then catch-fail(symmetricstateunpack(ss_4)) else caught-fail) in
        {67}let v_19: bool = (not-caught-fail(v_18) && success?(1-proj-3-tuple(v_18))) in
        {68}let h_5: bitstring = (if v_19 then 3-proj-3-tuple(v_18) else caught-fail) in
        {69}let ck_5: key = (if v_19 then 2-proj-3-tuple(v_18) else caught-fail) in
        {70}let cs_5: cipherstate = (if v_19 then 1-proj-3-tuple(v_18) else caught-fail) in
        {71}let ss_5: symmetricstate = (if v_17 then catch-fail((if v_19 then symmetricstatepack(cs_5,ck_5,hash(h_5,rm)) else fail-any)) else caught-fail) in
        {72}let v_20: bool = not-caught-fail(ss_5) in
        {73}let hs: handshakestate = (if v_6 then (if v_10 then (if v_14 then (if v_17 then (if v_20 then handshakestatepack(ss_5,s,m,e,rs,rm,re,psk,true) else fail-any) else fail-any) else fail-any) else fail-any) else fail-any) in
        {74}insert statestore(me,them,sid_1,statepack_a(hs))
    ) | (
        {187}get statestore(=me,=them,=sid_1,statepack_a(hs_1: handshakestate)) in
        {75}let payload: bitstring = msg_a(me,them,sid_1) in
        {76}let v_21: bitstring = catch-fail(handshakestateunpack(hs_1)) in
        {77}let v_22: bool = (not-caught-fail(v_21) && success?(1-proj-9-tuple(v_21))) in
        {78}let initiator_1: bool = (if v_22 then 9-proj-9-tuple(v_21) else caught-fail) in
        {79}let psk_1: key = (if v_22 then 8-proj-9-tuple(v_21) else caught-fail) in
        {80}let re_1: key = (if v_22 then 7-proj-9-tuple(v_21) else caught-fail) in
        {81}let rm_1: key = (if v_22 then 6-proj-9-tuple(v_21) else caught-fail) in
        {82}let rs_1: key = (if v_22 then 5-proj-9-tuple(v_21) else caught-fail) in
        {83}let e_1: keypair = (if v_22 then 4-proj-9-tuple(v_21) else caught-fail) in
        {84}let m_1: keypair = (if v_22 then 3-proj-9-tuple(v_21) else caught-fail) in
        {85}let s_1: keypair = (if v_22 then 2-proj-9-tuple(v_21) else caught-fail) in
        {86}let ss_6: symmetricstate = (if v_22 then 1-proj-9-tuple(v_21) else caught-fail) in
        {87}let v_23: bitstring = (if v_22 then catch-fail((empty,empty,empty)) else caught-fail) in
        {88}let v_24: bool = (not-caught-fail(v_23) && success?(1-proj-3-tuple(v_23))) in
        {89}let ciphertext: bitstring = (if v_24 then 3-proj-3-tuple(v_23) else caught-fail) in
        {90}let ns: bitstring = (if v_24 then 2-proj-3-tuple(v_23) else caught-fail) in
        {91}let ne: bitstring = (if v_24 then 1-proj-3-tuple(v_23) else caught-fail) in
        {92}let basis_4: key = (if v_24 then key_e(me,them,sid_1) else caught-fail) in
        {93}let public_key_4: key = (if v_24 then catch-fail(dhexp(basis_4,validkey(g))) else caught-fail) in
        {94}let v_25: bool = not-caught-fail(public_key_4) in
        {95}let e_2: keypair = (if v_24 then catch-fail((if v_25 then keypairpack(validkey(public_key_4),basis_4) else fail-any)) else caught-fail) in
        {96}let v_26: bool = not-caught-fail(e_2) in
        {97}let ne_1: bitstring = (if v_26 then catch-fail(getpublickey(e_2)) else caught-fail) in
        {98}let v_27: bool = not-caught-fail(ne_1) in
        {99}let v_28: bitstring = (if v_27 then catch-fail(symmetricstateunpack(ss_6)) else caught-fail) in
        {100}let v_29: bool = (not-caught-fail(v_28) && success?(1-proj-3-tuple(v_28))) in
        {101}let h_6: bitstring = (if v_29 then 3-proj-3-tuple(v_28) else caught-fail) in
        {102}let ck_6: key = (if v_29 then 2-proj-3-tuple(v_28) else caught-fail) in
        {103}let cs_6: cipherstate = (if v_29 then 1-proj-3-tuple(v_28) else caught-fail) in
        {104}let ss_7: symmetricstate = (if v_27 then catch-fail((if v_29 then symmetricstatepack(cs_6,ck_6,hash(h_6,ne_1)) else fail-any)) else caught-fail) in
        {105}let v_30: bool = not-caught-fail(ss_7) in
        {106}let v_31: bitstring = (if v_30 then catch-fail(keypairunpack(e_2)) else caught-fail) in
        {107}let v_32: bool = (not-caught-fail(v_31) && success?(1-proj-2-tuple(v_31))) in
        {108}let my_private_key: key = (if v_32 then 2-proj-2-tuple(v_31) else caught-fail) in
        {109}let my_public_key: key = (if v_32 then 1-proj-2-tuple(v_31) else caught-fail) in
        {110}let input_key_material: key = (if v_30 then catch-fail((if v_32 then dhexp(my_private_key,rm_1) else fail-any)) else caught-fail) in
        {111}let v_33: bool = not-caught-fail(input_key_material) in
        {112}let v_34: bitstring = (if v_33 then catch-fail(symmetricstateunpack(ss_7)) else caught-fail) in
        {113}let v_35: bool = (not-caught-fail(v_34) && success?(1-proj-3-tuple(v_34))) in
        {114}let h_7: bitstring = (if v_35 then 3-proj-3-tuple(v_34) else caught-fail) in
        {115}let ck_7: key = (if v_35 then 2-proj-3-tuple(v_34) else caught-fail) in
        {116}let cs_7: cipherstate = (if v_35 then 1-proj-3-tuple(v_34) else caught-fail) in
        {117}let output1: key = (if v_35 then hmac_hash1(ck_7,input_key_material) else caught-fail) in
        {118}let output2: key = (if v_35 then hmac_hash2(ck_7,input_key_material) else caught-fail) in
        {119}let output3: key = (if v_35 then hmac_hash3(ck_7,input_key_material) else caught-fail) in
        {120}let v_36: bitstring = (if v_35 then catch-fail((output1,output2,output3)) else caught-fail) in
        {121}let v_37: bool = (not-caught-fail(v_36) && success?(1-proj-3-tuple(v_36))) in
        {122}let output_3: key = (if v_37 then 3-proj-3-tuple(v_36) else caught-fail) in
        {123}let temp_k: key = (if v_37 then 2-proj-3-tuple(v_36) else caught-fail) in
        {124}let ck_8: key = (if v_37 then 1-proj-3-tuple(v_36) else caught-fail) in
        {125}let ss_8: symmetricstate = (if v_30 then catch-fail((if v_33 then (if v_35 then (if v_37 then symmetricstatepack(cipherstatepack(temp_k,minnonce),ck_8,h_7) else fail-any) else fail-any) else fail-any)) else caught-fail) in
        {126}let v_38: bool = not-caught-fail(ss_8) in
        {127}let v_39: bitstring = (if v_38 then catch-fail(keypairunpack(m_1)) else caught-fail) in
        {128}let v_40: bool = (not-caught-fail(v_39) && success?(1-proj-2-tuple(v_39))) in
        {129}let my_private_key_1: key = (if v_40 then 2-proj-2-tuple(v_39) else caught-fail) in
        {130}let my_public_key_1: key = (if v_40 then 1-proj-2-tuple(v_39) else caught-fail) in
        {131}let input_key_material_1: key = (if v_38 then catch-fail((if v_40 then dhexp(my_private_key_1,rs_1) else fail-any)) else caught-fail) in
        {132}let v_41: bool = not-caught-fail(input_key_material_1) in
        {133}let v_42: bitstring = (if v_41 then catch-fail(symmetricstateunpack(ss_8)) else caught-fail) in
        {134}let v_43: bool = (not-caught-fail(v_42) && success?(1-proj-3-tuple(v_42))) in
        {135}let h_8: bitstring = (if v_43 then 3-proj-3-tuple(v_42) else caught-fail) in
        {136}let ck_9: key = (if v_43 then 2-proj-3-tuple(v_42) else caught-fail) in
        {137}let cs_8: cipherstate = (if v_43 then 1-proj-3-tuple(v_42) else caught-fail) in
        {138}let output1_1: key = (if v_43 then hmac_hash1(ck_9,input_key_material_1) else caught-fail) in
        {139}let output2_1: key = (if v_43 then hmac_hash2(ck_9,input_key_material_1) else caught-fail) in
        {140}let output3_1: key = (if v_43 then hmac_hash3(ck_9,input_key_material_1) else caught-fail) in
        {141}let v_44: bitstring = (if v_43 then catch-fail((output1_1,output2_1,output3_1)) else caught-fail) in
        {142}let v_45: bool = (not-caught-fail(v_44) && success?(1-proj-3-tuple(v_44))) in
        {143}let output: key = (if v_45 then 3-proj-3-tuple(v_44) else caught-fail) in
        {144}let temp_k_1: key = (if v_45 then 2-proj-3-tuple(v_44) else caught-fail) in
        {145}let ck_10: key = (if v_45 then 1-proj-3-tuple(v_44) else caught-fail) in
        {146}let ss_9: symmetricstate = (if v_38 then catch-fail((if v_41 then (if v_43 then (if v_45 then symmetricstatepack(cipherstatepack(temp_k_1,minnonce),ck_10,h_8) else fail-any) else fail-any) else fail-any)) else caught-fail) in
        {147}let v_46: bool = not-caught-fail(ss_9) in
        {148}let v_47: bitstring = (if v_46 then catch-fail(symmetricstateunpack(ss_9)) else caught-fail) in
        {149}let v_48: bool = (not-caught-fail(v_47) && success?(1-proj-3-tuple(v_47))) in
        {150}let h_9: bitstring = (if v_48 then 3-proj-3-tuple(v_47) else caught-fail) in
        {151}let ck_11: key = (if v_48 then 2-proj-3-tuple(v_47) else caught-fail) in
        {152}let cs_9: cipherstate = (if v_48 then 1-proj-3-tuple(v_47) else caught-fail) in
        {153}let v_49: bitstring = (if v_48 then catch-fail(cipherstateunpack(cs_9)) else caught-fail) in
        {154}let v_50: bool = (not-caught-fail(v_49) && success?(1-proj-2-tuple(v_49))) in
        {155}let n: nonce = (if v_50 then 2-proj-2-tuple(v_49) else caught-fail) in
        {156}let k_1: key = (if v_50 then 1-proj-2-tuple(v_49) else caught-fail) in
        {157}let e_3: bitstring = (if v_50 then encrypt(k_1,n,h_9,payload) else caught-fail) in
        {158}let n_1: nonce = (if v_50 then increment_nonce(n) else caught-fail) in
        {159}let v_51: bitstring = (if v_50 then catch-fail(cipherstateunpack(cs_9)) else caught-fail) in
        {160}let v_52: bool = (not-caught-fail(v_51) && success?(1-proj-2-tuple(v_51))) in
        {161}let o: nonce = (if v_52 then 2-proj-2-tuple(v_51) else caught-fail) in
        {162}let k_2: key = (if v_52 then 1-proj-2-tuple(v_51) else caught-fail) in
        {163}let csi: cipherstate = (if v_50 then catch-fail((if v_52 then cipherstatepack(k_2,n_1) else fail-any)) else caught-fail) in
        {164}let v_53: bool = not-caught-fail(csi) in
        {165}let v_54: bitstring = (if v_48 then catch-fail((if v_50 then (if v_53 then (csi,e_3) else fail-any) else fail-any)) else caught-fail) in
        {166}let v_55: bool = (not-caught-fail(v_54) && success?(1-proj-2-tuple(v_54))) in
        {167}let ciphertext_1: bitstring = (if v_55 then 2-proj-2-tuple(v_54) else caught-fail) in
        {168}let csi_1: cipherstate = (if v_55 then 1-proj-2-tuple(v_54) else caught-fail) in
        {169}let ss_10: symmetricstate = (if v_55 then symmetricstatepack(csi_1,ck_11,h_9) else caught-fail) in
        {170}let v_56: bitstring = (if v_55 then catch-fail(symmetricstateunpack(ss_10)) else caught-fail) in
        {171}let v_57: bool = (not-caught-fail(v_56) && success?(1-proj-3-tuple(v_56))) in
        {172}let h_10: bitstring = (if v_57 then 3-proj-3-tuple(v_56) else caught-fail) in
        {173}let ck_12: key = (if v_57 then 2-proj-3-tuple(v_56) else caught-fail) in
        {174}let cs_10: cipherstate = (if v_57 then 1-proj-3-tuple(v_56) else caught-fail) in
        {175}let ssi: symmetricstate = (if v_55 then catch-fail((if v_57 then symmetricstatepack(cs_10,ck_12,hash(h_10,ciphertext_1)) else fail-any)) else caught-fail) in
        {176}let v_58: bool = not-caught-fail(ssi) in
        {177}let v_59: bitstring = (if v_46 then catch-fail((if v_48 then (if v_55 then (if v_58 then (ssi,ciphertext_1) else fail-any) else fail-any) else fail-any)) else caught-fail) in
        {178}let v_60: bool = (not-caught-fail(v_59) && success?(1-proj-2-tuple(v_59))) in
        {179}let ciphertext_2: bitstring = (if v_60 then 2-proj-2-tuple(v_59) else caught-fail) in
        {180}let ss_11: symmetricstate = (if v_60 then 1-proj-2-tuple(v_59) else caught-fail) in
        {181}let hs_2: handshakestate = (if v_60 then handshakestatepack(ss_11,s_1,m_1,e_2,rs_1,rm_1,re_1,psk_1,initiator_1) else caught-fail) in
        {182}let message_buffer: bitstring = (if v_60 then concat3(ne_1,ns,ciphertext_2) else caught-fail) in
        {183}let (hs_3: handshakestate,message_a: bitstring) = (if v_22 then (if v_24 then (if v_26 then (if v_27 then (if v_30 then (if v_38 then (if v_46 then (if v_60 then (hs_2,message_buffer) else fail-any) else fail-any) else fail-any) else fail-any) else fail-any) else fail-any) else fail-any) else fail-any) in
        {184}event SendMsg(me,them,stagepack_a(sid_1),msg_a(me,them,sid_1));
        {185}insert statestore(me,them,sid_1,statepack_b(hs_3));
        {186}out(pub, message_a)
    ) | (
        {344}get statestore(=me,=them,=sid_1,statepack_b(hs_4: handshakestate)) in
        {188}in(pub, message_b: bitstring);
        {189}let v_61: bitstring = catch-fail(handshakestateunpack(hs_4)) in
        {190}let v_62: bool = (not-caught-fail(v_61) && success?(1-proj-9-tuple(v_61))) in
        {191}let initiator_2: bool = (if v_62 then 9-proj-9-tuple(v_61) else caught-fail) in
        {192}let psk_2: key = (if v_62 then 8-proj-9-tuple(v_61) else caught-fail) in
        {193}let re_2: key = (if v_62 then 7-proj-9-tuple(v_61) else caught-fail) in
        {194}let rm_2: key = (if v_62 then 6-proj-9-tuple(v_61) else caught-fail) in
        {195}let rs_2: key = (if v_62 then 5-proj-9-tuple(v_61) else caught-fail) in
        {196}let e_4: keypair = (if v_62 then 4-proj-9-tuple(v_61) else caught-fail) in
        {197}let m_2: keypair = (if v_62 then 3-proj-9-tuple(v_61) else caught-fail) in
        {198}let s_2: keypair = (if v_62 then 2-proj-9-tuple(v_61) else caught-fail) in
        {199}let ss_12: symmetricstate = (if v_62 then 1-proj-9-tuple(v_61) else caught-fail) in
        {200}let v_63: bitstring = (if v_62 then catch-fail(deconcat3(message_b)) else caught-fail) in
        {201}let v_64: bool = (not-caught-fail(v_63) && success?(1-proj-3-tuple(v_63))) in
        {202}let ciphertext_3: bitstring = (if v_64 then 3-proj-3-tuple(v_63) else caught-fail) in
        {203}let ns_1: bitstring = (if v_64 then 2-proj-3-tuple(v_63) else caught-fail) in
        {204}let ne_2: bitstring = (if v_64 then 1-proj-3-tuple(v_63) else caught-fail) in
        {205}let valid1: bool = (if v_64 then true else caught-fail) in
        {206}let re_3: key = (if v_64 then ne_2 else caught-fail) in
        {207}let v_65: bitstring = (if v_64 then catch-fail(symmetricstateunpack(ss_12)) else caught-fail) in
        {208}let v_66: bool = (not-caught-fail(v_65) && success?(1-proj-3-tuple(v_65))) in
        {209}let h_11: bitstring = (if v_66 then 3-proj-3-tuple(v_65) else caught-fail) in
        {210}let ck_13: key = (if v_66 then 2-proj-3-tuple(v_65) else caught-fail) in
        {211}let cs_11: cipherstate = (if v_66 then 1-proj-3-tuple(v_65) else caught-fail) in
        {212}let ss_13: symmetricstate = (if v_64 then catch-fail((if v_66 then symmetricstatepack(cs_11,ck_13,hash(h_11,re_3)) else fail-any)) else caught-fail) in
        {213}let v_67: bool = not-caught-fail(ss_13) in
        {214}let v_68: bitstring = (if v_67 then catch-fail(keypairunpack(e_4)) else caught-fail) in
        {215}let v_69: bool = (not-caught-fail(v_68) && success?(1-proj-2-tuple(v_68))) in
        {216}let my_private_key_2: key = (if v_69 then 2-proj-2-tuple(v_68) else caught-fail) in
        {217}let my_public_key_2: key = (if v_69 then 1-proj-2-tuple(v_68) else caught-fail) in
        {218}let input_key_material_2: key = (if v_67 then catch-fail((if v_69 then dhexp(my_private_key_2,re_3) else fail-any)) else caught-fail) in
        {219}let v_70: bool = not-caught-fail(input_key_material_2) in
        {220}let v_71: bitstring = (if v_70 then catch-fail(symmetricstateunpack(ss_13)) else caught-fail) in
        {221}let v_72: bool = (not-caught-fail(v_71) && success?(1-proj-3-tuple(v_71))) in
        {222}let h_12: bitstring = (if v_72 then 3-proj-3-tuple(v_71) else caught-fail) in
        {223}let ck_14: key = (if v_72 then 2-proj-3-tuple(v_71) else caught-fail) in
        {224}let cs_12: cipherstate = (if v_72 then 1-proj-3-tuple(v_71) else caught-fail) in
        {225}let output1_2: key = (if v_72 then hmac_hash1(ck_14,input_key_material_2) else caught-fail) in
        {226}let output2_2: key = (if v_72 then hmac_hash2(ck_14,input_key_material_2) else caught-fail) in
        {227}let output3_2: key = (if v_72 then hmac_hash3(ck_14,input_key_material_2) else caught-fail) in
        {228}let v_73: bitstring = (if v_72 then catch-fail((output1_2,output2_2,output3_2)) else caught-fail) in
        {229}let v_74: bool = (not-caught-fail(v_73) && success?(1-proj-3-tuple(v_73))) in
        {230}let output_1: key = (if v_74 then 3-proj-3-tuple(v_73) else caught-fail) in
        {231}let temp_k_2: key = (if v_74 then 2-proj-3-tuple(v_73) else caught-fail) in
        {232}let ck_15: key = (if v_74 then 1-proj-3-tuple(v_73) else caught-fail) in
        {233}let ss_14: symmetricstate = (if v_67 then catch-fail((if v_70 then (if v_72 then (if v_74 then symmetricstatepack(cipherstatepack(temp_k_2,minnonce),ck_15,h_12) else fail-any) else fail-any) else fail-any)) else caught-fail) in
        {234}let v_75: bool = not-caught-fail(ss_14) in
        {235}let v_76: bitstring = (if v_75 then catch-fail(keypairunpack(s_2)) else caught-fail) in
        {236}let v_77: bool = (not-caught-fail(v_76) && success?(1-proj-2-tuple(v_76))) in
        {237}let my_private_key_3: key = (if v_77 then 2-proj-2-tuple(v_76) else caught-fail) in
        {238}let my_public_key_3: key = (if v_77 then 1-proj-2-tuple(v_76) else caught-fail) in
        {239}let input_key_material_3: key = (if v_75 then catch-fail((if v_77 then dhexp(my_private_key_3,re_3) else fail-any)) else caught-fail) in
        {240}let v_78: bool = not-caught-fail(input_key_material_3) in
        {241}let v_79: bitstring = (if v_78 then catch-fail(symmetricstateunpack(ss_14)) else caught-fail) in
        {242}let v_80: bool = (not-caught-fail(v_79) && success?(1-proj-3-tuple(v_79))) in
        {243}let h_13: bitstring = (if v_80 then 3-proj-3-tuple(v_79) else caught-fail) in
        {244}let ck_16: key = (if v_80 then 2-proj-3-tuple(v_79) else caught-fail) in
        {245}let cs_13: cipherstate = (if v_80 then 1-proj-3-tuple(v_79) else caught-fail) in
        {246}let output1_3: key = (if v_80 then hmac_hash1(ck_16,input_key_material_3) else caught-fail) in
        {247}let output2_3: key = (if v_80 then hmac_hash2(ck_16,input_key_material_3) else caught-fail) in
        {248}let output3_3: key = (if v_80 then hmac_hash3(ck_16,input_key_material_3) else caught-fail) in
        {249}let v_81: bitstring = (if v_80 then catch-fail((output1_3,output2_3,output3_3)) else caught-fail) in
        {250}let v_82: bool = (not-caught-fail(v_81) && success?(1-proj-3-tuple(v_81))) in
        {251}let output_2: key = (if v_82 then 3-proj-3-tuple(v_81) else caught-fail) in
        {252}let temp_k_3: key = (if v_82 then 2-proj-3-tuple(v_81) else caught-fail) in
        {253}let ck_17: key = (if v_82 then 1-proj-3-tuple(v_81) else caught-fail) in
        {254}let ss_15: symmetricstate = (if v_75 then catch-fail((if v_78 then (if v_80 then (if v_82 then symmetricstatepack(cipherstatepack(temp_k_3,minnonce),ck_17,h_13) else fail-any) else fail-any) else fail-any)) else caught-fail) in
        {255}let v_83: bool = not-caught-fail(ss_15) in
        {256}let v_84: bitstring = (if v_83 then catch-fail(keypairunpack(m_2)) else caught-fail) in
        {257}let v_85: bool = (not-caught-fail(v_84) && success?(1-proj-2-tuple(v_84))) in
        {258}let my_private_key_4: key = (if v_85 then 2-proj-2-tuple(v_84) else caught-fail) in
        {259}let my_public_key_4: key = (if v_85 then 1-proj-2-tuple(v_84) else caught-fail) in
        {260}let input_key_material_4: key = (if v_83 then catch-fail((if v_85 then dhexp(my_private_key_4,re_3) else fail-any)) else caught-fail) in
        {261}let v_86: bool = not-caught-fail(input_key_material_4) in
        {262}let v_87: bitstring = (if v_86 then catch-fail(symmetricstateunpack(ss_15)) else caught-fail) in
        {263}let v_88: bool = (not-caught-fail(v_87) && success?(1-proj-3-tuple(v_87))) in
        {264}let h_14: bitstring = (if v_88 then 3-proj-3-tuple(v_87) else caught-fail) in
        {265}let ck_18: key = (if v_88 then 2-proj-3-tuple(v_87) else caught-fail) in
        {266}let cs_14: cipherstate = (if v_88 then 1-proj-3-tuple(v_87) else caught-fail) in
        {267}let output1_4: key = (if v_88 then hmac_hash1(ck_18,input_key_material_4) else caught-fail) in
        {268}let output2_4: key = (if v_88 then hmac_hash2(ck_18,input_key_material_4) else caught-fail) in
        {269}let output3_4: key = (if v_88 then hmac_hash3(ck_18,input_key_material_4) else caught-fail) in
        {270}let v_89: bitstring = (if v_88 then catch-fail((output1_4,output2_4,output3_4)) else caught-fail) in
        {271}let v_90: bool = (not-caught-fail(v_89) && success?(1-proj-3-tuple(v_89))) in
        {272}let output_4: key = (if v_90 then 3-proj-3-tuple(v_89) else caught-fail) in
        {273}let temp_k_4: key = (if v_90 then 2-proj-3-tuple(v_89) else caught-fail) in
        {274}let ck_19: key = (if v_90 then 1-proj-3-tuple(v_89) else caught-fail) in
        {275}let ss_16: symmetricstate = (if v_83 then catch-fail((if v_86 then (if v_88 then (if v_90 then symmetricstatepack(cipherstatepack(temp_k_4,minnonce),ck_19,h_14) else fail-any) else fail-any) else fail-any)) else caught-fail) in
        {276}let v_91: bool = not-caught-fail(ss_16) in
        {277}let v_92: bitstring = (if v_91 then catch-fail(symmetricstateunpack(ss_16)) else caught-fail) in
        {278}let v_93: bool = (not-caught-fail(v_92) && success?(1-proj-3-tuple(v_92))) in
        {279}let h_15: bitstring = (if v_93 then 3-proj-3-tuple(v_92) else caught-fail) in
        {280}let ck_20: key = (if v_93 then 2-proj-3-tuple(v_92) else caught-fail) in
        {281}let cs_15: cipherstate = (if v_93 then 1-proj-3-tuple(v_92) else caught-fail) in
        {282}let v_94: bitstring = (if v_93 then catch-fail(cipherstateunpack(cs_15)) else caught-fail) in
        {283}let v_95: bool = (not-caught-fail(v_94) && success?(1-proj-2-tuple(v_94))) in
        {284}let n_2: nonce = (if v_95 then 2-proj-2-tuple(v_94) else caught-fail) in
        {285}let k_3: key = (if v_95 then 1-proj-2-tuple(v_94) else caught-fail) in
        {286}let d: aead = (if v_95 then catch-fail(decrypt(k_3,n_2,h_15,ciphertext_3)) else caught-fail) in
        {287}let v_96: bool = not-caught-fail(d) in
        {288}let v_97: bitstring = (if v_96 then catch-fail(aeadunpack(d)) else caught-fail) in
        {289}let v_98: bool = (not-caught-fail(v_97) && success?(1-proj-3-tuple(v_97))) in
        {290}let plaintext: bitstring = (if v_98 then 3-proj-3-tuple(v_97) else caught-fail) in
        {291}let adi: bitstring = (if v_98 then 2-proj-3-tuple(v_97) else caught-fail) in
        {292}let valid: bool = (if v_98 then 1-proj-3-tuple(v_97) else caught-fail) in
        {293}let n_3: nonce = (if v_98 then increment_nonce(n_2) else caught-fail) in
        {294}let v_99: bitstring = (if v_98 then catch-fail(cipherstateunpack(cs_15)) else caught-fail) in
        {295}let v_100: bool = (not-caught-fail(v_99) && success?(1-proj-2-tuple(v_99))) in
        {296}let o_1: nonce = (if v_100 then 2-proj-2-tuple(v_99) else caught-fail) in
        {297}let k_4: key = (if v_100 then 1-proj-2-tuple(v_99) else caught-fail) in
        {298}let csi_2: cipherstate = (if v_98 then catch-fail((if v_100 then cipherstatepack(k_4,n_3) else fail-any)) else caught-fail) in
        {299}let v_101: bool = not-caught-fail(csi_2) in
        {300}let v_102: bitstring = (if v_93 then catch-fail((if v_95 then (if v_96 then (if v_98 then (if v_101 then (csi_2,plaintext,valid) else fail-any) else fail-any) else fail-any) else fail-any)) else caught-fail) in
        {301}let v_103: bool = (not-caught-fail(v_102) && success?(1-proj-3-tuple(v_102))) in
        {302}let valid_1: bool = (if v_103 then 3-proj-3-tuple(v_102) else caught-fail) in
        {303}let plaintext_1: bitstring = (if v_103 then 2-proj-3-tuple(v_102) else caught-fail) in
        {304}let csi_3: cipherstate = (if v_103 then 1-proj-3-tuple(v_102) else caught-fail) in
        {305}let ss_17: symmetricstate = (if v_103 then symmetricstatepack(csi_3,ck_20,h_15) else caught-fail) in
        {306}let v_104: bitstring = (if v_103 then catch-fail(symmetricstateunpack(ss_17)) else caught-fail) in
        {307}let v_105: bool = (not-caught-fail(v_104) && success?(1-proj-3-tuple(v_104))) in
        {308}let h_16: bitstring = (if v_105 then 3-proj-3-tuple(v_104) else caught-fail) in
        {309}let ck_21: key = (if v_105 then 2-proj-3-tuple(v_104) else caught-fail) in
        {310}let cs_16: cipherstate = (if v_105 then 1-proj-3-tuple(v_104) else caught-fail) in
        {311}let ssi_1: symmetricstate = (if v_103 then catch-fail((if v_105 then symmetricstatepack(cs_16,ck_21,hash(h_16,ciphertext_3)) else fail-any)) else caught-fail) in
        {312}let v_106: bool = not-caught-fail(ssi_1) in
        {313}let v_107: bitstring = (if v_91 then catch-fail((if v_93 then (if v_103 then (if v_106 then (ssi_1,plaintext_1,valid_1) else fail-any) else fail-any) else fail-any)) else caught-fail) in
        {314}let v_108: bool = (not-caught-fail(v_107) && success?(1-proj-3-tuple(v_107))) in
        {315}let valid2: bool = (if v_108 then 3-proj-3-tuple(v_107) else caught-fail) in
        {316}let plaintext_2: bitstring = (if v_108 then 2-proj-3-tuple(v_107) else caught-fail) in
        {317}let ss_18: symmetricstate = (if v_108 then 1-proj-3-tuple(v_107) else caught-fail) in
        {318}let v_109: bool = (if v_108 then catch-fail((valid1 && valid2)) else caught-fail) in
        {319}let hs_5: handshakestate = (if v_109 then handshakestatepack(ss_18,s_2,m_2,e_4,rs_2,rm_2,re_3,psk_2,initiator_2) else caught-fail) in
        {320}let v_110: bitstring = (if v_109 then catch-fail(symmetricstateunpack(ss_18)) else caught-fail) in
        {321}let v_111: bool = (not-caught-fail(v_110) && success?(1-proj-3-tuple(v_110))) in
        {322}let h_17: bitstring = (if v_111 then 3-proj-3-tuple(v_110) else caught-fail) in
        {323}let ck_22: key = (if v_111 then 2-proj-3-tuple(v_110) else caught-fail) in
        {324}let cs_17: cipherstate = (if v_111 then 1-proj-3-tuple(v_110) else caught-fail) in
        {325}let input_key_material_5: key = (if v_111 then zero else caught-fail) in
        {326}let output1_5: key = (if v_111 then hmac_hash1(ck_22,input_key_material_5) else caught-fail) in
        {327}let output2_5: key = (if v_111 then hmac_hash2(ck_22,input_key_material_5) else caught-fail) in
        {328}let output3_5: key = (if v_111 then hmac_hash3(ck_22,input_key_material_5) else caught-fail) in
        {329}let v_112: bitstring = (if v_111 then catch-fail((output1_5,output2_5,output3_5)) else caught-fail) in
        {330}let v_113: bool = (not-caught-fail(v_112) && success?(1-proj-3-tuple(v_112))) in
        {331}let temp_k3: key = (if v_113 then 3-proj-3-tuple(v_112) else caught-fail) in
        {332}let temp_k2: key = (if v_113 then 2-proj-3-tuple(v_112) else caught-fail) in
        {333}let temp_k1: key = (if v_113 then 1-proj-3-tuple(v_112) else caught-fail) in
        {334}let cs1: cipherstate = (if v_113 then cipherstatepack(temp_k1,minnonce) else caught-fail) in
        {335}let cs2: cipherstate = (if v_113 then cipherstatepack(temp_k2,minnonce) else caught-fail) in
        {336}let v_114: bitstring = (if v_109 then catch-fail((if v_111 then (if v_113 then (ss_18,cs1,cs2) else fail-any) else fail-any)) else caught-fail) in
        {337}let v_115: bool = (not-caught-fail(v_114) && success?(1-proj-3-tuple(v_114))) in
        {338}let cs2_1: cipherstate = (if v_115 then 3-proj-3-tuple(v_114) else caught-fail) in
        {339}let cs1_1: cipherstate = (if v_115 then 2-proj-3-tuple(v_114) else caught-fail) in
        {340}let ssi_2: symmetricstate = (if v_115 then 1-proj-3-tuple(v_114) else caught-fail) in
        {341}let (hs_6: handshakestate,plaintext_b: bitstring,valid_2: bool,cs1_2: cipherstate,cs2_2: cipherstate) = (if v_62 then (if v_64 then (if v_67 then (if v_75 then (if v_83 then (if v_91 then (if v_108 then (if undo-catch-fail(v_109) then (if v_115 then (hs_5,plaintext_2,true,cs1_1,cs2_1) else fail-any) else fail-any) else fail-any) else fail-any) else fail-any) else fail-any) else fail-any) else fail-any) else fail-any) in
        {342}event RecvMsg(me,them,stagepack_b(sid_1),plaintext_b);
        {343}insert statestore(me,them,sid_1,statepack_c(hs_6,cs1_2,cs2_2))
    ) | (
        {345}!
        {403}get statestore(=me,=them,=sid_1,statepack_c(hs_7: handshakestate,cs1_3: cipherstate,cs2_3: cipherstate)) in
        {346}let hs_8: handshakestate = handshakestatesetcs(hs_7,cs1_3) in
        {347}let payload_1: bitstring = msg_c(me,them,sid_1) in
        {348}let v_116: bitstring = catch-fail(handshakestateunpack(hs_8)) in
        {349}let v_117: bool = (not-caught-fail(v_116) && success?(1-proj-9-tuple(v_116))) in
        {350}let initiator_3: bool = (if v_117 then 9-proj-9-tuple(v_116) else caught-fail) in
        {351}let psk_3: key = (if v_117 then 8-proj-9-tuple(v_116) else caught-fail) in
        {352}let re_4: key = (if v_117 then 7-proj-9-tuple(v_116) else caught-fail) in
        {353}let rm_3: key = (if v_117 then 6-proj-9-tuple(v_116) else caught-fail) in
        {354}let rs_3: key = (if v_117 then 5-proj-9-tuple(v_116) else caught-fail) in
        {355}let e_5: keypair = (if v_117 then 4-proj-9-tuple(v_116) else caught-fail) in
        {356}let m_3: keypair = (if v_117 then 3-proj-9-tuple(v_116) else caught-fail) in
        {357}let s_3: keypair = (if v_117 then 2-proj-9-tuple(v_116) else caught-fail) in
        {358}let ss_19: symmetricstate = (if v_117 then 1-proj-9-tuple(v_116) else caught-fail) in
        {359}let v_118: bitstring = (if v_117 then catch-fail((empty,empty,empty)) else caught-fail) in
        {360}let v_119: bool = (not-caught-fail(v_118) && success?(1-proj-3-tuple(v_118))) in
        {361}let ciphertext_4: bitstring = (if v_119 then 3-proj-3-tuple(v_118) else caught-fail) in
        {362}let ns_2: bitstring = (if v_119 then 2-proj-3-tuple(v_118) else caught-fail) in
        {363}let ne_3: bitstring = (if v_119 then 1-proj-3-tuple(v_118) else caught-fail) in
        {364}let v_120: bitstring = (if v_119 then catch-fail(symmetricstateunpack(ss_19)) else caught-fail) in
        {365}let v_121: bool = (not-caught-fail(v_120) && success?(1-proj-3-tuple(v_120))) in
        {366}let h_18: bitstring = (if v_121 then 3-proj-3-tuple(v_120) else caught-fail) in
        {367}let ck_23: key = (if v_121 then 2-proj-3-tuple(v_120) else caught-fail) in
        {368}let cs_18: cipherstate = (if v_121 then 1-proj-3-tuple(v_120) else caught-fail) in
        {369}let v_122: bitstring = (if v_121 then catch-fail(cipherstateunpack(cs_18)) else caught-fail) in
        {370}let v_123: bool = (not-caught-fail(v_122) && success?(1-proj-2-tuple(v_122))) in
        {371}let n_4: nonce = (if v_123 then 2-proj-2-tuple(v_122) else caught-fail) in
        {372}let k_5: key = (if v_123 then 1-proj-2-tuple(v_122) else caught-fail) in
        {373}let e_6: bitstring = (if v_123 then encrypt(k_5,n_4,h_18,payload_1) else caught-fail) in
        {374}let n_5: nonce = (if v_123 then increment_nonce(n_4) else caught-fail) in
        {375}let v_124: bitstring = (if v_123 then catch-fail(cipherstateunpack(cs_18)) else caught-fail) in
        {376}let v_125: bool = (not-caught-fail(v_124) && success?(1-proj-2-tuple(v_124))) in
        {377}let o_2: nonce = (if v_125 then 2-proj-2-tuple(v_124) else caught-fail) in
        {378}let k_6: key = (if v_125 then 1-proj-2-tuple(v_124) else caught-fail) in
        {379}let csi_4: cipherstate = (if v_123 then catch-fail((if v_125 then cipherstatepack(k_6,n_5) else fail-any)) else caught-fail) in
        {380}let v_126: bool = not-caught-fail(csi_4) in
        {381}let v_127: bitstring = (if v_121 then catch-fail((if v_123 then (if v_126 then (csi_4,e_6) else fail-any) else fail-any)) else caught-fail) in
        {382}let v_128: bool = (not-caught-fail(v_127) && success?(1-proj-2-tuple(v_127))) in
        {383}let ciphertext_5: bitstring = (if v_128 then 2-proj-2-tuple(v_127) else caught-fail) in
        {384}let csi_5: cipherstate = (if v_128 then 1-proj-2-tuple(v_127) else caught-fail) in
        {385}let ss_20: symmetricstate = (if v_128 then symmetricstatepack(csi_5,ck_23,h_18) else caught-fail) in
        {386}let v_129: bitstring = (if v_128 then catch-fail(symmetricstateunpack(ss_20)) else caught-fail) in
        {387}let v_130: bool = (not-caught-fail(v_129) && success?(1-proj-3-tuple(v_129))) in
        {388}let h_19: bitstring = (if v_130 then 3-proj-3-tuple(v_129) else caught-fail) in
        {389}let ck_24: key = (if v_130 then 2-proj-3-tuple(v_129) else caught-fail) in
        {390}let cs_19: cipherstate = (if v_130 then 1-proj-3-tuple(v_129) else caught-fail) in
        {391}let ssi_3: symmetricstate = (if v_128 then catch-fail((if v_130 then symmetricstatepack(cs_19,ck_24,hash(h_19,ciphertext_5)) else fail-any)) else caught-fail) in
        {392}let v_131: bool = not-caught-fail(ssi_3) in
        {393}let v_132: bitstring = (if v_119 then catch-fail((if v_121 then (if v_128 then (if v_131 then (ssi_3,ciphertext_5) else fail-any) else fail-any) else fail-any)) else caught-fail) in
        {394}let v_133: bool = (not-caught-fail(v_132) && success?(1-proj-2-tuple(v_132))) in
        {395}let ciphertext_6: bitstring = (if v_133 then 2-proj-2-tuple(v_132) else caught-fail) in
        {396}let ss_21: symmetricstate = (if v_133 then 1-proj-2-tuple(v_132) else caught-fail) in
        {397}let hs_9: handshakestate = (if v_133 then handshakestatepack(ss_21,s_3,m_3,e_5,rs_3,rm_3,re_4,psk_3,initiator_3) else caught-fail) in
        {398}let message_buffer_1: bitstring = (if v_133 then concat3(ne_3,ns_2,ciphertext_6) else caught-fail) in
        {399}let (hs_10: handshakestate,message_c: bitstring) = (if v_117 then (if v_119 then (if v_133 then (hs_9,message_buffer_1) else fail-any) else fail-any) else fail-any) in
        {400}event SendMsg(me,them,stagepack_c(sid_1),msg_c(me,them,sid_1));
        {401}insert statestore(me,them,sid_1,statepack_d(hs_10,handshakestategetcs(hs_10),cs2_3));
        {402}out(pub, message_c)
    ) | (
        {404}!
        {470}get statestore(=me,=them,=sid_1,statepack_d(hs_11: handshakestate,cs1_4: cipherstate,cs2_4: cipherstate)) in
        {405}let hs_12: handshakestate = handshakestatesetcs(hs_11,cs2_4) in
        {406}in(pub, message_d: bitstring);
        {407}let v_134: bitstring = catch-fail(handshakestateunpack(hs_12)) in
        {408}let v_135: bool = (not-caught-fail(v_134) && success?(1-proj-9-tuple(v_134))) in
        {409}let initiator_4: bool = (if v_135 then 9-proj-9-tuple(v_134) else caught-fail) in
        {410}let psk_4: key = (if v_135 then 8-proj-9-tuple(v_134) else caught-fail) in
        {411}let re_5: key = (if v_135 then 7-proj-9-tuple(v_134) else caught-fail) in
        {412}let rm_4: key = (if v_135 then 6-proj-9-tuple(v_134) else caught-fail) in
        {413}let rs_4: key = (if v_135 then 5-proj-9-tuple(v_134) else caught-fail) in
        {414}let e_7: keypair = (if v_135 then 4-proj-9-tuple(v_134) else caught-fail) in
        {415}let m_4: keypair = (if v_135 then 3-proj-9-tuple(v_134) else caught-fail) in
        {416}let s_4: keypair = (if v_135 then 2-proj-9-tuple(v_134) else caught-fail) in
        {417}let ss_22: symmetricstate = (if v_135 then 1-proj-9-tuple(v_134) else caught-fail) in
        {418}let v_136: bitstring = (if v_135 then catch-fail(deconcat3(message_d)) else caught-fail) in
        {419}let v_137: bool = (not-caught-fail(v_136) && success?(1-proj-3-tuple(v_136))) in
        {420}let ciphertext_7: bitstring = (if v_137 then 3-proj-3-tuple(v_136) else caught-fail) in
        {421}let ns_3: bitstring = (if v_137 then 2-proj-3-tuple(v_136) else caught-fail) in
        {422}let ne_4: bitstring = (if v_137 then 1-proj-3-tuple(v_136) else caught-fail) in
        {423}let valid1_1: bool = (if v_137 then true else caught-fail) in
        {424}let v_138: bitstring = (if v_137 then catch-fail(symmetricstateunpack(ss_22)) else caught-fail) in
        {425}let v_139: bool = (not-caught-fail(v_138) && success?(1-proj-3-tuple(v_138))) in
        {426}let h_20: bitstring = (if v_139 then 3-proj-3-tuple(v_138) else caught-fail) in
        {427}let ck_25: key = (if v_139 then 2-proj-3-tuple(v_138) else caught-fail) in
        {428}let cs_20: cipherstate = (if v_139 then 1-proj-3-tuple(v_138) else caught-fail) in
        {429}let v_140: bitstring = (if v_139 then catch-fail(cipherstateunpack(cs_20)) else caught-fail) in
        {430}let v_141: bool = (not-caught-fail(v_140) && success?(1-proj-2-tuple(v_140))) in
        {431}let n_6: nonce = (if v_141 then 2-proj-2-tuple(v_140) else caught-fail) in
        {432}let k_7: key = (if v_141 then 1-proj-2-tuple(v_140) else caught-fail) in
        {433}let d_1: aead = (if v_141 then catch-fail(decrypt(k_7,n_6,h_20,ciphertext_7)) else caught-fail) in
        {434}let v_142: bool = not-caught-fail(d_1) in
        {435}let v_143: bitstring = (if v_142 then catch-fail(aeadunpack(d_1)) else caught-fail) in
        {436}let v_144: bool = (not-caught-fail(v_143) && success?(1-proj-3-tuple(v_143))) in
        {437}let plaintext_3: bitstring = (if v_144 then 3-proj-3-tuple(v_143) else caught-fail) in
        {438}let adi_1: bitstring = (if v_144 then 2-proj-3-tuple(v_143) else caught-fail) in
        {439}let valid_3: bool = (if v_144 then 1-proj-3-tuple(v_143) else caught-fail) in
        {440}let n_7: nonce = (if v_144 then increment_nonce(n_6) else caught-fail) in
        {441}let v_145: bitstring = (if v_144 then catch-fail(cipherstateunpack(cs_20)) else caught-fail) in
        {442}let v_146: bool = (not-caught-fail(v_145) && success?(1-proj-2-tuple(v_145))) in
        {443}let o_3: nonce = (if v_146 then 2-proj-2-tuple(v_145) else caught-fail) in
        {444}let k_8: key = (if v_146 then 1-proj-2-tuple(v_145) else caught-fail) in
        {445}let csi_6: cipherstate = (if v_144 then catch-fail((if v_146 then cipherstatepack(k_8,n_7) else fail-any)) else caught-fail) in
        {446}let v_147: bool = not-caught-fail(csi_6) in
        {447}let v_148: bitstring = (if v_139 then catch-fail((if v_141 then (if v_142 then (if v_144 then (if v_147 then (csi_6,plaintext_3,valid_3) else fail-any) else fail-any) else fail-any) else fail-any)) else caught-fail) in
        {448}let v_149: bool = (not-caught-fail(v_148) && success?(1-proj-3-tuple(v_148))) in
        {449}let valid_4: bool = (if v_149 then 3-proj-3-tuple(v_148) else caught-fail) in
        {450}let plaintext_4: bitstring = (if v_149 then 2-proj-3-tuple(v_148) else caught-fail) in
        {451}let csi_7: cipherstate = (if v_149 then 1-proj-3-tuple(v_148) else caught-fail) in
        {452}let ss_23: symmetricstate = (if v_149 then symmetricstatepack(csi_7,ck_25,h_20) else caught-fail) in
        {453}let v_150: bitstring = (if v_149 then catch-fail(symmetricstateunpack(ss_23)) else caught-fail) in
        {454}let v_151: bool = (not-caught-fail(v_150) && success?(1-proj-3-tuple(v_150))) in
        {455}let h_21: bitstring = (if v_151 then 3-proj-3-tuple(v_150) else caught-fail) in
        {456}let ck_26: key = (if v_151 then 2-proj-3-tuple(v_150) else caught-fail) in
        {457}let cs_21: cipherstate = (if v_151 then 1-proj-3-tuple(v_150) else caught-fail) in
        {458}let ssi_4: symmetricstate = (if v_149 then catch-fail((if v_151 then symmetricstatepack(cs_21,ck_26,hash(h_21,ciphertext_7)) else fail-any)) else caught-fail) in
        {459}let v_152: bool = not-caught-fail(ssi_4) in
        {460}let v_153: bitstring = (if v_137 then catch-fail((if v_139 then (if v_149 then (if v_152 then (ssi_4,plaintext_4,valid_4) else fail-any) else fail-any) else fail-any)) else caught-fail) in
        {461}let v_154: bool = (not-caught-fail(v_153) && success?(1-proj-3-tuple(v_153))) in
        {462}let valid2_1: bool = (if v_154 then 3-proj-3-tuple(v_153) else caught-fail) in
        {463}let plaintext_5: bitstring = (if v_154 then 2-proj-3-tuple(v_153) else caught-fail) in
        {464}let ss_24: symmetricstate = (if v_154 then 1-proj-3-tuple(v_153) else caught-fail) in
        {465}let v_155: bool = (if v_154 then catch-fail((valid1_1 && valid2_1)) else caught-fail) in
        {466}let hs_13: handshakestate = (if v_155 then handshakestatepack(ss_24,s_4,m_4,e_7,rs_4,rm_4,re_5,psk_4,initiator_4) else caught-fail) in
        {467}let (hs_14: handshakestate,plaintext_d: bitstring,valid_5: bool) = (if v_135 then (if v_137 then (if v_154 then (if undo-catch-fail(v_155) then (hs_13,plaintext_5,true) else fail-any) else fail-any) else fail-any) else fail-any) in
        {468}event RecvMsg(me,them,stagepack_d(sid_1),plaintext_d);
        {469}event RecvEnd(valid_5)
    ) | (
        {471}event LeakS(phase0,me);
        {472}event LeakM(phase0,me);
        {473}out(pub, (key_s(me),key_m(me)))
    ) | (
        {474}phase 1;
        {475}event LeakS(phase1,me);
        {476}event LeakM(phase1,me);
        {477}out(pub, (key_s(me),key_m(me)))
    )
) | (
    {478}let me_1: principal = alice in
    {479}let them_1: principal = charlie in
    {480}let sid_2: sessionid = sid in
    {481}let basis_5: key = key_s(me_1) in
    {482}let public_key_5: key = catch-fail(dhexp(basis_5,validkey(g))) in
    {483}let v_156: bool = not-caught-fail(public_key_5) in
    {484}let s_5: keypair = (if v_156 then keypairpack(validkey(public_key_5),basis_5) else fail-any) in
    {485}let basis_6: key = key_m(me_1) in
    {486}let public_key_6: key = catch-fail(dhexp(basis_6,validkey(g))) in
    {487}let v_157: bool = not-caught-fail(public_key_6) in
    {488}let m_5: keypair = (if v_157 then keypairpack(validkey(public_key_6),basis_6) else fail-any) in
    {489}out(pub, (getpublickey(s_5),getpublickey(m_5)));
    (
        {490}let e_8: keypair = keypairpack(empty,empty) in
        {491}let basis_7: key = key_s(them_1) in
        {492}let public_key_7: key = catch-fail(dhexp(basis_7,validkey(g))) in
        {493}let v_158: bool = not-caught-fail(public_key_7) in
        {494}let rs_5: key = getpublickey((if v_158 then keypairpack(validkey(public_key_7),basis_7) else fail-any)) in
        {495}let basis_8: key = key_s(them_1) in
        {496}let public_key_8: key = catch-fail(dhexp(basis_8,validkey(g))) in
        {497}let v_159: bool = not-caught-fail(public_key_8) in
        {498}let rm_5: key = getpublickey((if v_159 then keypairpack(validkey(public_key_8),basis_8) else fail-any)) in
        {499}let re_6: key = empty in
        {500}let prologue_1: bitstring = empty in
        {501}let psk_5: key = empty in
        {502}let protocol_name_1: bitstring = somename in
        {503}let h_22: bitstring = hash(protocol_name_1,empty) in
        {504}let ck_27: key = h_22 in
        {505}let k_9: key = empty in
        {506}let cs_22: cipherstate = cipherstatepack(k_9,minnonce) in
        {507}let ss_25: symmetricstate = symmetricstatepack(cs_22,ck_27,h_22) in
        {508}let v_160: bitstring = catch-fail(symmetricstateunpack(ss_25)) in
        {509}let v_161: bool = (not-caught-fail(v_160) && success?(1-proj-3-tuple(v_160))) in
        {510}let h_23: bitstring = (if v_161 then 3-proj-3-tuple(v_160) else caught-fail) in
        {511}let ck_28: key = (if v_161 then 2-proj-3-tuple(v_160) else caught-fail) in
        {512}let cs_23: cipherstate = (if v_161 then 1-proj-3-tuple(v_160) else caught-fail) in
        {513}let ss_26: symmetricstate = catch-fail((if v_161 then symmetricstatepack(cs_23,ck_28,hash(h_23,prologue_1)) else fail-any)) in
        {514}let v_162: bool = not-caught-fail(ss_26) in
        {515}let data_2: bitstring = (if v_162 then catch-fail(getpublickey(s_5)) else caught-fail) in
        {516}let v_163: bool = not-caught-fail(data_2) in
        {517}let v_164: bitstring = (if v_163 then catch-fail(symmetricstateunpack(ss_26)) else caught-fail) in
        {518}let v_165: bool = (not-caught-fail(v_164) && success?(1-proj-3-tuple(v_164))) in
        {519}let h_24: bitstring = (if v_165 then 3-proj-3-tuple(v_164) else caught-fail) in
        {520}let ck_29: key = (if v_165 then 2-proj-3-tuple(v_164) else caught-fail) in
        {521}let cs_24: cipherstate = (if v_165 then 1-proj-3-tuple(v_164) else caught-fail) in
        {522}let ss_27: symmetricstate = (if v_162 then catch-fail((if v_163 then (if v_165 then symmetricstatepack(cs_24,ck_29,hash(h_24,data_2)) else fail-any) else fail-any)) else caught-fail) in
        {523}let v_166: bool = not-caught-fail(ss_27) in
        {524}let data_3: bitstring = (if v_166 then catch-fail(getpublickey(m_5)) else caught-fail) in
        {525}let v_167: bool = not-caught-fail(data_3) in
        {526}let v_168: bitstring = (if v_167 then catch-fail(symmetricstateunpack(ss_27)) else caught-fail) in
        {527}let v_169: bool = (not-caught-fail(v_168) && success?(1-proj-3-tuple(v_168))) in
        {528}let h_25: bitstring = (if v_169 then 3-proj-3-tuple(v_168) else caught-fail) in
        {529}let ck_30: key = (if v_169 then 2-proj-3-tuple(v_168) else caught-fail) in
        {530}let cs_25: cipherstate = (if v_169 then 1-proj-3-tuple(v_168) else caught-fail) in
        {531}let ss_28: symmetricstate = (if v_166 then catch-fail((if v_167 then (if v_169 then symmetricstatepack(cs_25,ck_30,hash(h_25,data_3)) else fail-any) else fail-any)) else caught-fail) in
        {532}let v_170: bool = not-caught-fail(ss_28) in
        {533}let v_171: bitstring = (if v_170 then catch-fail(symmetricstateunpack(ss_28)) else caught-fail) in
        {534}let v_172: bool = (not-caught-fail(v_171) && success?(1-proj-3-tuple(v_171))) in
        {535}let h_26: bitstring = (if v_172 then 3-proj-3-tuple(v_171) else caught-fail) in
        {536}let ck_31: key = (if v_172 then 2-proj-3-tuple(v_171) else caught-fail) in
        {537}let cs_26: cipherstate = (if v_172 then 1-proj-3-tuple(v_171) else caught-fail) in
        {538}let ss_29: symmetricstate = (if v_170 then catch-fail((if v_172 then symmetricstatepack(cs_26,ck_31,hash(h_26,rs_5)) else fail-any)) else caught-fail) in
        {539}let v_173: bool = not-caught-fail(ss_29) in
        {540}let v_174: bitstring = (if v_173 then catch-fail(symmetricstateunpack(ss_29)) else caught-fail) in
        {541}let v_175: bool = (not-caught-fail(v_174) && success?(1-proj-3-tuple(v_174))) in
        {542}let h_27: bitstring = (if v_175 then 3-proj-3-tuple(v_174) else caught-fail) in
        {543}let ck_32: key = (if v_175 then 2-proj-3-tuple(v_174) else caught-fail) in
        {544}let cs_27: cipherstate = (if v_175 then 1-proj-3-tuple(v_174) else caught-fail) in
        {545}let ss_30: symmetricstate = (if v_173 then catch-fail((if v_175 then symmetricstatepack(cs_27,ck_32,hash(h_27,rm_5)) else fail-any)) else caught-fail) in
        {546}let v_176: bool = not-caught-fail(ss_30) in
        {547}let hs_15: handshakestate = (if v_162 then (if v_166 then (if v_170 then (if v_173 then (if v_176 then handshakestatepack(ss_30,s_5,m_5,e_8,rs_5,rm_5,re_6,psk_5,true) else fail-any) else fail-any) else fail-any) else fail-any) else fail-any) in
        {548}insert statestore(me_1,them_1,sid_2,statepack_a(hs_15))
    ) | (
        {661}get statestore(=me_1,=them_1,=sid_2,statepack_a(hs_16: handshakestate)) in
        {549}let payload_2: bitstring = msg_a(me_1,them_1,sid_2) in
        {550}let v_177: bitstring = catch-fail(handshakestateunpack(hs_16)) in
        {551}let v_178: bool = (not-caught-fail(v_177) && success?(1-proj-9-tuple(v_177))) in
        {552}let initiator_5: bool = (if v_178 then 9-proj-9-tuple(v_177) else caught-fail) in
        {553}let psk_6: key = (if v_178 then 8-proj-9-tuple(v_177) else caught-fail) in
        {554}let re_7: key = (if v_178 then 7-proj-9-tuple(v_177) else caught-fail) in
        {555}let rm_6: key = (if v_178 then 6-proj-9-tuple(v_177) else caught-fail) in
        {556}let rs_6: key = (if v_178 then 5-proj-9-tuple(v_177) else caught-fail) in
        {557}let e_9: keypair = (if v_178 then 4-proj-9-tuple(v_177) else caught-fail) in
        {558}let m_6: keypair = (if v_178 then 3-proj-9-tuple(v_177) else caught-fail) in
        {559}let s_6: keypair = (if v_178 then 2-proj-9-tuple(v_177) else caught-fail) in
        {560}let ss_31: symmetricstate = (if v_178 then 1-proj-9-tuple(v_177) else caught-fail) in
        {561}let v_179: bitstring = (if v_178 then catch-fail((empty,empty,empty)) else caught-fail) in
        {562}let v_180: bool = (not-caught-fail(v_179) && success?(1-proj-3-tuple(v_179))) in
        {563}let ciphertext_8: bitstring = (if v_180 then 3-proj-3-tuple(v_179) else caught-fail) in
        {564}let ns_4: bitstring = (if v_180 then 2-proj-3-tuple(v_179) else caught-fail) in
        {565}let ne_5: bitstring = (if v_180 then 1-proj-3-tuple(v_179) else caught-fail) in
        {566}let basis_9: key = (if v_180 then key_e(me_1,them_1,sid_2) else caught-fail) in
        {567}let public_key_9: key = (if v_180 then catch-fail(dhexp(basis_9,validkey(g))) else caught-fail) in
        {568}let v_181: bool = not-caught-fail(public_key_9) in
        {569}let e_10: keypair = (if v_180 then catch-fail((if v_181 then keypairpack(validkey(public_key_9),basis_9) else fail-any)) else caught-fail) in
        {570}let v_182: bool = not-caught-fail(e_10) in
        {571}let ne_6: bitstring = (if v_182 then catch-fail(getpublickey(e_10)) else caught-fail) in
        {572}let v_183: bool = not-caught-fail(ne_6) in
        {573}let v_184: bitstring = (if v_183 then catch-fail(symmetricstateunpack(ss_31)) else caught-fail) in
        {574}let v_185: bool = (not-caught-fail(v_184) && success?(1-proj-3-tuple(v_184))) in
        {575}let h_28: bitstring = (if v_185 then 3-proj-3-tuple(v_184) else caught-fail) in
        {576}let ck_33: key = (if v_185 then 2-proj-3-tuple(v_184) else caught-fail) in
        {577}let cs_28: cipherstate = (if v_185 then 1-proj-3-tuple(v_184) else caught-fail) in
        {578}let ss_32: symmetricstate = (if v_183 then catch-fail((if v_185 then symmetricstatepack(cs_28,ck_33,hash(h_28,ne_6)) else fail-any)) else caught-fail) in
        {579}let v_186: bool = not-caught-fail(ss_32) in
        {580}let v_187: bitstring = (if v_186 then catch-fail(keypairunpack(e_10)) else caught-fail) in
        {581}let v_188: bool = (not-caught-fail(v_187) && success?(1-proj-2-tuple(v_187))) in
        {582}let my_private_key_5: key = (if v_188 then 2-proj-2-tuple(v_187) else caught-fail) in
        {583}let my_public_key_5: key = (if v_188 then 1-proj-2-tuple(v_187) else caught-fail) in
        {584}let input_key_material_6: key = (if v_186 then catch-fail((if v_188 then dhexp(my_private_key_5,rm_6) else fail-any)) else caught-fail) in
        {585}let v_189: bool = not-caught-fail(input_key_material_6) in
        {586}let v_190: bitstring = (if v_189 then catch-fail(symmetricstateunpack(ss_32)) else caught-fail) in
        {587}let v_191: bool = (not-caught-fail(v_190) && success?(1-proj-3-tuple(v_190))) in
        {588}let h_29: bitstring = (if v_191 then 3-proj-3-tuple(v_190) else caught-fail) in
        {589}let ck_34: key = (if v_191 then 2-proj-3-tuple(v_190) else caught-fail) in
        {590}let cs_29: cipherstate = (if v_191 then 1-proj-3-tuple(v_190) else caught-fail) in
        {591}let output1_6: key = (if v_191 then hmac_hash1(ck_34,input_key_material_6) else caught-fail) in
        {592}let output2_6: key = (if v_191 then hmac_hash2(ck_34,input_key_material_6) else caught-fail) in
        {593}let output3_6: key = (if v_191 then hmac_hash3(ck_34,input_key_material_6) else caught-fail) in
        {594}let v_192: bitstring = (if v_191 then catch-fail((output1_6,output2_6,output3_6)) else caught-fail) in
        {595}let v_193: bool = (not-caught-fail(v_192) && success?(1-proj-3-tuple(v_192))) in
        {596}let output_5: key = (if v_193 then 3-proj-3-tuple(v_192) else caught-fail) in
        {597}let temp_k_5: key = (if v_193 then 2-proj-3-tuple(v_192) else caught-fail) in
        {598}let ck_35: key = (if v_193 then 1-proj-3-tuple(v_192) else caught-fail) in
        {599}let ss_33: symmetricstate = (if v_186 then catch-fail((if v_189 then (if v_191 then (if v_193 then symmetricstatepack(cipherstatepack(temp_k_5,minnonce),ck_35,h_29) else fail-any) else fail-any) else fail-any)) else caught-fail) in
        {600}let v_194: bool = not-caught-fail(ss_33) in
        {601}let v_195: bitstring = (if v_194 then catch-fail(keypairunpack(m_6)) else caught-fail) in
        {602}let v_196: bool = (not-caught-fail(v_195) && success?(1-proj-2-tuple(v_195))) in
        {603}let my_private_key_6: key = (if v_196 then 2-proj-2-tuple(v_195) else caught-fail) in
        {604}let my_public_key_6: key = (if v_196 then 1-proj-2-tuple(v_195) else caught-fail) in
        {605}let input_key_material_7: key = (if v_194 then catch-fail((if v_196 then dhexp(my_private_key_6,rs_6) else fail-any)) else caught-fail) in
        {606}let v_197: bool = not-caught-fail(input_key_material_7) in
        {607}let v_198: bitstring = (if v_197 then catch-fail(symmetricstateunpack(ss_33)) else caught-fail) in
        {608}let v_199: bool = (not-caught-fail(v_198) && success?(1-proj-3-tuple(v_198))) in
        {609}let h_30: bitstring = (if v_199 then 3-proj-3-tuple(v_198) else caught-fail) in
        {610}let ck_36: key = (if v_199 then 2-proj-3-tuple(v_198) else caught-fail) in
        {611}let cs_30: cipherstate = (if v_199 then 1-proj-3-tuple(v_198) else caught-fail) in
        {612}let output1_7: key = (if v_199 then hmac_hash1(ck_36,input_key_material_7) else caught-fail) in
        {613}let output2_7: key = (if v_199 then hmac_hash2(ck_36,input_key_material_7) else caught-fail) in
        {614}let output3_7: key = (if v_199 then hmac_hash3(ck_36,input_key_material_7) else caught-fail) in
        {615}let v_200: bitstring = (if v_199 then catch-fail((output1_7,output2_7,output3_7)) else caught-fail) in
        {616}let v_201: bool = (not-caught-fail(v_200) && success?(1-proj-3-tuple(v_200))) in
        {617}let output_6: key = (if v_201 then 3-proj-3-tuple(v_200) else caught-fail) in
        {618}let temp_k_6: key = (if v_201 then 2-proj-3-tuple(v_200) else caught-fail) in
        {619}let ck_37: key = (if v_201 then 1-proj-3-tuple(v_200) else caught-fail) in
        {620}let ss_34: symmetricstate = (if v_194 then catch-fail((if v_197 then (if v_199 then (if v_201 then symmetricstatepack(cipherstatepack(temp_k_6,minnonce),ck_37,h_30) else fail-any) else fail-any) else fail-any)) else caught-fail) in
        {621}let v_202: bool = not-caught-fail(ss_34) in
        {622}let v_203: bitstring = (if v_202 then catch-fail(symmetricstateunpack(ss_34)) else caught-fail) in
        {623}let v_204: bool = (not-caught-fail(v_203) && success?(1-proj-3-tuple(v_203))) in
        {624}let h_31: bitstring = (if v_204 then 3-proj-3-tuple(v_203) else caught-fail) in
        {625}let ck_38: key = (if v_204 then 2-proj-3-tuple(v_203) else caught-fail) in
        {626}let cs_31: cipherstate = (if v_204 then 1-proj-3-tuple(v_203) else caught-fail) in
        {627}let v_205: bitstring = (if v_204 then catch-fail(cipherstateunpack(cs_31)) else caught-fail) in
        {628}let v_206: bool = (not-caught-fail(v_205) && success?(1-proj-2-tuple(v_205))) in
        {629}let n_8: nonce = (if v_206 then 2-proj-2-tuple(v_205) else caught-fail) in
        {630}let k_10: key = (if v_206 then 1-proj-2-tuple(v_205) else caught-fail) in
        {631}let e_11: bitstring = (if v_206 then encrypt(k_10,n_8,h_31,payload_2) else caught-fail) in
        {632}let n_9: nonce = (if v_206 then increment_nonce(n_8) else caught-fail) in
        {633}let v_207: bitstring = (if v_206 then catch-fail(cipherstateunpack(cs_31)) else caught-fail) in
        {634}let v_208: bool = (not-caught-fail(v_207) && success?(1-proj-2-tuple(v_207))) in
        {635}let o_4: nonce = (if v_208 then 2-proj-2-tuple(v_207) else caught-fail) in
        {636}let k_11: key = (if v_208 then 1-proj-2-tuple(v_207) else caught-fail) in
        {637}let csi_8: cipherstate = (if v_206 then catch-fail((if v_208 then cipherstatepack(k_11,n_9) else fail-any)) else caught-fail) in
        {638}let v_209: bool = not-caught-fail(csi_8) in
        {639}let v_210: bitstring = (if v_204 then catch-fail((if v_206 then (if v_209 then (csi_8,e_11) else fail-any) else fail-any)) else caught-fail) in
        {640}let v_211: bool = (not-caught-fail(v_210) && success?(1-proj-2-tuple(v_210))) in
        {641}let ciphertext_9: bitstring = (if v_211 then 2-proj-2-tuple(v_210) else caught-fail) in
        {642}let csi_9: cipherstate = (if v_211 then 1-proj-2-tuple(v_210) else caught-fail) in
        {643}let ss_35: symmetricstate = (if v_211 then symmetricstatepack(csi_9,ck_38,h_31) else caught-fail) in
        {644}let v_212: bitstring = (if v_211 then catch-fail(symmetricstateunpack(ss_35)) else caught-fail) in
        {645}let v_213: bool = (not-caught-fail(v_212) && success?(1-proj-3-tuple(v_212))) in
        {646}let h_32: bitstring = (if v_213 then 3-proj-3-tuple(v_212) else caught-fail) in
        {647}let ck_39: key = (if v_213 then 2-proj-3-tuple(v_212) else caught-fail) in
        {648}let cs_32: cipherstate = (if v_213 then 1-proj-3-tuple(v_212) else caught-fail) in
        {649}let ssi_5: symmetricstate = (if v_211 then catch-fail((if v_213 then symmetricstatepack(cs_32,ck_39,hash(h_32,ciphertext_9)) else fail-any)) else caught-fail) in
        {650}let v_214: bool = not-caught-fail(ssi_5) in
        {651}let v_215: bitstring = (if v_202 then catch-fail((if v_204 then (if v_211 then (if v_214 then (ssi_5,ciphertext_9) else fail-any) else fail-any) else fail-any)) else caught-fail) in
        {652}let v_216: bool = (not-caught-fail(v_215) && success?(1-proj-2-tuple(v_215))) in
        {653}let ciphertext_10: bitstring = (if v_216 then 2-proj-2-tuple(v_215) else caught-fail) in
        {654}let ss_36: symmetricstate = (if v_216 then 1-proj-2-tuple(v_215) else caught-fail) in
        {655}let hs_17: handshakestate = (if v_216 then handshakestatepack(ss_36,s_6,m_6,e_10,rs_6,rm_6,re_7,psk_6,initiator_5) else caught-fail) in
        {656}let message_buffer_2: bitstring = (if v_216 then concat3(ne_6,ns_4,ciphertext_10) else caught-fail) in
        {657}let (hs_18: handshakestate,message_a_1: bitstring) = (if v_178 then (if v_180 then (if v_182 then (if v_183 then (if v_186 then (if v_194 then (if v_202 then (if v_216 then (hs_17,message_buffer_2) else fail-any) else fail-any) else fail-any) else fail-any) else fail-any) else fail-any) else fail-any) else fail-any) in
        {658}event SendMsg(me_1,them_1,stagepack_a(sid_2),msg_a(me_1,them_1,sid_2));
        {659}insert statestore(me_1,them_1,sid_2,statepack_b(hs_18));
        {660}out(pub, message_a_1)
    ) | (
        {818}get statestore(=me_1,=them_1,=sid_2,statepack_b(hs_19: handshakestate)) in
        {662}in(pub, message_b_1: bitstring);
        {663}let v_217: bitstring = catch-fail(handshakestateunpack(hs_19)) in
        {664}let v_218: bool = (not-caught-fail(v_217) && success?(1-proj-9-tuple(v_217))) in
        {665}let initiator_6: bool = (if v_218 then 9-proj-9-tuple(v_217) else caught-fail) in
        {666}let psk_7: key = (if v_218 then 8-proj-9-tuple(v_217) else caught-fail) in
        {667}let re_8: key = (if v_218 then 7-proj-9-tuple(v_217) else caught-fail) in
        {668}let rm_7: key = (if v_218 then 6-proj-9-tuple(v_217) else caught-fail) in
        {669}let rs_7: key = (if v_218 then 5-proj-9-tuple(v_217) else caught-fail) in
        {670}let e_12: keypair = (if v_218 then 4-proj-9-tuple(v_217) else caught-fail) in
        {671}let m_7: keypair = (if v_218 then 3-proj-9-tuple(v_217) else caught-fail) in
        {672}let s_7: keypair = (if v_218 then 2-proj-9-tuple(v_217) else caught-fail) in
        {673}let ss_37: symmetricstate = (if v_218 then 1-proj-9-tuple(v_217) else caught-fail) in
        {674}let v_219: bitstring = (if v_218 then catch-fail(deconcat3(message_b_1)) else caught-fail) in
        {675}let v_220: bool = (not-caught-fail(v_219) && success?(1-proj-3-tuple(v_219))) in
        {676}let ciphertext_11: bitstring = (if v_220 then 3-proj-3-tuple(v_219) else caught-fail) in
        {677}let ns_5: bitstring = (if v_220 then 2-proj-3-tuple(v_219) else caught-fail) in
        {678}let ne_7: bitstring = (if v_220 then 1-proj-3-tuple(v_219) else caught-fail) in
        {679}let valid1_2: bool = (if v_220 then true else caught-fail) in
        {680}let re_9: key = (if v_220 then ne_7 else caught-fail) in
        {681}let v_221: bitstring = (if v_220 then catch-fail(symmetricstateunpack(ss_37)) else caught-fail) in
        {682}let v_222: bool = (not-caught-fail(v_221) && success?(1-proj-3-tuple(v_221))) in
        {683}let h_33: bitstring = (if v_222 then 3-proj-3-tuple(v_221) else caught-fail) in
        {684}let ck_40: key = (if v_222 then 2-proj-3-tuple(v_221) else caught-fail) in
        {685}let cs_33: cipherstate = (if v_222 then 1-proj-3-tuple(v_221) else caught-fail) in
        {686}let ss_38: symmetricstate = (if v_220 then catch-fail((if v_222 then symmetricstatepack(cs_33,ck_40,hash(h_33,re_9)) else fail-any)) else caught-fail) in
        {687}let v_223: bool = not-caught-fail(ss_38) in
        {688}let v_224: bitstring = (if v_223 then catch-fail(keypairunpack(e_12)) else caught-fail) in
        {689}let v_225: bool = (not-caught-fail(v_224) && success?(1-proj-2-tuple(v_224))) in
        {690}let my_private_key_7: key = (if v_225 then 2-proj-2-tuple(v_224) else caught-fail) in
        {691}let my_public_key_7: key = (if v_225 then 1-proj-2-tuple(v_224) else caught-fail) in
        {692}let input_key_material_8: key = (if v_223 then catch-fail((if v_225 then dhexp(my_private_key_7,re_9) else fail-any)) else caught-fail) in
        {693}let v_226: bool = not-caught-fail(input_key_material_8) in
        {694}let v_227: bitstring = (if v_226 then catch-fail(symmetricstateunpack(ss_38)) else caught-fail) in
        {695}let v_228: bool = (not-caught-fail(v_227) && success?(1-proj-3-tuple(v_227))) in
        {696}let h_34: bitstring = (if v_228 then 3-proj-3-tuple(v_227) else caught-fail) in
        {697}let ck_41: key = (if v_228 then 2-proj-3-tuple(v_227) else caught-fail) in
        {698}let cs_34: cipherstate = (if v_228 then 1-proj-3-tuple(v_227) else caught-fail) in
        {699}let output1_8: key = (if v_228 then hmac_hash1(ck_41,input_key_material_8) else caught-fail) in
        {700}let output2_8: key = (if v_228 then hmac_hash2(ck_41,input_key_material_8) else caught-fail) in
        {701}let output3_8: key = (if v_228 then hmac_hash3(ck_41,input_key_material_8) else caught-fail) in
        {702}let v_229: bitstring = (if v_228 then catch-fail((output1_8,output2_8,output3_8)) else caught-fail) in
        {703}let v_230: bool = (not-caught-fail(v_229) && success?(1-proj-3-tuple(v_229))) in
        {704}let output_7: key = (if v_230 then 3-proj-3-tuple(v_229) else caught-fail) in
        {705}let temp_k_7: key = (if v_230 then 2-proj-3-tuple(v_229) else caught-fail) in
        {706}let ck_42: key = (if v_230 then 1-proj-3-tuple(v_229) else caught-fail) in
        {707}let ss_39: symmetricstate = (if v_223 then catch-fail((if v_226 then (if v_228 then (if v_230 then symmetricstatepack(cipherstatepack(temp_k_7,minnonce),ck_42,h_34) else fail-any) else fail-any) else fail-any)) else caught-fail) in
        {708}let v_231: bool = not-caught-fail(ss_39) in
        {709}let v_232: bitstring = (if v_231 then catch-fail(keypairunpack(s_7)) else caught-fail) in
        {710}let v_233: bool = (not-caught-fail(v_232) && success?(1-proj-2-tuple(v_232))) in
        {711}let my_private_key_8: key = (if v_233 then 2-proj-2-tuple(v_232) else caught-fail) in
        {712}let my_public_key_8: key = (if v_233 then 1-proj-2-tuple(v_232) else caught-fail) in
        {713}let input_key_material_9: key = (if v_231 then catch-fail((if v_233 then dhexp(my_private_key_8,re_9) else fail-any)) else caught-fail) in
        {714}let v_234: bool = not-caught-fail(input_key_material_9) in
        {715}let v_235: bitstring = (if v_234 then catch-fail(symmetricstateunpack(ss_39)) else caught-fail) in
        {716}let v_236: bool = (not-caught-fail(v_235) && success?(1-proj-3-tuple(v_235))) in
        {717}let h_35: bitstring = (if v_236 then 3-proj-3-tuple(v_235) else caught-fail) in
        {718}let ck_43: key = (if v_236 then 2-proj-3-tuple(v_235) else caught-fail) in
        {719}let cs_35: cipherstate = (if v_236 then 1-proj-3-tuple(v_235) else caught-fail) in
        {720}let output1_9: key = (if v_236 then hmac_hash1(ck_43,input_key_material_9) else caught-fail) in
        {721}let output2_9: key = (if v_236 then hmac_hash2(ck_43,input_key_material_9) else caught-fail) in
        {722}let output3_9: key = (if v_236 then hmac_hash3(ck_43,input_key_material_9) else caught-fail) in
        {723}let v_237: bitstring = (if v_236 then catch-fail((output1_9,output2_9,output3_9)) else caught-fail) in
        {724}let v_238: bool = (not-caught-fail(v_237) && success?(1-proj-3-tuple(v_237))) in
        {725}let output_8: key = (if v_238 then 3-proj-3-tuple(v_237) else caught-fail) in
        {726}let temp_k_8: key = (if v_238 then 2-proj-3-tuple(v_237) else caught-fail) in
        {727}let ck_44: key = (if v_238 then 1-proj-3-tuple(v_237) else caught-fail) in
        {728}let ss_40: symmetricstate = (if v_231 then catch-fail((if v_234 then (if v_236 then (if v_238 then symmetricstatepack(cipherstatepack(temp_k_8,minnonce),ck_44,h_35) else fail-any) else fail-any) else fail-any)) else caught-fail) in
        {729}let v_239: bool = not-caught-fail(ss_40) in
        {730}let v_240: bitstring = (if v_239 then catch-fail(keypairunpack(m_7)) else caught-fail) in
        {731}let v_241: bool = (not-caught-fail(v_240) && success?(1-proj-2-tuple(v_240))) in
        {732}let my_private_key_9: key = (if v_241 then 2-proj-2-tuple(v_240) else caught-fail) in
        {733}let my_public_key_9: key = (if v_241 then 1-proj-2-tuple(v_240) else caught-fail) in
        {734}let input_key_material_10: key = (if v_239 then catch-fail((if v_241 then dhexp(my_private_key_9,re_9) else fail-any)) else caught-fail) in
        {735}let v_242: bool = not-caught-fail(input_key_material_10) in
        {736}let v_243: bitstring = (if v_242 then catch-fail(symmetricstateunpack(ss_40)) else caught-fail) in
        {737}let v_244: bool = (not-caught-fail(v_243) && success?(1-proj-3-tuple(v_243))) in
        {738}let h_36: bitstring = (if v_244 then 3-proj-3-tuple(v_243) else caught-fail) in
        {739}let ck_45: key = (if v_244 then 2-proj-3-tuple(v_243) else caught-fail) in
        {740}let cs_36: cipherstate = (if v_244 then 1-proj-3-tuple(v_243) else caught-fail) in
        {741}let output1_10: key = (if v_244 then hmac_hash1(ck_45,input_key_material_10) else caught-fail) in
        {742}let output2_10: key = (if v_244 then hmac_hash2(ck_45,input_key_material_10) else caught-fail) in
        {743}let output3_10: key = (if v_244 then hmac_hash3(ck_45,input_key_material_10) else caught-fail) in
        {744}let v_245: bitstring = (if v_244 then catch-fail((output1_10,output2_10,output3_10)) else caught-fail) in
        {745}let v_246: bool = (not-caught-fail(v_245) && success?(1-proj-3-tuple(v_245))) in
        {746}let output_9: key = (if v_246 then 3-proj-3-tuple(v_245) else caught-fail) in
        {747}let temp_k_9: key = (if v_246 then 2-proj-3-tuple(v_245) else caught-fail) in
        {748}let ck_46: key = (if v_246 then 1-proj-3-tuple(v_245) else caught-fail) in
        {749}let ss_41: symmetricstate = (if v_239 then catch-fail((if v_242 then (if v_244 then (if v_246 then symmetricstatepack(cipherstatepack(temp_k_9,minnonce),ck_46,h_36) else fail-any) else fail-any) else fail-any)) else caught-fail) in
        {750}let v_247: bool = not-caught-fail(ss_41) in
        {751}let v_248: bitstring = (if v_247 then catch-fail(symmetricstateunpack(ss_41)) else caught-fail) in
        {752}let v_249: bool = (not-caught-fail(v_248) && success?(1-proj-3-tuple(v_248))) in
        {753}let h_37: bitstring = (if v_249 then 3-proj-3-tuple(v_248) else caught-fail) in
        {754}let ck_47: key = (if v_249 then 2-proj-3-tuple(v_248) else caught-fail) in
        {755}let cs_37: cipherstate = (if v_249 then 1-proj-3-tuple(v_248) else caught-fail) in
        {756}let v_250: bitstring = (if v_249 then catch-fail(cipherstateunpack(cs_37)) else caught-fail) in
        {757}let v_251: bool = (not-caught-fail(v_250) && success?(1-proj-2-tuple(v_250))) in
        {758}let n_10: nonce = (if v_251 then 2-proj-2-tuple(v_250) else caught-fail) in
        {759}let k_12: key = (if v_251 then 1-proj-2-tuple(v_250) else caught-fail) in
        {760}let d_2: aead = (if v_251 then catch-fail(decrypt(k_12,n_10,h_37,ciphertext_11)) else caught-fail) in
        {761}let v_252: bool = not-caught-fail(d_2) in
        {762}let v_253: bitstring = (if v_252 then catch-fail(aeadunpack(d_2)) else caught-fail) in
        {763}let v_254: bool = (not-caught-fail(v_253) && success?(1-proj-3-tuple(v_253))) in
        {764}let plaintext_6: bitstring = (if v_254 then 3-proj-3-tuple(v_253) else caught-fail) in
        {765}let adi_2: bitstring = (if v_254 then 2-proj-3-tuple(v_253) else caught-fail) in
        {766}let valid_6: bool = (if v_254 then 1-proj-3-tuple(v_253) else caught-fail) in
        {767}let n_11: nonce = (if v_254 then increment_nonce(n_10) else caught-fail) in
        {768}let v_255: bitstring = (if v_254 then catch-fail(cipherstateunpack(cs_37)) else caught-fail) in
        {769}let v_256: bool = (not-caught-fail(v_255) && success?(1-proj-2-tuple(v_255))) in
        {770}let o_5: nonce = (if v_256 then 2-proj-2-tuple(v_255) else caught-fail) in
        {771}let k_13: key = (if v_256 then 1-proj-2-tuple(v_255) else caught-fail) in
        {772}let csi_10: cipherstate = (if v_254 then catch-fail((if v_256 then cipherstatepack(k_13,n_11) else fail-any)) else caught-fail) in
        {773}let v_257: bool = not-caught-fail(csi_10) in
        {774}let v_258: bitstring = (if v_249 then catch-fail((if v_251 then (if v_252 then (if v_254 then (if v_257 then (csi_10,plaintext_6,valid_6) else fail-any) else fail-any) else fail-any) else fail-any)) else caught-fail) in
        {775}let v_259: bool = (not-caught-fail(v_258) && success?(1-proj-3-tuple(v_258))) in
        {776}let valid_7: bool = (if v_259 then 3-proj-3-tuple(v_258) else caught-fail) in
        {777}let plaintext_7: bitstring = (if v_259 then 2-proj-3-tuple(v_258) else caught-fail) in
        {778}let csi_11: cipherstate = (if v_259 then 1-proj-3-tuple(v_258) else caught-fail) in
        {779}let ss_42: symmetricstate = (if v_259 then symmetricstatepack(csi_11,ck_47,h_37) else caught-fail) in
        {780}let v_260: bitstring = (if v_259 then catch-fail(symmetricstateunpack(ss_42)) else caught-fail) in
        {781}let v_261: bool = (not-caught-fail(v_260) && success?(1-proj-3-tuple(v_260))) in
        {782}let h_38: bitstring = (if v_261 then 3-proj-3-tuple(v_260) else caught-fail) in
        {783}let ck_48: key = (if v_261 then 2-proj-3-tuple(v_260) else caught-fail) in
        {784}let cs_38: cipherstate = (if v_261 then 1-proj-3-tuple(v_260) else caught-fail) in
        {785}let ssi_6: symmetricstate = (if v_259 then catch-fail((if v_261 then symmetricstatepack(cs_38,ck_48,hash(h_38,ciphertext_11)) else fail-any)) else caught-fail) in
        {786}let v_262: bool = not-caught-fail(ssi_6) in
        {787}let v_263: bitstring = (if v_247 then catch-fail((if v_249 then (if v_259 then (if v_262 then (ssi_6,plaintext_7,valid_7) else fail-any) else fail-any) else fail-any)) else caught-fail) in
        {788}let v_264: bool = (not-caught-fail(v_263) && success?(1-proj-3-tuple(v_263))) in
        {789}let valid2_2: bool = (if v_264 then 3-proj-3-tuple(v_263) else caught-fail) in
        {790}let plaintext_8: bitstring = (if v_264 then 2-proj-3-tuple(v_263) else caught-fail) in
        {791}let ss_43: symmetricstate = (if v_264 then 1-proj-3-tuple(v_263) else caught-fail) in
        {792}let v_265: bool = (if v_264 then catch-fail((valid1_2 && valid2_2)) else caught-fail) in
        {793}let hs_20: handshakestate = (if v_265 then handshakestatepack(ss_43,s_7,m_7,e_12,rs_7,rm_7,re_9,psk_7,initiator_6) else caught-fail) in
        {794}let v_266: bitstring = (if v_265 then catch-fail(symmetricstateunpack(ss_43)) else caught-fail) in
        {795}let v_267: bool = (not-caught-fail(v_266) && success?(1-proj-3-tuple(v_266))) in
        {796}let h_39: bitstring = (if v_267 then 3-proj-3-tuple(v_266) else caught-fail) in
        {797}let ck_49: key = (if v_267 then 2-proj-3-tuple(v_266) else caught-fail) in
        {798}let cs_39: cipherstate = (if v_267 then 1-proj-3-tuple(v_266) else caught-fail) in
        {799}let input_key_material_11: key = (if v_267 then zero else caught-fail) in
        {800}let output1_11: key = (if v_267 then hmac_hash1(ck_49,input_key_material_11) else caught-fail) in
        {801}let output2_11: key = (if v_267 then hmac_hash2(ck_49,input_key_material_11) else caught-fail) in
        {802}let output3_11: key = (if v_267 then hmac_hash3(ck_49,input_key_material_11) else caught-fail) in
        {803}let v_268: bitstring = (if v_267 then catch-fail((output1_11,output2_11,output3_11)) else caught-fail) in
        {804}let v_269: bool = (not-caught-fail(v_268) && success?(1-proj-3-tuple(v_268))) in
        {805}let temp_k3_1: key = (if v_269 then 3-proj-3-tuple(v_268) else caught-fail) in
        {806}let temp_k2_1: key = (if v_269 then 2-proj-3-tuple(v_268) else caught-fail) in
        {807}let temp_k1_1: key = (if v_269 then 1-proj-3-tuple(v_268) else caught-fail) in
        {808}let cs1_5: cipherstate = (if v_269 then cipherstatepack(temp_k1_1,minnonce) else caught-fail) in
        {809}let cs2_5: cipherstate = (if v_269 then cipherstatepack(temp_k2_1,minnonce) else caught-fail) in
        {810}let v_270: bitstring = (if v_265 then catch-fail((if v_267 then (if v_269 then (ss_43,cs1_5,cs2_5) else fail-any) else fail-any)) else caught-fail) in
        {811}let v_271: bool = (not-caught-fail(v_270) && success?(1-proj-3-tuple(v_270))) in
        {812}let cs2_6: cipherstate = (if v_271 then 3-proj-3-tuple(v_270) else caught-fail) in
        {813}let cs1_6: cipherstate = (if v_271 then 2-proj-3-tuple(v_270) else caught-fail) in
        {814}let ssi_7: symmetricstate = (if v_271 then 1-proj-3-tuple(v_270) else caught-fail) in
        {815}let (hs_21: handshakestate,plaintext_b_1: bitstring,valid_8: bool,cs1_7: cipherstate,cs2_7: cipherstate) = (if v_218 then (if v_220 then (if v_223 then (if v_231 then (if v_239 then (if v_247 then (if v_264 then (if undo-catch-fail(v_265) then (if v_271 then (hs_20,plaintext_8,true,cs1_6,cs2_6) else fail-any) else fail-any) else fail-any) else fail-any) else fail-any) else fail-any) else fail-any) else fail-any) else fail-any) in
        {816}event RecvMsg(me_1,them_1,stagepack_b(sid_2),plaintext_b_1);
        {817}insert statestore(me_1,them_1,sid_2,statepack_c(hs_21,cs1_7,cs2_7))
    ) | (
        {819}!
        {877}get statestore(=me_1,=them_1,=sid_2,statepack_c(hs_22: handshakestate,cs1_8: cipherstate,cs2_8: cipherstate)) in
        {820}let hs_23: handshakestate = handshakestatesetcs(hs_22,cs1_8) in
        {821}let payload_3: bitstring = msg_c(me_1,them_1,sid_2) in
        {822}let v_272: bitstring = catch-fail(handshakestateunpack(hs_23)) in
        {823}let v_273: bool = (not-caught-fail(v_272) && success?(1-proj-9-tuple(v_272))) in
        {824}let initiator_7: bool = (if v_273 then 9-proj-9-tuple(v_272) else caught-fail) in
        {825}let psk_8: key = (if v_273 then 8-proj-9-tuple(v_272) else caught-fail) in
        {826}let re_10: key = (if v_273 then 7-proj-9-tuple(v_272) else caught-fail) in
        {827}let rm_8: key = (if v_273 then 6-proj-9-tuple(v_272) else caught-fail) in
        {828}let rs_8: key = (if v_273 then 5-proj-9-tuple(v_272) else caught-fail) in
        {829}let e_13: keypair = (if v_273 then 4-proj-9-tuple(v_272) else caught-fail) in
        {830}let m_8: keypair = (if v_273 then 3-proj-9-tuple(v_272) else caught-fail) in
        {831}let s_8: keypair = (if v_273 then 2-proj-9-tuple(v_272) else caught-fail) in
        {832}let ss_44: symmetricstate = (if v_273 then 1-proj-9-tuple(v_272) else caught-fail) in
        {833}let v_274: bitstring = (if v_273 then catch-fail((empty,empty,empty)) else caught-fail) in
        {834}let v_275: bool = (not-caught-fail(v_274) && success?(1-proj-3-tuple(v_274))) in
        {835}let ciphertext_12: bitstring = (if v_275 then 3-proj-3-tuple(v_274) else caught-fail) in
        {836}let ns_6: bitstring = (if v_275 then 2-proj-3-tuple(v_274) else caught-fail) in
        {837}let ne_8: bitstring = (if v_275 then 1-proj-3-tuple(v_274) else caught-fail) in
        {838}let v_276: bitstring = (if v_275 then catch-fail(symmetricstateunpack(ss_44)) else caught-fail) in
        {839}let v_277: bool = (not-caught-fail(v_276) && success?(1-proj-3-tuple(v_276))) in
        {840}let h_40: bitstring = (if v_277 then 3-proj-3-tuple(v_276) else caught-fail) in
        {841}let ck_50: key = (if v_277 then 2-proj-3-tuple(v_276) else caught-fail) in
        {842}let cs_40: cipherstate = (if v_277 then 1-proj-3-tuple(v_276) else caught-fail) in
        {843}let v_278: bitstring = (if v_277 then catch-fail(cipherstateunpack(cs_40)) else caught-fail) in
        {844}let v_279: bool = (not-caught-fail(v_278) && success?(1-proj-2-tuple(v_278))) in
        {845}let n_12: nonce = (if v_279 then 2-proj-2-tuple(v_278) else caught-fail) in
        {846}let k_14: key = (if v_279 then 1-proj-2-tuple(v_278) else caught-fail) in
        {847}let e_14: bitstring = (if v_279 then encrypt(k_14,n_12,h_40,payload_3) else caught-fail) in
        {848}let n_13: nonce = (if v_279 then increment_nonce(n_12) else caught-fail) in
        {849}let v_280: bitstring = (if v_279 then catch-fail(cipherstateunpack(cs_40)) else caught-fail) in
        {850}let v_281: bool = (not-caught-fail(v_280) && success?(1-proj-2-tuple(v_280))) in
        {851}let o_6: nonce = (if v_281 then 2-proj-2-tuple(v_280) else caught-fail) in
        {852}let k_15: key = (if v_281 then 1-proj-2-tuple(v_280) else caught-fail) in
        {853}let csi_12: cipherstate = (if v_279 then catch-fail((if v_281 then cipherstatepack(k_15,n_13) else fail-any)) else caught-fail) in
        {854}let v_282: bool = not-caught-fail(csi_12) in
        {855}let v_283: bitstring = (if v_277 then catch-fail((if v_279 then (if v_282 then (csi_12,e_14) else fail-any) else fail-any)) else caught-fail) in
        {856}let v_284: bool = (not-caught-fail(v_283) && success?(1-proj-2-tuple(v_283))) in
        {857}let ciphertext_13: bitstring = (if v_284 then 2-proj-2-tuple(v_283) else caught-fail) in
        {858}let csi_13: cipherstate = (if v_284 then 1-proj-2-tuple(v_283) else caught-fail) in
        {859}let ss_45: symmetricstate = (if v_284 then symmetricstatepack(csi_13,ck_50,h_40) else caught-fail) in
        {860}let v_285: bitstring = (if v_284 then catch-fail(symmetricstateunpack(ss_45)) else caught-fail) in
        {861}let v_286: bool = (not-caught-fail(v_285) && success?(1-proj-3-tuple(v_285))) in
        {862}let h_41: bitstring = (if v_286 then 3-proj-3-tuple(v_285) else caught-fail) in
        {863}let ck_51: key = (if v_286 then 2-proj-3-tuple(v_285) else caught-fail) in
        {864}let cs_41: cipherstate = (if v_286 then 1-proj-3-tuple(v_285) else caught-fail) in
        {865}let ssi_8: symmetricstate = (if v_284 then catch-fail((if v_286 then symmetricstatepack(cs_41,ck_51,hash(h_41,ciphertext_13)) else fail-any)) else caught-fail) in
        {866}let v_287: bool = not-caught-fail(ssi_8) in
        {867}let v_288: bitstring = (if v_275 then catch-fail((if v_277 then (if v_284 then (if v_287 then (ssi_8,ciphertext_13) else fail-any) else fail-any) else fail-any)) else caught-fail) in
        {868}let v_289: bool = (not-caught-fail(v_288) && success?(1-proj-2-tuple(v_288))) in
        {869}let ciphertext_14: bitstring = (if v_289 then 2-proj-2-tuple(v_288) else caught-fail) in
        {870}let ss_46: symmetricstate = (if v_289 then 1-proj-2-tuple(v_288) else caught-fail) in
        {871}let hs_24: handshakestate = (if v_289 then handshakestatepack(ss_46,s_8,m_8,e_13,rs_8,rm_8,re_10,psk_8,initiator_7) else caught-fail) in
        {872}let message_buffer_3: bitstring = (if v_289 then concat3(ne_8,ns_6,ciphertext_14) else caught-fail) in
        {873}let (hs_25: handshakestate,message_c_1: bitstring) = (if v_273 then (if v_275 then (if v_289 then (hs_24,message_buffer_3) else fail-any) else fail-any) else fail-any) in
        {874}event SendMsg(me_1,them_1,stagepack_c(sid_2),msg_c(me_1,them_1,sid_2));
        {875}insert statestore(me_1,them_1,sid_2,statepack_d(hs_25,handshakestategetcs(hs_25),cs2_8));
        {876}out(pub, message_c_1)
    ) | (
        {878}!
        {944}get statestore(=me_1,=them_1,=sid_2,statepack_d(hs_26: handshakestate,cs1_9: cipherstate,cs2_9: cipherstate)) in
        {879}let hs_27: handshakestate = handshakestatesetcs(hs_26,cs2_9) in
        {880}in(pub, message_d_1: bitstring);
        {881}let v_290: bitstring = catch-fail(handshakestateunpack(hs_27)) in
        {882}let v_291: bool = (not-caught-fail(v_290) && success?(1-proj-9-tuple(v_290))) in
        {883}let initiator_8: bool = (if v_291 then 9-proj-9-tuple(v_290) else caught-fail) in
        {884}let psk_9: key = (if v_291 then 8-proj-9-tuple(v_290) else caught-fail) in
        {885}let re_11: key = (if v_291 then 7-proj-9-tuple(v_290) else caught-fail) in
        {886}let rm_9: key = (if v_291 then 6-proj-9-tuple(v_290) else caught-fail) in
        {887}let rs_9: key = (if v_291 then 5-proj-9-tuple(v_290) else caught-fail) in
        {888}let e_15: keypair = (if v_291 then 4-proj-9-tuple(v_290) else caught-fail) in
        {889}let m_9: keypair = (if v_291 then 3-proj-9-tuple(v_290) else caught-fail) in
        {890}let s_9: keypair = (if v_291 then 2-proj-9-tuple(v_290) else caught-fail) in
        {891}let ss_47: symmetricstate = (if v_291 then 1-proj-9-tuple(v_290) else caught-fail) in
        {892}let v_292: bitstring = (if v_291 then catch-fail(deconcat3(message_d_1)) else caught-fail) in
        {893}let v_293: bool = (not-caught-fail(v_292) && success?(1-proj-3-tuple(v_292))) in
        {894}let ciphertext_15: bitstring = (if v_293 then 3-proj-3-tuple(v_292) else caught-fail) in
        {895}let ns_7: bitstring = (if v_293 then 2-proj-3-tuple(v_292) else caught-fail) in
        {896}let ne_9: bitstring = (if v_293 then 1-proj-3-tuple(v_292) else caught-fail) in
        {897}let valid1_3: bool = (if v_293 then true else caught-fail) in
        {898}let v_294: bitstring = (if v_293 then catch-fail(symmetricstateunpack(ss_47)) else caught-fail) in
        {899}let v_295: bool = (not-caught-fail(v_294) && success?(1-proj-3-tuple(v_294))) in
        {900}let h_42: bitstring = (if v_295 then 3-proj-3-tuple(v_294) else caught-fail) in
        {901}let ck_52: key = (if v_295 then 2-proj-3-tuple(v_294) else caught-fail) in
        {902}let cs_42: cipherstate = (if v_295 then 1-proj-3-tuple(v_294) else caught-fail) in
        {903}let v_296: bitstring = (if v_295 then catch-fail(cipherstateunpack(cs_42)) else caught-fail) in
        {904}let v_297: bool = (not-caught-fail(v_296) && success?(1-proj-2-tuple(v_296))) in
        {905}let n_14: nonce = (if v_297 then 2-proj-2-tuple(v_296) else caught-fail) in
        {906}let k_16: key = (if v_297 then 1-proj-2-tuple(v_296) else caught-fail) in
        {907}let d_3: aead = (if v_297 then catch-fail(decrypt(k_16,n_14,h_42,ciphertext_15)) else caught-fail) in
        {908}let v_298: bool = not-caught-fail(d_3) in
        {909}let v_299: bitstring = (if v_298 then catch-fail(aeadunpack(d_3)) else caught-fail) in
        {910}let v_300: bool = (not-caught-fail(v_299) && success?(1-proj-3-tuple(v_299))) in
        {911}let plaintext_9: bitstring = (if v_300 then 3-proj-3-tuple(v_299) else caught-fail) in
        {912}let adi_3: bitstring = (if v_300 then 2-proj-3-tuple(v_299) else caught-fail) in
        {913}let valid_9: bool = (if v_300 then 1-proj-3-tuple(v_299) else caught-fail) in
        {914}let n_15: nonce = (if v_300 then increment_nonce(n_14) else caught-fail) in
        {915}let v_301: bitstring = (if v_300 then catch-fail(cipherstateunpack(cs_42)) else caught-fail) in
        {916}let v_302: bool = (not-caught-fail(v_301) && success?(1-proj-2-tuple(v_301))) in
        {917}let o_7: nonce = (if v_302 then 2-proj-2-tuple(v_301) else caught-fail) in
        {918}let k_17: key = (if v_302 then 1-proj-2-tuple(v_301) else caught-fail) in
        {919}let csi_14: cipherstate = (if v_300 then catch-fail((if v_302 then cipherstatepack(k_17,n_15) else fail-any)) else caught-fail) in
        {920}let v_303: bool = not-caught-fail(csi_14) in
        {921}let v_304: bitstring = (if v_295 then catch-fail((if v_297 then (if v_298 then (if v_300 then (if v_303 then (csi_14,plaintext_9,valid_9) else fail-any) else fail-any) else fail-any) else fail-any)) else caught-fail) in
        {922}let v_305: bool = (not-caught-fail(v_304) && success?(1-proj-3-tuple(v_304))) in
        {923}let valid_10: bool = (if v_305 then 3-proj-3-tuple(v_304) else caught-fail) in
        {924}let plaintext_10: bitstring = (if v_305 then 2-proj-3-tuple(v_304) else caught-fail) in
        {925}let csi_15: cipherstate = (if v_305 then 1-proj-3-tuple(v_304) else caught-fail) in
        {926}let ss_48: symmetricstate = (if v_305 then symmetricstatepack(csi_15,ck_52,h_42) else caught-fail) in
        {927}let v_306: bitstring = (if v_305 then catch-fail(symmetricstateunpack(ss_48)) else caught-fail) in
        {928}let v_307: bool = (not-caught-fail(v_306) && success?(1-proj-3-tuple(v_306))) in
        {929}let h_43: bitstring = (if v_307 then 3-proj-3-tuple(v_306) else caught-fail) in
        {930}let ck_53: key = (if v_307 then 2-proj-3-tuple(v_306) else caught-fail) in
        {931}let cs_43: cipherstate = (if v_307 then 1-proj-3-tuple(v_306) else caught-fail) in
        {932}let ssi_9: symmetricstate = (if v_305 then catch-fail((if v_307 then symmetricstatepack(cs_43,ck_53,hash(h_43,ciphertext_15)) else fail-any)) else caught-fail) in
        {933}let v_308: bool = not-caught-fail(ssi_9) in
        {934}let v_309: bitstring = (if v_293 then catch-fail((if v_295 then (if v_305 then (if v_308 then (ssi_9,plaintext_10,valid_10) else fail-any) else fail-any) else fail-any)) else caught-fail) in
        {935}let v_310: bool = (not-caught-fail(v_309) && success?(1-proj-3-tuple(v_309))) in
        {936}let valid2_3: bool = (if v_310 then 3-proj-3-tuple(v_309) else caught-fail) in
        {937}let plaintext_11: bitstring = (if v_310 then 2-proj-3-tuple(v_309) else caught-fail) in
        {938}let ss_49: symmetricstate = (if v_310 then 1-proj-3-tuple(v_309) else caught-fail) in
        {939}let v_311: bool = (if v_310 then catch-fail((valid1_3 && valid2_3)) else caught-fail) in
        {940}let hs_28: handshakestate = (if v_311 then handshakestatepack(ss_49,s_9,m_9,e_15,rs_9,rm_9,re_11,psk_9,initiator_8) else caught-fail) in
        {941}let (hs_29: handshakestate,plaintext_d_1: bitstring,valid_11: bool) = (if v_291 then (if v_293 then (if v_310 then (if undo-catch-fail(v_311) then (hs_28,plaintext_11,true) else fail-any) else fail-any) else fail-any) else fail-any) in
        {942}event RecvMsg(me_1,them_1,stagepack_d(sid_2),plaintext_d_1);
        {943}event RecvEnd(valid_11)
    ) | (
        {945}event LeakS(phase0,me_1);
        {946}event LeakM(phase0,me_1);
        {947}out(pub, (key_s(me_1),key_m(me_1)))
    ) | (
        {948}phase 1;
        {949}event LeakS(phase1,me_1);
        {950}event LeakM(phase1,me_1);
        {951}out(pub, (key_s(me_1),key_m(me_1)))
    )
) | (
    {952}let me_2: principal = bob in
    {953}let them_2: principal = alice in
    {954}let sid_3: sessionid = sid in
    {955}let basis_10: key = key_s(me_2) in
    {956}let public_key_10: key = catch-fail(dhexp(basis_10,validkey(g))) in
    {957}let v_312: bool = not-caught-fail(public_key_10) in
    {958}let s_10: keypair = (if v_312 then keypairpack(validkey(public_key_10),basis_10) else fail-any) in
    {959}let basis_11: key = key_m(me_2) in
    {960}let public_key_11: key = catch-fail(dhexp(basis_11,validkey(g))) in
    {961}let v_313: bool = not-caught-fail(public_key_11) in
    {962}let m_10: keypair = (if v_313 then keypairpack(validkey(public_key_11),basis_11) else fail-any) in
    {963}out(pub, (getpublickey(s_10),getpublickey(m_10)));
    (
        {964}let e_16: keypair = keypairpack(empty,empty) in
        {965}let basis_12: key = key_s(them_2) in
        {966}let public_key_12: key = catch-fail(dhexp(basis_12,validkey(g))) in
        {967}let v_314: bool = not-caught-fail(public_key_12) in
        {968}let rs_10: key = getpublickey((if v_314 then keypairpack(validkey(public_key_12),basis_12) else fail-any)) in
        {969}let basis_13: key = key_m(them_2) in
        {970}let public_key_13: key = catch-fail(dhexp(basis_13,validkey(g))) in
        {971}let v_315: bool = not-caught-fail(public_key_13) in
        {972}let rm_10: key = getpublickey((if v_315 then keypairpack(validkey(public_key_13),basis_13) else fail-any)) in
        {973}let re_12: key = empty in
        {974}let prologue_2: bitstring = empty in
        {975}let psk_10: key = empty in
        {976}let protocol_name_2: bitstring = somename in
        {977}let h_44: bitstring = hash(protocol_name_2,empty) in
        {978}let ck_54: key = h_44 in
        {979}let k_18: key = empty in
        {980}let cs_44: cipherstate = cipherstatepack(k_18,minnonce) in
        {981}let ss_50: symmetricstate = symmetricstatepack(cs_44,ck_54,h_44) in
        {982}let v_316: bitstring = catch-fail(symmetricstateunpack(ss_50)) in
        {983}let v_317: bool = (not-caught-fail(v_316) && success?(1-proj-3-tuple(v_316))) in
        {984}let h_45: bitstring = (if v_317 then 3-proj-3-tuple(v_316) else caught-fail) in
        {985}let ck_55: key = (if v_317 then 2-proj-3-tuple(v_316) else caught-fail) in
        {986}let cs_45: cipherstate = (if v_317 then 1-proj-3-tuple(v_316) else caught-fail) in
        {987}let ss_51: symmetricstate = catch-fail((if v_317 then symmetricstatepack(cs_45,ck_55,hash(h_45,prologue_2)) else fail-any)) in
        {988}let v_318: bool = not-caught-fail(ss_51) in
        {989}let v_319: bitstring = (if v_318 then catch-fail(symmetricstateunpack(ss_51)) else caught-fail) in
        {990}let v_320: bool = (not-caught-fail(v_319) && success?(1-proj-3-tuple(v_319))) in
        {991}let h_46: bitstring = (if v_320 then 3-proj-3-tuple(v_319) else caught-fail) in
        {992}let ck_56: key = (if v_320 then 2-proj-3-tuple(v_319) else caught-fail) in
        {993}let cs_46: cipherstate = (if v_320 then 1-proj-3-tuple(v_319) else caught-fail) in
        {994}let ss_52: symmetricstate = (if v_318 then catch-fail((if v_320 then symmetricstatepack(cs_46,ck_56,hash(h_46,rs_10)) else fail-any)) else caught-fail) in
        {995}let v_321: bool = not-caught-fail(ss_52) in
        {996}let v_322: bitstring = (if v_321 then catch-fail(symmetricstateunpack(ss_52)) else caught-fail) in
        {997}let v_323: bool = (not-caught-fail(v_322) && success?(1-proj-3-tuple(v_322))) in
        {998}let h_47: bitstring = (if v_323 then 3-proj-3-tuple(v_322) else caught-fail) in
        {999}let ck_57: key = (if v_323 then 2-proj-3-tuple(v_322) else caught-fail) in
        {1000}let cs_47: cipherstate = (if v_323 then 1-proj-3-tuple(v_322) else caught-fail) in
        {1001}let ss_53: symmetricstate = (if v_321 then catch-fail((if v_323 then symmetricstatepack(cs_47,ck_57,hash(h_47,rm_10)) else fail-any)) else caught-fail) in
        {1002}let v_324: bool = not-caught-fail(ss_53) in
        {1003}let data_4: bitstring = (if v_324 then catch-fail(getpublickey(s_10)) else caught-fail) in
        {1004}let v_325: bool = not-caught-fail(data_4) in
        {1005}let v_326: bitstring = (if v_325 then catch-fail(symmetricstateunpack(ss_53)) else caught-fail) in
        {1006}let v_327: bool = (not-caught-fail(v_326) && success?(1-proj-3-tuple(v_326))) in
        {1007}let h_48: bitstring = (if v_327 then 3-proj-3-tuple(v_326) else caught-fail) in
        {1008}let ck_58: key = (if v_327 then 2-proj-3-tuple(v_326) else caught-fail) in
        {1009}let cs_48: cipherstate = (if v_327 then 1-proj-3-tuple(v_326) else caught-fail) in
        {1010}let ss_54: symmetricstate = (if v_324 then catch-fail((if v_325 then (if v_327 then symmetricstatepack(cs_48,ck_58,hash(h_48,data_4)) else fail-any) else fail-any)) else caught-fail) in
        {1011}let v_328: bool = not-caught-fail(ss_54) in
        {1012}let data_5: bitstring = (if v_328 then catch-fail(getpublickey(m_10)) else caught-fail) in
        {1013}let v_329: bool = not-caught-fail(data_5) in
        {1014}let v_330: bitstring = (if v_329 then catch-fail(symmetricstateunpack(ss_54)) else caught-fail) in
        {1015}let v_331: bool = (not-caught-fail(v_330) && success?(1-proj-3-tuple(v_330))) in
        {1016}let h_49: bitstring = (if v_331 then 3-proj-3-tuple(v_330) else caught-fail) in
        {1017}let ck_59: key = (if v_331 then 2-proj-3-tuple(v_330) else caught-fail) in
        {1018}let cs_49: cipherstate = (if v_331 then 1-proj-3-tuple(v_330) else caught-fail) in
        {1019}let ss_55: symmetricstate = (if v_328 then catch-fail((if v_329 then (if v_331 then symmetricstatepack(cs_49,ck_59,hash(h_49,data_5)) else fail-any) else fail-any)) else caught-fail) in
        {1020}let v_332: bool = not-caught-fail(ss_55) in
        {1021}let hs_30: handshakestate = (if v_318 then (if v_321 then (if v_324 then (if v_328 then (if v_332 then handshakestatepack(ss_55,s_10,m_10,e_16,rs_10,rm_10,re_12,psk_10,false) else fail-any) else fail-any) else fail-any) else fail-any) else fail-any) in
        {1022}insert statestore(me_2,them_2,sid_3,statepack_a(hs_30))
    ) | (
        {1137}get statestore(=me_2,=them_2,=sid_3,statepack_a(hs_31: handshakestate)) in
        {1023}in(pub, message_a_2: bitstring);
        {1024}let v_333: bitstring = catch-fail(handshakestateunpack(hs_31)) in
        {1025}let v_334: bool = (not-caught-fail(v_333) && success?(1-proj-9-tuple(v_333))) in
        {1026}let initiator_9: bool = (if v_334 then 9-proj-9-tuple(v_333) else caught-fail) in
        {1027}let psk_11: key = (if v_334 then 8-proj-9-tuple(v_333) else caught-fail) in
        {1028}let re_13: key = (if v_334 then 7-proj-9-tuple(v_333) else caught-fail) in
        {1029}let rm_11: key = (if v_334 then 6-proj-9-tuple(v_333) else caught-fail) in
        {1030}let rs_11: key = (if v_334 then 5-proj-9-tuple(v_333) else caught-fail) in
        {1031}let e_17: keypair = (if v_334 then 4-proj-9-tuple(v_333) else caught-fail) in
        {1032}let m_11: keypair = (if v_334 then 3-proj-9-tuple(v_333) else caught-fail) in
        {1033}let s_11: keypair = (if v_334 then 2-proj-9-tuple(v_333) else caught-fail) in
        {1034}let ss_56: symmetricstate = (if v_334 then 1-proj-9-tuple(v_333) else caught-fail) in
        {1035}let v_335: bitstring = (if v_334 then catch-fail(deconcat3(message_a_2)) else caught-fail) in
        {1036}let v_336: bool = (not-caught-fail(v_335) && success?(1-proj-3-tuple(v_335))) in
        {1037}let ciphertext_16: bitstring = (if v_336 then 3-proj-3-tuple(v_335) else caught-fail) in
        {1038}let ns_8: bitstring = (if v_336 then 2-proj-3-tuple(v_335) else caught-fail) in
        {1039}let ne_10: bitstring = (if v_336 then 1-proj-3-tuple(v_335) else caught-fail) in
        {1040}let valid1_4: bool = (if v_336 then true else caught-fail) in
        {1041}let re_14: key = (if v_336 then ne_10 else caught-fail) in
        {1042}let v_337: bitstring = (if v_336 then catch-fail(symmetricstateunpack(ss_56)) else caught-fail) in
        {1043}let v_338: bool = (not-caught-fail(v_337) && success?(1-proj-3-tuple(v_337))) in
        {1044}let h_50: bitstring = (if v_338 then 3-proj-3-tuple(v_337) else caught-fail) in
        {1045}let ck_60: key = (if v_338 then 2-proj-3-tuple(v_337) else caught-fail) in
        {1046}let cs_50: cipherstate = (if v_338 then 1-proj-3-tuple(v_337) else caught-fail) in
        {1047}let ss_57: symmetricstate = (if v_336 then catch-fail((if v_338 then symmetricstatepack(cs_50,ck_60,hash(h_50,re_14)) else fail-any)) else caught-fail) in
        {1048}let v_339: bool = not-caught-fail(ss_57) in
        {1049}let v_340: bitstring = (if v_339 then catch-fail(keypairunpack(m_11)) else caught-fail) in
        {1050}let v_341: bool = (not-caught-fail(v_340) && success?(1-proj-2-tuple(v_340))) in
        {1051}let my_private_key_10: key = (if v_341 then 2-proj-2-tuple(v_340) else caught-fail) in
        {1052}let my_public_key_10: key = (if v_341 then 1-proj-2-tuple(v_340) else caught-fail) in
        {1053}let input_key_material_12: key = (if v_339 then catch-fail((if v_341 then dhexp(my_private_key_10,re_14) else fail-any)) else caught-fail) in
        {1054}let v_342: bool = not-caught-fail(input_key_material_12) in
        {1055}let v_343: bitstring = (if v_342 then catch-fail(symmetricstateunpack(ss_57)) else caught-fail) in
        {1056}let v_344: bool = (not-caught-fail(v_343) && success?(1-proj-3-tuple(v_343))) in
        {1057}let h_51: bitstring = (if v_344 then 3-proj-3-tuple(v_343) else caught-fail) in
        {1058}let ck_61: key = (if v_344 then 2-proj-3-tuple(v_343) else caught-fail) in
        {1059}let cs_51: cipherstate = (if v_344 then 1-proj-3-tuple(v_343) else caught-fail) in
        {1060}let output1_12: key = (if v_344 then hmac_hash1(ck_61,input_key_material_12) else caught-fail) in
        {1061}let output2_12: key = (if v_344 then hmac_hash2(ck_61,input_key_material_12) else caught-fail) in
        {1062}let output3_12: key = (if v_344 then hmac_hash3(ck_61,input_key_material_12) else caught-fail) in
        {1063}let v_345: bitstring = (if v_344 then catch-fail((output1_12,output2_12,output3_12)) else caught-fail) in
        {1064}let v_346: bool = (not-caught-fail(v_345) && success?(1-proj-3-tuple(v_345))) in
        {1065}let output_10: key = (if v_346 then 3-proj-3-tuple(v_345) else caught-fail) in
        {1066}let temp_k_10: key = (if v_346 then 2-proj-3-tuple(v_345) else caught-fail) in
        {1067}let ck_62: key = (if v_346 then 1-proj-3-tuple(v_345) else caught-fail) in
        {1068}let ss_58: symmetricstate = (if v_339 then catch-fail((if v_342 then (if v_344 then (if v_346 then symmetricstatepack(cipherstatepack(temp_k_10,minnonce),ck_62,h_51) else fail-any) else fail-any) else fail-any)) else caught-fail) in
        {1069}let v_347: bool = not-caught-fail(ss_58) in
        {1070}let v_348: bitstring = (if v_347 then catch-fail(keypairunpack(s_11)) else caught-fail) in
        {1071}let v_349: bool = (not-caught-fail(v_348) && success?(1-proj-2-tuple(v_348))) in
        {1072}let my_private_key_11: key = (if v_349 then 2-proj-2-tuple(v_348) else caught-fail) in
        {1073}let my_public_key_11: key = (if v_349 then 1-proj-2-tuple(v_348) else caught-fail) in
        {1074}let input_key_material_13: key = (if v_347 then catch-fail((if v_349 then dhexp(my_private_key_11,rm_11) else fail-any)) else caught-fail) in
        {1075}let v_350: bool = not-caught-fail(input_key_material_13) in
        {1076}let v_351: bitstring = (if v_350 then catch-fail(symmetricstateunpack(ss_58)) else caught-fail) in
        {1077}let v_352: bool = (not-caught-fail(v_351) && success?(1-proj-3-tuple(v_351))) in
        {1078}let h_52: bitstring = (if v_352 then 3-proj-3-tuple(v_351) else caught-fail) in
        {1079}let ck_63: key = (if v_352 then 2-proj-3-tuple(v_351) else caught-fail) in
        {1080}let cs_52: cipherstate = (if v_352 then 1-proj-3-tuple(v_351) else caught-fail) in
        {1081}let output1_13: key = (if v_352 then hmac_hash1(ck_63,input_key_material_13) else caught-fail) in
        {1082}let output2_13: key = (if v_352 then hmac_hash2(ck_63,input_key_material_13) else caught-fail) in
        {1083}let output3_13: key = (if v_352 then hmac_hash3(ck_63,input_key_material_13) else caught-fail) in
        {1084}let v_353: bitstring = (if v_352 then catch-fail((output1_13,output2_13,output3_13)) else caught-fail) in
        {1085}let v_354: bool = (not-caught-fail(v_353) && success?(1-proj-3-tuple(v_353))) in
        {1086}let output_11: key = (if v_354 then 3-proj-3-tuple(v_353) else caught-fail) in
        {1087}let temp_k_11: key = (if v_354 then 2-proj-3-tuple(v_353) else caught-fail) in
        {1088}let ck_64: key = (if v_354 then 1-proj-3-tuple(v_353) else caught-fail) in
        {1089}let ss_59: symmetricstate = (if v_347 then catch-fail((if v_350 then (if v_352 then (if v_354 then symmetricstatepack(cipherstatepack(temp_k_11,minnonce),ck_64,h_52) else fail-any) else fail-any) else fail-any)) else caught-fail) in
        {1090}let v_355: bool = not-caught-fail(ss_59) in
        {1091}let v_356: bitstring = (if v_355 then catch-fail(symmetricstateunpack(ss_59)) else caught-fail) in
        {1092}let v_357: bool = (not-caught-fail(v_356) && success?(1-proj-3-tuple(v_356))) in
        {1093}let h_53: bitstring = (if v_357 then 3-proj-3-tuple(v_356) else caught-fail) in
        {1094}let ck_65: key = (if v_357 then 2-proj-3-tuple(v_356) else caught-fail) in
        {1095}let cs_53: cipherstate = (if v_357 then 1-proj-3-tuple(v_356) else caught-fail) in
        {1096}let v_358: bitstring = (if v_357 then catch-fail(cipherstateunpack(cs_53)) else caught-fail) in
        {1097}let v_359: bool = (not-caught-fail(v_358) && success?(1-proj-2-tuple(v_358))) in
        {1098}let n_16: nonce = (if v_359 then 2-proj-2-tuple(v_358) else caught-fail) in
        {1099}let k_19: key = (if v_359 then 1-proj-2-tuple(v_358) else caught-fail) in
        {1100}let d_4: aead = (if v_359 then catch-fail(decrypt(k_19,n_16,h_53,ciphertext_16)) else caught-fail) in
        {1101}let v_360: bool = not-caught-fail(d_4) in
        {1102}let v_361: bitstring = (if v_360 then catch-fail(aeadunpack(d_4)) else caught-fail) in
        {1103}let v_362: bool = (not-caught-fail(v_361) && success?(1-proj-3-tuple(v_361))) in
        {1104}let plaintext_12: bitstring = (if v_362 then 3-proj-3-tuple(v_361) else caught-fail) in
        {1105}let adi_4: bitstring = (if v_362 then 2-proj-3-tuple(v_361) else caught-fail) in
        {1106}let valid_12: bool = (if v_362 then 1-proj-3-tuple(v_361) else caught-fail) in
        {1107}let n_17: nonce = (if v_362 then increment_nonce(n_16) else caught-fail) in
        {1108}let v_363: bitstring = (if v_362 then catch-fail(cipherstateunpack(cs_53)) else caught-fail) in
        {1109}let v_364: bool = (not-caught-fail(v_363) && success?(1-proj-2-tuple(v_363))) in
        {1110}let o_8: nonce = (if v_364 then 2-proj-2-tuple(v_363) else caught-fail) in
        {1111}let k_20: key = (if v_364 then 1-proj-2-tuple(v_363) else caught-fail) in
        {1112}let csi_16: cipherstate = (if v_362 then catch-fail((if v_364 then cipherstatepack(k_20,n_17) else fail-any)) else caught-fail) in
        {1113}let v_365: bool = not-caught-fail(csi_16) in
        {1114}let v_366: bitstring = (if v_357 then catch-fail((if v_359 then (if v_360 then (if v_362 then (if v_365 then (csi_16,plaintext_12,valid_12) else fail-any) else fail-any) else fail-any) else fail-any)) else caught-fail) in
        {1115}let v_367: bool = (not-caught-fail(v_366) && success?(1-proj-3-tuple(v_366))) in
        {1116}let valid_13: bool = (if v_367 then 3-proj-3-tuple(v_366) else caught-fail) in
        {1117}let plaintext_13: bitstring = (if v_367 then 2-proj-3-tuple(v_366) else caught-fail) in
        {1118}let csi_17: cipherstate = (if v_367 then 1-proj-3-tuple(v_366) else caught-fail) in
        {1119}let ss_60: symmetricstate = (if v_367 then symmetricstatepack(csi_17,ck_65,h_53) else caught-fail) in
        {1120}let v_368: bitstring = (if v_367 then catch-fail(symmetricstateunpack(ss_60)) else caught-fail) in
        {1121}let v_369: bool = (not-caught-fail(v_368) && success?(1-proj-3-tuple(v_368))) in
        {1122}let h_54: bitstring = (if v_369 then 3-proj-3-tuple(v_368) else caught-fail) in
        {1123}let ck_66: key = (if v_369 then 2-proj-3-tuple(v_368) else caught-fail) in
        {1124}let cs_54: cipherstate = (if v_369 then 1-proj-3-tuple(v_368) else caught-fail) in
        {1125}let ssi_10: symmetricstate = (if v_367 then catch-fail((if v_369 then symmetricstatepack(cs_54,ck_66,hash(h_54,ciphertext_16)) else fail-any)) else caught-fail) in
        {1126}let v_370: bool = not-caught-fail(ssi_10) in
        {1127}let v_371: bitstring = (if v_355 then catch-fail((if v_357 then (if v_367 then (if v_370 then (ssi_10,plaintext_13,valid_13) else fail-any) else fail-any) else fail-any)) else caught-fail) in
        {1128}let v_372: bool = (not-caught-fail(v_371) && success?(1-proj-3-tuple(v_371))) in
        {1129}let valid2_4: bool = (if v_372 then 3-proj-3-tuple(v_371) else caught-fail) in
        {1130}let plaintext_14: bitstring = (if v_372 then 2-proj-3-tuple(v_371) else caught-fail) in
        {1131}let ss_61: symmetricstate = (if v_372 then 1-proj-3-tuple(v_371) else caught-fail) in
        {1132}let v_373: bool = (if v_372 then catch-fail((valid1_4 && valid2_4)) else caught-fail) in
        {1133}let hs_32: handshakestate = (if v_373 then handshakestatepack(ss_61,s_11,m_11,e_17,rs_11,rm_11,re_14,psk_11,initiator_9) else caught-fail) in
        {1134}let (hs_33: handshakestate,plaintext_a: bitstring,valid_14: bool) = (if v_334 then (if v_336 then (if v_339 then (if v_347 then (if v_355 then (if v_372 then (if undo-catch-fail(v_373) then (hs_32,plaintext_14,true) else fail-any) else fail-any) else fail-any) else fail-any) else fail-any) else fail-any) else fail-any) in
        {1135}event RecvMsg(me_2,them_2,stagepack_a(sid_3),plaintext_a);
        {1136}insert statestore(me_2,them_2,sid_3,statepack_b(hs_33))
    ) | (
        {1292}get statestore(=me_2,=them_2,=sid_3,statepack_b(hs_34: handshakestate)) in
        {1138}let payload_4: bitstring = msg_b(me_2,them_2,sid_3) in
        {1139}let v_374: bitstring = catch-fail(handshakestateunpack(hs_34)) in
        {1140}let v_375: bool = (not-caught-fail(v_374) && success?(1-proj-9-tuple(v_374))) in
        {1141}let initiator_10: bool = (if v_375 then 9-proj-9-tuple(v_374) else caught-fail) in
        {1142}let psk_12: key = (if v_375 then 8-proj-9-tuple(v_374) else caught-fail) in
        {1143}let re_15: key = (if v_375 then 7-proj-9-tuple(v_374) else caught-fail) in
        {1144}let rm_12: key = (if v_375 then 6-proj-9-tuple(v_374) else caught-fail) in
        {1145}let rs_12: key = (if v_375 then 5-proj-9-tuple(v_374) else caught-fail) in
        {1146}let e_18: keypair = (if v_375 then 4-proj-9-tuple(v_374) else caught-fail) in
        {1147}let m_12: keypair = (if v_375 then 3-proj-9-tuple(v_374) else caught-fail) in
        {1148}let s_12: keypair = (if v_375 then 2-proj-9-tuple(v_374) else caught-fail) in
        {1149}let ss_62: symmetricstate = (if v_375 then 1-proj-9-tuple(v_374) else caught-fail) in
        {1150}let v_376: bitstring = (if v_375 then catch-fail((empty,empty,empty)) else caught-fail) in
        {1151}let v_377: bool = (not-caught-fail(v_376) && success?(1-proj-3-tuple(v_376))) in
        {1152}let ciphertext_17: bitstring = (if v_377 then 3-proj-3-tuple(v_376) else caught-fail) in
        {1153}let ns_9: bitstring = (if v_377 then 2-proj-3-tuple(v_376) else caught-fail) in
        {1154}let ne_11: bitstring = (if v_377 then 1-proj-3-tuple(v_376) else caught-fail) in
        {1155}let basis_14: key = (if v_377 then key_e(me_2,them_2,sid_3) else caught-fail) in
        {1156}let public_key_14: key = (if v_377 then catch-fail(dhexp(basis_14,validkey(g))) else caught-fail) in
        {1157}let v_378: bool = not-caught-fail(public_key_14) in
        {1158}let e_19: keypair = (if v_377 then catch-fail((if v_378 then keypairpack(validkey(public_key_14),basis_14) else fail-any)) else caught-fail) in
        {1159}let v_379: bool = not-caught-fail(e_19) in
        {1160}let ne_12: bitstring = (if v_379 then catch-fail(getpublickey(e_19)) else caught-fail) in
        {1161}let v_380: bool = not-caught-fail(ne_12) in
        {1162}let v_381: bitstring = (if v_380 then catch-fail(symmetricstateunpack(ss_62)) else caught-fail) in
        {1163}let v_382: bool = (not-caught-fail(v_381) && success?(1-proj-3-tuple(v_381))) in
        {1164}let h_55: bitstring = (if v_382 then 3-proj-3-tuple(v_381) else caught-fail) in
        {1165}let ck_67: key = (if v_382 then 2-proj-3-tuple(v_381) else caught-fail) in
        {1166}let cs_55: cipherstate = (if v_382 then 1-proj-3-tuple(v_381) else caught-fail) in
        {1167}let ss_63: symmetricstate = (if v_380 then catch-fail((if v_382 then symmetricstatepack(cs_55,ck_67,hash(h_55,ne_12)) else fail-any)) else caught-fail) in
        {1168}let v_383: bool = not-caught-fail(ss_63) in
        {1169}let v_384: bitstring = (if v_383 then catch-fail(keypairunpack(e_19)) else caught-fail) in
        {1170}let v_385: bool = (not-caught-fail(v_384) && success?(1-proj-2-tuple(v_384))) in
        {1171}let my_private_key_12: key = (if v_385 then 2-proj-2-tuple(v_384) else caught-fail) in
        {1172}let my_public_key_12: key = (if v_385 then 1-proj-2-tuple(v_384) else caught-fail) in
        {1173}let input_key_material_14: key = (if v_383 then catch-fail((if v_385 then dhexp(my_private_key_12,re_15) else fail-any)) else caught-fail) in
        {1174}let v_386: bool = not-caught-fail(input_key_material_14) in
        {1175}let v_387: bitstring = (if v_386 then catch-fail(symmetricstateunpack(ss_63)) else caught-fail) in
        {1176}let v_388: bool = (not-caught-fail(v_387) && success?(1-proj-3-tuple(v_387))) in
        {1177}let h_56: bitstring = (if v_388 then 3-proj-3-tuple(v_387) else caught-fail) in
        {1178}let ck_68: key = (if v_388 then 2-proj-3-tuple(v_387) else caught-fail) in
        {1179}let cs_56: cipherstate = (if v_388 then 1-proj-3-tuple(v_387) else caught-fail) in
        {1180}let output1_14: key = (if v_388 then hmac_hash1(ck_68,input_key_material_14) else caught-fail) in
        {1181}let output2_14: key = (if v_388 then hmac_hash2(ck_68,input_key_material_14) else caught-fail) in
        {1182}let output3_14: key = (if v_388 then hmac_hash3(ck_68,input_key_material_14) else caught-fail) in
        {1183}let v_389: bitstring = (if v_388 then catch-fail((output1_14,output2_14,output3_14)) else caught-fail) in
        {1184}let v_390: bool = (not-caught-fail(v_389) && success?(1-proj-3-tuple(v_389))) in
        {1185}let output_12: key = (if v_390 then 3-proj-3-tuple(v_389) else caught-fail) in
        {1186}let temp_k_12: key = (if v_390 then 2-proj-3-tuple(v_389) else caught-fail) in
        {1187}let ck_69: key = (if v_390 then 1-proj-3-tuple(v_389) else caught-fail) in
        {1188}let ss_64: symmetricstate = (if v_383 then catch-fail((if v_386 then (if v_388 then (if v_390 then symmetricstatepack(cipherstatepack(temp_k_12,minnonce),ck_69,h_56) else fail-any) else fail-any) else fail-any)) else caught-fail) in
        {1189}let v_391: bool = not-caught-fail(ss_64) in
        {1190}let v_392: bitstring = (if v_391 then catch-fail(keypairunpack(e_19)) else caught-fail) in
        {1191}let v_393: bool = (not-caught-fail(v_392) && success?(1-proj-2-tuple(v_392))) in
        {1192}let my_private_key_13: key = (if v_393 then 2-proj-2-tuple(v_392) else caught-fail) in
        {1193}let my_public_key_13: key = (if v_393 then 1-proj-2-tuple(v_392) else caught-fail) in
        {1194}let input_key_material_15: key = (if v_391 then catch-fail((if v_393 then dhexp(my_private_key_13,rs_12) else fail-any)) else caught-fail) in
        {1195}let v_394: bool = not-caught-fail(input_key_material_15) in
        {1196}let v_395: bitstring = (if v_394 then catch-fail(symmetricstateunpack(ss_64)) else caught-fail) in
        {1197}let v_396: bool = (not-caught-fail(v_395) && success?(1-proj-3-tuple(v_395))) in
        {1198}let h_57: bitstring = (if v_396 then 3-proj-3-tuple(v_395) else caught-fail) in
        {1199}let ck_70: key = (if v_396 then 2-proj-3-tuple(v_395) else caught-fail) in
        {1200}let cs_57: cipherstate = (if v_396 then 1-proj-3-tuple(v_395) else caught-fail) in
        {1201}let output1_15: key = (if v_396 then hmac_hash1(ck_70,input_key_material_15) else caught-fail) in
        {1202}let output2_15: key = (if v_396 then hmac_hash2(ck_70,input_key_material_15) else caught-fail) in
        {1203}let output3_15: key = (if v_396 then hmac_hash3(ck_70,input_key_material_15) else caught-fail) in
        {1204}let v_397: bitstring = (if v_396 then catch-fail((output1_15,output2_15,output3_15)) else caught-fail) in
        {1205}let v_398: bool = (not-caught-fail(v_397) && success?(1-proj-3-tuple(v_397))) in
        {1206}let output_13: key = (if v_398 then 3-proj-3-tuple(v_397) else caught-fail) in
        {1207}let temp_k_13: key = (if v_398 then 2-proj-3-tuple(v_397) else caught-fail) in
        {1208}let ck_71: key = (if v_398 then 1-proj-3-tuple(v_397) else caught-fail) in
        {1209}let ss_65: symmetricstate = (if v_391 then catch-fail((if v_394 then (if v_396 then (if v_398 then symmetricstatepack(cipherstatepack(temp_k_13,minnonce),ck_71,h_57) else fail-any) else fail-any) else fail-any)) else caught-fail) in
        {1210}let v_399: bool = not-caught-fail(ss_65) in
        {1211}let v_400: bitstring = (if v_399 then catch-fail(keypairunpack(e_19)) else caught-fail) in
        {1212}let v_401: bool = (not-caught-fail(v_400) && success?(1-proj-2-tuple(v_400))) in
        {1213}let my_private_key_14: key = (if v_401 then 2-proj-2-tuple(v_400) else caught-fail) in
        {1214}let my_public_key_14: key = (if v_401 then 1-proj-2-tuple(v_400) else caught-fail) in
        {1215}let input_key_material_16: key = (if v_399 then catch-fail((if v_401 then dhexp(my_private_key_14,rm_12) else fail-any)) else caught-fail) in
        {1216}let v_402: bool = not-caught-fail(input_key_material_16) in
        {1217}let v_403: bitstring = (if v_402 then catch-fail(symmetricstateunpack(ss_65)) else caught-fail) in
        {1218}let v_404: bool = (not-caught-fail(v_403) && success?(1-proj-3-tuple(v_403))) in
        {1219}let h_58: bitstring = (if v_404 then 3-proj-3-tuple(v_403) else caught-fail) in
        {1220}let ck_72: key = (if v_404 then 2-proj-3-tuple(v_403) else caught-fail) in
        {1221}let cs_58: cipherstate = (if v_404 then 1-proj-3-tuple(v_403) else caught-fail) in
        {1222}let output1_16: key = (if v_404 then hmac_hash1(ck_72,input_key_material_16) else caught-fail) in
        {1223}let output2_16: key = (if v_404 then hmac_hash2(ck_72,input_key_material_16) else caught-fail) in
        {1224}let output3_16: key = (if v_404 then hmac_hash3(ck_72,input_key_material_16) else caught-fail) in
        {1225}let v_405: bitstring = (if v_404 then catch-fail((output1_16,output2_16,output3_16)) else caught-fail) in
        {1226}let v_406: bool = (not-caught-fail(v_405) && success?(1-proj-3-tuple(v_405))) in
        {1227}let output_14: key = (if v_406 then 3-proj-3-tuple(v_405) else caught-fail) in
        {1228}let temp_k_14: key = (if v_406 then 2-proj-3-tuple(v_405) else caught-fail) in
        {1229}let ck_73: key = (if v_406 then 1-proj-3-tuple(v_405) else caught-fail) in
        {1230}let ss_66: symmetricstate = (if v_399 then catch-fail((if v_402 then (if v_404 then (if v_406 then symmetricstatepack(cipherstatepack(temp_k_14,minnonce),ck_73,h_58) else fail-any) else fail-any) else fail-any)) else caught-fail) in
        {1231}let v_407: bool = not-caught-fail(ss_66) in
        {1232}let v_408: bitstring = (if v_407 then catch-fail(symmetricstateunpack(ss_66)) else caught-fail) in
        {1233}let v_409: bool = (not-caught-fail(v_408) && success?(1-proj-3-tuple(v_408))) in
        {1234}let h_59: bitstring = (if v_409 then 3-proj-3-tuple(v_408) else caught-fail) in
        {1235}let ck_74: key = (if v_409 then 2-proj-3-tuple(v_408) else caught-fail) in
        {1236}let cs_59: cipherstate = (if v_409 then 1-proj-3-tuple(v_408) else caught-fail) in
        {1237}let v_410: bitstring = (if v_409 then catch-fail(cipherstateunpack(cs_59)) else caught-fail) in
        {1238}let v_411: bool = (not-caught-fail(v_410) && success?(1-proj-2-tuple(v_410))) in
        {1239}let n_18: nonce = (if v_411 then 2-proj-2-tuple(v_410) else caught-fail) in
        {1240}let k_21: key = (if v_411 then 1-proj-2-tuple(v_410) else caught-fail) in
        {1241}let e_20: bitstring = (if v_411 then encrypt(k_21,n_18,h_59,payload_4) else caught-fail) in
        {1242}let n_19: nonce = (if v_411 then increment_nonce(n_18) else caught-fail) in
        {1243}let v_412: bitstring = (if v_411 then catch-fail(cipherstateunpack(cs_59)) else caught-fail) in
        {1244}let v_413: bool = (not-caught-fail(v_412) && success?(1-proj-2-tuple(v_412))) in
        {1245}let o_9: nonce = (if v_413 then 2-proj-2-tuple(v_412) else caught-fail) in
        {1246}let k_22: key = (if v_413 then 1-proj-2-tuple(v_412) else caught-fail) in
        {1247}let csi_18: cipherstate = (if v_411 then catch-fail((if v_413 then cipherstatepack(k_22,n_19) else fail-any)) else caught-fail) in
        {1248}let v_414: bool = not-caught-fail(csi_18) in
        {1249}let v_415: bitstring = (if v_409 then catch-fail((if v_411 then (if v_414 then (csi_18,e_20) else fail-any) else fail-any)) else caught-fail) in
        {1250}let v_416: bool = (not-caught-fail(v_415) && success?(1-proj-2-tuple(v_415))) in
        {1251}let ciphertext_18: bitstring = (if v_416 then 2-proj-2-tuple(v_415) else caught-fail) in
        {1252}let csi_19: cipherstate = (if v_416 then 1-proj-2-tuple(v_415) else caught-fail) in
        {1253}let ss_67: symmetricstate = (if v_416 then symmetricstatepack(csi_19,ck_74,h_59) else caught-fail) in
        {1254}let v_417: bitstring = (if v_416 then catch-fail(symmetricstateunpack(ss_67)) else caught-fail) in
        {1255}let v_418: bool = (not-caught-fail(v_417) && success?(1-proj-3-tuple(v_417))) in
        {1256}let h_60: bitstring = (if v_418 then 3-proj-3-tuple(v_417) else caught-fail) in
        {1257}let ck_75: key = (if v_418 then 2-proj-3-tuple(v_417) else caught-fail) in
        {1258}let cs_60: cipherstate = (if v_418 then 1-proj-3-tuple(v_417) else caught-fail) in
        {1259}let ssi_11: symmetricstate = (if v_416 then catch-fail((if v_418 then symmetricstatepack(cs_60,ck_75,hash(h_60,ciphertext_18)) else fail-any)) else caught-fail) in
        {1260}let v_419: bool = not-caught-fail(ssi_11) in
        {1261}let v_420: bitstring = (if v_407 then catch-fail((if v_409 then (if v_416 then (if v_419 then (ssi_11,ciphertext_18) else fail-any) else fail-any) else fail-any)) else caught-fail) in
        {1262}let v_421: bool = (not-caught-fail(v_420) && success?(1-proj-2-tuple(v_420))) in
        {1263}let ciphertext_19: bitstring = (if v_421 then 2-proj-2-tuple(v_420) else caught-fail) in
        {1264}let ss_68: symmetricstate = (if v_421 then 1-proj-2-tuple(v_420) else caught-fail) in
        {1265}let hs_35: handshakestate = (if v_421 then handshakestatepack(ss_68,s_12,m_12,e_19,rs_12,rm_12,re_15,psk_12,initiator_10) else caught-fail) in
        {1266}let message_buffer_4: bitstring = (if v_421 then concat3(ne_12,ns_9,ciphertext_19) else caught-fail) in
        {1267}let v_422: bitstring = (if v_421 then catch-fail(symmetricstateunpack(ss_68)) else caught-fail) in
        {1268}let v_423: bool = (not-caught-fail(v_422) && success?(1-proj-3-tuple(v_422))) in
        {1269}let h_61: bitstring = (if v_423 then 3-proj-3-tuple(v_422) else caught-fail) in
        {1270}let ck_76: key = (if v_423 then 2-proj-3-tuple(v_422) else caught-fail) in
        {1271}let cs_61: cipherstate = (if v_423 then 1-proj-3-tuple(v_422) else caught-fail) in
        {1272}let input_key_material_17: key = (if v_423 then zero else caught-fail) in
        {1273}let output1_17: key = (if v_423 then hmac_hash1(ck_76,input_key_material_17) else caught-fail) in
        {1274}let output2_17: key = (if v_423 then hmac_hash2(ck_76,input_key_material_17) else caught-fail) in
        {1275}let output3_17: key = (if v_423 then hmac_hash3(ck_76,input_key_material_17) else caught-fail) in
        {1276}let v_424: bitstring = (if v_423 then catch-fail((output1_17,output2_17,output3_17)) else caught-fail) in
        {1277}let v_425: bool = (not-caught-fail(v_424) && success?(1-proj-3-tuple(v_424))) in
        {1278}let temp_k3_2: key = (if v_425 then 3-proj-3-tuple(v_424) else caught-fail) in
        {1279}let temp_k2_2: key = (if v_425 then 2-proj-3-tuple(v_424) else caught-fail) in
        {1280}let temp_k1_2: key = (if v_425 then 1-proj-3-tuple(v_424) else caught-fail) in
        {1281}let cs1_10: cipherstate = (if v_425 then cipherstatepack(temp_k1_2,minnonce) else caught-fail) in
        {1282}let cs2_10: cipherstate = (if v_425 then cipherstatepack(temp_k2_2,minnonce) else caught-fail) in
        {1283}let v_426: bitstring = (if v_421 then catch-fail((if v_423 then (if v_425 then (ss_68,cs1_10,cs2_10) else fail-any) else fail-any)) else caught-fail) in
        {1284}let v_427: bool = (not-caught-fail(v_426) && success?(1-proj-3-tuple(v_426))) in
        {1285}let cs2_11: cipherstate = (if v_427 then 3-proj-3-tuple(v_426) else caught-fail) in
        {1286}let cs1_11: cipherstate = (if v_427 then 2-proj-3-tuple(v_426) else caught-fail) in
        {1287}let ssi_12: symmetricstate = (if v_427 then 1-proj-3-tuple(v_426) else caught-fail) in
        {1288}let (hs_36: handshakestate,message_b_2: bitstring,cs1_12: cipherstate,cs2_12: cipherstate) = (if v_375 then (if v_377 then (if v_379 then (if v_380 then (if v_383 then (if v_391 then (if v_399 then (if v_407 then (if v_421 then (if v_427 then (hs_35,message_buffer_4,cs1_11,cs2_11) else fail-any) else fail-any) else fail-any) else fail-any) else fail-any) else fail-any) else fail-any) else fail-any) else fail-any) else fail-any) in
        {1289}event SendMsg(me_2,them_2,stagepack_b(sid_3),msg_b(me_2,them_2,sid_3));
        {1290}insert statestore(me_2,them_2,sid_3,statepack_c(hs_36,cs1_12,cs2_12));
        {1291}out(pub, message_b_2)
    ) | (
        {1293}!
        {1359}get statestore(=me_2,=them_2,=sid_3,statepack_c(hs_37: handshakestate,cs1_13: cipherstate,cs2_13: cipherstate)) in
        {1294}let hs_38: handshakestate = handshakestatesetcs(hs_37,cs1_13) in
        {1295}in(pub, message_c_2: bitstring);
        {1296}let v_428: bitstring = catch-fail(handshakestateunpack(hs_38)) in
        {1297}let v_429: bool = (not-caught-fail(v_428) && success?(1-proj-9-tuple(v_428))) in
        {1298}let initiator_11: bool = (if v_429 then 9-proj-9-tuple(v_428) else caught-fail) in
        {1299}let psk_13: key = (if v_429 then 8-proj-9-tuple(v_428) else caught-fail) in
        {1300}let re_16: key = (if v_429 then 7-proj-9-tuple(v_428) else caught-fail) in
        {1301}let rm_13: key = (if v_429 then 6-proj-9-tuple(v_428) else caught-fail) in
        {1302}let rs_13: key = (if v_429 then 5-proj-9-tuple(v_428) else caught-fail) in
        {1303}let e_21: keypair = (if v_429 then 4-proj-9-tuple(v_428) else caught-fail) in
        {1304}let m_13: keypair = (if v_429 then 3-proj-9-tuple(v_428) else caught-fail) in
        {1305}let s_13: keypair = (if v_429 then 2-proj-9-tuple(v_428) else caught-fail) in
        {1306}let ss_69: symmetricstate = (if v_429 then 1-proj-9-tuple(v_428) else caught-fail) in
        {1307}let v_430: bitstring = (if v_429 then catch-fail(deconcat3(message_c_2)) else caught-fail) in
        {1308}let v_431: bool = (not-caught-fail(v_430) && success?(1-proj-3-tuple(v_430))) in
        {1309}let ciphertext_20: bitstring = (if v_431 then 3-proj-3-tuple(v_430) else caught-fail) in
        {1310}let ns_10: bitstring = (if v_431 then 2-proj-3-tuple(v_430) else caught-fail) in
        {1311}let ne_13: bitstring = (if v_431 then 1-proj-3-tuple(v_430) else caught-fail) in
        {1312}let valid1_5: bool = (if v_431 then true else caught-fail) in
        {1313}let v_432: bitstring = (if v_431 then catch-fail(symmetricstateunpack(ss_69)) else caught-fail) in
        {1314}let v_433: bool = (not-caught-fail(v_432) && success?(1-proj-3-tuple(v_432))) in
        {1315}let h_62: bitstring = (if v_433 then 3-proj-3-tuple(v_432) else caught-fail) in
        {1316}let ck_77: key = (if v_433 then 2-proj-3-tuple(v_432) else caught-fail) in
        {1317}let cs_62: cipherstate = (if v_433 then 1-proj-3-tuple(v_432) else caught-fail) in
        {1318}let v_434: bitstring = (if v_433 then catch-fail(cipherstateunpack(cs_62)) else caught-fail) in
        {1319}let v_435: bool = (not-caught-fail(v_434) && success?(1-proj-2-tuple(v_434))) in
        {1320}let n_20: nonce = (if v_435 then 2-proj-2-tuple(v_434) else caught-fail) in
        {1321}let k_23: key = (if v_435 then 1-proj-2-tuple(v_434) else caught-fail) in
        {1322}let d_5: aead = (if v_435 then catch-fail(decrypt(k_23,n_20,h_62,ciphertext_20)) else caught-fail) in
        {1323}let v_436: bool = not-caught-fail(d_5) in
        {1324}let v_437: bitstring = (if v_436 then catch-fail(aeadunpack(d_5)) else caught-fail) in
        {1325}let v_438: bool = (not-caught-fail(v_437) && success?(1-proj-3-tuple(v_437))) in
        {1326}let plaintext_15: bitstring = (if v_438 then 3-proj-3-tuple(v_437) else caught-fail) in
        {1327}let adi_5: bitstring = (if v_438 then 2-proj-3-tuple(v_437) else caught-fail) in
        {1328}let valid_15: bool = (if v_438 then 1-proj-3-tuple(v_437) else caught-fail) in
        {1329}let n_21: nonce = (if v_438 then increment_nonce(n_20) else caught-fail) in
        {1330}let v_439: bitstring = (if v_438 then catch-fail(cipherstateunpack(cs_62)) else caught-fail) in
        {1331}let v_440: bool = (not-caught-fail(v_439) && success?(1-proj-2-tuple(v_439))) in
        {1332}let o_10: nonce = (if v_440 then 2-proj-2-tuple(v_439) else caught-fail) in
        {1333}let k_24: key = (if v_440 then 1-proj-2-tuple(v_439) else caught-fail) in
        {1334}let csi_20: cipherstate = (if v_438 then catch-fail((if v_440 then cipherstatepack(k_24,n_21) else fail-any)) else caught-fail) in
        {1335}let v_441: bool = not-caught-fail(csi_20) in
        {1336}let v_442: bitstring = (if v_433 then catch-fail((if v_435 then (if v_436 then (if v_438 then (if v_441 then (csi_20,plaintext_15,valid_15) else fail-any) else fail-any) else fail-any) else fail-any)) else caught-fail) in
        {1337}let v_443: bool = (not-caught-fail(v_442) && success?(1-proj-3-tuple(v_442))) in
        {1338}let valid_16: bool = (if v_443 then 3-proj-3-tuple(v_442) else caught-fail) in
        {1339}let plaintext_16: bitstring = (if v_443 then 2-proj-3-tuple(v_442) else caught-fail) in
        {1340}let csi_21: cipherstate = (if v_443 then 1-proj-3-tuple(v_442) else caught-fail) in
        {1341}let ss_70: symmetricstate = (if v_443 then symmetricstatepack(csi_21,ck_77,h_62) else caught-fail) in
        {1342}let v_444: bitstring = (if v_443 then catch-fail(symmetricstateunpack(ss_70)) else caught-fail) in
        {1343}let v_445: bool = (not-caught-fail(v_444) && success?(1-proj-3-tuple(v_444))) in
        {1344}let h_63: bitstring = (if v_445 then 3-proj-3-tuple(v_444) else caught-fail) in
        {1345}let ck_78: key = (if v_445 then 2-proj-3-tuple(v_444) else caught-fail) in
        {1346}let cs_63: cipherstate = (if v_445 then 1-proj-3-tuple(v_444) else caught-fail) in
        {1347}let ssi_13: symmetricstate = (if v_443 then catch-fail((if v_445 then symmetricstatepack(cs_63,ck_78,hash(h_63,ciphertext_20)) else fail-any)) else caught-fail) in
        {1348}let v_446: bool = not-caught-fail(ssi_13) in
        {1349}let v_447: bitstring = (if v_431 then catch-fail((if v_433 then (if v_443 then (if v_446 then (ssi_13,plaintext_16,valid_16) else fail-any) else fail-any) else fail-any)) else caught-fail) in
        {1350}let v_448: bool = (not-caught-fail(v_447) && success?(1-proj-3-tuple(v_447))) in
        {1351}let valid2_5: bool = (if v_448 then 3-proj-3-tuple(v_447) else caught-fail) in
        {1352}let plaintext_17: bitstring = (if v_448 then 2-proj-3-tuple(v_447) else caught-fail) in
        {1353}let ss_71: symmetricstate = (if v_448 then 1-proj-3-tuple(v_447) else caught-fail) in
        {1354}let v_449: bool = (if v_448 then catch-fail((valid1_5 && valid2_5)) else caught-fail) in
        {1355}let hs_39: handshakestate = (if v_449 then handshakestatepack(ss_71,s_13,m_13,e_21,rs_13,rm_13,re_16,psk_13,initiator_11) else caught-fail) in
        {1356}let (hs_40: handshakestate,plaintext_c: bitstring,valid_17: bool) = (if v_429 then (if v_431 then (if v_448 then (if undo-catch-fail(v_449) then (hs_39,plaintext_17,true) else fail-any) else fail-any) else fail-any) else fail-any) in
        {1357}event RecvMsg(me_2,them_2,stagepack_c(sid_3),plaintext_c);
        {1358}insert statestore(me_2,them_2,sid_3,statepack_d(hs_40,handshakestategetcs(hs_40),cs2_13))
    ) | (
        {1360}!
        {1417}get statestore(=me_2,=them_2,=sid_3,statepack_d(hs_41: handshakestate,cs1_14: cipherstate,cs2_14: cipherstate)) in
        {1361}let hs_42: handshakestate = handshakestatesetcs(hs_41,cs2_14) in
        {1362}let payload_5: bitstring = msg_d(me_2,them_2,sid_3) in
        {1363}let v_450: bitstring = catch-fail(handshakestateunpack(hs_42)) in
        {1364}let v_451: bool = (not-caught-fail(v_450) && success?(1-proj-9-tuple(v_450))) in
        {1365}let initiator_12: bool = (if v_451 then 9-proj-9-tuple(v_450) else caught-fail) in
        {1366}let psk_14: key = (if v_451 then 8-proj-9-tuple(v_450) else caught-fail) in
        {1367}let re_17: key = (if v_451 then 7-proj-9-tuple(v_450) else caught-fail) in
        {1368}let rm_14: key = (if v_451 then 6-proj-9-tuple(v_450) else caught-fail) in
        {1369}let rs_14: key = (if v_451 then 5-proj-9-tuple(v_450) else caught-fail) in
        {1370}let e_22: keypair = (if v_451 then 4-proj-9-tuple(v_450) else caught-fail) in
        {1371}let m_14: keypair = (if v_451 then 3-proj-9-tuple(v_450) else caught-fail) in
        {1372}let s_14: keypair = (if v_451 then 2-proj-9-tuple(v_450) else caught-fail) in
        {1373}let ss_72: symmetricstate = (if v_451 then 1-proj-9-tuple(v_450) else caught-fail) in
        {1374}let v_452: bitstring = (if v_451 then catch-fail((empty,empty,empty)) else caught-fail) in
        {1375}let v_453: bool = (not-caught-fail(v_452) && success?(1-proj-3-tuple(v_452))) in
        {1376}let ciphertext_21: bitstring = (if v_453 then 3-proj-3-tuple(v_452) else caught-fail) in
        {1377}let ns_11: bitstring = (if v_453 then 2-proj-3-tuple(v_452) else caught-fail) in
        {1378}let ne_14: bitstring = (if v_453 then 1-proj-3-tuple(v_452) else caught-fail) in
        {1379}let v_454: bitstring = (if v_453 then catch-fail(symmetricstateunpack(ss_72)) else caught-fail) in
        {1380}let v_455: bool = (not-caught-fail(v_454) && success?(1-proj-3-tuple(v_454))) in
        {1381}let h_64: bitstring = (if v_455 then 3-proj-3-tuple(v_454) else caught-fail) in
        {1382}let ck_79: key = (if v_455 then 2-proj-3-tuple(v_454) else caught-fail) in
        {1383}let cs_64: cipherstate = (if v_455 then 1-proj-3-tuple(v_454) else caught-fail) in
        {1384}let v_456: bitstring = (if v_455 then catch-fail(cipherstateunpack(cs_64)) else caught-fail) in
        {1385}let v_457: bool = (not-caught-fail(v_456) && success?(1-proj-2-tuple(v_456))) in
        {1386}let n_22: nonce = (if v_457 then 2-proj-2-tuple(v_456) else caught-fail) in
        {1387}let k_25: key = (if v_457 then 1-proj-2-tuple(v_456) else caught-fail) in
        {1388}let e_23: bitstring = (if v_457 then encrypt(k_25,n_22,h_64,payload_5) else caught-fail) in
        {1389}let n_23: nonce = (if v_457 then increment_nonce(n_22) else caught-fail) in
        {1390}let v_458: bitstring = (if v_457 then catch-fail(cipherstateunpack(cs_64)) else caught-fail) in
        {1391}let v_459: bool = (not-caught-fail(v_458) && success?(1-proj-2-tuple(v_458))) in
        {1392}let o_11: nonce = (if v_459 then 2-proj-2-tuple(v_458) else caught-fail) in
        {1393}let k_26: key = (if v_459 then 1-proj-2-tuple(v_458) else caught-fail) in
        {1394}let csi_22: cipherstate = (if v_457 then catch-fail((if v_459 then cipherstatepack(k_26,n_23) else fail-any)) else caught-fail) in
        {1395}let v_460: bool = not-caught-fail(csi_22) in
        {1396}let v_461: bitstring = (if v_455 then catch-fail((if v_457 then (if v_460 then (csi_22,e_23) else fail-any) else fail-any)) else caught-fail) in
        {1397}let v_462: bool = (not-caught-fail(v_461) && success?(1-proj-2-tuple(v_461))) in
        {1398}let ciphertext_22: bitstring = (if v_462 then 2-proj-2-tuple(v_461) else caught-fail) in
        {1399}let csi_23: cipherstate = (if v_462 then 1-proj-2-tuple(v_461) else caught-fail) in
        {1400}let ss_73: symmetricstate = (if v_462 then symmetricstatepack(csi_23,ck_79,h_64) else caught-fail) in
        {1401}let v_463: bitstring = (if v_462 then catch-fail(symmetricstateunpack(ss_73)) else caught-fail) in
        {1402}let v_464: bool = (not-caught-fail(v_463) && success?(1-proj-3-tuple(v_463))) in
        {1403}let h_65: bitstring = (if v_464 then 3-proj-3-tuple(v_463) else caught-fail) in
        {1404}let ck_80: key = (if v_464 then 2-proj-3-tuple(v_463) else caught-fail) in
        {1405}let cs_65: cipherstate = (if v_464 then 1-proj-3-tuple(v_463) else caught-fail) in
        {1406}let ssi_14: symmetricstate = (if v_462 then catch-fail((if v_464 then symmetricstatepack(cs_65,ck_80,hash(h_65,ciphertext_22)) else fail-any)) else caught-fail) in
        {1407}let v_465: bool = not-caught-fail(ssi_14) in
        {1408}let v_466: bitstring = (if v_453 then catch-fail((if v_455 then (if v_462 then (if v_465 then (ssi_14,ciphertext_22) else fail-any) else fail-any) else fail-any)) else caught-fail) in
        {1409}let v_467: bool = (not-caught-fail(v_466) && success?(1-proj-2-tuple(v_466))) in
        {1410}let ciphertext_23: bitstring = (if v_467 then 2-proj-2-tuple(v_466) else caught-fail) in
        {1411}let ss_74: symmetricstate = (if v_467 then 1-proj-2-tuple(v_466) else caught-fail) in
        {1412}let hs_43: handshakestate = (if v_467 then handshakestatepack(ss_74,s_14,m_14,e_22,rs_14,rm_14,re_17,psk_14,initiator_12) else caught-fail) in
        {1413}let message_buffer_5: bitstring = (if v_467 then concat3(ne_14,ns_11,ciphertext_23) else caught-fail) in
        {1414}let (hs_44: handshakestate,message_d_2: bitstring) = (if v_451 then (if v_453 then (if v_467 then (hs_43,message_buffer_5) else fail-any) else fail-any) else fail-any) in
        {1415}event SendMsg(me_2,them_2,stagepack_d(sid_3),msg_d(me_2,them_2,sid_3));
        {1416}out(pub, message_d_2)
    ) | (
        {1418}event LeakS(phase0,me_2);
        {1419}event LeakM(phase0,me_2);
        {1420}out(pub, (key_s(me_2),key_m(me_2)))
    ) | (
        {1421}phase 1;
        {1422}event LeakS(phase1,me_2);
        {1423}event LeakM(phase1,me_2);
        {1424}out(pub, (key_s(me_2),key_m(me_2)))
    )
) | (
    {1425}let me_3: principal = bob in
    {1426}let them_3: principal = charlie in
    {1427}let sid_4: sessionid = sid in
    {1428}let basis_15: key = key_s(me_3) in
    {1429}let public_key_15: key = catch-fail(dhexp(basis_15,validkey(g))) in
    {1430}let v_468: bool = not-caught-fail(public_key_15) in
    {1431}let s_15: keypair = (if v_468 then keypairpack(validkey(public_key_15),basis_15) else fail-any) in
    {1432}let basis_16: key = key_m(me_3) in
    {1433}let public_key_16: key = catch-fail(dhexp(basis_16,validkey(g))) in
    {1434}let v_469: bool = not-caught-fail(public_key_16) in
    {1435}let m_15: keypair = (if v_469 then keypairpack(validkey(public_key_16),basis_16) else fail-any) in
    {1436}out(pub, (getpublickey(s_15),getpublickey(m_15)));
    (
        {1437}let e_24: keypair = keypairpack(empty,empty) in
        {1438}let basis_17: key = key_s(them_3) in
        {1439}let public_key_17: key = catch-fail(dhexp(basis_17,validkey(g))) in
        {1440}let v_470: bool = not-caught-fail(public_key_17) in
        {1441}let rs_15: key = getpublickey((if v_470 then keypairpack(validkey(public_key_17),basis_17) else fail-any)) in
        {1442}let basis_18: key = key_m(them_3) in
        {1443}let public_key_18: key = catch-fail(dhexp(basis_18,validkey(g))) in
        {1444}let v_471: bool = not-caught-fail(public_key_18) in
        {1445}let rm_15: key = getpublickey((if v_471 then keypairpack(validkey(public_key_18),basis_18) else fail-any)) in
        {1446}let re_18: key = empty in
        {1447}let prologue_3: bitstring = empty in
        {1448}let psk_15: key = empty in
        {1449}let protocol_name_3: bitstring = somename in
        {1450}let h_66: bitstring = hash(protocol_name_3,empty) in
        {1451}let ck_81: key = h_66 in
        {1452}let k_27: key = empty in
        {1453}let cs_66: cipherstate = cipherstatepack(k_27,minnonce) in
        {1454}let ss_75: symmetricstate = symmetricstatepack(cs_66,ck_81,h_66) in
        {1455}let v_472: bitstring = catch-fail(symmetricstateunpack(ss_75)) in
        {1456}let v_473: bool = (not-caught-fail(v_472) && success?(1-proj-3-tuple(v_472))) in
        {1457}let h_67: bitstring = (if v_473 then 3-proj-3-tuple(v_472) else caught-fail) in
        {1458}let ck_82: key = (if v_473 then 2-proj-3-tuple(v_472) else caught-fail) in
        {1459}let cs_67: cipherstate = (if v_473 then 1-proj-3-tuple(v_472) else caught-fail) in
        {1460}let ss_76: symmetricstate = catch-fail((if v_473 then symmetricstatepack(cs_67,ck_82,hash(h_67,prologue_3)) else fail-any)) in
        {1461}let v_474: bool = not-caught-fail(ss_76) in
        {1462}let v_475: bitstring = (if v_474 then catch-fail(symmetricstateunpack(ss_76)) else caught-fail) in
        {1463}let v_476: bool = (not-caught-fail(v_475) && success?(1-proj-3-tuple(v_475))) in
        {1464}let h_68: bitstring = (if v_476 then 3-proj-3-tuple(v_475) else caught-fail) in
        {1465}let ck_83: key = (if v_476 then 2-proj-3-tuple(v_475) else caught-fail) in
        {1466}let cs_68: cipherstate = (if v_476 then 1-proj-3-tuple(v_475) else caught-fail) in
        {1467}let ss_77: symmetricstate = (if v_474 then catch-fail((if v_476 then symmetricstatepack(cs_68,ck_83,hash(h_68,rs_15)) else fail-any)) else caught-fail) in
        {1468}let v_477: bool = not-caught-fail(ss_77) in
        {1469}let v_478: bitstring = (if v_477 then catch-fail(symmetricstateunpack(ss_77)) else caught-fail) in
        {1470}let v_479: bool = (not-caught-fail(v_478) && success?(1-proj-3-tuple(v_478))) in
        {1471}let h_69: bitstring = (if v_479 then 3-proj-3-tuple(v_478) else caught-fail) in
        {1472}let ck_84: key = (if v_479 then 2-proj-3-tuple(v_478) else caught-fail) in
        {1473}let cs_69: cipherstate = (if v_479 then 1-proj-3-tuple(v_478) else caught-fail) in
        {1474}let ss_78: symmetricstate = (if v_477 then catch-fail((if v_479 then symmetricstatepack(cs_69,ck_84,hash(h_69,rm_15)) else fail-any)) else caught-fail) in
        {1475}let v_480: bool = not-caught-fail(ss_78) in
        {1476}let data_6: bitstring = (if v_480 then catch-fail(getpublickey(s_15)) else caught-fail) in
        {1477}let v_481: bool = not-caught-fail(data_6) in
        {1478}let v_482: bitstring = (if v_481 then catch-fail(symmetricstateunpack(ss_78)) else caught-fail) in
        {1479}let v_483: bool = (not-caught-fail(v_482) && success?(1-proj-3-tuple(v_482))) in
        {1480}let h_70: bitstring = (if v_483 then 3-proj-3-tuple(v_482) else caught-fail) in
        {1481}let ck_85: key = (if v_483 then 2-proj-3-tuple(v_482) else caught-fail) in
        {1482}let cs_70: cipherstate = (if v_483 then 1-proj-3-tuple(v_482) else caught-fail) in
        {1483}let ss_79: symmetricstate = (if v_480 then catch-fail((if v_481 then (if v_483 then symmetricstatepack(cs_70,ck_85,hash(h_70,data_6)) else fail-any) else fail-any)) else caught-fail) in
        {1484}let v_484: bool = not-caught-fail(ss_79) in
        {1485}let data_7: bitstring = (if v_484 then catch-fail(getpublickey(m_15)) else caught-fail) in
        {1486}let v_485: bool = not-caught-fail(data_7) in
        {1487}let v_486: bitstring = (if v_485 then catch-fail(symmetricstateunpack(ss_79)) else caught-fail) in
        {1488}let v_487: bool = (not-caught-fail(v_486) && success?(1-proj-3-tuple(v_486))) in
        {1489}let h_71: bitstring = (if v_487 then 3-proj-3-tuple(v_486) else caught-fail) in
        {1490}let ck_86: key = (if v_487 then 2-proj-3-tuple(v_486) else caught-fail) in
        {1491}let cs_71: cipherstate = (if v_487 then 1-proj-3-tuple(v_486) else caught-fail) in
        {1492}let ss_80: symmetricstate = (if v_484 then catch-fail((if v_485 then (if v_487 then symmetricstatepack(cs_71,ck_86,hash(h_71,data_7)) else fail-any) else fail-any)) else caught-fail) in
        {1493}let v_488: bool = not-caught-fail(ss_80) in
        {1494}let hs_45: handshakestate = (if v_474 then (if v_477 then (if v_480 then (if v_484 then (if v_488 then handshakestatepack(ss_80,s_15,m_15,e_24,rs_15,rm_15,re_18,psk_15,false) else fail-any) else fail-any) else fail-any) else fail-any) else fail-any) in
        {1495}insert statestore(me_3,them_3,sid_4,statepack_a(hs_45))
    ) | (
        {1610}get statestore(=me_3,=them_3,=sid_4,statepack_a(hs_46: handshakestate)) in
        {1496}in(pub, message_a_3: bitstring);
        {1497}let v_489: bitstring = catch-fail(handshakestateunpack(hs_46)) in
        {1498}let v_490: bool = (not-caught-fail(v_489) && success?(1-proj-9-tuple(v_489))) in
        {1499}let initiator_13: bool = (if v_490 then 9-proj-9-tuple(v_489) else caught-fail) in
        {1500}let psk_16: key = (if v_490 then 8-proj-9-tuple(v_489) else caught-fail) in
        {1501}let re_19: key = (if v_490 then 7-proj-9-tuple(v_489) else caught-fail) in
        {1502}let rm_16: key = (if v_490 then 6-proj-9-tuple(v_489) else caught-fail) in
        {1503}let rs_16: key = (if v_490 then 5-proj-9-tuple(v_489) else caught-fail) in
        {1504}let e_25: keypair = (if v_490 then 4-proj-9-tuple(v_489) else caught-fail) in
        {1505}let m_16: keypair = (if v_490 then 3-proj-9-tuple(v_489) else caught-fail) in
        {1506}let s_16: keypair = (if v_490 then 2-proj-9-tuple(v_489) else caught-fail) in
        {1507}let ss_81: symmetricstate = (if v_490 then 1-proj-9-tuple(v_489) else caught-fail) in
        {1508}let v_491: bitstring = (if v_490 then catch-fail(deconcat3(message_a_3)) else caught-fail) in
        {1509}let v_492: bool = (not-caught-fail(v_491) && success?(1-proj-3-tuple(v_491))) in
        {1510}let ciphertext_24: bitstring = (if v_492 then 3-proj-3-tuple(v_491) else caught-fail) in
        {1511}let ns_12: bitstring = (if v_492 then 2-proj-3-tuple(v_491) else caught-fail) in
        {1512}let ne_15: bitstring = (if v_492 then 1-proj-3-tuple(v_491) else caught-fail) in
        {1513}let valid1_6: bool = (if v_492 then true else caught-fail) in
        {1514}let re_20: key = (if v_492 then ne_15 else caught-fail) in
        {1515}let v_493: bitstring = (if v_492 then catch-fail(symmetricstateunpack(ss_81)) else caught-fail) in
        {1516}let v_494: bool = (not-caught-fail(v_493) && success?(1-proj-3-tuple(v_493))) in
        {1517}let h_72: bitstring = (if v_494 then 3-proj-3-tuple(v_493) else caught-fail) in
        {1518}let ck_87: key = (if v_494 then 2-proj-3-tuple(v_493) else caught-fail) in
        {1519}let cs_72: cipherstate = (if v_494 then 1-proj-3-tuple(v_493) else caught-fail) in
        {1520}let ss_82: symmetricstate = (if v_492 then catch-fail((if v_494 then symmetricstatepack(cs_72,ck_87,hash(h_72,re_20)) else fail-any)) else caught-fail) in
        {1521}let v_495: bool = not-caught-fail(ss_82) in
        {1522}let v_496: bitstring = (if v_495 then catch-fail(keypairunpack(m_16)) else caught-fail) in
        {1523}let v_497: bool = (not-caught-fail(v_496) && success?(1-proj-2-tuple(v_496))) in
        {1524}let my_private_key_15: key = (if v_497 then 2-proj-2-tuple(v_496) else caught-fail) in
        {1525}let my_public_key_15: key = (if v_497 then 1-proj-2-tuple(v_496) else caught-fail) in
        {1526}let input_key_material_18: key = (if v_495 then catch-fail((if v_497 then dhexp(my_private_key_15,re_20) else fail-any)) else caught-fail) in
        {1527}let v_498: bool = not-caught-fail(input_key_material_18) in
        {1528}let v_499: bitstring = (if v_498 then catch-fail(symmetricstateunpack(ss_82)) else caught-fail) in
        {1529}let v_500: bool = (not-caught-fail(v_499) && success?(1-proj-3-tuple(v_499))) in
        {1530}let h_73: bitstring = (if v_500 then 3-proj-3-tuple(v_499) else caught-fail) in
        {1531}let ck_88: key = (if v_500 then 2-proj-3-tuple(v_499) else caught-fail) in
        {1532}let cs_73: cipherstate = (if v_500 then 1-proj-3-tuple(v_499) else caught-fail) in
        {1533}let output1_18: key = (if v_500 then hmac_hash1(ck_88,input_key_material_18) else caught-fail) in
        {1534}let output2_18: key = (if v_500 then hmac_hash2(ck_88,input_key_material_18) else caught-fail) in
        {1535}let output3_18: key = (if v_500 then hmac_hash3(ck_88,input_key_material_18) else caught-fail) in
        {1536}let v_501: bitstring = (if v_500 then catch-fail((output1_18,output2_18,output3_18)) else caught-fail) in
        {1537}let v_502: bool = (not-caught-fail(v_501) && success?(1-proj-3-tuple(v_501))) in
        {1538}let output_15: key = (if v_502 then 3-proj-3-tuple(v_501) else caught-fail) in
        {1539}let temp_k_15: key = (if v_502 then 2-proj-3-tuple(v_501) else caught-fail) in
        {1540}let ck_89: key = (if v_502 then 1-proj-3-tuple(v_501) else caught-fail) in
        {1541}let ss_83: symmetricstate = (if v_495 then catch-fail((if v_498 then (if v_500 then (if v_502 then symmetricstatepack(cipherstatepack(temp_k_15,minnonce),ck_89,h_73) else fail-any) else fail-any) else fail-any)) else caught-fail) in
        {1542}let v_503: bool = not-caught-fail(ss_83) in
        {1543}let v_504: bitstring = (if v_503 then catch-fail(keypairunpack(s_16)) else caught-fail) in
        {1544}let v_505: bool = (not-caught-fail(v_504) && success?(1-proj-2-tuple(v_504))) in
        {1545}let my_private_key_16: key = (if v_505 then 2-proj-2-tuple(v_504) else caught-fail) in
        {1546}let my_public_key_16: key = (if v_505 then 1-proj-2-tuple(v_504) else caught-fail) in
        {1547}let input_key_material_19: key = (if v_503 then catch-fail((if v_505 then dhexp(my_private_key_16,rm_16) else fail-any)) else caught-fail) in
        {1548}let v_506: bool = not-caught-fail(input_key_material_19) in
        {1549}let v_507: bitstring = (if v_506 then catch-fail(symmetricstateunpack(ss_83)) else caught-fail) in
        {1550}let v_508: bool = (not-caught-fail(v_507) && success?(1-proj-3-tuple(v_507))) in
        {1551}let h_74: bitstring = (if v_508 then 3-proj-3-tuple(v_507) else caught-fail) in
        {1552}let ck_90: key = (if v_508 then 2-proj-3-tuple(v_507) else caught-fail) in
        {1553}let cs_74: cipherstate = (if v_508 then 1-proj-3-tuple(v_507) else caught-fail) in
        {1554}let output1_19: key = (if v_508 then hmac_hash1(ck_90,input_key_material_19) else caught-fail) in
        {1555}let output2_19: key = (if v_508 then hmac_hash2(ck_90,input_key_material_19) else caught-fail) in
        {1556}let output3_19: key = (if v_508 then hmac_hash3(ck_90,input_key_material_19) else caught-fail) in
        {1557}let v_509: bitstring = (if v_508 then catch-fail((output1_19,output2_19,output3_19)) else caught-fail) in
        {1558}let v_510: bool = (not-caught-fail(v_509) && success?(1-proj-3-tuple(v_509))) in
        {1559}let output_16: key = (if v_510 then 3-proj-3-tuple(v_509) else caught-fail) in
        {1560}let temp_k_16: key = (if v_510 then 2-proj-3-tuple(v_509) else caught-fail) in
        {1561}let ck_91: key = (if v_510 then 1-proj-3-tuple(v_509) else caught-fail) in
        {1562}let ss_84: symmetricstate = (if v_503 then catch-fail((if v_506 then (if v_508 then (if v_510 then symmetricstatepack(cipherstatepack(temp_k_16,minnonce),ck_91,h_74) else fail-any) else fail-any) else fail-any)) else caught-fail) in
        {1563}let v_511: bool = not-caught-fail(ss_84) in
        {1564}let v_512: bitstring = (if v_511 then catch-fail(symmetricstateunpack(ss_84)) else caught-fail) in
        {1565}let v_513: bool = (not-caught-fail(v_512) && success?(1-proj-3-tuple(v_512))) in
        {1566}let h_75: bitstring = (if v_513 then 3-proj-3-tuple(v_512) else caught-fail) in
        {1567}let ck_92: key = (if v_513 then 2-proj-3-tuple(v_512) else caught-fail) in
        {1568}let cs_75: cipherstate = (if v_513 then 1-proj-3-tuple(v_512) else caught-fail) in
        {1569}let v_514: bitstring = (if v_513 then catch-fail(cipherstateunpack(cs_75)) else caught-fail) in
        {1570}let v_515: bool = (not-caught-fail(v_514) && success?(1-proj-2-tuple(v_514))) in
        {1571}let n_24: nonce = (if v_515 then 2-proj-2-tuple(v_514) else caught-fail) in
        {1572}let k_28: key = (if v_515 then 1-proj-2-tuple(v_514) else caught-fail) in
        {1573}let d_6: aead = (if v_515 then catch-fail(decrypt(k_28,n_24,h_75,ciphertext_24)) else caught-fail) in
        {1574}let v_516: bool = not-caught-fail(d_6) in
        {1575}let v_517: bitstring = (if v_516 then catch-fail(aeadunpack(d_6)) else caught-fail) in
        {1576}let v_518: bool = (not-caught-fail(v_517) && success?(1-proj-3-tuple(v_517))) in
        {1577}let plaintext_18: bitstring = (if v_518 then 3-proj-3-tuple(v_517) else caught-fail) in
        {1578}let adi_6: bitstring = (if v_518 then 2-proj-3-tuple(v_517) else caught-fail) in
        {1579}let valid_18: bool = (if v_518 then 1-proj-3-tuple(v_517) else caught-fail) in
        {1580}let n_25: nonce = (if v_518 then increment_nonce(n_24) else caught-fail) in
        {1581}let v_519: bitstring = (if v_518 then catch-fail(cipherstateunpack(cs_75)) else caught-fail) in
        {1582}let v_520: bool = (not-caught-fail(v_519) && success?(1-proj-2-tuple(v_519))) in
        {1583}let o_12: nonce = (if v_520 then 2-proj-2-tuple(v_519) else caught-fail) in
        {1584}let k_29: key = (if v_520 then 1-proj-2-tuple(v_519) else caught-fail) in
        {1585}let csi_24: cipherstate = (if v_518 then catch-fail((if v_520 then cipherstatepack(k_29,n_25) else fail-any)) else caught-fail) in
        {1586}let v_521: bool = not-caught-fail(csi_24) in
        {1587}let v_522: bitstring = (if v_513 then catch-fail((if v_515 then (if v_516 then (if v_518 then (if v_521 then (csi_24,plaintext_18,valid_18) else fail-any) else fail-any) else fail-any) else fail-any)) else caught-fail) in
        {1588}let v_523: bool = (not-caught-fail(v_522) && success?(1-proj-3-tuple(v_522))) in
        {1589}let valid_19: bool = (if v_523 then 3-proj-3-tuple(v_522) else caught-fail) in
        {1590}let plaintext_19: bitstring = (if v_523 then 2-proj-3-tuple(v_522) else caught-fail) in
        {1591}let csi_25: cipherstate = (if v_523 then 1-proj-3-tuple(v_522) else caught-fail) in
        {1592}let ss_85: symmetricstate = (if v_523 then symmetricstatepack(csi_25,ck_92,h_75) else caught-fail) in
        {1593}let v_524: bitstring = (if v_523 then catch-fail(symmetricstateunpack(ss_85)) else caught-fail) in
        {1594}let v_525: bool = (not-caught-fail(v_524) && success?(1-proj-3-tuple(v_524))) in
        {1595}let h_76: bitstring = (if v_525 then 3-proj-3-tuple(v_524) else caught-fail) in
        {1596}let ck_93: key = (if v_525 then 2-proj-3-tuple(v_524) else caught-fail) in
        {1597}let cs_76: cipherstate = (if v_525 then 1-proj-3-tuple(v_524) else caught-fail) in
        {1598}let ssi_15: symmetricstate = (if v_523 then catch-fail((if v_525 then symmetricstatepack(cs_76,ck_93,hash(h_76,ciphertext_24)) else fail-any)) else caught-fail) in
        {1599}let v_526: bool = not-caught-fail(ssi_15) in
        {1600}let v_527: bitstring = (if v_511 then catch-fail((if v_513 then (if v_523 then (if v_526 then (ssi_15,plaintext_19,valid_19) else fail-any) else fail-any) else fail-any)) else caught-fail) in
        {1601}let v_528: bool = (not-caught-fail(v_527) && success?(1-proj-3-tuple(v_527))) in
        {1602}let valid2_6: bool = (if v_528 then 3-proj-3-tuple(v_527) else caught-fail) in
        {1603}let plaintext_20: bitstring = (if v_528 then 2-proj-3-tuple(v_527) else caught-fail) in
        {1604}let ss_86: symmetricstate = (if v_528 then 1-proj-3-tuple(v_527) else caught-fail) in
        {1605}let v_529: bool = (if v_528 then catch-fail((valid1_6 && valid2_6)) else caught-fail) in
        {1606}let hs_47: handshakestate = (if v_529 then handshakestatepack(ss_86,s_16,m_16,e_25,rs_16,rm_16,re_20,psk_16,initiator_13) else caught-fail) in
        {1607}let (hs_48: handshakestate,plaintext_a_1: bitstring,valid_20: bool) = (if v_490 then (if v_492 then (if v_495 then (if v_503 then (if v_511 then (if v_528 then (if undo-catch-fail(v_529) then (hs_47,plaintext_20,true) else fail-any) else fail-any) else fail-any) else fail-any) else fail-any) else fail-any) else fail-any) in
        {1608}event RecvMsg(me_3,them_3,stagepack_a(sid_4),plaintext_a_1);
        {1609}insert statestore(me_3,them_3,sid_4,statepack_b(hs_48))
    ) | (
        {1765}get statestore(=me_3,=them_3,=sid_4,statepack_b(hs_49: handshakestate)) in
        {1611}let payload_6: bitstring = msg_b(me_3,them_3,sid_4) in
        {1612}let v_530: bitstring = catch-fail(handshakestateunpack(hs_49)) in
        {1613}let v_531: bool = (not-caught-fail(v_530) && success?(1-proj-9-tuple(v_530))) in
        {1614}let initiator_14: bool = (if v_531 then 9-proj-9-tuple(v_530) else caught-fail) in
        {1615}let psk_17: key = (if v_531 then 8-proj-9-tuple(v_530) else caught-fail) in
        {1616}let re_21: key = (if v_531 then 7-proj-9-tuple(v_530) else caught-fail) in
        {1617}let rm_17: key = (if v_531 then 6-proj-9-tuple(v_530) else caught-fail) in
        {1618}let rs_17: key = (if v_531 then 5-proj-9-tuple(v_530) else caught-fail) in
        {1619}let e_26: keypair = (if v_531 then 4-proj-9-tuple(v_530) else caught-fail) in
        {1620}let m_17: keypair = (if v_531 then 3-proj-9-tuple(v_530) else caught-fail) in
        {1621}let s_17: keypair = (if v_531 then 2-proj-9-tuple(v_530) else caught-fail) in
        {1622}let ss_87: symmetricstate = (if v_531 then 1-proj-9-tuple(v_530) else caught-fail) in
        {1623}let v_532: bitstring = (if v_531 then catch-fail((empty,empty,empty)) else caught-fail) in
        {1624}let v_533: bool = (not-caught-fail(v_532) && success?(1-proj-3-tuple(v_532))) in
        {1625}let ciphertext_25: bitstring = (if v_533 then 3-proj-3-tuple(v_532) else caught-fail) in
        {1626}let ns_13: bitstring = (if v_533 then 2-proj-3-tuple(v_532) else caught-fail) in
        {1627}let ne_16: bitstring = (if v_533 then 1-proj-3-tuple(v_532) else caught-fail) in
        {1628}let basis_19: key = (if v_533 then key_e(me_3,them_3,sid_4) else caught-fail) in
        {1629}let public_key_19: key = (if v_533 then catch-fail(dhexp(basis_19,validkey(g))) else caught-fail) in
        {1630}let v_534: bool = not-caught-fail(public_key_19) in
        {1631}let e_27: keypair = (if v_533 then catch-fail((if v_534 then keypairpack(validkey(public_key_19),basis_19) else fail-any)) else caught-fail) in
        {1632}let v_535: bool = not-caught-fail(e_27) in
        {1633}let ne_17: bitstring = (if v_535 then catch-fail(getpublickey(e_27)) else caught-fail) in
        {1634}let v_536: bool = not-caught-fail(ne_17) in
        {1635}let v_537: bitstring = (if v_536 then catch-fail(symmetricstateunpack(ss_87)) else caught-fail) in
        {1636}let v_538: bool = (not-caught-fail(v_537) && success?(1-proj-3-tuple(v_537))) in
        {1637}let h_77: bitstring = (if v_538 then 3-proj-3-tuple(v_537) else caught-fail) in
        {1638}let ck_94: key = (if v_538 then 2-proj-3-tuple(v_537) else caught-fail) in
        {1639}let cs_77: cipherstate = (if v_538 then 1-proj-3-tuple(v_537) else caught-fail) in
        {1640}let ss_88: symmetricstate = (if v_536 then catch-fail((if v_538 then symmetricstatepack(cs_77,ck_94,hash(h_77,ne_17)) else fail-any)) else caught-fail) in
        {1641}let v_539: bool = not-caught-fail(ss_88) in
        {1642}let v_540: bitstring = (if v_539 then catch-fail(keypairunpack(e_27)) else caught-fail) in
        {1643}let v_541: bool = (not-caught-fail(v_540) && success?(1-proj-2-tuple(v_540))) in
        {1644}let my_private_key_17: key = (if v_541 then 2-proj-2-tuple(v_540) else caught-fail) in
        {1645}let my_public_key_17: key = (if v_541 then 1-proj-2-tuple(v_540) else caught-fail) in
        {1646}let input_key_material_20: key = (if v_539 then catch-fail((if v_541 then dhexp(my_private_key_17,re_21) else fail-any)) else caught-fail) in
        {1647}let v_542: bool = not-caught-fail(input_key_material_20) in
        {1648}let v_543: bitstring = (if v_542 then catch-fail(symmetricstateunpack(ss_88)) else caught-fail) in
        {1649}let v_544: bool = (not-caught-fail(v_543) && success?(1-proj-3-tuple(v_543))) in
        {1650}let h_78: bitstring = (if v_544 then 3-proj-3-tuple(v_543) else caught-fail) in
        {1651}let ck_95: key = (if v_544 then 2-proj-3-tuple(v_543) else caught-fail) in
        {1652}let cs_78: cipherstate = (if v_544 then 1-proj-3-tuple(v_543) else caught-fail) in
        {1653}let output1_20: key = (if v_544 then hmac_hash1(ck_95,input_key_material_20) else caught-fail) in
        {1654}let output2_20: key = (if v_544 then hmac_hash2(ck_95,input_key_material_20) else caught-fail) in
        {1655}let output3_20: key = (if v_544 then hmac_hash3(ck_95,input_key_material_20) else caught-fail) in
        {1656}let v_545: bitstring = (if v_544 then catch-fail((output1_20,output2_20,output3_20)) else caught-fail) in
        {1657}let v_546: bool = (not-caught-fail(v_545) && success?(1-proj-3-tuple(v_545))) in
        {1658}let output_17: key = (if v_546 then 3-proj-3-tuple(v_545) else caught-fail) in
        {1659}let temp_k_17: key = (if v_546 then 2-proj-3-tuple(v_545) else caught-fail) in
        {1660}let ck_96: key = (if v_546 then 1-proj-3-tuple(v_545) else caught-fail) in
        {1661}let ss_89: symmetricstate = (if v_539 then catch-fail((if v_542 then (if v_544 then (if v_546 then symmetricstatepack(cipherstatepack(temp_k_17,minnonce),ck_96,h_78) else fail-any) else fail-any) else fail-any)) else caught-fail) in
        {1662}let v_547: bool = not-caught-fail(ss_89) in
        {1663}let v_548: bitstring = (if v_547 then catch-fail(keypairunpack(e_27)) else caught-fail) in
        {1664}let v_549: bool = (not-caught-fail(v_548) && success?(1-proj-2-tuple(v_548))) in
        {1665}let my_private_key_18: key = (if v_549 then 2-proj-2-tuple(v_548) else caught-fail) in
        {1666}let my_public_key_18: key = (if v_549 then 1-proj-2-tuple(v_548) else caught-fail) in
        {1667}let input_key_material_21: key = (if v_547 then catch-fail((if v_549 then dhexp(my_private_key_18,rs_17) else fail-any)) else caught-fail) in
        {1668}let v_550: bool = not-caught-fail(input_key_material_21) in
        {1669}let v_551: bitstring = (if v_550 then catch-fail(symmetricstateunpack(ss_89)) else caught-fail) in
        {1670}let v_552: bool = (not-caught-fail(v_551) && success?(1-proj-3-tuple(v_551))) in
        {1671}let h_79: bitstring = (if v_552 then 3-proj-3-tuple(v_551) else caught-fail) in
        {1672}let ck_97: key = (if v_552 then 2-proj-3-tuple(v_551) else caught-fail) in
        {1673}let cs_79: cipherstate = (if v_552 then 1-proj-3-tuple(v_551) else caught-fail) in
        {1674}let output1_21: key = (if v_552 then hmac_hash1(ck_97,input_key_material_21) else caught-fail) in
        {1675}let output2_21: key = (if v_552 then hmac_hash2(ck_97,input_key_material_21) else caught-fail) in
        {1676}let output3_21: key = (if v_552 then hmac_hash3(ck_97,input_key_material_21) else caught-fail) in
        {1677}let v_553: bitstring = (if v_552 then catch-fail((output1_21,output2_21,output3_21)) else caught-fail) in
        {1678}let v_554: bool = (not-caught-fail(v_553) && success?(1-proj-3-tuple(v_553))) in
        {1679}let output_18: key = (if v_554 then 3-proj-3-tuple(v_553) else caught-fail) in
        {1680}let temp_k_18: key = (if v_554 then 2-proj-3-tuple(v_553) else caught-fail) in
        {1681}let ck_98: key = (if v_554 then 1-proj-3-tuple(v_553) else caught-fail) in
        {1682}let ss_90: symmetricstate = (if v_547 then catch-fail((if v_550 then (if v_552 then (if v_554 then symmetricstatepack(cipherstatepack(temp_k_18,minnonce),ck_98,h_79) else fail-any) else fail-any) else fail-any)) else caught-fail) in
        {1683}let v_555: bool = not-caught-fail(ss_90) in
        {1684}let v_556: bitstring = (if v_555 then catch-fail(keypairunpack(e_27)) else caught-fail) in
        {1685}let v_557: bool = (not-caught-fail(v_556) && success?(1-proj-2-tuple(v_556))) in
        {1686}let my_private_key_19: key = (if v_557 then 2-proj-2-tuple(v_556) else caught-fail) in
        {1687}let my_public_key_19: key = (if v_557 then 1-proj-2-tuple(v_556) else caught-fail) in
        {1688}let input_key_material_22: key = (if v_555 then catch-fail((if v_557 then dhexp(my_private_key_19,rm_17) else fail-any)) else caught-fail) in
        {1689}let v_558: bool = not-caught-fail(input_key_material_22) in
        {1690}let v_559: bitstring = (if v_558 then catch-fail(symmetricstateunpack(ss_90)) else caught-fail) in
        {1691}let v_560: bool = (not-caught-fail(v_559) && success?(1-proj-3-tuple(v_559))) in
        {1692}let h_80: bitstring = (if v_560 then 3-proj-3-tuple(v_559) else caught-fail) in
        {1693}let ck_99: key = (if v_560 then 2-proj-3-tuple(v_559) else caught-fail) in
        {1694}let cs_80: cipherstate = (if v_560 then 1-proj-3-tuple(v_559) else caught-fail) in
        {1695}let output1_22: key = (if v_560 then hmac_hash1(ck_99,input_key_material_22) else caught-fail) in
        {1696}let output2_22: key = (if v_560 then hmac_hash2(ck_99,input_key_material_22) else caught-fail) in
        {1697}let output3_22: key = (if v_560 then hmac_hash3(ck_99,input_key_material_22) else caught-fail) in
        {1698}let v_561: bitstring = (if v_560 then catch-fail((output1_22,output2_22,output3_22)) else caught-fail) in
        {1699}let v_562: bool = (not-caught-fail(v_561) && success?(1-proj-3-tuple(v_561))) in
        {1700}let output_19: key = (if v_562 then 3-proj-3-tuple(v_561) else caught-fail) in
        {1701}let temp_k_19: key = (if v_562 then 2-proj-3-tuple(v_561) else caught-fail) in
        {1702}let ck_100: key = (if v_562 then 1-proj-3-tuple(v_561) else caught-fail) in
        {1703}let ss_91: symmetricstate = (if v_555 then catch-fail((if v_558 then (if v_560 then (if v_562 then symmetricstatepack(cipherstatepack(temp_k_19,minnonce),ck_100,h_80) else fail-any) else fail-any) else fail-any)) else caught-fail) in
        {1704}let v_563: bool = not-caught-fail(ss_91) in
        {1705}let v_564: bitstring = (if v_563 then catch-fail(symmetricstateunpack(ss_91)) else caught-fail) in
        {1706}let v_565: bool = (not-caught-fail(v_564) && success?(1-proj-3-tuple(v_564))) in
        {1707}let h_81: bitstring = (if v_565 then 3-proj-3-tuple(v_564) else caught-fail) in
        {1708}let ck_101: key = (if v_565 then 2-proj-3-tuple(v_564) else caught-fail) in
        {1709}let cs_81: cipherstate = (if v_565 then 1-proj-3-tuple(v_564) else caught-fail) in
        {1710}let v_566: bitstring = (if v_565 then catch-fail(cipherstateunpack(cs_81)) else caught-fail) in
        {1711}let v_567: bool = (not-caught-fail(v_566) && success?(1-proj-2-tuple(v_566))) in
        {1712}let n_26: nonce = (if v_567 then 2-proj-2-tuple(v_566) else caught-fail) in
        {1713}let k_30: key = (if v_567 then 1-proj-2-tuple(v_566) else caught-fail) in
        {1714}let e_28: bitstring = (if v_567 then encrypt(k_30,n_26,h_81,payload_6) else caught-fail) in
        {1715}let n_27: nonce = (if v_567 then increment_nonce(n_26) else caught-fail) in
        {1716}let v_568: bitstring = (if v_567 then catch-fail(cipherstateunpack(cs_81)) else caught-fail) in
        {1717}let v_569: bool = (not-caught-fail(v_568) && success?(1-proj-2-tuple(v_568))) in
        {1718}let o_13: nonce = (if v_569 then 2-proj-2-tuple(v_568) else caught-fail) in
        {1719}let k_31: key = (if v_569 then 1-proj-2-tuple(v_568) else caught-fail) in
        {1720}let csi_26: cipherstate = (if v_567 then catch-fail((if v_569 then cipherstatepack(k_31,n_27) else fail-any)) else caught-fail) in
        {1721}let v_570: bool = not-caught-fail(csi_26) in
        {1722}let v_571: bitstring = (if v_565 then catch-fail((if v_567 then (if v_570 then (csi_26,e_28) else fail-any) else fail-any)) else caught-fail) in
        {1723}let v_572: bool = (not-caught-fail(v_571) && success?(1-proj-2-tuple(v_571))) in
        {1724}let ciphertext_26: bitstring = (if v_572 then 2-proj-2-tuple(v_571) else caught-fail) in
        {1725}let csi_27: cipherstate = (if v_572 then 1-proj-2-tuple(v_571) else caught-fail) in
        {1726}let ss_92: symmetricstate = (if v_572 then symmetricstatepack(csi_27,ck_101,h_81) else caught-fail) in
        {1727}let v_573: bitstring = (if v_572 then catch-fail(symmetricstateunpack(ss_92)) else caught-fail) in
        {1728}let v_574: bool = (not-caught-fail(v_573) && success?(1-proj-3-tuple(v_573))) in
        {1729}let h_82: bitstring = (if v_574 then 3-proj-3-tuple(v_573) else caught-fail) in
        {1730}let ck_102: key = (if v_574 then 2-proj-3-tuple(v_573) else caught-fail) in
        {1731}let cs_82: cipherstate = (if v_574 then 1-proj-3-tuple(v_573) else caught-fail) in
        {1732}let ssi_16: symmetricstate = (if v_572 then catch-fail((if v_574 then symmetricstatepack(cs_82,ck_102,hash(h_82,ciphertext_26)) else fail-any)) else caught-fail) in
        {1733}let v_575: bool = not-caught-fail(ssi_16) in
        {1734}let v_576: bitstring = (if v_563 then catch-fail((if v_565 then (if v_572 then (if v_575 then (ssi_16,ciphertext_26) else fail-any) else fail-any) else fail-any)) else caught-fail) in
        {1735}let v_577: bool = (not-caught-fail(v_576) && success?(1-proj-2-tuple(v_576))) in
        {1736}let ciphertext_27: bitstring = (if v_577 then 2-proj-2-tuple(v_576) else caught-fail) in
        {1737}let ss_93: symmetricstate = (if v_577 then 1-proj-2-tuple(v_576) else caught-fail) in
        {1738}let hs_50: handshakestate = (if v_577 then handshakestatepack(ss_93,s_17,m_17,e_27,rs_17,rm_17,re_21,psk_17,initiator_14) else caught-fail) in
        {1739}let message_buffer_6: bitstring = (if v_577 then concat3(ne_17,ns_13,ciphertext_27) else caught-fail) in
        {1740}let v_578: bitstring = (if v_577 then catch-fail(symmetricstateunpack(ss_93)) else caught-fail) in
        {1741}let v_579: bool = (not-caught-fail(v_578) && success?(1-proj-3-tuple(v_578))) in
        {1742}let h_83: bitstring = (if v_579 then 3-proj-3-tuple(v_578) else caught-fail) in
        {1743}let ck_103: key = (if v_579 then 2-proj-3-tuple(v_578) else caught-fail) in
        {1744}let cs_83: cipherstate = (if v_579 then 1-proj-3-tuple(v_578) else caught-fail) in
        {1745}let input_key_material_23: key = (if v_579 then zero else caught-fail) in
        {1746}let output1_23: key = (if v_579 then hmac_hash1(ck_103,input_key_material_23) else caught-fail) in
        {1747}let output2_23: key = (if v_579 then hmac_hash2(ck_103,input_key_material_23) else caught-fail) in
        {1748}let output3_23: key = (if v_579 then hmac_hash3(ck_103,input_key_material_23) else caught-fail) in
        {1749}let v_580: bitstring = (if v_579 then catch-fail((output1_23,output2_23,output3_23)) else caught-fail) in
        {1750}let v_581: bool = (not-caught-fail(v_580) && success?(1-proj-3-tuple(v_580))) in
        {1751}let temp_k3_3: key = (if v_581 then 3-proj-3-tuple(v_580) else caught-fail) in
        {1752}let temp_k2_3: key = (if v_581 then 2-proj-3-tuple(v_580) else caught-fail) in
        {1753}let temp_k1_3: key = (if v_581 then 1-proj-3-tuple(v_580) else caught-fail) in
        {1754}let cs1_15: cipherstate = (if v_581 then cipherstatepack(temp_k1_3,minnonce) else caught-fail) in
        {1755}let cs2_15: cipherstate = (if v_581 then cipherstatepack(temp_k2_3,minnonce) else caught-fail) in
        {1756}let v_582: bitstring = (if v_577 then catch-fail((if v_579 then (if v_581 then (ss_93,cs1_15,cs2_15) else fail-any) else fail-any)) else caught-fail) in
        {1757}let v_583: bool = (not-caught-fail(v_582) && success?(1-proj-3-tuple(v_582))) in
        {1758}let cs2_16: cipherstate = (if v_583 then 3-proj-3-tuple(v_582) else caught-fail) in
        {1759}let cs1_16: cipherstate = (if v_583 then 2-proj-3-tuple(v_582) else caught-fail) in
        {1760}let ssi_17: symmetricstate = (if v_583 then 1-proj-3-tuple(v_582) else caught-fail) in
        {1761}let (hs_51: handshakestate,message_b_3: bitstring,cs1_17: cipherstate,cs2_17: cipherstate) = (if v_531 then (if v_533 then (if v_535 then (if v_536 then (if v_539 then (if v_547 then (if v_555 then (if v_563 then (if v_577 then (if v_583 then (hs_50,message_buffer_6,cs1_16,cs2_16) else fail-any) else fail-any) else fail-any) else fail-any) else fail-any) else fail-any) else fail-any) else fail-any) else fail-any) else fail-any) in
        {1762}event SendMsg(me_3,them_3,stagepack_b(sid_4),msg_b(me_3,them_3,sid_4));
        {1763}insert statestore(me_3,them_3,sid_4,statepack_c(hs_51,cs1_17,cs2_17));
        {1764}out(pub, message_b_3)
    ) | (
        {1766}!
        {1832}get statestore(=me_3,=them_3,=sid_4,statepack_c(hs_52: handshakestate,cs1_18: cipherstate,cs2_18: cipherstate)) in
        {1767}let hs_53: handshakestate = handshakestatesetcs(hs_52,cs1_18) in
        {1768}in(pub, message_c_3: bitstring);
        {1769}let v_584: bitstring = catch-fail(handshakestateunpack(hs_53)) in
        {1770}let v_585: bool = (not-caught-fail(v_584) && success?(1-proj-9-tuple(v_584))) in
        {1771}let initiator_15: bool = (if v_585 then 9-proj-9-tuple(v_584) else caught-fail) in
        {1772}let psk_18: key = (if v_585 then 8-proj-9-tuple(v_584) else caught-fail) in
        {1773}let re_22: key = (if v_585 then 7-proj-9-tuple(v_584) else caught-fail) in
        {1774}let rm_18: key = (if v_585 then 6-proj-9-tuple(v_584) else caught-fail) in
        {1775}let rs_18: key = (if v_585 then 5-proj-9-tuple(v_584) else caught-fail) in
        {1776}let e_29: keypair = (if v_585 then 4-proj-9-tuple(v_584) else caught-fail) in
        {1777}let m_18: keypair = (if v_585 then 3-proj-9-tuple(v_584) else caught-fail) in
        {1778}let s_18: keypair = (if v_585 then 2-proj-9-tuple(v_584) else caught-fail) in
        {1779}let ss_94: symmetricstate = (if v_585 then 1-proj-9-tuple(v_584) else caught-fail) in
        {1780}let v_586: bitstring = (if v_585 then catch-fail(deconcat3(message_c_3)) else caught-fail) in
        {1781}let v_587: bool = (not-caught-fail(v_586) && success?(1-proj-3-tuple(v_586))) in
        {1782}let ciphertext_28: bitstring = (if v_587 then 3-proj-3-tuple(v_586) else caught-fail) in
        {1783}let ns_14: bitstring = (if v_587 then 2-proj-3-tuple(v_586) else caught-fail) in
        {1784}let ne_18: bitstring = (if v_587 then 1-proj-3-tuple(v_586) else caught-fail) in
        {1785}let valid1_7: bool = (if v_587 then true else caught-fail) in
        {1786}let v_588: bitstring = (if v_587 then catch-fail(symmetricstateunpack(ss_94)) else caught-fail) in
        {1787}let v_589: bool = (not-caught-fail(v_588) && success?(1-proj-3-tuple(v_588))) in
        {1788}let h_84: bitstring = (if v_589 then 3-proj-3-tuple(v_588) else caught-fail) in
        {1789}let ck_104: key = (if v_589 then 2-proj-3-tuple(v_588) else caught-fail) in
        {1790}let cs_84: cipherstate = (if v_589 then 1-proj-3-tuple(v_588) else caught-fail) in
        {1791}let v_590: bitstring = (if v_589 then catch-fail(cipherstateunpack(cs_84)) else caught-fail) in
        {1792}let v_591: bool = (not-caught-fail(v_590) && success?(1-proj-2-tuple(v_590))) in
        {1793}let n_28: nonce = (if v_591 then 2-proj-2-tuple(v_590) else caught-fail) in
        {1794}let k_32: key = (if v_591 then 1-proj-2-tuple(v_590) else caught-fail) in
        {1795}let d_7: aead = (if v_591 then catch-fail(decrypt(k_32,n_28,h_84,ciphertext_28)) else caught-fail) in
        {1796}let v_592: bool = not-caught-fail(d_7) in
        {1797}let v_593: bitstring = (if v_592 then catch-fail(aeadunpack(d_7)) else caught-fail) in
        {1798}let v_594: bool = (not-caught-fail(v_593) && success?(1-proj-3-tuple(v_593))) in
        {1799}let plaintext_21: bitstring = (if v_594 then 3-proj-3-tuple(v_593) else caught-fail) in
        {1800}let adi_7: bitstring = (if v_594 then 2-proj-3-tuple(v_593) else caught-fail) in
        {1801}let valid_21: bool = (if v_594 then 1-proj-3-tuple(v_593) else caught-fail) in
        {1802}let n_29: nonce = (if v_594 then increment_nonce(n_28) else caught-fail) in
        {1803}let v_595: bitstring = (if v_594 then catch-fail(cipherstateunpack(cs_84)) else caught-fail) in
        {1804}let v_596: bool = (not-caught-fail(v_595) && success?(1-proj-2-tuple(v_595))) in
        {1805}let o_14: nonce = (if v_596 then 2-proj-2-tuple(v_595) else caught-fail) in
        {1806}let k_33: key = (if v_596 then 1-proj-2-tuple(v_595) else caught-fail) in
        {1807}let csi_28: cipherstate = (if v_594 then catch-fail((if v_596 then cipherstatepack(k_33,n_29) else fail-any)) else caught-fail) in
        {1808}let v_597: bool = not-caught-fail(csi_28) in
        {1809}let v_598: bitstring = (if v_589 then catch-fail((if v_591 then (if v_592 then (if v_594 then (if v_597 then (csi_28,plaintext_21,valid_21) else fail-any) else fail-any) else fail-any) else fail-any)) else caught-fail) in
        {1810}let v_599: bool = (not-caught-fail(v_598) && success?(1-proj-3-tuple(v_598))) in
        {1811}let valid_22: bool = (if v_599 then 3-proj-3-tuple(v_598) else caught-fail) in
        {1812}let plaintext_22: bitstring = (if v_599 then 2-proj-3-tuple(v_598) else caught-fail) in
        {1813}let csi_29: cipherstate = (if v_599 then 1-proj-3-tuple(v_598) else caught-fail) in
        {1814}let ss_95: symmetricstate = (if v_599 then symmetricstatepack(csi_29,ck_104,h_84) else caught-fail) in
        {1815}let v_600: bitstring = (if v_599 then catch-fail(symmetricstateunpack(ss_95)) else caught-fail) in
        {1816}let v_601: bool = (not-caught-fail(v_600) && success?(1-proj-3-tuple(v_600))) in
        {1817}let h_85: bitstring = (if v_601 then 3-proj-3-tuple(v_600) else caught-fail) in
        {1818}let ck_105: key = (if v_601 then 2-proj-3-tuple(v_600) else caught-fail) in
        {1819}let cs_85: cipherstate = (if v_601 then 1-proj-3-tuple(v_600) else caught-fail) in
        {1820}let ssi_18: symmetricstate = (if v_599 then catch-fail((if v_601 then symmetricstatepack(cs_85,ck_105,hash(h_85,ciphertext_28)) else fail-any)) else caught-fail) in
        {1821}let v_602: bool = not-caught-fail(ssi_18) in
        {1822}let v_603: bitstring = (if v_587 then catch-fail((if v_589 then (if v_599 then (if v_602 then (ssi_18,plaintext_22,valid_22) else fail-any) else fail-any) else fail-any)) else caught-fail) in
        {1823}let v_604: bool = (not-caught-fail(v_603) && success?(1-proj-3-tuple(v_603))) in
        {1824}let valid2_7: bool = (if v_604 then 3-proj-3-tuple(v_603) else caught-fail) in
        {1825}let plaintext_23: bitstring = (if v_604 then 2-proj-3-tuple(v_603) else caught-fail) in
        {1826}let ss_96: symmetricstate = (if v_604 then 1-proj-3-tuple(v_603) else caught-fail) in
        {1827}let v_605: bool = (if v_604 then catch-fail((valid1_7 && valid2_7)) else caught-fail) in
        {1828}let hs_54: handshakestate = (if v_605 then handshakestatepack(ss_96,s_18,m_18,e_29,rs_18,rm_18,re_22,psk_18,initiator_15) else caught-fail) in
        {1829}let (hs_55: handshakestate,plaintext_c_1: bitstring,valid_23: bool) = (if v_585 then (if v_587 then (if v_604 then (if undo-catch-fail(v_605) then (hs_54,plaintext_23,true) else fail-any) else fail-any) else fail-any) else fail-any) in
        {1830}event RecvMsg(me_3,them_3,stagepack_c(sid_4),plaintext_c_1);
        {1831}insert statestore(me_3,them_3,sid_4,statepack_d(hs_55,handshakestategetcs(hs_55),cs2_18))
    ) | (
        {1833}!
        {1890}get statestore(=me_3,=them_3,=sid_4,statepack_d(hs_56: handshakestate,cs1_19: cipherstate,cs2_19: cipherstate)) in
        {1834}let hs_57: handshakestate = handshakestatesetcs(hs_56,cs2_19) in
        {1835}let payload_7: bitstring = msg_d(me_3,them_3,sid_4) in
        {1836}let v_606: bitstring = catch-fail(handshakestateunpack(hs_57)) in
        {1837}let v_607: bool = (not-caught-fail(v_606) && success?(1-proj-9-tuple(v_606))) in
        {1838}let initiator_16: bool = (if v_607 then 9-proj-9-tuple(v_606) else caught-fail) in
        {1839}let psk_19: key = (if v_607 then 8-proj-9-tuple(v_606) else caught-fail) in
        {1840}let re_23: key = (if v_607 then 7-proj-9-tuple(v_606) else caught-fail) in
        {1841}let rm_19: key = (if v_607 then 6-proj-9-tuple(v_606) else caught-fail) in
        {1842}let rs_19: key = (if v_607 then 5-proj-9-tuple(v_606) else caught-fail) in
        {1843}let e_30: keypair = (if v_607 then 4-proj-9-tuple(v_606) else caught-fail) in
        {1844}let m_19: keypair = (if v_607 then 3-proj-9-tuple(v_606) else caught-fail) in
        {1845}let s_19: keypair = (if v_607 then 2-proj-9-tuple(v_606) else caught-fail) in
        {1846}let ss_97: symmetricstate = (if v_607 then 1-proj-9-tuple(v_606) else caught-fail) in
        {1847}let v_608: bitstring = (if v_607 then catch-fail((empty,empty,empty)) else caught-fail) in
        {1848}let v_609: bool = (not-caught-fail(v_608) && success?(1-proj-3-tuple(v_608))) in
        {1849}let ciphertext_29: bitstring = (if v_609 then 3-proj-3-tuple(v_608) else caught-fail) in
        {1850}let ns_15: bitstring = (if v_609 then 2-proj-3-tuple(v_608) else caught-fail) in
        {1851}let ne_19: bitstring = (if v_609 then 1-proj-3-tuple(v_608) else caught-fail) in
        {1852}let v_610: bitstring = (if v_609 then catch-fail(symmetricstateunpack(ss_97)) else caught-fail) in
        {1853}let v_611: bool = (not-caught-fail(v_610) && success?(1-proj-3-tuple(v_610))) in
        {1854}let h_86: bitstring = (if v_611 then 3-proj-3-tuple(v_610) else caught-fail) in
        {1855}let ck_106: key = (if v_611 then 2-proj-3-tuple(v_610) else caught-fail) in
        {1856}let cs_86: cipherstate = (if v_611 then 1-proj-3-tuple(v_610) else caught-fail) in
        {1857}let v_612: bitstring = (if v_611 then catch-fail(cipherstateunpack(cs_86)) else caught-fail) in
        {1858}let v_613: bool = (not-caught-fail(v_612) && success?(1-proj-2-tuple(v_612))) in
        {1859}let n_30: nonce = (if v_613 then 2-proj-2-tuple(v_612) else caught-fail) in
        {1860}let k_34: key = (if v_613 then 1-proj-2-tuple(v_612) else caught-fail) in
        {1861}let e_31: bitstring = (if v_613 then encrypt(k_34,n_30,h_86,payload_7) else caught-fail) in
        {1862}let n_31: nonce = (if v_613 then increment_nonce(n_30) else caught-fail) in
        {1863}let v_614: bitstring = (if v_613 then catch-fail(cipherstateunpack(cs_86)) else caught-fail) in
        {1864}let v_615: bool = (not-caught-fail(v_614) && success?(1-proj-2-tuple(v_614))) in
        {1865}let o_15: nonce = (if v_615 then 2-proj-2-tuple(v_614) else caught-fail) in
        {1866}let k_35: key = (if v_615 then 1-proj-2-tuple(v_614) else caught-fail) in
        {1867}let csi_30: cipherstate = (if v_613 then catch-fail((if v_615 then cipherstatepack(k_35,n_31) else fail-any)) else caught-fail) in
        {1868}let v_616: bool = not-caught-fail(csi_30) in
        {1869}let v_617: bitstring = (if v_611 then catch-fail((if v_613 then (if v_616 then (csi_30,e_31) else fail-any) else fail-any)) else caught-fail) in
        {1870}let v_618: bool = (not-caught-fail(v_617) && success?(1-proj-2-tuple(v_617))) in
        {1871}let ciphertext_30: bitstring = (if v_618 then 2-proj-2-tuple(v_617) else caught-fail) in
        {1872}let csi_31: cipherstate = (if v_618 then 1-proj-2-tuple(v_617) else caught-fail) in
        {1873}let ss_98: symmetricstate = (if v_618 then symmetricstatepack(csi_31,ck_106,h_86) else caught-fail) in
        {1874}let v_619: bitstring = (if v_618 then catch-fail(symmetricstateunpack(ss_98)) else caught-fail) in
        {1875}let v_620: bool = (not-caught-fail(v_619) && success?(1-proj-3-tuple(v_619))) in
        {1876}let h_87: bitstring = (if v_620 then 3-proj-3-tuple(v_619) else caught-fail) in
        {1877}let ck_107: key = (if v_620 then 2-proj-3-tuple(v_619) else caught-fail) in
        {1878}let cs_87: cipherstate = (if v_620 then 1-proj-3-tuple(v_619) else caught-fail) in
        {1879}let ssi_19: symmetricstate = (if v_618 then catch-fail((if v_620 then symmetricstatepack(cs_87,ck_107,hash(h_87,ciphertext_30)) else fail-any)) else caught-fail) in
        {1880}let v_621: bool = not-caught-fail(ssi_19) in
        {1881}let v_622: bitstring = (if v_609 then catch-fail((if v_611 then (if v_618 then (if v_621 then (ssi_19,ciphertext_30) else fail-any) else fail-any) else fail-any)) else caught-fail) in
        {1882}let v_623: bool = (not-caught-fail(v_622) && success?(1-proj-2-tuple(v_622))) in
        {1883}let ciphertext_31: bitstring = (if v_623 then 2-proj-2-tuple(v_622) else caught-fail) in
        {1884}let ss_99: symmetricstate = (if v_623 then 1-proj-2-tuple(v_622) else caught-fail) in
        {1885}let hs_58: handshakestate = (if v_623 then handshakestatepack(ss_99,s_19,m_19,e_30,rs_19,rm_19,re_23,psk_19,initiator_16) else caught-fail) in
        {1886}let message_buffer_7: bitstring = (if v_623 then concat3(ne_19,ns_15,ciphertext_31) else caught-fail) in
        {1887}let (hs_59: handshakestate,message_d_3: bitstring) = (if v_607 then (if v_609 then (if v_623 then (hs_58,message_buffer_7) else fail-any) else fail-any) else fail-any) in
        {1888}event SendMsg(me_3,them_3,stagepack_d(sid_4),msg_d(me_3,them_3,sid_4));
        {1889}out(pub, message_d_3)
    ) | (
        {1891}event LeakS(phase0,me_3);
        {1892}event LeakM(phase0,me_3);
        {1893}out(pub, (key_s(me_3),key_m(me_3)))
    ) | (
        {1894}phase 1;
        {1895}event LeakS(phase1,me_3);
        {1896}event LeakM(phase1,me_3);
        {1897}out(pub, (key_s(me_3),key_m(me_3)))
    )
)

--  Process 1 (that is, process 0, with let moved downwards):
{1}out(pub, (key_s(charlie),key_m(charlie)));
{2}!
{3}new sid: sessionid;
(
    {4}let me: principal = alice in
    {7}let basis: key = key_s(me) in
    {8}let public_key: key = catch-fail(dhexp(basis,validkey(g))) in
    {9}let v: bool = not-caught-fail(public_key) in
    {10}let s: keypair = (if v then keypairpack(validkey(public_key),basis) else fail-any) in
    {11}let basis_1: key = key_m(me) in
    {12}let public_key_1: key = catch-fail(dhexp(basis_1,validkey(g))) in
    {13}let v_1: bool = not-caught-fail(public_key_1) in
    {14}let m: keypair = (if v_1 then keypairpack(validkey(public_key_1),basis_1) else fail-any) in
    {15}out(pub, (getpublickey(s),getpublickey(m)));
    {6}let sid_1: sessionid = sid in
    {5}let them: principal = bob in
    (
        {17}let basis_2: key = key_s(them) in
        {18}let public_key_2: key = catch-fail(dhexp(basis_2,validkey(g))) in
        {19}let v_2: bool = not-caught-fail(public_key_2) in
        {20}let rs: key = getpublickey((if v_2 then keypairpack(validkey(public_key_2),basis_2) else fail-any)) in
        {21}let basis_3: key = key_s(them) in
        {22}let public_key_3: key = catch-fail(dhexp(basis_3,validkey(g))) in
        {23}let v_3: bool = not-caught-fail(public_key_3) in
        {24}let rm: key = getpublickey((if v_3 then keypairpack(validkey(public_key_3),basis_3) else fail-any)) in
        {31}let k: key = empty in
        {32}let cs: cipherstate = cipherstatepack(k,minnonce) in
        {28}let protocol_name: bitstring = somename in
        {29}let h: bitstring = hash(protocol_name,empty) in
        {30}let ck: key = h in
        {33}let ss: symmetricstate = symmetricstatepack(cs,ck,h) in
        {34}let v_4: bitstring = catch-fail(symmetricstateunpack(ss)) in
        {35}let v_5: bool = (not-caught-fail(v_4) && success?(1-proj-3-tuple(v_4))) in
        {36}let h_1: bitstring = (if v_5 then 3-proj-3-tuple(v_4) else caught-fail) in
        {37}let ck_1: key = (if v_5 then 2-proj-3-tuple(v_4) else caught-fail) in
        {38}let cs_1: cipherstate = (if v_5 then 1-proj-3-tuple(v_4) else caught-fail) in
        {26}let prologue: bitstring = empty in
        {39}let ss_1: symmetricstate = catch-fail((if v_5 then symmetricstatepack(cs_1,ck_1,hash(h_1,prologue)) else fail-any)) in
        {40}let v_6: bool = not-caught-fail(ss_1) in
        {41}let data: bitstring = (if v_6 then catch-fail(getpublickey(s)) else caught-fail) in
        {42}let v_7: bool = not-caught-fail(data) in
        {43}let v_8: bitstring = (if v_7 then catch-fail(symmetricstateunpack(ss_1)) else caught-fail) in
        {44}let v_9: bool = (not-caught-fail(v_8) && success?(1-proj-3-tuple(v_8))) in
        {45}let h_2: bitstring = (if v_9 then 3-proj-3-tuple(v_8) else caught-fail) in
        {46}let ck_2: key = (if v_9 then 2-proj-3-tuple(v_8) else caught-fail) in
        {47}let cs_2: cipherstate = (if v_9 then 1-proj-3-tuple(v_8) else caught-fail) in
        {48}let ss_2: symmetricstate = (if v_6 then catch-fail((if v_7 then (if v_9 then symmetricstatepack(cs_2,ck_2,hash(h_2,data)) else fail-any) else fail-any)) else caught-fail) in
        {49}let v_10: bool = not-caught-fail(ss_2) in
        {50}let data_1: bitstring = (if v_10 then catch-fail(getpublickey(m)) else caught-fail) in
        {51}let v_11: bool = not-caught-fail(data_1) in
        {52}let v_12: bitstring = (if v_11 then catch-fail(symmetricstateunpack(ss_2)) else caught-fail) in
        {53}let v_13: bool = (not-caught-fail(v_12) && success?(1-proj-3-tuple(v_12))) in
        {54}let h_3: bitstring = (if v_13 then 3-proj-3-tuple(v_12) else caught-fail) in
        {55}let ck_3: key = (if v_13 then 2-proj-3-tuple(v_12) else caught-fail) in
        {56}let cs_3: cipherstate = (if v_13 then 1-proj-3-tuple(v_12) else caught-fail) in
        {57}let ss_3: symmetricstate = (if v_10 then catch-fail((if v_11 then (if v_13 then symmetricstatepack(cs_3,ck_3,hash(h_3,data_1)) else fail-any) else fail-any)) else caught-fail) in
        {58}let v_14: bool = not-caught-fail(ss_3) in
        {59}let v_15: bitstring = (if v_14 then catch-fail(symmetricstateunpack(ss_3)) else caught-fail) in
        {60}let v_16: bool = (not-caught-fail(v_15) && success?(1-proj-3-tuple(v_15))) in
        {61}let h_4: bitstring = (if v_16 then 3-proj-3-tuple(v_15) else caught-fail) in
        {62}let ck_4: key = (if v_16 then 2-proj-3-tuple(v_15) else caught-fail) in
        {63}let cs_4: cipherstate = (if v_16 then 1-proj-3-tuple(v_15) else caught-fail) in
        {64}let ss_4: symmetricstate = (if v_14 then catch-fail((if v_16 then symmetricstatepack(cs_4,ck_4,hash(h_4,rs)) else fail-any)) else caught-fail) in
        {65}let v_17: bool = not-caught-fail(ss_4) in
        {66}let v_18: bitstring = (if v_17 then catch-fail(symmetricstateunpack(ss_4)) else caught-fail) in
        {67}let v_19: bool = (not-caught-fail(v_18) && success?(1-proj-3-tuple(v_18))) in
        {68}let h_5: bitstring = (if v_19 then 3-proj-3-tuple(v_18) else caught-fail) in
        {69}let ck_5: key = (if v_19 then 2-proj-3-tuple(v_18) else caught-fail) in
        {70}let cs_5: cipherstate = (if v_19 then 1-proj-3-tuple(v_18) else caught-fail) in
        {71}let ss_5: symmetricstate = (if v_17 then catch-fail((if v_19 then symmetricstatepack(cs_5,ck_5,hash(h_5,rm)) else fail-any)) else caught-fail) in
        {72}let v_20: bool = not-caught-fail(ss_5) in
        {27}let psk: key = empty in
        {25}let re: key = empty in
        {16}let e: keypair = keypairpack(empty,empty) in
        {73}let hs: handshakestate = (if v_6 then (if v_10 then (if v_14 then (if v_17 then (if v_20 then handshakestatepack(ss_5,s,m,e,rs,rm,re,psk,true) else fail-any) else fail-any) else fail-any) else fail-any) else fail-any) in
        {74}insert statestore(me,them,sid_1,statepack_a(hs))
    ) | (
        {187}get statestore(=me,=them,=sid_1,statepack_a(hs_1: handshakestate)) in
        {76}let v_21: bitstring = catch-fail(handshakestateunpack(hs_1)) in
        {77}let v_22: bool = (not-caught-fail(v_21) && success?(1-proj-9-tuple(v_21))) in
        {78}let initiator_1: bool = (if v_22 then 9-proj-9-tuple(v_21) else caught-fail) in
        {79}let psk_1: key = (if v_22 then 8-proj-9-tuple(v_21) else caught-fail) in
        {80}let re_1: key = (if v_22 then 7-proj-9-tuple(v_21) else caught-fail) in
        {81}let rm_1: key = (if v_22 then 6-proj-9-tuple(v_21) else caught-fail) in
        {82}let rs_1: key = (if v_22 then 5-proj-9-tuple(v_21) else caught-fail) in
        {83}let e_1: keypair = (if v_22 then 4-proj-9-tuple(v_21) else caught-fail) in
        {84}let m_1: keypair = (if v_22 then 3-proj-9-tuple(v_21) else caught-fail) in
        {85}let s_1: keypair = (if v_22 then 2-proj-9-tuple(v_21) else caught-fail) in
        {86}let ss_6: symmetricstate = (if v_22 then 1-proj-9-tuple(v_21) else caught-fail) in
        {87}let v_23: bitstring = (if v_22 then catch-fail((empty,empty,empty)) else caught-fail) in
        {88}let v_24: bool = (not-caught-fail(v_23) && success?(1-proj-3-tuple(v_23))) in
        {89}let ciphertext: bitstring = (if v_24 then 3-proj-3-tuple(v_23) else caught-fail) in
        {90}let ns: bitstring = (if v_24 then 2-proj-3-tuple(v_23) else caught-fail) in
        {91}let ne: bitstring = (if v_24 then 1-proj-3-tuple(v_23) else caught-fail) in
        {92}let basis_4: key = (if v_24 then key_e(me,them,sid_1) else caught-fail) in
        {93}let public_key_4: key = (if v_24 then catch-fail(dhexp(basis_4,validkey(g))) else caught-fail) in
        {94}let v_25: bool = not-caught-fail(public_key_4) in
        {95}let e_2: keypair = (if v_24 then catch-fail((if v_25 then keypairpack(validkey(public_key_4),basis_4) else fail-any)) else caught-fail) in
        {96}let v_26: bool = not-caught-fail(e_2) in
        {97}let ne_1: bitstring = (if v_26 then catch-fail(getpublickey(e_2)) else caught-fail) in
        {98}let v_27: bool = not-caught-fail(ne_1) in
        {99}let v_28: bitstring = (if v_27 then catch-fail(symmetricstateunpack(ss_6)) else caught-fail) in
        {100}let v_29: bool = (not-caught-fail(v_28) && success?(1-proj-3-tuple(v_28))) in
        {101}let h_6: bitstring = (if v_29 then 3-proj-3-tuple(v_28) else caught-fail) in
        {102}let ck_6: key = (if v_29 then 2-proj-3-tuple(v_28) else caught-fail) in
        {103}let cs_6: cipherstate = (if v_29 then 1-proj-3-tuple(v_28) else caught-fail) in
        {104}let ss_7: symmetricstate = (if v_27 then catch-fail((if v_29 then symmetricstatepack(cs_6,ck_6,hash(h_6,ne_1)) else fail-any)) else caught-fail) in
        {105}let v_30: bool = not-caught-fail(ss_7) in
        {106}let v_31: bitstring = (if v_30 then catch-fail(keypairunpack(e_2)) else caught-fail) in
        {107}let v_32: bool = (not-caught-fail(v_31) && success?(1-proj-2-tuple(v_31))) in
        {108}let my_private_key: key = (if v_32 then 2-proj-2-tuple(v_31) else caught-fail) in
        {109}let my_public_key: key = (if v_32 then 1-proj-2-tuple(v_31) else caught-fail) in
        {110}let input_key_material: key = (if v_30 then catch-fail((if v_32 then dhexp(my_private_key,rm_1) else fail-any)) else caught-fail) in
        {111}let v_33: bool = not-caught-fail(input_key_material) in
        {112}let v_34: bitstring = (if v_33 then catch-fail(symmetricstateunpack(ss_7)) else caught-fail) in
        {113}let v_35: bool = (not-caught-fail(v_34) && success?(1-proj-3-tuple(v_34))) in
        {114}let h_7: bitstring = (if v_35 then 3-proj-3-tuple(v_34) else caught-fail) in
        {115}let ck_7: key = (if v_35 then 2-proj-3-tuple(v_34) else caught-fail) in
        {116}let cs_7: cipherstate = (if v_35 then 1-proj-3-tuple(v_34) else caught-fail) in
        {119}let output3: key = (if v_35 then hmac_hash3(ck_7,input_key_material) else caught-fail) in
        {118}let output2: key = (if v_35 then hmac_hash2(ck_7,input_key_material) else caught-fail) in
        {117}let output1: key = (if v_35 then hmac_hash1(ck_7,input_key_material) else caught-fail) in
        {120}let v_36: bitstring = (if v_35 then catch-fail((output1,output2,output3)) else caught-fail) in
        {121}let v_37: bool = (not-caught-fail(v_36) && success?(1-proj-3-tuple(v_36))) in
        {122}let output_3: key = (if v_37 then 3-proj-3-tuple(v_36) else caught-fail) in
        {123}let temp_k: key = (if v_37 then 2-proj-3-tuple(v_36) else caught-fail) in
        {124}let ck_8: key = (if v_37 then 1-proj-3-tuple(v_36) else caught-fail) in
        {125}let ss_8: symmetricstate = (if v_30 then catch-fail((if v_33 then (if v_35 then (if v_37 then symmetricstatepack(cipherstatepack(temp_k,minnonce),ck_8,h_7) else fail-any) else fail-any) else fail-any)) else caught-fail) in
        {126}let v_38: bool = not-caught-fail(ss_8) in
        {127}let v_39: bitstring = (if v_38 then catch-fail(keypairunpack(m_1)) else caught-fail) in
        {128}let v_40: bool = (not-caught-fail(v_39) && success?(1-proj-2-tuple(v_39))) in
        {129}let my_private_key_1: key = (if v_40 then 2-proj-2-tuple(v_39) else caught-fail) in
        {130}let my_public_key_1: key = (if v_40 then 1-proj-2-tuple(v_39) else caught-fail) in
        {131}let input_key_material_1: key = (if v_38 then catch-fail((if v_40 then dhexp(my_private_key_1,rs_1) else fail-any)) else caught-fail) in
        {132}let v_41: bool = not-caught-fail(input_key_material_1) in
        {133}let v_42: bitstring = (if v_41 then catch-fail(symmetricstateunpack(ss_8)) else caught-fail) in
        {134}let v_43: bool = (not-caught-fail(v_42) && success?(1-proj-3-tuple(v_42))) in
        {135}let h_8: bitstring = (if v_43 then 3-proj-3-tuple(v_42) else caught-fail) in
        {136}let ck_9: key = (if v_43 then 2-proj-3-tuple(v_42) else caught-fail) in
        {137}let cs_8: cipherstate = (if v_43 then 1-proj-3-tuple(v_42) else caught-fail) in
        {140}let output3_1: key = (if v_43 then hmac_hash3(ck_9,input_key_material_1) else caught-fail) in
        {139}let output2_1: key = (if v_43 then hmac_hash2(ck_9,input_key_material_1) else caught-fail) in
        {138}let output1_1: key = (if v_43 then hmac_hash1(ck_9,input_key_material_1) else caught-fail) in
        {141}let v_44: bitstring = (if v_43 then catch-fail((output1_1,output2_1,output3_1)) else caught-fail) in
        {142}let v_45: bool = (not-caught-fail(v_44) && success?(1-proj-3-tuple(v_44))) in
        {143}let output: key = (if v_45 then 3-proj-3-tuple(v_44) else caught-fail) in
        {144}let temp_k_1: key = (if v_45 then 2-proj-3-tuple(v_44) else caught-fail) in
        {145}let ck_10: key = (if v_45 then 1-proj-3-tuple(v_44) else caught-fail) in
        {146}let ss_9: symmetricstate = (if v_38 then catch-fail((if v_41 then (if v_43 then (if v_45 then symmetricstatepack(cipherstatepack(temp_k_1,minnonce),ck_10,h_8) else fail-any) else fail-any) else fail-any)) else caught-fail) in
        {147}let v_46: bool = not-caught-fail(ss_9) in
        {148}let v_47: bitstring = (if v_46 then catch-fail(symmetricstateunpack(ss_9)) else caught-fail) in
        {149}let v_48: bool = (not-caught-fail(v_47) && success?(1-proj-3-tuple(v_47))) in
        {150}let h_9: bitstring = (if v_48 then 3-proj-3-tuple(v_47) else caught-fail) in
        {151}let ck_11: key = (if v_48 then 2-proj-3-tuple(v_47) else caught-fail) in
        {152}let cs_9: cipherstate = (if v_48 then 1-proj-3-tuple(v_47) else caught-fail) in
        {153}let v_49: bitstring = (if v_48 then catch-fail(cipherstateunpack(cs_9)) else caught-fail) in
        {154}let v_50: bool = (not-caught-fail(v_49) && success?(1-proj-2-tuple(v_49))) in
        {155}let n: nonce = (if v_50 then 2-proj-2-tuple(v_49) else caught-fail) in
        {156}let k_1: key = (if v_50 then 1-proj-2-tuple(v_49) else caught-fail) in
        {159}let v_51: bitstring = (if v_50 then catch-fail(cipherstateunpack(cs_9)) else caught-fail) in
        {160}let v_52: bool = (not-caught-fail(v_51) && success?(1-proj-2-tuple(v_51))) in
        {161}let o: nonce = (if v_52 then 2-proj-2-tuple(v_51) else caught-fail) in
        {162}let k_2: key = (if v_52 then 1-proj-2-tuple(v_51) else caught-fail) in
        {158}let n_1: nonce = (if v_50 then increment_nonce(n) else caught-fail) in
        {163}let csi: cipherstate = (if v_50 then catch-fail((if v_52 then cipherstatepack(k_2,n_1) else fail-any)) else caught-fail) in
        {164}let v_53: bool = not-caught-fail(csi) in
        {75}let payload: bitstring = msg_a(me,them,sid_1) in
        {157}let e_3: bitstring = (if v_50 then encrypt(k_1,n,h_9,payload) else caught-fail) in
        {165}let v_54: bitstring = (if v_48 then catch-fail((if v_50 then (if v_53 then (csi,e_3) else fail-any) else fail-any)) else caught-fail) in
        {166}let v_55: bool = (not-caught-fail(v_54) && success?(1-proj-2-tuple(v_54))) in
        {167}let ciphertext_1: bitstring = (if v_55 then 2-proj-2-tuple(v_54) else caught-fail) in
        {168}let csi_1: cipherstate = (if v_55 then 1-proj-2-tuple(v_54) else caught-fail) in
        {169}let ss_10: symmetricstate = (if v_55 then symmetricstatepack(csi_1,ck_11,h_9) else caught-fail) in
        {170}let v_56: bitstring = (if v_55 then catch-fail(symmetricstateunpack(ss_10)) else caught-fail) in
        {171}let v_57: bool = (not-caught-fail(v_56) && success?(1-proj-3-tuple(v_56))) in
        {172}let h_10: bitstring = (if v_57 then 3-proj-3-tuple(v_56) else caught-fail) in
        {173}let ck_12: key = (if v_57 then 2-proj-3-tuple(v_56) else caught-fail) in
        {174}let cs_10: cipherstate = (if v_57 then 1-proj-3-tuple(v_56) else caught-fail) in
        {175}let ssi: symmetricstate = (if v_55 then catch-fail((if v_57 then symmetricstatepack(cs_10,ck_12,hash(h_10,ciphertext_1)) else fail-any)) else caught-fail) in
        {176}let v_58: bool = not-caught-fail(ssi) in
        {177}let v_59: bitstring = (if v_46 then catch-fail((if v_48 then (if v_55 then (if v_58 then (ssi,ciphertext_1) else fail-any) else fail-any) else fail-any)) else caught-fail) in
        {178}let v_60: bool = (not-caught-fail(v_59) && success?(1-proj-2-tuple(v_59))) in
        {179}let ciphertext_2: bitstring = (if v_60 then 2-proj-2-tuple(v_59) else caught-fail) in
        {180}let ss_11: symmetricstate = (if v_60 then 1-proj-2-tuple(v_59) else caught-fail) in
        {182}let message_buffer: bitstring = (if v_60 then concat3(ne_1,ns,ciphertext_2) else caught-fail) in
        {181}let hs_2: handshakestate = (if v_60 then handshakestatepack(ss_11,s_1,m_1,e_2,rs_1,rm_1,re_1,psk_1,initiator_1) else caught-fail) in
        {183}let (hs_3: handshakestate,message_a: bitstring) = (if v_22 then (if v_24 then (if v_26 then (if v_27 then (if v_30 then (if v_38 then (if v_46 then (if v_60 then (hs_2,message_buffer) else fail-any) else fail-any) else fail-any) else fail-any) else fail-any) else fail-any) else fail-any) else fail-any) in
        {184}event SendMsg(me,them,stagepack_a(sid_1),msg_a(me,them,sid_1));
        {185}insert statestore(me,them,sid_1,statepack_b(hs_3));
        {186}out(pub, message_a)
    ) | (
        {344}get statestore(=me,=them,=sid_1,statepack_b(hs_4: handshakestate)) in
        {188}in(pub, message_b: bitstring);
        {189}let v_61: bitstring = catch-fail(handshakestateunpack(hs_4)) in
        {190}let v_62: bool = (not-caught-fail(v_61) && success?(1-proj-9-tuple(v_61))) in
        {191}let initiator_2: bool = (if v_62 then 9-proj-9-tuple(v_61) else caught-fail) in
        {192}let psk_2: key = (if v_62 then 8-proj-9-tuple(v_61) else caught-fail) in
        {193}let re_2: key = (if v_62 then 7-proj-9-tuple(v_61) else caught-fail) in
        {194}let rm_2: key = (if v_62 then 6-proj-9-tuple(v_61) else caught-fail) in
        {195}let rs_2: key = (if v_62 then 5-proj-9-tuple(v_61) else caught-fail) in
        {196}let e_4: keypair = (if v_62 then 4-proj-9-tuple(v_61) else caught-fail) in
        {197}let m_2: keypair = (if v_62 then 3-proj-9-tuple(v_61) else caught-fail) in
        {198}let s_2: keypair = (if v_62 then 2-proj-9-tuple(v_61) else caught-fail) in
        {199}let ss_12: symmetricstate = (if v_62 then 1-proj-9-tuple(v_61) else caught-fail) in
        {200}let v_63: bitstring = (if v_62 then catch-fail(deconcat3(message_b)) else caught-fail) in
        {201}let v_64: bool = (not-caught-fail(v_63) && success?(1-proj-3-tuple(v_63))) in
        {202}let ciphertext_3: bitstring = (if v_64 then 3-proj-3-tuple(v_63) else caught-fail) in
        {203}let ns_1: bitstring = (if v_64 then 2-proj-3-tuple(v_63) else caught-fail) in
        {204}let ne_2: bitstring = (if v_64 then 1-proj-3-tuple(v_63) else caught-fail) in
        {207}let v_65: bitstring = (if v_64 then catch-fail(symmetricstateunpack(ss_12)) else caught-fail) in
        {208}let v_66: bool = (not-caught-fail(v_65) && success?(1-proj-3-tuple(v_65))) in
        {209}let h_11: bitstring = (if v_66 then 3-proj-3-tuple(v_65) else caught-fail) in
        {210}let ck_13: key = (if v_66 then 2-proj-3-tuple(v_65) else caught-fail) in
        {211}let cs_11: cipherstate = (if v_66 then 1-proj-3-tuple(v_65) else caught-fail) in
        {206}let re_3: key = (if v_64 then ne_2 else caught-fail) in
        {212}let ss_13: symmetricstate = (if v_64 then catch-fail((if v_66 then symmetricstatepack(cs_11,ck_13,hash(h_11,re_3)) else fail-any)) else caught-fail) in
        {213}let v_67: bool = not-caught-fail(ss_13) in
        {214}let v_68: bitstring = (if v_67 then catch-fail(keypairunpack(e_4)) else caught-fail) in
        {215}let v_69: bool = (not-caught-fail(v_68) && success?(1-proj-2-tuple(v_68))) in
        {216}let my_private_key_2: key = (if v_69 then 2-proj-2-tuple(v_68) else caught-fail) in
        {217}let my_public_key_2: key = (if v_69 then 1-proj-2-tuple(v_68) else caught-fail) in
        {218}let input_key_material_2: key = (if v_67 then catch-fail((if v_69 then dhexp(my_private_key_2,re_3) else fail-any)) else caught-fail) in
        {219}let v_70: bool = not-caught-fail(input_key_material_2) in
        {220}let v_71: bitstring = (if v_70 then catch-fail(symmetricstateunpack(ss_13)) else caught-fail) in
        {221}let v_72: bool = (not-caught-fail(v_71) && success?(1-proj-3-tuple(v_71))) in
        {222}let h_12: bitstring = (if v_72 then 3-proj-3-tuple(v_71) else caught-fail) in
        {223}let ck_14: key = (if v_72 then 2-proj-3-tuple(v_71) else caught-fail) in
        {224}let cs_12: cipherstate = (if v_72 then 1-proj-3-tuple(v_71) else caught-fail) in
        {227}let output3_2: key = (if v_72 then hmac_hash3(ck_14,input_key_material_2) else caught-fail) in
        {226}let output2_2: key = (if v_72 then hmac_hash2(ck_14,input_key_material_2) else caught-fail) in
        {225}let output1_2: key = (if v_72 then hmac_hash1(ck_14,input_key_material_2) else caught-fail) in
        {228}let v_73: bitstring = (if v_72 then catch-fail((output1_2,output2_2,output3_2)) else caught-fail) in
        {229}let v_74: bool = (not-caught-fail(v_73) && success?(1-proj-3-tuple(v_73))) in
        {230}let output_1: key = (if v_74 then 3-proj-3-tuple(v_73) else caught-fail) in
        {231}let temp_k_2: key = (if v_74 then 2-proj-3-tuple(v_73) else caught-fail) in
        {232}let ck_15: key = (if v_74 then 1-proj-3-tuple(v_73) else caught-fail) in
        {233}let ss_14: symmetricstate = (if v_67 then catch-fail((if v_70 then (if v_72 then (if v_74 then symmetricstatepack(cipherstatepack(temp_k_2,minnonce),ck_15,h_12) else fail-any) else fail-any) else fail-any)) else caught-fail) in
        {234}let v_75: bool = not-caught-fail(ss_14) in
        {235}let v_76: bitstring = (if v_75 then catch-fail(keypairunpack(s_2)) else caught-fail) in
        {236}let v_77: bool = (not-caught-fail(v_76) && success?(1-proj-2-tuple(v_76))) in
        {237}let my_private_key_3: key = (if v_77 then 2-proj-2-tuple(v_76) else caught-fail) in
        {238}let my_public_key_3: key = (if v_77 then 1-proj-2-tuple(v_76) else caught-fail) in
        {239}let input_key_material_3: key = (if v_75 then catch-fail((if v_77 then dhexp(my_private_key_3,re_3) else fail-any)) else caught-fail) in
        {240}let v_78: bool = not-caught-fail(input_key_material_3) in
        {241}let v_79: bitstring = (if v_78 then catch-fail(symmetricstateunpack(ss_14)) else caught-fail) in
        {242}let v_80: bool = (not-caught-fail(v_79) && success?(1-proj-3-tuple(v_79))) in
        {243}let h_13: bitstring = (if v_80 then 3-proj-3-tuple(v_79) else caught-fail) in
        {244}let ck_16: key = (if v_80 then 2-proj-3-tuple(v_79) else caught-fail) in
        {245}let cs_13: cipherstate = (if v_80 then 1-proj-3-tuple(v_79) else caught-fail) in
        {248}let output3_3: key = (if v_80 then hmac_hash3(ck_16,input_key_material_3) else caught-fail) in
        {247}let output2_3: key = (if v_80 then hmac_hash2(ck_16,input_key_material_3) else caught-fail) in
        {246}let output1_3: key = (if v_80 then hmac_hash1(ck_16,input_key_material_3) else caught-fail) in
        {249}let v_81: bitstring = (if v_80 then catch-fail((output1_3,output2_3,output3_3)) else caught-fail) in
        {250}let v_82: bool = (not-caught-fail(v_81) && success?(1-proj-3-tuple(v_81))) in
        {251}let output_2: key = (if v_82 then 3-proj-3-tuple(v_81) else caught-fail) in
        {252}let temp_k_3: key = (if v_82 then 2-proj-3-tuple(v_81) else caught-fail) in
        {253}let ck_17: key = (if v_82 then 1-proj-3-tuple(v_81) else caught-fail) in
        {254}let ss_15: symmetricstate = (if v_75 then catch-fail((if v_78 then (if v_80 then (if v_82 then symmetricstatepack(cipherstatepack(temp_k_3,minnonce),ck_17,h_13) else fail-any) else fail-any) else fail-any)) else caught-fail) in
        {255}let v_83: bool = not-caught-fail(ss_15) in
        {256}let v_84: bitstring = (if v_83 then catch-fail(keypairunpack(m_2)) else caught-fail) in
        {257}let v_85: bool = (not-caught-fail(v_84) && success?(1-proj-2-tuple(v_84))) in
        {258}let my_private_key_4: key = (if v_85 then 2-proj-2-tuple(v_84) else caught-fail) in
        {259}let my_public_key_4: key = (if v_85 then 1-proj-2-tuple(v_84) else caught-fail) in
        {260}let input_key_material_4: key = (if v_83 then catch-fail((if v_85 then dhexp(my_private_key_4,re_3) else fail-any)) else caught-fail) in
        {261}let v_86: bool = not-caught-fail(input_key_material_4) in
        {262}let v_87: bitstring = (if v_86 then catch-fail(symmetricstateunpack(ss_15)) else caught-fail) in
        {263}let v_88: bool = (not-caught-fail(v_87) && success?(1-proj-3-tuple(v_87))) in
        {264}let h_14: bitstring = (if v_88 then 3-proj-3-tuple(v_87) else caught-fail) in
        {265}let ck_18: key = (if v_88 then 2-proj-3-tuple(v_87) else caught-fail) in
        {266}let cs_14: cipherstate = (if v_88 then 1-proj-3-tuple(v_87) else caught-fail) in
        {269}let output3_4: key = (if v_88 then hmac_hash3(ck_18,input_key_material_4) else caught-fail) in
        {268}let output2_4: key = (if v_88 then hmac_hash2(ck_18,input_key_material_4) else caught-fail) in
        {267}let output1_4: key = (if v_88 then hmac_hash1(ck_18,input_key_material_4) else caught-fail) in
        {270}let v_89: bitstring = (if v_88 then catch-fail((output1_4,output2_4,output3_4)) else caught-fail) in
        {271}let v_90: bool = (not-caught-fail(v_89) && success?(1-proj-3-tuple(v_89))) in
        {272}let output_4: key = (if v_90 then 3-proj-3-tuple(v_89) else caught-fail) in
        {273}let temp_k_4: key = (if v_90 then 2-proj-3-tuple(v_89) else caught-fail) in
        {274}let ck_19: key = (if v_90 then 1-proj-3-tuple(v_89) else caught-fail) in
        {275}let ss_16: symmetricstate = (if v_83 then catch-fail((if v_86 then (if v_88 then (if v_90 then symmetricstatepack(cipherstatepack(temp_k_4,minnonce),ck_19,h_14) else fail-any) else fail-any) else fail-any)) else caught-fail) in
        {276}let v_91: bool = not-caught-fail(ss_16) in
        {277}let v_92: bitstring = (if v_91 then catch-fail(symmetricstateunpack(ss_16)) else caught-fail) in
        {278}let v_93: bool = (not-caught-fail(v_92) && success?(1-proj-3-tuple(v_92))) in
        {279}let h_15: bitstring = (if v_93 then 3-proj-3-tuple(v_92) else caught-fail) in
        {280}let ck_20: key = (if v_93 then 2-proj-3-tuple(v_92) else caught-fail) in
        {281}let cs_15: cipherstate = (if v_93 then 1-proj-3-tuple(v_92) else caught-fail) in
        {282}let v_94: bitstring = (if v_93 then catch-fail(cipherstateunpack(cs_15)) else caught-fail) in
        {283}let v_95: bool = (not-caught-fail(v_94) && success?(1-proj-2-tuple(v_94))) in
        {284}let n_2: nonce = (if v_95 then 2-proj-2-tuple(v_94) else caught-fail) in
        {285}let k_3: key = (if v_95 then 1-proj-2-tuple(v_94) else caught-fail) in
        {286}let d: aead = (if v_95 then catch-fail(decrypt(k_3,n_2,h_15,ciphertext_3)) else caught-fail) in
        {287}let v_96: bool = not-caught-fail(d) in
        {288}let v_97: bitstring = (if v_96 then catch-fail(aeadunpack(d)) else caught-fail) in
        {289}let v_98: bool = (not-caught-fail(v_97) && success?(1-proj-3-tuple(v_97))) in
        {290}let plaintext: bitstring = (if v_98 then 3-proj-3-tuple(v_97) else caught-fail) in
        {291}let adi: bitstring = (if v_98 then 2-proj-3-tuple(v_97) else caught-fail) in
        {292}let valid: bool = (if v_98 then 1-proj-3-tuple(v_97) else caught-fail) in
        {294}let v_99: bitstring = (if v_98 then catch-fail(cipherstateunpack(cs_15)) else caught-fail) in
        {295}let v_100: bool = (not-caught-fail(v_99) && success?(1-proj-2-tuple(v_99))) in
        {296}let o_1: nonce = (if v_100 then 2-proj-2-tuple(v_99) else caught-fail) in
        {297}let k_4: key = (if v_100 then 1-proj-2-tuple(v_99) else caught-fail) in
        {293}let n_3: nonce = (if v_98 then increment_nonce(n_2) else caught-fail) in
        {298}let csi_2: cipherstate = (if v_98 then catch-fail((if v_100 then cipherstatepack(k_4,n_3) else fail-any)) else caught-fail) in
        {299}let v_101: bool = not-caught-fail(csi_2) in
        {300}let v_102: bitstring = (if v_93 then catch-fail((if v_95 then (if v_96 then (if v_98 then (if v_101 then (csi_2,plaintext,valid) else fail-any) else fail-any) else fail-any) else fail-any)) else caught-fail) in
        {301}let v_103: bool = (not-caught-fail(v_102) && success?(1-proj-3-tuple(v_102))) in
        {302}let valid_1: bool = (if v_103 then 3-proj-3-tuple(v_102) else caught-fail) in
        {303}let plaintext_1: bitstring = (if v_103 then 2-proj-3-tuple(v_102) else caught-fail) in
        {304}let csi_3: cipherstate = (if v_103 then 1-proj-3-tuple(v_102) else caught-fail) in
        {305}let ss_17: symmetricstate = (if v_103 then symmetricstatepack(csi_3,ck_20,h_15) else caught-fail) in
        {306}let v_104: bitstring = (if v_103 then catch-fail(symmetricstateunpack(ss_17)) else caught-fail) in
        {307}let v_105: bool = (not-caught-fail(v_104) && success?(1-proj-3-tuple(v_104))) in
        {308}let h_16: bitstring = (if v_105 then 3-proj-3-tuple(v_104) else caught-fail) in
        {309}let ck_21: key = (if v_105 then 2-proj-3-tuple(v_104) else caught-fail) in
        {310}let cs_16: cipherstate = (if v_105 then 1-proj-3-tuple(v_104) else caught-fail) in
        {311}let ssi_1: symmetricstate = (if v_103 then catch-fail((if v_105 then symmetricstatepack(cs_16,ck_21,hash(h_16,ciphertext_3)) else fail-any)) else caught-fail) in
        {312}let v_106: bool = not-caught-fail(ssi_1) in
        {313}let v_107: bitstring = (if v_91 then catch-fail((if v_93 then (if v_103 then (if v_106 then (ssi_1,plaintext_1,valid_1) else fail-any) else fail-any) else fail-any)) else caught-fail) in
        {314}let v_108: bool = (not-caught-fail(v_107) && success?(1-proj-3-tuple(v_107))) in
        {315}let valid2: bool = (if v_108 then 3-proj-3-tuple(v_107) else caught-fail) in
        {316}let plaintext_2: bitstring = (if v_108 then 2-proj-3-tuple(v_107) else caught-fail) in
        {317}let ss_18: symmetricstate = (if v_108 then 1-proj-3-tuple(v_107) else caught-fail) in
        {205}let valid1: bool = (if v_64 then true else caught-fail) in
        {318}let v_109: bool = (if v_108 then catch-fail((valid1 && valid2)) else caught-fail) in
        {320}let v_110: bitstring = (if v_109 then catch-fail(symmetricstateunpack(ss_18)) else caught-fail) in
        {321}let v_111: bool = (not-caught-fail(v_110) && success?(1-proj-3-tuple(v_110))) in
        {322}let h_17: bitstring = (if v_111 then 3-proj-3-tuple(v_110) else caught-fail) in
        {323}let ck_22: key = (if v_111 then 2-proj-3-tuple(v_110) else caught-fail) in
        {324}let cs_17: cipherstate = (if v_111 then 1-proj-3-tuple(v_110) else caught-fail) in
        {325}let input_key_material_5: key = (if v_111 then zero else caught-fail) in
        {328}let output3_5: key = (if v_111 then hmac_hash3(ck_22,input_key_material_5) else caught-fail) in
        {327}let output2_5: key = (if v_111 then hmac_hash2(ck_22,input_key_material_5) else caught-fail) in
        {326}let output1_5: key = (if v_111 then hmac_hash1(ck_22,input_key_material_5) else caught-fail) in
        {329}let v_112: bitstring = (if v_111 then catch-fail((output1_5,output2_5,output3_5)) else caught-fail) in
        {330}let v_113: bool = (not-caught-fail(v_112) && success?(1-proj-3-tuple(v_112))) in
        {331}let temp_k3: key = (if v_113 then 3-proj-3-tuple(v_112) else caught-fail) in
        {332}let temp_k2: key = (if v_113 then 2-proj-3-tuple(v_112) else caught-fail) in
        {333}let temp_k1: key = (if v_113 then 1-proj-3-tuple(v_112) else caught-fail) in
        {335}let cs2: cipherstate = (if v_113 then cipherstatepack(temp_k2,minnonce) else caught-fail) in
        {334}let cs1: cipherstate = (if v_113 then cipherstatepack(temp_k1,minnonce) else caught-fail) in
        {336}let v_114: bitstring = (if v_109 then catch-fail((if v_111 then (if v_113 then (ss_18,cs1,cs2) else fail-any) else fail-any)) else caught-fail) in
        {337}let v_115: bool = (not-caught-fail(v_114) && success?(1-proj-3-tuple(v_114))) in
        {338}let cs2_1: cipherstate = (if v_115 then 3-proj-3-tuple(v_114) else caught-fail) in
        {339}let cs1_1: cipherstate = (if v_115 then 2-proj-3-tuple(v_114) else caught-fail) in
        {340}let ssi_2: symmetricstate = (if v_115 then 1-proj-3-tuple(v_114) else caught-fail) in
        {319}let hs_5: handshakestate = (if v_109 then handshakestatepack(ss_18,s_2,m_2,e_4,rs_2,rm_2,re_3,psk_2,initiator_2) else caught-fail) in
        {341}let (hs_6: handshakestate,plaintext_b: bitstring,valid_2: bool,cs1_2: cipherstate,cs2_2: cipherstate) = (if v_62 then (if v_64 then (if v_67 then (if v_75 then (if v_83 then (if v_91 then (if v_108 then (if undo-catch-fail(v_109) then (if v_115 then (hs_5,plaintext_2,true,cs1_1,cs2_1) else fail-any) else fail-any) else fail-any) else fail-any) else fail-any) else fail-any) else fail-any) else fail-any) else fail-any) in
        {342}event RecvMsg(me,them,stagepack_b(sid_1),plaintext_b);
        {343}insert statestore(me,them,sid_1,statepack_c(hs_6,cs1_2,cs2_2))
    ) | (
        {345}!
        {403}get statestore(=me,=them,=sid_1,statepack_c(hs_7: handshakestate,cs1_3: cipherstate,cs2_3: cipherstate)) in
        {346}let hs_8: handshakestate = handshakestatesetcs(hs_7,cs1_3) in
        {348}let v_116: bitstring = catch-fail(handshakestateunpack(hs_8)) in
        {349}let v_117: bool = (not-caught-fail(v_116) && success?(1-proj-9-tuple(v_116))) in
        {350}let initiator_3: bool = (if v_117 then 9-proj-9-tuple(v_116) else caught-fail) in
        {351}let psk_3: key = (if v_117 then 8-proj-9-tuple(v_116) else caught-fail) in
        {352}let re_4: key = (if v_117 then 7-proj-9-tuple(v_116) else caught-fail) in
        {353}let rm_3: key = (if v_117 then 6-proj-9-tuple(v_116) else caught-fail) in
        {354}let rs_3: key = (if v_117 then 5-proj-9-tuple(v_116) else caught-fail) in
        {355}let e_5: keypair = (if v_117 then 4-proj-9-tuple(v_116) else caught-fail) in
        {356}let m_3: keypair = (if v_117 then 3-proj-9-tuple(v_116) else caught-fail) in
        {357}let s_3: keypair = (if v_117 then 2-proj-9-tuple(v_116) else caught-fail) in
        {358}let ss_19: symmetricstate = (if v_117 then 1-proj-9-tuple(v_116) else caught-fail) in
        {359}let v_118: bitstring = (if v_117 then catch-fail((empty,empty,empty)) else caught-fail) in
        {360}let v_119: bool = (not-caught-fail(v_118) && success?(1-proj-3-tuple(v_118))) in
        {361}let ciphertext_4: bitstring = (if v_119 then 3-proj-3-tuple(v_118) else caught-fail) in
        {362}let ns_2: bitstring = (if v_119 then 2-proj-3-tuple(v_118) else caught-fail) in
        {363}let ne_3: bitstring = (if v_119 then 1-proj-3-tuple(v_118) else caught-fail) in
        {364}let v_120: bitstring = (if v_119 then catch-fail(symmetricstateunpack(ss_19)) else caught-fail) in
        {365}let v_121: bool = (not-caught-fail(v_120) && success?(1-proj-3-tuple(v_120))) in
        {366}let h_18: bitstring = (if v_121 then 3-proj-3-tuple(v_120) else caught-fail) in
        {367}let ck_23: key = (if v_121 then 2-proj-3-tuple(v_120) else caught-fail) in
        {368}let cs_18: cipherstate = (if v_121 then 1-proj-3-tuple(v_120) else caught-fail) in
        {369}let v_122: bitstring = (if v_121 then catch-fail(cipherstateunpack(cs_18)) else caught-fail) in
        {370}let v_123: bool = (not-caught-fail(v_122) && success?(1-proj-2-tuple(v_122))) in
        {371}let n_4: nonce = (if v_123 then 2-proj-2-tuple(v_122) else caught-fail) in
        {372}let k_5: key = (if v_123 then 1-proj-2-tuple(v_122) else caught-fail) in
        {375}let v_124: bitstring = (if v_123 then catch-fail(cipherstateunpack(cs_18)) else caught-fail) in
        {376}let v_125: bool = (not-caught-fail(v_124) && success?(1-proj-2-tuple(v_124))) in
        {377}let o_2: nonce = (if v_125 then 2-proj-2-tuple(v_124) else caught-fail) in
        {378}let k_6: key = (if v_125 then 1-proj-2-tuple(v_124) else caught-fail) in
        {374}let n_5: nonce = (if v_123 then increment_nonce(n_4) else caught-fail) in
        {379}let csi_4: cipherstate = (if v_123 then catch-fail((if v_125 then cipherstatepack(k_6,n_5) else fail-any)) else caught-fail) in
        {380}let v_126: bool = not-caught-fail(csi_4) in
        {347}let payload_1: bitstring = msg_c(me,them,sid_1) in
        {373}let e_6: bitstring = (if v_123 then encrypt(k_5,n_4,h_18,payload_1) else caught-fail) in
        {381}let v_127: bitstring = (if v_121 then catch-fail((if v_123 then (if v_126 then (csi_4,e_6) else fail-any) else fail-any)) else caught-fail) in
        {382}let v_128: bool = (not-caught-fail(v_127) && success?(1-proj-2-tuple(v_127))) in
        {383}let ciphertext_5: bitstring = (if v_128 then 2-proj-2-tuple(v_127) else caught-fail) in
        {384}let csi_5: cipherstate = (if v_128 then 1-proj-2-tuple(v_127) else caught-fail) in
        {385}let ss_20: symmetricstate = (if v_128 then symmetricstatepack(csi_5,ck_23,h_18) else caught-fail) in
        {386}let v_129: bitstring = (if v_128 then catch-fail(symmetricstateunpack(ss_20)) else caught-fail) in
        {387}let v_130: bool = (not-caught-fail(v_129) && success?(1-proj-3-tuple(v_129))) in
        {388}let h_19: bitstring = (if v_130 then 3-proj-3-tuple(v_129) else caught-fail) in
        {389}let ck_24: key = (if v_130 then 2-proj-3-tuple(v_129) else caught-fail) in
        {390}let cs_19: cipherstate = (if v_130 then 1-proj-3-tuple(v_129) else caught-fail) in
        {391}let ssi_3: symmetricstate = (if v_128 then catch-fail((if v_130 then symmetricstatepack(cs_19,ck_24,hash(h_19,ciphertext_5)) else fail-any)) else caught-fail) in
        {392}let v_131: bool = not-caught-fail(ssi_3) in
        {393}let v_132: bitstring = (if v_119 then catch-fail((if v_121 then (if v_128 then (if v_131 then (ssi_3,ciphertext_5) else fail-any) else fail-any) else fail-any)) else caught-fail) in
        {394}let v_133: bool = (not-caught-fail(v_132) && success?(1-proj-2-tuple(v_132))) in
        {395}let ciphertext_6: bitstring = (if v_133 then 2-proj-2-tuple(v_132) else caught-fail) in
        {396}let ss_21: symmetricstate = (if v_133 then 1-proj-2-tuple(v_132) else caught-fail) in
        {398}let message_buffer_1: bitstring = (if v_133 then concat3(ne_3,ns_2,ciphertext_6) else caught-fail) in
        {397}let hs_9: handshakestate = (if v_133 then handshakestatepack(ss_21,s_3,m_3,e_5,rs_3,rm_3,re_4,psk_3,initiator_3) else caught-fail) in
        {399}let (hs_10: handshakestate,message_c: bitstring) = (if v_117 then (if v_119 then (if v_133 then (hs_9,message_buffer_1) else fail-any) else fail-any) else fail-any) in
        {400}event SendMsg(me,them,stagepack_c(sid_1),msg_c(me,them,sid_1));
        {401}insert statestore(me,them,sid_1,statepack_d(hs_10,handshakestategetcs(hs_10),cs2_3));
        {402}out(pub, message_c)
    ) | (
        {404}!
        {470}get statestore(=me,=them,=sid_1,statepack_d(hs_11: handshakestate,cs1_4: cipherstate,cs2_4: cipherstate)) in
        {405}let hs_12: handshakestate = handshakestatesetcs(hs_11,cs2_4) in
        {406}in(pub, message_d: bitstring);
        {407}let v_134: bitstring = catch-fail(handshakestateunpack(hs_12)) in
        {408}let v_135: bool = (not-caught-fail(v_134) && success?(1-proj-9-tuple(v_134))) in
        {409}let initiator_4: bool = (if v_135 then 9-proj-9-tuple(v_134) else caught-fail) in
        {410}let psk_4: key = (if v_135 then 8-proj-9-tuple(v_134) else caught-fail) in
        {411}let re_5: key = (if v_135 then 7-proj-9-tuple(v_134) else caught-fail) in
        {412}let rm_4: key = (if v_135 then 6-proj-9-tuple(v_134) else caught-fail) in
        {413}let rs_4: key = (if v_135 then 5-proj-9-tuple(v_134) else caught-fail) in
        {414}let e_7: keypair = (if v_135 then 4-proj-9-tuple(v_134) else caught-fail) in
        {415}let m_4: keypair = (if v_135 then 3-proj-9-tuple(v_134) else caught-fail) in
        {416}let s_4: keypair = (if v_135 then 2-proj-9-tuple(v_134) else caught-fail) in
        {417}let ss_22: symmetricstate = (if v_135 then 1-proj-9-tuple(v_134) else caught-fail) in
        {418}let v_136: bitstring = (if v_135 then catch-fail(deconcat3(message_d)) else caught-fail) in
        {419}let v_137: bool = (not-caught-fail(v_136) && success?(1-proj-3-tuple(v_136))) in
        {420}let ciphertext_7: bitstring = (if v_137 then 3-proj-3-tuple(v_136) else caught-fail) in
        {421}let ns_3: bitstring = (if v_137 then 2-proj-3-tuple(v_136) else caught-fail) in
        {422}let ne_4: bitstring = (if v_137 then 1-proj-3-tuple(v_136) else caught-fail) in
        {424}let v_138: bitstring = (if v_137 then catch-fail(symmetricstateunpack(ss_22)) else caught-fail) in
        {425}let v_139: bool = (not-caught-fail(v_138) && success?(1-proj-3-tuple(v_138))) in
        {426}let h_20: bitstring = (if v_139 then 3-proj-3-tuple(v_138) else caught-fail) in
        {427}let ck_25: key = (if v_139 then 2-proj-3-tuple(v_138) else caught-fail) in
        {428}let cs_20: cipherstate = (if v_139 then 1-proj-3-tuple(v_138) else caught-fail) in
        {429}let v_140: bitstring = (if v_139 then catch-fail(cipherstateunpack(cs_20)) else caught-fail) in
        {430}let v_141: bool = (not-caught-fail(v_140) && success?(1-proj-2-tuple(v_140))) in
        {431}let n_6: nonce = (if v_141 then 2-proj-2-tuple(v_140) else caught-fail) in
        {432}let k_7: key = (if v_141 then 1-proj-2-tuple(v_140) else caught-fail) in
        {433}let d_1: aead = (if v_141 then catch-fail(decrypt(k_7,n_6,h_20,ciphertext_7)) else caught-fail) in
        {434}let v_142: bool = not-caught-fail(d_1) in
        {435}let v_143: bitstring = (if v_142 then catch-fail(aeadunpack(d_1)) else caught-fail) in
        {436}let v_144: bool = (not-caught-fail(v_143) && success?(1-proj-3-tuple(v_143))) in
        {437}let plaintext_3: bitstring = (if v_144 then 3-proj-3-tuple(v_143) else caught-fail) in
        {438}let adi_1: bitstring = (if v_144 then 2-proj-3-tuple(v_143) else caught-fail) in
        {439}let valid_3: bool = (if v_144 then 1-proj-3-tuple(v_143) else caught-fail) in
        {441}let v_145: bitstring = (if v_144 then catch-fail(cipherstateunpack(cs_20)) else caught-fail) in
        {442}let v_146: bool = (not-caught-fail(v_145) && success?(1-proj-2-tuple(v_145))) in
        {443}let o_3: nonce = (if v_146 then 2-proj-2-tuple(v_145) else caught-fail) in
        {444}let k_8: key = (if v_146 then 1-proj-2-tuple(v_145) else caught-fail) in
        {440}let n_7: nonce = (if v_144 then increment_nonce(n_6) else caught-fail) in
        {445}let csi_6: cipherstate = (if v_144 then catch-fail((if v_146 then cipherstatepack(k_8,n_7) else fail-any)) else caught-fail) in
        {446}let v_147: bool = not-caught-fail(csi_6) in
        {447}let v_148: bitstring = (if v_139 then catch-fail((if v_141 then (if v_142 then (if v_144 then (if v_147 then (csi_6,plaintext_3,valid_3) else fail-any) else fail-any) else fail-any) else fail-any)) else caught-fail) in
        {448}let v_149: bool = (not-caught-fail(v_148) && success?(1-proj-3-tuple(v_148))) in
        {449}let valid_4: bool = (if v_149 then 3-proj-3-tuple(v_148) else caught-fail) in
        {450}let plaintext_4: bitstring = (if v_149 then 2-proj-3-tuple(v_148) else caught-fail) in
        {451}let csi_7: cipherstate = (if v_149 then 1-proj-3-tuple(v_148) else caught-fail) in
        {452}let ss_23: symmetricstate = (if v_149 then symmetricstatepack(csi_7,ck_25,h_20) else caught-fail) in
        {453}let v_150: bitstring = (if v_149 then catch-fail(symmetricstateunpack(ss_23)) else caught-fail) in
        {454}let v_151: bool = (not-caught-fail(v_150) && success?(1-proj-3-tuple(v_150))) in
        {455}let h_21: bitstring = (if v_151 then 3-proj-3-tuple(v_150) else caught-fail) in
        {456}let ck_26: key = (if v_151 then 2-proj-3-tuple(v_150) else caught-fail) in
        {457}let cs_21: cipherstate = (if v_151 then 1-proj-3-tuple(v_150) else caught-fail) in
        {458}let ssi_4: symmetricstate = (if v_149 then catch-fail((if v_151 then symmetricstatepack(cs_21,ck_26,hash(h_21,ciphertext_7)) else fail-any)) else caught-fail) in
        {459}let v_152: bool = not-caught-fail(ssi_4) in
        {460}let v_153: bitstring = (if v_137 then catch-fail((if v_139 then (if v_149 then (if v_152 then (ssi_4,plaintext_4,valid_4) else fail-any) else fail-any) else fail-any)) else caught-fail) in
        {461}let v_154: bool = (not-caught-fail(v_153) && success?(1-proj-3-tuple(v_153))) in
        {462}let valid2_1: bool = (if v_154 then 3-proj-3-tuple(v_153) else caught-fail) in
        {463}let plaintext_5: bitstring = (if v_154 then 2-proj-3-tuple(v_153) else caught-fail) in
        {464}let ss_24: symmetricstate = (if v_154 then 1-proj-3-tuple(v_153) else caught-fail) in
        {423}let valid1_1: bool = (if v_137 then true else caught-fail) in
        {465}let v_155: bool = (if v_154 then catch-fail((valid1_1 && valid2_1)) else caught-fail) in
        {466}let hs_13: handshakestate = (if v_155 then handshakestatepack(ss_24,s_4,m_4,e_7,rs_4,rm_4,re_5,psk_4,initiator_4) else caught-fail) in
        {467}let (hs_14: handshakestate,plaintext_d: bitstring,valid_5: bool) = (if v_135 then (if v_137 then (if v_154 then (if undo-catch-fail(v_155) then (hs_13,plaintext_5,true) else fail-any) else fail-any) else fail-any) else fail-any) in
        {468}event RecvMsg(me,them,stagepack_d(sid_1),plaintext_d);
        {469}event RecvEnd(valid_5)
    ) | (
        {471}event LeakS(phase0,me);
        {472}event LeakM(phase0,me);
        {473}out(pub, (key_s(me),key_m(me)))
    ) | (
        {474}phase 1;
        {475}event LeakS(phase1,me);
        {476}event LeakM(phase1,me);
        {477}out(pub, (key_s(me),key_m(me)))
    )
) | (
    {478}let me_1: principal = alice in
    {481}let basis_5: key = key_s(me_1) in
    {482}let public_key_5: key = catch-fail(dhexp(basis_5,validkey(g))) in
    {483}let v_156: bool = not-caught-fail(public_key_5) in
    {484}let s_5: keypair = (if v_156 then keypairpack(validkey(public_key_5),basis_5) else fail-any) in
    {485}let basis_6: key = key_m(me_1) in
    {486}let public_key_6: key = catch-fail(dhexp(basis_6,validkey(g))) in
    {487}let v_157: bool = not-caught-fail(public_key_6) in
    {488}let m_5: keypair = (if v_157 then keypairpack(validkey(public_key_6),basis_6) else fail-any) in
    {489}out(pub, (getpublickey(s_5),getpublickey(m_5)));
    {480}let sid_2: sessionid = sid in
    {479}let them_1: principal = charlie in
    (
        {491}let basis_7: key = key_s(them_1) in
        {492}let public_key_7: key = catch-fail(dhexp(basis_7,validkey(g))) in
        {493}let v_158: bool = not-caught-fail(public_key_7) in
        {494}let rs_5: key = getpublickey((if v_158 then keypairpack(validkey(public_key_7),basis_7) else fail-any)) in
        {495}let basis_8: key = key_s(them_1) in
        {496}let public_key_8: key = catch-fail(dhexp(basis_8,validkey(g))) in
        {497}let v_159: bool = not-caught-fail(public_key_8) in
        {498}let rm_5: key = getpublickey((if v_159 then keypairpack(validkey(public_key_8),basis_8) else fail-any)) in
        {505}let k_9: key = empty in
        {506}let cs_22: cipherstate = cipherstatepack(k_9,minnonce) in
        {502}let protocol_name_1: bitstring = somename in
        {503}let h_22: bitstring = hash(protocol_name_1,empty) in
        {504}let ck_27: key = h_22 in
        {507}let ss_25: symmetricstate = symmetricstatepack(cs_22,ck_27,h_22) in
        {508}let v_160: bitstring = catch-fail(symmetricstateunpack(ss_25)) in
        {509}let v_161: bool = (not-caught-fail(v_160) && success?(1-proj-3-tuple(v_160))) in
        {510}let h_23: bitstring = (if v_161 then 3-proj-3-tuple(v_160) else caught-fail) in
        {511}let ck_28: key = (if v_161 then 2-proj-3-tuple(v_160) else caught-fail) in
        {512}let cs_23: cipherstate = (if v_161 then 1-proj-3-tuple(v_160) else caught-fail) in
        {500}let prologue_1: bitstring = empty in
        {513}let ss_26: symmetricstate = catch-fail((if v_161 then symmetricstatepack(cs_23,ck_28,hash(h_23,prologue_1)) else fail-any)) in
        {514}let v_162: bool = not-caught-fail(ss_26) in
        {515}let data_2: bitstring = (if v_162 then catch-fail(getpublickey(s_5)) else caught-fail) in
        {516}let v_163: bool = not-caught-fail(data_2) in
        {517}let v_164: bitstring = (if v_163 then catch-fail(symmetricstateunpack(ss_26)) else caught-fail) in
        {518}let v_165: bool = (not-caught-fail(v_164) && success?(1-proj-3-tuple(v_164))) in
        {519}let h_24: bitstring = (if v_165 then 3-proj-3-tuple(v_164) else caught-fail) in
        {520}let ck_29: key = (if v_165 then 2-proj-3-tuple(v_164) else caught-fail) in
        {521}let cs_24: cipherstate = (if v_165 then 1-proj-3-tuple(v_164) else caught-fail) in
        {522}let ss_27: symmetricstate = (if v_162 then catch-fail((if v_163 then (if v_165 then symmetricstatepack(cs_24,ck_29,hash(h_24,data_2)) else fail-any) else fail-any)) else caught-fail) in
        {523}let v_166: bool = not-caught-fail(ss_27) in
        {524}let data_3: bitstring = (if v_166 then catch-fail(getpublickey(m_5)) else caught-fail) in
        {525}let v_167: bool = not-caught-fail(data_3) in
        {526}let v_168: bitstring = (if v_167 then catch-fail(symmetricstateunpack(ss_27)) else caught-fail) in
        {527}let v_169: bool = (not-caught-fail(v_168) && success?(1-proj-3-tuple(v_168))) in
        {528}let h_25: bitstring = (if v_169 then 3-proj-3-tuple(v_168) else caught-fail) in
        {529}let ck_30: key = (if v_169 then 2-proj-3-tuple(v_168) else caught-fail) in
        {530}let cs_25: cipherstate = (if v_169 then 1-proj-3-tuple(v_168) else caught-fail) in
        {531}let ss_28: symmetricstate = (if v_166 then catch-fail((if v_167 then (if v_169 then symmetricstatepack(cs_25,ck_30,hash(h_25,data_3)) else fail-any) else fail-any)) else caught-fail) in
        {532}let v_170: bool = not-caught-fail(ss_28) in
        {533}let v_171: bitstring = (if v_170 then catch-fail(symmetricstateunpack(ss_28)) else caught-fail) in
        {534}let v_172: bool = (not-caught-fail(v_171) && success?(1-proj-3-tuple(v_171))) in
        {535}let h_26: bitstring = (if v_172 then 3-proj-3-tuple(v_171) else caught-fail) in
        {536}let ck_31: key = (if v_172 then 2-proj-3-tuple(v_171) else caught-fail) in
        {537}let cs_26: cipherstate = (if v_172 then 1-proj-3-tuple(v_171) else caught-fail) in
        {538}let ss_29: symmetricstate = (if v_170 then catch-fail((if v_172 then symmetricstatepack(cs_26,ck_31,hash(h_26,rs_5)) else fail-any)) else caught-fail) in
        {539}let v_173: bool = not-caught-fail(ss_29) in
        {540}let v_174: bitstring = (if v_173 then catch-fail(symmetricstateunpack(ss_29)) else caught-fail) in
        {541}let v_175: bool = (not-caught-fail(v_174) && success?(1-proj-3-tuple(v_174))) in
        {542}let h_27: bitstring = (if v_175 then 3-proj-3-tuple(v_174) else caught-fail) in
        {543}let ck_32: key = (if v_175 then 2-proj-3-tuple(v_174) else caught-fail) in
        {544}let cs_27: cipherstate = (if v_175 then 1-proj-3-tuple(v_174) else caught-fail) in
        {545}let ss_30: symmetricstate = (if v_173 then catch-fail((if v_175 then symmetricstatepack(cs_27,ck_32,hash(h_27,rm_5)) else fail-any)) else caught-fail) in
        {546}let v_176: bool = not-caught-fail(ss_30) in
        {501}let psk_5: key = empty in
        {499}let re_6: key = empty in
        {490}let e_8: keypair = keypairpack(empty,empty) in
        {547}let hs_15: handshakestate = (if v_162 then (if v_166 then (if v_170 then (if v_173 then (if v_176 then handshakestatepack(ss_30,s_5,m_5,e_8,rs_5,rm_5,re_6,psk_5,true) else fail-any) else fail-any) else fail-any) else fail-any) else fail-any) in
        {548}insert statestore(me_1,them_1,sid_2,statepack_a(hs_15))
    ) | (
        {661}get statestore(=me_1,=them_1,=sid_2,statepack_a(hs_16: handshakestate)) in
        {550}let v_177: bitstring = catch-fail(handshakestateunpack(hs_16)) in
        {551}let v_178: bool = (not-caught-fail(v_177) && success?(1-proj-9-tuple(v_177))) in
        {552}let initiator_5: bool = (if v_178 then 9-proj-9-tuple(v_177) else caught-fail) in
        {553}let psk_6: key = (if v_178 then 8-proj-9-tuple(v_177) else caught-fail) in
        {554}let re_7: key = (if v_178 then 7-proj-9-tuple(v_177) else caught-fail) in
        {555}let rm_6: key = (if v_178 then 6-proj-9-tuple(v_177) else caught-fail) in
        {556}let rs_6: key = (if v_178 then 5-proj-9-tuple(v_177) else caught-fail) in
        {557}let e_9: keypair = (if v_178 then 4-proj-9-tuple(v_177) else caught-fail) in
        {558}let m_6: keypair = (if v_178 then 3-proj-9-tuple(v_177) else caught-fail) in
        {559}let s_6: keypair = (if v_178 then 2-proj-9-tuple(v_177) else caught-fail) in
        {560}let ss_31: symmetricstate = (if v_178 then 1-proj-9-tuple(v_177) else caught-fail) in
        {561}let v_179: bitstring = (if v_178 then catch-fail((empty,empty,empty)) else caught-fail) in
        {562}let v_180: bool = (not-caught-fail(v_179) && success?(1-proj-3-tuple(v_179))) in
        {563}let ciphertext_8: bitstring = (if v_180 then 3-proj-3-tuple(v_179) else caught-fail) in
        {564}let ns_4: bitstring = (if v_180 then 2-proj-3-tuple(v_179) else caught-fail) in
        {565}let ne_5: bitstring = (if v_180 then 1-proj-3-tuple(v_179) else caught-fail) in
        {566}let basis_9: key = (if v_180 then key_e(me_1,them_1,sid_2) else caught-fail) in
        {567}let public_key_9: key = (if v_180 then catch-fail(dhexp(basis_9,validkey(g))) else caught-fail) in
        {568}let v_181: bool = not-caught-fail(public_key_9) in
        {569}let e_10: keypair = (if v_180 then catch-fail((if v_181 then keypairpack(validkey(public_key_9),basis_9) else fail-any)) else caught-fail) in
        {570}let v_182: bool = not-caught-fail(e_10) in
        {571}let ne_6: bitstring = (if v_182 then catch-fail(getpublickey(e_10)) else caught-fail) in
        {572}let v_183: bool = not-caught-fail(ne_6) in
        {573}let v_184: bitstring = (if v_183 then catch-fail(symmetricstateunpack(ss_31)) else caught-fail) in
        {574}let v_185: bool = (not-caught-fail(v_184) && success?(1-proj-3-tuple(v_184))) in
        {575}let h_28: bitstring = (if v_185 then 3-proj-3-tuple(v_184) else caught-fail) in
        {576}let ck_33: key = (if v_185 then 2-proj-3-tuple(v_184) else caught-fail) in
        {577}let cs_28: cipherstate = (if v_185 then 1-proj-3-tuple(v_184) else caught-fail) in
        {578}let ss_32: symmetricstate = (if v_183 then catch-fail((if v_185 then symmetricstatepack(cs_28,ck_33,hash(h_28,ne_6)) else fail-any)) else caught-fail) in
        {579}let v_186: bool = not-caught-fail(ss_32) in
        {580}let v_187: bitstring = (if v_186 then catch-fail(keypairunpack(e_10)) else caught-fail) in
        {581}let v_188: bool = (not-caught-fail(v_187) && success?(1-proj-2-tuple(v_187))) in
        {582}let my_private_key_5: key = (if v_188 then 2-proj-2-tuple(v_187) else caught-fail) in
        {583}let my_public_key_5: key = (if v_188 then 1-proj-2-tuple(v_187) else caught-fail) in
        {584}let input_key_material_6: key = (if v_186 then catch-fail((if v_188 then dhexp(my_private_key_5,rm_6) else fail-any)) else caught-fail) in
        {585}let v_189: bool = not-caught-fail(input_key_material_6) in
        {586}let v_190: bitstring = (if v_189 then catch-fail(symmetricstateunpack(ss_32)) else caught-fail) in
        {587}let v_191: bool = (not-caught-fail(v_190) && success?(1-proj-3-tuple(v_190))) in
        {588}let h_29: bitstring = (if v_191 then 3-proj-3-tuple(v_190) else caught-fail) in
        {589}let ck_34: key = (if v_191 then 2-proj-3-tuple(v_190) else caught-fail) in
        {590}let cs_29: cipherstate = (if v_191 then 1-proj-3-tuple(v_190) else caught-fail) in
        {593}let output3_6: key = (if v_191 then hmac_hash3(ck_34,input_key_material_6) else caught-fail) in
        {592}let output2_6: key = (if v_191 then hmac_hash2(ck_34,input_key_material_6) else caught-fail) in
        {591}let output1_6: key = (if v_191 then hmac_hash1(ck_34,input_key_material_6) else caught-fail) in
        {594}let v_192: bitstring = (if v_191 then catch-fail((output1_6,output2_6,output3_6)) else caught-fail) in
        {595}let v_193: bool = (not-caught-fail(v_192) && success?(1-proj-3-tuple(v_192))) in
        {596}let output_5: key = (if v_193 then 3-proj-3-tuple(v_192) else caught-fail) in
        {597}let temp_k_5: key = (if v_193 then 2-proj-3-tuple(v_192) else caught-fail) in
        {598}let ck_35: key = (if v_193 then 1-proj-3-tuple(v_192) else caught-fail) in
        {599}let ss_33: symmetricstate = (if v_186 then catch-fail((if v_189 then (if v_191 then (if v_193 then symmetricstatepack(cipherstatepack(temp_k_5,minnonce),ck_35,h_29) else fail-any) else fail-any) else fail-any)) else caught-fail) in
        {600}let v_194: bool = not-caught-fail(ss_33) in
        {601}let v_195: bitstring = (if v_194 then catch-fail(keypairunpack(m_6)) else caught-fail) in
        {602}let v_196: bool = (not-caught-fail(v_195) && success?(1-proj-2-tuple(v_195))) in
        {603}let my_private_key_6: key = (if v_196 then 2-proj-2-tuple(v_195) else caught-fail) in
        {604}let my_public_key_6: key = (if v_196 then 1-proj-2-tuple(v_195) else caught-fail) in
        {605}let input_key_material_7: key = (if v_194 then catch-fail((if v_196 then dhexp(my_private_key_6,rs_6) else fail-any)) else caught-fail) in
        {606}let v_197: bool = not-caught-fail(input_key_material_7) in
        {607}let v_198: bitstring = (if v_197 then catch-fail(symmetricstateunpack(ss_33)) else caught-fail) in
        {608}let v_199: bool = (not-caught-fail(v_198) && success?(1-proj-3-tuple(v_198))) in
        {609}let h_30: bitstring = (if v_199 then 3-proj-3-tuple(v_198) else caught-fail) in
        {610}let ck_36: key = (if v_199 then 2-proj-3-tuple(v_198) else caught-fail) in
        {611}let cs_30: cipherstate = (if v_199 then 1-proj-3-tuple(v_198) else caught-fail) in
        {614}let output3_7: key = (if v_199 then hmac_hash3(ck_36,input_key_material_7) else caught-fail) in
        {613}let output2_7: key = (if v_199 then hmac_hash2(ck_36,input_key_material_7) else caught-fail) in
        {612}let output1_7: key = (if v_199 then hmac_hash1(ck_36,input_key_material_7) else caught-fail) in
        {615}let v_200: bitstring = (if v_199 then catch-fail((output1_7,output2_7,output3_7)) else caught-fail) in
        {616}let v_201: bool = (not-caught-fail(v_200) && success?(1-proj-3-tuple(v_200))) in
        {617}let output_6: key = (if v_201 then 3-proj-3-tuple(v_200) else caught-fail) in
        {618}let temp_k_6: key = (if v_201 then 2-proj-3-tuple(v_200) else caught-fail) in
        {619}let ck_37: key = (if v_201 then 1-proj-3-tuple(v_200) else caught-fail) in
        {620}let ss_34: symmetricstate = (if v_194 then catch-fail((if v_197 then (if v_199 then (if v_201 then symmetricstatepack(cipherstatepack(temp_k_6,minnonce),ck_37,h_30) else fail-any) else fail-any) else fail-any)) else caught-fail) in
        {621}let v_202: bool = not-caught-fail(ss_34) in
        {622}let v_203: bitstring = (if v_202 then catch-fail(symmetricstateunpack(ss_34)) else caught-fail) in
        {623}let v_204: bool = (not-caught-fail(v_203) && success?(1-proj-3-tuple(v_203))) in
        {624}let h_31: bitstring = (if v_204 then 3-proj-3-tuple(v_203) else caught-fail) in
        {625}let ck_38: key = (if v_204 then 2-proj-3-tuple(v_203) else caught-fail) in
        {626}let cs_31: cipherstate = (if v_204 then 1-proj-3-tuple(v_203) else caught-fail) in
        {627}let v_205: bitstring = (if v_204 then catch-fail(cipherstateunpack(cs_31)) else caught-fail) in
        {628}let v_206: bool = (not-caught-fail(v_205) && success?(1-proj-2-tuple(v_205))) in
        {629}let n_8: nonce = (if v_206 then 2-proj-2-tuple(v_205) else caught-fail) in
        {630}let k_10: key = (if v_206 then 1-proj-2-tuple(v_205) else caught-fail) in
        {633}let v_207: bitstring = (if v_206 then catch-fail(cipherstateunpack(cs_31)) else caught-fail) in
        {634}let v_208: bool = (not-caught-fail(v_207) && success?(1-proj-2-tuple(v_207))) in
        {635}let o_4: nonce = (if v_208 then 2-proj-2-tuple(v_207) else caught-fail) in
        {636}let k_11: key = (if v_208 then 1-proj-2-tuple(v_207) else caught-fail) in
        {632}let n_9: nonce = (if v_206 then increment_nonce(n_8) else caught-fail) in
        {637}let csi_8: cipherstate = (if v_206 then catch-fail((if v_208 then cipherstatepack(k_11,n_9) else fail-any)) else caught-fail) in
        {638}let v_209: bool = not-caught-fail(csi_8) in
        {549}let payload_2: bitstring = msg_a(me_1,them_1,sid_2) in
        {631}let e_11: bitstring = (if v_206 then encrypt(k_10,n_8,h_31,payload_2) else caught-fail) in
        {639}let v_210: bitstring = (if v_204 then catch-fail((if v_206 then (if v_209 then (csi_8,e_11) else fail-any) else fail-any)) else caught-fail) in
        {640}let v_211: bool = (not-caught-fail(v_210) && success?(1-proj-2-tuple(v_210))) in
        {641}let ciphertext_9: bitstring = (if v_211 then 2-proj-2-tuple(v_210) else caught-fail) in
        {642}let csi_9: cipherstate = (if v_211 then 1-proj-2-tuple(v_210) else caught-fail) in
        {643}let ss_35: symmetricstate = (if v_211 then symmetricstatepack(csi_9,ck_38,h_31) else caught-fail) in
        {644}let v_212: bitstring = (if v_211 then catch-fail(symmetricstateunpack(ss_35)) else caught-fail) in
        {645}let v_213: bool = (not-caught-fail(v_212) && success?(1-proj-3-tuple(v_212))) in
        {646}let h_32: bitstring = (if v_213 then 3-proj-3-tuple(v_212) else caught-fail) in
        {647}let ck_39: key = (if v_213 then 2-proj-3-tuple(v_212) else caught-fail) in
        {648}let cs_32: cipherstate = (if v_213 then 1-proj-3-tuple(v_212) else caught-fail) in
        {649}let ssi_5: symmetricstate = (if v_211 then catch-fail((if v_213 then symmetricstatepack(cs_32,ck_39,hash(h_32,ciphertext_9)) else fail-any)) else caught-fail) in
        {650}let v_214: bool = not-caught-fail(ssi_5) in
        {651}let v_215: bitstring = (if v_202 then catch-fail((if v_204 then (if v_211 then (if v_214 then (ssi_5,ciphertext_9) else fail-any) else fail-any) else fail-any)) else caught-fail) in
        {652}let v_216: bool = (not-caught-fail(v_215) && success?(1-proj-2-tuple(v_215))) in
        {653}let ciphertext_10: bitstring = (if v_216 then 2-proj-2-tuple(v_215) else caught-fail) in
        {654}let ss_36: symmetricstate = (if v_216 then 1-proj-2-tuple(v_215) else caught-fail) in
        {656}let message_buffer_2: bitstring = (if v_216 then concat3(ne_6,ns_4,ciphertext_10) else caught-fail) in
        {655}let hs_17: handshakestate = (if v_216 then handshakestatepack(ss_36,s_6,m_6,e_10,rs_6,rm_6,re_7,psk_6,initiator_5) else caught-fail) in
        {657}let (hs_18: handshakestate,message_a_1: bitstring) = (if v_178 then (if v_180 then (if v_182 then (if v_183 then (if v_186 then (if v_194 then (if v_202 then (if v_216 then (hs_17,message_buffer_2) else fail-any) else fail-any) else fail-any) else fail-any) else fail-any) else fail-any) else fail-any) else fail-any) in
        {658}event SendMsg(me_1,them_1,stagepack_a(sid_2),msg_a(me_1,them_1,sid_2));
        {659}insert statestore(me_1,them_1,sid_2,statepack_b(hs_18));
        {660}out(pub, message_a_1)
    ) | (
        {818}get statestore(=me_1,=them_1,=sid_2,statepack_b(hs_19: handshakestate)) in
        {662}in(pub, message_b_1: bitstring);
        {663}let v_217: bitstring = catch-fail(handshakestateunpack(hs_19)) in
        {664}let v_218: bool = (not-caught-fail(v_217) && success?(1-proj-9-tuple(v_217))) in
        {665}let initiator_6: bool = (if v_218 then 9-proj-9-tuple(v_217) else caught-fail) in
        {666}let psk_7: key = (if v_218 then 8-proj-9-tuple(v_217) else caught-fail) in
        {667}let re_8: key = (if v_218 then 7-proj-9-tuple(v_217) else caught-fail) in
        {668}let rm_7: key = (if v_218 then 6-proj-9-tuple(v_217) else caught-fail) in
        {669}let rs_7: key = (if v_218 then 5-proj-9-tuple(v_217) else caught-fail) in
        {670}let e_12: keypair = (if v_218 then 4-proj-9-tuple(v_217) else caught-fail) in
        {671}let m_7: keypair = (if v_218 then 3-proj-9-tuple(v_217) else caught-fail) in
        {672}let s_7: keypair = (if v_218 then 2-proj-9-tuple(v_217) else caught-fail) in
        {673}let ss_37: symmetricstate = (if v_218 then 1-proj-9-tuple(v_217) else caught-fail) in
        {674}let v_219: bitstring = (if v_218 then catch-fail(deconcat3(message_b_1)) else caught-fail) in
        {675}let v_220: bool = (not-caught-fail(v_219) && success?(1-proj-3-tuple(v_219))) in
        {676}let ciphertext_11: bitstring = (if v_220 then 3-proj-3-tuple(v_219) else caught-fail) in
        {677}let ns_5: bitstring = (if v_220 then 2-proj-3-tuple(v_219) else caught-fail) in
        {678}let ne_7: bitstring = (if v_220 then 1-proj-3-tuple(v_219) else caught-fail) in
        {681}let v_221: bitstring = (if v_220 then catch-fail(symmetricstateunpack(ss_37)) else caught-fail) in
        {682}let v_222: bool = (not-caught-fail(v_221) && success?(1-proj-3-tuple(v_221))) in
        {683}let h_33: bitstring = (if v_222 then 3-proj-3-tuple(v_221) else caught-fail) in
        {684}let ck_40: key = (if v_222 then 2-proj-3-tuple(v_221) else caught-fail) in
        {685}let cs_33: cipherstate = (if v_222 then 1-proj-3-tuple(v_221) else caught-fail) in
        {680}let re_9: key = (if v_220 then ne_7 else caught-fail) in
        {686}let ss_38: symmetricstate = (if v_220 then catch-fail((if v_222 then symmetricstatepack(cs_33,ck_40,hash(h_33,re_9)) else fail-any)) else caught-fail) in
        {687}let v_223: bool = not-caught-fail(ss_38) in
        {688}let v_224: bitstring = (if v_223 then catch-fail(keypairunpack(e_12)) else caught-fail) in
        {689}let v_225: bool = (not-caught-fail(v_224) && success?(1-proj-2-tuple(v_224))) in
        {690}let my_private_key_7: key = (if v_225 then 2-proj-2-tuple(v_224) else caught-fail) in
        {691}let my_public_key_7: key = (if v_225 then 1-proj-2-tuple(v_224) else caught-fail) in
        {692}let input_key_material_8: key = (if v_223 then catch-fail((if v_225 then dhexp(my_private_key_7,re_9) else fail-any)) else caught-fail) in
        {693}let v_226: bool = not-caught-fail(input_key_material_8) in
        {694}let v_227: bitstring = (if v_226 then catch-fail(symmetricstateunpack(ss_38)) else caught-fail) in
        {695}let v_228: bool = (not-caught-fail(v_227) && success?(1-proj-3-tuple(v_227))) in
        {696}let h_34: bitstring = (if v_228 then 3-proj-3-tuple(v_227) else caught-fail) in
        {697}let ck_41: key = (if v_228 then 2-proj-3-tuple(v_227) else caught-fail) in
        {698}let cs_34: cipherstate = (if v_228 then 1-proj-3-tuple(v_227) else caught-fail) in
        {701}let output3_8: key = (if v_228 then hmac_hash3(ck_41,input_key_material_8) else caught-fail) in
        {700}let output2_8: key = (if v_228 then hmac_hash2(ck_41,input_key_material_8) else caught-fail) in
        {699}let output1_8: key = (if v_228 then hmac_hash1(ck_41,input_key_material_8) else caught-fail) in
        {702}let v_229: bitstring = (if v_228 then catch-fail((output1_8,output2_8,output3_8)) else caught-fail) in
        {703}let v_230: bool = (not-caught-fail(v_229) && success?(1-proj-3-tuple(v_229))) in
        {704}let output_7: key = (if v_230 then 3-proj-3-tuple(v_229) else caught-fail) in
        {705}let temp_k_7: key = (if v_230 then 2-proj-3-tuple(v_229) else caught-fail) in
        {706}let ck_42: key = (if v_230 then 1-proj-3-tuple(v_229) else caught-fail) in
        {707}let ss_39: symmetricstate = (if v_223 then catch-fail((if v_226 then (if v_228 then (if v_230 then symmetricstatepack(cipherstatepack(temp_k_7,minnonce),ck_42,h_34) else fail-any) else fail-any) else fail-any)) else caught-fail) in
        {708}let v_231: bool = not-caught-fail(ss_39) in
        {709}let v_232: bitstring = (if v_231 then catch-fail(keypairunpack(s_7)) else caught-fail) in
        {710}let v_233: bool = (not-caught-fail(v_232) && success?(1-proj-2-tuple(v_232))) in
        {711}let my_private_key_8: key = (if v_233 then 2-proj-2-tuple(v_232) else caught-fail) in
        {712}let my_public_key_8: key = (if v_233 then 1-proj-2-tuple(v_232) else caught-fail) in
        {713}let input_key_material_9: key = (if v_231 then catch-fail((if v_233 then dhexp(my_private_key_8,re_9) else fail-any)) else caught-fail) in
        {714}let v_234: bool = not-caught-fail(input_key_material_9) in
        {715}let v_235: bitstring = (if v_234 then catch-fail(symmetricstateunpack(ss_39)) else caught-fail) in
        {716}let v_236: bool = (not-caught-fail(v_235) && success?(1-proj-3-tuple(v_235))) in
        {717}let h_35: bitstring = (if v_236 then 3-proj-3-tuple(v_235) else caught-fail) in
        {718}let ck_43: key = (if v_236 then 2-proj-3-tuple(v_235) else caught-fail) in
        {719}let cs_35: cipherstate = (if v_236 then 1-proj-3-tuple(v_235) else caught-fail) in
        {722}let output3_9: key = (if v_236 then hmac_hash3(ck_43,input_key_material_9) else caught-fail) in
        {721}let output2_9: key = (if v_236 then hmac_hash2(ck_43,input_key_material_9) else caught-fail) in
        {720}let output1_9: key = (if v_236 then hmac_hash1(ck_43,input_key_material_9) else caught-fail) in
        {723}let v_237: bitstring = (if v_236 then catch-fail((output1_9,output2_9,output3_9)) else caught-fail) in
        {724}let v_238: bool = (not-caught-fail(v_237) && success?(1-proj-3-tuple(v_237))) in
        {725}let output_8: key = (if v_238 then 3-proj-3-tuple(v_237) else caught-fail) in
        {726}let temp_k_8: key = (if v_238 then 2-proj-3-tuple(v_237) else caught-fail) in
        {727}let ck_44: key = (if v_238 then 1-proj-3-tuple(v_237) else caught-fail) in
        {728}let ss_40: symmetricstate = (if v_231 then catch-fail((if v_234 then (if v_236 then (if v_238 then symmetricstatepack(cipherstatepack(temp_k_8,minnonce),ck_44,h_35) else fail-any) else fail-any) else fail-any)) else caught-fail) in
        {729}let v_239: bool = not-caught-fail(ss_40) in
        {730}let v_240: bitstring = (if v_239 then catch-fail(keypairunpack(m_7)) else caught-fail) in
        {731}let v_241: bool = (not-caught-fail(v_240) && success?(1-proj-2-tuple(v_240))) in
        {732}let my_private_key_9: key = (if v_241 then 2-proj-2-tuple(v_240) else caught-fail) in
        {733}let my_public_key_9: key = (if v_241 then 1-proj-2-tuple(v_240) else caught-fail) in
        {734}let input_key_material_10: key = (if v_239 then catch-fail((if v_241 then dhexp(my_private_key_9,re_9) else fail-any)) else caught-fail) in
        {735}let v_242: bool = not-caught-fail(input_key_material_10) in
        {736}let v_243: bitstring = (if v_242 then catch-fail(symmetricstateunpack(ss_40)) else caught-fail) in
        {737}let v_244: bool = (not-caught-fail(v_243) && success?(1-proj-3-tuple(v_243))) in
        {738}let h_36: bitstring = (if v_244 then 3-proj-3-tuple(v_243) else caught-fail) in
        {739}let ck_45: key = (if v_244 then 2-proj-3-tuple(v_243) else caught-fail) in
        {740}let cs_36: cipherstate = (if v_244 then 1-proj-3-tuple(v_243) else caught-fail) in
        {743}let output3_10: key = (if v_244 then hmac_hash3(ck_45,input_key_material_10) else caught-fail) in
        {742}let output2_10: key = (if v_244 then hmac_hash2(ck_45,input_key_material_10) else caught-fail) in
        {741}let output1_10: key = (if v_244 then hmac_hash1(ck_45,input_key_material_10) else caught-fail) in
        {744}let v_245: bitstring = (if v_244 then catch-fail((output1_10,output2_10,output3_10)) else caught-fail) in
        {745}let v_246: bool = (not-caught-fail(v_245) && success?(1-proj-3-tuple(v_245))) in
        {746}let output_9: key = (if v_246 then 3-proj-3-tuple(v_245) else caught-fail) in
        {747}let temp_k_9: key = (if v_246 then 2-proj-3-tuple(v_245) else caught-fail) in
        {748}let ck_46: key = (if v_246 then 1-proj-3-tuple(v_245) else caught-fail) in
        {749}let ss_41: symmetricstate = (if v_239 then catch-fail((if v_242 then (if v_244 then (if v_246 then symmetricstatepack(cipherstatepack(temp_k_9,minnonce),ck_46,h_36) else fail-any) else fail-any) else fail-any)) else caught-fail) in
        {750}let v_247: bool = not-caught-fail(ss_41) in
        {751}let v_248: bitstring = (if v_247 then catch-fail(symmetricstateunpack(ss_41)) else caught-fail) in
        {752}let v_249: bool = (not-caught-fail(v_248) && success?(1-proj-3-tuple(v_248))) in
        {753}let h_37: bitstring = (if v_249 then 3-proj-3-tuple(v_248) else caught-fail) in
        {754}let ck_47: key = (if v_249 then 2-proj-3-tuple(v_248) else caught-fail) in
        {755}let cs_37: cipherstate = (if v_249 then 1-proj-3-tuple(v_248) else caught-fail) in
        {756}let v_250: bitstring = (if v_249 then catch-fail(cipherstateunpack(cs_37)) else caught-fail) in
        {757}let v_251: bool = (not-caught-fail(v_250) && success?(1-proj-2-tuple(v_250))) in
        {758}let n_10: nonce = (if v_251 then 2-proj-2-tuple(v_250) else caught-fail) in
        {759}let k_12: key = (if v_251 then 1-proj-2-tuple(v_250) else caught-fail) in
        {760}let d_2: aead = (if v_251 then catch-fail(decrypt(k_12,n_10,h_37,ciphertext_11)) else caught-fail) in
        {761}let v_252: bool = not-caught-fail(d_2) in
        {762}let v_253: bitstring = (if v_252 then catch-fail(aeadunpack(d_2)) else caught-fail) in
        {763}let v_254: bool = (not-caught-fail(v_253) && success?(1-proj-3-tuple(v_253))) in
        {764}let plaintext_6: bitstring = (if v_254 then 3-proj-3-tuple(v_253) else caught-fail) in
        {765}let adi_2: bitstring = (if v_254 then 2-proj-3-tuple(v_253) else caught-fail) in
        {766}let valid_6: bool = (if v_254 then 1-proj-3-tuple(v_253) else caught-fail) in
        {768}let v_255: bitstring = (if v_254 then catch-fail(cipherstateunpack(cs_37)) else caught-fail) in
        {769}let v_256: bool = (not-caught-fail(v_255) && success?(1-proj-2-tuple(v_255))) in
        {770}let o_5: nonce = (if v_256 then 2-proj-2-tuple(v_255) else caught-fail) in
        {771}let k_13: key = (if v_256 then 1-proj-2-tuple(v_255) else caught-fail) in
        {767}let n_11: nonce = (if v_254 then increment_nonce(n_10) else caught-fail) in
        {772}let csi_10: cipherstate = (if v_254 then catch-fail((if v_256 then cipherstatepack(k_13,n_11) else fail-any)) else caught-fail) in
        {773}let v_257: bool = not-caught-fail(csi_10) in
        {774}let v_258: bitstring = (if v_249 then catch-fail((if v_251 then (if v_252 then (if v_254 then (if v_257 then (csi_10,plaintext_6,valid_6) else fail-any) else fail-any) else fail-any) else fail-any)) else caught-fail) in
        {775}let v_259: bool = (not-caught-fail(v_258) && success?(1-proj-3-tuple(v_258))) in
        {776}let valid_7: bool = (if v_259 then 3-proj-3-tuple(v_258) else caught-fail) in
        {777}let plaintext_7: bitstring = (if v_259 then 2-proj-3-tuple(v_258) else caught-fail) in
        {778}let csi_11: cipherstate = (if v_259 then 1-proj-3-tuple(v_258) else caught-fail) in
        {779}let ss_42: symmetricstate = (if v_259 then symmetricstatepack(csi_11,ck_47,h_37) else caught-fail) in
        {780}let v_260: bitstring = (if v_259 then catch-fail(symmetricstateunpack(ss_42)) else caught-fail) in
        {781}let v_261: bool = (not-caught-fail(v_260) && success?(1-proj-3-tuple(v_260))) in
        {782}let h_38: bitstring = (if v_261 then 3-proj-3-tuple(v_260) else caught-fail) in
        {783}let ck_48: key = (if v_261 then 2-proj-3-tuple(v_260) else caught-fail) in
        {784}let cs_38: cipherstate = (if v_261 then 1-proj-3-tuple(v_260) else caught-fail) in
        {785}let ssi_6: symmetricstate = (if v_259 then catch-fail((if v_261 then symmetricstatepack(cs_38,ck_48,hash(h_38,ciphertext_11)) else fail-any)) else caught-fail) in
        {786}let v_262: bool = not-caught-fail(ssi_6) in
        {787}let v_263: bitstring = (if v_247 then catch-fail((if v_249 then (if v_259 then (if v_262 then (ssi_6,plaintext_7,valid_7) else fail-any) else fail-any) else fail-any)) else caught-fail) in
        {788}let v_264: bool = (not-caught-fail(v_263) && success?(1-proj-3-tuple(v_263))) in
        {789}let valid2_2: bool = (if v_264 then 3-proj-3-tuple(v_263) else caught-fail) in
        {790}let plaintext_8: bitstring = (if v_264 then 2-proj-3-tuple(v_263) else caught-fail) in
        {791}let ss_43: symmetricstate = (if v_264 then 1-proj-3-tuple(v_263) else caught-fail) in
        {679}let valid1_2: bool = (if v_220 then true else caught-fail) in
        {792}let v_265: bool = (if v_264 then catch-fail((valid1_2 && valid2_2)) else caught-fail) in
        {794}let v_266: bitstring = (if v_265 then catch-fail(symmetricstateunpack(ss_43)) else caught-fail) in
        {795}let v_267: bool = (not-caught-fail(v_266) && success?(1-proj-3-tuple(v_266))) in
        {796}let h_39: bitstring = (if v_267 then 3-proj-3-tuple(v_266) else caught-fail) in
        {797}let ck_49: key = (if v_267 then 2-proj-3-tuple(v_266) else caught-fail) in
        {798}let cs_39: cipherstate = (if v_267 then 1-proj-3-tuple(v_266) else caught-fail) in
        {799}let input_key_material_11: key = (if v_267 then zero else caught-fail) in
        {802}let output3_11: key = (if v_267 then hmac_hash3(ck_49,input_key_material_11) else caught-fail) in
        {801}let output2_11: key = (if v_267 then hmac_hash2(ck_49,input_key_material_11) else caught-fail) in
        {800}let output1_11: key = (if v_267 then hmac_hash1(ck_49,input_key_material_11) else caught-fail) in
        {803}let v_268: bitstring = (if v_267 then catch-fail((output1_11,output2_11,output3_11)) else caught-fail) in
        {804}let v_269: bool = (not-caught-fail(v_268) && success?(1-proj-3-tuple(v_268))) in
        {805}let temp_k3_1: key = (if v_269 then 3-proj-3-tuple(v_268) else caught-fail) in
        {806}let temp_k2_1: key = (if v_269 then 2-proj-3-tuple(v_268) else caught-fail) in
        {807}let temp_k1_1: key = (if v_269 then 1-proj-3-tuple(v_268) else caught-fail) in
        {809}let cs2_5: cipherstate = (if v_269 then cipherstatepack(temp_k2_1,minnonce) else caught-fail) in
        {808}let cs1_5: cipherstate = (if v_269 then cipherstatepack(temp_k1_1,minnonce) else caught-fail) in
        {810}let v_270: bitstring = (if v_265 then catch-fail((if v_267 then (if v_269 then (ss_43,cs1_5,cs2_5) else fail-any) else fail-any)) else caught-fail) in
        {811}let v_271: bool = (not-caught-fail(v_270) && success?(1-proj-3-tuple(v_270))) in
        {812}let cs2_6: cipherstate = (if v_271 then 3-proj-3-tuple(v_270) else caught-fail) in
        {813}let cs1_6: cipherstate = (if v_271 then 2-proj-3-tuple(v_270) else caught-fail) in
        {814}let ssi_7: symmetricstate = (if v_271 then 1-proj-3-tuple(v_270) else caught-fail) in
        {793}let hs_20: handshakestate = (if v_265 then handshakestatepack(ss_43,s_7,m_7,e_12,rs_7,rm_7,re_9,psk_7,initiator_6) else caught-fail) in
        {815}let (hs_21: handshakestate,plaintext_b_1: bitstring,valid_8: bool,cs1_7: cipherstate,cs2_7: cipherstate) = (if v_218 then (if v_220 then (if v_223 then (if v_231 then (if v_239 then (if v_247 then (if v_264 then (if undo-catch-fail(v_265) then (if v_271 then (hs_20,plaintext_8,true,cs1_6,cs2_6) else fail-any) else fail-any) else fail-any) else fail-any) else fail-any) else fail-any) else fail-any) else fail-any) else fail-any) in
        {816}event RecvMsg(me_1,them_1,stagepack_b(sid_2),plaintext_b_1);
        {817}insert statestore(me_1,them_1,sid_2,statepack_c(hs_21,cs1_7,cs2_7))
    ) | (
        {819}!
        {877}get statestore(=me_1,=them_1,=sid_2,statepack_c(hs_22: handshakestate,cs1_8: cipherstate,cs2_8: cipherstate)) in
        {820}let hs_23: handshakestate = handshakestatesetcs(hs_22,cs1_8) in
        {822}let v_272: bitstring = catch-fail(handshakestateunpack(hs_23)) in
        {823}let v_273: bool = (not-caught-fail(v_272) && success?(1-proj-9-tuple(v_272))) in
        {824}let initiator_7: bool = (if v_273 then 9-proj-9-tuple(v_272) else caught-fail) in
        {825}let psk_8: key = (if v_273 then 8-proj-9-tuple(v_272) else caught-fail) in
        {826}let re_10: key = (if v_273 then 7-proj-9-tuple(v_272) else caught-fail) in
        {827}let rm_8: key = (if v_273 then 6-proj-9-tuple(v_272) else caught-fail) in
        {828}let rs_8: key = (if v_273 then 5-proj-9-tuple(v_272) else caught-fail) in
        {829}let e_13: keypair = (if v_273 then 4-proj-9-tuple(v_272) else caught-fail) in
        {830}let m_8: keypair = (if v_273 then 3-proj-9-tuple(v_272) else caught-fail) in
        {831}let s_8: keypair = (if v_273 then 2-proj-9-tuple(v_272) else caught-fail) in
        {832}let ss_44: symmetricstate = (if v_273 then 1-proj-9-tuple(v_272) else caught-fail) in
        {833}let v_274: bitstring = (if v_273 then catch-fail((empty,empty,empty)) else caught-fail) in
        {834}let v_275: bool = (not-caught-fail(v_274) && success?(1-proj-3-tuple(v_274))) in
        {835}let ciphertext_12: bitstring = (if v_275 then 3-proj-3-tuple(v_274) else caught-fail) in
        {836}let ns_6: bitstring = (if v_275 then 2-proj-3-tuple(v_274) else caught-fail) in
        {837}let ne_8: bitstring = (if v_275 then 1-proj-3-tuple(v_274) else caught-fail) in
        {838}let v_276: bitstring = (if v_275 then catch-fail(symmetricstateunpack(ss_44)) else caught-fail) in
        {839}let v_277: bool = (not-caught-fail(v_276) && success?(1-proj-3-tuple(v_276))) in
        {840}let h_40: bitstring = (if v_277 then 3-proj-3-tuple(v_276) else caught-fail) in
        {841}let ck_50: key = (if v_277 then 2-proj-3-tuple(v_276) else caught-fail) in
        {842}let cs_40: cipherstate = (if v_277 then 1-proj-3-tuple(v_276) else caught-fail) in
        {843}let v_278: bitstring = (if v_277 then catch-fail(cipherstateunpack(cs_40)) else caught-fail) in
        {844}let v_279: bool = (not-caught-fail(v_278) && success?(1-proj-2-tuple(v_278))) in
        {845}let n_12: nonce = (if v_279 then 2-proj-2-tuple(v_278) else caught-fail) in
        {846}let k_14: key = (if v_279 then 1-proj-2-tuple(v_278) else caught-fail) in
        {849}let v_280: bitstring = (if v_279 then catch-fail(cipherstateunpack(cs_40)) else caught-fail) in
        {850}let v_281: bool = (not-caught-fail(v_280) && success?(1-proj-2-tuple(v_280))) in
        {851}let o_6: nonce = (if v_281 then 2-proj-2-tuple(v_280) else caught-fail) in
        {852}let k_15: key = (if v_281 then 1-proj-2-tuple(v_280) else caught-fail) in
        {848}let n_13: nonce = (if v_279 then increment_nonce(n_12) else caught-fail) in
        {853}let csi_12: cipherstate = (if v_279 then catch-fail((if v_281 then cipherstatepack(k_15,n_13) else fail-any)) else caught-fail) in
        {854}let v_282: bool = not-caught-fail(csi_12) in
        {821}let payload_3: bitstring = msg_c(me_1,them_1,sid_2) in
        {847}let e_14: bitstring = (if v_279 then encrypt(k_14,n_12,h_40,payload_3) else caught-fail) in
        {855}let v_283: bitstring = (if v_277 then catch-fail((if v_279 then (if v_282 then (csi_12,e_14) else fail-any) else fail-any)) else caught-fail) in
        {856}let v_284: bool = (not-caught-fail(v_283) && success?(1-proj-2-tuple(v_283))) in
        {857}let ciphertext_13: bitstring = (if v_284 then 2-proj-2-tuple(v_283) else caught-fail) in
        {858}let csi_13: cipherstate = (if v_284 then 1-proj-2-tuple(v_283) else caught-fail) in
        {859}let ss_45: symmetricstate = (if v_284 then symmetricstatepack(csi_13,ck_50,h_40) else caught-fail) in
        {860}let v_285: bitstring = (if v_284 then catch-fail(symmetricstateunpack(ss_45)) else caught-fail) in
        {861}let v_286: bool = (not-caught-fail(v_285) && success?(1-proj-3-tuple(v_285))) in
        {862}let h_41: bitstring = (if v_286 then 3-proj-3-tuple(v_285) else caught-fail) in
        {863}let ck_51: key = (if v_286 then 2-proj-3-tuple(v_285) else caught-fail) in
        {864}let cs_41: cipherstate = (if v_286 then 1-proj-3-tuple(v_285) else caught-fail) in
        {865}let ssi_8: symmetricstate = (if v_284 then catch-fail((if v_286 then symmetricstatepack(cs_41,ck_51,hash(h_41,ciphertext_13)) else fail-any)) else caught-fail) in
        {866}let v_287: bool = not-caught-fail(ssi_8) in
        {867}let v_288: bitstring = (if v_275 then catch-fail((if v_277 then (if v_284 then (if v_287 then (ssi_8,ciphertext_13) else fail-any) else fail-any) else fail-any)) else caught-fail) in
        {868}let v_289: bool = (not-caught-fail(v_288) && success?(1-proj-2-tuple(v_288))) in
        {869}let ciphertext_14: bitstring = (if v_289 then 2-proj-2-tuple(v_288) else caught-fail) in
        {870}let ss_46: symmetricstate = (if v_289 then 1-proj-2-tuple(v_288) else caught-fail) in
        {872}let message_buffer_3: bitstring = (if v_289 then concat3(ne_8,ns_6,ciphertext_14) else caught-fail) in
        {871}let hs_24: handshakestate = (if v_289 then handshakestatepack(ss_46,s_8,m_8,e_13,rs_8,rm_8,re_10,psk_8,initiator_7) else caught-fail) in
        {873}let (hs_25: handshakestate,message_c_1: bitstring) = (if v_273 then (if v_275 then (if v_289 then (hs_24,message_buffer_3) else fail-any) else fail-any) else fail-any) in
        {874}event SendMsg(me_1,them_1,stagepack_c(sid_2),msg_c(me_1,them_1,sid_2));
        {875}insert statestore(me_1,them_1,sid_2,statepack_d(hs_25,handshakestategetcs(hs_25),cs2_8));
        {876}out(pub, message_c_1)
    ) | (
        {878}!
        {944}get statestore(=me_1,=them_1,=sid_2,statepack_d(hs_26: handshakestate,cs1_9: cipherstate,cs2_9: cipherstate)) in
        {879}let hs_27: handshakestate = handshakestatesetcs(hs_26,cs2_9) in
        {880}in(pub, message_d_1: bitstring);
        {881}let v_290: bitstring = catch-fail(handshakestateunpack(hs_27)) in
        {882}let v_291: bool = (not-caught-fail(v_290) && success?(1-proj-9-tuple(v_290))) in
        {883}let initiator_8: bool = (if v_291 then 9-proj-9-tuple(v_290) else caught-fail) in
        {884}let psk_9: key = (if v_291 then 8-proj-9-tuple(v_290) else caught-fail) in
        {885}let re_11: key = (if v_291 then 7-proj-9-tuple(v_290) else caught-fail) in
        {886}let rm_9: key = (if v_291 then 6-proj-9-tuple(v_290) else caught-fail) in
        {887}let rs_9: key = (if v_291 then 5-proj-9-tuple(v_290) else caught-fail) in
        {888}let e_15: keypair = (if v_291 then 4-proj-9-tuple(v_290) else caught-fail) in
        {889}let m_9: keypair = (if v_291 then 3-proj-9-tuple(v_290) else caught-fail) in
        {890}let s_9: keypair = (if v_291 then 2-proj-9-tuple(v_290) else caught-fail) in
        {891}let ss_47: symmetricstate = (if v_291 then 1-proj-9-tuple(v_290) else caught-fail) in
        {892}let v_292: bitstring = (if v_291 then catch-fail(deconcat3(message_d_1)) else caught-fail) in
        {893}let v_293: bool = (not-caught-fail(v_292) && success?(1-proj-3-tuple(v_292))) in
        {894}let ciphertext_15: bitstring = (if v_293 then 3-proj-3-tuple(v_292) else caught-fail) in
        {895}let ns_7: bitstring = (if v_293 then 2-proj-3-tuple(v_292) else caught-fail) in
        {896}let ne_9: bitstring = (if v_293 then 1-proj-3-tuple(v_292) else caught-fail) in
        {898}let v_294: bitstring = (if v_293 then catch-fail(symmetricstateunpack(ss_47)) else caught-fail) in
        {899}let v_295: bool = (not-caught-fail(v_294) && success?(1-proj-3-tuple(v_294))) in
        {900}let h_42: bitstring = (if v_295 then 3-proj-3-tuple(v_294) else caught-fail) in
        {901}let ck_52: key = (if v_295 then 2-proj-3-tuple(v_294) else caught-fail) in
        {902}let cs_42: cipherstate = (if v_295 then 1-proj-3-tuple(v_294) else caught-fail) in
        {903}let v_296: bitstring = (if v_295 then catch-fail(cipherstateunpack(cs_42)) else caught-fail) in
        {904}let v_297: bool = (not-caught-fail(v_296) && success?(1-proj-2-tuple(v_296))) in
        {905}let n_14: nonce = (if v_297 then 2-proj-2-tuple(v_296) else caught-fail) in
        {906}let k_16: key = (if v_297 then 1-proj-2-tuple(v_296) else caught-fail) in
        {907}let d_3: aead = (if v_297 then catch-fail(decrypt(k_16,n_14,h_42,ciphertext_15)) else caught-fail) in
        {908}let v_298: bool = not-caught-fail(d_3) in
        {909}let v_299: bitstring = (if v_298 then catch-fail(aeadunpack(d_3)) else caught-fail) in
        {910}let v_300: bool = (not-caught-fail(v_299) && success?(1-proj-3-tuple(v_299))) in
        {911}let plaintext_9: bitstring = (if v_300 then 3-proj-3-tuple(v_299) else caught-fail) in
        {912}let adi_3: bitstring = (if v_300 then 2-proj-3-tuple(v_299) else caught-fail) in
        {913}let valid_9: bool = (if v_300 then 1-proj-3-tuple(v_299) else caught-fail) in
        {915}let v_301: bitstring = (if v_300 then catch-fail(cipherstateunpack(cs_42)) else caught-fail) in
        {916}let v_302: bool = (not-caught-fail(v_301) && success?(1-proj-2-tuple(v_301))) in
        {917}let o_7: nonce = (if v_302 then 2-proj-2-tuple(v_301) else caught-fail) in
        {918}let k_17: key = (if v_302 then 1-proj-2-tuple(v_301) else caught-fail) in
        {914}let n_15: nonce = (if v_300 then increment_nonce(n_14) else caught-fail) in
        {919}let csi_14: cipherstate = (if v_300 then catch-fail((if v_302 then cipherstatepack(k_17,n_15) else fail-any)) else caught-fail) in
        {920}let v_303: bool = not-caught-fail(csi_14) in
        {921}let v_304: bitstring = (if v_295 then catch-fail((if v_297 then (if v_298 then (if v_300 then (if v_303 then (csi_14,plaintext_9,valid_9) else fail-any) else fail-any) else fail-any) else fail-any)) else caught-fail) in
        {922}let v_305: bool = (not-caught-fail(v_304) && success?(1-proj-3-tuple(v_304))) in
        {923}let valid_10: bool = (if v_305 then 3-proj-3-tuple(v_304) else caught-fail) in
        {924}let plaintext_10: bitstring = (if v_305 then 2-proj-3-tuple(v_304) else caught-fail) in
        {925}let csi_15: cipherstate = (if v_305 then 1-proj-3-tuple(v_304) else caught-fail) in
        {926}let ss_48: symmetricstate = (if v_305 then symmetricstatepack(csi_15,ck_52,h_42) else caught-fail) in
        {927}let v_306: bitstring = (if v_305 then catch-fail(symmetricstateunpack(ss_48)) else caught-fail) in
        {928}let v_307: bool = (not-caught-fail(v_306) && success?(1-proj-3-tuple(v_306))) in
        {929}let h_43: bitstring = (if v_307 then 3-proj-3-tuple(v_306) else caught-fail) in
        {930}let ck_53: key = (if v_307 then 2-proj-3-tuple(v_306) else caught-fail) in
        {931}let cs_43: cipherstate = (if v_307 then 1-proj-3-tuple(v_306) else caught-fail) in
        {932}let ssi_9: symmetricstate = (if v_305 then catch-fail((if v_307 then symmetricstatepack(cs_43,ck_53,hash(h_43,ciphertext_15)) else fail-any)) else caught-fail) in
        {933}let v_308: bool = not-caught-fail(ssi_9) in
        {934}let v_309: bitstring = (if v_293 then catch-fail((if v_295 then (if v_305 then (if v_308 then (ssi_9,plaintext_10,valid_10) else fail-any) else fail-any) else fail-any)) else caught-fail) in
        {935}let v_310: bool = (not-caught-fail(v_309) && success?(1-proj-3-tuple(v_309))) in
        {936}let valid2_3: bool = (if v_310 then 3-proj-3-tuple(v_309) else caught-fail) in
        {937}let plaintext_11: bitstring = (if v_310 then 2-proj-3-tuple(v_309) else caught-fail) in
        {938}let ss_49: symmetricstate = (if v_310 then 1-proj-3-tuple(v_309) else caught-fail) in
        {897}let valid1_3: bool = (if v_293 then true else caught-fail) in
        {939}let v_311: bool = (if v_310 then catch-fail((valid1_3 && valid2_3)) else caught-fail) in
        {940}let hs_28: handshakestate = (if v_311 then handshakestatepack(ss_49,s_9,m_9,e_15,rs_9,rm_9,re_11,psk_9,initiator_8) else caught-fail) in
        {941}let (hs_29: handshakestate,plaintext_d_1: bitstring,valid_11: bool) = (if v_291 then (if v_293 then (if v_310 then (if undo-catch-fail(v_311) then (hs_28,plaintext_11,true) else fail-any) else fail-any) else fail-any) else fail-any) in
        {942}event RecvMsg(me_1,them_1,stagepack_d(sid_2),plaintext_d_1);
        {943}event RecvEnd(valid_11)
    ) | (
        {945}event LeakS(phase0,me_1);
        {946}event LeakM(phase0,me_1);
        {947}out(pub, (key_s(me_1),key_m(me_1)))
    ) | (
        {948}phase 1;
        {949}event LeakS(phase1,me_1);
        {950}event LeakM(phase1,me_1);
        {951}out(pub, (key_s(me_1),key_m(me_1)))
    )
) | (
    {952}let me_2: principal = bob in
    {955}let basis_10: key = key_s(me_2) in
    {956}let public_key_10: key = catch-fail(dhexp(basis_10,validkey(g))) in
    {957}let v_312: bool = not-caught-fail(public_key_10) in
    {958}let s_10: keypair = (if v_312 then keypairpack(validkey(public_key_10),basis_10) else fail-any) in
    {959}let basis_11: key = key_m(me_2) in
    {960}let public_key_11: key = catch-fail(dhexp(basis_11,validkey(g))) in
    {961}let v_313: bool = not-caught-fail(public_key_11) in
    {962}let m_10: keypair = (if v_313 then keypairpack(validkey(public_key_11),basis_11) else fail-any) in
    {963}out(pub, (getpublickey(s_10),getpublickey(m_10)));
    {954}let sid_3: sessionid = sid in
    {953}let them_2: principal = alice in
    (
        {965}let basis_12: key = key_s(them_2) in
        {966}let public_key_12: key = catch-fail(dhexp(basis_12,validkey(g))) in
        {967}let v_314: bool = not-caught-fail(public_key_12) in
        {968}let rs_10: key = getpublickey((if v_314 then keypairpack(validkey(public_key_12),basis_12) else fail-any)) in
        {969}let basis_13: key = key_m(them_2) in
        {970}let public_key_13: key = catch-fail(dhexp(basis_13,validkey(g))) in
        {971}let v_315: bool = not-caught-fail(public_key_13) in
        {972}let rm_10: key = getpublickey((if v_315 then keypairpack(validkey(public_key_13),basis_13) else fail-any)) in
        {979}let k_18: key = empty in
        {980}let cs_44: cipherstate = cipherstatepack(k_18,minnonce) in
        {976}let protocol_name_2: bitstring = somename in
        {977}let h_44: bitstring = hash(protocol_name_2,empty) in
        {978}let ck_54: key = h_44 in
        {981}let ss_50: symmetricstate = symmetricstatepack(cs_44,ck_54,h_44) in
        {982}let v_316: bitstring = catch-fail(symmetricstateunpack(ss_50)) in
        {983}let v_317: bool = (not-caught-fail(v_316) && success?(1-proj-3-tuple(v_316))) in
        {984}let h_45: bitstring = (if v_317 then 3-proj-3-tuple(v_316) else caught-fail) in
        {985}let ck_55: key = (if v_317 then 2-proj-3-tuple(v_316) else caught-fail) in
        {986}let cs_45: cipherstate = (if v_317 then 1-proj-3-tuple(v_316) else caught-fail) in
        {974}let prologue_2: bitstring = empty in
        {987}let ss_51: symmetricstate = catch-fail((if v_317 then symmetricstatepack(cs_45,ck_55,hash(h_45,prologue_2)) else fail-any)) in
        {988}let v_318: bool = not-caught-fail(ss_51) in
        {989}let v_319: bitstring = (if v_318 then catch-fail(symmetricstateunpack(ss_51)) else caught-fail) in
        {990}let v_320: bool = (not-caught-fail(v_319) && success?(1-proj-3-tuple(v_319))) in
        {991}let h_46: bitstring = (if v_320 then 3-proj-3-tuple(v_319) else caught-fail) in
        {992}let ck_56: key = (if v_320 then 2-proj-3-tuple(v_319) else caught-fail) in
        {993}let cs_46: cipherstate = (if v_320 then 1-proj-3-tuple(v_319) else caught-fail) in
        {994}let ss_52: symmetricstate = (if v_318 then catch-fail((if v_320 then symmetricstatepack(cs_46,ck_56,hash(h_46,rs_10)) else fail-any)) else caught-fail) in
        {995}let v_321: bool = not-caught-fail(ss_52) in
        {996}let v_322: bitstring = (if v_321 then catch-fail(symmetricstateunpack(ss_52)) else caught-fail) in
        {997}let v_323: bool = (not-caught-fail(v_322) && success?(1-proj-3-tuple(v_322))) in
        {998}let h_47: bitstring = (if v_323 then 3-proj-3-tuple(v_322) else caught-fail) in
        {999}let ck_57: key = (if v_323 then 2-proj-3-tuple(v_322) else caught-fail) in
        {1000}let cs_47: cipherstate = (if v_323 then 1-proj-3-tuple(v_322) else caught-fail) in
        {1001}let ss_53: symmetricstate = (if v_321 then catch-fail((if v_323 then symmetricstatepack(cs_47,ck_57,hash(h_47,rm_10)) else fail-any)) else caught-fail) in
        {1002}let v_324: bool = not-caught-fail(ss_53) in
        {1003}let data_4: bitstring = (if v_324 then catch-fail(getpublickey(s_10)) else caught-fail) in
        {1004}let v_325: bool = not-caught-fail(data_4) in
        {1005}let v_326: bitstring = (if v_325 then catch-fail(symmetricstateunpack(ss_53)) else caught-fail) in
        {1006}let v_327: bool = (not-caught-fail(v_326) && success?(1-proj-3-tuple(v_326))) in
        {1007}let h_48: bitstring = (if v_327 then 3-proj-3-tuple(v_326) else caught-fail) in
        {1008}let ck_58: key = (if v_327 then 2-proj-3-tuple(v_326) else caught-fail) in
        {1009}let cs_48: cipherstate = (if v_327 then 1-proj-3-tuple(v_326) else caught-fail) in
        {1010}let ss_54: symmetricstate = (if v_324 then catch-fail((if v_325 then (if v_327 then symmetricstatepack(cs_48,ck_58,hash(h_48,data_4)) else fail-any) else fail-any)) else caught-fail) in
        {1011}let v_328: bool = not-caught-fail(ss_54) in
        {1012}let data_5: bitstring = (if v_328 then catch-fail(getpublickey(m_10)) else caught-fail) in
        {1013}let v_329: bool = not-caught-fail(data_5) in
        {1014}let v_330: bitstring = (if v_329 then catch-fail(symmetricstateunpack(ss_54)) else caught-fail) in
        {1015}let v_331: bool = (not-caught-fail(v_330) && success?(1-proj-3-tuple(v_330))) in
        {1016}let h_49: bitstring = (if v_331 then 3-proj-3-tuple(v_330) else caught-fail) in
        {1017}let ck_59: key = (if v_331 then 2-proj-3-tuple(v_330) else caught-fail) in
        {1018}let cs_49: cipherstate = (if v_331 then 1-proj-3-tuple(v_330) else caught-fail) in
        {1019}let ss_55: symmetricstate = (if v_328 then catch-fail((if v_329 then (if v_331 then symmetricstatepack(cs_49,ck_59,hash(h_49,data_5)) else fail-any) else fail-any)) else caught-fail) in
        {1020}let v_332: bool = not-caught-fail(ss_55) in
        {975}let psk_10: key = empty in
        {973}let re_12: key = empty in
        {964}let e_16: keypair = keypairpack(empty,empty) in
        {1021}let hs_30: handshakestate = (if v_318 then (if v_321 then (if v_324 then (if v_328 then (if v_332 then handshakestatepack(ss_55,s_10,m_10,e_16,rs_10,rm_10,re_12,psk_10,false) else fail-any) else fail-any) else fail-any) else fail-any) else fail-any) in
        {1022}insert statestore(me_2,them_2,sid_3,statepack_a(hs_30))
    ) | (
        {1137}get statestore(=me_2,=them_2,=sid_3,statepack_a(hs_31: handshakestate)) in
        {1023}in(pub, message_a_2: bitstring);
        {1024}let v_333: bitstring = catch-fail(handshakestateunpack(hs_31)) in
        {1025}let v_334: bool = (not-caught-fail(v_333) && success?(1-proj-9-tuple(v_333))) in
        {1026}let initiator_9: bool = (if v_334 then 9-proj-9-tuple(v_333) else caught-fail) in
        {1027}let psk_11: key = (if v_334 then 8-proj-9-tuple(v_333) else caught-fail) in
        {1028}let re_13: key = (if v_334 then 7-proj-9-tuple(v_333) else caught-fail) in
        {1029}let rm_11: key = (if v_334 then 6-proj-9-tuple(v_333) else caught-fail) in
        {1030}let rs_11: key = (if v_334 then 5-proj-9-tuple(v_333) else caught-fail) in
        {1031}let e_17: keypair = (if v_334 then 4-proj-9-tuple(v_333) else caught-fail) in
        {1032}let m_11: keypair = (if v_334 then 3-proj-9-tuple(v_333) else caught-fail) in
        {1033}let s_11: keypair = (if v_334 then 2-proj-9-tuple(v_333) else caught-fail) in
        {1034}let ss_56: symmetricstate = (if v_334 then 1-proj-9-tuple(v_333) else caught-fail) in
        {1035}let v_335: bitstring = (if v_334 then catch-fail(deconcat3(message_a_2)) else caught-fail) in
        {1036}let v_336: bool = (not-caught-fail(v_335) && success?(1-proj-3-tuple(v_335))) in
        {1037}let ciphertext_16: bitstring = (if v_336 then 3-proj-3-tuple(v_335) else caught-fail) in
        {1038}let ns_8: bitstring = (if v_336 then 2-proj-3-tuple(v_335) else caught-fail) in
        {1039}let ne_10: bitstring = (if v_336 then 1-proj-3-tuple(v_335) else caught-fail) in
        {1042}let v_337: bitstring = (if v_336 then catch-fail(symmetricstateunpack(ss_56)) else caught-fail) in
        {1043}let v_338: bool = (not-caught-fail(v_337) && success?(1-proj-3-tuple(v_337))) in
        {1044}let h_50: bitstring = (if v_338 then 3-proj-3-tuple(v_337) else caught-fail) in
        {1045}let ck_60: key = (if v_338 then 2-proj-3-tuple(v_337) else caught-fail) in
        {1046}let cs_50: cipherstate = (if v_338 then 1-proj-3-tuple(v_337) else caught-fail) in
        {1041}let re_14: key = (if v_336 then ne_10 else caught-fail) in
        {1047}let ss_57: symmetricstate = (if v_336 then catch-fail((if v_338 then symmetricstatepack(cs_50,ck_60,hash(h_50,re_14)) else fail-any)) else caught-fail) in
        {1048}let v_339: bool = not-caught-fail(ss_57) in
        {1049}let v_340: bitstring = (if v_339 then catch-fail(keypairunpack(m_11)) else caught-fail) in
        {1050}let v_341: bool = (not-caught-fail(v_340) && success?(1-proj-2-tuple(v_340))) in
        {1051}let my_private_key_10: key = (if v_341 then 2-proj-2-tuple(v_340) else caught-fail) in
        {1052}let my_public_key_10: key = (if v_341 then 1-proj-2-tuple(v_340) else caught-fail) in
        {1053}let input_key_material_12: key = (if v_339 then catch-fail((if v_341 then dhexp(my_private_key_10,re_14) else fail-any)) else caught-fail) in
        {1054}let v_342: bool = not-caught-fail(input_key_material_12) in
        {1055}let v_343: bitstring = (if v_342 then catch-fail(symmetricstateunpack(ss_57)) else caught-fail) in
        {1056}let v_344: bool = (not-caught-fail(v_343) && success?(1-proj-3-tuple(v_343))) in
        {1057}let h_51: bitstring = (if v_344 then 3-proj-3-tuple(v_343) else caught-fail) in
        {1058}let ck_61: key = (if v_344 then 2-proj-3-tuple(v_343) else caught-fail) in
        {1059}let cs_51: cipherstate = (if v_344 then 1-proj-3-tuple(v_343) else caught-fail) in
        {1062}let output3_12: key = (if v_344 then hmac_hash3(ck_61,input_key_material_12) else caught-fail) in
        {1061}let output2_12: key = (if v_344 then hmac_hash2(ck_61,input_key_material_12) else caught-fail) in
        {1060}let output1_12: key = (if v_344 then hmac_hash1(ck_61,input_key_material_12) else caught-fail) in
        {1063}let v_345: bitstring = (if v_344 then catch-fail((output1_12,output2_12,output3_12)) else caught-fail) in
        {1064}let v_346: bool = (not-caught-fail(v_345) && success?(1-proj-3-tuple(v_345))) in
        {1065}let output_10: key = (if v_346 then 3-proj-3-tuple(v_345) else caught-fail) in
        {1066}let temp_k_10: key = (if v_346 then 2-proj-3-tuple(v_345) else caught-fail) in
        {1067}let ck_62: key = (if v_346 then 1-proj-3-tuple(v_345) else caught-fail) in
        {1068}let ss_58: symmetricstate = (if v_339 then catch-fail((if v_342 then (if v_344 then (if v_346 then symmetricstatepack(cipherstatepack(temp_k_10,minnonce),ck_62,h_51) else fail-any) else fail-any) else fail-any)) else caught-fail) in
        {1069}let v_347: bool = not-caught-fail(ss_58) in
        {1070}let v_348: bitstring = (if v_347 then catch-fail(keypairunpack(s_11)) else caught-fail) in
        {1071}let v_349: bool = (not-caught-fail(v_348) && success?(1-proj-2-tuple(v_348))) in
        {1072}let my_private_key_11: key = (if v_349 then 2-proj-2-tuple(v_348) else caught-fail) in
        {1073}let my_public_key_11: key = (if v_349 then 1-proj-2-tuple(v_348) else caught-fail) in
        {1074}let input_key_material_13: key = (if v_347 then catch-fail((if v_349 then dhexp(my_private_key_11,rm_11) else fail-any)) else caught-fail) in
        {1075}let v_350: bool = not-caught-fail(input_key_material_13) in
        {1076}let v_351: bitstring = (if v_350 then catch-fail(symmetricstateunpack(ss_58)) else caught-fail) in
        {1077}let v_352: bool = (not-caught-fail(v_351) && success?(1-proj-3-tuple(v_351))) in
        {1078}let h_52: bitstring = (if v_352 then 3-proj-3-tuple(v_351) else caught-fail) in
        {1079}let ck_63: key = (if v_352 then 2-proj-3-tuple(v_351) else caught-fail) in
        {1080}let cs_52: cipherstate = (if v_352 then 1-proj-3-tuple(v_351) else caught-fail) in
        {1083}let output3_13: key = (if v_352 then hmac_hash3(ck_63,input_key_material_13) else caught-fail) in
        {1082}let output2_13: key = (if v_352 then hmac_hash2(ck_63,input_key_material_13) else caught-fail) in
        {1081}let output1_13: key = (if v_352 then hmac_hash1(ck_63,input_key_material_13) else caught-fail) in
        {1084}let v_353: bitstring = (if v_352 then catch-fail((output1_13,output2_13,output3_13)) else caught-fail) in
        {1085}let v_354: bool = (not-caught-fail(v_353) && success?(1-proj-3-tuple(v_353))) in
        {1086}let output_11: key = (if v_354 then 3-proj-3-tuple(v_353) else caught-fail) in
        {1087}let temp_k_11: key = (if v_354 then 2-proj-3-tuple(v_353) else caught-fail) in
        {1088}let ck_64: key = (if v_354 then 1-proj-3-tuple(v_353) else caught-fail) in
        {1089}let ss_59: symmetricstate = (if v_347 then catch-fail((if v_350 then (if v_352 then (if v_354 then symmetricstatepack(cipherstatepack(temp_k_11,minnonce),ck_64,h_52) else fail-any) else fail-any) else fail-any)) else caught-fail) in
        {1090}let v_355: bool = not-caught-fail(ss_59) in
        {1091}let v_356: bitstring = (if v_355 then catch-fail(symmetricstateunpack(ss_59)) else caught-fail) in
        {1092}let v_357: bool = (not-caught-fail(v_356) && success?(1-proj-3-tuple(v_356))) in
        {1093}let h_53: bitstring = (if v_357 then 3-proj-3-tuple(v_356) else caught-fail) in
        {1094}let ck_65: key = (if v_357 then 2-proj-3-tuple(v_356) else caught-fail) in
        {1095}let cs_53: cipherstate = (if v_357 then 1-proj-3-tuple(v_356) else caught-fail) in
        {1096}let v_358: bitstring = (if v_357 then catch-fail(cipherstateunpack(cs_53)) else caught-fail) in
        {1097}let v_359: bool = (not-caught-fail(v_358) && success?(1-proj-2-tuple(v_358))) in
        {1098}let n_16: nonce = (if v_359 then 2-proj-2-tuple(v_358) else caught-fail) in
        {1099}let k_19: key = (if v_359 then 1-proj-2-tuple(v_358) else caught-fail) in
        {1100}let d_4: aead = (if v_359 then catch-fail(decrypt(k_19,n_16,h_53,ciphertext_16)) else caught-fail) in
        {1101}let v_360: bool = not-caught-fail(d_4) in
        {1102}let v_361: bitstring = (if v_360 then catch-fail(aeadunpack(d_4)) else caught-fail) in
        {1103}let v_362: bool = (not-caught-fail(v_361) && success?(1-proj-3-tuple(v_361))) in
        {1104}let plaintext_12: bitstring = (if v_362 then 3-proj-3-tuple(v_361) else caught-fail) in
        {1105}let adi_4: bitstring = (if v_362 then 2-proj-3-tuple(v_361) else caught-fail) in
        {1106}let valid_12: bool = (if v_362 then 1-proj-3-tuple(v_361) else caught-fail) in
        {1108}let v_363: bitstring = (if v_362 then catch-fail(cipherstateunpack(cs_53)) else caught-fail) in
        {1109}let v_364: bool = (not-caught-fail(v_363) && success?(1-proj-2-tuple(v_363))) in
        {1110}let o_8: nonce = (if v_364 then 2-proj-2-tuple(v_363) else caught-fail) in
        {1111}let k_20: key = (if v_364 then 1-proj-2-tuple(v_363) else caught-fail) in
        {1107}let n_17: nonce = (if v_362 then increment_nonce(n_16) else caught-fail) in
        {1112}let csi_16: cipherstate = (if v_362 then catch-fail((if v_364 then cipherstatepack(k_20,n_17) else fail-any)) else caught-fail) in
        {1113}let v_365: bool = not-caught-fail(csi_16) in
        {1114}let v_366: bitstring = (if v_357 then catch-fail((if v_359 then (if v_360 then (if v_362 then (if v_365 then (csi_16,plaintext_12,valid_12) else fail-any) else fail-any) else fail-any) else fail-any)) else caught-fail) in
        {1115}let v_367: bool = (not-caught-fail(v_366) && success?(1-proj-3-tuple(v_366))) in
        {1116}let valid_13: bool = (if v_367 then 3-proj-3-tuple(v_366) else caught-fail) in
        {1117}let plaintext_13: bitstring = (if v_367 then 2-proj-3-tuple(v_366) else caught-fail) in
        {1118}let csi_17: cipherstate = (if v_367 then 1-proj-3-tuple(v_366) else caught-fail) in
        {1119}let ss_60: symmetricstate = (if v_367 then symmetricstatepack(csi_17,ck_65,h_53) else caught-fail) in
        {1120}let v_368: bitstring = (if v_367 then catch-fail(symmetricstateunpack(ss_60)) else caught-fail) in
        {1121}let v_369: bool = (not-caught-fail(v_368) && success?(1-proj-3-tuple(v_368))) in
        {1122}let h_54: bitstring = (if v_369 then 3-proj-3-tuple(v_368) else caught-fail) in
        {1123}let ck_66: key = (if v_369 then 2-proj-3-tuple(v_368) else caught-fail) in
        {1124}let cs_54: cipherstate = (if v_369 then 1-proj-3-tuple(v_368) else caught-fail) in
        {1125}let ssi_10: symmetricstate = (if v_367 then catch-fail((if v_369 then symmetricstatepack(cs_54,ck_66,hash(h_54,ciphertext_16)) else fail-any)) else caught-fail) in
        {1126}let v_370: bool = not-caught-fail(ssi_10) in
        {1127}let v_371: bitstring = (if v_355 then catch-fail((if v_357 then (if v_367 then (if v_370 then (ssi_10,plaintext_13,valid_13) else fail-any) else fail-any) else fail-any)) else caught-fail) in
        {1128}let v_372: bool = (not-caught-fail(v_371) && success?(1-proj-3-tuple(v_371))) in
        {1129}let valid2_4: bool = (if v_372 then 3-proj-3-tuple(v_371) else caught-fail) in
        {1130}let plaintext_14: bitstring = (if v_372 then 2-proj-3-tuple(v_371) else caught-fail) in
        {1131}let ss_61: symmetricstate = (if v_372 then 1-proj-3-tuple(v_371) else caught-fail) in
        {1040}let valid1_4: bool = (if v_336 then true else caught-fail) in
        {1132}let v_373: bool = (if v_372 then catch-fail((valid1_4 && valid2_4)) else caught-fail) in
        {1133}let hs_32: handshakestate = (if v_373 then handshakestatepack(ss_61,s_11,m_11,e_17,rs_11,rm_11,re_14,psk_11,initiator_9) else caught-fail) in
        {1134}let (hs_33: handshakestate,plaintext_a: bitstring,valid_14: bool) = (if v_334 then (if v_336 then (if v_339 then (if v_347 then (if v_355 then (if v_372 then (if undo-catch-fail(v_373) then (hs_32,plaintext_14,true) else fail-any) else fail-any) else fail-any) else fail-any) else fail-any) else fail-any) else fail-any) in
        {1135}event RecvMsg(me_2,them_2,stagepack_a(sid_3),plaintext_a);
        {1136}insert statestore(me_2,them_2,sid_3,statepack_b(hs_33))
    ) | (
        {1292}get statestore(=me_2,=them_2,=sid_3,statepack_b(hs_34: handshakestate)) in
        {1139}let v_374: bitstring = catch-fail(handshakestateunpack(hs_34)) in
        {1140}let v_375: bool = (not-caught-fail(v_374) && success?(1-proj-9-tuple(v_374))) in
        {1141}let initiator_10: bool = (if v_375 then 9-proj-9-tuple(v_374) else caught-fail) in
        {1142}let psk_12: key = (if v_375 then 8-proj-9-tuple(v_374) else caught-fail) in
        {1143}let re_15: key = (if v_375 then 7-proj-9-tuple(v_374) else caught-fail) in
        {1144}let rm_12: key = (if v_375 then 6-proj-9-tuple(v_374) else caught-fail) in
        {1145}let rs_12: key = (if v_375 then 5-proj-9-tuple(v_374) else caught-fail) in
        {1146}let e_18: keypair = (if v_375 then 4-proj-9-tuple(v_374) else caught-fail) in
        {1147}let m_12: keypair = (if v_375 then 3-proj-9-tuple(v_374) else caught-fail) in
        {1148}let s_12: keypair = (if v_375 then 2-proj-9-tuple(v_374) else caught-fail) in
        {1149}let ss_62: symmetricstate = (if v_375 then 1-proj-9-tuple(v_374) else caught-fail) in
        {1150}let v_376: bitstring = (if v_375 then catch-fail((empty,empty,empty)) else caught-fail) in
        {1151}let v_377: bool = (not-caught-fail(v_376) && success?(1-proj-3-tuple(v_376))) in
        {1152}let ciphertext_17: bitstring = (if v_377 then 3-proj-3-tuple(v_376) else caught-fail) in
        {1153}let ns_9: bitstring = (if v_377 then 2-proj-3-tuple(v_376) else caught-fail) in
        {1154}let ne_11: bitstring = (if v_377 then 1-proj-3-tuple(v_376) else caught-fail) in
        {1155}let basis_14: key = (if v_377 then key_e(me_2,them_2,sid_3) else caught-fail) in
        {1156}let public_key_14: key = (if v_377 then catch-fail(dhexp(basis_14,validkey(g))) else caught-fail) in
        {1157}let v_378: bool = not-caught-fail(public_key_14) in
        {1158}let e_19: keypair = (if v_377 then catch-fail((if v_378 then keypairpack(validkey(public_key_14),basis_14) else fail-any)) else caught-fail) in
        {1159}let v_379: bool = not-caught-fail(e_19) in
        {1160}let ne_12: bitstring = (if v_379 then catch-fail(getpublickey(e_19)) else caught-fail) in
        {1161}let v_380: bool = not-caught-fail(ne_12) in
        {1162}let v_381: bitstring = (if v_380 then catch-fail(symmetricstateunpack(ss_62)) else caught-fail) in
        {1163}let v_382: bool = (not-caught-fail(v_381) && success?(1-proj-3-tuple(v_381))) in
        {1164}let h_55: bitstring = (if v_382 then 3-proj-3-tuple(v_381) else caught-fail) in
        {1165}let ck_67: key = (if v_382 then 2-proj-3-tuple(v_381) else caught-fail) in
        {1166}let cs_55: cipherstate = (if v_382 then 1-proj-3-tuple(v_381) else caught-fail) in
        {1167}let ss_63: symmetricstate = (if v_380 then catch-fail((if v_382 then symmetricstatepack(cs_55,ck_67,hash(h_55,ne_12)) else fail-any)) else caught-fail) in
        {1168}let v_383: bool = not-caught-fail(ss_63) in
        {1169}let v_384: bitstring = (if v_383 then catch-fail(keypairunpack(e_19)) else caught-fail) in
        {1170}let v_385: bool = (not-caught-fail(v_384) && success?(1-proj-2-tuple(v_384))) in
        {1171}let my_private_key_12: key = (if v_385 then 2-proj-2-tuple(v_384) else caught-fail) in
        {1172}let my_public_key_12: key = (if v_385 then 1-proj-2-tuple(v_384) else caught-fail) in
        {1173}let input_key_material_14: key = (if v_383 then catch-fail((if v_385 then dhexp(my_private_key_12,re_15) else fail-any)) else caught-fail) in
        {1174}let v_386: bool = not-caught-fail(input_key_material_14) in
        {1175}let v_387: bitstring = (if v_386 then catch-fail(symmetricstateunpack(ss_63)) else caught-fail) in
        {1176}let v_388: bool = (not-caught-fail(v_387) && success?(1-proj-3-tuple(v_387))) in
        {1177}let h_56: bitstring = (if v_388 then 3-proj-3-tuple(v_387) else caught-fail) in
        {1178}let ck_68: key = (if v_388 then 2-proj-3-tuple(v_387) else caught-fail) in
        {1179}let cs_56: cipherstate = (if v_388 then 1-proj-3-tuple(v_387) else caught-fail) in
        {1182}let output3_14: key = (if v_388 then hmac_hash3(ck_68,input_key_material_14) else caught-fail) in
        {1181}let output2_14: key = (if v_388 then hmac_hash2(ck_68,input_key_material_14) else caught-fail) in
        {1180}let output1_14: key = (if v_388 then hmac_hash1(ck_68,input_key_material_14) else caught-fail) in
        {1183}let v_389: bitstring = (if v_388 then catch-fail((output1_14,output2_14,output3_14)) else caught-fail) in
        {1184}let v_390: bool = (not-caught-fail(v_389) && success?(1-proj-3-tuple(v_389))) in
        {1185}let output_12: key = (if v_390 then 3-proj-3-tuple(v_389) else caught-fail) in
        {1186}let temp_k_12: key = (if v_390 then 2-proj-3-tuple(v_389) else caught-fail) in
        {1187}let ck_69: key = (if v_390 then 1-proj-3-tuple(v_389) else caught-fail) in
        {1188}let ss_64: symmetricstate = (if v_383 then catch-fail((if v_386 then (if v_388 then (if v_390 then symmetricstatepack(cipherstatepack(temp_k_12,minnonce),ck_69,h_56) else fail-any) else fail-any) else fail-any)) else caught-fail) in
        {1189}let v_391: bool = not-caught-fail(ss_64) in
        {1190}let v_392: bitstring = (if v_391 then catch-fail(keypairunpack(e_19)) else caught-fail) in
        {1191}let v_393: bool = (not-caught-fail(v_392) && success?(1-proj-2-tuple(v_392))) in
        {1192}let my_private_key_13: key = (if v_393 then 2-proj-2-tuple(v_392) else caught-fail) in
        {1193}let my_public_key_13: key = (if v_393 then 1-proj-2-tuple(v_392) else caught-fail) in
        {1194}let input_key_material_15: key = (if v_391 then catch-fail((if v_393 then dhexp(my_private_key_13,rs_12) else fail-any)) else caught-fail) in
        {1195}let v_394: bool = not-caught-fail(input_key_material_15) in
        {1196}let v_395: bitstring = (if v_394 then catch-fail(symmetricstateunpack(ss_64)) else caught-fail) in
        {1197}let v_396: bool = (not-caught-fail(v_395) && success?(1-proj-3-tuple(v_395))) in
        {1198}let h_57: bitstring = (if v_396 then 3-proj-3-tuple(v_395) else caught-fail) in
        {1199}let ck_70: key = (if v_396 then 2-proj-3-tuple(v_395) else caught-fail) in
        {1200}let cs_57: cipherstate = (if v_396 then 1-proj-3-tuple(v_395) else caught-fail) in
        {1203}let output3_15: key = (if v_396 then hmac_hash3(ck_70,input_key_material_15) else caught-fail) in
        {1202}let output2_15: key = (if v_396 then hmac_hash2(ck_70,input_key_material_15) else caught-fail) in
        {1201}let output1_15: key = (if v_396 then hmac_hash1(ck_70,input_key_material_15) else caught-fail) in
        {1204}let v_397: bitstring = (if v_396 then catch-fail((output1_15,output2_15,output3_15)) else caught-fail) in
        {1205}let v_398: bool = (not-caught-fail(v_397) && success?(1-proj-3-tuple(v_397))) in
        {1206}let output_13: key = (if v_398 then 3-proj-3-tuple(v_397) else caught-fail) in
        {1207}let temp_k_13: key = (if v_398 then 2-proj-3-tuple(v_397) else caught-fail) in
        {1208}let ck_71: key = (if v_398 then 1-proj-3-tuple(v_397) else caught-fail) in
        {1209}let ss_65: symmetricstate = (if v_391 then catch-fail((if v_394 then (if v_396 then (if v_398 then symmetricstatepack(cipherstatepack(temp_k_13,minnonce),ck_71,h_57) else fail-any) else fail-any) else fail-any)) else caught-fail) in
        {1210}let v_399: bool = not-caught-fail(ss_65) in
        {1211}let v_400: bitstring = (if v_399 then catch-fail(keypairunpack(e_19)) else caught-fail) in
        {1212}let v_401: bool = (not-caught-fail(v_400) && success?(1-proj-2-tuple(v_400))) in
        {1213}let my_private_key_14: key = (if v_401 then 2-proj-2-tuple(v_400) else caught-fail) in
        {1214}let my_public_key_14: key = (if v_401 then 1-proj-2-tuple(v_400) else caught-fail) in
        {1215}let input_key_material_16: key = (if v_399 then catch-fail((if v_401 then dhexp(my_private_key_14,rm_12) else fail-any)) else caught-fail) in
        {1216}let v_402: bool = not-caught-fail(input_key_material_16) in
        {1217}let v_403: bitstring = (if v_402 then catch-fail(symmetricstateunpack(ss_65)) else caught-fail) in
        {1218}let v_404: bool = (not-caught-fail(v_403) && success?(1-proj-3-tuple(v_403))) in
        {1219}let h_58: bitstring = (if v_404 then 3-proj-3-tuple(v_403) else caught-fail) in
        {1220}let ck_72: key = (if v_404 then 2-proj-3-tuple(v_403) else caught-fail) in
        {1221}let cs_58: cipherstate = (if v_404 then 1-proj-3-tuple(v_403) else caught-fail) in
        {1224}let output3_16: key = (if v_404 then hmac_hash3(ck_72,input_key_material_16) else caught-fail) in
        {1223}let output2_16: key = (if v_404 then hmac_hash2(ck_72,input_key_material_16) else caught-fail) in
        {1222}let output1_16: key = (if v_404 then hmac_hash1(ck_72,input_key_material_16) else caught-fail) in
        {1225}let v_405: bitstring = (if v_404 then catch-fail((output1_16,output2_16,output3_16)) else caught-fail) in
        {1226}let v_406: bool = (not-caught-fail(v_405) && success?(1-proj-3-tuple(v_405))) in
        {1227}let output_14: key = (if v_406 then 3-proj-3-tuple(v_405) else caught-fail) in
        {1228}let temp_k_14: key = (if v_406 then 2-proj-3-tuple(v_405) else caught-fail) in
        {1229}let ck_73: key = (if v_406 then 1-proj-3-tuple(v_405) else caught-fail) in
        {1230}let ss_66: symmetricstate = (if v_399 then catch-fail((if v_402 then (if v_404 then (if v_406 then symmetricstatepack(cipherstatepack(temp_k_14,minnonce),ck_73,h_58) else fail-any) else fail-any) else fail-any)) else caught-fail) in
        {1231}let v_407: bool = not-caught-fail(ss_66) in
        {1232}let v_408: bitstring = (if v_407 then catch-fail(symmetricstateunpack(ss_66)) else caught-fail) in
        {1233}let v_409: bool = (not-caught-fail(v_408) && success?(1-proj-3-tuple(v_408))) in
        {1234}let h_59: bitstring = (if v_409 then 3-proj-3-tuple(v_408) else caught-fail) in
        {1235}let ck_74: key = (if v_409 then 2-proj-3-tuple(v_408) else caught-fail) in
        {1236}let cs_59: cipherstate = (if v_409 then 1-proj-3-tuple(v_408) else caught-fail) in
        {1237}let v_410: bitstring = (if v_409 then catch-fail(cipherstateunpack(cs_59)) else caught-fail) in
        {1238}let v_411: bool = (not-caught-fail(v_410) && success?(1-proj-2-tuple(v_410))) in
        {1239}let n_18: nonce = (if v_411 then 2-proj-2-tuple(v_410) else caught-fail) in
        {1240}let k_21: key = (if v_411 then 1-proj-2-tuple(v_410) else caught-fail) in
        {1243}let v_412: bitstring = (if v_411 then catch-fail(cipherstateunpack(cs_59)) else caught-fail) in
        {1244}let v_413: bool = (not-caught-fail(v_412) && success?(1-proj-2-tuple(v_412))) in
        {1245}let o_9: nonce = (if v_413 then 2-proj-2-tuple(v_412) else caught-fail) in
        {1246}let k_22: key = (if v_413 then 1-proj-2-tuple(v_412) else caught-fail) in
        {1242}let n_19: nonce = (if v_411 then increment_nonce(n_18) else caught-fail) in
        {1247}let csi_18: cipherstate = (if v_411 then catch-fail((if v_413 then cipherstatepack(k_22,n_19) else fail-any)) else caught-fail) in
        {1248}let v_414: bool = not-caught-fail(csi_18) in
        {1138}let payload_4: bitstring = msg_b(me_2,them_2,sid_3) in
        {1241}let e_20: bitstring = (if v_411 then encrypt(k_21,n_18,h_59,payload_4) else caught-fail) in
        {1249}let v_415: bitstring = (if v_409 then catch-fail((if v_411 then (if v_414 then (csi_18,e_20) else fail-any) else fail-any)) else caught-fail) in
        {1250}let v_416: bool = (not-caught-fail(v_415) && success?(1-proj-2-tuple(v_415))) in
        {1251}let ciphertext_18: bitstring = (if v_416 then 2-proj-2-tuple(v_415) else caught-fail) in
        {1252}let csi_19: cipherstate = (if v_416 then 1-proj-2-tuple(v_415) else caught-fail) in
        {1253}let ss_67: symmetricstate = (if v_416 then symmetricstatepack(csi_19,ck_74,h_59) else caught-fail) in
        {1254}let v_417: bitstring = (if v_416 then catch-fail(symmetricstateunpack(ss_67)) else caught-fail) in
        {1255}let v_418: bool = (not-caught-fail(v_417) && success?(1-proj-3-tuple(v_417))) in
        {1256}let h_60: bitstring = (if v_418 then 3-proj-3-tuple(v_417) else caught-fail) in
        {1257}let ck_75: key = (if v_418 then 2-proj-3-tuple(v_417) else caught-fail) in
        {1258}let cs_60: cipherstate = (if v_418 then 1-proj-3-tuple(v_417) else caught-fail) in
        {1259}let ssi_11: symmetricstate = (if v_416 then catch-fail((if v_418 then symmetricstatepack(cs_60,ck_75,hash(h_60,ciphertext_18)) else fail-any)) else caught-fail) in
        {1260}let v_419: bool = not-caught-fail(ssi_11) in
        {1261}let v_420: bitstring = (if v_407 then catch-fail((if v_409 then (if v_416 then (if v_419 then (ssi_11,ciphertext_18) else fail-any) else fail-any) else fail-any)) else caught-fail) in
        {1262}let v_421: bool = (not-caught-fail(v_420) && success?(1-proj-2-tuple(v_420))) in
        {1263}let ciphertext_19: bitstring = (if v_421 then 2-proj-2-tuple(v_420) else caught-fail) in
        {1264}let ss_68: symmetricstate = (if v_421 then 1-proj-2-tuple(v_420) else caught-fail) in
        {1267}let v_422: bitstring = (if v_421 then catch-fail(symmetricstateunpack(ss_68)) else caught-fail) in
        {1268}let v_423: bool = (not-caught-fail(v_422) && success?(1-proj-3-tuple(v_422))) in
        {1269}let h_61: bitstring = (if v_423 then 3-proj-3-tuple(v_422) else caught-fail) in
        {1270}let ck_76: key = (if v_423 then 2-proj-3-tuple(v_422) else caught-fail) in
        {1271}let cs_61: cipherstate = (if v_423 then 1-proj-3-tuple(v_422) else caught-fail) in
        {1272}let input_key_material_17: key = (if v_423 then zero else caught-fail) in
        {1275}let output3_17: key = (if v_423 then hmac_hash3(ck_76,input_key_material_17) else caught-fail) in
        {1274}let output2_17: key = (if v_423 then hmac_hash2(ck_76,input_key_material_17) else caught-fail) in
        {1273}let output1_17: key = (if v_423 then hmac_hash1(ck_76,input_key_material_17) else caught-fail) in
        {1276}let v_424: bitstring = (if v_423 then catch-fail((output1_17,output2_17,output3_17)) else caught-fail) in
        {1277}let v_425: bool = (not-caught-fail(v_424) && success?(1-proj-3-tuple(v_424))) in
        {1278}let temp_k3_2: key = (if v_425 then 3-proj-3-tuple(v_424) else caught-fail) in
        {1279}let temp_k2_2: key = (if v_425 then 2-proj-3-tuple(v_424) else caught-fail) in
        {1280}let temp_k1_2: key = (if v_425 then 1-proj-3-tuple(v_424) else caught-fail) in
        {1282}let cs2_10: cipherstate = (if v_425 then cipherstatepack(temp_k2_2,minnonce) else caught-fail) in
        {1281}let cs1_10: cipherstate = (if v_425 then cipherstatepack(temp_k1_2,minnonce) else caught-fail) in
        {1283}let v_426: bitstring = (if v_421 then catch-fail((if v_423 then (if v_425 then (ss_68,cs1_10,cs2_10) else fail-any) else fail-any)) else caught-fail) in
        {1284}let v_427: bool = (not-caught-fail(v_426) && success?(1-proj-3-tuple(v_426))) in
        {1285}let cs2_11: cipherstate = (if v_427 then 3-proj-3-tuple(v_426) else caught-fail) in
        {1286}let cs1_11: cipherstate = (if v_427 then 2-proj-3-tuple(v_426) else caught-fail) in
        {1287}let ssi_12: symmetricstate = (if v_427 then 1-proj-3-tuple(v_426) else caught-fail) in
        {1266}let message_buffer_4: bitstring = (if v_421 then concat3(ne_12,ns_9,ciphertext_19) else caught-fail) in
        {1265}let hs_35: handshakestate = (if v_421 then handshakestatepack(ss_68,s_12,m_12,e_19,rs_12,rm_12,re_15,psk_12,initiator_10) else caught-fail) in
        {1288}let (hs_36: handshakestate,message_b_2: bitstring,cs1_12: cipherstate,cs2_12: cipherstate) = (if v_375 then (if v_377 then (if v_379 then (if v_380 then (if v_383 then (if v_391 then (if v_399 then (if v_407 then (if v_421 then (if v_427 then (hs_35,message_buffer_4,cs1_11,cs2_11) else fail-any) else fail-any) else fail-any) else fail-any) else fail-any) else fail-any) else fail-any) else fail-any) else fail-any) else fail-any) in
        {1289}event SendMsg(me_2,them_2,stagepack_b(sid_3),msg_b(me_2,them_2,sid_3));
        {1290}insert statestore(me_2,them_2,sid_3,statepack_c(hs_36,cs1_12,cs2_12));
        {1291}out(pub, message_b_2)
    ) | (
        {1293}!
        {1359}get statestore(=me_2,=them_2,=sid_3,statepack_c(hs_37: handshakestate,cs1_13: cipherstate,cs2_13: cipherstate)) in
        {1294}let hs_38: handshakestate = handshakestatesetcs(hs_37,cs1_13) in
        {1295}in(pub, message_c_2: bitstring);
        {1296}let v_428: bitstring = catch-fail(handshakestateunpack(hs_38)) in
        {1297}let v_429: bool = (not-caught-fail(v_428) && success?(1-proj-9-tuple(v_428))) in
        {1298}let initiator_11: bool = (if v_429 then 9-proj-9-tuple(v_428) else caught-fail) in
        {1299}let psk_13: key = (if v_429 then 8-proj-9-tuple(v_428) else caught-fail) in
        {1300}let re_16: key = (if v_429 then 7-proj-9-tuple(v_428) else caught-fail) in
        {1301}let rm_13: key = (if v_429 then 6-proj-9-tuple(v_428) else caught-fail) in
        {1302}let rs_13: key = (if v_429 then 5-proj-9-tuple(v_428) else caught-fail) in
        {1303}let e_21: keypair = (if v_429 then 4-proj-9-tuple(v_428) else caught-fail) in
        {1304}let m_13: keypair = (if v_429 then 3-proj-9-tuple(v_428) else caught-fail) in
        {1305}let s_13: keypair = (if v_429 then 2-proj-9-tuple(v_428) else caught-fail) in
        {1306}let ss_69: symmetricstate = (if v_429 then 1-proj-9-tuple(v_428) else caught-fail) in
        {1307}let v_430: bitstring = (if v_429 then catch-fail(deconcat3(message_c_2)) else caught-fail) in
        {1308}let v_431: bool = (not-caught-fail(v_430) && success?(1-proj-3-tuple(v_430))) in
        {1309}let ciphertext_20: bitstring = (if v_431 then 3-proj-3-tuple(v_430) else caught-fail) in
        {1310}let ns_10: bitstring = (if v_431 then 2-proj-3-tuple(v_430) else caught-fail) in
        {1311}let ne_13: bitstring = (if v_431 then 1-proj-3-tuple(v_430) else caught-fail) in
        {1313}let v_432: bitstring = (if v_431 then catch-fail(symmetricstateunpack(ss_69)) else caught-fail) in
        {1314}let v_433: bool = (not-caught-fail(v_432) && success?(1-proj-3-tuple(v_432))) in
        {1315}let h_62: bitstring = (if v_433 then 3-proj-3-tuple(v_432) else caught-fail) in
        {1316}let ck_77: key = (if v_433 then 2-proj-3-tuple(v_432) else caught-fail) in
        {1317}let cs_62: cipherstate = (if v_433 then 1-proj-3-tuple(v_432) else caught-fail) in
        {1318}let v_434: bitstring = (if v_433 then catch-fail(cipherstateunpack(cs_62)) else caught-fail) in
        {1319}let v_435: bool = (not-caught-fail(v_434) && success?(1-proj-2-tuple(v_434))) in
        {1320}let n_20: nonce = (if v_435 then 2-proj-2-tuple(v_434) else caught-fail) in
        {1321}let k_23: key = (if v_435 then 1-proj-2-tuple(v_434) else caught-fail) in
        {1322}let d_5: aead = (if v_435 then catch-fail(decrypt(k_23,n_20,h_62,ciphertext_20)) else caught-fail) in
        {1323}let v_436: bool = not-caught-fail(d_5) in
        {1324}let v_437: bitstring = (if v_436 then catch-fail(aeadunpack(d_5)) else caught-fail) in
        {1325}let v_438: bool = (not-caught-fail(v_437) && success?(1-proj-3-tuple(v_437))) in
        {1326}let plaintext_15: bitstring = (if v_438 then 3-proj-3-tuple(v_437) else caught-fail) in
        {1327}let adi_5: bitstring = (if v_438 then 2-proj-3-tuple(v_437) else caught-fail) in
        {1328}let valid_15: bool = (if v_438 then 1-proj-3-tuple(v_437) else caught-fail) in
        {1330}let v_439: bitstring = (if v_438 then catch-fail(cipherstateunpack(cs_62)) else caught-fail) in
        {1331}let v_440: bool = (not-caught-fail(v_439) && success?(1-proj-2-tuple(v_439))) in
        {1332}let o_10: nonce = (if v_440 then 2-proj-2-tuple(v_439) else caught-fail) in
        {1333}let k_24: key = (if v_440 then 1-proj-2-tuple(v_439) else caught-fail) in
        {1329}let n_21: nonce = (if v_438 then increment_nonce(n_20) else caught-fail) in
        {1334}let csi_20: cipherstate = (if v_438 then catch-fail((if v_440 then cipherstatepack(k_24,n_21) else fail-any)) else caught-fail) in
        {1335}let v_441: bool = not-caught-fail(csi_20) in
        {1336}let v_442: bitstring = (if v_433 then catch-fail((if v_435 then (if v_436 then (if v_438 then (if v_441 then (csi_20,plaintext_15,valid_15) else fail-any) else fail-any) else fail-any) else fail-any)) else caught-fail) in
        {1337}let v_443: bool = (not-caught-fail(v_442) && success?(1-proj-3-tuple(v_442))) in
        {1338}let valid_16: bool = (if v_443 then 3-proj-3-tuple(v_442) else caught-fail) in
        {1339}let plaintext_16: bitstring = (if v_443 then 2-proj-3-tuple(v_442) else caught-fail) in
        {1340}let csi_21: cipherstate = (if v_443 then 1-proj-3-tuple(v_442) else caught-fail) in
        {1341}let ss_70: symmetricstate = (if v_443 then symmetricstatepack(csi_21,ck_77,h_62) else caught-fail) in
        {1342}let v_444: bitstring = (if v_443 then catch-fail(symmetricstateunpack(ss_70)) else caught-fail) in
        {1343}let v_445: bool = (not-caught-fail(v_444) && success?(1-proj-3-tuple(v_444))) in
        {1344}let h_63: bitstring = (if v_445 then 3-proj-3-tuple(v_444) else caught-fail) in
        {1345}let ck_78: key = (if v_445 then 2-proj-3-tuple(v_444) else caught-fail) in
        {1346}let cs_63: cipherstate = (if v_445 then 1-proj-3-tuple(v_444) else caught-fail) in
        {1347}let ssi_13: symmetricstate = (if v_443 then catch-fail((if v_445 then symmetricstatepack(cs_63,ck_78,hash(h_63,ciphertext_20)) else fail-any)) else caught-fail) in
        {1348}let v_446: bool = not-caught-fail(ssi_13) in
        {1349}let v_447: bitstring = (if v_431 then catch-fail((if v_433 then (if v_443 then (if v_446 then (ssi_13,plaintext_16,valid_16) else fail-any) else fail-any) else fail-any)) else caught-fail) in
        {1350}let v_448: bool = (not-caught-fail(v_447) && success?(1-proj-3-tuple(v_447))) in
        {1351}let valid2_5: bool = (if v_448 then 3-proj-3-tuple(v_447) else caught-fail) in
        {1352}let plaintext_17: bitstring = (if v_448 then 2-proj-3-tuple(v_447) else caught-fail) in
        {1353}let ss_71: symmetricstate = (if v_448 then 1-proj-3-tuple(v_447) else caught-fail) in
        {1312}let valid1_5: bool = (if v_431 then true else caught-fail) in
        {1354}let v_449: bool = (if v_448 then catch-fail((valid1_5 && valid2_5)) else caught-fail) in
        {1355}let hs_39: handshakestate = (if v_449 then handshakestatepack(ss_71,s_13,m_13,e_21,rs_13,rm_13,re_16,psk_13,initiator_11) else caught-fail) in
        {1356}let (hs_40: handshakestate,plaintext_c: bitstring,valid_17: bool) = (if v_429 then (if v_431 then (if v_448 then (if undo-catch-fail(v_449) then (hs_39,plaintext_17,true) else fail-any) else fail-any) else fail-any) else fail-any) in
        {1357}event RecvMsg(me_2,them_2,stagepack_c(sid_3),plaintext_c);
        {1358}insert statestore(me_2,them_2,sid_3,statepack_d(hs_40,handshakestategetcs(hs_40),cs2_13))
    ) | (
        {1360}!
        {1417}get statestore(=me_2,=them_2,=sid_3,statepack_d(hs_41: handshakestate,cs1_14: cipherstate,cs2_14: cipherstate)) in
        {1361}let hs_42: handshakestate = handshakestatesetcs(hs_41,cs2_14) in
        {1363}let v_450: bitstring = catch-fail(handshakestateunpack(hs_42)) in
        {1364}let v_451: bool = (not-caught-fail(v_450) && success?(1-proj-9-tuple(v_450))) in
        {1365}let initiator_12: bool = (if v_451 then 9-proj-9-tuple(v_450) else caught-fail) in
        {1366}let psk_14: key = (if v_451 then 8-proj-9-tuple(v_450) else caught-fail) in
        {1367}let re_17: key = (if v_451 then 7-proj-9-tuple(v_450) else caught-fail) in
        {1368}let rm_14: key = (if v_451 then 6-proj-9-tuple(v_450) else caught-fail) in
        {1369}let rs_14: key = (if v_451 then 5-proj-9-tuple(v_450) else caught-fail) in
        {1370}let e_22: keypair = (if v_451 then 4-proj-9-tuple(v_450) else caught-fail) in
        {1371}let m_14: keypair = (if v_451 then 3-proj-9-tuple(v_450) else caught-fail) in
        {1372}let s_14: keypair = (if v_451 then 2-proj-9-tuple(v_450) else caught-fail) in
        {1373}let ss_72: symmetricstate = (if v_451 then 1-proj-9-tuple(v_450) else caught-fail) in
        {1374}let v_452: bitstring = (if v_451 then catch-fail((empty,empty,empty)) else caught-fail) in
        {1375}let v_453: bool = (not-caught-fail(v_452) && success?(1-proj-3-tuple(v_452))) in
        {1376}let ciphertext_21: bitstring = (if v_453 then 3-proj-3-tuple(v_452) else caught-fail) in
        {1377}let ns_11: bitstring = (if v_453 then 2-proj-3-tuple(v_452) else caught-fail) in
        {1378}let ne_14: bitstring = (if v_453 then 1-proj-3-tuple(v_452) else caught-fail) in
        {1379}let v_454: bitstring = (if v_453 then catch-fail(symmetricstateunpack(ss_72)) else caught-fail) in
        {1380}let v_455: bool = (not-caught-fail(v_454) && success?(1-proj-3-tuple(v_454))) in
        {1381}let h_64: bitstring = (if v_455 then 3-proj-3-tuple(v_454) else caught-fail) in
        {1382}let ck_79: key = (if v_455 then 2-proj-3-tuple(v_454) else caught-fail) in
        {1383}let cs_64: cipherstate = (if v_455 then 1-proj-3-tuple(v_454) else caught-fail) in
        {1384}let v_456: bitstring = (if v_455 then catch-fail(cipherstateunpack(cs_64)) else caught-fail) in
        {1385}let v_457: bool = (not-caught-fail(v_456) && success?(1-proj-2-tuple(v_456))) in
        {1386}let n_22: nonce = (if v_457 then 2-proj-2-tuple(v_456) else caught-fail) in
        {1387}let k_25: key = (if v_457 then 1-proj-2-tuple(v_456) else caught-fail) in
        {1390}let v_458: bitstring = (if v_457 then catch-fail(cipherstateunpack(cs_64)) else caught-fail) in
        {1391}let v_459: bool = (not-caught-fail(v_458) && success?(1-proj-2-tuple(v_458))) in
        {1392}let o_11: nonce = (if v_459 then 2-proj-2-tuple(v_458) else caught-fail) in
        {1393}let k_26: key = (if v_459 then 1-proj-2-tuple(v_458) else caught-fail) in
        {1389}let n_23: nonce = (if v_457 then increment_nonce(n_22) else caught-fail) in
        {1394}let csi_22: cipherstate = (if v_457 then catch-fail((if v_459 then cipherstatepack(k_26,n_23) else fail-any)) else caught-fail) in
        {1395}let v_460: bool = not-caught-fail(csi_22) in
        {1362}let payload_5: bitstring = msg_d(me_2,them_2,sid_3) in
        {1388}let e_23: bitstring = (if v_457 then encrypt(k_25,n_22,h_64,payload_5) else caught-fail) in
        {1396}let v_461: bitstring = (if v_455 then catch-fail((if v_457 then (if v_460 then (csi_22,e_23) else fail-any) else fail-any)) else caught-fail) in
        {1397}let v_462: bool = (not-caught-fail(v_461) && success?(1-proj-2-tuple(v_461))) in
        {1398}let ciphertext_22: bitstring = (if v_462 then 2-proj-2-tuple(v_461) else caught-fail) in
        {1399}let csi_23: cipherstate = (if v_462 then 1-proj-2-tuple(v_461) else caught-fail) in
        {1400}let ss_73: symmetricstate = (if v_462 then symmetricstatepack(csi_23,ck_79,h_64) else caught-fail) in
        {1401}let v_463: bitstring = (if v_462 then catch-fail(symmetricstateunpack(ss_73)) else caught-fail) in
        {1402}let v_464: bool = (not-caught-fail(v_463) && success?(1-proj-3-tuple(v_463))) in
        {1403}let h_65: bitstring = (if v_464 then 3-proj-3-tuple(v_463) else caught-fail) in
        {1404}let ck_80: key = (if v_464 then 2-proj-3-tuple(v_463) else caught-fail) in
        {1405}let cs_65: cipherstate = (if v_464 then 1-proj-3-tuple(v_463) else caught-fail) in
        {1406}let ssi_14: symmetricstate = (if v_462 then catch-fail((if v_464 then symmetricstatepack(cs_65,ck_80,hash(h_65,ciphertext_22)) else fail-any)) else caught-fail) in
        {1407}let v_465: bool = not-caught-fail(ssi_14) in
        {1408}let v_466: bitstring = (if v_453 then catch-fail((if v_455 then (if v_462 then (if v_465 then (ssi_14,ciphertext_22) else fail-any) else fail-any) else fail-any)) else caught-fail) in
        {1409}let v_467: bool = (not-caught-fail(v_466) && success?(1-proj-2-tuple(v_466))) in
        {1410}let ciphertext_23: bitstring = (if v_467 then 2-proj-2-tuple(v_466) else caught-fail) in
        {1411}let ss_74: symmetricstate = (if v_467 then 1-proj-2-tuple(v_466) else caught-fail) in
        {1413}let message_buffer_5: bitstring = (if v_467 then concat3(ne_14,ns_11,ciphertext_23) else caught-fail) in
        {1412}let hs_43: handshakestate = (if v_467 then handshakestatepack(ss_74,s_14,m_14,e_22,rs_14,rm_14,re_17,psk_14,initiator_12) else caught-fail) in
        {1414}let (hs_44: handshakestate,message_d_2: bitstring) = (if v_451 then (if v_453 then (if v_467 then (hs_43,message_buffer_5) else fail-any) else fail-any) else fail-any) in
        {1415}event SendMsg(me_2,them_2,stagepack_d(sid_3),msg_d(me_2,them_2,sid_3));
        {1416}out(pub, message_d_2)
    ) | (
        {1418}event LeakS(phase0,me_2);
        {1419}event LeakM(phase0,me_2);
        {1420}out(pub, (key_s(me_2),key_m(me_2)))
    ) | (
        {1421}phase 1;
        {1422}event LeakS(phase1,me_2);
        {1423}event LeakM(phase1,me_2);
        {1424}out(pub, (key_s(me_2),key_m(me_2)))
    )
) | (
    {1425}let me_3: principal = bob in
    {1428}let basis_15: key = key_s(me_3) in
    {1429}let public_key_15: key = catch-fail(dhexp(basis_15,validkey(g))) in
    {1430}let v_468: bool = not-caught-fail(public_key_15) in
    {1431}let s_15: keypair = (if v_468 then keypairpack(validkey(public_key_15),basis_15) else fail-any) in
    {1432}let basis_16: key = key_m(me_3) in
    {1433}let public_key_16: key = catch-fail(dhexp(basis_16,validkey(g))) in
    {1434}let v_469: bool = not-caught-fail(public_key_16) in
    {1435}let m_15: keypair = (if v_469 then keypairpack(validkey(public_key_16),basis_16) else fail-any) in
    {1436}out(pub, (getpublickey(s_15),getpublickey(m_15)));
    {1427}let sid_4: sessionid = sid in
    {1426}let them_3: principal = charlie in
    (
        {1438}let basis_17: key = key_s(them_3) in
        {1439}let public_key_17: key = catch-fail(dhexp(basis_17,validkey(g))) in
        {1440}let v_470: bool = not-caught-fail(public_key_17) in
        {1441}let rs_15: key = getpublickey((if v_470 then keypairpack(validkey(public_key_17),basis_17) else fail-any)) in
        {1442}let basis_18: key = key_m(them_3) in
        {1443}let public_key_18: key = catch-fail(dhexp(basis_18,validkey(g))) in
        {1444}let v_471: bool = not-caught-fail(public_key_18) in
        {1445}let rm_15: key = getpublickey((if v_471 then keypairpack(validkey(public_key_18),basis_18) else fail-any)) in
        {1452}let k_27: key = empty in
        {1453}let cs_66: cipherstate = cipherstatepack(k_27,minnonce) in
        {1449}let protocol_name_3: bitstring = somename in
        {1450}let h_66: bitstring = hash(protocol_name_3,empty) in
        {1451}let ck_81: key = h_66 in
        {1454}let ss_75: symmetricstate = symmetricstatepack(cs_66,ck_81,h_66) in
        {1455}let v_472: bitstring = catch-fail(symmetricstateunpack(ss_75)) in
        {1456}let v_473: bool = (not-caught-fail(v_472) && success?(1-proj-3-tuple(v_472))) in
        {1457}let h_67: bitstring = (if v_473 then 3-proj-3-tuple(v_472) else caught-fail) in
        {1458}let ck_82: key = (if v_473 then 2-proj-3-tuple(v_472) else caught-fail) in
        {1459}let cs_67: cipherstate = (if v_473 then 1-proj-3-tuple(v_472) else caught-fail) in
        {1447}let prologue_3: bitstring = empty in
        {1460}let ss_76: symmetricstate = catch-fail((if v_473 then symmetricstatepack(cs_67,ck_82,hash(h_67,prologue_3)) else fail-any)) in
        {1461}let v_474: bool = not-caught-fail(ss_76) in
        {1462}let v_475: bitstring = (if v_474 then catch-fail(symmetricstateunpack(ss_76)) else caught-fail) in
        {1463}let v_476: bool = (not-caught-fail(v_475) && success?(1-proj-3-tuple(v_475))) in
        {1464}let h_68: bitstring = (if v_476 then 3-proj-3-tuple(v_475) else caught-fail) in
        {1465}let ck_83: key = (if v_476 then 2-proj-3-tuple(v_475) else caught-fail) in
        {1466}let cs_68: cipherstate = (if v_476 then 1-proj-3-tuple(v_475) else caught-fail) in
        {1467}let ss_77: symmetricstate = (if v_474 then catch-fail((if v_476 then symmetricstatepack(cs_68,ck_83,hash(h_68,rs_15)) else fail-any)) else caught-fail) in
        {1468}let v_477: bool = not-caught-fail(ss_77) in
        {1469}let v_478: bitstring = (if v_477 then catch-fail(symmetricstateunpack(ss_77)) else caught-fail) in
        {1470}let v_479: bool = (not-caught-fail(v_478) && success?(1-proj-3-tuple(v_478))) in
        {1471}let h_69: bitstring = (if v_479 then 3-proj-3-tuple(v_478) else caught-fail) in
        {1472}let ck_84: key = (if v_479 then 2-proj-3-tuple(v_478) else caught-fail) in
        {1473}let cs_69: cipherstate = (if v_479 then 1-proj-3-tuple(v_478) else caught-fail) in
        {1474}let ss_78: symmetricstate = (if v_477 then catch-fail((if v_479 then symmetricstatepack(cs_69,ck_84,hash(h_69,rm_15)) else fail-any)) else caught-fail) in
        {1475}let v_480: bool = not-caught-fail(ss_78) in
        {1476}let data_6: bitstring = (if v_480 then catch-fail(getpublickey(s_15)) else caught-fail) in
        {1477}let v_481: bool = not-caught-fail(data_6) in
        {1478}let v_482: bitstring = (if v_481 then catch-fail(symmetricstateunpack(ss_78)) else caught-fail) in
        {1479}let v_483: bool = (not-caught-fail(v_482) && success?(1-proj-3-tuple(v_482))) in
        {1480}let h_70: bitstring = (if v_483 then 3-proj-3-tuple(v_482) else caught-fail) in
        {1481}let ck_85: key = (if v_483 then 2-proj-3-tuple(v_482) else caught-fail) in
        {1482}let cs_70: cipherstate = (if v_483 then 1-proj-3-tuple(v_482) else caught-fail) in
        {1483}let ss_79: symmetricstate = (if v_480 then catch-fail((if v_481 then (if v_483 then symmetricstatepack(cs_70,ck_85,hash(h_70,data_6)) else fail-any) else fail-any)) else caught-fail) in
        {1484}let v_484: bool = not-caught-fail(ss_79) in
        {1485}let data_7: bitstring = (if v_484 then catch-fail(getpublickey(m_15)) else caught-fail) in
        {1486}let v_485: bool = not-caught-fail(data_7) in
        {1487}let v_486: bitstring = (if v_485 then catch-fail(symmetricstateunpack(ss_79)) else caught-fail) in
        {1488}let v_487: bool = (not-caught-fail(v_486) && success?(1-proj-3-tuple(v_486))) in
        {1489}let h_71: bitstring = (if v_487 then 3-proj-3-tuple(v_486) else caught-fail) in
        {1490}let ck_86: key = (if v_487 then 2-proj-3-tuple(v_486) else caught-fail) in
        {1491}let cs_71: cipherstate = (if v_487 then 1-proj-3-tuple(v_486) else caught-fail) in
        {1492}let ss_80: symmetricstate = (if v_484 then catch-fail((if v_485 then (if v_487 then symmetricstatepack(cs_71,ck_86,hash(h_71,data_7)) else fail-any) else fail-any)) else caught-fail) in
        {1493}let v_488: bool = not-caught-fail(ss_80) in
        {1448}let psk_15: key = empty in
        {1446}let re_18: key = empty in
        {1437}let e_24: keypair = keypairpack(empty,empty) in
        {1494}let hs_45: handshakestate = (if v_474 then (if v_477 then (if v_480 then (if v_484 then (if v_488 then handshakestatepack(ss_80,s_15,m_15,e_24,rs_15,rm_15,re_18,psk_15,false) else fail-any) else fail-any) else fail-any) else fail-any) else fail-any) in
        {1495}insert statestore(me_3,them_3,sid_4,statepack_a(hs_45))
    ) | (
        {1610}get statestore(=me_3,=them_3,=sid_4,statepack_a(hs_46: handshakestate)) in
        {1496}in(pub, message_a_3: bitstring);
        {1497}let v_489: bitstring = catch-fail(handshakestateunpack(hs_46)) in
        {1498}let v_490: bool = (not-caught-fail(v_489) && success?(1-proj-9-tuple(v_489))) in
        {1499}let initiator_13: bool = (if v_490 then 9-proj-9-tuple(v_489) else caught-fail) in
        {1500}let psk_16: key = (if v_490 then 8-proj-9-tuple(v_489) else caught-fail) in
        {1501}let re_19: key = (if v_490 then 7-proj-9-tuple(v_489) else caught-fail) in
        {1502}let rm_16: key = (if v_490 then 6-proj-9-tuple(v_489) else caught-fail) in
        {1503}let rs_16: key = (if v_490 then 5-proj-9-tuple(v_489) else caught-fail) in
        {1504}let e_25: keypair = (if v_490 then 4-proj-9-tuple(v_489) else caught-fail) in
        {1505}let m_16: keypair = (if v_490 then 3-proj-9-tuple(v_489) else caught-fail) in
        {1506}let s_16: keypair = (if v_490 then 2-proj-9-tuple(v_489) else caught-fail) in
        {1507}let ss_81: symmetricstate = (if v_490 then 1-proj-9-tuple(v_489) else caught-fail) in
        {1508}let v_491: bitstring = (if v_490 then catch-fail(deconcat3(message_a_3)) else caught-fail) in
        {1509}let v_492: bool = (not-caught-fail(v_491) && success?(1-proj-3-tuple(v_491))) in
        {1510}let ciphertext_24: bitstring = (if v_492 then 3-proj-3-tuple(v_491) else caught-fail) in
        {1511}let ns_12: bitstring = (if v_492 then 2-proj-3-tuple(v_491) else caught-fail) in
        {1512}let ne_15: bitstring = (if v_492 then 1-proj-3-tuple(v_491) else caught-fail) in
        {1515}let v_493: bitstring = (if v_492 then catch-fail(symmetricstateunpack(ss_81)) else caught-fail) in
        {1516}let v_494: bool = (not-caught-fail(v_493) && success?(1-proj-3-tuple(v_493))) in
        {1517}let h_72: bitstring = (if v_494 then 3-proj-3-tuple(v_493) else caught-fail) in
        {1518}let ck_87: key = (if v_494 then 2-proj-3-tuple(v_493) else caught-fail) in
        {1519}let cs_72: cipherstate = (if v_494 then 1-proj-3-tuple(v_493) else caught-fail) in
        {1514}let re_20: key = (if v_492 then ne_15 else caught-fail) in
        {1520}let ss_82: symmetricstate = (if v_492 then catch-fail((if v_494 then symmetricstatepack(cs_72,ck_87,hash(h_72,re_20)) else fail-any)) else caught-fail) in
        {1521}let v_495: bool = not-caught-fail(ss_82) in
        {1522}let v_496: bitstring = (if v_495 then catch-fail(keypairunpack(m_16)) else caught-fail) in
        {1523}let v_497: bool = (not-caught-fail(v_496) && success?(1-proj-2-tuple(v_496))) in
        {1524}let my_private_key_15: key = (if v_497 then 2-proj-2-tuple(v_496) else caught-fail) in
        {1525}let my_public_key_15: key = (if v_497 then 1-proj-2-tuple(v_496) else caught-fail) in
        {1526}let input_key_material_18: key = (if v_495 then catch-fail((if v_497 then dhexp(my_private_key_15,re_20) else fail-any)) else caught-fail) in
        {1527}let v_498: bool = not-caught-fail(input_key_material_18) in
        {1528}let v_499: bitstring = (if v_498 then catch-fail(symmetricstateunpack(ss_82)) else caught-fail) in
        {1529}let v_500: bool = (not-caught-fail(v_499) && success?(1-proj-3-tuple(v_499))) in
        {1530}let h_73: bitstring = (if v_500 then 3-proj-3-tuple(v_499) else caught-fail) in
        {1531}let ck_88: key = (if v_500 then 2-proj-3-tuple(v_499) else caught-fail) in
        {1532}let cs_73: cipherstate = (if v_500 then 1-proj-3-tuple(v_499) else caught-fail) in
        {1535}let output3_18: key = (if v_500 then hmac_hash3(ck_88,input_key_material_18) else caught-fail) in
        {1534}let output2_18: key = (if v_500 then hmac_hash2(ck_88,input_key_material_18) else caught-fail) in
        {1533}let output1_18: key = (if v_500 then hmac_hash1(ck_88,input_key_material_18) else caught-fail) in
        {1536}let v_501: bitstring = (if v_500 then catch-fail((output1_18,output2_18,output3_18)) else caught-fail) in
        {1537}let v_502: bool = (not-caught-fail(v_501) && success?(1-proj-3-tuple(v_501))) in
        {1538}let output_15: key = (if v_502 then 3-proj-3-tuple(v_501) else caught-fail) in
        {1539}let temp_k_15: key = (if v_502 then 2-proj-3-tuple(v_501) else caught-fail) in
        {1540}let ck_89: key = (if v_502 then 1-proj-3-tuple(v_501) else caught-fail) in
        {1541}let ss_83: symmetricstate = (if v_495 then catch-fail((if v_498 then (if v_500 then (if v_502 then symmetricstatepack(cipherstatepack(temp_k_15,minnonce),ck_89,h_73) else fail-any) else fail-any) else fail-any)) else caught-fail) in
        {1542}let v_503: bool = not-caught-fail(ss_83) in
        {1543}let v_504: bitstring = (if v_503 then catch-fail(keypairunpack(s_16)) else caught-fail) in
        {1544}let v_505: bool = (not-caught-fail(v_504) && success?(1-proj-2-tuple(v_504))) in
        {1545}let my_private_key_16: key = (if v_505 then 2-proj-2-tuple(v_504) else caught-fail) in
        {1546}let my_public_key_16: key = (if v_505 then 1-proj-2-tuple(v_504) else caught-fail) in
        {1547}let input_key_material_19: key = (if v_503 then catch-fail((if v_505 then dhexp(my_private_key_16,rm_16) else fail-any)) else caught-fail) in
        {1548}let v_506: bool = not-caught-fail(input_key_material_19) in
        {1549}let v_507: bitstring = (if v_506 then catch-fail(symmetricstateunpack(ss_83)) else caught-fail) in
        {1550}let v_508: bool = (not-caught-fail(v_507) && success?(1-proj-3-tuple(v_507))) in
        {1551}let h_74: bitstring = (if v_508 then 3-proj-3-tuple(v_507) else caught-fail) in
        {1552}let ck_90: key = (if v_508 then 2-proj-3-tuple(v_507) else caught-fail) in
        {1553}let cs_74: cipherstate = (if v_508 then 1-proj-3-tuple(v_507) else caught-fail) in
        {1556}let output3_19: key = (if v_508 then hmac_hash3(ck_90,input_key_material_19) else caught-fail) in
        {1555}let output2_19: key = (if v_508 then hmac_hash2(ck_90,input_key_material_19) else caught-fail) in
        {1554}let output1_19: key = (if v_508 then hmac_hash1(ck_90,input_key_material_19) else caught-fail) in
        {1557}let v_509: bitstring = (if v_508 then catch-fail((output1_19,output2_19,output3_19)) else caught-fail) in
        {1558}let v_510: bool = (not-caught-fail(v_509) && success?(1-proj-3-tuple(v_509))) in
        {1559}let output_16: key = (if v_510 then 3-proj-3-tuple(v_509) else caught-fail) in
        {1560}let temp_k_16: key = (if v_510 then 2-proj-3-tuple(v_509) else caught-fail) in
        {1561}let ck_91: key = (if v_510 then 1-proj-3-tuple(v_509) else caught-fail) in
        {1562}let ss_84: symmetricstate = (if v_503 then catch-fail((if v_506 then (if v_508 then (if v_510 then symmetricstatepack(cipherstatepack(temp_k_16,minnonce),ck_91,h_74) else fail-any) else fail-any) else fail-any)) else caught-fail) in
        {1563}let v_511: bool = not-caught-fail(ss_84) in
        {1564}let v_512: bitstring = (if v_511 then catch-fail(symmetricstateunpack(ss_84)) else caught-fail) in
        {1565}let v_513: bool = (not-caught-fail(v_512) && success?(1-proj-3-tuple(v_512))) in
        {1566}let h_75: bitstring = (if v_513 then 3-proj-3-tuple(v_512) else caught-fail) in
        {1567}let ck_92: key = (if v_513 then 2-proj-3-tuple(v_512) else caught-fail) in
        {1568}let cs_75: cipherstate = (if v_513 then 1-proj-3-tuple(v_512) else caught-fail) in
        {1569}let v_514: bitstring = (if v_513 then catch-fail(cipherstateunpack(cs_75)) else caught-fail) in
        {1570}let v_515: bool = (not-caught-fail(v_514) && success?(1-proj-2-tuple(v_514))) in
        {1571}let n_24: nonce = (if v_515 then 2-proj-2-tuple(v_514) else caught-fail) in
        {1572}let k_28: key = (if v_515 then 1-proj-2-tuple(v_514) else caught-fail) in
        {1573}let d_6: aead = (if v_515 then catch-fail(decrypt(k_28,n_24,h_75,ciphertext_24)) else caught-fail) in
        {1574}let v_516: bool = not-caught-fail(d_6) in
        {1575}let v_517: bitstring = (if v_516 then catch-fail(aeadunpack(d_6)) else caught-fail) in
        {1576}let v_518: bool = (not-caught-fail(v_517) && success?(1-proj-3-tuple(v_517))) in
        {1577}let plaintext_18: bitstring = (if v_518 then 3-proj-3-tuple(v_517) else caught-fail) in
        {1578}let adi_6: bitstring = (if v_518 then 2-proj-3-tuple(v_517) else caught-fail) in
        {1579}let valid_18: bool = (if v_518 then 1-proj-3-tuple(v_517) else caught-fail) in
        {1581}let v_519: bitstring = (if v_518 then catch-fail(cipherstateunpack(cs_75)) else caught-fail) in
        {1582}let v_520: bool = (not-caught-fail(v_519) && success?(1-proj-2-tuple(v_519))) in
        {1583}let o_12: nonce = (if v_520 then 2-proj-2-tuple(v_519) else caught-fail) in
        {1584}let k_29: key = (if v_520 then 1-proj-2-tuple(v_519) else caught-fail) in
        {1580}let n_25: nonce = (if v_518 then increment_nonce(n_24) else caught-fail) in
        {1585}let csi_24: cipherstate = (if v_518 then catch-fail((if v_520 then cipherstatepack(k_29,n_25) else fail-any)) else caught-fail) in
        {1586}let v_521: bool = not-caught-fail(csi_24) in
        {1587}let v_522: bitstring = (if v_513 then catch-fail((if v_515 then (if v_516 then (if v_518 then (if v_521 then (csi_24,plaintext_18,valid_18) else fail-any) else fail-any) else fail-any) else fail-any)) else caught-fail) in
        {1588}let v_523: bool = (not-caught-fail(v_522) && success?(1-proj-3-tuple(v_522))) in
        {1589}let valid_19: bool = (if v_523 then 3-proj-3-tuple(v_522) else caught-fail) in
        {1590}let plaintext_19: bitstring = (if v_523 then 2-proj-3-tuple(v_522) else caught-fail) in
        {1591}let csi_25: cipherstate = (if v_523 then 1-proj-3-tuple(v_522) else caught-fail) in
        {1592}let ss_85: symmetricstate = (if v_523 then symmetricstatepack(csi_25,ck_92,h_75) else caught-fail) in
        {1593}let v_524: bitstring = (if v_523 then catch-fail(symmetricstateunpack(ss_85)) else caught-fail) in
        {1594}let v_525: bool = (not-caught-fail(v_524) && success?(1-proj-3-tuple(v_524))) in
        {1595}let h_76: bitstring = (if v_525 then 3-proj-3-tuple(v_524) else caught-fail) in
        {1596}let ck_93: key = (if v_525 then 2-proj-3-tuple(v_524) else caught-fail) in
        {1597}let cs_76: cipherstate = (if v_525 then 1-proj-3-tuple(v_524) else caught-fail) in
        {1598}let ssi_15: symmetricstate = (if v_523 then catch-fail((if v_525 then symmetricstatepack(cs_76,ck_93,hash(h_76,ciphertext_24)) else fail-any)) else caught-fail) in
        {1599}let v_526: bool = not-caught-fail(ssi_15) in
        {1600}let v_527: bitstring = (if v_511 then catch-fail((if v_513 then (if v_523 then (if v_526 then (ssi_15,plaintext_19,valid_19) else fail-any) else fail-any) else fail-any)) else caught-fail) in
        {1601}let v_528: bool = (not-caught-fail(v_527) && success?(1-proj-3-tuple(v_527))) in
        {1602}let valid2_6: bool = (if v_528 then 3-proj-3-tuple(v_527) else caught-fail) in
        {1603}let plaintext_20: bitstring = (if v_528 then 2-proj-3-tuple(v_527) else caught-fail) in
        {1604}let ss_86: symmetricstate = (if v_528 then 1-proj-3-tuple(v_527) else caught-fail) in
        {1513}let valid1_6: bool = (if v_492 then true else caught-fail) in
        {1605}let v_529: bool = (if v_528 then catch-fail((valid1_6 && valid2_6)) else caught-fail) in
        {1606}let hs_47: handshakestate = (if v_529 then handshakestatepack(ss_86,s_16,m_16,e_25,rs_16,rm_16,re_20,psk_16,initiator_13) else caught-fail) in
        {1607}let (hs_48: handshakestate,plaintext_a_1: bitstring,valid_20: bool) = (if v_490 then (if v_492 then (if v_495 then (if v_503 then (if v_511 then (if v_528 then (if undo-catch-fail(v_529) then (hs_47,plaintext_20,true) else fail-any) else fail-any) else fail-any) else fail-any) else fail-any) else fail-any) else fail-any) in
        {1608}event RecvMsg(me_3,them_3,stagepack_a(sid_4),plaintext_a_1);
        {1609}insert statestore(me_3,them_3,sid_4,statepack_b(hs_48))
    ) | (
        {1765}get statestore(=me_3,=them_3,=sid_4,statepack_b(hs_49: handshakestate)) in
        {1612}let v_530: bitstring = catch-fail(handshakestateunpack(hs_49)) in
        {1613}let v_531: bool = (not-caught-fail(v_530) && success?(1-proj-9-tuple(v_530))) in
        {1614}let initiator_14: bool = (if v_531 then 9-proj-9-tuple(v_530) else caught-fail) in
        {1615}let psk_17: key = (if v_531 then 8-proj-9-tuple(v_530) else caught-fail) in
        {1616}let re_21: key = (if v_531 then 7-proj-9-tuple(v_530) else caught-fail) in
        {1617}let rm_17: key = (if v_531 then 6-proj-9-tuple(v_530) else caught-fail) in
        {1618}let rs_17: key = (if v_531 then 5-proj-9-tuple(v_530) else caught-fail) in
        {1619}let e_26: keypair = (if v_531 then 4-proj-9-tuple(v_530) else caught-fail) in
        {1620}let m_17: keypair = (if v_531 then 3-proj-9-tuple(v_530) else caught-fail) in
        {1621}let s_17: keypair = (if v_531 then 2-proj-9-tuple(v_530) else caught-fail) in
        {1622}let ss_87: symmetricstate = (if v_531 then 1-proj-9-tuple(v_530) else caught-fail) in
        {1623}let v_532: bitstring = (if v_531 then catch-fail((empty,empty,empty)) else caught-fail) in
        {1624}let v_533: bool = (not-caught-fail(v_532) && success?(1-proj-3-tuple(v_532))) in
        {1625}let ciphertext_25: bitstring = (if v_533 then 3-proj-3-tuple(v_532) else caught-fail) in
        {1626}let ns_13: bitstring = (if v_533 then 2-proj-3-tuple(v_532) else caught-fail) in
        {1627}let ne_16: bitstring = (if v_533 then 1-proj-3-tuple(v_532) else caught-fail) in
        {1628}let basis_19: key = (if v_533 then key_e(me_3,them_3,sid_4) else caught-fail) in
        {1629}let public_key_19: key = (if v_533 then catch-fail(dhexp(basis_19,validkey(g))) else caught-fail) in
        {1630}let v_534: bool = not-caught-fail(public_key_19) in
        {1631}let e_27: keypair = (if v_533 then catch-fail((if v_534 then keypairpack(validkey(public_key_19),basis_19) else fail-any)) else caught-fail) in
        {1632}let v_535: bool = not-caught-fail(e_27) in
        {1633}let ne_17: bitstring = (if v_535 then catch-fail(getpublickey(e_27)) else caught-fail) in
        {1634}let v_536: bool = not-caught-fail(ne_17) in
        {1635}let v_537: bitstring = (if v_536 then catch-fail(symmetricstateunpack(ss_87)) else caught-fail) in
        {1636}let v_538: bool = (not-caught-fail(v_537) && success?(1-proj-3-tuple(v_537))) in
        {1637}let h_77: bitstring = (if v_538 then 3-proj-3-tuple(v_537) else caught-fail) in
        {1638}let ck_94: key = (if v_538 then 2-proj-3-tuple(v_537) else caught-fail) in
        {1639}let cs_77: cipherstate = (if v_538 then 1-proj-3-tuple(v_537) else caught-fail) in
        {1640}let ss_88: symmetricstate = (if v_536 then catch-fail((if v_538 then symmetricstatepack(cs_77,ck_94,hash(h_77,ne_17)) else fail-any)) else caught-fail) in
        {1641}let v_539: bool = not-caught-fail(ss_88) in
        {1642}let v_540: bitstring = (if v_539 then catch-fail(keypairunpack(e_27)) else caught-fail) in
        {1643}let v_541: bool = (not-caught-fail(v_540) && success?(1-proj-2-tuple(v_540))) in
        {1644}let my_private_key_17: key = (if v_541 then 2-proj-2-tuple(v_540) else caught-fail) in
        {1645}let my_public_key_17: key = (if v_541 then 1-proj-2-tuple(v_540) else caught-fail) in
        {1646}let input_key_material_20: key = (if v_539 then catch-fail((if v_541 then dhexp(my_private_key_17,re_21) else fail-any)) else caught-fail) in
        {1647}let v_542: bool = not-caught-fail(input_key_material_20) in
        {1648}let v_543: bitstring = (if v_542 then catch-fail(symmetricstateunpack(ss_88)) else caught-fail) in
        {1649}let v_544: bool = (not-caught-fail(v_543) && success?(1-proj-3-tuple(v_543))) in
        {1650}let h_78: bitstring = (if v_544 then 3-proj-3-tuple(v_543) else caught-fail) in
        {1651}let ck_95: key = (if v_544 then 2-proj-3-tuple(v_543) else caught-fail) in
        {1652}let cs_78: cipherstate = (if v_544 then 1-proj-3-tuple(v_543) else caught-fail) in
        {1655}let output3_20: key = (if v_544 then hmac_hash3(ck_95,input_key_material_20) else caught-fail) in
        {1654}let output2_20: key = (if v_544 then hmac_hash2(ck_95,input_key_material_20) else caught-fail) in
        {1653}let output1_20: key = (if v_544 then hmac_hash1(ck_95,input_key_material_20) else caught-fail) in
        {1656}let v_545: bitstring = (if v_544 then catch-fail((output1_20,output2_20,output3_20)) else caught-fail) in
        {1657}let v_546: bool = (not-caught-fail(v_545) && success?(1-proj-3-tuple(v_545))) in
        {1658}let output_17: key = (if v_546 then 3-proj-3-tuple(v_545) else caught-fail) in
        {1659}let temp_k_17: key = (if v_546 then 2-proj-3-tuple(v_545) else caught-fail) in
        {1660}let ck_96: key = (if v_546 then 1-proj-3-tuple(v_545) else caught-fail) in
        {1661}let ss_89: symmetricstate = (if v_539 then catch-fail((if v_542 then (if v_544 then (if v_546 then symmetricstatepack(cipherstatepack(temp_k_17,minnonce),ck_96,h_78) else fail-any) else fail-any) else fail-any)) else caught-fail) in
        {1662}let v_547: bool = not-caught-fail(ss_89) in
        {1663}let v_548: bitstring = (if v_547 then catch-fail(keypairunpack(e_27)) else caught-fail) in
        {1664}let v_549: bool = (not-caught-fail(v_548) && success?(1-proj-2-tuple(v_548))) in
        {1665}let my_private_key_18: key = (if v_549 then 2-proj-2-tuple(v_548) else caught-fail) in
        {1666}let my_public_key_18: key = (if v_549 then 1-proj-2-tuple(v_548) else caught-fail) in
        {1667}let input_key_material_21: key = (if v_547 then catch-fail((if v_549 then dhexp(my_private_key_18,rs_17) else fail-any)) else caught-fail) in
        {1668}let v_550: bool = not-caught-fail(input_key_material_21) in
        {1669}let v_551: bitstring = (if v_550 then catch-fail(symmetricstateunpack(ss_89)) else caught-fail) in
        {1670}let v_552: bool = (not-caught-fail(v_551) && success?(1-proj-3-tuple(v_551))) in
        {1671}let h_79: bitstring = (if v_552 then 3-proj-3-tuple(v_551) else caught-fail) in
        {1672}let ck_97: key = (if v_552 then 2-proj-3-tuple(v_551) else caught-fail) in
        {1673}let cs_79: cipherstate = (if v_552 then 1-proj-3-tuple(v_551) else caught-fail) in
        {1676}let output3_21: key = (if v_552 then hmac_hash3(ck_97,input_key_material_21) else caught-fail) in
        {1675}let output2_21: key = (if v_552 then hmac_hash2(ck_97,input_key_material_21) else caught-fail) in
        {1674}let output1_21: key = (if v_552 then hmac_hash1(ck_97,input_key_material_21) else caught-fail) in
        {1677}let v_553: bitstring = (if v_552 then catch-fail((output1_21,output2_21,output3_21)) else caught-fail) in
        {1678}let v_554: bool = (not-caught-fail(v_553) && success?(1-proj-3-tuple(v_553))) in
        {1679}let output_18: key = (if v_554 then 3-proj-3-tuple(v_553) else caught-fail) in
        {1680}let temp_k_18: key = (if v_554 then 2-proj-3-tuple(v_553) else caught-fail) in
        {1681}let ck_98: key = (if v_554 then 1-proj-3-tuple(v_553) else caught-fail) in
        {1682}let ss_90: symmetricstate = (if v_547 then catch-fail((if v_550 then (if v_552 then (if v_554 then symmetricstatepack(cipherstatepack(temp_k_18,minnonce),ck_98,h_79) else fail-any) else fail-any) else fail-any)) else caught-fail) in
        {1683}let v_555: bool = not-caught-fail(ss_90) in
        {1684}let v_556: bitstring = (if v_555 then catch-fail(keypairunpack(e_27)) else caught-fail) in
        {1685}let v_557: bool = (not-caught-fail(v_556) && success?(1-proj-2-tuple(v_556))) in
        {1686}let my_private_key_19: key = (if v_557 then 2-proj-2-tuple(v_556) else caught-fail) in
        {1687}let my_public_key_19: key = (if v_557 then 1-proj-2-tuple(v_556) else caught-fail) in
        {1688}let input_key_material_22: key = (if v_555 then catch-fail((if v_557 then dhexp(my_private_key_19,rm_17) else fail-any)) else caught-fail) in
        {1689}let v_558: bool = not-caught-fail(input_key_material_22) in
        {1690}let v_559: bitstring = (if v_558 then catch-fail(symmetricstateunpack(ss_90)) else caught-fail) in
        {1691}let v_560: bool = (not-caught-fail(v_559) && success?(1-proj-3-tuple(v_559))) in
        {1692}let h_80: bitstring = (if v_560 then 3-proj-3-tuple(v_559) else caught-fail) in
        {1693}let ck_99: key = (if v_560 then 2-proj-3-tuple(v_559) else caught-fail) in
        {1694}let cs_80: cipherstate = (if v_560 then 1-proj-3-tuple(v_559) else caught-fail) in
        {1697}let output3_22: key = (if v_560 then hmac_hash3(ck_99,input_key_material_22) else caught-fail) in
        {1696}let output2_22: key = (if v_560 then hmac_hash2(ck_99,input_key_material_22) else caught-fail) in
        {1695}let output1_22: key = (if v_560 then hmac_hash1(ck_99,input_key_material_22) else caught-fail) in
        {1698}let v_561: bitstring = (if v_560 then catch-fail((output1_22,output2_22,output3_22)) else caught-fail) in
        {1699}let v_562: bool = (not-caught-fail(v_561) && success?(1-proj-3-tuple(v_561))) in
        {1700}let output_19: key = (if v_562 then 3-proj-3-tuple(v_561) else caught-fail) in
        {1701}let temp_k_19: key = (if v_562 then 2-proj-3-tuple(v_561) else caught-fail) in
        {1702}let ck_100: key = (if v_562 then 1-proj-3-tuple(v_561) else caught-fail) in
        {1703}let ss_91: symmetricstate = (if v_555 then catch-fail((if v_558 then (if v_560 then (if v_562 then symmetricstatepack(cipherstatepack(temp_k_19,minnonce),ck_100,h_80) else fail-any) else fail-any) else fail-any)) else caught-fail) in
        {1704}let v_563: bool = not-caught-fail(ss_91) in
        {1705}let v_564: bitstring = (if v_563 then catch-fail(symmetricstateunpack(ss_91)) else caught-fail) in
        {1706}let v_565: bool = (not-caught-fail(v_564) && success?(1-proj-3-tuple(v_564))) in
        {1707}let h_81: bitstring = (if v_565 then 3-proj-3-tuple(v_564) else caught-fail) in
        {1708}let ck_101: key = (if v_565 then 2-proj-3-tuple(v_564) else caught-fail) in
        {1709}let cs_81: cipherstate = (if v_565 then 1-proj-3-tuple(v_564) else caught-fail) in
        {1710}let v_566: bitstring = (if v_565 then catch-fail(cipherstateunpack(cs_81)) else caught-fail) in
        {1711}let v_567: bool = (not-caught-fail(v_566) && success?(1-proj-2-tuple(v_566))) in
        {1712}let n_26: nonce = (if v_567 then 2-proj-2-tuple(v_566) else caught-fail) in
        {1713}let k_30: key = (if v_567 then 1-proj-2-tuple(v_566) else caught-fail) in
        {1716}let v_568: bitstring = (if v_567 then catch-fail(cipherstateunpack(cs_81)) else caught-fail) in
        {1717}let v_569: bool = (not-caught-fail(v_568) && success?(1-proj-2-tuple(v_568))) in
        {1718}let o_13: nonce = (if v_569 then 2-proj-2-tuple(v_568) else caught-fail) in
        {1719}let k_31: key = (if v_569 then 1-proj-2-tuple(v_568) else caught-fail) in
        {1715}let n_27: nonce = (if v_567 then increment_nonce(n_26) else caught-fail) in
        {1720}let csi_26: cipherstate = (if v_567 then catch-fail((if v_569 then cipherstatepack(k_31,n_27) else fail-any)) else caught-fail) in
        {1721}let v_570: bool = not-caught-fail(csi_26) in
        {1611}let payload_6: bitstring = msg_b(me_3,them_3,sid_4) in
        {1714}let e_28: bitstring = (if v_567 then encrypt(k_30,n_26,h_81,payload_6) else caught-fail) in
        {1722}let v_571: bitstring = (if v_565 then catch-fail((if v_567 then (if v_570 then (csi_26,e_28) else fail-any) else fail-any)) else caught-fail) in
        {1723}let v_572: bool = (not-caught-fail(v_571) && success?(1-proj-2-tuple(v_571))) in
        {1724}let ciphertext_26: bitstring = (if v_572 then 2-proj-2-tuple(v_571) else caught-fail) in
        {1725}let csi_27: cipherstate = (if v_572 then 1-proj-2-tuple(v_571) else caught-fail) in
        {1726}let ss_92: symmetricstate = (if v_572 then symmetricstatepack(csi_27,ck_101,h_81) else caught-fail) in
        {1727}let v_573: bitstring = (if v_572 then catch-fail(symmetricstateunpack(ss_92)) else caught-fail) in
        {1728}let v_574: bool = (not-caught-fail(v_573) && success?(1-proj-3-tuple(v_573))) in
        {1729}let h_82: bitstring = (if v_574 then 3-proj-3-tuple(v_573) else caught-fail) in
        {1730}let ck_102: key = (if v_574 then 2-proj-3-tuple(v_573) else caught-fail) in
        {1731}let cs_82: cipherstate = (if v_574 then 1-proj-3-tuple(v_573) else caught-fail) in
        {1732}let ssi_16: symmetricstate = (if v_572 then catch-fail((if v_574 then symmetricstatepack(cs_82,ck_102,hash(h_82,ciphertext_26)) else fail-any)) else caught-fail) in
        {1733}let v_575: bool = not-caught-fail(ssi_16) in
        {1734}let v_576: bitstring = (if v_563 then catch-fail((if v_565 then (if v_572 then (if v_575 then (ssi_16,ciphertext_26) else fail-any) else fail-any) else fail-any)) else caught-fail) in
        {1735}let v_577: bool = (not-caught-fail(v_576) && success?(1-proj-2-tuple(v_576))) in
        {1736}let ciphertext_27: bitstring = (if v_577 then 2-proj-2-tuple(v_576) else caught-fail) in
        {1737}let ss_93: symmetricstate = (if v_577 then 1-proj-2-tuple(v_576) else caught-fail) in
        {1740}let v_578: bitstring = (if v_577 then catch-fail(symmetricstateunpack(ss_93)) else caught-fail) in
        {1741}let v_579: bool = (not-caught-fail(v_578) && success?(1-proj-3-tuple(v_578))) in
        {1742}let h_83: bitstring = (if v_579 then 3-proj-3-tuple(v_578) else caught-fail) in
        {1743}let ck_103: key = (if v_579 then 2-proj-3-tuple(v_578) else caught-fail) in
        {1744}let cs_83: cipherstate = (if v_579 then 1-proj-3-tuple(v_578) else caught-fail) in
        {1745}let input_key_material_23: key = (if v_579 then zero else caught-fail) in
        {1748}let output3_23: key = (if v_579 then hmac_hash3(ck_103,input_key_material_23) else caught-fail) in
        {1747}let output2_23: key = (if v_579 then hmac_hash2(ck_103,input_key_material_23) else caught-fail) in
        {1746}let output1_23: key = (if v_579 then hmac_hash1(ck_103,input_key_material_23) else caught-fail) in
        {1749}let v_580: bitstring = (if v_579 then catch-fail((output1_23,output2_23,output3_23)) else caught-fail) in
        {1750}let v_581: bool = (not-caught-fail(v_580) && success?(1-proj-3-tuple(v_580))) in
        {1751}let temp_k3_3: key = (if v_581 then 3-proj-3-tuple(v_580) else caught-fail) in
        {1752}let temp_k2_3: key = (if v_581 then 2-proj-3-tuple(v_580) else caught-fail) in
        {1753}let temp_k1_3: key = (if v_581 then 1-proj-3-tuple(v_580) else caught-fail) in
        {1755}let cs2_15: cipherstate = (if v_581 then cipherstatepack(temp_k2_3,minnonce) else caught-fail) in
        {1754}let cs1_15: cipherstate = (if v_581 then cipherstatepack(temp_k1_3,minnonce) else caught-fail) in
        {1756}let v_582: bitstring = (if v_577 then catch-fail((if v_579 then (if v_581 then (ss_93,cs1_15,cs2_15) else fail-any) else fail-any)) else caught-fail) in
        {1757}let v_583: bool = (not-caught-fail(v_582) && success?(1-proj-3-tuple(v_582))) in
        {1758}let cs2_16: cipherstate = (if v_583 then 3-proj-3-tuple(v_582) else caught-fail) in
        {1759}let cs1_16: cipherstate = (if v_583 then 2-proj-3-tuple(v_582) else caught-fail) in
        {1760}let ssi_17: symmetricstate = (if v_583 then 1-proj-3-tuple(v_582) else caught-fail) in
        {1739}let message_buffer_6: bitstring = (if v_577 then concat3(ne_17,ns_13,ciphertext_27) else caught-fail) in
        {1738}let hs_50: handshakestate = (if v_577 then handshakestatepack(ss_93,s_17,m_17,e_27,rs_17,rm_17,re_21,psk_17,initiator_14) else caught-fail) in
        {1761}let (hs_51: handshakestate,message_b_3: bitstring,cs1_17: cipherstate,cs2_17: cipherstate) = (if v_531 then (if v_533 then (if v_535 then (if v_536 then (if v_539 then (if v_547 then (if v_555 then (if v_563 then (if v_577 then (if v_583 then (hs_50,message_buffer_6,cs1_16,cs2_16) else fail-any) else fail-any) else fail-any) else fail-any) else fail-any) else fail-any) else fail-any) else fail-any) else fail-any) else fail-any) in
        {1762}event SendMsg(me_3,them_3,stagepack_b(sid_4),msg_b(me_3,them_3,sid_4));
        {1763}insert statestore(me_3,them_3,sid_4,statepack_c(hs_51,cs1_17,cs2_17));
        {1764}out(pub, message_b_3)
    ) | (
        {1766}!
        {1832}get statestore(=me_3,=them_3,=sid_4,statepack_c(hs_52: handshakestate,cs1_18: cipherstate,cs2_18: cipherstate)) in
        {1767}let hs_53: handshakestate = handshakestatesetcs(hs_52,cs1_18) in
        {1768}in(pub, message_c_3: bitstring);
        {1769}let v_584: bitstring = catch-fail(handshakestateunpack(hs_53)) in
        {1770}let v_585: bool = (not-caught-fail(v_584) && success?(1-proj-9-tuple(v_584))) in
        {1771}let initiator_15: bool = (if v_585 then 9-proj-9-tuple(v_584) else caught-fail) in
        {1772}let psk_18: key = (if v_585 then 8-proj-9-tuple(v_584) else caught-fail) in
        {1773}let re_22: key = (if v_585 then 7-proj-9-tuple(v_584) else caught-fail) in
        {1774}let rm_18: key = (if v_585 then 6-proj-9-tuple(v_584) else caught-fail) in
        {1775}let rs_18: key = (if v_585 then 5-proj-9-tuple(v_584) else caught-fail) in
        {1776}let e_29: keypair = (if v_585 then 4-proj-9-tuple(v_584) else caught-fail) in
        {1777}let m_18: keypair = (if v_585 then 3-proj-9-tuple(v_584) else caught-fail) in
        {1778}let s_18: keypair = (if v_585 then 2-proj-9-tuple(v_584) else caught-fail) in
        {1779}let ss_94: symmetricstate = (if v_585 then 1-proj-9-tuple(v_584) else caught-fail) in
        {1780}let v_586: bitstring = (if v_585 then catch-fail(deconcat3(message_c_3)) else caught-fail) in
        {1781}let v_587: bool = (not-caught-fail(v_586) && success?(1-proj-3-tuple(v_586))) in
        {1782}let ciphertext_28: bitstring = (if v_587 then 3-proj-3-tuple(v_586) else caught-fail) in
        {1783}let ns_14: bitstring = (if v_587 then 2-proj-3-tuple(v_586) else caught-fail) in
        {1784}let ne_18: bitstring = (if v_587 then 1-proj-3-tuple(v_586) else caught-fail) in
        {1786}let v_588: bitstring = (if v_587 then catch-fail(symmetricstateunpack(ss_94)) else caught-fail) in
        {1787}let v_589: bool = (not-caught-fail(v_588) && success?(1-proj-3-tuple(v_588))) in
        {1788}let h_84: bitstring = (if v_589 then 3-proj-3-tuple(v_588) else caught-fail) in
        {1789}let ck_104: key = (if v_589 then 2-proj-3-tuple(v_588) else caught-fail) in
        {1790}let cs_84: cipherstate = (if v_589 then 1-proj-3-tuple(v_588) else caught-fail) in
        {1791}let v_590: bitstring = (if v_589 then catch-fail(cipherstateunpack(cs_84)) else caught-fail) in
        {1792}let v_591: bool = (not-caught-fail(v_590) && success?(1-proj-2-tuple(v_590))) in
        {1793}let n_28: nonce = (if v_591 then 2-proj-2-tuple(v_590) else caught-fail) in
        {1794}let k_32: key = (if v_591 then 1-proj-2-tuple(v_590) else caught-fail) in
        {1795}let d_7: aead = (if v_591 then catch-fail(decrypt(k_32,n_28,h_84,ciphertext_28)) else caught-fail) in
        {1796}let v_592: bool = not-caught-fail(d_7) in
        {1797}let v_593: bitstring = (if v_592 then catch-fail(aeadunpack(d_7)) else caught-fail) in
        {1798}let v_594: bool = (not-caught-fail(v_593) && success?(1-proj-3-tuple(v_593))) in
        {1799}let plaintext_21: bitstring = (if v_594 then 3-proj-3-tuple(v_593) else caught-fail) in
        {1800}let adi_7: bitstring = (if v_594 then 2-proj-3-tuple(v_593) else caught-fail) in
        {1801}let valid_21: bool = (if v_594 then 1-proj-3-tuple(v_593) else caught-fail) in
        {1803}let v_595: bitstring = (if v_594 then catch-fail(cipherstateunpack(cs_84)) else caught-fail) in
        {1804}let v_596: bool = (not-caught-fail(v_595) && success?(1-proj-2-tuple(v_595))) in
        {1805}let o_14: nonce = (if v_596 then 2-proj-2-tuple(v_595) else caught-fail) in
        {1806}let k_33: key = (if v_596 then 1-proj-2-tuple(v_595) else caught-fail) in
        {1802}let n_29: nonce = (if v_594 then increment_nonce(n_28) else caught-fail) in
        {1807}let csi_28: cipherstate = (if v_594 then catch-fail((if v_596 then cipherstatepack(k_33,n_29) else fail-any)) else caught-fail) in
        {1808}let v_597: bool = not-caught-fail(csi_28) in
        {1809}let v_598: bitstring = (if v_589 then catch-fail((if v_591 then (if v_592 then (if v_594 then (if v_597 then (csi_28,plaintext_21,valid_21) else fail-any) else fail-any) else fail-any) else fail-any)) else caught-fail) in
        {1810}let v_599: bool = (not-caught-fail(v_598) && success?(1-proj-3-tuple(v_598))) in
        {1811}let valid_22: bool = (if v_599 then 3-proj-3-tuple(v_598) else caught-fail) in
        {1812}let plaintext_22: bitstring = (if v_599 then 2-proj-3-tuple(v_598) else caught-fail) in
        {1813}let csi_29: cipherstate = (if v_599 then 1-proj-3-tuple(v_598) else caught-fail) in
        {1814}let ss_95: symmetricstate = (if v_599 then symmetricstatepack(csi_29,ck_104,h_84) else caught-fail) in
        {1815}let v_600: bitstring = (if v_599 then catch-fail(symmetricstateunpack(ss_95)) else caught-fail) in
        {1816}let v_601: bool = (not-caught-fail(v_600) && success?(1-proj-3-tuple(v_600))) in
        {1817}let h_85: bitstring = (if v_601 then 3-proj-3-tuple(v_600) else caught-fail) in
        {1818}let ck_105: key = (if v_601 then 2-proj-3-tuple(v_600) else caught-fail) in
        {1819}let cs_85: cipherstate = (if v_601 then 1-proj-3-tuple(v_600) else caught-fail) in
        {1820}let ssi_18: symmetricstate = (if v_599 then catch-fail((if v_601 then symmetricstatepack(cs_85,ck_105,hash(h_85,ciphertext_28)) else fail-any)) else caught-fail) in
        {1821}let v_602: bool = not-caught-fail(ssi_18) in
        {1822}let v_603: bitstring = (if v_587 then catch-fail((if v_589 then (if v_599 then (if v_602 then (ssi_18,plaintext_22,valid_22) else fail-any) else fail-any) else fail-any)) else caught-fail) in
        {1823}let v_604: bool = (not-caught-fail(v_603) && success?(1-proj-3-tuple(v_603))) in
        {1824}let valid2_7: bool = (if v_604 then 3-proj-3-tuple(v_603) else caught-fail) in
        {1825}let plaintext_23: bitstring = (if v_604 then 2-proj-3-tuple(v_603) else caught-fail) in
        {1826}let ss_96: symmetricstate = (if v_604 then 1-proj-3-tuple(v_603) else caught-fail) in
        {1785}let valid1_7: bool = (if v_587 then true else caught-fail) in
        {1827}let v_605: bool = (if v_604 then catch-fail((valid1_7 && valid2_7)) else caught-fail) in
        {1828}let hs_54: handshakestate = (if v_605 then handshakestatepack(ss_96,s_18,m_18,e_29,rs_18,rm_18,re_22,psk_18,initiator_15) else caught-fail) in
        {1829}let (hs_55: handshakestate,plaintext_c_1: bitstring,valid_23: bool) = (if v_585 then (if v_587 then (if v_604 then (if undo-catch-fail(v_605) then (hs_54,plaintext_23,true) else fail-any) else fail-any) else fail-any) else fail-any) in
        {1830}event RecvMsg(me_3,them_3,stagepack_c(sid_4),plaintext_c_1);
        {1831}insert statestore(me_3,them_3,sid_4,statepack_d(hs_55,handshakestategetcs(hs_55),cs2_18))
    ) | (
        {1833}!
        {1890}get statestore(=me_3,=them_3,=sid_4,statepack_d(hs_56: handshakestate,cs1_19: cipherstate,cs2_19: cipherstate)) in
        {1834}let hs_57: handshakestate = handshakestatesetcs(hs_56,cs2_19) in
        {1836}let v_606: bitstring = catch-fail(handshakestateunpack(hs_57)) in
        {1837}let v_607: bool = (not-caught-fail(v_606) && success?(1-proj-9-tuple(v_606))) in
        {1838}let initiator_16: bool = (if v_607 then 9-proj-9-tuple(v_606) else caught-fail) in
        {1839}let psk_19: key = (if v_607 then 8-proj-9-tuple(v_606) else caught-fail) in
        {1840}let re_23: key = (if v_607 then 7-proj-9-tuple(v_606) else caught-fail) in
        {1841}let rm_19: key = (if v_607 then 6-proj-9-tuple(v_606) else caught-fail) in
        {1842}let rs_19: key = (if v_607 then 5-proj-9-tuple(v_606) else caught-fail) in
        {1843}let e_30: keypair = (if v_607 then 4-proj-9-tuple(v_606) else caught-fail) in
        {1844}let m_19: keypair = (if v_607 then 3-proj-9-tuple(v_606) else caught-fail) in
        {1845}let s_19: keypair = (if v_607 then 2-proj-9-tuple(v_606) else caught-fail) in
        {1846}let ss_97: symmetricstate = (if v_607 then 1-proj-9-tuple(v_606) else caught-fail) in
        {1847}let v_608: bitstring = (if v_607 then catch-fail((empty,empty,empty)) else caught-fail) in
        {1848}let v_609: bool = (not-caught-fail(v_608) && success?(1-proj-3-tuple(v_608))) in
        {1849}let ciphertext_29: bitstring = (if v_609 then 3-proj-3-tuple(v_608) else caught-fail) in
        {1850}let ns_15: bitstring = (if v_609 then 2-proj-3-tuple(v_608) else caught-fail) in
        {1851}let ne_19: bitstring = (if v_609 then 1-proj-3-tuple(v_608) else caught-fail) in
        {1852}let v_610: bitstring = (if v_609 then catch-fail(symmetricstateunpack(ss_97)) else caught-fail) in
        {1853}let v_611: bool = (not-caught-fail(v_610) && success?(1-proj-3-tuple(v_610))) in
        {1854}let h_86: bitstring = (if v_611 then 3-proj-3-tuple(v_610) else caught-fail) in
        {1855}let ck_106: key = (if v_611 then 2-proj-3-tuple(v_610) else caught-fail) in
        {1856}let cs_86: cipherstate = (if v_611 then 1-proj-3-tuple(v_610) else caught-fail) in
        {1857}let v_612: bitstring = (if v_611 then catch-fail(cipherstateunpack(cs_86)) else caught-fail) in
        {1858}let v_613: bool = (not-caught-fail(v_612) && success?(1-proj-2-tuple(v_612))) in
        {1859}let n_30: nonce = (if v_613 then 2-proj-2-tuple(v_612) else caught-fail) in
        {1860}let k_34: key = (if v_613 then 1-proj-2-tuple(v_612) else caught-fail) in
        {1863}let v_614: bitstring = (if v_613 then catch-fail(cipherstateunpack(cs_86)) else caught-fail) in
        {1864}let v_615: bool = (not-caught-fail(v_614) && success?(1-proj-2-tuple(v_614))) in
        {1865}let o_15: nonce = (if v_615 then 2-proj-2-tuple(v_614) else caught-fail) in
        {1866}let k_35: key = (if v_615 then 1-proj-2-tuple(v_614) else caught-fail) in
        {1862}let n_31: nonce = (if v_613 then increment_nonce(n_30) else caught-fail) in
        {1867}let csi_30: cipherstate = (if v_613 then catch-fail((if v_615 then cipherstatepack(k_35,n_31) else fail-any)) else caught-fail) in
        {1868}let v_616: bool = not-caught-fail(csi_30) in
        {1835}let payload_7: bitstring = msg_d(me_3,them_3,sid_4) in
        {1861}let e_31: bitstring = (if v_613 then encrypt(k_34,n_30,h_86,payload_7) else caught-fail) in
        {1869}let v_617: bitstring = (if v_611 then catch-fail((if v_613 then (if v_616 then (csi_30,e_31) else fail-any) else fail-any)) else caught-fail) in
        {1870}let v_618: bool = (not-caught-fail(v_617) && success?(1-proj-2-tuple(v_617))) in
        {1871}let ciphertext_30: bitstring = (if v_618 then 2-proj-2-tuple(v_617) else caught-fail) in
        {1872}let csi_31: cipherstate = (if v_618 then 1-proj-2-tuple(v_617) else caught-fail) in
        {1873}let ss_98: symmetricstate = (if v_618 then symmetricstatepack(csi_31,ck_106,h_86) else caught-fail) in
        {1874}let v_619: bitstring = (if v_618 then catch-fail(symmetricstateunpack(ss_98)) else caught-fail) in
        {1875}let v_620: bool = (not-caught-fail(v_619) && success?(1-proj-3-tuple(v_619))) in
        {1876}let h_87: bitstring = (if v_620 then 3-proj-3-tuple(v_619) else caught-fail) in
        {1877}let ck_107: key = (if v_620 then 2-proj-3-tuple(v_619) else caught-fail) in
        {1878}let cs_87: cipherstate = (if v_620 then 1-proj-3-tuple(v_619) else caught-fail) in
        {1879}let ssi_19: symmetricstate = (if v_618 then catch-fail((if v_620 then symmetricstatepack(cs_87,ck_107,hash(h_87,ciphertext_30)) else fail-any)) else caught-fail) in
        {1880}let v_621: bool = not-caught-fail(ssi_19) in
        {1881}let v_622: bitstring = (if v_609 then catch-fail((if v_611 then (if v_618 then (if v_621 then (ssi_19,ciphertext_30) else fail-any) else fail-any) else fail-any)) else caught-fail) in
        {1882}let v_623: bool = (not-caught-fail(v_622) && success?(1-proj-2-tuple(v_622))) in
        {1883}let ciphertext_31: bitstring = (if v_623 then 2-proj-2-tuple(v_622) else caught-fail) in
        {1884}let ss_99: symmetricstate = (if v_623 then 1-proj-2-tuple(v_622) else caught-fail) in
        {1886}let message_buffer_7: bitstring = (if v_623 then concat3(ne_19,ns_15,ciphertext_31) else caught-fail) in
        {1885}let hs_58: handshakestate = (if v_623 then handshakestatepack(ss_99,s_19,m_19,e_30,rs_19,rm_19,re_23,psk_19,initiator_16) else caught-fail) in
        {1887}let (hs_59: handshakestate,message_d_3: bitstring) = (if v_607 then (if v_609 then (if v_623 then (hs_58,message_buffer_7) else fail-any) else fail-any) else fail-any) in
        {1888}event SendMsg(me_3,them_3,stagepack_d(sid_4),msg_d(me_3,them_3,sid_4));
        {1889}out(pub, message_d_3)
    ) | (
        {1891}event LeakS(phase0,me_3);
        {1892}event LeakM(phase0,me_3);
        {1893}out(pub, (key_s(me_3),key_m(me_3)))
    ) | (
        {1894}phase 1;
        {1895}event LeakS(phase1,me_3);
        {1896}event LeakM(phase1,me_3);
        {1897}out(pub, (key_s(me_3),key_m(me_3)))
    )
)

-- Query event(RecvMsg(bob,alice,stagepack_a(sid_b),msg)) ==> event(SendMsg(alice,bob,stagepack_a(sid_a),msg)); event(RecvMsg(bob,alice,stagepack_a(sid_b),msg)) ==> event(SendMsg(alice,c,stagepack_a(sid_a),msg)) || (event(LeakS(phase0,alice)) && event(LeakM(phase0,alice))) || (event(LeakS(phase0,bob)) && event(LeakM(phase0,bob))); event(RecvMsg(bob,alice,stagepack_a(sid_b),msg)) ==> event(SendMsg(alice,c,stagepack_a(sid_a),msg)) || (event(LeakS(phase0,alice)) && event(LeakM(phase0,alice))); event(RecvMsg(bob,alice,stagepack_a(sid_b),msg)) ==> event(SendMsg(alice,bob,stagepack_a(sid_a),msg)) || (event(LeakS(phase0,alice)) && event(LeakM(phase0,alice))) || (event(LeakS(phase0,bob)) && event(LeakM(phase0,bob))); event(RecvMsg(bob,alice,stagepack_a(sid_b),msg)) ==> event(SendMsg(alice,bob,stagepack_a(sid_a),msg)) || (event(LeakS(phase0,alice)) && event(LeakM(phase0,alice))); not attacker_p1(msg_a(alice,bob,sid_a)); attacker_p1(msg_a(alice,bob,sid_a)) ==> event(LeakS(px,bob)) && event(LeakM(px,bob)); attacker_p1(msg_a(alice,bob,sid_a)) ==> (event(LeakS(phase0,bob)) && event(LeakM(phase0,bob))) || (event(LeakS(px,bob)) && event(LeakM(px,bob)) && event(LeakS(pz,alice)) && event(LeakM(pz,alice))); attacker_p1(msg_a(alice,bob,sid_a)) ==> event(LeakS(phase0,bob)) && event(LeakM(phase0,bob)); event(RecvMsg(alice,bob,stagepack_b(sid_a),msg)) ==> event(SendMsg(bob,alice,stagepack_b(sid_b),msg)); event(RecvMsg(alice,bob,stagepack_b(sid_a),msg)) ==> event(SendMsg(bob,c,stagepack_b(sid_b),msg)) || (event(LeakS(phase0,bob)) && event(LeakM(phase0,bob))) || (event(LeakS(phase0,alice)) && event(LeakM(phase0,alice))); event(RecvMsg(alice,bob,stagepack_b(sid_a),msg)) ==> event(SendMsg(bob,c,stagepack_b(sid_b),msg)) || (event(LeakS(phase0,bob)) && event(LeakM(phase0,bob))); event(RecvMsg(alice,bob,stagepack_b(sid_a),msg)) ==> event(SendMsg(bob,alice,stagepack_b(sid_b),msg)) || (event(LeakS(phase0,bob)) && event(LeakM(phase0,bob))) || (event(LeakS(phase0,alice)) && event(LeakM(phase0,alice))); event(RecvMsg(alice,bob,stagepack_b(sid_a),msg)) ==> event(SendMsg(bob,alice,stagepack_b(sid_b),msg)) || (event(LeakS(phase0,bob)) && event(LeakM(phase0,bob))); not attacker_p1(msg_b(bob,alice,sid_b)); attacker_p1(msg_b(bob,alice,sid_b)) ==> event(LeakS(px,alice)) && event(LeakM(px,alice)); attacker_p1(msg_b(bob,alice,sid_b)) ==> (event(LeakS(phase0,alice)) && event(LeakM(phase0,alice))) || (event(LeakS(px,alice)) && event(LeakM(px,alice)) && event(LeakS(pz,bob)) && event(LeakM(pz,bob))); attacker_p1(msg_b(bob,alice,sid_b)) ==> event(LeakS(phase0,alice)) && event(LeakM(phase0,alice)); event(RecvMsg(bob,alice,stagepack_c(sid_b),msg)) ==> event(SendMsg(alice,bob,stagepack_c(sid_a),msg)); event(RecvMsg(bob,alice,stagepack_c(sid_b),msg)) ==> event(SendMsg(alice,c,stagepack_c(sid_a),msg)) || (event(LeakS(phase0,alice)) && event(LeakM(phase0,alice))) || (event(LeakS(phase0,bob)) && event(LeakM(phase0,bob))); event(RecvMsg(bob,alice,stagepack_c(sid_b),msg)) ==> event(SendMsg(alice,c,stagepack_c(sid_a),msg)) || (event(LeakS(phase0,alice)) && event(LeakM(phase0,alice))); event(RecvMsg(bob,alice,stagepack_c(sid_b),msg)) ==> event(SendMsg(alice,bob,stagepack_c(sid_a),msg)) || (event(LeakS(phase0,alice)) && event(LeakM(phase0,alice))) || (event(LeakS(phase0,bob)) && event(LeakM(phase0,bob))); event(RecvMsg(bob,alice,stagepack_c(sid_b),msg)) ==> event(SendMsg(alice,bob,stagepack_c(sid_a),msg)) || (event(LeakS(phase0,alice)) && event(LeakM(phase0,alice))); not attacker_p1(msg_c(alice,bob,sid_a)); attacker_p1(msg_c(alice,bob,sid_a)) ==> event(LeakS(px,bob)) && event(LeakM(px,bob)); attacker_p1(msg_c(alice,bob,sid_a)) ==> (event(LeakS(phase0,bob)) && event(LeakM(phase0,bob))) || (event(LeakS(px,bob)) && event(LeakM(px,bob)) && event(LeakS(pz,alice)) && event(LeakM(pz,alice))); attacker_p1(msg_c(alice,bob,sid_a)) ==> event(LeakS(phase0,bob)) && event(LeakM(phase0,bob)); event(RecvMsg(alice,bob,stagepack_d(sid_a),msg)) ==> event(SendMsg(bob,alice,stagepack_d(sid_b),msg)); event(RecvMsg(alice,bob,stagepack_d(sid_a),msg)) ==> event(SendMsg(bob,c,stagepack_d(sid_b),msg)) || (event(LeakS(phase0,bob)) && event(LeakM(phase0,bob))) || (event(LeakS(phase0,alice)) && event(LeakM(phase0,alice))); event(RecvMsg(alice,bob,stagepack_d(sid_a),msg)) ==> event(SendMsg(bob,c,stagepack_d(sid_b),msg)) || (event(LeakS(phase0,bob)) && event(LeakM(phase0,bob))); event(RecvMsg(alice,bob,stagepack_d(sid_a),msg)) ==> event(SendMsg(bob,alice,stagepack_d(sid_b),msg)) || (event(LeakS(phase0,bob)) && event(LeakM(phase0,bob))) || (event(LeakS(phase0,alice)) && event(LeakM(phase0,alice))); event(RecvMsg(alice,bob,stagepack_d(sid_a),msg)) ==> event(SendMsg(bob,alice,stagepack_d(sid_b),msg)) || (event(LeakS(phase0,bob)) && event(LeakM(phase0,bob))); not attacker_p1(msg_d(bob,alice,sid_b)); attacker_p1(msg_d(bob,alice,sid_b)) ==> event(LeakS(px,alice)) && event(LeakM(px,alice)); attacker_p1(msg_d(bob,alice,sid_b)) ==> (event(LeakS(phase0,alice)) && event(LeakM(phase0,alice))) || (event(LeakS(px,alice)) && event(LeakM(px,alice)) && event(LeakS(pz,bob)) && event(LeakM(pz,bob))); attacker_p1(msg_d(bob,alice,sid_b)) ==> event(LeakS(phase0,alice)) && event(LeakM(phase0,alice)); not event(RecvEnd(true)) in process 1.
Translating the process into Horn clauses...
Completing...
200 rules inserted. Base: 200 rules (87 with conclusion selected). Queue: 263 rules.
400 rules inserted. Base: 400 rules (104 with conclusion selected). Queue: 102 rules.
600 rules inserted. Base: 597 rules (182 with conclusion selected). Queue: 23 rules.
800 rules inserted. Base: 797 rules (182 with conclusion selected). Queue: 80 rules.
1000 rules inserted. Base: 996 rules (182 with conclusion selected). Queue: 134 rules.
1200 rules inserted. Base: 1180 rules (182 with conclusion selected). Queue: 143 rules.
1400 rules inserted. Base: 1290 rules (182 with conclusion selected). Queue: 73 rules.
Starting query event(RecvMsg(bob,alice,stagepack_a(sid_b),msg)) ==> event(SendMsg(alice,bob,stagepack_a(sid_a),msg))
RESULT event(RecvMsg(bob,alice,stagepack_a(sid_b),msg)) ==> event(SendMsg(alice,bob,stagepack_a(sid_a),msg)) is true.
Starting query event(RecvMsg(bob,alice,stagepack_a(sid_b),msg)) ==> event(SendMsg(alice,c,stagepack_a(sid_a),msg)) || (event(LeakS(phase0,alice)) && event(LeakM(phase0,alice))) || (event(LeakS(phase0,bob)) && event(LeakM(phase0,bob)))
RESULT event(RecvMsg(bob,alice,stagepack_a(sid_b),msg)) ==> event(SendMsg(alice,c,stagepack_a(sid_a),msg)) || (event(LeakS(phase0,alice)) && event(LeakM(phase0,alice))) || (event(LeakS(phase0,bob)) && event(LeakM(phase0,bob))) is true.
Starting query event(RecvMsg(bob,alice,stagepack_a(sid_b),msg)) ==> event(SendMsg(alice,c,stagepack_a(sid_a),msg)) || (event(LeakS(phase0,alice)) && event(LeakM(phase0,alice)))
RESULT event(RecvMsg(bob,alice,stagepack_a(sid_b),msg)) ==> event(SendMsg(alice,c,stagepack_a(sid_a),msg)) || (event(LeakS(phase0,alice)) && event(LeakM(phase0,alice))) is true.
Starting query event(RecvMsg(bob,alice,stagepack_a(sid_b),msg)) ==> event(SendMsg(alice,bob,stagepack_a(sid_a),msg)) || (event(LeakS(phase0,alice)) && event(LeakM(phase0,alice))) || (event(LeakS(phase0,bob)) && event(LeakM(phase0,bob)))
RESULT event(RecvMsg(bob,alice,stagepack_a(sid_b),msg)) ==> event(SendMsg(alice,bob,stagepack_a(sid_a),msg)) || (event(LeakS(phase0,alice)) && event(LeakM(phase0,alice))) || (event(LeakS(phase0,bob)) && event(LeakM(phase0,bob))) is true.
Starting query event(RecvMsg(bob,alice,stagepack_a(sid_b),msg)) ==> event(SendMsg(alice,bob,stagepack_a(sid_a),msg)) || (event(LeakS(phase0,alice)) && event(LeakM(phase0,alice)))
RESULT event(RecvMsg(bob,alice,stagepack_a(sid_b),msg)) ==> event(SendMsg(alice,bob,stagepack_a(sid_a),msg)) || (event(LeakS(phase0,alice)) && event(LeakM(phase0,alice))) is true.
Starting query not attacker_p1(msg_a(alice,bob,sid_a))
goal reachable: begin(LeakM(phase1,bob)) && begin(LeakS(phase1,bob)) && begin(SendMsg(alice,bob,stagepack_a(sid_5),msg_a(alice,bob,sid_5))) -> attacker_p1(msg_a(alice,bob,sid_5))
Abbreviations:
sid_5 = sid[!1 = @sid]

Derivation:
Abbreviations:
sid_5 = sid[!1 = @sid]

1. Using the function pub the attacker may obtain pub.
attacker(pub).

2. The entry statestore(alice,bob,sid_5,statepack_a(handshakestatepack(symmetricstatepack(cipherstatepack(empty,minnonce),hash(somename,empty),hash(hash(hash(hash(hash(hash(somename,empty),empty),validkey(dhexp_real(key_s(alice),g))),validkey(dhexp_real(key_m(alice),g))),validkey(dhexp_real(key_s(bob),g))),validkey(dhexp_real(key_s(bob),g)))),keypairpack(validkey(dhexp_real(key_s(alice),g)),key_s(alice)),keypairpack(validkey(dhexp_real(key_m(alice),g)),key_m(alice)),keypairpack(empty,empty),validkey(dhexp_real(key_s(bob),g)),validkey(dhexp_real(key_s(bob),g)),empty,empty,true))) may be inserted in a table at insert {74}.
table(statestore(alice,bob,sid_5,statepack_a(handshakestatepack(symmetricstatepack(cipherstatepack(empty,minnonce),hash(somename,empty),hash(hash(hash(hash(hash(hash(somename,empty),empty),validkey(dhexp_real(key_s(alice),g))),validkey(dhexp_real(key_m(alice),g))),validkey(dhexp_real(key_s(bob),g))),validkey(dhexp_real(key_s(bob),g)))),keypairpack(validkey(dhexp_real(key_s(alice),g)),key_s(alice)),keypairpack(validkey(dhexp_real(key_m(alice),g)),key_m(alice)),keypairpack(empty,empty),validkey(dhexp_real(key_s(bob),g)),validkey(dhexp_real(key_s(bob),g)),empty,empty,true)))).

3. The entry statestore(alice,bob,sid_5,statepack_a(handshakestatepack(symmetricstatepack(cipherstatepack(empty,minnonce),hash(somename,empty),hash(hash(hash(hash(hash(hash(somename,empty),empty),validkey(dhexp_real(key_s(alice),g))),validkey(dhexp_real(key_m(alice),g))),validkey(dhexp_real(key_s(bob),g))),validkey(dhexp_real(key_s(bob),g)))),keypairpack(validkey(dhexp_real(key_s(alice),g)),key_s(alice)),keypairpack(validkey(dhexp_real(key_m(alice),g)),key_m(alice)),keypairpack(empty,empty),validkey(dhexp_real(key_s(bob),g)),validkey(dhexp_real(key_s(bob),g)),empty,empty,true))) that may be in a table by 2 may be read at get {187}.
The event SendMsg(alice,bob,stagepack_a(sid_5),msg_a(alice,bob,sid_5)) may be executed at {184}.
So the message concat3(validkey(dhexp_real(key_e(alice,bob,sid_5),g)),empty,encrypt(hmac_hash2(hmac_hash1(hash(somename,empty),dhexp_real(key_e(alice,bob,sid_5),dhexp_real(key_s(bob),g))),dhexp_real(key_m(alice),dhexp_real(key_s(bob),g))),minnonce,hash(hash(hash(hash(hash(hash(hash(somename,empty),empty),validkey(dhexp_real(key_s(alice),g))),validkey(dhexp_real(key_m(alice),g))),validkey(dhexp_real(key_s(bob),g))),validkey(dhexp_real(key_s(bob),g))),validkey(dhexp_real(key_e(alice,bob,sid_5),g))),msg_a(alice,bob,sid_5))) may be sent on channel pub at output {186}.
mess(pub,concat3(validkey(dhexp_real(key_e(alice,bob,sid_5),g)),empty,encrypt(hmac_hash2(hmac_hash1(hash(somename,empty),dhexp_real(key_e(alice,bob,sid_5),dhexp_real(key_s(bob),g))),dhexp_real(key_m(alice),dhexp_real(key_s(bob),g))),minnonce,hash(hash(hash(hash(hash(hash(hash(somename,empty),empty),validkey(dhexp_real(key_s(alice),g))),validkey(dhexp_real(key_m(alice),g))),validkey(dhexp_real(key_s(bob),g))),validkey(dhexp_real(key_s(bob),g))),validkey(dhexp_real(key_e(alice,bob,sid_5),g))),msg_a(alice,bob,sid_5)))).

4. By 1, the attacker may have the channel pub.
By 3, the message concat3(validkey(dhexp_real(key_e(alice,bob,sid_5),g)),empty,encrypt(hmac_hash2(hmac_hash1(hash(somename,empty),dhexp_real(key_e(alice,bob,sid_5),dhexp_real(key_s(bob),g))),dhexp_real(key_m(alice),dhexp_real(key_s(bob),g))),minnonce,hash(hash(hash(hash(hash(hash(hash(somename,empty),empty),validkey(dhexp_real(key_s(alice),g))),validkey(dhexp_real(key_m(alice),g))),validkey(dhexp_real(key_s(bob),g))),validkey(dhexp_real(key_s(bob),g))),validkey(dhexp_real(key_e(alice,bob,sid_5),g))),msg_a(alice,bob,sid_5))) may be sent on this channel.
So the attacker may obtain the message concat3(validkey(dhexp_real(key_e(alice,bob,sid_5),g)),empty,encrypt(hmac_hash2(hmac_hash1(hash(somename,empty),dhexp_real(key_e(alice,bob,sid_5),dhexp_real(key_s(bob),g))),dhexp_real(key_m(alice),dhexp_real(key_s(bob),g))),minnonce,hash(hash(hash(hash(hash(hash(hash(somename,empty),empty),validkey(dhexp_real(key_s(alice),g))),validkey(dhexp_real(key_m(alice),g))),validkey(dhexp_real(key_s(bob),g))),validkey(dhexp_real(key_s(bob),g))),validkey(dhexp_real(key_e(alice,bob,sid_5),g))),msg_a(alice,bob,sid_5))) by listening on this channel.
attacker(concat3(validkey(dhexp_real(key_e(alice,bob,sid_5),g)),empty,encrypt(hmac_hash2(hmac_hash1(hash(somename,empty),dhexp_real(key_e(alice,bob,sid_5),dhexp_real(key_s(bob),g))),dhexp_real(key_m(alice),dhexp_real(key_s(bob),g))),minnonce,hash(hash(hash(hash(hash(hash(hash(somename,empty),empty),validkey(dhexp_real(key_s(alice),g))),validkey(dhexp_real(key_m(alice),g))),validkey(dhexp_real(key_s(bob),g))),validkey(dhexp_real(key_s(bob),g))),validkey(dhexp_real(key_e(alice,bob,sid_5),g))),msg_a(alice,bob,sid_5)))).

5. By 4, the attacker may know concat3(validkey(dhexp_real(key_e(alice,bob,sid_5),g)),empty,encrypt(hmac_hash2(hmac_hash1(hash(somename,empty),dhexp_real(key_e(alice,bob,sid_5),dhexp_real(key_s(bob),g))),dhexp_real(key_m(alice),dhexp_real(key_s(bob),g))),minnonce,hash(hash(hash(hash(hash(hash(hash(somename,empty),empty),validkey(dhexp_real(key_s(alice),g))),validkey(dhexp_real(key_m(alice),g))),validkey(dhexp_real(key_s(bob),g))),validkey(dhexp_real(key_s(bob),g))),validkey(dhexp_real(key_e(alice,bob,sid_5),g))),msg_a(alice,bob,sid_5))).
Using the function 3-proj-concat3 the attacker may obtain encrypt(hmac_hash2(hmac_hash1(hash(somename,empty),dhexp_real(key_e(alice,bob,sid_5),dhexp_real(key_s(bob),g))),dhexp_real(key_m(alice),dhexp_real(key_s(bob),g))),minnonce,hash(hash(hash(hash(hash(hash(hash(somename,empty),empty),validkey(dhexp_real(key_s(alice),g))),validkey(dhexp_real(key_m(alice),g))),validkey(dhexp_real(key_s(bob),g))),validkey(dhexp_real(key_s(bob),g))),validkey(dhexp_real(key_e(alice,bob,sid_5),g))),msg_a(alice,bob,sid_5)).
attacker(encrypt(hmac_hash2(hmac_hash1(hash(somename,empty),dhexp_real(key_e(alice,bob,sid_5),dhexp_real(key_s(bob),g))),dhexp_real(key_m(alice),dhexp_real(key_s(bob),g))),minnonce,hash(hash(hash(hash(hash(hash(hash(somename,empty),empty),validkey(dhexp_real(key_s(alice),g))),validkey(dhexp_real(key_m(alice),g))),validkey(dhexp_real(key_s(bob),g))),validkey(dhexp_real(key_s(bob),g))),validkey(dhexp_real(key_e(alice,bob,sid_5),g))),msg_a(alice,bob,sid_5))).

6. By 5, the attacker may know encrypt(hmac_hash2(hmac_hash1(hash(somename,empty),dhexp_real(key_e(alice,bob,sid_5),dhexp_real(key_s(bob),g))),dhexp_real(key_m(alice),dhexp_real(key_s(bob),g))),minnonce,hash(hash(hash(hash(hash(hash(hash(somename,empty),empty),validkey(dhexp_real(key_s(alice),g))),validkey(dhexp_real(key_m(alice),g))),validkey(dhexp_real(key_s(bob),g))),validkey(dhexp_real(key_s(bob),g))),validkey(dhexp_real(key_e(alice,bob,sid_5),g))),msg_a(alice,bob,sid_5)).
So the attacker may know encrypt(hmac_hash2(hmac_hash1(hash(somename,empty),dhexp_real(key_e(alice,bob,sid_5),dhexp_real(key_s(bob),g))),dhexp_real(key_m(alice),dhexp_real(key_s(bob),g))),minnonce,hash(hash(hash(hash(hash(hash(hash(somename,empty),empty),validkey(dhexp_real(key_s(alice),g))),validkey(dhexp_real(key_m(alice),g))),validkey(dhexp_real(key_s(bob),g))),validkey(dhexp_real(key_s(bob),g))),validkey(dhexp_real(key_e(alice,bob,sid_5),g))),msg_a(alice,bob,sid_5)) in phase 1.
attacker_p1(encrypt(hmac_hash2(hmac_hash1(hash(somename,empty),dhexp_real(key_e(alice,bob,sid_5),dhexp_real(key_s(bob),g))),dhexp_real(key_m(alice),dhexp_real(key_s(bob),g))),minnonce,hash(hash(hash(hash(hash(hash(hash(somename,empty),empty),validkey(dhexp_real(key_s(alice),g))),validkey(dhexp_real(key_m(alice),g))),validkey(dhexp_real(key_s(bob),g))),validkey(dhexp_real(key_s(bob),g))),validkey(dhexp_real(key_e(alice,bob,sid_5),g))),msg_a(alice,bob,sid_5))).

7. By 4, the attacker may know concat3(validkey(dhexp_real(key_e(alice,bob,sid_5),g)),empty,encrypt(hmac_hash2(hmac_hash1(hash(somename,empty),dhexp_real(key_e(alice,bob,sid_5),dhexp_real(key_s(bob),g))),dhexp_real(key_m(alice),dhexp_real(key_s(bob),g))),minnonce,hash(hash(hash(hash(hash(hash(hash(somename,empty),empty),validkey(dhexp_real(key_s(alice),g))),validkey(dhexp_real(key_m(alice),g))),validkey(dhexp_real(key_s(bob),g))),validkey(dhexp_real(key_s(bob),g))),validkey(dhexp_real(key_e(alice,bob,sid_5),g))),msg_a(alice,bob,sid_5))).
Using the function 1-proj-concat3 the attacker may obtain validkey(dhexp_real(key_e(alice,bob,sid_5),g)).
attacker(validkey(dhexp_real(key_e(alice,bob,sid_5),g))).

8. The message (validkey(dhexp_real(key_s(bob),g)),validkey(dhexp_real(key_m(bob),g))) may be sent on channel pub at output {963}.
mess(pub,(validkey(dhexp_real(key_s(bob),g)),validkey(dhexp_real(key_m(bob),g)))).

9. By 1, the attacker may have the channel pub.
By 8, the message (validkey(dhexp_real(key_s(bob),g)),validkey(dhexp_real(key_m(bob),g))) may be sent on this channel.
So the attacker may obtain the message (validkey(dhexp_real(key_s(bob),g)),validkey(dhexp_real(key_m(bob),g))) by listening on this channel.
attacker((validkey(dhexp_real(key_s(bob),g)),validkey(dhexp_real(key_m(bob),g)))).

10. By 9, the attacker may know (validkey(dhexp_real(key_s(bob),g)),validkey(dhexp_real(key_m(bob),g))).
Using the function 1-proj-2-tuple the attacker may obtain validkey(dhexp_real(key_s(bob),g)).
attacker(validkey(dhexp_real(key_s(bob),g))).

11. The message (validkey(dhexp_real(key_s(alice),g)),validkey(dhexp_real(key_m(alice),g))) may be sent on channel pub at output {15}.
mess(pub,(validkey(dhexp_real(key_s(alice),g)),validkey(dhexp_real(key_m(alice),g)))).

12. By 1, the attacker may have the channel pub.
By 11, the message (validkey(dhexp_real(key_s(alice),g)),validkey(dhexp_real(key_m(alice),g))) may be sent on this channel.
So the attacker may obtain the message (validkey(dhexp_real(key_s(alice),g)),validkey(dhexp_real(key_m(alice),g))) by listening on this channel.
attacker((validkey(dhexp_real(key_s(alice),g)),validkey(dhexp_real(key_m(alice),g)))).

13. By 12, the attacker may know (validkey(dhexp_real(key_s(alice),g)),validkey(dhexp_real(key_m(alice),g))).
Using the function 2-proj-2-tuple the attacker may obtain validkey(dhexp_real(key_m(alice),g)).
attacker(validkey(dhexp_real(key_m(alice),g))).

14. By 12, the attacker may know (validkey(dhexp_real(key_s(alice),g)),validkey(dhexp_real(key_m(alice),g))).
Using the function 1-proj-2-tuple the attacker may obtain validkey(dhexp_real(key_s(alice),g)).
attacker(validkey(dhexp_real(key_s(alice),g))).

15. Using the function empty the attacker may obtain empty.
attacker(empty).

16. Using the function somename the attacker may obtain somename.
attacker(somename).

17. By 16, the attacker may know somename.
By 15, the attacker may know empty.
Using the function hash the attacker may obtain hash(somename,empty).
attacker(hash(somename,empty)).

18. By 17, the attacker may know hash(somename,empty).
By 15, the attacker may know empty.
Using the function hash the attacker may obtain hash(hash(somename,empty),empty).
attacker(hash(hash(somename,empty),empty)).

19. By 18, the attacker may know hash(hash(somename,empty),empty).
By 14, the attacker may know validkey(dhexp_real(key_s(alice),g)).
Using the function hash the attacker may obtain hash(hash(hash(somename,empty),empty),validkey(dhexp_real(key_s(alice),g))).
attacker(hash(hash(hash(somename,empty),empty),validkey(dhexp_real(key_s(alice),g)))).

20. By 19, the attacker may know hash(hash(hash(somename,empty),empty),validkey(dhexp_real(key_s(alice),g))).
By 13, the attacker may know validkey(dhexp_real(key_m(alice),g)).
Using the function hash the attacker may obtain hash(hash(hash(hash(somename,empty),empty),validkey(dhexp_real(key_s(alice),g))),validkey(dhexp_real(key_m(alice),g))).
attacker(hash(hash(hash(hash(somename,empty),empty),validkey(dhexp_real(key_s(alice),g))),validkey(dhexp_real(key_m(alice),g)))).

21. By 20, the attacker may know hash(hash(hash(hash(somename,empty),empty),validkey(dhexp_real(key_s(alice),g))),validkey(dhexp_real(key_m(alice),g))).
By 10, the attacker may know validkey(dhexp_real(key_s(bob),g)).
Using the function hash the attacker may obtain hash(hash(hash(hash(hash(somename,empty),empty),validkey(dhexp_real(key_s(alice),g))),validkey(dhexp_real(key_m(alice),g))),validkey(dhexp_real(key_s(bob),g))).
attacker(hash(hash(hash(hash(hash(somename,empty),empty),validkey(dhexp_real(key_s(alice),g))),validkey(dhexp_real(key_m(alice),g))),validkey(dhexp_real(key_s(bob),g)))).

22. By 21, the attacker may know hash(hash(hash(hash(hash(somename,empty),empty),validkey(dhexp_real(key_s(alice),g))),validkey(dhexp_real(key_m(alice),g))),validkey(dhexp_real(key_s(bob),g))).
By 10, the attacker may know validkey(dhexp_real(key_s(bob),g)).
Using the function hash the attacker may obtain hash(hash(hash(hash(hash(hash(somename,empty),empty),validkey(dhexp_real(key_s(alice),g))),validkey(dhexp_real(key_m(alice),g))),validkey(dhexp_real(key_s(bob),g))),validkey(dhexp_real(key_s(bob),g))).
attacker(hash(hash(hash(hash(hash(hash(somename,empty),empty),validkey(dhexp_real(key_s(alice),g))),validkey(dhexp_real(key_m(alice),g))),validkey(dhexp_real(key_s(bob),g))),validkey(dhexp_real(key_s(bob),g)))).

23. By 22, the attacker may know hash(hash(hash(hash(hash(hash(somename,empty),empty),validkey(dhexp_real(key_s(alice),g))),validkey(dhexp_real(key_m(alice),g))),validkey(dhexp_real(key_s(bob),g))),validkey(dhexp_real(key_s(bob),g))).
By 7, the attacker may know validkey(dhexp_real(key_e(alice,bob,sid_5),g)).
Using the function hash the attacker may obtain hash(hash(hash(hash(hash(hash(hash(somename,empty),empty),validkey(dhexp_real(key_s(alice),g))),validkey(dhexp_real(key_m(alice),g))),validkey(dhexp_real(key_s(bob),g))),validkey(dhexp_real(key_s(bob),g))),validkey(dhexp_real(key_e(alice,bob,sid_5),g))).
attacker(hash(hash(hash(hash(hash(hash(hash(somename,empty),empty),validkey(dhexp_real(key_s(alice),g))),validkey(dhexp_real(key_m(alice),g))),validkey(dhexp_real(key_s(bob),g))),validkey(dhexp_real(key_s(bob),g))),validkey(dhexp_real(key_e(alice,bob,sid_5),g)))).

24. By 23, the attacker may know hash(hash(hash(hash(hash(hash(hash(somename,empty),empty),validkey(dhexp_real(key_s(alice),g))),validkey(dhexp_real(key_m(alice),g))),validkey(dhexp_real(key_s(bob),g))),validkey(dhexp_real(key_s(bob),g))),validkey(dhexp_real(key_e(alice,bob,sid_5),g))).
So the attacker may know hash(hash(hash(hash(hash(hash(hash(somename,empty),empty),validkey(dhexp_real(key_s(alice),g))),validkey(dhexp_real(key_m(alice),g))),validkey(dhexp_real(key_s(bob),g))),validkey(dhexp_real(key_s(bob),g))),validkey(dhexp_real(key_e(alice,bob,sid_5),g))) in phase 1.
attacker_p1(hash(hash(hash(hash(hash(hash(hash(somename,empty),empty),validkey(dhexp_real(key_s(alice),g))),validkey(dhexp_real(key_m(alice),g))),validkey(dhexp_real(key_s(bob),g))),validkey(dhexp_real(key_s(bob),g))),validkey(dhexp_real(key_e(alice,bob,sid_5),g)))).

25. Using the function minnonce the attacker may obtain minnonce in phase 1.
attacker_p1(minnonce).

26. By 13, the attacker may know validkey(dhexp_real(key_m(alice),g)).
So the attacker may know validkey(dhexp_real(key_m(alice),g)) in phase 1.
attacker_p1(validkey(dhexp_real(key_m(alice),g))).

27. Using the function pub the attacker may obtain pub in phase 1.
attacker_p1(pub).

28. The event LeakS(phase1,bob) may be executed at {1422}.
The event LeakM(phase1,bob) may be executed at {1423}.
So the message (key_s(bob),key_m(bob)) may be sent on channel pub in phase 1 at output {1424}.
mess_p1(pub,(key_s(bob),key_m(bob))).

29. By 27, the attacker may have the channel pub in phase 1.
By 28, the message (key_s(bob),key_m(bob)) in phase 1 may be sent on this channel.
So the attacker may obtain the message (key_s(bob),key_m(bob)) in phase 1 by listening on this channel.
attacker_p1((key_s(bob),key_m(bob))).

30. By 29, the attacker may know (key_s(bob),key_m(bob)) in phase 1.
Using the function 1-proj-2-tuple the attacker may obtain key_s(bob) in phase 1.
attacker_p1(key_s(bob)).

31. By 30, the attacker may know key_s(bob) in phase 1.
By 26, the attacker may know validkey(dhexp_real(key_m(alice),g)) in phase 1.
Using the function dhexp the attacker may obtain dhexp_real(key_m(alice),dhexp_real(key_s(bob),g)) in phase 1.
attacker_p1(dhexp_real(key_m(alice),dhexp_real(key_s(bob),g))).

32. By 7, the attacker may know validkey(dhexp_real(key_e(alice,bob,sid_5),g)).
So the attacker may know validkey(dhexp_real(key_e(alice,bob,sid_5),g)) in phase 1.
attacker_p1(validkey(dhexp_real(key_e(alice,bob,sid_5),g))).

33. By 30, the attacker may know key_s(bob) in phase 1.
By 32, the attacker may know validkey(dhexp_real(key_e(alice,bob,sid_5),g)) in phase 1.
Using the function dhexp the attacker may obtain dhexp_real(key_e(alice,bob,sid_5),dhexp_real(key_s(bob),g)) in phase 1.
attacker_p1(dhexp_real(key_e(alice,bob,sid_5),dhexp_real(key_s(bob),g))).

34. Using the function empty the attacker may obtain empty in phase 1.
attacker_p1(empty).

35. Using the function somename the attacker may obtain somename in phase 1.
attacker_p1(somename).

36. By 35, the attacker may know somename in phase 1.
By 34, the attacker may know empty in phase 1.
Using the function hash the attacker may obtain hash(somename,empty) in phase 1.
attacker_p1(hash(somename,empty)).

37. By 36, the attacker may know hash(somename,empty) in phase 1.
By 33, the attacker may know dhexp_real(key_e(alice,bob,sid_5),dhexp_real(key_s(bob),g)) in phase 1.
Using the function hmac_hash1 the attacker may obtain hmac_hash1(hash(somename,empty),dhexp_real(key_e(alice,bob,sid_5),dhexp_real(key_s(bob),g))) in phase 1.
attacker_p1(hmac_hash1(hash(somename,empty),dhexp_real(key_e(alice,bob,sid_5),dhexp_real(key_s(bob),g)))).

38. By 37, the attacker may know hmac_hash1(hash(somename,empty),dhexp_real(key_e(alice,bob,sid_5),dhexp_real(key_s(bob),g))) in phase 1.
By 31, the attacker may know dhexp_real(key_m(alice),dhexp_real(key_s(bob),g)) in phase 1.
Using the function hmac_hash2 the attacker may obtain hmac_hash2(hmac_hash1(hash(somename,empty),dhexp_real(key_e(alice,bob,sid_5),dhexp_real(key_s(bob),g))),dhexp_real(key_m(alice),dhexp_real(key_s(bob),g))) in phase 1.
attacker_p1(hmac_hash2(hmac_hash1(hash(somename,empty),dhexp_real(key_e(alice,bob,sid_5),dhexp_real(key_s(bob),g))),dhexp_real(key_m(alice),dhexp_real(key_s(bob),g)))).

39. By 38, the attacker may know hmac_hash2(hmac_hash1(hash(somename,empty),dhexp_real(key_e(alice,bob,sid_5),dhexp_real(key_s(bob),g))),dhexp_real(key_m(alice),dhexp_real(key_s(bob),g))) in phase 1.
By 25, the attacker may know minnonce in phase 1.
By 24, the attacker may know hash(hash(hash(hash(hash(hash(hash(somename,empty),empty),validkey(dhexp_real(key_s(alice),g))),validkey(dhexp_real(key_m(alice),g))),validkey(dhexp_real(key_s(bob),g))),validkey(dhexp_real(key_s(bob),g))),validkey(dhexp_real(key_e(alice,bob,sid_5),g))) in phase 1.
By 6, the attacker may know encrypt(hmac_hash2(hmac_hash1(hash(somename,empty),dhexp_real(key_e(alice,bob,sid_5),dhexp_real(key_s(bob),g))),dhexp_real(key_m(alice),dhexp_real(key_s(bob),g))),minnonce,hash(hash(hash(hash(hash(hash(hash(somename,empty),empty),validkey(dhexp_real(key_s(alice),g))),validkey(dhexp_real(key_m(alice),g))),validkey(dhexp_real(key_s(bob),g))),validkey(dhexp_real(key_s(bob),g))),validkey(dhexp_real(key_e(alice,bob,sid_5),g))),msg_a(alice,bob,sid_5)) in phase 1.
Using the function decrypt the attacker may obtain aeadpack(true,hash(hash(hash(hash(hash(hash(hash(somename,empty),empty),validkey(dhexp_real(key_s(alice),g))),validkey(dhexp_real(key_m(alice),g))),validkey(dhexp_real(key_s(bob),g))),validkey(dhexp_real(key_s(bob),g))),validkey(dhexp_real(key_e(alice,bob,sid_5),g))),msg_a(alice,bob,sid_5)) in phase 1.
attacker_p1(aeadpack(true,hash(hash(hash(hash(hash(hash(hash(somename,empty),empty),validkey(dhexp_real(key_s(alice),g))),validkey(dhexp_real(key_m(alice),g))),validkey(dhexp_real(key_s(bob),g))),validkey(dhexp_real(key_s(bob),g))),validkey(dhexp_real(key_e(alice,bob,sid_5),g))),msg_a(alice,bob,sid_5))).

40. By 39, the attacker may know aeadpack(true,hash(hash(hash(hash(hash(hash(hash(somename,empty),empty),validkey(dhexp_real(key_s(alice),g))),validkey(dhexp_real(key_m(alice),g))),validkey(dhexp_real(key_s(bob),g))),validkey(dhexp_real(key_s(bob),g))),validkey(dhexp_real(key_e(alice,bob,sid_5),g))),msg_a(alice,bob,sid_5)) in phase 1.
Using the function 3-proj-aeadpack the attacker may obtain msg_a(alice,bob,sid_5) in phase 1.
attacker_p1(msg_a(alice,bob,sid_5)).

41. By 40, attacker_p1(msg_a(alice,bob,sid_5)).
The goal is reached, represented in the following fact:
attacker_p1(msg_a(alice,bob,sid_5)).


RESULT not attacker_p1(msg_a(alice,bob,sid_a)) cannot be proved.
Starting query attacker_p1(msg_a(alice,bob,sid_a)) ==> event(LeakS(px,bob)) && event(LeakM(px,bob))
goal reachable: begin(LeakM(phase1,bob)) && begin(LeakS(phase1,bob)) && begin(SendMsg(alice,bob,stagepack_a(sid_5),msg_a(alice,bob,sid_5))) -> attacker_p1(msg_a(alice,bob,sid_5))
Abbreviations:
sid_5 = sid[!1 = @sid]
goal reachable: begin(LeakM(phase0,bob)) && begin(LeakS(phase0,bob)) && begin(SendMsg(alice,bob,stagepack_a(sid_5),msg_a(alice,bob,sid_5))) -> attacker_p1(msg_a(alice,bob,sid_5))
Abbreviations:
sid_5 = sid[!1 = @sid]
RESULT attacker_p1(msg_a(alice,bob,sid_a)) ==> event(LeakS(px,bob)) && event(LeakM(px,bob)) is true.
Starting query attacker_p1(msg_a(alice,bob,sid_a)) ==> (event(LeakS(phase0,bob)) && event(LeakM(phase0,bob))) || (event(LeakS(px,bob)) && event(LeakM(px,bob)) && event(LeakS(pz,alice)) && event(LeakM(pz,alice)))
goal reachable: begin(LeakM(phase1,bob)) && begin(LeakS(phase1,bob)) && begin(SendMsg(alice,bob,stagepack_a(sid_5),msg_a(alice,bob,sid_5))) -> attacker_p1(msg_a(alice,bob,sid_5))
Abbreviations:
sid_5 = sid[!1 = @sid]

Derivation:
Abbreviations:
sid_5 = sid[!1 = @sid]

1. Using the function pub the attacker may obtain pub.
attacker(pub).

2. The entry statestore(alice,bob,sid_5,statepack_a(handshakestatepack(symmetricstatepack(cipherstatepack(empty,minnonce),hash(somename,empty),hash(hash(hash(hash(hash(hash(somename,empty),empty),validkey(dhexp_real(key_s(alice),g))),validkey(dhexp_real(key_m(alice),g))),validkey(dhexp_real(key_s(bob),g))),validkey(dhexp_real(key_s(bob),g)))),keypairpack(validkey(dhexp_real(key_s(alice),g)),key_s(alice)),keypairpack(validkey(dhexp_real(key_m(alice),g)),key_m(alice)),keypairpack(empty,empty),validkey(dhexp_real(key_s(bob),g)),validkey(dhexp_real(key_s(bob),g)),empty,empty,true))) may be inserted in a table at insert {74}.
table(statestore(alice,bob,sid_5,statepack_a(handshakestatepack(symmetricstatepack(cipherstatepack(empty,minnonce),hash(somename,empty),hash(hash(hash(hash(hash(hash(somename,empty),empty),validkey(dhexp_real(key_s(alice),g))),validkey(dhexp_real(key_m(alice),g))),validkey(dhexp_real(key_s(bob),g))),validkey(dhexp_real(key_s(bob),g)))),keypairpack(validkey(dhexp_real(key_s(alice),g)),key_s(alice)),keypairpack(validkey(dhexp_real(key_m(alice),g)),key_m(alice)),keypairpack(empty,empty),validkey(dhexp_real(key_s(bob),g)),validkey(dhexp_real(key_s(bob),g)),empty,empty,true)))).

3. The entry statestore(alice,bob,sid_5,statepack_a(handshakestatepack(symmetricstatepack(cipherstatepack(empty,minnonce),hash(somename,empty),hash(hash(hash(hash(hash(hash(somename,empty),empty),validkey(dhexp_real(key_s(alice),g))),validkey(dhexp_real(key_m(alice),g))),validkey(dhexp_real(key_s(bob),g))),validkey(dhexp_real(key_s(bob),g)))),keypairpack(validkey(dhexp_real(key_s(alice),g)),key_s(alice)),keypairpack(validkey(dhexp_real(key_m(alice),g)),key_m(alice)),keypairpack(empty,empty),validkey(dhexp_real(key_s(bob),g)),validkey(dhexp_real(key_s(bob),g)),empty,empty,true))) that may be in a table by 2 may be read at get {187}.
The event SendMsg(alice,bob,stagepack_a(sid_5),msg_a(alice,bob,sid_5)) may be executed at {184}.
So the message concat3(validkey(dhexp_real(key_e(alice,bob,sid_5),g)),empty,encrypt(hmac_hash2(hmac_hash1(hash(somename,empty),dhexp_real(key_e(alice,bob,sid_5),dhexp_real(key_s(bob),g))),dhexp_real(key_m(alice),dhexp_real(key_s(bob),g))),minnonce,hash(hash(hash(hash(hash(hash(hash(somename,empty),empty),validkey(dhexp_real(key_s(alice),g))),validkey(dhexp_real(key_m(alice),g))),validkey(dhexp_real(key_s(bob),g))),validkey(dhexp_real(key_s(bob),g))),validkey(dhexp_real(key_e(alice,bob,sid_5),g))),msg_a(alice,bob,sid_5))) may be sent on channel pub at output {186}.
mess(pub,concat3(validkey(dhexp_real(key_e(alice,bob,sid_5),g)),empty,encrypt(hmac_hash2(hmac_hash1(hash(somename,empty),dhexp_real(key_e(alice,bob,sid_5),dhexp_real(key_s(bob),g))),dhexp_real(key_m(alice),dhexp_real(key_s(bob),g))),minnonce,hash(hash(hash(hash(hash(hash(hash(somename,empty),empty),validkey(dhexp_real(key_s(alice),g))),validkey(dhexp_real(key_m(alice),g))),validkey(dhexp_real(key_s(bob),g))),validkey(dhexp_real(key_s(bob),g))),validkey(dhexp_real(key_e(alice,bob,sid_5),g))),msg_a(alice,bob,sid_5)))).

4. By 1, the attacker may have the channel pub.
By 3, the message concat3(validkey(dhexp_real(key_e(alice,bob,sid_5),g)),empty,encrypt(hmac_hash2(hmac_hash1(hash(somename,empty),dhexp_real(key_e(alice,bob,sid_5),dhexp_real(key_s(bob),g))),dhexp_real(key_m(alice),dhexp_real(key_s(bob),g))),minnonce,hash(hash(hash(hash(hash(hash(hash(somename,empty),empty),validkey(dhexp_real(key_s(alice),g))),validkey(dhexp_real(key_m(alice),g))),validkey(dhexp_real(key_s(bob),g))),validkey(dhexp_real(key_s(bob),g))),validkey(dhexp_real(key_e(alice,bob,sid_5),g))),msg_a(alice,bob,sid_5))) may be sent on this channel.
So the attacker may obtain the message concat3(validkey(dhexp_real(key_e(alice,bob,sid_5),g)),empty,encrypt(hmac_hash2(hmac_hash1(hash(somename,empty),dhexp_real(key_e(alice,bob,sid_5),dhexp_real(key_s(bob),g))),dhexp_real(key_m(alice),dhexp_real(key_s(bob),g))),minnonce,hash(hash(hash(hash(hash(hash(hash(somename,empty),empty),validkey(dhexp_real(key_s(alice),g))),validkey(dhexp_real(key_m(alice),g))),validkey(dhexp_real(key_s(bob),g))),validkey(dhexp_real(key_s(bob),g))),validkey(dhexp_real(key_e(alice,bob,sid_5),g))),msg_a(alice,bob,sid_5))) by listening on this channel.
attacker(concat3(validkey(dhexp_real(key_e(alice,bob,sid_5),g)),empty,encrypt(hmac_hash2(hmac_hash1(hash(somename,empty),dhexp_real(key_e(alice,bob,sid_5),dhexp_real(key_s(bob),g))),dhexp_real(key_m(alice),dhexp_real(key_s(bob),g))),minnonce,hash(hash(hash(hash(hash(hash(hash(somename,empty),empty),validkey(dhexp_real(key_s(alice),g))),validkey(dhexp_real(key_m(alice),g))),validkey(dhexp_real(key_s(bob),g))),validkey(dhexp_real(key_s(bob),g))),validkey(dhexp_real(key_e(alice,bob,sid_5),g))),msg_a(alice,bob,sid_5)))).

5. By 4, the attacker may know concat3(validkey(dhexp_real(key_e(alice,bob,sid_5),g)),empty,encrypt(hmac_hash2(hmac_hash1(hash(somename,empty),dhexp_real(key_e(alice,bob,sid_5),dhexp_real(key_s(bob),g))),dhexp_real(key_m(alice),dhexp_real(key_s(bob),g))),minnonce,hash(hash(hash(hash(hash(hash(hash(somename,empty),empty),validkey(dhexp_real(key_s(alice),g))),validkey(dhexp_real(key_m(alice),g))),validkey(dhexp_real(key_s(bob),g))),validkey(dhexp_real(key_s(bob),g))),validkey(dhexp_real(key_e(alice,bob,sid_5),g))),msg_a(alice,bob,sid_5))).
Using the function 3-proj-concat3 the attacker may obtain encrypt(hmac_hash2(hmac_hash1(hash(somename,empty),dhexp_real(key_e(alice,bob,sid_5),dhexp_real(key_s(bob),g))),dhexp_real(key_m(alice),dhexp_real(key_s(bob),g))),minnonce,hash(hash(hash(hash(hash(hash(hash(somename,empty),empty),validkey(dhexp_real(key_s(alice),g))),validkey(dhexp_real(key_m(alice),g))),validkey(dhexp_real(key_s(bob),g))),validkey(dhexp_real(key_s(bob),g))),validkey(dhexp_real(key_e(alice,bob,sid_5),g))),msg_a(alice,bob,sid_5)).
attacker(encrypt(hmac_hash2(hmac_hash1(hash(somename,empty),dhexp_real(key_e(alice,bob,sid_5),dhexp_real(key_s(bob),g))),dhexp_real(key_m(alice),dhexp_real(key_s(bob),g))),minnonce,hash(hash(hash(hash(hash(hash(hash(somename,empty),empty),validkey(dhexp_real(key_s(alice),g))),validkey(dhexp_real(key_m(alice),g))),validkey(dhexp_real(key_s(bob),g))),validkey(dhexp_real(key_s(bob),g))),validkey(dhexp_real(key_e(alice,bob,sid_5),g))),msg_a(alice,bob,sid_5))).

6. By 5, the attacker may know encrypt(hmac_hash2(hmac_hash1(hash(somename,empty),dhexp_real(key_e(alice,bob,sid_5),dhexp_real(key_s(bob),g))),dhexp_real(key_m(alice),dhexp_real(key_s(bob),g))),minnonce,hash(hash(hash(hash(hash(hash(hash(somename,empty),empty),validkey(dhexp_real(key_s(alice),g))),validkey(dhexp_real(key_m(alice),g))),validkey(dhexp_real(key_s(bob),g))),validkey(dhexp_real(key_s(bob),g))),validkey(dhexp_real(key_e(alice,bob,sid_5),g))),msg_a(alice,bob,sid_5)).
So the attacker may know encrypt(hmac_hash2(hmac_hash1(hash(somename,empty),dhexp_real(key_e(alice,bob,sid_5),dhexp_real(key_s(bob),g))),dhexp_real(key_m(alice),dhexp_real(key_s(bob),g))),minnonce,hash(hash(hash(hash(hash(hash(hash(somename,empty),empty),validkey(dhexp_real(key_s(alice),g))),validkey(dhexp_real(key_m(alice),g))),validkey(dhexp_real(key_s(bob),g))),validkey(dhexp_real(key_s(bob),g))),validkey(dhexp_real(key_e(alice,bob,sid_5),g))),msg_a(alice,bob,sid_5)) in phase 1.
attacker_p1(encrypt(hmac_hash2(hmac_hash1(hash(somename,empty),dhexp_real(key_e(alice,bob,sid_5),dhexp_real(key_s(bob),g))),dhexp_real(key_m(alice),dhexp_real(key_s(bob),g))),minnonce,hash(hash(hash(hash(hash(hash(hash(somename,empty),empty),validkey(dhexp_real(key_s(alice),g))),validkey(dhexp_real(key_m(alice),g))),validkey(dhexp_real(key_s(bob),g))),validkey(dhexp_real(key_s(bob),g))),validkey(dhexp_real(key_e(alice,bob,sid_5),g))),msg_a(alice,bob,sid_5))).

7. By 4, the attacker may know concat3(validkey(dhexp_real(key_e(alice,bob,sid_5),g)),empty,encrypt(hmac_hash2(hmac_hash1(hash(somename,empty),dhexp_real(key_e(alice,bob,sid_5),dhexp_real(key_s(bob),g))),dhexp_real(key_m(alice),dhexp_real(key_s(bob),g))),minnonce,hash(hash(hash(hash(hash(hash(hash(somename,empty),empty),validkey(dhexp_real(key_s(alice),g))),validkey(dhexp_real(key_m(alice),g))),validkey(dhexp_real(key_s(bob),g))),validkey(dhexp_real(key_s(bob),g))),validkey(dhexp_real(key_e(alice,bob,sid_5),g))),msg_a(alice,bob,sid_5))).
Using the function 1-proj-concat3 the attacker may obtain validkey(dhexp_real(key_e(alice,bob,sid_5),g)).
attacker(validkey(dhexp_real(key_e(alice,bob,sid_5),g))).

8. The message (validkey(dhexp_real(key_s(bob),g)),validkey(dhexp_real(key_m(bob),g))) may be sent on channel pub at output {963}.
mess(pub,(validkey(dhexp_real(key_s(bob),g)),validkey(dhexp_real(key_m(bob),g)))).

9. By 1, the attacker may have the channel pub.
By 8, the message (validkey(dhexp_real(key_s(bob),g)),validkey(dhexp_real(key_m(bob),g))) may be sent on this channel.
So the attacker may obtain the message (validkey(dhexp_real(key_s(bob),g)),validkey(dhexp_real(key_m(bob),g))) by listening on this channel.
attacker((validkey(dhexp_real(key_s(bob),g)),validkey(dhexp_real(key_m(bob),g)))).

10. By 9, the attacker may know (validkey(dhexp_real(key_s(bob),g)),validkey(dhexp_real(key_m(bob),g))).
Using the function 1-proj-2-tuple the attacker may obtain validkey(dhexp_real(key_s(bob),g)).
attacker(validkey(dhexp_real(key_s(bob),g))).

11. The message (validkey(dhexp_real(key_s(alice),g)),validkey(dhexp_real(key_m(alice),g))) may be sent on channel pub at output {15}.
mess(pub,(validkey(dhexp_real(key_s(alice),g)),validkey(dhexp_real(key_m(alice),g)))).

12. By 1, the attacker may have the channel pub.
By 11, the message (validkey(dhexp_real(key_s(alice),g)),validkey(dhexp_real(key_m(alice),g))) may be sent on this channel.
So the attacker may obtain the message (validkey(dhexp_real(key_s(alice),g)),validkey(dhexp_real(key_m(alice),g))) by listening on this channel.
attacker((validkey(dhexp_real(key_s(alice),g)),validkey(dhexp_real(key_m(alice),g)))).

13. By 12, the attacker may know (validkey(dhexp_real(key_s(alice),g)),validkey(dhexp_real(key_m(alice),g))).
Using the function 2-proj-2-tuple the attacker may obtain validkey(dhexp_real(key_m(alice),g)).
attacker(validkey(dhexp_real(key_m(alice),g))).

14. By 12, the attacker may know (validkey(dhexp_real(key_s(alice),g)),validkey(dhexp_real(key_m(alice),g))).
Using the function 1-proj-2-tuple the attacker may obtain validkey(dhexp_real(key_s(alice),g)).
attacker(validkey(dhexp_real(key_s(alice),g))).

15. Using the function empty the attacker may obtain empty.
attacker(empty).

16. Using the function somename the attacker may obtain somename.
attacker(somename).

17. By 16, the attacker may know somename.
By 15, the attacker may know empty.
Using the function hash the attacker may obtain hash(somename,empty).
attacker(hash(somename,empty)).

18. By 17, the attacker may know hash(somename,empty).
By 15, the attacker may know empty.
Using the function hash the attacker may obtain hash(hash(somename,empty),empty).
attacker(hash(hash(somename,empty),empty)).

19. By 18, the attacker may know hash(hash(somename,empty),empty).
By 14, the attacker may know validkey(dhexp_real(key_s(alice),g)).
Using the function hash the attacker may obtain hash(hash(hash(somename,empty),empty),validkey(dhexp_real(key_s(alice),g))).
attacker(hash(hash(hash(somename,empty),empty),validkey(dhexp_real(key_s(alice),g)))).

20. By 19, the attacker may know hash(hash(hash(somename,empty),empty),validkey(dhexp_real(key_s(alice),g))).
By 13, the attacker may know validkey(dhexp_real(key_m(alice),g)).
Using the function hash the attacker may obtain hash(hash(hash(hash(somename,empty),empty),validkey(dhexp_real(key_s(alice),g))),validkey(dhexp_real(key_m(alice),g))).
attacker(hash(hash(hash(hash(somename,empty),empty),validkey(dhexp_real(key_s(alice),g))),validkey(dhexp_real(key_m(alice),g)))).

21. By 20, the attacker may know hash(hash(hash(hash(somename,empty),empty),validkey(dhexp_real(key_s(alice),g))),validkey(dhexp_real(key_m(alice),g))).
By 10, the attacker may know validkey(dhexp_real(key_s(bob),g)).
Using the function hash the attacker may obtain hash(hash(hash(hash(hash(somename,empty),empty),validkey(dhexp_real(key_s(alice),g))),validkey(dhexp_real(key_m(alice),g))),validkey(dhexp_real(key_s(bob),g))).
attacker(hash(hash(hash(hash(hash(somename,empty),empty),validkey(dhexp_real(key_s(alice),g))),validkey(dhexp_real(key_m(alice),g))),validkey(dhexp_real(key_s(bob),g)))).

22. By 21, the attacker may know hash(hash(hash(hash(hash(somename,empty),empty),validkey(dhexp_real(key_s(alice),g))),validkey(dhexp_real(key_m(alice),g))),validkey(dhexp_real(key_s(bob),g))).
By 10, the attacker may know validkey(dhexp_real(key_s(bob),g)).
Using the function hash the attacker may obtain hash(hash(hash(hash(hash(hash(somename,empty),empty),validkey(dhexp_real(key_s(alice),g))),validkey(dhexp_real(key_m(alice),g))),validkey(dhexp_real(key_s(bob),g))),validkey(dhexp_real(key_s(bob),g))).
attacker(hash(hash(hash(hash(hash(hash(somename,empty),empty),validkey(dhexp_real(key_s(alice),g))),validkey(dhexp_real(key_m(alice),g))),validkey(dhexp_real(key_s(bob),g))),validkey(dhexp_real(key_s(bob),g)))).

23. By 22, the attacker may know hash(hash(hash(hash(hash(hash(somename,empty),empty),validkey(dhexp_real(key_s(alice),g))),validkey(dhexp_real(key_m(alice),g))),validkey(dhexp_real(key_s(bob),g))),validkey(dhexp_real(key_s(bob),g))).
By 7, the attacker may know validkey(dhexp_real(key_e(alice,bob,sid_5),g)).
Using the function hash the attacker may obtain hash(hash(hash(hash(hash(hash(hash(somename,empty),empty),validkey(dhexp_real(key_s(alice),g))),validkey(dhexp_real(key_m(alice),g))),validkey(dhexp_real(key_s(bob),g))),validkey(dhexp_real(key_s(bob),g))),validkey(dhexp_real(key_e(alice,bob,sid_5),g))).
attacker(hash(hash(hash(hash(hash(hash(hash(somename,empty),empty),validkey(dhexp_real(key_s(alice),g))),validkey(dhexp_real(key_m(alice),g))),validkey(dhexp_real(key_s(bob),g))),validkey(dhexp_real(key_s(bob),g))),validkey(dhexp_real(key_e(alice,bob,sid_5),g)))).

24. By 23, the attacker may know hash(hash(hash(hash(hash(hash(hash(somename,empty),empty),validkey(dhexp_real(key_s(alice),g))),validkey(dhexp_real(key_m(alice),g))),validkey(dhexp_real(key_s(bob),g))),validkey(dhexp_real(key_s(bob),g))),validkey(dhexp_real(key_e(alice,bob,sid_5),g))).
So the attacker may know hash(hash(hash(hash(hash(hash(hash(somename,empty),empty),validkey(dhexp_real(key_s(alice),g))),validkey(dhexp_real(key_m(alice),g))),validkey(dhexp_real(key_s(bob),g))),validkey(dhexp_real(key_s(bob),g))),validkey(dhexp_real(key_e(alice,bob,sid_5),g))) in phase 1.
attacker_p1(hash(hash(hash(hash(hash(hash(hash(somename,empty),empty),validkey(dhexp_real(key_s(alice),g))),validkey(dhexp_real(key_m(alice),g))),validkey(dhexp_real(key_s(bob),g))),validkey(dhexp_real(key_s(bob),g))),validkey(dhexp_real(key_e(alice,bob,sid_5),g)))).

25. Using the function minnonce the attacker may obtain minnonce in phase 1.
attacker_p1(minnonce).

26. By 13, the attacker may know validkey(dhexp_real(key_m(alice),g)).
So the attacker may know validkey(dhexp_real(key_m(alice),g)) in phase 1.
attacker_p1(validkey(dhexp_real(key_m(alice),g))).

27. Using the function pub the attacker may obtain pub in phase 1.
attacker_p1(pub).

28. The event LeakS(phase1,bob) may be executed at {1422}.
The event LeakM(phase1,bob) may be executed at {1423}.
So the message (key_s(bob),key_m(bob)) may be sent on channel pub in phase 1 at output {1424}.
mess_p1(pub,(key_s(bob),key_m(bob))).

29. By 27, the attacker may have the channel pub in phase 1.
By 28, the message (key_s(bob),key_m(bob)) in phase 1 may be sent on this channel.
So the attacker may obtain the message (key_s(bob),key_m(bob)) in phase 1 by listening on this channel.
attacker_p1((key_s(bob),key_m(bob))).

30. By 29, the attacker may know (key_s(bob),key_m(bob)) in phase 1.
Using the function 1-proj-2-tuple the attacker may obtain key_s(bob) in phase 1.
attacker_p1(key_s(bob)).

31. By 30, the attacker may know key_s(bob) in phase 1.
By 26, the attacker may know validkey(dhexp_real(key_m(alice),g)) in phase 1.
Using the function dhexp the attacker may obtain dhexp_real(key_m(alice),dhexp_real(key_s(bob),g)) in phase 1.
attacker_p1(dhexp_real(key_m(alice),dhexp_real(key_s(bob),g))).

32. By 7, the attacker may know validkey(dhexp_real(key_e(alice,bob,sid_5),g)).
So the attacker may know validkey(dhexp_real(key_e(alice,bob,sid_5),g)) in phase 1.
attacker_p1(validkey(dhexp_real(key_e(alice,bob,sid_5),g))).

33. By 30, the attacker may know key_s(bob) in phase 1.
By 32, the attacker may know validkey(dhexp_real(key_e(alice,bob,sid_5),g)) in phase 1.
Using the function dhexp the attacker may obtain dhexp_real(key_e(alice,bob,sid_5),dhexp_real(key_s(bob),g)) in phase 1.
attacker_p1(dhexp_real(key_e(alice,bob,sid_5),dhexp_real(key_s(bob),g))).

34. Using the function empty the attacker may obtain empty in phase 1.
attacker_p1(empty).

35. Using the function somename the attacker may obtain somename in phase 1.
attacker_p1(somename).

36. By 35, the attacker may know somename in phase 1.
By 34, the attacker may know empty in phase 1.
Using the function hash the attacker may obtain hash(somename,empty) in phase 1.
attacker_p1(hash(somename,empty)).

37. By 36, the attacker may know hash(somename,empty) in phase 1.
By 33, the attacker may know dhexp_real(key_e(alice,bob,sid_5),dhexp_real(key_s(bob),g)) in phase 1.
Using the function hmac_hash1 the attacker may obtain hmac_hash1(hash(somename,empty),dhexp_real(key_e(alice,bob,sid_5),dhexp_real(key_s(bob),g))) in phase 1.
attacker_p1(hmac_hash1(hash(somename,empty),dhexp_real(key_e(alice,bob,sid_5),dhexp_real(key_s(bob),g)))).

38. By 37, the attacker may know hmac_hash1(hash(somename,empty),dhexp_real(key_e(alice,bob,sid_5),dhexp_real(key_s(bob),g))) in phase 1.
By 31, the attacker may know dhexp_real(key_m(alice),dhexp_real(key_s(bob),g)) in phase 1.
Using the function hmac_hash2 the attacker may obtain hmac_hash2(hmac_hash1(hash(somename,empty),dhexp_real(key_e(alice,bob,sid_5),dhexp_real(key_s(bob),g))),dhexp_real(key_m(alice),dhexp_real(key_s(bob),g))) in phase 1.
attacker_p1(hmac_hash2(hmac_hash1(hash(somename,empty),dhexp_real(key_e(alice,bob,sid_5),dhexp_real(key_s(bob),g))),dhexp_real(key_m(alice),dhexp_real(key_s(bob),g)))).

39. By 38, the attacker may know hmac_hash2(hmac_hash1(hash(somename,empty),dhexp_real(key_e(alice,bob,sid_5),dhexp_real(key_s(bob),g))),dhexp_real(key_m(alice),dhexp_real(key_s(bob),g))) in phase 1.
By 25, the attacker may know minnonce in phase 1.
By 24, the attacker may know hash(hash(hash(hash(hash(hash(hash(somename,empty),empty),validkey(dhexp_real(key_s(alice),g))),validkey(dhexp_real(key_m(alice),g))),validkey(dhexp_real(key_s(bob),g))),validkey(dhexp_real(key_s(bob),g))),validkey(dhexp_real(key_e(alice,bob,sid_5),g))) in phase 1.
By 6, the attacker may know encrypt(hmac_hash2(hmac_hash1(hash(somename,empty),dhexp_real(key_e(alice,bob,sid_5),dhexp_real(key_s(bob),g))),dhexp_real(key_m(alice),dhexp_real(key_s(bob),g))),minnonce,hash(hash(hash(hash(hash(hash(hash(somename,empty),empty),validkey(dhexp_real(key_s(alice),g))),validkey(dhexp_real(key_m(alice),g))),validkey(dhexp_real(key_s(bob),g))),validkey(dhexp_real(key_s(bob),g))),validkey(dhexp_real(key_e(alice,bob,sid_5),g))),msg_a(alice,bob,sid_5)) in phase 1.
Using the function decrypt the attacker may obtain aeadpack(true,hash(hash(hash(hash(hash(hash(hash(somename,empty),empty),validkey(dhexp_real(key_s(alice),g))),validkey(dhexp_real(key_m(alice),g))),validkey(dhexp_real(key_s(bob),g))),validkey(dhexp_real(key_s(bob),g))),validkey(dhexp_real(key_e(alice,bob,sid_5),g))),msg_a(alice,bob,sid_5)) in phase 1.
attacker_p1(aeadpack(true,hash(hash(hash(hash(hash(hash(hash(somename,empty),empty),validkey(dhexp_real(key_s(alice),g))),validkey(dhexp_real(key_m(alice),g))),validkey(dhexp_real(key_s(bob),g))),validkey(dhexp_real(key_s(bob),g))),validkey(dhexp_real(key_e(alice,bob,sid_5),g))),msg_a(alice,bob,sid_5))).

40. By 39, the attacker may know aeadpack(true,hash(hash(hash(hash(hash(hash(hash(somename,empty),empty),validkey(dhexp_real(key_s(alice),g))),validkey(dhexp_real(key_m(alice),g))),validkey(dhexp_real(key_s(bob),g))),validkey(dhexp_real(key_s(bob),g))),validkey(dhexp_real(key_e(alice,bob,sid_5),g))),msg_a(alice,bob,sid_5)) in phase 1.
Using the function 3-proj-aeadpack the attacker may obtain msg_a(alice,bob,sid_5) in phase 1.
attacker_p1(msg_a(alice,bob,sid_5)).

41. By 40, attacker_p1(msg_a(alice,bob,sid_5)).
The goal is reached, represented in the following fact:
attacker_p1(msg_a(alice,bob,sid_5)).


RESULT attacker_p1(msg_a(alice,bob,sid_a)) ==> (event(LeakS(phase0,bob)) && event(LeakM(phase0,bob))) || (event(LeakS(px,bob)) && event(LeakM(px,bob)) && event(LeakS(pz,alice)) && event(LeakM(pz,alice))) cannot be proved.
Starting query attacker_p1(msg_a(alice,bob,sid_a)) ==> event(LeakS(phase0,bob)) && event(LeakM(phase0,bob))
goal reachable: begin(LeakM(phase1,bob)) && begin(LeakS(phase1,bob)) && begin(SendMsg(alice,bob,stagepack_a(sid_5),msg_a(alice,bob,sid_5))) -> attacker_p1(msg_a(alice,bob,sid_5))
Abbreviations:
sid_5 = sid[!1 = @sid]

Derivation:
Abbreviations:
sid_5 = sid[!1 = @sid]

1. Using the function pub the attacker may obtain pub.
attacker(pub).

2. The entry statestore(alice,bob,sid_5,statepack_a(handshakestatepack(symmetricstatepack(cipherstatepack(empty,minnonce),hash(somename,empty),hash(hash(hash(hash(hash(hash(somename,empty),empty),validkey(dhexp_real(key_s(alice),g))),validkey(dhexp_real(key_m(alice),g))),validkey(dhexp_real(key_s(bob),g))),validkey(dhexp_real(key_s(bob),g)))),keypairpack(validkey(dhexp_real(key_s(alice),g)),key_s(alice)),keypairpack(validkey(dhexp_real(key_m(alice),g)),key_m(alice)),keypairpack(empty,empty),validkey(dhexp_real(key_s(bob),g)),validkey(dhexp_real(key_s(bob),g)),empty,empty,true))) may be inserted in a table at insert {74}.
table(statestore(alice,bob,sid_5,statepack_a(handshakestatepack(symmetricstatepack(cipherstatepack(empty,minnonce),hash(somename,empty),hash(hash(hash(hash(hash(hash(somename,empty),empty),validkey(dhexp_real(key_s(alice),g))),validkey(dhexp_real(key_m(alice),g))),validkey(dhexp_real(key_s(bob),g))),validkey(dhexp_real(key_s(bob),g)))),keypairpack(validkey(dhexp_real(key_s(alice),g)),key_s(alice)),keypairpack(validkey(dhexp_real(key_m(alice),g)),key_m(alice)),keypairpack(empty,empty),validkey(dhexp_real(key_s(bob),g)),validkey(dhexp_real(key_s(bob),g)),empty,empty,true)))).

3. The entry statestore(alice,bob,sid_5,statepack_a(handshakestatepack(symmetricstatepack(cipherstatepack(empty,minnonce),hash(somename,empty),hash(hash(hash(hash(hash(hash(somename,empty),empty),validkey(dhexp_real(key_s(alice),g))),validkey(dhexp_real(key_m(alice),g))),validkey(dhexp_real(key_s(bob),g))),validkey(dhexp_real(key_s(bob),g)))),keypairpack(validkey(dhexp_real(key_s(alice),g)),key_s(alice)),keypairpack(validkey(dhexp_real(key_m(alice),g)),key_m(alice)),keypairpack(empty,empty),validkey(dhexp_real(key_s(bob),g)),validkey(dhexp_real(key_s(bob),g)),empty,empty,true))) that may be in a table by 2 may be read at get {187}.
The event SendMsg(alice,bob,stagepack_a(sid_5),msg_a(alice,bob,sid_5)) may be executed at {184}.
So the message concat3(validkey(dhexp_real(key_e(alice,bob,sid_5),g)),empty,encrypt(hmac_hash2(hmac_hash1(hash(somename,empty),dhexp_real(key_e(alice,bob,sid_5),dhexp_real(key_s(bob),g))),dhexp_real(key_m(alice),dhexp_real(key_s(bob),g))),minnonce,hash(hash(hash(hash(hash(hash(hash(somename,empty),empty),validkey(dhexp_real(key_s(alice),g))),validkey(dhexp_real(key_m(alice),g))),validkey(dhexp_real(key_s(bob),g))),validkey(dhexp_real(key_s(bob),g))),validkey(dhexp_real(key_e(alice,bob,sid_5),g))),msg_a(alice,bob,sid_5))) may be sent on channel pub at output {186}.
mess(pub,concat3(validkey(dhexp_real(key_e(alice,bob,sid_5),g)),empty,encrypt(hmac_hash2(hmac_hash1(hash(somename,empty),dhexp_real(key_e(alice,bob,sid_5),dhexp_real(key_s(bob),g))),dhexp_real(key_m(alice),dhexp_real(key_s(bob),g))),minnonce,hash(hash(hash(hash(hash(hash(hash(somename,empty),empty),validkey(dhexp_real(key_s(alice),g))),validkey(dhexp_real(key_m(alice),g))),validkey(dhexp_real(key_s(bob),g))),validkey(dhexp_real(key_s(bob),g))),validkey(dhexp_real(key_e(alice,bob,sid_5),g))),msg_a(alice,bob,sid_5)))).

4. By 1, the attacker may have the channel pub.
By 3, the message concat3(validkey(dhexp_real(key_e(alice,bob,sid_5),g)),empty,encrypt(hmac_hash2(hmac_hash1(hash(somename,empty),dhexp_real(key_e(alice,bob,sid_5),dhexp_real(key_s(bob),g))),dhexp_real(key_m(alice),dhexp_real(key_s(bob),g))),minnonce,hash(hash(hash(hash(hash(hash(hash(somename,empty),empty),validkey(dhexp_real(key_s(alice),g))),validkey(dhexp_real(key_m(alice),g))),validkey(dhexp_real(key_s(bob),g))),validkey(dhexp_real(key_s(bob),g))),validkey(dhexp_real(key_e(alice,bob,sid_5),g))),msg_a(alice,bob,sid_5))) may be sent on this channel.
So the attacker may obtain the message concat3(validkey(dhexp_real(key_e(alice,bob,sid_5),g)),empty,encrypt(hmac_hash2(hmac_hash1(hash(somename,empty),dhexp_real(key_e(alice,bob,sid_5),dhexp_real(key_s(bob),g))),dhexp_real(key_m(alice),dhexp_real(key_s(bob),g))),minnonce,hash(hash(hash(hash(hash(hash(hash(somename,empty),empty),validkey(dhexp_real(key_s(alice),g))),validkey(dhexp_real(key_m(alice),g))),validkey(dhexp_real(key_s(bob),g))),validkey(dhexp_real(key_s(bob),g))),validkey(dhexp_real(key_e(alice,bob,sid_5),g))),msg_a(alice,bob,sid_5))) by listening on this channel.
attacker(concat3(validkey(dhexp_real(key_e(alice,bob,sid_5),g)),empty,encrypt(hmac_hash2(hmac_hash1(hash(somename,empty),dhexp_real(key_e(alice,bob,sid_5),dhexp_real(key_s(bob),g))),dhexp_real(key_m(alice),dhexp_real(key_s(bob),g))),minnonce,hash(hash(hash(hash(hash(hash(hash(somename,empty),empty),validkey(dhexp_real(key_s(alice),g))),validkey(dhexp_real(key_m(alice),g))),validkey(dhexp_real(key_s(bob),g))),validkey(dhexp_real(key_s(bob),g))),validkey(dhexp_real(key_e(alice,bob,sid_5),g))),msg_a(alice,bob,sid_5)))).

5. By 4, the attacker may know concat3(validkey(dhexp_real(key_e(alice,bob,sid_5),g)),empty,encrypt(hmac_hash2(hmac_hash1(hash(somename,empty),dhexp_real(key_e(alice,bob,sid_5),dhexp_real(key_s(bob),g))),dhexp_real(key_m(alice),dhexp_real(key_s(bob),g))),minnonce,hash(hash(hash(hash(hash(hash(hash(somename,empty),empty),validkey(dhexp_real(key_s(alice),g))),validkey(dhexp_real(key_m(alice),g))),validkey(dhexp_real(key_s(bob),g))),validkey(dhexp_real(key_s(bob),g))),validkey(dhexp_real(key_e(alice,bob,sid_5),g))),msg_a(alice,bob,sid_5))).
Using the function 3-proj-concat3 the attacker may obtain encrypt(hmac_hash2(hmac_hash1(hash(somename,empty),dhexp_real(key_e(alice,bob,sid_5),dhexp_real(key_s(bob),g))),dhexp_real(key_m(alice),dhexp_real(key_s(bob),g))),minnonce,hash(hash(hash(hash(hash(hash(hash(somename,empty),empty),validkey(dhexp_real(key_s(alice),g))),validkey(dhexp_real(key_m(alice),g))),validkey(dhexp_real(key_s(bob),g))),validkey(dhexp_real(key_s(bob),g))),validkey(dhexp_real(key_e(alice,bob,sid_5),g))),msg_a(alice,bob,sid_5)).
attacker(encrypt(hmac_hash2(hmac_hash1(hash(somename,empty),dhexp_real(key_e(alice,bob,sid_5),dhexp_real(key_s(bob),g))),dhexp_real(key_m(alice),dhexp_real(key_s(bob),g))),minnonce,hash(hash(hash(hash(hash(hash(hash(somename,empty),empty),validkey(dhexp_real(key_s(alice),g))),validkey(dhexp_real(key_m(alice),g))),validkey(dhexp_real(key_s(bob),g))),validkey(dhexp_real(key_s(bob),g))),validkey(dhexp_real(key_e(alice,bob,sid_5),g))),msg_a(alice,bob,sid_5))).

6. By 5, the attacker may know encrypt(hmac_hash2(hmac_hash1(hash(somename,empty),dhexp_real(key_e(alice,bob,sid_5),dhexp_real(key_s(bob),g))),dhexp_real(key_m(alice),dhexp_real(key_s(bob),g))),minnonce,hash(hash(hash(hash(hash(hash(hash(somename,empty),empty),validkey(dhexp_real(key_s(alice),g))),validkey(dhexp_real(key_m(alice),g))),validkey(dhexp_real(key_s(bob),g))),validkey(dhexp_real(key_s(bob),g))),validkey(dhexp_real(key_e(alice,bob,sid_5),g))),msg_a(alice,bob,sid_5)).
So the attacker may know encrypt(hmac_hash2(hmac_hash1(hash(somename,empty),dhexp_real(key_e(alice,bob,sid_5),dhexp_real(key_s(bob),g))),dhexp_real(key_m(alice),dhexp_real(key_s(bob),g))),minnonce,hash(hash(hash(hash(hash(hash(hash(somename,empty),empty),validkey(dhexp_real(key_s(alice),g))),validkey(dhexp_real(key_m(alice),g))),validkey(dhexp_real(key_s(bob),g))),validkey(dhexp_real(key_s(bob),g))),validkey(dhexp_real(key_e(alice,bob,sid_5),g))),msg_a(alice,bob,sid_5)) in phase 1.
attacker_p1(encrypt(hmac_hash2(hmac_hash1(hash(somename,empty),dhexp_real(key_e(alice,bob,sid_5),dhexp_real(key_s(bob),g))),dhexp_real(key_m(alice),dhexp_real(key_s(bob),g))),minnonce,hash(hash(hash(hash(hash(hash(hash(somename,empty),empty),validkey(dhexp_real(key_s(alice),g))),validkey(dhexp_real(key_m(alice),g))),validkey(dhexp_real(key_s(bob),g))),validkey(dhexp_real(key_s(bob),g))),validkey(dhexp_real(key_e(alice,bob,sid_5),g))),msg_a(alice,bob,sid_5))).

7. By 4, the attacker may know concat3(validkey(dhexp_real(key_e(alice,bob,sid_5),g)),empty,encrypt(hmac_hash2(hmac_hash1(hash(somename,empty),dhexp_real(key_e(alice,bob,sid_5),dhexp_real(key_s(bob),g))),dhexp_real(key_m(alice),dhexp_real(key_s(bob),g))),minnonce,hash(hash(hash(hash(hash(hash(hash(somename,empty),empty),validkey(dhexp_real(key_s(alice),g))),validkey(dhexp_real(key_m(alice),g))),validkey(dhexp_real(key_s(bob),g))),validkey(dhexp_real(key_s(bob),g))),validkey(dhexp_real(key_e(alice,bob,sid_5),g))),msg_a(alice,bob,sid_5))).
Using the function 1-proj-concat3 the attacker may obtain validkey(dhexp_real(key_e(alice,bob,sid_5),g)).
attacker(validkey(dhexp_real(key_e(alice,bob,sid_5),g))).

8. The message (validkey(dhexp_real(key_s(bob),g)),validkey(dhexp_real(key_m(bob),g))) may be sent on channel pub at output {963}.
mess(pub,(validkey(dhexp_real(key_s(bob),g)),validkey(dhexp_real(key_m(bob),g)))).

9. By 1, the attacker may have the channel pub.
By 8, the message (validkey(dhexp_real(key_s(bob),g)),validkey(dhexp_real(key_m(bob),g))) may be sent on this channel.
So the attacker may obtain the message (validkey(dhexp_real(key_s(bob),g)),validkey(dhexp_real(key_m(bob),g))) by listening on this channel.
attacker((validkey(dhexp_real(key_s(bob),g)),validkey(dhexp_real(key_m(bob),g)))).

10. By 9, the attacker may know (validkey(dhexp_real(key_s(bob),g)),validkey(dhexp_real(key_m(bob),g))).
Using the function 1-proj-2-tuple the attacker may obtain validkey(dhexp_real(key_s(bob),g)).
attacker(validkey(dhexp_real(key_s(bob),g))).

11. The message (validkey(dhexp_real(key_s(alice),g)),validkey(dhexp_real(key_m(alice),g))) may be sent on channel pub at output {15}.
mess(pub,(validkey(dhexp_real(key_s(alice),g)),validkey(dhexp_real(key_m(alice),g)))).

12. By 1, the attacker may have the channel pub.
By 11, the message (validkey(dhexp_real(key_s(alice),g)),validkey(dhexp_real(key_m(alice),g))) may be sent on this channel.
So the attacker may obtain the message (validkey(dhexp_real(key_s(alice),g)),validkey(dhexp_real(key_m(alice),g))) by listening on this channel.
attacker((validkey(dhexp_real(key_s(alice),g)),validkey(dhexp_real(key_m(alice),g)))).

13. By 12, the attacker may know (validkey(dhexp_real(key_s(alice),g)),validkey(dhexp_real(key_m(alice),g))).
Using the function 2-proj-2-tuple the attacker may obtain validkey(dhexp_real(key_m(alice),g)).
attacker(validkey(dhexp_real(key_m(alice),g))).

14. By 12, the attacker may know (validkey(dhexp_real(key_s(alice),g)),validkey(dhexp_real(key_m(alice),g))).
Using the function 1-proj-2-tuple the attacker may obtain validkey(dhexp_real(key_s(alice),g)).
attacker(validkey(dhexp_real(key_s(alice),g))).

15. Using the function empty the attacker may obtain empty.
attacker(empty).

16. Using the function somename the attacker may obtain somename.
attacker(somename).

17. By 16, the attacker may know somename.
By 15, the attacker may know empty.
Using the function hash the attacker may obtain hash(somename,empty).
attacker(hash(somename,empty)).

18. By 17, the attacker may know hash(somename,empty).
By 15, the attacker may know empty.
Using the function hash the attacker may obtain hash(hash(somename,empty),empty).
attacker(hash(hash(somename,empty),empty)).

19. By 18, the attacker may know hash(hash(somename,empty),empty).
By 14, the attacker may know validkey(dhexp_real(key_s(alice),g)).
Using the function hash the attacker may obtain hash(hash(hash(somename,empty),empty),validkey(dhexp_real(key_s(alice),g))).
attacker(hash(hash(hash(somename,empty),empty),validkey(dhexp_real(key_s(alice),g)))).

20. By 19, the attacker may know hash(hash(hash(somename,empty),empty),validkey(dhexp_real(key_s(alice),g))).
By 13, the attacker may know validkey(dhexp_real(key_m(alice),g)).
Using the function hash the attacker may obtain hash(hash(hash(hash(somename,empty),empty),validkey(dhexp_real(key_s(alice),g))),validkey(dhexp_real(key_m(alice),g))).
attacker(hash(hash(hash(hash(somename,empty),empty),validkey(dhexp_real(key_s(alice),g))),validkey(dhexp_real(key_m(alice),g)))).

21. By 20, the attacker may know hash(hash(hash(hash(somename,empty),empty),validkey(dhexp_real(key_s(alice),g))),validkey(dhexp_real(key_m(alice),g))).
By 10, the attacker may know validkey(dhexp_real(key_s(bob),g)).
Using the function hash the attacker may obtain hash(hash(hash(hash(hash(somename,empty),empty),validkey(dhexp_real(key_s(alice),g))),validkey(dhexp_real(key_m(alice),g))),validkey(dhexp_real(key_s(bob),g))).
attacker(hash(hash(hash(hash(hash(somename,empty),empty),validkey(dhexp_real(key_s(alice),g))),validkey(dhexp_real(key_m(alice),g))),validkey(dhexp_real(key_s(bob),g)))).

22. By 21, the attacker may know hash(hash(hash(hash(hash(somename,empty),empty),validkey(dhexp_real(key_s(alice),g))),validkey(dhexp_real(key_m(alice),g))),validkey(dhexp_real(key_s(bob),g))).
By 10, the attacker may know validkey(dhexp_real(key_s(bob),g)).
Using the function hash the attacker may obtain hash(hash(hash(hash(hash(hash(somename,empty),empty),validkey(dhexp_real(key_s(alice),g))),validkey(dhexp_real(key_m(alice),g))),validkey(dhexp_real(key_s(bob),g))),validkey(dhexp_real(key_s(bob),g))).
attacker(hash(hash(hash(hash(hash(hash(somename,empty),empty),validkey(dhexp_real(key_s(alice),g))),validkey(dhexp_real(key_m(alice),g))),validkey(dhexp_real(key_s(bob),g))),validkey(dhexp_real(key_s(bob),g)))).

23. By 22, the attacker may know hash(hash(hash(hash(hash(hash(somename,empty),empty),validkey(dhexp_real(key_s(alice),g))),validkey(dhexp_real(key_m(alice),g))),validkey(dhexp_real(key_s(bob),g))),validkey(dhexp_real(key_s(bob),g))).
By 7, the attacker may know validkey(dhexp_real(key_e(alice,bob,sid_5),g)).
Using the function hash the attacker may obtain hash(hash(hash(hash(hash(hash(hash(somename,empty),empty),validkey(dhexp_real(key_s(alice),g))),validkey(dhexp_real(key_m(alice),g))),validkey(dhexp_real(key_s(bob),g))),validkey(dhexp_real(key_s(bob),g))),validkey(dhexp_real(key_e(alice,bob,sid_5),g))).
attacker(hash(hash(hash(hash(hash(hash(hash(somename,empty),empty),validkey(dhexp_real(key_s(alice),g))),validkey(dhexp_real(key_m(alice),g))),validkey(dhexp_real(key_s(bob),g))),validkey(dhexp_real(key_s(bob),g))),validkey(dhexp_real(key_e(alice,bob,sid_5),g)))).

24. By 23, the attacker may know hash(hash(hash(hash(hash(hash(hash(somename,empty),empty),validkey(dhexp_real(key_s(alice),g))),validkey(dhexp_real(key_m(alice),g))),validkey(dhexp_real(key_s(bob),g))),validkey(dhexp_real(key_s(bob),g))),validkey(dhexp_real(key_e(alice,bob,sid_5),g))).
So the attacker may know hash(hash(hash(hash(hash(hash(hash(somename,empty),empty),validkey(dhexp_real(key_s(alice),g))),validkey(dhexp_real(key_m(alice),g))),validkey(dhexp_real(key_s(bob),g))),validkey(dhexp_real(key_s(bob),g))),validkey(dhexp_real(key_e(alice,bob,sid_5),g))) in phase 1.
attacker_p1(hash(hash(hash(hash(hash(hash(hash(somename,empty),empty),validkey(dhexp_real(key_s(alice),g))),validkey(dhexp_real(key_m(alice),g))),validkey(dhexp_real(key_s(bob),g))),validkey(dhexp_real(key_s(bob),g))),validkey(dhexp_real(key_e(alice,bob,sid_5),g)))).

25. Using the function minnonce the attacker may obtain minnonce in phase 1.
attacker_p1(minnonce).

26. By 13, the attacker may know validkey(dhexp_real(key_m(alice),g)).
So the attacker may know validkey(dhexp_real(key_m(alice),g)) in phase 1.
attacker_p1(validkey(dhexp_real(key_m(alice),g))).

27. Using the function pub the attacker may obtain pub in phase 1.
attacker_p1(pub).

28. The event LeakS(phase1,bob) may be executed at {1422}.
The event LeakM(phase1,bob) may be executed at {1423}.
So the message (key_s(bob),key_m(bob)) may be sent on channel pub in phase 1 at output {1424}.
mess_p1(pub,(key_s(bob),key_m(bob))).

29. By 27, the attacker may have the channel pub in phase 1.
By 28, the message (key_s(bob),key_m(bob)) in phase 1 may be sent on this channel.
So the attacker may obtain the message (key_s(bob),key_m(bob)) in phase 1 by listening on this channel.
attacker_p1((key_s(bob),key_m(bob))).

30. By 29, the attacker may know (key_s(bob),key_m(bob)) in phase 1.
Using the function 1-proj-2-tuple the attacker may obtain key_s(bob) in phase 1.
attacker_p1(key_s(bob)).

31. By 30, the attacker may know key_s(bob) in phase 1.
By 26, the attacker may know validkey(dhexp_real(key_m(alice),g)) in phase 1.
Using the function dhexp the attacker may obtain dhexp_real(key_m(alice),dhexp_real(key_s(bob),g)) in phase 1.
attacker_p1(dhexp_real(key_m(alice),dhexp_real(key_s(bob),g))).

32. By 7, the attacker may know validkey(dhexp_real(key_e(alice,bob,sid_5),g)).
So the attacker may know validkey(dhexp_real(key_e(alice,bob,sid_5),g)) in phase 1.
attacker_p1(validkey(dhexp_real(key_e(alice,bob,sid_5),g))).

33. By 30, the attacker may know key_s(bob) in phase 1.
By 32, the attacker may know validkey(dhexp_real(key_e(alice,bob,sid_5),g)) in phase 1.
Using the function dhexp the attacker may obtain dhexp_real(key_e(alice,bob,sid_5),dhexp_real(key_s(bob),g)) in phase 1.
attacker_p1(dhexp_real(key_e(alice,bob,sid_5),dhexp_real(key_s(bob),g))).

34. Using the function empty the attacker may obtain empty in phase 1.
attacker_p1(empty).

35. Using the function somename the attacker may obtain somename in phase 1.
attacker_p1(somename).

36. By 35, the attacker may know somename in phase 1.
By 34, the attacker may know empty in phase 1.
Using the function hash the attacker may obtain hash(somename,empty) in phase 1.
attacker_p1(hash(somename,empty)).

37. By 36, the attacker may know hash(somename,empty) in phase 1.
By 33, the attacker may know dhexp_real(key_e(alice,bob,sid_5),dhexp_real(key_s(bob),g)) in phase 1.
Using the function hmac_hash1 the attacker may obtain hmac_hash1(hash(somename,empty),dhexp_real(key_e(alice,bob,sid_5),dhexp_real(key_s(bob),g))) in phase 1.
attacker_p1(hmac_hash1(hash(somename,empty),dhexp_real(key_e(alice,bob,sid_5),dhexp_real(key_s(bob),g)))).

38. By 37, the attacker may know hmac_hash1(hash(somename,empty),dhexp_real(key_e(alice,bob,sid_5),dhexp_real(key_s(bob),g))) in phase 1.
By 31, the attacker may know dhexp_real(key_m(alice),dhexp_real(key_s(bob),g)) in phase 1.
Using the function hmac_hash2 the attacker may obtain hmac_hash2(hmac_hash1(hash(somename,empty),dhexp_real(key_e(alice,bob,sid_5),dhexp_real(key_s(bob),g))),dhexp_real(key_m(alice),dhexp_real(key_s(bob),g))) in phase 1.
attacker_p1(hmac_hash2(hmac_hash1(hash(somename,empty),dhexp_real(key_e(alice,bob,sid_5),dhexp_real(key_s(bob),g))),dhexp_real(key_m(alice),dhexp_real(key_s(bob),g)))).

39. By 38, the attacker may know hmac_hash2(hmac_hash1(hash(somename,empty),dhexp_real(key_e(alice,bob,sid_5),dhexp_real(key_s(bob),g))),dhexp_real(key_m(alice),dhexp_real(key_s(bob),g))) in phase 1.
By 25, the attacker may know minnonce in phase 1.
By 24, the attacker may know hash(hash(hash(hash(hash(hash(hash(somename,empty),empty),validkey(dhexp_real(key_s(alice),g))),validkey(dhexp_real(key_m(alice),g))),validkey(dhexp_real(key_s(bob),g))),validkey(dhexp_real(key_s(bob),g))),validkey(dhexp_real(key_e(alice,bob,sid_5),g))) in phase 1.
By 6, the attacker may know encrypt(hmac_hash2(hmac_hash1(hash(somename,empty),dhexp_real(key_e(alice,bob,sid_5),dhexp_real(key_s(bob),g))),dhexp_real(key_m(alice),dhexp_real(key_s(bob),g))),minnonce,hash(hash(hash(hash(hash(hash(hash(somename,empty),empty),validkey(dhexp_real(key_s(alice),g))),validkey(dhexp_real(key_m(alice),g))),validkey(dhexp_real(key_s(bob),g))),validkey(dhexp_real(key_s(bob),g))),validkey(dhexp_real(key_e(alice,bob,sid_5),g))),msg_a(alice,bob,sid_5)) in phase 1.
Using the function decrypt the attacker may obtain aeadpack(true,hash(hash(hash(hash(hash(hash(hash(somename,empty),empty),validkey(dhexp_real(key_s(alice),g))),validkey(dhexp_real(key_m(alice),g))),validkey(dhexp_real(key_s(bob),g))),validkey(dhexp_real(key_s(bob),g))),validkey(dhexp_real(key_e(alice,bob,sid_5),g))),msg_a(alice,bob,sid_5)) in phase 1.
attacker_p1(aeadpack(true,hash(hash(hash(hash(hash(hash(hash(somename,empty),empty),validkey(dhexp_real(key_s(alice),g))),validkey(dhexp_real(key_m(alice),g))),validkey(dhexp_real(key_s(bob),g))),validkey(dhexp_real(key_s(bob),g))),validkey(dhexp_real(key_e(alice,bob,sid_5),g))),msg_a(alice,bob,sid_5))).

40. By 39, the attacker may know aeadpack(true,hash(hash(hash(hash(hash(hash(hash(somename,empty),empty),validkey(dhexp_real(key_s(alice),g))),validkey(dhexp_real(key_m(alice),g))),validkey(dhexp_real(key_s(bob),g))),validkey(dhexp_real(key_s(bob),g))),validkey(dhexp_real(key_e(alice,bob,sid_5),g))),msg_a(alice,bob,sid_5)) in phase 1.
Using the function 3-proj-aeadpack the attacker may obtain msg_a(alice,bob,sid_5) in phase 1.
attacker_p1(msg_a(alice,bob,sid_5)).

41. By 40, attacker_p1(msg_a(alice,bob,sid_5)).
The goal is reached, represented in the following fact:
attacker_p1(msg_a(alice,bob,sid_5)).


RESULT attacker_p1(msg_a(alice,bob,sid_a)) ==> event(LeakS(phase0,bob)) && event(LeakM(phase0,bob)) cannot be proved.
Starting query event(RecvMsg(alice,bob,stagepack_b(sid_a),msg)) ==> event(SendMsg(bob,alice,stagepack_b(sid_b),msg))
RESULT event(RecvMsg(alice,bob,stagepack_b(sid_a),msg)) ==> event(SendMsg(bob,alice,stagepack_b(sid_b),msg)) is true.
Starting query event(RecvMsg(alice,bob,stagepack_b(sid_a),msg)) ==> event(SendMsg(bob,c,stagepack_b(sid_b),msg)) || (event(LeakS(phase0,bob)) && event(LeakM(phase0,bob))) || (event(LeakS(phase0,alice)) && event(LeakM(phase0,alice)))
RESULT event(RecvMsg(alice,bob,stagepack_b(sid_a),msg)) ==> event(SendMsg(bob,c,stagepack_b(sid_b),msg)) || (event(LeakS(phase0,bob)) && event(LeakM(phase0,bob))) || (event(LeakS(phase0,alice)) && event(LeakM(phase0,alice))) is true.
Starting query event(RecvMsg(alice,bob,stagepack_b(sid_a),msg)) ==> event(SendMsg(bob,c,stagepack_b(sid_b),msg)) || (event(LeakS(phase0,bob)) && event(LeakM(phase0,bob)))
RESULT event(RecvMsg(alice,bob,stagepack_b(sid_a),msg)) ==> event(SendMsg(bob,c,stagepack_b(sid_b),msg)) || (event(LeakS(phase0,bob)) && event(LeakM(phase0,bob))) is true.
Starting query event(RecvMsg(alice,bob,stagepack_b(sid_a),msg)) ==> event(SendMsg(bob,alice,stagepack_b(sid_b),msg)) || (event(LeakS(phase0,bob)) && event(LeakM(phase0,bob))) || (event(LeakS(phase0,alice)) && event(LeakM(phase0,alice)))
RESULT event(RecvMsg(alice,bob,stagepack_b(sid_a),msg)) ==> event(SendMsg(bob,alice,stagepack_b(sid_b),msg)) || (event(LeakS(phase0,bob)) && event(LeakM(phase0,bob))) || (event(LeakS(phase0,alice)) && event(LeakM(phase0,alice))) is true.
Starting query event(RecvMsg(alice,bob,stagepack_b(sid_a),msg)) ==> event(SendMsg(bob,alice,stagepack_b(sid_b),msg)) || (event(LeakS(phase0,bob)) && event(LeakM(phase0,bob)))
RESULT event(RecvMsg(alice,bob,stagepack_b(sid_a),msg)) ==> event(SendMsg(bob,alice,stagepack_b(sid_b),msg)) || (event(LeakS(phase0,bob)) && event(LeakM(phase0,bob))) is true.
Starting query not attacker_p1(msg_b(bob,alice,sid_b))
RESULT not attacker_p1(msg_b(bob,alice,sid_b)) is true.
Starting query attacker_p1(msg_b(bob,alice,sid_b)) ==> event(LeakS(px,alice)) && event(LeakM(px,alice))
RESULT attacker_p1(msg_b(bob,alice,sid_b)) ==> event(LeakS(px,alice)) && event(LeakM(px,alice)) is true.
Starting query attacker_p1(msg_b(bob,alice,sid_b)) ==> (event(LeakS(phase0,alice)) && event(LeakM(phase0,alice))) || (event(LeakS(px,alice)) && event(LeakM(px,alice)) && event(LeakS(pz,bob)) && event(LeakM(pz,bob)))
RESULT attacker_p1(msg_b(bob,alice,sid_b)) ==> (event(LeakS(phase0,alice)) && event(LeakM(phase0,alice))) || (event(LeakS(px,alice)) && event(LeakM(px,alice)) && event(LeakS(pz,bob)) && event(LeakM(pz,bob))) is true.
Starting query attacker_p1(msg_b(bob,alice,sid_b)) ==> event(LeakS(phase0,alice)) && event(LeakM(phase0,alice))
RESULT attacker_p1(msg_b(bob,alice,sid_b)) ==> event(LeakS(phase0,alice)) && event(LeakM(phase0,alice)) is true.
Starting query event(RecvMsg(bob,alice,stagepack_c(sid_b),msg)) ==> event(SendMsg(alice,bob,stagepack_c(sid_a),msg))
RESULT event(RecvMsg(bob,alice,stagepack_c(sid_b),msg)) ==> event(SendMsg(alice,bob,stagepack_c(sid_a),msg)) is true.
Starting query event(RecvMsg(bob,alice,stagepack_c(sid_b),msg)) ==> event(SendMsg(alice,c,stagepack_c(sid_a),msg)) || (event(LeakS(phase0,alice)) && event(LeakM(phase0,alice))) || (event(LeakS(phase0,bob)) && event(LeakM(phase0,bob)))
RESULT event(RecvMsg(bob,alice,stagepack_c(sid_b),msg)) ==> event(SendMsg(alice,c,stagepack_c(sid_a),msg)) || (event(LeakS(phase0,alice)) && event(LeakM(phase0,alice))) || (event(LeakS(phase0,bob)) && event(LeakM(phase0,bob))) is true.
Starting query event(RecvMsg(bob,alice,stagepack_c(sid_b),msg)) ==> event(SendMsg(alice,c,stagepack_c(sid_a),msg)) || (event(LeakS(phase0,alice)) && event(LeakM(phase0,alice)))
RESULT event(RecvMsg(bob,alice,stagepack_c(sid_b),msg)) ==> event(SendMsg(alice,c,stagepack_c(sid_a),msg)) || (event(LeakS(phase0,alice)) && event(LeakM(phase0,alice))) is true.
Starting query event(RecvMsg(bob,alice,stagepack_c(sid_b),msg)) ==> event(SendMsg(alice,bob,stagepack_c(sid_a),msg)) || (event(LeakS(phase0,alice)) && event(LeakM(phase0,alice))) || (event(LeakS(phase0,bob)) && event(LeakM(phase0,bob)))
RESULT event(RecvMsg(bob,alice,stagepack_c(sid_b),msg)) ==> event(SendMsg(alice,bob,stagepack_c(sid_a),msg)) || (event(LeakS(phase0,alice)) && event(LeakM(phase0,alice))) || (event(LeakS(phase0,bob)) && event(LeakM(phase0,bob))) is true.
Starting query event(RecvMsg(bob,alice,stagepack_c(sid_b),msg)) ==> event(SendMsg(alice,bob,stagepack_c(sid_a),msg)) || (event(LeakS(phase0,alice)) && event(LeakM(phase0,alice)))
RESULT event(RecvMsg(bob,alice,stagepack_c(sid_b),msg)) ==> event(SendMsg(alice,bob,stagepack_c(sid_a),msg)) || (event(LeakS(phase0,alice)) && event(LeakM(phase0,alice))) is true.
Starting query not attacker_p1(msg_c(alice,bob,sid_a))
RESULT not attacker_p1(msg_c(alice,bob,sid_a)) is true.
Starting query attacker_p1(msg_c(alice,bob,sid_a)) ==> event(LeakS(px,bob)) && event(LeakM(px,bob))
RESULT attacker_p1(msg_c(alice,bob,sid_a)) ==> event(LeakS(px,bob)) && event(LeakM(px,bob)) is true.
Starting query attacker_p1(msg_c(alice,bob,sid_a)) ==> (event(LeakS(phase0,bob)) && event(LeakM(phase0,bob))) || (event(LeakS(px,bob)) && event(LeakM(px,bob)) && event(LeakS(pz,alice)) && event(LeakM(pz,alice)))
RESULT attacker_p1(msg_c(alice,bob,sid_a)) ==> (event(LeakS(phase0,bob)) && event(LeakM(phase0,bob))) || (event(LeakS(px,bob)) && event(LeakM(px,bob)) && event(LeakS(pz,alice)) && event(LeakM(pz,alice))) is true.
Starting query attacker_p1(msg_c(alice,bob,sid_a)) ==> event(LeakS(phase0,bob)) && event(LeakM(phase0,bob))
RESULT attacker_p1(msg_c(alice,bob,sid_a)) ==> event(LeakS(phase0,bob)) && event(LeakM(phase0,bob)) is true.
Starting query event(RecvMsg(alice,bob,stagepack_d(sid_a),msg)) ==> event(SendMsg(bob,alice,stagepack_d(sid_b),msg))
RESULT event(RecvMsg(alice,bob,stagepack_d(sid_a),msg)) ==> event(SendMsg(bob,alice,stagepack_d(sid_b),msg)) is true.
Starting query event(RecvMsg(alice,bob,stagepack_d(sid_a),msg)) ==> event(SendMsg(bob,c,stagepack_d(sid_b),msg)) || (event(LeakS(phase0,bob)) && event(LeakM(phase0,bob))) || (event(LeakS(phase0,alice)) && event(LeakM(phase0,alice)))
RESULT event(RecvMsg(alice,bob,stagepack_d(sid_a),msg)) ==> event(SendMsg(bob,c,stagepack_d(sid_b),msg)) || (event(LeakS(phase0,bob)) && event(LeakM(phase0,bob))) || (event(LeakS(phase0,alice)) && event(LeakM(phase0,alice))) is true.
Starting query event(RecvMsg(alice,bob,stagepack_d(sid_a),msg)) ==> event(SendMsg(bob,c,stagepack_d(sid_b),msg)) || (event(LeakS(phase0,bob)) && event(LeakM(phase0,bob)))
RESULT event(RecvMsg(alice,bob,stagepack_d(sid_a),msg)) ==> event(SendMsg(bob,c,stagepack_d(sid_b),msg)) || (event(LeakS(phase0,bob)) && event(LeakM(phase0,bob))) is true.
Starting query event(RecvMsg(alice,bob,stagepack_d(sid_a),msg)) ==> event(SendMsg(bob,alice,stagepack_d(sid_b),msg)) || (event(LeakS(phase0,bob)) && event(LeakM(phase0,bob))) || (event(LeakS(phase0,alice)) && event(LeakM(phase0,alice)))
RESULT event(RecvMsg(alice,bob,stagepack_d(sid_a),msg)) ==> event(SendMsg(bob,alice,stagepack_d(sid_b),msg)) || (event(LeakS(phase0,bob)) && event(LeakM(phase0,bob))) || (event(LeakS(phase0,alice)) && event(LeakM(phase0,alice))) is true.
Starting query event(RecvMsg(alice,bob,stagepack_d(sid_a),msg)) ==> event(SendMsg(bob,alice,stagepack_d(sid_b),msg)) || (event(LeakS(phase0,bob)) && event(LeakM(phase0,bob)))
RESULT event(RecvMsg(alice,bob,stagepack_d(sid_a),msg)) ==> event(SendMsg(bob,alice,stagepack_d(sid_b),msg)) || (event(LeakS(phase0,bob)) && event(LeakM(phase0,bob))) is true.
Starting query not attacker_p1(msg_d(bob,alice,sid_b))
RESULT not attacker_p1(msg_d(bob,alice,sid_b)) is true.
Starting query attacker_p1(msg_d(bob,alice,sid_b)) ==> event(LeakS(px,alice)) && event(LeakM(px,alice))
RESULT attacker_p1(msg_d(bob,alice,sid_b)) ==> event(LeakS(px,alice)) && event(LeakM(px,alice)) is true.
Starting query attacker_p1(msg_d(bob,alice,sid_b)) ==> (event(LeakS(phase0,alice)) && event(LeakM(phase0,alice))) || (event(LeakS(px,alice)) && event(LeakM(px,alice)) && event(LeakS(pz,bob)) && event(LeakM(pz,bob)))
RESULT attacker_p1(msg_d(bob,alice,sid_b)) ==> (event(LeakS(phase0,alice)) && event(LeakM(phase0,alice))) || (event(LeakS(px,alice)) && event(LeakM(px,alice)) && event(LeakS(pz,bob)) && event(LeakM(pz,bob))) is true.
Starting query attacker_p1(msg_d(bob,alice,sid_b)) ==> event(LeakS(phase0,alice)) && event(LeakM(phase0,alice))
RESULT attacker_p1(msg_d(bob,alice,sid_b)) ==> event(LeakS(phase0,alice)) && event(LeakM(phase0,alice)) is true.
Starting query not event(RecvEnd(true))
RESULT not event(RecvEnd(true)) is true.

--------------------------------------------------------------
Verification summary:

Query event(RecvMsg(bob,alice,stagepack_a(sid_b),msg)) ==> event(SendMsg(alice,bob,stagepack_a(sid_a),msg)) is true.

Query event(RecvMsg(bob,alice,stagepack_a(sid_b),msg)) ==> event(SendMsg(alice,c,stagepack_a(sid_a),msg)) || (event(LeakS(phase0,alice)) && event(LeakM(phase0,alice))) || (event(LeakS(phase0,bob)) && event(LeakM(phase0,bob))) is true.

Query event(RecvMsg(bob,alice,stagepack_a(sid_b),msg)) ==> event(SendMsg(alice,c,stagepack_a(sid_a),msg)) || (event(LeakS(phase0,alice)) && event(LeakM(phase0,alice))) is true.

Query event(RecvMsg(bob,alice,stagepack_a(sid_b),msg)) ==> event(SendMsg(alice,bob,stagepack_a(sid_a),msg)) || (event(LeakS(phase0,alice)) && event(LeakM(phase0,alice))) || (event(LeakS(phase0,bob)) && event(LeakM(phase0,bob))) is true.

Query event(RecvMsg(bob,alice,stagepack_a(sid_b),msg)) ==> event(SendMsg(alice,bob,stagepack_a(sid_a),msg)) || (event(LeakS(phase0,alice)) && event(LeakM(phase0,alice))) is true.

Query not attacker_p1(msg_a(alice,bob,sid_a)) cannot be proved.

Query attacker_p1(msg_a(alice,bob,sid_a)) ==> event(LeakS(px,bob)) && event(LeakM(px,bob)) is true.

Query attacker_p1(msg_a(alice,bob,sid_a)) ==> (event(LeakS(phase0,bob)) && event(LeakM(phase0,bob))) || (event(LeakS(px,bob)) && event(LeakM(px,bob)) && event(LeakS(pz,alice)) && event(LeakM(pz,alice))) cannot be proved.

Query attacker_p1(msg_a(alice,bob,sid_a)) ==> event(LeakS(phase0,bob)) && event(LeakM(phase0,bob)) cannot be proved.

Query event(RecvMsg(alice,bob,stagepack_b(sid_a),msg)) ==> event(SendMsg(bob,alice,stagepack_b(sid_b),msg)) is true.

Query event(RecvMsg(alice,bob,stagepack_b(sid_a),msg)) ==> event(SendMsg(bob,c,stagepack_b(sid_b),msg)) || (event(LeakS(phase0,bob)) && event(LeakM(phase0,bob))) || (event(LeakS(phase0,alice)) && event(LeakM(phase0,alice))) is true.

Query event(RecvMsg(alice,bob,stagepack_b(sid_a),msg)) ==> event(SendMsg(bob,c,stagepack_b(sid_b),msg)) || (event(LeakS(phase0,bob)) && event(LeakM(phase0,bob))) is true.

Query event(RecvMsg(alice,bob,stagepack_b(sid_a),msg)) ==> event(SendMsg(bob,alice,stagepack_b(sid_b),msg)) || (event(LeakS(phase0,bob)) && event(LeakM(phase0,bob))) || (event(LeakS(phase0,alice)) && event(LeakM(phase0,alice))) is true.

Query event(RecvMsg(alice,bob,stagepack_b(sid_a),msg)) ==> event(SendMsg(bob,alice,stagepack_b(sid_b),msg)) || (event(LeakS(phase0,bob)) && event(LeakM(phase0,bob))) is true.

Query not attacker_p1(msg_b(bob,alice,sid_b)) is true.

Query attacker_p1(msg_b(bob,alice,sid_b)) ==> event(LeakS(px,alice)) && event(LeakM(px,alice)) is true.

Query attacker_p1(msg_b(bob,alice,sid_b)) ==> (event(LeakS(phase0,alice)) && event(LeakM(phase0,alice))) || (event(LeakS(px,alice)) && event(LeakM(px,alice)) && event(LeakS(pz,bob)) && event(LeakM(pz,bob))) is true.

Query attacker_p1(msg_b(bob,alice,sid_b)) ==> event(LeakS(phase0,alice)) && event(LeakM(phase0,alice)) is true.

Query event(RecvMsg(bob,alice,stagepack_c(sid_b),msg)) ==> event(SendMsg(alice,bob,stagepack_c(sid_a),msg)) is true.

Query event(RecvMsg(bob,alice,stagepack_c(sid_b),msg)) ==> event(SendMsg(alice,c,stagepack_c(sid_a),msg)) || (event(LeakS(phase0,alice)) && event(LeakM(phase0,alice))) || (event(LeakS(phase0,bob)) && event(LeakM(phase0,bob))) is true.

Query event(RecvMsg(bob,alice,stagepack_c(sid_b),msg)) ==> event(SendMsg(alice,c,stagepack_c(sid_a),msg)) || (event(LeakS(phase0,alice)) && event(LeakM(phase0,alice))) is true.

Query event(RecvMsg(bob,alice,stagepack_c(sid_b),msg)) ==> event(SendMsg(alice,bob,stagepack_c(sid_a),msg)) || (event(LeakS(phase0,alice)) && event(LeakM(phase0,alice))) || (event(LeakS(phase0,bob)) && event(LeakM(phase0,bob))) is true.

Query event(RecvMsg(bob,alice,stagepack_c(sid_b),msg)) ==> event(SendMsg(alice,bob,stagepack_c(sid_a),msg)) || (event(LeakS(phase0,alice)) && event(LeakM(phase0,alice))) is true.

Query not attacker_p1(msg_c(alice,bob,sid_a)) is true.

Query attacker_p1(msg_c(alice,bob,sid_a)) ==> event(LeakS(px,bob)) && event(LeakM(px,bob)) is true.

Query attacker_p1(msg_c(alice,bob,sid_a)) ==> (event(LeakS(phase0,bob)) && event(LeakM(phase0,bob))) || (event(LeakS(px,bob)) && event(LeakM(px,bob)) && event(LeakS(pz,alice)) && event(LeakM(pz,alice))) is true.

Query attacker_p1(msg_c(alice,bob,sid_a)) ==> event(LeakS(phase0,bob)) && event(LeakM(phase0,bob)) is true.

Query event(RecvMsg(alice,bob,stagepack_d(sid_a),msg)) ==> event(SendMsg(bob,alice,stagepack_d(sid_b),msg)) is true.

Query event(RecvMsg(alice,bob,stagepack_d(sid_a),msg)) ==> event(SendMsg(bob,c,stagepack_d(sid_b),msg)) || (event(LeakS(phase0,bob)) && event(LeakM(phase0,bob))) || (event(LeakS(phase0,alice)) && event(LeakM(phase0,alice))) is true.

Query event(RecvMsg(alice,bob,stagepack_d(sid_a),msg)) ==> event(SendMsg(bob,c,stagepack_d(sid_b),msg)) || (event(LeakS(phase0,bob)) && event(LeakM(phase0,bob))) is true.

Query event(RecvMsg(alice,bob,stagepack_d(sid_a),msg)) ==> event(SendMsg(bob,alice,stagepack_d(sid_b),msg)) || (event(LeakS(phase0,bob)) && event(LeakM(phase0,bob))) || (event(LeakS(phase0,alice)) && event(LeakM(phase0,alice))) is true.

Query event(RecvMsg(alice,bob,stagepack_d(sid_a),msg)) ==> event(SendMsg(bob,alice,stagepack_d(sid_b),msg)) || (event(LeakS(phase0,bob)) && event(LeakM(phase0,bob))) is true.

Query not attacker_p1(msg_d(bob,alice,sid_b)) is true.

Query attacker_p1(msg_d(bob,alice,sid_b)) ==> event(LeakS(px,alice)) && event(LeakM(px,alice)) is true.

Query attacker_p1(msg_d(bob,alice,sid_b)) ==> (event(LeakS(phase0,alice)) && event(LeakM(phase0,alice))) || (event(LeakS(px,alice)) && event(LeakM(px,alice)) && event(LeakS(pz,bob)) && event(LeakM(pz,bob))) is true.

Query attacker_p1(msg_d(bob,alice,sid_b)) ==> event(LeakS(phase0,alice)) && event(LeakM(phase0,alice)) is true.

Query not event(RecvEnd(true)) is true.

--------------------------------------------------------------

